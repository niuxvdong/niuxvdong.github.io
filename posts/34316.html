<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>互联网分布式注册中心Zookeeper介绍 | 小牛博客</title><meta name="keywords" content="Zookeeper,注册中心,分布式锁"><meta name="author" content="ITNXD"><meta name="copyright" content="ITNXD"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="¶一、简介 ¶1、概述 Zookeeper 是一个开源的分布式的，为分布式框架提供协调服务的 Apache 项目。 ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 ¶2、工作机制 Zookeepe">
<meta property="og:type" content="article">
<meta property="og:title" content="互联网分布式注册中心Zookeeper介绍">
<meta property="og:url" content="https://www.itnxd.cn/posts/34316.html">
<meta property="og:site_name" content="小牛博客">
<meta property="og:description" content="¶一、简介 ¶1、概述 Zookeeper 是一个开源的分布式的，为分布式框架提供协调服务的 Apache 项目。 ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 ¶2、工作机制 Zookeepe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/niuxvdong/pic@be75530d6fedb428ff2e154f0aa823d6b754520e/2021/09/28/5efed5f7a5d8a6e858152e7c78b31007.png">
<meta property="article:published_time" content="2021-09-28T00:59:38.000Z">
<meta property="article:modified_time" content="2021-10-01T07:50:11.039Z">
<meta property="article:author" content="ITNXD">
<meta property="article:tag" content="Zookeeper">
<meta property="article:tag" content="注册中心">
<meta property="article:tag" content="分布式锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/niuxvdong/pic@be75530d6fedb428ff2e154f0aa823d6b754520e/2021/09/28/5efed5f7a5d8a6e858152e7c78b31007.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/favicon.ico"><link rel="canonical" href="https://www.itnxd.cn/posts/34316"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="H9LW1qdxrkJ55YbkfWulMvpaexxx3Rk0Yo6dVANeNHc"/><meta name="baidu-site-verification" content="code-YglH3DObCb"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8d3bd59bf6303bd5f44677445d369df5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":300,"languages":{"author":"作者: ITNXD","link":"链接: ","source":"来源: 小牛博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '互联网分布式注册中心Zookeeper介绍',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-01 15:50:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="/css/my.css"><style type="text/css">#toggle-sidebar {bottom: 80px}</style><link rel="stylesheet" href="//at.alicdn.com/t/font_1828588_zrw9f0qqie.css"><link rel="stylesheet" href="/self/atom-one-light.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="小牛博客" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@2f11f173da64ba6a270c2e93d23e00911b1019d3/2021/02/06/e373babbf340391956b673128a84185d.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">256</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">210</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/niuxvdong/pic@be75530d6fedb428ff2e154f0aa823d6b754520e/2021/09/28/5efed5f7a5d8a6e858152e7c78b31007.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小牛博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">互联网分布式注册中心Zookeeper介绍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-28T00:59:38.000Z" title="发表于 2021-09-28 08:59:38">2021-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-01T07:50:11.039Z" title="更新于 2021-10-01 15:50:11">2021-10-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1/">分布式微服务</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="互联网分布式注册中心Zookeeper介绍"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、简介"><a class="header-anchor" href="#一、简介">¶</a>一、简介</h1>
<h2 id="1、概述"><a class="header-anchor" href="#1、概述">¶</a>1、概述</h2>
<p>Zookeeper 是一个开源的分布式的，为分布式框架提供协调服务的 Apache 项目。</p>
<p>ZooKeeper是一个<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F/19276232">分布式</a>的，开放源码的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/9854429">分布式应用程序</a>协调服务，是<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/Google">Google</a>的Chubby一个<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E5%BC%80%E6%BA%90/246339">开源</a>的实现，是Hadoop和<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/Hbase/7670213">Hbase</a>的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<h2 id="2、工作机制"><a class="header-anchor" href="#2、工作机制">¶</a>2、工作机制</h2>
<p>Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责<strong>存储和管理大家都关心的数据</strong>，然后<strong>接受观察者的注册</strong>，一旦这些数据的状态发生变化，Zookeeper就将负责<strong>通知已经在Zookeeper上注册的那些观察者</strong>做出相应的反应。</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@d2ffb15fe689ebe549b384477d1aef7af89f4d5e/2021/09/28/61af91ab79f77f80bfc0366d646efb8c.png" alt=""></p>
<h2 id="3、特点"><a class="header-anchor" href="#3、特点">¶</a>3、特点</h2>
<ol>
<li>Zookeeper：<strong>一个领导者</strong>（Leader），多个跟随者（Follower）组成的集群。</li>
<li>集群中只要有<strong>半数以上</strong>节点存活，Zookeeper集群就能正常服务。所 以Zookeeper适合安装<strong>奇数台</strong>服务器。</li>
<li><strong>全局数据一致</strong>：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。</li>
<li><strong>更新请求顺序执行</strong>，来自同一个Client的更新请求按其发送顺序依次执行。</li>
<li><strong>数据更新原子性</strong>，一次数据更新要么成功，要么失败。</li>
<li><strong>实时性</strong>，在一定时间范围内，Client能读到最新数据。</li>
</ol>
<h2 id="4、数据结构"><a class="header-anchor" href="#4、数据结构">¶</a>4、数据结构</h2>
<p>ZooKeeper 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是一棵树，每个节点称做一个 ZNode。每一个 ZNode 默认能够存储 1MB 的数据，每个 ZNode 都可以通过其路径唯一标识。</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@8b5e83c764d1bb82ee4d9cd4638857a178a5e355/2021/09/28/d5e42c40a0d741e973660d2483ec7bd1.png" alt=""></p>
<h2 id="5、应用场景"><a class="header-anchor" href="#5、应用场景">¶</a>5、应用场景</h2>
<p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p>
<p><strong>统一命名服务：</strong></p>
<ul>
<li>在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。例如：IP不容易记住，而域名容易记住。</li>
</ul>
<p><strong>统一配置管理：</strong></p>
<ul>
<li>
<p>分布式环境下，配置文件同步非常常见。一般要求一个集群中，所有节点的配置信息是一致的，比如 Kafka 集群。对配置文件修改后，希望能够快速同步到各个节点上。</p>
</li>
<li>
<p>配置管理可交由ZooKeeper实现。可将配置信息写入ZooKeeper上的一个Znode。各个客户端服务器<strong>监听</strong>这个Znode。一旦Znode中的数据被修改ZooKeeper将通知各个客户端服务器。</p>
</li>
</ul>
<p><strong>统一集群管理：</strong></p>
<ul>
<li>分布式环境中，实时掌握每个节点的状态是必要的。可根据节点实时状态做出一些调整。</li>
<li>ZooKeeper可以实现实时监控节点状态变化。可将节点信息写入ZooKeeper上的一个ZNode。监听这个ZNode可获取它的实时状态变化。</li>
</ul>
<p><strong>服务器动态上下线：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@596aa6d5c46b56416d3397fe65a97654505fa8a8/2021/09/28/3a29034d6383f50e9b66a08b43a9ef6d.png" alt=""></p>
<p><strong>软负载均衡：</strong></p>
<p>在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求！</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@9f35e4cb3889a0977a28364e764650cfcfebbe63/2021/09/28/d9bcc4db25c42b2cf79243825bceb96a.png" alt=""></p>
<h1 id="二、安装"><a class="header-anchor" href="#二、安装">¶</a>二、安装</h1>
<blockquote>
<p>官网地址：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p>
</blockquote>
<h2 id="1、下载安装"><a class="header-anchor" href="#1、下载安装">¶</a>1、下载安装</h2>
<p><strong>前提：得有jdk环境！</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载</span><br>wget https://archive.apache.org/dist/zookeeper/zookeeper-3.5.7/apache-zookeeper-3.5.7-bin.tar.gz<br><span class="hljs-meta">#</span><span class="bash"> 解压</span><br>tar -zxvf apache-zookeeper-3.5.7-bin.tar.gz<br><span class="hljs-meta">#</span><span class="bash"> 改名</span><br>mv apache-zookeeper-3.5.7-bin/ zookeeper-3.5.7<br><span class="hljs-meta">#</span><span class="bash"> 拷贝一份配置文件</span><br>mv zoo_sample.cfg zoo.cfg<br><span class="hljs-meta">#</span><span class="bash"> 修改 dataDir 路径，改为 dataDir=/opt/zookeeper-3.5.7/zkData</span><br>vim zoo.cfg<br></code></pre></td></tr></tbody></table></figure>
<h2 id="2、常用命令"><a class="header-anchor" href="#2、常用命令">¶</a>2、常用命令</h2>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动服务端</span><br>./zkServer.sh start<br><span class="hljs-meta">#</span><span class="bash"> 停止服务端</span><br>./zkServer.sh stop<br><span class="hljs-meta">#</span><span class="bash"> 查看服务端状态</span><br>./zkServer.sh status<br><span class="hljs-meta">#</span><span class="bash"> 启动客户端</span><br>./zkCli.sh<br><span class="hljs-meta">#</span><span class="bash"> 退出客户端</span><br>quit<br><br><span class="hljs-meta">#</span><span class="bash"> 查看进程是否启动</span><br>jps<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3、配置文件介绍"><a class="header-anchor" href="#3、配置文件介绍">¶</a>3、配置文件介绍</h2>
<p><strong>zoo.cfg：</strong></p>
<ul>
<li>tickTime = 2000：通信心跳时间，Zookeeper服务器与客户端心跳时间，单位毫秒。</li>
<li>initLimit = 10：LF<strong>初始</strong>通信时限。Leader和Follower初始连接时能容忍的最多心跳数（tickTime的数量）。</li>
<li>syncLimit = 5：LF同步通信时限。Leader和Follower之间通信时间如果超过syncLimit * tickTime，Leader认为Follwer死掉，从服务器列表中删除Follwer。</li>
<li>dataDir：保存Zookeeper中的数据。注意：默认的tmp目录，容易被Linux系统定期删除，所以一般不用默认的tmp目录。</li>
<li>clientPort = 2181：客户端连接端口，通常不做修改。</li>
</ul>
<h1 id="三、集群操作"><a class="header-anchor" href="#三、集群操作">¶</a>三、集群操作</h1>
<h2 id="1、准备"><a class="header-anchor" href="#1、准备">¶</a>1、准备</h2>
<p>准备三台服务器，三台服务器同步操作！</p>
<p>在三台服务器上都安装jdk环境以及ZK！</p>
<p>或者在一台服务器上使用三个不同端口区分即可！只需要保证配置文件的<code>clientPort=2181</code>端口不冲突即可！(<strong>我们使用这种方法</strong>！)</p>
<h2 id="2、集群配置"><a class="header-anchor" href="#2、集群配置">¶</a>2、集群配置</h2>
<h3 id="配置服务器编号"><a class="header-anchor" href="#配置服务器编号">¶</a>配置服务器编号</h3>
<p><strong>三台机器同步操作：</strong></p>
<ol>
<li>在/opt/zookeeper-3.5.7/这个目录下创建 zkData 目录</li>
<li>在/opt/zookeeper-3.5.7/zkData 目录下创建一个 myid 的文件</li>
<li>在文件中添加与 server 对应的编号（唯一id）（注意：上下不要有空行，左右不要有空格）</li>
<li>三台服务器分别为1,2,3即可！</li>
</ol>
<h3 id="配置zoo-cfg文件"><a class="header-anchor" href="#配置zoo-cfg文件">¶</a>配置zoo.cfg文件</h3>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">修改数据存储路径配置</span><br>dataDir=/opt/zookeeper-3.5.7/zkData<br><span class="hljs-meta">#</span><span class="bash">最后增加如下配置</span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">######################cluster##########################</span></span><br>server.1=localhost:2881:3881<br>server.2=localhost:2882:3882<br>server.3=localhost:2883:3883<br></code></pre></td></tr></tbody></table></figure>
<p><code>server.A=B:C:D</code>：</p>
<ul>
<li>A 是一个数字，表示这个是第几号服务器；集群模式下配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面有一个数据就是 A 的值，Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个 server。</li>
<li>B 是这个服务器的地址；</li>
<li>C 是这个服务器 Follower 与集群中的 Leader 服务器交换信息的端口；</li>
<li>D 是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</li>
</ul>
<h2 id="3、集群操作"><a class="header-anchor" href="#3、集群操作">¶</a>3、集群操作</h2>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 同步启动三台</span><br>./zkServer.sh start<br><span class="hljs-meta">#</span><span class="bash"> 查看是leader还是follower，详细状态</span><br>./zkServer.sh status<br></code></pre></td></tr></tbody></table></figure>
<h2 id="4、选举机制"><a class="header-anchor" href="#4、选举机制">¶</a>4、选举机制</h2>
<p><strong>前提：以五台ZK，一个leader四个follower为例！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@8046ec31d068211b45d78a305f31273d8927893d/2021/09/28/1d8ff2069539acb2008ba9074d1d2295.png" alt=""></p>
<p><strong>第一次启动：</strong></p>
<ol>
<li>服务器1启动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成，服务器1状态保持为LOOKING；</li>
<li>服务器2启动，再发起一次选举。服务器1和2分别投自己一票并交换选票信息：此时服务器1发现服务器2的myid比自己目前投票推举的（服务器1）大，更改选票为推举服务器2。此时服务器1票数0票，服务器2票数2票，没有半数以上结果，选举无法完成，服务器1，2状态保持LOOKING</li>
<li>服务器3启动，发起一次选举。此时服务器1和2都会更改选票为服务器3。此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数，服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；</li>
<li>服务器4启动，发起一次选举。此时服务器1，2，3已经不是LOOKING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING；</li>
<li>服务器5启动，同4一样当小弟。</li>
</ol>
<p><strong>非第一次启动：</strong></p>
<ol>
<li>当ZooKeeper集群中的一台服务器出现以下两种情况之一时，就会开始进入Leader选举：
<ol>
<li>服务器初始化启动。</li>
<li>服务器运行期间无法和Leader保持连接。</li>
</ol>
</li>
<li>而当一台机器进入Leader选举流程时，当前集群也可能会处于以下两种状态：
<ol>
<li>集群中本来就已经存在一个Leader。对于第一种已经存在Leader的情况，机器试图去选举Leader时，会被告知当前服务器的Leader信息，对于该机器来说，仅仅需要和Leader机器建立连接，并进行状态同步即可。</li>
<li>集群中确实不存在Leader。
<ol>
<li>假设ZooKeeper由5台服务器组成，SID分别为1、2、3、4、5，ZXID分别为8、8、8、7、7，并且此时SID为3的服务器是Leader。某一时刻，3和5服务器出现故障，因此开始进行Leader选举。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>选举情况：</strong></p>
<p>（EPOCH，ZXID，SID ）<br>
SID为1、2、4的机器投票情况： （1，8，1） （1，8，2） （1，7，4）</p>
<p><strong>选举Leader规则：</strong></p>
<ol>
<li>EPOCH大的直接胜出</li>
<li>EPOCH相同，事务id大的胜出</li>
<li>事务id相同，服务器id大的胜出</li>
</ol>
<p><strong>三个id：</strong></p>
<ul>
<li>SID：<strong>服务器ID</strong>。用来唯一标识一台ZooKeeper集群中的机器，每台机器不能重复，和myid一致。</li>
<li>ZXID：<strong>事务ID</strong>。ZXID是一个事务ID，用来标识一次服务器状态的变更。在某一时刻，集群中的每台机器的ZXID值不一定完全一致，这和ZooKeeper服务器对于客户端“更新请求”的处理逻辑有关。</li>
<li>Epoch：<strong>每个Leader任期的代号</strong>。没有Leader时同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加</li>
</ul>
<h2 id="5、集群命令"><a class="header-anchor" href="#5、集群命令">¶</a>5、集群命令</h2>
<p>help：显示所有操作命令</p>
<p>ls path：使用 ls 命令来查看当前 znode 的子节点 [可监听]</p>
<ul>
<li>-w 监听子节点变化</li>
<li>-s 附加次级信息</li>
</ul>
<p>create：普通创建</p>
<ul>
<li>-s 含有序列</li>
<li>-e 临时（重启或者超时消失）</li>
</ul>
<p>get path：获得节点的值 [可监听]</p>
<ul>
<li>
<p>-w 监听节点内容变化</p>
</li>
<li>
<p>-s 附加次级信息</p>
</li>
</ul>
<p>set：设置节点的具体值</p>
<p>stat：查看节点状态</p>
<p>delete：删除节点</p>
<p>deleteall：递归删除节点</p>
<p><strong>节点删除和查看状态：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1）删除节点</span><br>[zk: localhost:2181(CONNECTED) 4] delete /sanguo/jin<br><span class="hljs-meta">#</span><span class="bash"> 2）递归删除节点</span><br>[zk: localhost:2181(CONNECTED) 15] deleteall /sanguo/shuguo<br><span class="hljs-meta">#</span><span class="bash"> 3）查看节点状态</span><br>[zk: localhost:2181(CONNECTED) 17] stat /sanguo<br>cZxid = 0x100000003<br>ctime = Wed Aug 29 00:03:23 CST 2018<br>mZxid = 0x100000011<br>mtime = Wed Aug 29 00:21:23 CST 2018<br>pZxid = 0x100000014<br>cversion = 9<br>dataVersion = 1<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 4<br>numChildren = 1<br></code></pre></td></tr></tbody></table></figure>
<p><strong>ls -s介绍：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 5] ls -s /<br>[zookeeper]cZxid = 0x0<br>ctime = Thu Jan 01 08:00:00 CST 1970<br>mZxid = 0x0<br>mtime = Thu Jan 01 08:00:00 CST 1970<br>pZxid = 0x0<br>cversion = -1<br>dataVersion = 0<br>aclVersion = 0<br>ephemeralOwner = 0x0<br>dataLength = 0<br>numChildren = 1<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>czxid</strong>：创建节点的事务 zxid。
<ul>
<li>每次修改 ZooKeeper 状态都会产生一个 ZooKeeper 事务 ID。事务 ID 是 ZooKeeper 中所有修改总的次序。每次修改都有唯一的 zxid，如果 zxid1 小于 zxid2，那么 zxid1 在 zxid2 之前发生。</li>
</ul>
</li>
<li>ctime：znode 被创建的毫秒数（从 1970 年开始）</li>
<li>mzxid：znode 最后更新的事务 zxid</li>
<li>mtime：znode 最后修改的毫秒数（从 1970 年开始）</li>
<li>pZxid：znode 最后更新的子节点 zxid</li>
<li>cversion：znode 子节点变化号，znode 子节点修改次数</li>
<li>dataversion：znode 数据变化号</li>
<li>aclVersion：znode 访问控制列表的变化号</li>
<li>ephemeralOwner：如果是临时节点，这个是 znode 拥有者的 session id。如果不是临时节点则是 0。</li>
<li>dataLength：znode 的数据长度</li>
<li>numChildren：znode 子节点数量</li>
</ul>
<h2 id="6、节点类型"><a class="header-anchor" href="#6、节点类型">¶</a>6、节点类型</h2>
<p>持久（Persistent）：客户端和服务器端断开连接后，创建的节点不删除</p>
<p>短暂（Ephemeral）：客户端和服务器端断开连接后，创建的节点自己删除</p>
<ol>
<li>持久化目录节点：客户端与Zookeeper断开连接后，该节点依旧存在。</li>
<li>持久化顺序编号目录节点：客户端与Zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号。</li>
<li>临时目录节点：客户端与Zookeeper断开连接后，该节点被删除。</li>
<li>临时顺序编号目录节点：客户端与 Zookeeper 断开连接后，该 节 点 被 删 除，只是Zookeeper给该节点名称进行顺序编号。</li>
</ol>
<p><strong>说明</strong>：创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护！</p>
<p><strong>注意</strong>：在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序！</p>
<p><strong>示例：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 持久无序号节点</span><br>create /sanguo "diaochan"<br>create /sanguo/shuguo "liubei"<br><br><span class="hljs-meta">#</span><span class="bash"> 获取节点信息</span><br>get -s /sanguo<br><br><span class="hljs-meta">#</span><span class="bash"> 持久带序号节点 如果原来没有序号节点，序号从 0 开始依次递增。如果原节点下已有 2 个节点，则再排序时从 2 开始，以此类推。</span><br>[zk: localhost:2181(CONNECTED) 2] create -s /sanguo/weiguo/zhangliao "zhangliao"<br>Created /sanguo/weiguo/zhangliao0000000000<br>[zk: localhost:2181(CONNECTED) 3] create -s /sanguo/weiguo/zhangliao "zhangliao"<br>Created /sanguo/weiguo/zhangliao0000000001<br>[zk: localhost:2181(CONNECTED) 4] create -s /sanguo/weiguo/xuchu "xuchu"<br>Created /sanguo/weiguo/xuchu0000000002<br><br><span class="hljs-meta">#</span><span class="bash"> 短暂无序号节点</span><br>create -e /sanguo/wuguo "zhouyu"<br><br><span class="hljs-meta">#</span><span class="bash"> 短暂带序号节点</span><br>create -e -s /sanguo/wuguo "zhouyu"<br><br><span class="hljs-meta">#</span><span class="bash"> 退出客户端</span><br>quit<br><br><span class="hljs-meta">#</span><span class="bash"> 修改节点值</span><br>set /sanguo/weiguo "simayi"<br></code></pre></td></tr></tbody></table></figure>
<h2 id="7、监听器"><a class="header-anchor" href="#7、监听器">¶</a>7、监听器</h2>
<h3 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h3>
<p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、节点删除、子目录节点增加删除）时，ZooKeeper 会通知客户端。监听机制保证 ZooKeeper 保存的任何的数据的任何改变都能快速的响应到监听了该节点的应用程序。</p>
<h3 id="监听器原理"><a class="header-anchor" href="#监听器原理">¶</a>监听器原理</h3>
<p><strong>流程：</strong></p>
<ol>
<li>首先要有一个main()线程</li>
<li>在main线程中创建Zookeeper客户端，这时就会创建两个线程，一个负责网络连接通信（connet），一个负责监听（listener）。</li>
<li>通过connect线程将注册的监听事件发送给Zookeeper。</li>
<li>在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中。</li>
<li>Zookeeper监听到有数据或路径变化，就会将这个消息发送给listener线程。</li>
<li>listener线程内部调用了process()方法。</li>
</ol>
<p><strong>常见监听：</strong></p>
<ul>
<li>监听节点数据的变化：get path [watch]</li>
<li>监听子节点增减的变化：ls path [watch]</li>
</ul>
<p><strong>图示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@6f06d4bcb68c76a20ff3fbaf05c337c6e1ccb045/2021/09/28/9d19f5d452c962f893c0f3cebc50fcf7.png" alt=""></p>
<h3 id="监听案例"><a class="header-anchor" href="#监听案例">¶</a>监听案例</h3>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">------------------ 节点值变化监听----------------------</span><br><span class="hljs-meta">#</span><span class="bash">（1）在 104 主机上注册监听/sanguo 节点数据变化</span><br>[zk: localhost:2181(CONNECTED) 26] get -w /sanguo <br><span class="hljs-meta">#</span><span class="bash">（2）在 103 主机上修改/sanguo 节点的数据</span><br>[zk: localhost:2181(CONNECTED) 1] set /sanguo "xisi"<br><span class="hljs-meta">#</span><span class="bash">（3）观察 104 主机收到数据变化的监听</span><br>WATCHER::<br>WatchedEvent state:SyncConnected type:NodeDataChanged <br>path:/sanguo<br><span class="hljs-meta">#</span><span class="bash"> 注意：在103再多次修改/sanguo的值，104上不会再收到监听。因为注册一次，只能监听一次。想再次监听，需要再次注册。</span><br><br><span class="hljs-meta">#</span><span class="bash">------------------ 节点的子节点变化监听（路径变化）----------</span><br><span class="hljs-meta">#</span><span class="bash">（1）在 104 主机上注册监听/sanguo 节点的子节点变化</span><br>[zk: localhost:2181(CONNECTED) 1] ls -w /sanguo<br>[shuguo, weiguo]<br><span class="hljs-meta">#</span><span class="bash">（2）在 103 主机/sanguo 节点上创建子节点</span><br>[zk: localhost:2181(CONNECTED) 2] create /sanguo/jin "simayi"<br>Created /sanguo/jin<br><span class="hljs-meta">#</span><span class="bash">（3）观察 104 主机收到子节点变化的监听</span><br>WATCHER::<br>WatchedEvent state:SyncConnected type:NodeChildrenChanged <br>path:/sanguo<br><span class="hljs-meta">#</span><span class="bash"> 注意：节点的路径变化，也是注册一次，生效一次。想多次生效，就需要多次注册。</span><br></code></pre></td></tr></tbody></table></figure>
<h1 id="四、客户端API操作"><a class="header-anchor" href="#四、客户端API操作">¶</a>四、客户端API操作</h1>
<h2 id="1、IDEA环境搭建"><a class="header-anchor" href="#1、IDEA环境搭建">¶</a>1、IDEA环境搭建</h2>
<h3 id="pom-xml"><a class="header-anchor" href="#pom-xml">¶</a>pom.xml</h3>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="log4j-properties"><a class="header-anchor" href="#log4j-properties">¶</a>log4j.properties</h3>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">INFO, stdout</span><br><span class="hljs-meta">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">%d %p [%c] - %m%n</span><br><span class="hljs-meta">log4j.appender.logfile</span>=<span class="hljs-string">org.apache.log4j.FileAppender</span><br><span class="hljs-meta">log4j.appender.logfile.File</span>=<span class="hljs-string">target/spring.log</span><br><span class="hljs-meta">log4j.appender.logfile.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.logfile.layout.ConversionPattern</span>=<span class="hljs-string">%d %p [%c] - %m%n</span><br></code></pre></td></tr></tbody></table></figure>
<h2 id="2、API操作"><a class="header-anchor" href="#2、API操作">¶</a>2、API操作</h2>
<p><strong>zkClient.java：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itnxd.zk;<br><br><span class="hljs-keyword">import</span> org.apache.zookeeper.*;<br><span class="hljs-keyword">import</span> org.apache.zookeeper.data.Stat;<br><span class="hljs-keyword">import</span> org.junit.Before;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-09-27 16:07</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkClient</span> </span>{<br><br>    <span class="hljs-keyword">private</span> ZooKeeper zkClient = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sessionTimeout = <span class="hljs-number">2000</span>;<br>    <span class="hljs-comment">// zk集群多台时逗号分隔，且不能有空格！</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String connectString = <span class="hljs-string">"82.156.11.189:2181,82.156.11.189:2182,82.156.11.189:2183"</span>;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        zkClient = <span class="hljs-keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="hljs-keyword">new</span> Watcher() {<br><br>            <span class="hljs-comment">// 收到事件通知的回调函数，有变化就会执行一次！</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>{<br><br>                System.out.println(<span class="hljs-string">"**************************************"</span>);<br>                List&lt;String&gt; children = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> {<br>                    children = zkClient.getChildren(<span class="hljs-string">"/"</span>, <span class="hljs-keyword">true</span>);<br>                    <span class="hljs-keyword">for</span> (String child : children) {<br>                        System.out.println(child);<br>                    }<br>                } <span class="hljs-keyword">catch</span> (Exception e){<br>                    e.printStackTrace();<br>                }<br>            }<br>        });<br>    }<br><br>    <span class="hljs-meta">@Test()</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>{<br><br>        <span class="hljs-comment">/* OPEN_ACL_UNSAFE表示任何人都可访问，权限控制</span><br><span class="hljs-comment">            CreateMode.PERSISTENT：为四大类型之一，临时/永久/带序号/不带序号</span><br><span class="hljs-comment">         */</span><br>        String node = zkClient.create(<span class="hljs-string">"/atguigu"</span>, <span class="hljs-string">"ss.avi"</span>.getBytes(),<br>                ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br><br>    }<br><br>    <span class="hljs-comment">// 获取子节点，动态监听</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getChildren</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 监听路径  true表示走初始化的watcher</span><br>        List&lt;String&gt; children = zkClient.getChildren(<span class="hljs-string">"/"</span>, <span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">for</span> (String child : children) {<br>            System.out.println(child);<br>        }<br>        <span class="hljs-comment">// 延时阻塞</span><br>        Thread.sleep(Long.MAX_VALUE);<br>    }<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exist</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        Stat stat = zkClient.exists(<span class="hljs-string">"/atguigu"</span>, <span class="hljs-keyword">false</span>);<br>        System.out.println(stat == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"not exist"</span> : <span class="hljs-string">"exist"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3、客户端写数据流程"><a class="header-anchor" href="#3、客户端写数据流程">¶</a>3、客户端写数据流程</h2>
<p><strong>写流程之写入请求直接发送给Leader节点：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@af1e23da70c69d7ea71be735dd5297fcf52898a3/2021/09/28/25022a9ebba91591add21ae15e402f4a.png" alt=""></p>
<p><strong>写流程之写入请求发送给follower节点：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@70f08fe8ad160a9d4bb84ff5e33dc279a8e92f92/2021/09/28/da6d6675b57534e34e8920831cf1aedb.png" alt=""></p>
<h1 id="五、服务器动态上下线监听案例"><a class="header-anchor" href="#五、服务器动态上下线监听案例">¶</a>五、服务器动态上下线监听案例</h1>
<h2 id="1、需求分析"><a class="header-anchor" href="#1、需求分析">¶</a>1、需求分析</h2>
<p>某分布式系统中，主节点可以有多台，可以动态上下线，任意一台客户端都能实时感知到主节点服务器的上下线。</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@731af641d1f07987cf090530d0fcae5e3507bcb6/2021/09/28/9bf5fadbbc764b2c0bb54a6bbe62e932.png" alt=""></p>
<h2 id="2、具体实现"><a class="header-anchor" href="#2、具体实现">¶</a>2、具体实现</h2>
<ul>
<li>先在集群上创建/servers 节点 <code>create /servers "servers"</code></li>
</ul>
<p><strong>服务器代码：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itnxd.case1;<br><br><span class="hljs-keyword">import</span> org.apache.zookeeper.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-09-27 17:11</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistributeServer</span> </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String connectString = <span class="hljs-string">"82.156.11.189:2181,82.156.11.189:2182,82.156.11.189:2183"</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sessionTimeout = <span class="hljs-number">2000</span>;<br>    <span class="hljs-keyword">private</span> ZooKeeper zk = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 创建到 zk 的客户端连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getConnect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        zk = <span class="hljs-keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="hljs-keyword">new</span> Watcher() {<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>{<br>                    }<br>                });<br>    }<br><br>    <span class="hljs-comment">// 注册服务器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registServer</span><span class="hljs-params">(String hostname)</span> <span class="hljs-keyword">throws</span> Exception</span>{<br>        <span class="hljs-comment">// 节点类型：临时的有序的</span><br>        String create = zk.create(<span class="hljs-string">"/servers/"</span> + hostname,<br>                hostname.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,<br>                CreateMode.EPHEMERAL_SEQUENTIAL);<br>        <span class="hljs-comment">// 控制台打印上线通知</span><br>        System.out.println(hostname +<span class="hljs-string">" is online "</span>+ create);<br>    }<br><br>    <span class="hljs-comment">// 业务功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">business</span><span class="hljs-params">(String hostname)</span> <span class="hljs-keyword">throws</span> Exception</span>{<br>        <span class="hljs-comment">// 睡眠！</span><br>        System.out.println(hostname + <span class="hljs-string">" is working ..."</span>);<br>        Thread.sleep(Long.MAX_VALUE);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 1 获取 zk 连接</span><br>        DistributeServer server = <span class="hljs-keyword">new</span> DistributeServer();<br>        server.getConnect();<br>        <span class="hljs-comment">// 2 利用 zk 连接注册服务器信息</span><br>        server.registServer(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 3 启动业务功能</span><br>        server.business(args[<span class="hljs-number">0</span>]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>客户端代码：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itnxd.case1;<br><br><span class="hljs-keyword">import</span> org.apache.zookeeper.WatchedEvent;<br><span class="hljs-keyword">import</span> org.apache.zookeeper.Watcher;<br><span class="hljs-keyword">import</span> org.apache.zookeeper.ZooKeeper;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-09-27 17:27</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistributeClient</span> </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String connectString = <span class="hljs-string">"82.156.11.189:2181,82.156.11.189:2182,82.156.11.189:2183"</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sessionTimeout = <span class="hljs-number">2000</span>;<br>    <span class="hljs-keyword">private</span> ZooKeeper zk = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> String parentNode = <span class="hljs-string">"/servers"</span>;<br><br>    <span class="hljs-comment">// 创建到 zk 的客户端连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getConnect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        zk = <span class="hljs-keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="hljs-keyword">new</span> Watcher() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>{<br>                <span class="hljs-comment">// 再次启动监听</span><br>                <span class="hljs-keyword">try</span> {<br>                    getServerList();<br>                } <span class="hljs-keyword">catch</span> (Exception e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        });<br>    }<br><br>    <span class="hljs-comment">// 获取服务器列表信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getServerList</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 1 获取服务器子节点信息，并且对父节点进行监听</span><br>        List&lt;String&gt; children = zk.getChildren(parentNode, <span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 2 存储服务器信息列表</span><br>        ArrayList&lt;String&gt; servers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 3 遍历所有节点，获取节点中的主机名称信息</span><br>        <span class="hljs-keyword">for</span> (String child : children) {<br>            <span class="hljs-keyword">byte</span>[] data = zk.getData(parentNode + <span class="hljs-string">"/servers/"</span> + child, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>            servers.add(<span class="hljs-keyword">new</span> String(data));<br>        }<br>        <span class="hljs-comment">// 4 打印服务器列表信息</span><br>        System.out.println(servers);<br>    }<br><br>    <span class="hljs-comment">// 业务功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">business</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>{<br>        System.out.println(<span class="hljs-string">"client is working ..."</span>);<br>        Thread.sleep(Long.MAX_VALUE);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 1 获取 zk 连接</span><br>        DistributeClient client = <span class="hljs-keyword">new</span> DistributeClient();<br>        client.getConnect();<br>        <span class="hljs-comment">// 2 获取 servers 的子节点信息，从中获取服务器信息列表</span><br>        client.getServerList();<br>        <span class="hljs-comment">// 3 业务进程启动</span><br>        client.business();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3、测试"><a class="header-anchor" href="#3、测试">¶</a>3、测试</h2>
<p><strong>1、在 Linux 命令行上操作增加减少服务器</strong></p>
<ul>
<li>
<p>启动 DistributeClient 客户端</p>
</li>
<li>
<p>在 hadoop102 上 zk 的客户端/servers 目录上创建临时带序号节点</p>
</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 1] create -e -s /servers/hadoop102 "hadoop102"<br>[zk: localhost:2181(CONNECTED) 2] create -e -s /servers/hadoop103 "hadoop103"<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>观察 Idea 控制台变化</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[hadoop102, hadoop103]<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>执行删除操作</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[zk: localhost:2181(CONNECTED) 8] delete /servers/hadoop1020000000000<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>观察 Idea 控制台变化</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[hadoop103]<br></code></pre></td></tr></tbody></table></figure>
<p><strong>2、在 Idea 上操作增加减少服务器</strong></p>
<ul>
<li>启动 DistributeClient 客户端（如果已经启动过，不需要重启）</li>
<li>启动 DistributeServer 服务端</li>
<li>点击 Edit Configurations…，在弹出的窗口中（Program arguments）输入想启动的主机，例如，82.156.11.189:2182</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@f53b3f9736bab056f161ee07f35b6fd6cb08f882/2021/09/28/e800f92a3319b669f3800c4a87c97d20.png" alt=""></p>
<ul>
<li>回到 DistributeServer 的 main 方 法，右键运行</li>
<li>观察 DistributeServer 控制台，提示82.156.11.189:2182 is working</li>
<li>观察 DistributeClient 控制台，提示82.82.156.11.189:2182 已经上线</li>
</ul>
<h1 id="六、分布式锁案例"><a class="header-anchor" href="#六、分布式锁案例">¶</a>六、分布式锁案例</h1>
<h2 id="1、需求分析-2"><a class="header-anchor" href="#1、需求分析-2">¶</a>1、需求分析</h2>
<p><strong>什么叫做分布式锁呢？</strong></p>
<p>比如说"进程 1"在使用该资源的时候，会先去获得锁，"进程 1"获得锁以后会对该资源保持独占，这样其他进程就无法访问该资源，"进程 1"用完该资源以后就将锁释放掉，让其他进程来获得锁，那么通过这个锁机制，我们就能保证了分布式系统中多个进程能够有序的访问该临界资源。那么我们把这个分布式环境下的这个锁叫作分布式锁。</p>
<p><strong>分布式锁分析：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@942a46e95b763dcb9c44031dff5b5ec91126bbe2/2021/09/28/4406c85d0d47d70cea7a07f4347253d0.png" alt=""></p>
<h2 id="2、具体实现-2"><a class="header-anchor" href="#2、具体实现-2">¶</a>2、具体实现</h2>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itnxd.case2;<br><br><span class="hljs-keyword">import</span> org.apache.zookeeper.*;<br><span class="hljs-keyword">import</span> org.apache.zookeeper.data.Stat;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-09-27 17:51</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistributedLock</span> </span>{<br><br>    <span class="hljs-comment">// zookeeper server 列表</span><br>    <span class="hljs-keyword">private</span> String connectString = <span class="hljs-string">"82.156.11.189:2181,82.156.11.189:2182,82.156.11.189:2183"</span>;<br>    <span class="hljs-comment">// 超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sessionTimeout = <span class="hljs-number">2000</span>;<br>    <span class="hljs-keyword">private</span> ZooKeeper zk;<br>    <span class="hljs-keyword">private</span> String rootNode = <span class="hljs-string">"locks"</span>;<br>    <span class="hljs-keyword">private</span> String subNode = <span class="hljs-string">"seq-"</span>;<br>    <span class="hljs-comment">// 当前 client 等待的子节点</span><br>    <span class="hljs-keyword">private</span> String waitPath;<br>    <span class="hljs-comment">//ZooKeeper 连接</span><br>    <span class="hljs-keyword">private</span> CountDownLatch connectLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//ZooKeeper 节点等待</span><br>    <span class="hljs-keyword">private</span> CountDownLatch waitLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 当前 client 创建的子节点</span><br>    <span class="hljs-keyword">private</span> String currentNode;<br>    <span class="hljs-comment">// 和 zk 服务建立连接，并创建根节点</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DistributedLock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, KeeperException </span>{<br><br>        zk = <span class="hljs-keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="hljs-keyword">new</span> Watcher() {<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>{<br>                        <span class="hljs-comment">// 连接建立时, 打开 latch, 唤醒 wait 在该 latch 上的线程</span><br>                        <span class="hljs-keyword">if</span> (event.getState() == Event.KeeperState.SyncConnected) {<br>                            connectLatch.countDown();<br>                        }<br>                        <span class="hljs-comment">// 发生了 waitPath 的删除事件</span><br>                        <span class="hljs-keyword">if</span> (event.getType() ==<br>                                Event.EventType.NodeDeleted &amp;&amp; event.getPath().equals(waitPath))<br>                        {<br>                            waitLatch.countDown();<br>                        }<br>                    }<br>                });<br>        <span class="hljs-comment">// 等待连接建立</span><br>        connectLatch.await();<br>        <span class="hljs-comment">//获取根节点状态</span><br>        Stat stat = zk.exists(<span class="hljs-string">"/"</span> + rootNode, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">//如果根节点不存在，则创建根节点，根节点类型为永久节点</span><br>        <span class="hljs-keyword">if</span> (stat == <span class="hljs-keyword">null</span>) {<br>            System.out.println(<span class="hljs-string">"根节点不存在"</span>);<br>            zk.create(<span class="hljs-string">"/"</span> + rootNode, <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>],<br>                    ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>        }<br>    }<br>    <span class="hljs-comment">// 加锁方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zkLock</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">//在根节点下创建临时顺序节点，返回值为创建的节点路径</span><br>            currentNode = zk.create(<span class="hljs-string">"/"</span> + rootNode + <span class="hljs-string">"/"</span> + subNode,<br>                    <span class="hljs-keyword">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE,<br>                    CreateMode.EPHEMERAL_SEQUENTIAL);<br>            <span class="hljs-comment">// wait 一小会, 让结果更清晰一些</span><br>            Thread.sleep(<span class="hljs-number">10</span>);<br>            <span class="hljs-comment">// 注意, 没有必要监听"/locks"的子节点的变化情况</span><br>            List&lt;String&gt; childrenNodes = zk.getChildren(<span class="hljs-string">"/"</span> +<br>                    rootNode, <span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 列表中只有一个子节点, 那肯定就是 currentNode , 说明client 获得锁</span><br>            <span class="hljs-keyword">if</span> (childrenNodes.size() == <span class="hljs-number">1</span>) {<br>                <span class="hljs-keyword">return</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-comment">//对根节点下的所有临时顺序节点进行从小到大排序</span><br>                Collections.sort(childrenNodes);<br>                <span class="hljs-comment">//当前节点名称</span><br>                String thisNode = currentNode.substring((<span class="hljs-string">"/"</span> +<br>                        rootNode + <span class="hljs-string">"/"</span>).length());<br>                <span class="hljs-comment">//获取当前节点的位置</span><br>                <span class="hljs-keyword">int</span> index = childrenNodes.indexOf(thisNode);<br>                <span class="hljs-keyword">if</span> (index == -<span class="hljs-number">1</span>) {<br>                    System.out.println(<span class="hljs-string">"数据异常"</span>);<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) {<br>                    <span class="hljs-comment">// index == 0, 说明 thisNode 在列表中最小, 当前client 获得锁</span><br>                    <span class="hljs-keyword">return</span>;<br>                } <span class="hljs-keyword">else</span> {<br>                    <span class="hljs-comment">// 获得排名比 currentNode 前 1 位的节点</span><br>                    <span class="hljs-keyword">this</span>.waitPath = <span class="hljs-string">"/"</span> + rootNode + <span class="hljs-string">"/"</span> +<br>                            childrenNodes.get(index - <span class="hljs-number">1</span>);<br>                    <span class="hljs-comment">// 在 waitPath 上注册监听器, 当 waitPath 被删除时,zookeeper 会回调监听器的 process 方法</span><br>                    zk.getData(waitPath, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> Stat());<br>                    <span class="hljs-comment">//进入等待锁状态</span><br>                    waitLatch.await();<br>                    <span class="hljs-keyword">return</span>;<br>                }<br>            }<br>        } <span class="hljs-keyword">catch</span> (KeeperException e) {<br>            e.printStackTrace();<br>        } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>    <span class="hljs-comment">// 解锁方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zkUnlock</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">try</span> {<br>            zk.delete(<span class="hljs-keyword">this</span>.currentNode, -<span class="hljs-number">1</span>);<br>        } <span class="hljs-keyword">catch</span> (InterruptedException | KeeperException e) {<br>            e.printStackTrace();<br>        }<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3、测试-2"><a class="header-anchor" href="#3、测试-2">¶</a>3、测试</h2>
<p><strong>两个线程测试：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itnxd.case2;<br><br><span class="hljs-keyword">import</span> org.apache.zookeeper.KeeperException;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-09-27 20:04</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistributeLockTest</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException, KeeperException </span>{<br><br>        <span class="hljs-comment">// 创建分布式锁 1</span><br>        <span class="hljs-keyword">final</span> DistributedLock lock1 = <span class="hljs-keyword">new</span> DistributedLock();<br>        <span class="hljs-comment">// 创建分布式锁 2</span><br>        <span class="hljs-keyword">final</span> DistributedLock lock2 = <span class="hljs-keyword">new</span> DistributedLock();<br><br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                <span class="hljs-comment">// 获取锁对象</span><br>                <span class="hljs-keyword">try</span> {<br>                    lock1.zkLock();<br>                    System.out.println(<span class="hljs-string">"线程 1 获取锁"</span>);<br>                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);<br>                    lock1.zkUnlock();<br>                    System.out.println(<span class="hljs-string">"线程 1 释放锁"</span>);<br>                } <span class="hljs-keyword">catch</span> (Exception e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        }).start();<br><br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                <span class="hljs-comment">// 获取锁对象</span><br>                <span class="hljs-keyword">try</span> {<br>                    lock2.zkLock();<br>                    System.out.println(<span class="hljs-string">"线程 2 获取锁"</span>);<br>                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);<br>                    lock2.zkUnlock();<br>                    System.out.println(<span class="hljs-string">"线程 2 释放锁"</span>);<br>                } <span class="hljs-keyword">catch</span> (Exception e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        }).start();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>观察控制台变化：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">线程 1 获取锁<br>线程 1 释放锁<br>线程 2 获取锁<br>线程 2 释放锁<br></code></pre></td></tr></tbody></table></figure>
<h1 id="七、Curator-框架"><a class="header-anchor" href="#七、Curator-框架">¶</a>七、Curator 框架</h1>
<h2 id="1、简介"><a class="header-anchor" href="#1、简介">¶</a>1、简介</h2>
<p><strong>原生的 Java API 开发存在的问题？</strong></p>
<ul>
<li>
<p>会话连接是异步的，需要自己去处理。比如使用 CountDownLatch</p>
</li>
<li>
<p>Watch 需要重复注册，不然就不能生效</p>
</li>
<li>
<p>开发的复杂性还是比较高的</p>
</li>
<li>
<p>不支持多节点删除和创建。需要自己去递归</p>
</li>
</ul>
<p>Curator 是一个专门解决分布式锁的框架，解决了原生 JavaAPI 开发分布式遇到的问题。</p>
<p>详情请查看官方文档：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://curator.apache.org/index.html">https://curator.apache.org/index.html</a></p>
<h2 id="2、依赖"><a class="header-anchor" href="#2、依赖">¶</a>2、依赖</h2>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>
<h2 id="3、创建连接"><a class="header-anchor" href="#3、创建连接">¶</a>3、创建连接</h2>
<p><strong>创建连接的两种方式：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-comment">//1. 定义重试策略</span><br>    <span class="hljs-comment">// 重试时间 重试次数</span><br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">3000</span>,<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">//2. 创建CuratorFramework接口的对象</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> connectString       String类型的ZK服务器的地址:端口，多个使用逗号隔开</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sessionTimeoutMs    int类型会话超时时间，单位ms，默认60 * 1000，可省略</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> connectionTimeoutMs int类型的连接超时时间，单位ms，默认15 * 1000，可省略</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> retryPolicy         重试策略的对象</span><br><span class="hljs-comment">     */</span><br>    CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="hljs-string">"82.156.11.189:2181,82.156.11.189:2182,82.156.11.189:2183"</span>,retryPolicy);<br><br>    <span class="hljs-comment">//3. 开启连接</span><br>    client.start();<br>    <span class="hljs-comment">//client.close()关闭连接</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-comment">//1. 定义重试策略</span><br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">3000</span>,<span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">//2. 创建CuratorFramework接口的对象</span><br>    CuratorFramework client = CuratorFrameworkFactory.builder()<br>        .connectString(<span class="hljs-string">"82.156.11.189:2181,82.156.11.189:2182,82.156.11.189:2183"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">15</span> * <span class="hljs-number">1000</span>)<br>        .retryPolicy(retryPolicy)<br>        .namespace(<span class="hljs-string">"test"</span>) <span class="hljs-comment">//名称空间，所有节点的路径之前都包含/test，简化开发，可以不使用</span><br>        .build();<br><br>    <span class="hljs-comment">//3. 开启连接</span><br>    client.start();<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="4、增删改查"><a class="header-anchor" href="#4、增删改查">¶</a>4、增删改查</h2>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>    <br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">3000</span>,<span class="hljs-number">10</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder()<br>            .connectString(<span class="hljs-string">"82.156.11.189:2181,82.156.11.189:2182,82.156.11.189:2183"</span>)<br>            .sessionTimeoutMs(<span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)<br>            .connectionTimeoutMs(<span class="hljs-number">15</span> * <span class="hljs-number">1000</span>)<br>            .retryPolicy(retryPolicy)<br>            .build();<br>    client.start();<br><br>    <span class="hljs-comment">//=========================创建============================</span><br>    <br>    <span class="hljs-comment">// 1. 基本创建</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 创建节点如果没有指定数据，则默认将当前主机的ip地址作为值存储</span><br><span class="hljs-comment">     * 2. 创建的节点的父节点默认必须存在</span><br><span class="hljs-comment">     * 3. 返回值是String类型的创建的节点的路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 创建出/k1节点，值为v1!</span><br>    String path = client.create().forPath(<span class="hljs-string">"/k1"</span>, <span class="hljs-string">"v1"</span>.getBytes());<br><br>    <span class="hljs-comment">// 2. 创建不同类型的节点</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 默认是持久化节点</span><br><span class="hljs-comment">     * 2. 使用withMode方法创建不同类型(节点的四种类型)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//创建临时节点，会话关闭自动消失(非命令行会话)</span><br>    client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="hljs-string">"/k2"</span>);<br><br>    <span class="hljs-comment">// 3. 创建多级节点 如果父节点不存在则创建父节点</span><br>    client.create().creatingParentsIfNeeded().forPath(<span class="hljs-string">"/k2/k2_1"</span>, <span class="hljs-string">"v2_1"</span>.getBytes());<br>    <br>    <span class="hljs-comment">//==========================查询==================================</span><br>    <span class="hljs-comment">// 1. 查询某一结点的值</span><br>    <span class="hljs-keyword">byte</span>[] data = client.getData().forPath(<span class="hljs-string">"/k1"</span>);<br>    System.out.println(<span class="hljs-keyword">new</span> String(data));<br><br>    <span class="hljs-comment">// 2. 查询子节点</span><br>    List&lt;String&gt; strings = client.getChildren().forPath(<span class="hljs-string">"/"</span>);<br>    System.out.println(strings);<br><br>    <span class="hljs-comment">// 3. 查询某一节点详细信息</span><br>    <span class="hljs-comment">// Stat是一个 JavaBean，其中的属性就是之前所述详细信息的参数</span><br>    Stat stat = <span class="hljs-keyword">new</span> Stat();<br>    <span class="hljs-comment">//将获取到的信息存储在Stat对象的属性中</span><br>    client.getData().storingStatIn(stat).forPath(<span class="hljs-string">"/k1"</span>);<br>    <br>    <span class="hljs-comment">//==============================修改====================================</span><br>    <br>    <span class="hljs-comment">// 1. 修改某一结点的值</span><br>    client.setData().forPath(<span class="hljs-string">"/k1"</span>, <span class="hljs-string">"new_v1"</span>.getBytes());<br>    <span class="hljs-comment">// 2. 根据某一结点的版本修改值</span><br>    <span class="hljs-comment">// 每次修改值都会更新版本，使用此是为了防止多人修改一个节点时出错</span><br>    <span class="hljs-keyword">int</span> version = <span class="hljs-keyword">new</span> Stat().getVersion(); <span class="hljs-comment">//获取当前版本</span><br>    client.setData().withVersion(version).forPath(<span class="hljs-string">"/k2"</span>, <span class="hljs-string">"new_k2"</span>.getBytes());<br>    <br>    <br>    <span class="hljs-comment">// =================================删除=========================================</span><br>    <br>    <span class="hljs-comment">// 1. 删除单个节点</span><br>    client.delete().forPath(<span class="hljs-string">"/k2"</span>);<br>    <span class="hljs-comment">// 2. 删除带有子节点的节点</span><br>    client.delete().deletingChildrenIfNeeded().forPath(<span class="hljs-string">"/k2"</span>);<br>    <span class="hljs-comment">// 3. 必须成功的删除</span><br>    <span class="hljs-comment">//可能会由于网络抖动等原因导致删除失败，本质就是重试删除，直至成功</span><br>    client.delete().guaranteed().forPath(<span class="hljs-string">"/k2"</span>);<br>    <span class="hljs-comment">// 4. 回调删除</span><br>    <span class="hljs-comment">// 删除操作结束之后自动执行的回调函数</span><br>    client.delete().guaranteed().inBackground(<span class="hljs-keyword">new</span> BackgroundCallback() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processResult</span><span class="hljs-params">(CuratorFramework client, CuratorEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>            System.out.println(<span class="hljs-string">"执行了回调函数!"</span>);<br>        }<br>    }).forPath(<span class="hljs-string">"/k2"</span>);<br><br>    <span class="hljs-comment">// 关闭连接</span><br>    client.close();<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="5、Watch事件监听"><a class="header-anchor" href="#5、Watch事件监听">¶</a>5、Watch事件监听</h2>
<ol>
<li>ZK允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZK服务端会将事件通知到感兴趣的客户端中，该机制是ZK实现分布式协调服务的重要特性</li>
<li>ZK中引入了Watcher机制实现发布/订阅功能，能够让多个订阅者同时监听某一个对象，当此对象状态发生变化的时候，会通知所有订阅者</li>
<li>ZK提供了三种Watcher：
<ol>
<li>NodeCache：监听某一特定的节点</li>
<li>PathChildrenCache：监听某一结点的所有子节点 (并不监听此节点本身)</li>
<li>TreeCache：监听某一(子)树的所有结点 (NodeCache + PathChildrenCache)</li>
</ol>
</li>
</ol>
<p><strong>三种Watcher演示：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>    RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">3000</span>,<span class="hljs-number">10</span>);<br>    CuratorFramework client = CuratorFrameworkFactory.builder()<br>        .connectString(<span class="hljs-string">"82.156.11.189:2181,82.156.11.189:2182,82.156.11.189:2183"</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)<br>        .connectionTimeoutMs(<span class="hljs-number">15</span> * <span class="hljs-number">1000</span>)<br>        .retryPolicy(retryPolicy)<br>        .build();<br>    client.start();<br><br>    <span class="hljs-comment">//=========================演示一：NodeCache==========================</span><br><br>    <span class="hljs-comment">//1. 创建NodeCache对象</span><br>    NodeCache nodeCache = <span class="hljs-keyword">new</span> NodeCache(client, <span class="hljs-string">"/k1"</span>);<br>    <span class="hljs-comment">//2. 注册监听 (无法监听特定的添加或者删除等事件，除了get操作其余均会触发此事件)</span><br>    nodeCache.getListenable().addListener(<span class="hljs-keyword">new</span> NodeCacheListener() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nodeChanged</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>            System.out.println(<span class="hljs-string">"数据变化了"</span>);<br>            <span class="hljs-comment">//获取节点修改过后的值</span><br>            <span class="hljs-keyword">byte</span>[] data = nodeCache.getCurrentData().getData();<br>            System.out.println(<span class="hljs-string">"新值是："</span> + <span class="hljs-keyword">new</span> String(data));<br>        }<br>    });<br>    <span class="hljs-comment">// 3. 开启监听，如果设置为true，则开启监听时，如果之前的缓存记录中有满足监听条件的会显示出来</span><br>    nodeCache.start(<span class="hljs-keyword">true</span>);<br><br>    Thread.sleep(Long.MAX_VALUE);<br><br>    <span class="hljs-comment">//==================演示二：PathChildrenCache============================</span><br><br>    <span class="hljs-comment">// 1. 创建PathChildrenCache对象，设置为true，监听开启时加载之前的缓存数据</span><br>    PathChildrenCache pathChildrenCache = <span class="hljs-keyword">new</span> PathChildrenCache(client, <span class="hljs-string">"/"</span>, <span class="hljs-keyword">true</span>);<br><br>    <span class="hljs-comment">// 2. 注册监听</span><br>    pathChildrenCache.getListenable().addListener(<span class="hljs-keyword">new</span> PathChildrenCacheListener() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">childEvent</span><span class="hljs-params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>            System.out.println(<span class="hljs-string">"节点发生变更！"</span>);<br>            System.out.println(<span class="hljs-string">"event对象的值："</span> + event);<br><br>            <span class="hljs-comment">//获取节点变更的类型，Type是内部枚举类</span><br>            PathChildrenCacheEvent.Type type = event.getType();<br>            System.out.println(<span class="hljs-string">"获取到的变更类型："</span> + type);<br><br>            <span class="hljs-comment">//判断变更类型是否为UPDATED，还有ADDED、REMOVED等类型</span><br>            <span class="hljs-keyword">if</span> (type.equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)) {<br>                <span class="hljs-comment">//获取修改后的值，连续使用两个getData()</span><br>                System.out.println(<span class="hljs-string">"节点的值被修改成为："</span> + <span class="hljs-keyword">new</span> String(event.getData().getData()));<br>            }<br>        }<br>    });<br><br>    <span class="hljs-comment">// 3. 开启监听</span><br>    pathChildrenCache.start();<br><br>    Thread.sleep(Long.MAX_VALUE);<br><br><br><br>    <span class="hljs-comment">//===============================演示三：TreeCache===========================</span><br>    <span class="hljs-comment">// 1. 创建TreeCache对象</span><br>    TreeCache treeCache = <span class="hljs-keyword">new</span> TreeCache(client, <span class="hljs-string">"/k1"</span>);<br>    <span class="hljs-comment">// 2. 注册监听</span><br>    treeCache.getListenable().addListener(<span class="hljs-keyword">new</span> TreeCacheListener() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">childEvent</span><span class="hljs-params">(CuratorFramework client, TreeCacheEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>            System.out.println(<span class="hljs-string">"变更后的具体数组都在event对象中："</span> + event);<br>        }<br>    });<br>    <span class="hljs-comment">// 3. 开启监听</span><br>    treeCache.start();<br><br>    Thread.sleep(Long.MAX_VALUE);<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="6、分布式锁实现及测试"><a class="header-anchor" href="#6、分布式锁实现及测试">¶</a>6、分布式锁实现及测试</h2>
<p><strong>Curator实现分布式锁有五种方案：</strong></p>
<ul>
<li>InterProcessSemaphoreMutex：分布式排它锁</li>
<li>InterProcessMutex：<strong>分布式可重入排它锁 (使用较多)</strong></li>
<li>InterProcessReadWriteLock：分布式读写锁</li>
<li>InterProcessMultiLock：将多个锁作为单个实体管理的容器</li>
<li>InterProcessSemaphoreV2：共享信号量</li>
</ul>
<p><strong>分布式锁代码实现：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itnxd.case3;<br><br><span class="hljs-keyword">import</span> org.apache.curator.RetryPolicy;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFramework;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessLock;<br><span class="hljs-keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;<br><span class="hljs-keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-09-27 20:32</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CuratorLockTest</span> </span>{<br><br>    <span class="hljs-keyword">private</span> String rootNode = <span class="hljs-string">"/locks"</span>;<br>    <span class="hljs-comment">// zookeeper server 列表</span><br>    <span class="hljs-keyword">private</span> String connectString = <span class="hljs-string">"82.156.11.189:2181,82.156.11.189:2182,82.156.11.189:2183"</span>;<br>    <span class="hljs-comment">// connection 超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> connectionTimeout = <span class="hljs-number">2000</span>;<br>    <span class="hljs-comment">// session 超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sessionTimeout = <span class="hljs-number">2000</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-keyword">new</span> CuratorLockTest().test();<br>    }<br><br>    <span class="hljs-comment">// 测试</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-comment">// 创建分布式锁 1</span><br>        <span class="hljs-keyword">final</span> InterProcessLock lock1 = <span class="hljs-keyword">new</span><br>                InterProcessMutex(getCuratorFramework(), rootNode);<br>        <span class="hljs-comment">// 创建分布式锁 2</span><br>        <span class="hljs-keyword">final</span> InterProcessLock lock2 = <span class="hljs-keyword">new</span><br>                InterProcessMutex(getCuratorFramework(), rootNode);<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                <span class="hljs-comment">// 获取锁对象</span><br>                <span class="hljs-keyword">try</span> {<br>                    lock1.acquire();<br>                    System.out.println(<span class="hljs-string">"线程 1 获取锁"</span>);<br>                    <span class="hljs-comment">// 测试锁重入</span><br>                    lock1.acquire();<br>                    System.out.println(<span class="hljs-string">"线程 1 再次获取锁"</span>);<br>                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);<br>                    lock1.release();<br>                    System.out.println(<span class="hljs-string">"线程 1 释放锁"</span>);<br>                    lock1.release();<br>                    System.out.println(<span class="hljs-string">"线程 1 再次释放锁"</span>);<br>                } <span class="hljs-keyword">catch</span> (Exception e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        }).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                <span class="hljs-comment">// 获取锁对象</span><br>                <span class="hljs-keyword">try</span> {<br>                    lock2.acquire();<br>                    System.out.println(<span class="hljs-string">"线程 2 获取锁"</span>);<br>                    <span class="hljs-comment">// 测试锁重入</span><br>                    lock2.acquire();<br>                    System.out.println(<span class="hljs-string">"线程 2 再次获取锁"</span>);<br>                    Thread.sleep(<span class="hljs-number">5</span> * <span class="hljs-number">1000</span>);<br>                    lock2.release();<br>                    System.out.println(<span class="hljs-string">"线程 2 释放锁"</span>);<br>                    lock2.release();<br>                    System.out.println(<span class="hljs-string">"线程 2 再次释放锁"</span>);<br>                } <span class="hljs-keyword">catch</span> (Exception e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        }).start();<br>    }<br><br>    <span class="hljs-comment">// 分布式锁初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CuratorFramework <span class="hljs-title">getCuratorFramework</span> <span class="hljs-params">()</span></span>{<br>        <span class="hljs-comment">//重试策略，重试时间 3 秒，重试 3 次</span><br>        RetryPolicy policy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">3000</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//通过工厂创建 Curator</span><br>        CuratorFramework client =<br>                CuratorFrameworkFactory.builder()<br>                        .connectString(connectString)<br>                        .connectionTimeoutMs(connectionTimeout)<br>                        .sessionTimeoutMs(sessionTimeout)<br>                        .retryPolicy(policy).build();<br>        <span class="hljs-comment">//开启连接</span><br>        client.start();<br>        System.out.println(<span class="hljs-string">"zookeeper 初始化完成..."</span>);<br>        <span class="hljs-keyword">return</span> client;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>结果：</strong></p>
<p>观察控制台变化：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">线程 1 获取锁<br>线程 1 再次获取锁<br>线程 1 释放锁<br>线程 1 再次释放锁<br>线程 2 获取锁<br>线程 2 再次获取锁<br>线程 2 释放锁<br>线程 2 再次释放锁<br></code></pre></td></tr></tbody></table></figure>
<h1 id="七、面试真题"><a class="header-anchor" href="#七、面试真题">¶</a>七、面试真题</h1>
<h2 id="1、选举机制"><a class="header-anchor" href="#1、选举机制">¶</a>1、选举机制</h2>
<p>半数机制，超过半数的投票通过，即通过！</p>
<ol>
<li>第一次启动选举规则：投票过半数时，服务器 id 大的胜出</li>
<li>第二次启动选举规则：
<ol>
<li>EPOCH 大的直接胜出</li>
<li>EPOCH 相同，事务 id 大的胜出</li>
<li>事务 id 相同，服务器 id 大的胜出</li>
</ol>
</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>可运行的机器要超过集群总数量的半数</li>
<li>主服务器挂掉，其余服务器会重新进行选举出Leader</li>
<li>产生了Leader之后，当有新的服务器加入，不会影响到现有Leader地位</li>
</ul>
<h2 id="2、生产集群安装多少-zk-合适？"><a class="header-anchor" href="#2、生产集群安装多少-zk-合适？">¶</a>2、生产集群安装多少 zk 合适？</h2>
<p>安装奇数台！</p>
<p>生产经验：</p>
<p>10 台服务器：3 台 zk；</p>
<p>20 台服务器：5 台 zk；</p>
<p>100 台服务器：11 台 zk；</p>
<p>200 台服务器：11 台 zk</p>
<p>服务器台数多：好处，提高可靠性；坏处：提高通信延时！</p>
<h2 id="3、常用命令"><a class="header-anchor" href="#3、常用命令">¶</a>3、常用命令</h2>
<p>ls、get、create、delete …</p>
<h1 id="八、算法基础"><a class="header-anchor" href="#八、算法基础">¶</a>八、算法基础</h1>
<h2 id="1、拜占庭将军问题"><a class="header-anchor" href="#1、拜占庭将军问题">¶</a>1、拜占庭将军问题</h2>
<p>拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。</p>
<p>问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。</p>
<p>叛徒可以任意行动以达到以下目标：欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。</p>
<p>如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，<strong>只有完全达成一致的努力才能获得胜利</strong>。</p>
<h2 id="2、Paxos算法"><a class="header-anchor" href="#2、Paxos算法">¶</a>2、Paxos算法</h2>
<p><strong>Paxos算法</strong>：一种基于消息传递且具有<strong>高度容错特性的一致性算法</strong>。</p>
<p><strong>Paxos算法解决的问题</strong>：就是如何快速正确的在一个分布式系统中对某个数据值达成一致，并且保证不论发生任何异常，都不会破坏整个系统的一致性。</p>
<h3 id="Paxos算法描述"><a class="header-anchor" href="#Paxos算法描述">¶</a>Paxos算法描述</h3>
<p>在一个Paxos系统中，首先将所有节点划分为Proposer（提议者），Acceptor（接受者），和Learner（学习者）。（注意：每个节点都可以身兼数职）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@3e64bc1cb9d82b8fb9364a815e6aa1478c288080/2021/09/28/ba6ad0e4603b98c60d76c3b34569b977.png" alt=""></p>
<ul>
<li>一个完整的Paxos算法流程分为三个阶段：</li>
<li>Prepare准备阶段
<ul>
<li>Proposer向多个Acceptor发出Propose请求Promise（承诺）</li>
<li>Acceptor针对收到的Propose请求进行Promise（承诺）</li>
</ul>
</li>
<li>Accept接受阶段
<ul>
<li>Proposer收到多数Acceptor承诺的Promise后，向Acceptor发出Propose请求</li>
<li>Acceptor针对收到的Propose请求进行Accept处理</li>
</ul>
</li>
<li>Learn学习阶段：Proposer将形成的决议发送给所有Learners</li>
</ul>
<h3 id="Paxos算法流程"><a class="header-anchor" href="#Paxos算法流程">¶</a>Paxos算法流程</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@071f0366c890c6e01c9908e934452bf9313ee0d7/2021/09/28/284c1d3724df6ec49cca813971b0a462.png" alt=""></p>
<ol>
<li>Prepare: Proposer生成全局唯一且递增的Proposal ID，向所有Acceptor发送Propose请求，这里无需携带提案内容，只携带Proposal ID即可。</li>
<li>Promise: Acceptor收到Propose请求后，做出“两个承诺，一个应答”。
<ol>
<li>不再接受Proposal ID小于等于（注意：这里是&lt;= ）当前请求的Propose请求。</li>
<li>不再接受Proposal ID小于（注意：这里是&lt; ）当前请求的Accept请求。</li>
<li>不违背以前做出的承诺下，回复已经Accept过的提案中Proposal ID最大的那个提案的Value和Proposal ID，没有则返回空值。</li>
</ol>
</li>
<li>Propose: Proposer收到多数Acceptor的Promise应答后，从应答中选择Proposal ID最大的提案的Value，作为本次要发起的提案。如果所有应答的提案Value均为空值，则可以自己随意决定提案Value。然后携带当前Proposal ID，向所有Acceptor发 送Propose请求。</li>
<li>Accept: Acceptor收到Propose请求后，在不违背自己之前做出的承诺下，接受并持久化当前Proposal ID和提案Value。</li>
<li>Learn: Proposer收到多数Acceptor的Accept后，决议形成，将形成的决议发送给所有Learner。</li>
</ol>
<h3 id="情况一"><a class="header-anchor" href="#情况一">¶</a>情况一</h3>
<p><strong>有A1, A2, A3, A4, A5 5位议员，就税率问题进行决议：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@be99ebda978b625535098d70a8c7de4a803b5c21/2021/09/28/fd44d7220ba3590ee5226adce3eedf4d.png" alt=""></p>
<ul>
<li>A1发起1号Proposal的Propose，等待Promise承诺；</li>
<li>A2-A5回应Promise；</li>
<li>A1在收到两份回复时就会发起税率10%的Proposal；</li>
<li>A2-A5回应Accept；</li>
<li>通过Proposal，税率10%。</li>
</ul>
<h3 id="情况二"><a class="header-anchor" href="#情况二">¶</a>情况二</h3>
<p><strong>现在我们假设在A1提出提案的同时, A5决定将税率定为20%：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@a7efd65e4cd88c68a24df32332260757fc7434b1/2021/09/28/8ef0a99d411020479828223a52d58008.png" alt=""></p>
<ul>
<li>A1，A5同时发起Propose（序号分别为1，2）</li>
<li>A2承诺A1，A4承诺A5，A3行为成为关键</li>
<li>情况1：A3先收到A1消息，承诺A1。</li>
<li>A1发起Proposal（1，10%），A2，A3接受。</li>
<li>之后A3又收到A5消息，回复A1：（1，10%），并承诺A5。</li>
<li>A5发起Proposal（2，20%），A3，A4接受。之后A1，A5同时广播决议。</li>
</ul>
<p><strong>Paxos 算法缺陷</strong>：在网络复杂的情况下，一个应用 Paxos 算法的分布式系统，可能很久无法收敛，甚至陷入<strong>活锁</strong>的情况。</p>
<h3 id="情况三"><a class="header-anchor" href="#情况三">¶</a>情况三</h3>
<p><strong>现在我们假设在A1提出提案的同时, A5决定将税率定为20%：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@88725cf0b045051341e67a965327d69789673beb/2021/09/28/40b674519bae5b7c41d559930cd72e99.png" alt=""></p>
<ul>
<li>A1，A5同时发起Propose（序号分别为1，2）</li>
<li>A2承诺A1，A4承诺A5，A3行为成为关键</li>
<li>情况2：A3先收到A1消息，承诺A1。之后立刻收到A5消息，承诺A5。</li>
<li>A1发起Proposal（1，10%），无足够响应，A1重新Propose （序号3），A3再次承诺A1。</li>
<li>A5发起Proposal（2，20%），无足够相应。A5重新Propose （序号4），A3再次承诺A5。</li>
<li>……</li>
</ul>
<p>造成这种情况的原因是系统中有一个以上的 Proposer，多个 Proposers 相互争夺 Acceptor，造成迟迟无法达成一致的情况。针对这种情况，一种改进的 Paxos 算法被提出：从系统中选出一个节点作为 Leader，只有 Leader 能够发起提案。这样，一次 Paxos 流程中只有一个Proposer，不会出现活锁的情况，此时只会出现例子中第一种情况。</p>
<h2 id="3、Zab协议"><a class="header-anchor" href="#3、Zab协议">¶</a>3、Zab协议</h2>
<h3 id="什么是ZAB算法"><a class="header-anchor" href="#什么是ZAB算法">¶</a>什么是ZAB算法</h3>
<p>Zab 借鉴了 Paxos 算法，是特别为 Zookeeper 设计的支持崩溃恢复的原子广播协议。基于该协议，Zookeeper 设计为只有一台客户端（Leader）负责处理外部的写事务请求，然后Leader 客户端将数据同步到其他 Follower 节点。即 Zookeeper 只有一个 Leader 可以发起提案。</p>
<h3 id="Zab协议内容"><a class="header-anchor" href="#Zab协议内容">¶</a>Zab协议内容</h3>
<p>Zab 协议包括两种基本的模式：消息广播、崩溃恢复。</p>
<h3 id="消息广播"><a class="header-anchor" href="#消息广播">¶</a>消息广播</h3>
<p><strong>示意图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@c05bafcebac8798ccb6ef5c7abb55ea38e087f31/2021/09/28/5a257bbf67b5d6899ce410e0c12a3e8c.png" alt=""></p>
<p><strong>消息广播过程：</strong></p>
<ol>
<li>客户端发起一个写操作请求。</li>
<li>Leader服务器将客户端的请求转化为事务Proposal 提案，同时为每个Proposal 分配一个全局的ID，即zxid。</li>
<li>Leader服务器为每个Follower服务器分配一个单独的队列，然后将需要广播的 Proposal依次放到队列中去，并且根据FIFO策略进行消息发送。</li>
<li>Follower接收到Proposal后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向Leader反馈一个Ack响应消息。</li>
<li>Leader接收到超过半数以上Follower的Ack响应消息后，即认为消息发送成功，可以发送commit消息。</li>
<li>Leader向所有Follower广播commit消息，同时自身也会完成事务提交。Follower 接收到commit消息后，会将上一条事务提交。</li>
<li>Zookeeper采用Zab协议的核心，就是只要有一台服务器提交了Proposal，就要确保所有的服务器最终都能正确提交Proposal。</li>
</ol>
<p><strong>ZAB协议针对事务请求的处理过程类似于一个两阶段提交过程：</strong></p>
<ul>
<li>
<p>广播事务阶段</p>
</li>
<li>
<p>广播提交操作</p>
</li>
</ul>
<p>这两阶段提交模型，有可能因为Leader宕机带来数据不一致，比如</p>
<ul>
<li>Leader 发起一个事务Proposal1 后就宕机 ，Follower 都没有Proposal1</li>
<li>Leader收到半数ACK宕机，没来得及向Follower发送Commit怎么解决呢？ZAB引入了崩溃恢复模式。</li>
</ul>
<h3 id="崩溃恢复"><a class="header-anchor" href="#崩溃恢复">¶</a>崩溃恢复</h3>
<p><strong>崩溃恢复——异常假设</strong></p>
<p>一旦Leader服务器出现崩溃或者由于网络原因导致Leader服务器失去了与过半 Follower的联系，那么就会进入<strong>崩溃恢复模式。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@4392ea017a168e8f1131aa57a6cf89f46617db8b/2021/09/28/b4fd798df80c27b528ace22f6192ec71.png" alt=""></p>
<ol>
<li><strong>假设两种服务器异常情况：</strong>
<ol>
<li>假设一个事务在Leader提出之后，Leader挂了。</li>
<li>一个事务在Leader上提交了，并且过半的Follower都响应Ack了，但是Leader在Commit消息发出之前挂了。</li>
</ol>
</li>
<li><strong>Zab协议崩溃恢复要求满足以下两个要求：</strong>
<ol>
<li>确保已经被Leader提交的提案Proposal，必须最终被所有的Follower服务器提交。 （<strong>已经产生的提案，Follower必须执行</strong>）</li>
<li>确保<strong>丢弃</strong>已经被Leader提出的，但是没有被提交的Proposal。（<strong>丢弃胎死腹中的提案</strong>）</li>
</ol>
</li>
</ol>
<p><strong>崩溃恢复——Leader选举</strong></p>
<p>崩溃恢复主要包括两部分：<strong>Leader选举和数据恢复。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@a505cb65de12b1708f666b3e79c5f08ecf2fedf0/2021/09/28/dc642a53a02928fdd10aa674ebc3d6db.png" alt=""></p>
<p><strong>Leader选举</strong>：根据上述要求，Zab协议需要保证选举出来的Leader需要满足以下条件：</p>
<ol>
<li>新选举出来的Leader不能包含未提交的Proposal。<strong>即新Leader必须都是已经提交了Proposal的Follower服务器节点。</strong></li>
<li><strong>新选举的Leader节点中含有最大的zxid</strong>。这样做的好处是可以避免Leader服务器检查Proposal的提交和丢弃工作。</li>
</ol>
<p><strong>崩溃恢复——数据恢复</strong></p>
<p>崩溃恢复主要包括两部分：<strong>Leader选举和数据恢复。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@d92fc5b319f44c9645fd24be56d1e9f619b17f55/2021/09/28/e2f5b93c465b11fe6ec1749efc58abe9.png" alt=""></p>
<p><strong>Zab如何数据同步：</strong></p>
<ol>
<li>完成Leader选举后，在正式开始工作之前（接收事务请求，然后提出新的Proposal），<strong>Leader服务器会首先确认事务日志中的所有的Proposal 是否已经被集群中过半的服务器Commit。</strong></li>
<li>Leader服务器需要确保所有的Follower服务器能够接收到每一条事务的Proposal，并且能将所有已经提交的事务Proposal应用到内存数据中。<strong>等Follower将所有尚未同步的事务Proposal都从Leader服务器上同步过，并且应用到内存数据中以后，Leader才会把该Follower加入到真正可用的Follower列表中。</strong></li>
</ol>
<h2 id="4、CAP理论"><a class="header-anchor" href="#4、CAP理论">¶</a>4、CAP理论</h2>
<p><strong>CAP理论告诉我们，一个分布式系统不可能同时满足以下三种：</strong></p>
<ol>
<li>一致性（C：Consistency）</li>
<li>可用性（A：Available）</li>
<li>分区容错性（P：Partition Tolerance）</li>
</ol>
<p><strong>这三个基本需求，最多只能同时满足其中的两项，因为P是必须的，因此往往选择就在CP或者AP中。</strong></p>
<ul>
<li>
<p>一致性：在分布式环境中，一致性是指数据在多个副本之间是否能够保持数据一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。</p>
</li>
<li>
<p>可用性：可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
</li>
<li>
<p>分区容错性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
</li>
</ul>
<p><strong>ZooKeeper保证的是CP：</strong></p>
<ul>
<li>
<p>ZooKeeper不能保证每次服务请求的可用性。（注：在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果）。所以说，ZooKeeper不能保证服务可用性。</p>
</li>
<li>
<p>进行Leader选举时集群都是不可用。</p>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">ITNXD</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.itnxd.cn/posts/34316.html">https://www.itnxd.cn/posts/34316.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.itnxd.cn" target="_blank">小牛博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Zookeeper/">Zookeeper</a><a class="post-meta__tags" href="/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/">注册中心</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">分布式锁</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/niuxvdong/pic@be75530d6fedb428ff2e154f0aa823d6b754520e/2021/09/28/5efed5f7a5d8a6e858152e7c78b31007.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/WeChantQR.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/WeChantQR.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/AliPayQR.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/AliPayQR.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/23425.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@a2064035fcb2efe4f95ed2262f3f836bf7ba6350/2021/10/01/27c3919bb7046bc5ece2657118592e38.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">高性能、轻量级开源分布式RPC服务框架Dubbo使用介绍</div></div></a></div><div class="next-post pull-right"><a href="/posts/5524.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@6bf71771813a93d57a1c092ec63f34ea309a2450/2021/09/26/124fa3c7859ae9eb301e9b4d0e5cbfea.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mybatis加强版MyBatis-Plus使用、为简化开发而生</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">一、简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-text">2、工作机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-text">3、特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">4、数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5、应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85"><span class="toc-text">二、安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85"><span class="toc-text">1、下载安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">2、常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-text">3、配置文件介绍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%9B%86%E7%BE%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">三、集群操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%87%86%E5%A4%87"><span class="toc-text">1、准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-text">2、集群配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E5%8F%B7"><span class="toc-text">配置服务器编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEzoo-cfg%E6%96%87%E4%BB%B6"><span class="toc-text">配置zoo.cfg文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%9B%86%E7%BE%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">3、集群操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">4、选举机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E9%9B%86%E7%BE%A4%E5%91%BD%E4%BB%A4"><span class="toc-text">5、集群命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">6、节点类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-text">7、监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-text">监听器原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E6%A1%88%E4%BE%8B"><span class="toc-text">监听案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AFAPI%E6%93%8D%E4%BD%9C"><span class="toc-text">四、客户端API操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81IDEA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">1、IDEA环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pom-xml"><span class="toc-text">pom.xml</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#log4j-properties"><span class="toc-text">log4j.properties</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81API%E6%93%8D%E4%BD%9C"><span class="toc-text">2、API操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%86%99%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B"><span class="toc-text">3、客户端写数据流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A8%E6%80%81%E4%B8%8A%E4%B8%8B%E7%BA%BF%E7%9B%91%E5%90%AC%E6%A1%88%E4%BE%8B"><span class="toc-text">五、服务器动态上下线监听案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">1、需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">2、具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%B5%8B%E8%AF%95"><span class="toc-text">3、测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%A1%88%E4%BE%8B"><span class="toc-text">六、分布式锁案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-2"><span class="toc-text">1、需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">2、具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%B5%8B%E8%AF%95-2"><span class="toc-text">3、测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81Curator-%E6%A1%86%E6%9E%B6"><span class="toc-text">七、Curator 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">1、简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BE%9D%E8%B5%96"><span class="toc-text">2、依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5"><span class="toc-text">3、创建连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-text">4、增删改查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Watch%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-text">5、Watch事件监听</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%B5%8B%E8%AF%95"><span class="toc-text">6、分布式锁实现及测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98"><span class="toc-text">七、面试真题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">1、选举机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%94%9F%E4%BA%A7%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E5%A4%9A%E5%B0%91-zk-%E5%90%88%E9%80%82%EF%BC%9F"><span class="toc-text">2、生产集群安装多少 zk 合适？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">3、常用命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-text">八、算法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98"><span class="toc-text">1、拜占庭将军问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Paxos%E7%AE%97%E6%B3%95"><span class="toc-text">2、Paxos算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Paxos%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">Paxos算法描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Paxos%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-text">Paxos算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B8%80"><span class="toc-text">情况一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%BA%8C"><span class="toc-text">情况二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B8%89"><span class="toc-text">情况三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Zab%E5%8D%8F%E8%AE%AE"><span class="toc-text">3、Zab协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFZAB%E7%AE%97%E6%B3%95"><span class="toc-text">什么是ZAB算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zab%E5%8D%8F%E8%AE%AE%E5%86%85%E5%AE%B9"><span class="toc-text">Zab协议内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD"><span class="toc-text">消息广播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="toc-text">崩溃恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81CAP%E7%90%86%E8%AE%BA"><span class="toc-text">4、CAP理论</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By ITNXD</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">CDN BY <a target="_blank" rel="external nofollow" href="https://www.jsdelivr.com/"><b>jsDelivr</b></a> | HOST BY  <a target="_blank" rel="external nofollow" href="https://vercel.com/"><b>Vercel</b></a> && <a target="_blank" rel="external nofollow" href="https://github.com/"><b>Github</b></a><br><img style="vertical-align:middle" src="https://cdn.jsdelivr.net/gh/lzyblog/image@4b122354dee27f3056fd3a7fc6a43dbf68cebf33/2020/11/16/025e5329f3592dfa03a13c5365323ba1.png" alt=""> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.beian.miit.gov.cn/"><b>晋ICP备19005025号-2</b></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'itnxd-8g1z2i760e99f516',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'itnxd-8g1z2i760e99f516',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'itnxd-8g1z2i760e99f516',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><div class="aplayer no-destroy" data-id="1551071404" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/6dc9e8f9.js","daovoice")
</script><script>var isChatBtn = true
daovoice('init', {
  app_id: '6dc9e8f9',},{
  launcher: { 
     disableLauncherIcon: isChatBtn // 悬浮 ICON 是否显示
  },
});
daovoice('update');

if (isChatBtn) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      daovoice('show')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: true // 悬浮 ICON 是否显示
        },
      });
    }
    function chatBtnShow () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: false // 悬浮 ICON 是否显示
        },
      });
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>