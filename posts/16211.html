<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>反向代理、负载均衡服务器Nginx入门到精通 | 小牛博客</title><meta name="keywords" content="Nginx,Lua,负载均衡,反向代理"><meta name="author" content="ITNXD"><meta name="copyright" content="ITNXD"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="¶一、Nginx简介 ¶1、背景介绍 Nginx（“engine x”）一个具有高性能的【HTTP】和【反向代理】的【WEB服务器】，同时也是一个【POP3&#x2F;SMTP&#x2F;IMAP代理服务器】，是由伊戈尔·赛索耶夫(俄罗斯人)使用C语言编写的，Nginx的第一个版本是2004年10月4号发布的0.1.0版本。另外值得一提的是伊戈尔·赛索耶夫将Nginx的源码进行了开源，这也为Nginx的发展提供了良好">
<meta property="og:type" content="article">
<meta property="og:title" content="反向代理、负载均衡服务器Nginx入门到精通">
<meta property="og:url" content="https://www.itnxd.cn/posts/16211.html">
<meta property="og:site_name" content="小牛博客">
<meta property="og:description" content="¶一、Nginx简介 ¶1、背景介绍 Nginx（“engine x”）一个具有高性能的【HTTP】和【反向代理】的【WEB服务器】，同时也是一个【POP3&#x2F;SMTP&#x2F;IMAP代理服务器】，是由伊戈尔·赛索耶夫(俄罗斯人)使用C语言编写的，Nginx的第一个版本是2004年10月4号发布的0.1.0版本。另外值得一提的是伊戈尔·赛索耶夫将Nginx的源码进行了开源，这也为Nginx的发展提供了良好">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/niuxvdong/pic@ed6c32c3f3cc5f9a904e8a63ae2dd23d118bfd21/2021/09/20/8214792608475af375dedc1e855d8a07.png">
<meta property="article:published_time" content="2021-09-14T02:16:39.000Z">
<meta property="article:modified_time" content="2021-09-21T02:17:20.183Z">
<meta property="article:author" content="ITNXD">
<meta property="article:tag" content="Nginx">
<meta property="article:tag" content="Lua">
<meta property="article:tag" content="负载均衡">
<meta property="article:tag" content="反向代理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/niuxvdong/pic@ed6c32c3f3cc5f9a904e8a63ae2dd23d118bfd21/2021/09/20/8214792608475af375dedc1e855d8a07.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/favicon.ico"><link rel="canonical" href="https://www.itnxd.cn/posts/16211"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="H9LW1qdxrkJ55YbkfWulMvpaexxx3Rk0Yo6dVANeNHc"/><meta name="baidu-site-verification" content="code-YglH3DObCb"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8d3bd59bf6303bd5f44677445d369df5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":300,"languages":{"author":"作者: ITNXD","link":"链接: ","source":"来源: 小牛博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '反向代理、负载均衡服务器Nginx入门到精通',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-21 10:17:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="/css/my.css"><style type="text/css">#toggle-sidebar {bottom: 80px}</style><link rel="stylesheet" href="//at.alicdn.com/t/font_1828588_zrw9f0qqie.css"><link rel="stylesheet" href="/self/atom-one-light.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="小牛博客" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@2f11f173da64ba6a270c2e93d23e00911b1019d3/2021/02/06/e373babbf340391956b673128a84185d.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">249</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">196</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/niuxvdong/pic@ed6c32c3f3cc5f9a904e8a63ae2dd23d118bfd21/2021/09/20/8214792608475af375dedc1e855d8a07.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小牛博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">反向代理、负载均衡服务器Nginx入门到精通</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-14T02:16:39.000Z" title="发表于 2021-09-14 10:16:39">2021-09-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-21T02:17:20.183Z" title="更新于 2021-09-21 10:17:20">2021-09-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">40.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>148分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="反向代理、负载均衡服务器Nginx入门到精通"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、Nginx简介"><a class="header-anchor" href="#一、Nginx简介">¶</a>一、Nginx简介</h1>
<h2 id="1、背景介绍"><a class="header-anchor" href="#1、背景介绍">¶</a>1、背景介绍</h2>
<p>Nginx（“engine x”）一个具有高性能的【HTTP】和【反向代理】的【WEB服务器】，同时也是一个【POP3/SMTP/IMAP代理服务器】，是由伊戈尔·赛索耶夫(俄罗斯人)使用C语言编写的，Nginx的第一个版本是2004年10月4号发布的0.1.0版本。另外值得一提的是伊戈尔·赛索耶夫将Nginx的源码进行了开源，这也为Nginx的发展提供了良好的保障。</p>
<h2 id="2、名词解释"><a class="header-anchor" href="#2、名词解释">¶</a>2、名词解释</h2>
<h3 id="WEB服务器"><a class="header-anchor" href="#WEB服务器">¶</a>WEB服务器</h3>
<p>WEB服务器也叫网页服务器，英文名叫Web Server，主要功能是为用户提供网上信息浏览服务。</p>
<h3 id="HTTP"><a class="header-anchor" href="#HTTP">¶</a>HTTP</h3>
<p>HTTP是超文本传输协议的缩写，是用于从WEB服务器传输超文本到本地浏览器的传输协议，也是互联网上应用最为广泛的一种网络协议。HTTP是一个客户端和服务器端请求和应答的标准，客户端是终端用户，服务端是网站，通过使用Web浏览器、网络爬虫或者其他工具，客户端发起一个到服务器上指定端口的HTTP请求。</p>
<h3 id="POP3-SMTP-IMAP"><a class="header-anchor" href="#POP3-SMTP-IMAP">¶</a>POP3/SMTP/IMAP</h3>
<p>POP3(Post Offic Protocol 3)邮局协议的第三个版本，</p>
<p>SMTP(Simple Mail Transfer Protocol)简单邮件传输协议，</p>
<p>IMAP(Internet Mail Access Protocol)交互式邮件存取协议，</p>
<p>通过上述名词的解释，我们可以了解到Nginx也可以作为电子邮件代理服务器。</p>
<h3 id="反向代理"><a class="header-anchor" href="#反向代理">¶</a>反向代理</h3>
<p><strong>正向代理</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@aa8492a4df81efb58f6e2673b15c13507943569e/2021/09/16/e9eeb45f43d0d4a237f24a03aca62f7a.png" alt=""></p>
<p><strong>反向代理</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@5a845a0f4884745440bc05b8c94a1d3f73756b9a/2021/09/16/bc7dedd65a66cbfcd1f33539191dbec3.png" alt=""></p>
<h2 id="3、常见服务器对比"><a class="header-anchor" href="#3、常见服务器对比">¶</a>3、常见服务器对比</h2>
<h3 id="IIS"><a class="header-anchor" href="#IIS">¶</a>IIS</h3>
<p>​	全称(Internet Information Services)即互联网信息服务，是由微软公司提供的基于windows系统的互联网基本服务。windows作为服务器在稳定性与其他一些性能上都不如类UNIX操作系统，因此在需要高性能Web服务器的场合下，IIS可能就会被"冷落".</p>
<h3 id="Tomcat"><a class="header-anchor" href="#Tomcat">¶</a>Tomcat</h3>
<p>​	Tomcat是一个运行Servlet和JSP的Web应用软件，Tomcat技术先进、性能稳定而且开放源代码，因此深受Java爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器。但是Tomcat天生是一个重量级的Web服务器，对静态文件和高并发的处理比较弱。</p>
<h3 id="Apache"><a class="header-anchor" href="#Apache">¶</a>Apache</h3>
<p>​	Apache的发展时期很长，同时也有过一段辉煌的业绩。从上图可以看出大概在2014年以前都是市场份额第一的服务器。Apache有很多优点，如稳定、开源、跨平台等。但是它出现的时间太久了，在它兴起的年代，互联网的产业规模远远不如今天，所以它被设计成一个重量级的、不支持高并发的Web服务器。在Apache服务器上，如果有数以万计的并发HTTP请求同时访问，就会导致服务器上消耗大量能存，操作系统内核对成百上千的Apache进程做进程间切换也会消耗大量的CUP资源，并导致HTTP请求的平均响应速度降低，这些都决定了Apache不可能成为高性能的Web服务器。这也促使了Lighttpd和Nginx的出现。</p>
<h3 id="Lighttpd"><a class="header-anchor" href="#Lighttpd">¶</a>Lighttpd</h3>
<p>​	Lighttpd是德国的一个开源的Web服务器软件，它和Nginx一样，都是轻量级、高性能的Web服务器，欧美的业界开发者比较钟爱Lighttpd,而国内的公司更多的青睐Nginx，同时网上Nginx的资源要更丰富些。</p>
<h3 id="其他的服务器"><a class="header-anchor" href="#其他的服务器">¶</a>其他的服务器</h3>
<p>Google Servers，Weblogic, Webshpere(IBM)…</p>
<p>经过各个服务器的对比，种种迹象都表明，Nginx将以性能为王。这也是我们为什么选择Nginx的理由。</p>
<h2 id="4、Nginx的优点"><a class="header-anchor" href="#4、Nginx的优点">¶</a>4、Nginx的优点</h2>
<h3 id="速度更快、并发更高"><a class="header-anchor" href="#速度更快、并发更高">¶</a>速度更快、并发更高</h3>
<p>单次请求或者高并发请求的环境下，Nginx都会比其他Web服务器响应的速度更快。一方面在正常情况下，单次请求会得到更快的响应，另一方面，在高峰期(如有数以万计的并发请求)，Nginx比其他Web服务器更快的响应请求。Nginx之所以有这么高的并发处理能力和这么好的性能原因在于Nginx采用了多进程和I/O多路复用(epoll)的底层实现。</p>
<h3 id="配置简单，扩展性强"><a class="header-anchor" href="#配置简单，扩展性强">¶</a>配置简单，扩展性强</h3>
<p>Nginx的设计极具扩展性，它本身就是由很多模块组成，这些模块的使用可以通过配置文件的配置来添加。这些模块有官方提供的也有第三方提供的模块，如果需要完全可以开发服务自己业务特性的定制模块。</p>
<h3 id="高可靠性"><a class="header-anchor" href="#高可靠性">¶</a>高可靠性</h3>
<p>Nginx采用的是多进程模式运行，其中有一个master主进程和N多个worker进程，worker进程的数量我们可以手动设置，每个worker进程之间都是相互独立提供服务，并且master主进程可以在某一个worker进程出错时，快速去"拉起"新的worker进程提供服务。</p>
<h3 id="热部署"><a class="header-anchor" href="#热部署">¶</a>热部署</h3>
<p>现在互联网项目都要求以7*24小时进行服务的提供，针对于这一要求，Nginx也提供了热部署功能，即可以在Nginx不停止的情况下，对Nginx进行文件升级、更新配置和更换日志文件等功能。</p>
<h3 id="成本低、BSD许可证"><a class="header-anchor" href="#成本低、BSD许可证">¶</a>成本低、BSD许可证</h3>
<p>BSD是一个开源的许可证，世界上的开源许可证有很多，现在比较流行的有六种分别是GPL、BSD、MIT、Mozilla、Apache、LGPL。这六种的区别是什么，我们可以通过下面一张图来解释下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@7b85283859cf88d8ea052579a211c7185e0497f3/2021/09/16/1f5e9d7ace5930237eeafe7cf43fdc22.png" alt=""></p>
<p>Nginx本身是开源的，我们不仅可以免费的将Nginx应用在商业领域，而且还可以在项目中直接修改Nginx的源码来定制自己的特殊要求。这些点也都是Nginx为什么能吸引无数开发者继续为Nginx来贡献自己的智慧和青春。OpenRestry [Nginx+Lua]   Tengine[淘宝]</p>
<h2 id="5、Nginx的功能特性及常用功能"><a class="header-anchor" href="#5、Nginx的功能特性及常用功能">¶</a>5、Nginx的功能特性及常用功能</h2>
<p>Nginx提供的基本功能服务从大体上归纳为"基本HTTP服务"、“高级HTTP服务”和"邮件服务"等三大类。</p>
<h3 id="基本HTTP服务"><a class="header-anchor" href="#基本HTTP服务">¶</a>基本HTTP服务</h3>
<p>Nginx可以提供基本HTTP服务，可以作为HTTP代理服务器和反向代理服务器，支持通过缓存加速访问，可以完成简单的负载均衡和容错，支持包过滤功能，支持SSL等。</p>
<ul>
<li>处理静态文件、处理索引文件以及支持自动索引；</li>
<li>提供反向代理服务器，并可以使用缓存加上反向代理，同时完成负载均衡和容错；</li>
<li>提供对FastCGI、memcached等服务的缓存机制，，同时完成负载均衡和容错；</li>
<li>使用Nginx的模块化特性提供过滤器功能。Nginx基本过滤器包括gzip压缩、ranges支持、chunked响应、XSLT、SSI以及图像缩放等。其中针对包含多个SSI的页面，经由FastCGI或反向代理，SSI过滤器可以并行处理。</li>
<li>支持HTTP下的安全套接层安全协议SSL.</li>
<li>支持基于加权和依赖的优先权的HTTP/2</li>
</ul>
<h3 id="高级HTTP服务"><a class="header-anchor" href="#高级HTTP服务">¶</a>高级HTTP服务</h3>
<ul>
<li>支持基于名字和IP的虚拟主机设置</li>
<li>支持HTTP/1.0中的KEEP-Alive模式和管线(PipeLined)模型连接</li>
<li>自定义访问日志格式、带缓存的日志写操作以及快速日志轮转。</li>
<li>提供3xx~5xx错误代码重定向功能</li>
<li>支持重写（Rewrite)模块扩展</li>
<li>支持重新加载配置以及在线升级时无需中断正在处理的请求</li>
<li>支持网络监控</li>
<li>支持FLV和MP4流媒体传输</li>
</ul>
<h3 id="邮件服务"><a class="header-anchor" href="#邮件服务">¶</a>邮件服务</h3>
<p>Nginx提供邮件代理服务也是其基本开发需求之一，主要包含以下特性：</p>
<ul>
<li>支持IMPA/POP3代理服务功能</li>
<li>支持内部SMTP代理服务功能</li>
</ul>
<h3 id="Nginx常用的功能模块"><a class="header-anchor" href="#Nginx常用的功能模块">¶</a>Nginx常用的功能模块</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">静态资源部署<br>Rewrite地址重写<br>	正则表达式<br>反向代理<br>负载均衡<br>	轮询、加权轮询、ip_hash、url_hash、fair<br>Web缓存<br>环境部署<br>	高可用的环境<br>用户认证模块...<br></code></pre></td></tr></tbody></table></figure>
<h3 id="Nginx的核心组成"><a class="header-anchor" href="#Nginx的核心组成">¶</a>Nginx的核心组成</h3>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">nginx二进制可执行文件<br>nginx.conf配置文件<br>error.log错误的日志记录<br>access.log访问日志记录<br></code></pre></td></tr></tbody></table></figure>
<h1 id="二、Nginx环境准备"><a class="header-anchor" href="#二、Nginx环境准备">¶</a>二、Nginx环境准备</h1>
<h2 id="1、Nginx版本介绍"><a class="header-anchor" href="#1、Nginx版本介绍">¶</a>1、Nginx版本介绍</h2>
<blockquote>
<p>Nginx的官方网站为: <a target="_blank" rel="noopener external nofollow noreferrer" href="https://nginx.org">https://nginx.org</a>，Nginx的官方下载网站为 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@f1e9cf806c80f7c0e1fb76d6000e46f4f0befc9e/2021/09/16/faabf427d59ad1b9e22b128c1d6bd154.png" alt=""></p>
<h2 id="2、获取Nginx源码"><a class="header-anchor" href="#2、获取Nginx源码">¶</a>2、获取Nginx源码</h2>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://nginx.org/download/">http://nginx.org/download/</a> 打开上述网站，就可以查看到Nginx的所有版本，选中自己需要的版本进行下载。</p>
<h2 id="3、准备服务器系统"><a class="header-anchor" href="#3、准备服务器系统">¶</a>3、准备服务器系统</h2>
<p><strong>确认centos的内核：</strong></p>
<p>准备一个内核为2.6及以上版本的操作系统，因为linux2.6及以上内核才支持<strong>epoll</strong>,而Nginx需要解决高并发压力问题是需要用到epoll，所以我们需要有这样的版本要求。</p>
<p>我们可以使用<code>uname -a</code>命令来查询linux的内核版本。</p>
<p><strong>确认停用selinux：</strong></p>
<p>selinux(security-enhanced linux),美国安全局对于强制访问控制的实现，在linux2.6内核以后的版本中，selinux已经成功内核中的一部分。可以说selinux是linux史上最杰出的新安全子系统之一。虽然有了selinux，我们的系统会更安全，但是对于我们的学习Nginx的历程中，会多很多设置，所以这块建议大家将selinux进行关闭。</p>
<p><strong>sestatus查看状态：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@30451a46a7c2adef2536424af0eee600d2fc7003/2021/09/16/11c9857b57d50fa58a8ae3f9725d9818.png" alt=""></p>
<p>如果查看不是disabled状态，我们可以通过修改配置文件来进行设置,修改SELINUX=disabled，然后<strong>重启</strong>下系统即可生效。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/selinux/config<br></code></pre></td></tr></tbody></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@6dec769908aaa24cb45515e47364831b2f137c6e/2021/09/16/a0ed8186be0b4aee192c1445a2fcf55c.png" alt=""></p>
<h2 id="4、Nginx安装方式即依赖介绍"><a class="header-anchor" href="#4、Nginx安装方式即依赖介绍">¶</a>4、Nginx安装方式即依赖介绍</h2>
<p><strong>Nginx的安装方式有两种分别是:</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">通过Nginx源码<br>	通过Nginx源码简单安装 (1)<br>	通过Nginx源码复杂安装 (3)<br>通过yum安装 (2)<br></code></pre></td></tr></tbody></table></figure>
<p><strong>如果通过Nginx源码安装需要提前安装以下依赖：</strong></p>
<p><strong>GCC编译器：</strong></p>
<p>Nginx是使用C语言编写的程序，因此想要运行Nginx就需要安装一个编译工具。GCC就是一个开源的编译器集合，用于处理各种各样的语言，其中就包含了C语言。</p>
<p>使用命令<code>yum install -y gcc</code>来安装</p>
<p>安装成功后，可以通过<code>gcc --version</code>来查看gcc是否安装成功</p>
<p><strong>PCRE：</strong></p>
<p>Nginx在编译过程中需要使用到PCRE库（perl Compatible Regular Expressoin 兼容正则表达式库)，因为在Nginx的Rewrite模块和http核心模块都会使用到PCRE正则表达式语法。</p>
<p>可以使用命令<code>yum install -y pcre pcre-devel</code>来进行安装</p>
<p>安装成功后，可以通过<code>rpm -qa pcre pcre-devel</code>来查看是否安装成功</p>
<p><strong>zlib：</strong></p>
<p>zlib库提供了开发人员的压缩算法，在Nginx的各个模块中需要使用gzip压缩，所以我们也需要提前安装其库及源代码zlib和zlib-devel</p>
<p>可以使用命令<code>yum install -y zlib zlib-devel</code>来进行安装</p>
<p>安装成功后，可以通过<code>rpm -qa zlib zlib-devel</code>来查看是否安装成功</p>
<p><strong>OpenSSL：</strong></p>
<p>OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包进行安全通信，并且避免被窃听。</p>
<p>SSL：Secure Sockets Layer安全套接协议的缩写，可以在Internet上提供秘密性传输，其目标是保证两个应用间通信的保密性和可靠性。在Nginx中，如果服务器需要提供安全网页时就需要用到OpenSSL库，所以我们需要对OpenSSL的库文件及它的开发安装包进行一个安装。</p>
<p>可以使用命令<code>yum install -y openssl openssl-devel</code>来进行安装</p>
<p>安装成功后，可以通过<code>rpm -qa openssl openssl-devel</code>来查看是否安装成功</p>
<p><strong>上述命令，一个个来的话比较麻烦，我们也可以通过一条命令来进行安装：</strong></p>
<p><code>yum install -y gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel</code>进行全部安装。</p>
<h2 id="5、Nginx的源码简单安装"><a class="header-anchor" href="#5、Nginx的源码简单安装">¶</a>5、Nginx的源码简单安装</h2>
<p>1、进入官网查找需要下载版本的链接地址，然后使用wget命令进行下载</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget http://nginx.org/download/nginx-1.16.1.tar.gz<br></code></pre></td></tr></tbody></table></figure>
<p>2、建议大家将下载的资源进行包管理</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p nginx/coremv nginx-1.16.1.tar.gz nginx/core<br></code></pre></td></tr></tbody></table></figure>
<p>3、解压缩</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xzf nginx-1.16.1.tar.gz<br></code></pre></td></tr></tbody></table></figure>
<p>4、进入资源文件中，发现configure</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./configure<br></code></pre></td></tr></tbody></table></figure>
<p>5、编译</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make &amp;&amp; make install<br></code></pre></td></tr></tbody></table></figure>
<h2 id="6、yum安装"><a class="header-anchor" href="#6、yum安装">¶</a>6、yum安装</h2>
<blockquote>
<p>使用源码进行简单安装，我们会发现安装的过程比较繁琐，需要提前准备GCC编译器、PCRE兼容正则表达式库、zlib压缩库、OpenSSL安全通信的软件库包，然后才能进行Nginx的安装。官方文档yum安装介绍：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://nginx.org/en/linux_packages.html#RHEL-CentOS">https://nginx.org/en/linux_packages.html#RHEL-CentOS</a></p>
</blockquote>
<p>1、安装yum-utils</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum  install -y yum-utils<br></code></pre></td></tr></tbody></table></figure>
<p>2、添加yum源文件</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/yum.repos.d/nginx.repo<br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">[nginx-stable]<br>name=nginx stable repo<br>baseurl=http://nginx.org/packages/centos/<span class="hljs-variable">$releasever</span>/<span class="hljs-variable">$basearch</span>/<br>gpgcheck=1<br>enabled=1<br>gpgkey=https://nginx.org/keys/nginx_signing.key<br>module_hotfixes=<span class="hljs-literal">true</span><br><br>[nginx-mainline]<br>name=nginx mainline repo<br>baseurl=http://nginx.org/packages/mainline/centos/<span class="hljs-variable">$releasever</span>/<span class="hljs-variable">$basearch</span>/<br>gpgcheck=1<br>enabled=0<br>gpgkey=https://nginx.org/keys/nginx_signing.key<br>module_hotfixes=<span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure>
<p>3、查看是否配置成功</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum list | grep nginx<br></code></pre></td></tr></tbody></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@34476a5bbbc826991fe24a483b8e70996b31b0db/2021/09/16/7c116b2a4016c50cb953aff8a766c000.png" alt=""></p>
<p>4、使用yum进行安装</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yun install -y nginx<br></code></pre></td></tr></tbody></table></figure>
<p>5、查看nginx的安装位置</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">whereis nginx<br></code></pre></td></tr></tbody></table></figure>
<h2 id="7、源码简单安装和yum安装的差异"><a class="header-anchor" href="#7、源码简单安装和yum安装的差异">¶</a>7、源码简单安装和yum安装的差异</h2>
<p>这里先介绍一个命令: <code>./nginx -V</code>, 通过该命令可以查看到所安装Nginx的版本及相关配置信息。</p>
<p><strong>简单安装：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@43dfde146a7c4cb8f4941d63b0d97352c60f0f2b/2021/09/16/29e58d90d91cfc66e26d97838e2c6b5b.png" alt=""></p>
<p><strong>yum安装：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@c406d847041a19468e4bf4c19a26f80fefa1ac94/2021/09/21/3c22b1e1dbb518c9b3c8d1d4eb58f717.png" alt=""></p>
<h2 id="8、Nginx的源码复杂安装"><a class="header-anchor" href="#8、Nginx的源码复杂安装">¶</a>8、Nginx的源码复杂安装</h2>
<p>这种方式和简单的安装配置不同的地方在第一步，通过<code>./configure</code>来对编译参数进行设置，需要我们手动来指定。那么都有哪些参数可以进行设置，接下来我们进行一个详细的说明。</p>
<p><strong><code>·/configure --help</code>可以获得一些配置项参数：</strong></p>
<ul>
<li>PATH：是和路径相关的配置信息</li>
<li>with：是启动模块，默认是关闭的</li>
<li>without：是关闭模块，默认是开启的</li>
</ul>
<p><strong>一些简单的路径配置已经通过这些配置来完成一个简单的编译：</strong></p>
<p>–prefix=PATH</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">指向Nginx的安装目录，默认值为/usr/local/nginx   <br></code></pre></td></tr></tbody></table></figure>
<p>–sbin-path=PATH</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">指向(执行)程序文件(nginx)的路径,默认值为&lt;prefix&gt;/sbin/nginx<br></code></pre></td></tr></tbody></table></figure>
<p>–modules-path=PATH</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">指向Nginx动态模块安装目录，默认值为&lt;prefix&gt;/modules<br></code></pre></td></tr></tbody></table></figure>
<p>–conf-path=PATH</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">指向配置文件(nginx.conf)的路径,默认值为&lt;prefix&gt;/conf/nginx.conf<br></code></pre></td></tr></tbody></table></figure>
<p>–error-log-path=PATH</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">指向错误日志文件的路径,默认值为&lt;prefix&gt;/logs/error.log<br></code></pre></td></tr></tbody></table></figure>
<p>–http-log-path=PATH</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">指向访问日志文件的路径,默认值为&lt;prefix&gt;/logs/access.log<br></code></pre></td></tr></tbody></table></figure>
<p>–pid-path=PATH</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">指向Nginx启动后进行ID的文件路径，默认值为&lt;prefix&gt;/logs/nginx.pid<br></code></pre></td></tr></tbody></table></figure>
<p>–lock-path=PATH</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">指向Nginx锁文件的存放路径,默认值为&lt;prefix&gt;/logs/nginx.lock<br></code></pre></td></tr></tbody></table></figure>
<p><strong>要想使用可以通过如下命令：</strong></p>
<p>这里的值就是源码简单安装的默认值！</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./configure --prefix=/usr/local/nginx \--sbin-path=/usr/local/nginx/sbin/nginx \--modules-path=/usr/local/nginx/modules \--conf-path=/usr/local/nginx/conf/nginx.conf \--error-log-path=/usr/local/nginx/logs/error.log \--http-log-path=/usr/local/nginx/logs/access.log \--pid-path=/usr/local/nginx/logs/nginx.pid \--lock-path=/usr/local/nginx/logs/nginx.lock<br></code></pre></td></tr></tbody></table></figure>
<p><strong>在使用上述命令之前，需要将之前服务器已经安装的nginx进行卸载，卸载的步骤分为三步骤：</strong></p>
<p>步骤一：需要将nginx的进程关闭</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./nginx -s stop<br></code></pre></td></tr></tbody></table></figure>
<p>步骤二：将安装的nginx进行删除</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf /usr/local/nginx<br></code></pre></td></tr></tbody></table></figure>
<p>步骤三：将安装包之前编译的环境清除掉</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make clean<br></code></pre></td></tr></tbody></table></figure>
<h2 id="9、解压Nginx目录介绍"><a class="header-anchor" href="#9、解压Nginx目录介绍">¶</a>9、解压Nginx目录介绍</h2>
<p>执行<code>tar -zxvf nginx-1.16.1.tar.gz</code>对下载的资源进行解压缩，进入压缩后的目录，可以看到如下结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@e8fa950a3e08f2ef9f7df4255ebd60ee75becf03/2021/09/16/ff532a9007e0c9f2bd5fb61374acf2c2.png" alt=""></p>
<p><strong>内容解释：</strong></p>
<p>auto：存放的是编译相关的脚本</p>
<p>CHANGES：版本变更记录</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://CHANGES.ru">CHANGES.ru</a>：俄罗斯文的版本变更记录</p>
<p>conf：默认的配置文件</p>
<p>configure：nginx软件的自动脚本程序,是一个比较重要的文件，作用如下：</p>
<ul>
<li>检测环境及根据环境检测结果生成C代码（会在当前目录下多一个objs文件夹）</li>
<li>生成编译代码需要的Makefile文件（会在当前目录下多一个Makefile文件）</li>
</ul>
<p>contrib：存放的是几个特殊的脚本文件，其中README中对脚本有着详细的说明</p>
<p>html：存放的是Nginx自带的两个html页面，访问Nginx的首页和错误页面</p>
<p>LICENSE：许可证的相关描述文件</p>
<p>man：nginx的man手册</p>
<p>README：Nginx的阅读指南</p>
<p>src：Nginx的源代码</p>
<h2 id="10、Nginx目录结构分析"><a class="header-anchor" href="#10、Nginx目录结构分析">¶</a>10、Nginx目录结构分析</h2>
<p>在使用Nginx之前，我们先对安装好的Nginx目录文件进行一个分析，在这块给大家介绍一个工具tree，通过tree我们可以很方面的去查看centos系统上的文件目录结构，当然，如果想使用tree工具，就得先通过<code>yum install -y tree</code>来进行安装，安装成功后，可以通过执行<code>tree /usr/local/nginx</code>(tree后面跟的是Nginx的安装目录)，获取的结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@d30f7cc1285b3c562e6114e3603d8345b0152c03/2021/09/16/4d6cebf558f2f6bff2492d70372a1a9c.png" alt=""></p>
<p>conf：nginx所有配置文件目录</p>
<ul>
<li>
<p>CGI(Common Gateway Interface)<strong>通用网关【接口】</strong>，主要解决的问题是从客户端发送一个请求和数据，服务端获取到请求和数据后可以调用调用CGI【程序】处理及相应结果给客户端的一种标准规范。</p>
</li>
<li>
<p>fastcgi.conf：fastcgi相关配置文件</p>
</li>
<li>
<p>fastcgi.conf.default：fastcgi.conf的备份文件</p>
</li>
<li>
<p>fastcgi_params：fastcgi的参数文件</p>
</li>
<li>
<p>fastcgi_params.default：fastcgi的参数备份文件</p>
</li>
<li>
<p>scgi_params：scgi的参数文件</p>
</li>
<li>
<p>scgi_params.default：scgi的参数备份文件</p>
</li>
<li>
<p>uwsgi_params：uwsgi的参数文件</p>
</li>
<li>
<p>uwsgi_params.default：uwsgi的参数备份文件</p>
</li>
<li>
<p>mime.types：记录的是HTTP协议中的Content-Type的值和文件后缀名的对应关系</p>
</li>
<li>
<p>mime.types.default：mime.types的备份文件</p>
</li>
<li>
<p>nginx.conf：这个是Nginx的核心配置文件，这个文件非常重要，也是我们即将要学习的重点</p>
</li>
<li>
<p>nginx.conf.default：nginx.conf的备份文件</p>
</li>
<li>
<p>koi-utf、koi-win、win-utf：这三个文件都是与编码转换映射相关的配置文件，用来将一种编码转换成另一种编码</p>
</li>
</ul>
<p>html：存放nginx自带的两个静态的html页面</p>
<ul>
<li>50x.html：访问失败后的失败页面</li>
<li>index.html：成功访问的默认首页</li>
</ul>
<p>logs：记录入门的文件，当nginx服务器启动后，这里面会有 access.log error.log 和 nginx.pid 三个文件出现。</p>
<p>sbin：是存放执行程序文件nginx。nginx是用来控制Nginx的启动和停止等相关的命令。</p>
<h2 id="11、Nginx服务器启停命令"><a class="header-anchor" href="#11、Nginx服务器启停命令">¶</a>11、Nginx服务器启停命令</h2>
<p>Nginx安装完成后，接下来我们要学习的是如何启动、重启和停止Nginx的服务。</p>
<p>对于Nginx的启停在linux系统中也有很多种方式：</p>
<ol>
<li>Nginx服务的信号控制</li>
<li>Nginx的命令行控制</li>
</ol>
<h3 id="Nginx服务的信号控制"><a class="header-anchor" href="#Nginx服务的信号控制">¶</a>Nginx服务的信号控制</h3>
<p>前面在提到Nginx的高性能，其实也和它的架构模式有关。Nginx默认采用的是多进程的方式来工作的，当将Nginx启动后，我们通过<code>ps -ef | grep nginx</code>命令可以查看到如下内容：</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@39f911ca172882f6e708f961408bbd57786a17b6/2021/09/16/a2099b81c551d9bd9f3122701abf9c53.png" alt=""></p>
<p>从上图中可以看到,Nginx后台进程中包含<strong>一个master进程和多个worker进程</strong>。</p>
<p>master进程主要用来管理worker进程，包含接收外界的信息，并将接收到的信号发送给各个worker进程，监控worker进程的状态，当worker进程出现异常退出后，会自动重新启动新的worker进程。</p>
<p>而worker进程则是专门用来处理用户请求的，各个worker进程之间是平等的并且相互独立，处理请求的机会也是一样的。nginx的进程模型，我们可以通过下图来说明下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@ff89023316675a88efc090a3aacf557c959932fa/2021/09/16/8406abf39a0de70f1baeb77cd7fb58b8.png" alt=""></p>
<p><strong>我们现在作为管理员，只需要通过给master进程发送信号就可以来控制Nginx，这个时候我们需要有两个前提条件，一个是要操作的master进程，一个是信号。</strong></p>
<p>1、要想操作Nginx的master进程，就需要获取到master进程的进程号ID。获取方式简单介绍两个，</p>
<p>方式一：通过<code>ps -ef | grep nginx</code>；</p>
<p>方式二：在讲解nginx的<code>./configure</code>的配置参数的时候，有一个参数是<code>--pid-path=PATH</code>默认是<code>/usr/local/nginx/logs/nginx.pid</code>,所以可以通过查看该文件来获取nginx的master进程ID.</p>
<p>2、信号</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>TERM/INT</td>
<td>立即关闭整个服务</td>
</tr>
<tr>
<td>QUIT</td>
<td>"优雅"地关闭整个服务（等待worker处理完毕任务后再关闭）</td>
</tr>
<tr>
<td>HUP</td>
<td>重读配置文件并使用服务对新配置项生效</td>
</tr>
<tr>
<td>USR1</td>
<td>重新打开日志文件，可以用来进行日志切割</td>
</tr>
<tr>
<td>USR2</td>
<td>平滑升级到最新版的nginx</td>
</tr>
<tr>
<td>WINCH</td>
<td>所有子进程不在接收处理新连接，相当于给work进程发送QUIT指令</td>
</tr>
</tbody>
</table>
<p><strong>调用命令为<code>kill -signal PID</code></strong></p>
<p>signal：即为信号；PID即为获取到的master线程ID</p>
<ul>
<li>发送TERM/INT信号给master进程，会将Nginx服务立即关闭：</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -TERM PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`kill -INT PID / kill -INT `cat /usr/local/nginx/logs/nginx.pid`<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>发送QUIT信号给master进程，master进程会控制所有的work进程不再接收新的请求，等所有请求处理完后，在把进程都关闭掉：</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -QUIT PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>发送HUP信号给master进程，master进程会把控制旧的work进程不再接收新的请求，等处理完请求后将旧的work进程关闭掉，然后根据nginx的配置文件重新启动新的work进程：</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -HUP PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>发送USR1信号给master进程，告诉Nginx重新开启日志文件</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -USR1 PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>发送USR2信号给master进程，告诉master进程要平滑升级，这个时候，会重新开启对应的master进程和work进程，整个系统中将会有两个master进程，并且新的master进程的PID会被记录在<code>/usr/local/nginx/logs/nginx.pid</code>而之前的旧的master进程PID会被记录在<code>/usr/local/nginx/logs/nginx.pid.oldbin</code>文件中，接着再次发送QUIT信号给旧的master进程，让其处理完请求后再进行关闭</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -USR2 PID / kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`<br><br>kill -QUIT PID / kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>发送WINCH信号给master进程,让master进程控制不让所有的work进程在接收新的请求了，请求处理完后关闭work进程。注意master进程不会被关闭掉</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">kill -WINCH PID /kill -WINCH`cat /usr/local/nginx/logs/nginx.pid`<br></code></pre></td></tr></tbody></table></figure>
<h3 id="Nginx的命令行控制"><a class="header-anchor" href="#Nginx的命令行控制">¶</a>Nginx的命令行控制</h3>
<p>此方式是通过Nginx安装目录下的sbin下的可执行文件nginx来进行Nginx状态的控制，我们可以通过<code>nginx -h</code>来查看都有哪些参数可以用：</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@a1abe9bce2f69b726f2ce0c00493bb99ae3f9188/2021/09/16/e1436331505fbc1e8843dd8ef56d98fb.png" alt=""></p>
<p>-?和-h：显示帮助信息</p>
<p>-v：打印版本号信息并退出</p>
<p>-V：打印版本号信息和配置信息并退出</p>
<p><strong>-t：测试nginx的配置文件语法是否正确并退出</strong></p>
<p>-T：测试nginx的配置文件语法是否正确并列出用到的配置文件信息然后退出</p>
<p>-q：在配置测试期间禁止显示非错误消息</p>
<p><strong>-s：signal信号，后面可以添加</strong></p>
<ul>
<li>stop：快速关闭，类似于TERM/INT信号的作用</li>
<li>quit：优雅的关闭，类似于QUIT信号的作用</li>
<li>reopen：重新打开日志文件类似于USR1信号的作用</li>
<li>reload：类似于HUP信号的作用</li>
</ul>
<p>-p：prefix，指定Nginx的prefix路径，(默认为: /usr/local/nginx/)</p>
<p>-c：filename,指定Nginx的配置文件路径,(默认为: /usr/local/nginx/conf/nginx.conf)</p>
<p>-g：用来补充Nginx配置文件，向Nginx服务指定启动时应用全局的配置</p>
<h2 id="12、Nginx服务器版本升级和新增模块"><a class="header-anchor" href="#12、Nginx服务器版本升级和新增模块">¶</a>12、Nginx服务器版本升级和新增模块</h2>
<p>如果想对Nginx的版本进行更新，或者要应用一些新的模块，最简单的做法就是停止当前的Nginx服务，然后开启新的Nginx服务。但是这样会导致在一段时间内，用户是无法访问服务器。为了解决这个问题，我们就需要用到Nginx服务器提供的<strong>平滑升级功能</strong>。这个也是Nginx的一大特点，使用这种方式，就可以使Nginx在7*24小时不间断的提供服务了。接下来我们分析下需求：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">需求：Nginx的版本最开始使用的是Nginx-1.14.2,由于服务升级，需要将Nginx的版本升级到Nginx-1.16.1,要求Nginx不能中断提供服务。<br></code></pre></td></tr></tbody></table></figure>
<p><strong>为了应对上述的需求，提供两种解决方案:</strong></p>
<ol>
<li>使用Nginx服务信号完成Nginx的升级</li>
<li>使用Nginx安装目录的make命令完成升级</li>
</ol>
<p><strong>环境准备：</strong></p>
<p>1、先准备两个版本的Nginx分别是 1.14.2和1.16.1</p>
<p>2、使用Nginx源码安装的方式将1.14.2版本安装成功并正确访问</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">进入安装目录./configuremake &amp;&amp; make install<br></code></pre></td></tr></tbody></table></figure>
<p>3、将Nginx1.16.1进行参数配置和编译，<strong>不需要进行安装。</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">进入安装目录./configuremake <br></code></pre></td></tr></tbody></table></figure>
<h3 id="使用Nginx服务信号进行升级"><a class="header-anchor" href="#使用Nginx服务信号进行升级">¶</a>使用Nginx服务信号进行升级</h3>
<p>1、将1.14.2版本的sbin目录下的nginx进行备份</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/sbinmv nginx nginxold<br></code></pre></td></tr></tbody></table></figure>
<p>2、将Nginx1.16.1安装目录编译后的objs目录下的nginx文件，拷贝到原来<code>/usr/local/nginx/sbin</code>目录下</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/nginx/core/nginx-1.16.1/objscp nginx /usr/local/nginx/sbin<br></code></pre></td></tr></tbody></table></figure>
<p>3、发送信号USR2给Nginx的1.14.2版本对应的master进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -USR2 `more /usr/local/logs/nginx.pid.oldbin`<br></code></pre></td></tr></tbody></table></figure>
<p>4、发送信号QUIT给Nginx的1.14.2版本对应的master进程</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -QUIT `more /usr/local/logs/nginx.pid.oldbin`<br></code></pre></td></tr></tbody></table></figure>
<h3 id="使用Nginx安装目录的make命令完成升级"><a class="header-anchor" href="#使用Nginx安装目录的make命令完成升级">¶</a>使用Nginx安装目录的make命令完成升级</h3>
<p>1、将1.14.2版本的sbin目录下的nginx进行备份</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/sbinmv nginx nginxold<br></code></pre></td></tr></tbody></table></figure>
<p>2、将Nginx1.16.1安装目录编译后的objs目录下的nginx文件，拷贝到原来<code>/usr/local/nginx/sbin</code>目录下</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/nginx/core/nginx-1.16.1/objscp nginx /usr/local/nginx/sbin<br></code></pre></td></tr></tbody></table></figure>
<p>3、进入到安装目录，执行<code>make upgrade</code></p>
<p>会发现其实底层使用的也是信号控制的！</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@4938e4e8e2885e332acee4d7c7d256edde4af890/2021/09/16/7fdc4a32ea1137c5601ce51b0e1c1c62.png" alt=""></p>
<p>4、查看是否更新成功</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./nginx -v<br></code></pre></td></tr></tbody></table></figure>
<h1 id="三、Nginx核心配置文件结构"><a class="header-anchor" href="#三、Nginx核心配置文件结构">¶</a>三、Nginx核心配置文件结构</h1>
<p>Nginx的核心配置文件默认位置：<code>/usr/local/nginx/conf/nginx.conf</code></p>
<h2 id="1、配置文件介绍"><a class="header-anchor" href="#1、配置文件介绍">¶</a>1、配置文件介绍</h2>
<p><strong>读取Nginx自带的Nginx配置文件，我们将其中的注释部分删除掉后，就剩下下面内容：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">worker_processes  1;<br><br>events {<br>    worker_connections  1024;<br>}<br><br>http {<br>    include       mime.types;<br>    default_type  application/octet-stream;<br>    sendfile        on;<br>    keepalive_timeout  65;<br><br>    server {<br>        listen       80;<br>        server_name  localhost;<br>        location / {<br>            root   html;<br>            index  index.html index.htm;<br>        }<br>        error_page   500 502 503 504  /50x.html;<br>        location = /50x.html {<br>            root   html;<br>        }<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>简单小结下：</strong></p>
<ul>
<li>nginx.conf配置文件中默认有三大块：全局块、events块、http块</li>
<li>http块中可以配置多个server块，每个server块又可以配置多个location块。</li>
</ul>
<h2 id="2、全局块"><a class="header-anchor" href="#2、全局块">¶</a>2、全局块</h2>
<h3 id="user指令"><a class="header-anchor" href="#user指令">¶</a>user指令</h3>
<p><strong>user用于配置运行Nginx服务器的worker进程的用户和用户组。</strong></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>user user [group]</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>nobody</td>
</tr>
<tr>
<td>位置</td>
<td>全局块</td>
</tr>
</tbody>
</table>
<p>该属性也可以在编译的时候指定，语法如下<code>./configure --user=user --group=group</code>,如果两个地方都进行了设置，最终生效的是配置文件中的配置。</p>
<p>该指令的使用步骤:</p>
<p>1、设置一个用户信息"www"</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">user www;<br></code></pre></td></tr></tbody></table></figure>
<p>此时使用命令<code>./nginx -t</code>检查会发现报错，原因是本机目前还没有www用户！</p>
<p>2、Linux创建一个用户</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd www<br></code></pre></td></tr></tbody></table></figure>
<p>3、创建<code>/root/html/index.html</code>页面，添加如下内容</p>
<p>4、修改nginx.conf</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">location / {<br>	root   /root/html;<br>	index  index.html index.htm;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>5、测试启动访问</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">页面会报403拒绝访问的错误，因为当前用户没有访问/root/html目录的权限<br></code></pre></td></tr></tbody></table></figure>
<p>6、将文件创建到 <code>/home/www/html/index.html</code>,修改配置</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">location / {<br>	root   /home/www/html;<br>	index  index.html index.htm;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>7、再次测试正常启动访问</p>
<p><strong>综上所述，使用user指令可以指定启动运行工作进程的用户及用户组，这样对于系统的权限访问控制的更加精细，也更加安全。</strong></p>
<h3 id="work-process指令"><a class="header-anchor" href="#work-process指令">¶</a>work process指令</h3>
<p>master_process：用来指定是否开启工作进程。（<strong>修改该值需要重启nginx</strong>）</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>master_process on|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>master_process on;</td>
</tr>
<tr>
<td>位置</td>
<td>全局块</td>
</tr>
</tbody>
</table>
<p>worker_processes：用于配置Nginx生成工作进程的数量，这个是Nginx服务器实现并发处理服务的关键所在。理论上来说workder process的值越大，可以支持的并发处理量也越多，但事实上这个值的设定是需要受到来自服务器自身的限制，<strong>建议将该值和服务器CPU的内核数保存一致。</strong></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>worker_processes     num/auto;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>1</td>
</tr>
<tr>
<td>位置</td>
<td>全局块</td>
</tr>
</tbody>
</table>
<p>如果将worker_processes设置成2，则会看到如下内容:</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@6c298c31dc1c41e6ef8ded39953f4a778f5a7dce/2021/09/16/707c7455d265e40b0f8b57cb4674be3c.png" alt=""></p>
<h3 id="其他指令"><a class="header-anchor" href="#其他指令">¶</a>其他指令</h3>
<p>1、daemon：设定Nginx是否以守护进程的方式启动。</p>
<p>守护式进程是linux后台执行的一种服务进程，特点是独立于控制终端，不会随着终端关闭而停止。（<strong>也需要重启生效</strong>）</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>daemon on|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>daemon on;</td>
</tr>
<tr>
<td>位置</td>
<td>全局块</td>
</tr>
</tbody>
</table>
<p>2、pid：用来配置Nginx当前master进程的进程号ID存储的文件路径。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>pid file;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>默认为:/usr/local/nginx/logs/nginx.pid</td>
</tr>
<tr>
<td>位置</td>
<td>全局块</td>
</tr>
</tbody>
</table>
<p>该属性可以通过<code>./configure --pid-path=PATH</code>来指定</p>
<p>3、error_log：用来配置Nginx的错误日志存放路径</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>error_log  file [日志级别];</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>error_log logs/error.log error;</td>
</tr>
<tr>
<td>位置</td>
<td>全局块、http、server、location</td>
</tr>
</tbody>
</table>
<p>该属性可以通过<code>./configure --error-log-path=PATH</code>来指定</p>
<p>其中日志级别的值有：debug|info|notice|warn|error|crit|alert|emerg，翻译过来为试|信息|通知|警告|错误|临界|警报|紧急，这块建议大家设置的时候不要设置成info以下的等级，因为会带来大量的磁盘I/O消耗，影响Nginx的性能。</p>
<p>4、include：用来引入其他配置文件，使Nginx的配置更加灵活</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>include file;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>无</td>
</tr>
<tr>
<td>位置</td>
<td>any</td>
</tr>
</tbody>
</table>
<h2 id="3、events块"><a class="header-anchor" href="#3、events块">¶</a>3、events块</h2>
<p>1、accept_mutex：用来设置Nginx网络连接序列化</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>accept_mutex on|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>accept_mutex on;</td>
</tr>
<tr>
<td>位置</td>
<td>events</td>
</tr>
</tbody>
</table>
<p>这个配置主要可以用来解决常说的**"惊群"<strong>问题。大致意思是在某一个时刻，客户端发来一个请求连接，Nginx后台是以多进程的工作模式，也就是说有</strong>多个worker进程会被同时唤醒，但是最终只会有一个进程可以获取到连接**，如果每次唤醒的进程数目太多，就会影响Nginx的整体性能。如果将上述值设置为on(开启状态)，将会对多个Nginx进程接收连接进行序列号，一个个来唤醒接收，就防止了多个进程对连接的争抢。（高并发时关闭更好！）</p>
<p>2、multi_accept：用来设置是否允许同时接收多个网络连接</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>multi_accept on|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>multi_accept off;</td>
</tr>
<tr>
<td>位置</td>
<td>events</td>
</tr>
</tbody>
</table>
<p>如果multi_accept被禁止了，nginx一个工作进程只能同时接受一个新的连接。否则，一个工作进程可以同时接受所有的新连接</p>
<p>3、worker_connections：用来配置单个worker进程最大的连接数</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>worker_connections number;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>worker_commections 512;</td>
</tr>
<tr>
<td>位置</td>
<td>events</td>
</tr>
</tbody>
</table>
<p>这里的连接数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数。另外，number值不能大于操作系统支持打开的最大文件句柄数量。</p>
<p>4、use：用来设置Nginx服务器选择哪种事件驱动来处理网络消息。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>use  method;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>根据操作系统定</td>
</tr>
<tr>
<td>位置</td>
<td>events</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：此处所选择事件处理模型是Nginx优化部分的一个重要内容，method的可选值有select/poll/epoll/kqueue等，之前在准备centos环境的时候，我们强调过要使用linux内核在2.6以上，就是为了能使用<strong>epoll函数来优化Nginx</strong>。</p>
<p>另外这些值的选择，我们也可以在编译的时候使用</p>
<p><code>--with-select_module</code>、<code>--without-select_module</code>、</p>
<p><code> --with-poll_module</code>、<code> --without-poll_module</code></p>
<p>来设置是否需要将对应的事件驱动模块编译到Nginx的内核。</p>
<p><strong>events指令配置实例：</strong></p>
<p>打开Nginx的配置文件 nginx.conf,添加如下配置</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">events{<br>	accept_mutex on;<br>	multi_accept on;<br>	worker_commections 1024;<br>	use epoll;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>启动测试</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">./nginx -t<br>./nginx -s reload<br></code></pre></td></tr></tbody></table></figure>
<h2 id="4、http块"><a class="header-anchor" href="#4、http块">¶</a>4、http块</h2>
<p><strong>MIME-Type：</strong></p>
<p>我们都知道浏览器中可以显示的内容有HTML、XML、GIF等种类繁多的文件、媒体等资源，浏览器为了区分这些资源，就需要使用MIME Type。所以说MIME Type是网络资源的媒体类型。Nginx作为web服务器，也需要能够识别前端请求的资源类型。</p>
<p><strong>在Nginx的配置文件中，默认有两行配置：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">include mime.types;<br>default_type application/octet-stream;（表示是二进制流，浏览器会下载该文件）<br></code></pre></td></tr></tbody></table></figure>
<p><strong>default_type：用来配置Nginx响应前端请求默认的MIME类型。</strong></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>default_type mime-type;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>default_type text/plain；</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>在default_type之前还有一句<code>include mime.types</code>,include之前我们已经介绍过，相当于把mime.types文件中MIMT类型与相关类型文件的文件后缀名的对应关系加入到当前的配置文件中。</p>
<p><strong>举例来说明：</strong></p>
<p>有些时候请求某些接口的时候需要返回指定的文本字符串或者json字符串，如果逻辑非常简单或者干脆是固定的字符串，那么可以使用nginx快速实现，这样就不用编写程序响应请求了，可以减少服务器资源占用并且响应性能非常快。</p>
<p><strong>例子：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /get_text {<br><span class="hljs-meta">	#</span><span class="bash">这里也可以设置成text/plain</span><br><span class="hljs-meta">	#</span><span class="bash"> 二者区别：plain不会解析html标签，html会解析html标签</span><br>    default_type text/html;<br>    return 200 "&lt;h1&gt;this is nginx's text!&lt;/h1&gt;";<br>}<br>location /get_json{<br>    default_type application/json;<br>    return 200 '{"name":"TOM","age":18}';<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="5、自定义服务日志"><a class="header-anchor" href="#5、自定义服务日志">¶</a>5、自定义服务日志</h2>
<p>Nginx中日志的类型分access.log、error.log。</p>
<ul>
<li>access.log：用来记录用户所有的访问请求。</li>
<li>error.log：记录nginx本身运行时的错误信息，不会记录用户的访问请求。</li>
</ul>
<p>Nginx服务器支持对服务日志的格式、大小、输出等进行设置，需要使用到两个指令，分别是access_log和log_format指令。</p>
<p>1、access_log：用来设置用户访问日志的相关属性。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>access_log path[format[buffer=size]]</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>access_log logs/access.log combined;</td>
</tr>
<tr>
<td>位置</td>
<td><code>http</code>, <code>server</code>, <code>location</code></td>
</tr>
</tbody>
</table>
<p>2、log_format：用来指定日志的输出格式。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>log_format name [escape=default|json|none] string…;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>log_format combined “…”;</td>
</tr>
<tr>
<td>位置</td>
<td>http</td>
</tr>
</tbody>
</table>
<h2 id="6、其他配置指令"><a class="header-anchor" href="#6、其他配置指令">¶</a>6、其他配置指令</h2>
<p>1、sendfile：用来设置Nginx服务器是否使用sendfile()传输文件，该属性可以大大提高Nginx处理静态资源的性能</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>sendfile on|off；</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>sendfile off;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>2、keepalive_timeout：用来设置长连接的超时时间。</p>
<p><strong>为什么要使用keepalive？</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">我们都知道HTTP是一种无状态协议，客户端向服务端发送一个TCP请求，服务端响应完毕后断开连接。<br>如何客户端向服务端发送多个请求，每个请求都需要重新创建一次连接，效率相对来说比较多，使用keepalive模式，可以告诉服务器端在处理完一个请求后保持这个TCP连接的打开状态，若接收到来自这个客户端的其他请求，服务端就会利用这个未被关闭的连接，而不需要重新创建一个新连接，提升效率，但是这个连接也不能一直保持，这样的话，连接如果过多，也会是服务端的性能下降，这个时候就需要我们进行设置其的超时时间。<br></code></pre></td></tr></tbody></table></figure>
<table>
<thead>
<tr>
<th>语法</th>
<th>keepalive_timeout time;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>keepalive_timeout 75s;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>3、keepalive_requests：用来设置一个keep-alive连接使用的次数。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>keepalive_requests number;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>keepalive_requests 100;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<h2 id="7、server块和location块"><a class="header-anchor" href="#7、server块和location块">¶</a>7、server块和location块</h2>
<p>server块和location块，非常重要，后面介绍！</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>       listen       80;<br>       server_name  localhost;<br>       location / {<br>           root   html;<br>           index  index.html index.htm;<br>       }<br>      <br>       error_page   500 502 503 504 404  /50x.html;<br>       location = /50x.html {<br>           root   html;<br>       }<br>   }<br></code></pre></td></tr></tbody></table></figure>
<h1 id="四、Nginx服务器基础配置实例"><a class="header-anchor" href="#四、Nginx服务器基础配置实例">¶</a>四、Nginx服务器基础配置实例</h1>
<h2 id="1、目标需求"><a class="header-anchor" href="#1、目标需求">¶</a>1、目标需求</h2>
<p><strong>需求：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">（1）有如下访问：<br>	http://192.168.200.133:8081/server1/location1<br>		访问的是：index_sr1_location1.html<br>	http://192.168.200.133:8081/server1/location2<br>		访问的是：index_sr1_location2.html<br>	http://192.168.200.133:8082/server2/location1<br>		访问的是：index_sr2_location1.html<br>	http://192.168.200.133:8082/server2/location2<br>		访问的是：index_sr2_location2.html<br>（2）如果访问的资源不存在，<br>	返回自定义的404页面<br>（3）将/server1和/server2的配置使用不同的配置文件分割<br>	将文件放到/home/www/conf.d目录下，然后使用include进行合并<br>（4）为/server1和/server2各自创建一个访问日志文件<br></code></pre></td></tr></tbody></table></figure>
<p><strong>准备相关文件，目录如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@2fe604df11514859e6934fe62de2c5c3587578f1/2021/09/18/63fa0d0fddb32328ba5b37aa6067f4f5.png" alt=""></p>
<h2 id="2、配置内容"><a class="header-anchor" href="#2、配置内容">¶</a>2、配置内容</h2>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#全局块 begin##</span></span><br><span class="hljs-meta">#</span><span class="bash">配置允许运行Nginx工作进程的用户和用户组</span><br>user www;<br><span class="hljs-meta">#</span><span class="bash">配置运行Nginx进程生成的worker进程数</span><br>worker_processes 2;<br><span class="hljs-meta">#</span><span class="bash">配置Nginx服务器运行对错误日志存放的路径</span><br>error_log logs/error.log;<br><span class="hljs-meta">#</span><span class="bash">配置Nginx服务器允许时记录Nginx的master进程的PID文件路径和名称</span><br>pid logs/nginx.pid;<br><span class="hljs-meta">#</span><span class="bash">配置Nginx服务是否以守护进程方法启动</span><br><span class="hljs-meta">#</span><span class="bash">daemon on;</span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#全局块 end##</span></span><br><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#events块 begin##</span></span><br>events{<br><span class="hljs-meta">	#</span><span class="bash">设置Nginx网络连接序列化</span><br>	accept_mutex on;<br><span class="hljs-meta">	#</span><span class="bash">设置Nginx的worker进程是否可以同时接收多个请求</span><br>	multi_accept on;<br><span class="hljs-meta">	#</span><span class="bash">设置Nginx的worker进程最大的连接数</span><br>	worker_connections 1024;<br><span class="hljs-meta">	#</span><span class="bash">设置Nginx使用的事件驱动模型</span><br>	use epoll;<br>}<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#events块 end##</span></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#http块 start##</span></span><br>http{<br><span class="hljs-meta">	#</span><span class="bash">定义MIME-Type</span><br>	include mime.types;<br>	default_type application/octet-stream;<br><span class="hljs-meta">	#</span><span class="bash">配置允许使用sendfile方式运输</span><br>	sendfile on;<br><span class="hljs-meta">	#</span><span class="bash">配置连接超时时间</span><br>	keepalive_timeout 65;<br><span class="hljs-meta">	#</span><span class="bash">配置请求处理日志格式</span><br>	log_format server1 '===&gt;server1 access log';<br>	log_format server2 '===&gt;server2 access log';<br><span class="hljs-meta">	#</span><span class="bash"><span class="hljs-comment">#server块 开始##</span></span><br>	include /home/www/conf.d/*.conf;<br><span class="hljs-meta">	#</span><span class="bash"><span class="hljs-comment">#server块 结束##</span></span><br>}<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#http块 end##</span></span><br></code></pre></td></tr></tbody></table></figure>
<p><strong>server1.conf</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">server{<br><span class="hljs-meta">		#</span><span class="bash">配置监听端口和主机名称</span><br>		listen 8081;<br>		server_name localhost;<br><span class="hljs-meta">		#</span><span class="bash">配置请求处理日志存放路径</span><br>		access_log /home/www/myweb/server1/logs/access.log server1;<br><span class="hljs-meta">		#</span><span class="bash">配置错误页面</span><br>		error_page 404 /404.html;<br><span class="hljs-meta">		#</span><span class="bash">配置处理/server1/location1请求的location</span><br>		location /server1/location1{<br>			root /home/www/myweb;<br>			index index_sr1_location1.html;<br>		}<br><span class="hljs-meta">		#</span><span class="bash">配置处理/server1/location2请求的location</span><br>		location /server1/location2{<br>			root /home/www/myweb;<br>			index index_sr1_location2.html;<br>		}<br><span class="hljs-meta">		#</span><span class="bash">配置错误页面转向</span><br>		location = /404.html {<br>			root /home/www/myweb;<br>			index 404.html;<br>		}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>server2.conf</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">server{<br><span class="hljs-meta">		#</span><span class="bash">配置监听端口和主机名称</span><br>		listen 8082;<br>		server_name localhost;<br><span class="hljs-meta">		#</span><span class="bash">配置请求处理日志存放路径</span><br>		access_log /home/www/myweb/server2/logs/access.log server2;<br><span class="hljs-meta">		#</span><span class="bash">配置错误页面,对404.html做了定向配置</span><br>		error_page 404 /404.html;<br><span class="hljs-meta">		#</span><span class="bash">配置处理/server1/location1请求的location</span><br>		location /server2/location1{<br>			root /home/www/myweb;<br>			index index_sr2_location1.html;<br>		}<br><span class="hljs-meta">		#</span><span class="bash">配置处理/server2/location2请求的location</span><br>		location /server2/location2{<br>			root /home/www/myweb;<br>			index index_sr2_location2.html;<br>		}<br><span class="hljs-meta">		#</span><span class="bash">配置错误页面转向</span><br>		location = /404.html {<br>			root /home/www/myweb;<br>			index 404.html;<br>		}<br>	}<br></code></pre></td></tr></tbody></table></figure>
<h1 id="五、Nginx服务操作的问题"><a class="header-anchor" href="#五、Nginx服务操作的问题">¶</a>五、Nginx服务操作的问题</h1>
<blockquote>
<p>经过前面的操作，我们会发现，如果想要启动、关闭或重新加载nginx配置文件，都需要先进入到nginx的安装目录的sbin目录，然后使用nginx的二级制可执行文件来操作，相对来说操作比较繁琐，这块该如何优化？另外如果我们想把Nginx设置成随着服务器启动就自动完成启动操作。</p>
</blockquote>
<h2 id="1、Nginx配置成系统服务"><a class="header-anchor" href="#1、Nginx配置成系统服务">¶</a>1、Nginx配置成系统服务</h2>
<p>把Nginx应用服务设置成为系统服务，方便对Nginx服务的启动和停止等相关操作。</p>
<p><strong>在<code>/usr/lib/systemd/system</code>目录下添加nginx.service，内容如下:</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /usr/lib/systemd/system/nginx.service<br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=nginx web service<br>Documentation=http://nginx.org/en/docs/<br>After=network.target<br><br>[Service]<br>Type=forking<br>PIDFile=/usr/local/nginx/logs/nginx.pid<br>ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf<br>ExecStart=/usr/local/nginx/sbin/nginx<br>ExecReload=/usr/local/nginx/sbin/nginx -s reload<br>ExecStop=/usr/local/nginx/sbin/nginx -s stop<br>PrivateTmp=true<br><br>[Install]<br>WantedBy=default.target<br></code></pre></td></tr></tbody></table></figure>
<p><strong>添加完成后如果权限有问题需要进行权限设置：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 755 /usr/lib/systemd/system/nginx.service<br></code></pre></td></tr></tbody></table></figure>
<p><strong>使用系统命令来操作Nginx服务：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">启动: systemctl start nginx<br>停止: systemctl stop nginx<br>重启: systemctl restart nginx<br>重新加载配置文件: systemctl reload nginx<br>查看nginx状态: systemctl status nginx<br>开机启动: systemctl enable nginx<br></code></pre></td></tr></tbody></table></figure>
<h2 id="2、Nginx命令配置到系统环境"><a class="header-anchor" href="#2、Nginx命令配置到系统环境">¶</a>2、Nginx命令配置到系统环境</h2>
<p>Nginx安装目录下的二级制可执行文件<code>nginx</code>的很多命令，要想使用这些命令前提是需要进入sbin目录下才能使用，我们可以将该二进制可执行文件加入到系统的环境变量，这样的话在任何目录都可以使用nginx对应的相关命令。</p>
<p>1、修改<code>/etc/profile</code>文件</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/profile在最后一行添加export PATH=/usr/local/nginx/sbin:$PATH<br></code></pre></td></tr></tbody></table></figure>
<p>2、使之立即生效</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></tbody></table></figure>
<p>3、执行nginx命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -V<br></code></pre></td></tr></tbody></table></figure>
<h1 id="六、Nginx静态资源部署"><a class="header-anchor" href="#六、Nginx静态资源部署">¶</a>六、Nginx静态资源部署</h1>
<h2 id="1、Nginx静态资源概述"><a class="header-anchor" href="#1、Nginx静态资源概述">¶</a>1、Nginx静态资源概述</h2>
<p>上网去搜索访问资源对于我们来说并不陌生，通过浏览器发送一个HTTP请求实现从客户端发送请求到服务器端获取所需要内容后并把内容回显展示在页面的一个过程。这个时候，我们所请求的内容就分为两种类型，一类是静态资源、一类是动态资源。</p>
<ul>
<li><strong>静态资源</strong>即指在服务器端真实存在并且能直接拿来展示的一些文件，比如常见的html页面、css文件、js文件、图 片、视频等资源；</li>
<li><strong>动态资源</strong>即指在服务器端真实存在但是要想获取需要经过一定的业务逻辑处理，根据不同的条件展示在页面不同这 一部分内容，比如说报表数据展示、根据当前登录用户展示相关具体数据等资源；</li>
</ul>
<p><strong>Nginx处理静态资源的内容，我们需要考虑下面这几个问题：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">（1）静态资源的配置指令<br>（2）静态资源的配置优化<br>（3）静态资源的压缩配置指令<br>（4）静态资源的缓存处理<br>（5）静态资源的访问控制，包括跨域问题和防盗链问题<br></code></pre></td></tr></tbody></table></figure>
<h2 id="2、Nginx静态资源的配置指令"><a class="header-anchor" href="#2、Nginx静态资源的配置指令">¶</a>2、Nginx静态资源的配置指令</h2>
<h3 id="listen指令"><a class="header-anchor" href="#listen指令">¶</a>listen指令</h3>
<p><strong>listen：用来配置监听端口。</strong></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>listen address[:port] [default_server]…;<br>listen port [default_server]…;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>listen *:80 | *:8000</td>
</tr>
<tr>
<td>位置</td>
<td>server</td>
</tr>
</tbody>
</table>
<p>l<strong>isten设置几种方式：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">listen 127.0.0.1:8000; # listen localhost:8000 监听指定的IP和端口<br>listen 127.0.0.1;	# 监听指定IP的所有端口<br>listen 8000;	# 监听指定端口上的连接<br>listen *:8000;	# 监听指定端口上的连接<br></code></pre></td></tr></tbody></table></figure>
<p>default_server：是标识符，用来将此虚拟主机设置成默认主机。所谓的默认主机指的是如果没有匹配到对应的address:port，则会默认执行的。如果不指定默认使用的是第一个server。</p>
<p><strong>一个问题，server_name设置的是127.0.0.1，但是我们访问的是192内网地址，为何还能访问的到？</strong></p>
<p>因为default_server的默认值就是找第一个server的配置进行访问，即访问了server_name的配置！我们可以在listen后面添加default_server来指定默认server，即可以不按照第一个默认server去找！按照我们指定的顺序去访问！</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">server{<br>	listen 8080;<br>	server_name 127.0.0.1;<br>	location /{<br>		root html;<br>		index index.html;<br>	}<br>}<br>server{<br>	listen 8080 default_server;<br>	server_name localhost;<br>	default_type text/plain;<br>	return 444 'This is a error request';<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="server-name指令"><a class="header-anchor" href="#server-name指令">¶</a>server_name指令</h3>
<p>server_name：用来设置虚拟主机服务名称。127.0.0.1 、 localhost 、域名。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>server_name  name …;<br>name可以提供多个中间用空格分隔</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>server_name  “”;</td>
</tr>
<tr>
<td>位置</td>
<td>server</td>
</tr>
</tbody>
</table>
<p><strong>配置方式一：精确匹配</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	listen 80;<br>	server_name www.itcast.cn www.itheima.cn;<br>	...<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>配置方式二：使用通配符配置</strong></p>
<p>server_name中支持通配符"*", 但需要注意的是通配符不能出现在域名的中间，只能出现在首段或尾段，如：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	listen 80;<br>	server_name  *.itcast.cn	www.itheima.*;<br><span class="hljs-meta">	#</span><span class="bash"> www.itcast.cn abc.itcast.cn www.itheima.cn www.itheima.com</span><br><span class="hljs-meta">	#</span><span class="bash"> server_name www.*.cn www.itheima.c* 会报错！</span><br>	...<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>配置三：使用正则表达式配置</strong></p>
<p>server_name中可以使用正则表达式，并且使用<code>~</code>作为正则表达式字符串的开始标记。</p>
<p>配置如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 注意 ~后面不能加空格，括号可以取值</span><br>server{<br>        listen 80;<br>        server_name ~^www\.(\w+)\.com$;<br>        default_type text/plain;<br>        return 200 $1  $2 ..;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>匹配执行顺序</strong></p>
<blockquote>
<p>由于server_name指令支持通配符和正则表达式，因此在包含多个虚拟主机的配置文件中，可能会出现一个名称被多个虚拟主机的server_name匹配成功，当遇到这种情况，当前的请求交给谁来处理呢？</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plain">server{<br>	listen 80;<br>	server_name ~^www\.\w+\.com$;<br>	default_type text/plain;<br>	return 200 'regex_success';<br>}<br><br>server{<br>	listen 80;<br>	server_name www.itheima.*;<br>	default_type text/plain;<br>	return 200 'wildcard_after_success';<br>}<br><br>server{<br>	listen 80;<br>	server_name *.itheima.com;<br>	default_type text/plain;<br>	return 200 'wildcard_before_success';<br>}<br><br>server{<br>	listen 80;<br>	server_name www.itheima.com;<br>	default_type text/plain;<br>	return 200 'exact_success';<br>}<br><br>server{<br>	listen 80 default_server;<br>	server_name _;<br>	default_type text/plain;<br>	return 444 'default_server not found server';<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>结论：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">exact_success<br>wildcard_before_success<br>wildcard_after_success<br>regex_success<br>default_server not found server<br><br>No1:准确匹配server_name<br>No2:通配符在开始时匹配server_name成功<br>No3:通配符在结束时匹配server_name成功<br>No4:正则表达式匹配server_name成功<br>No5:被默认的default_server处理，如果没有指定默认找第一个server<br></code></pre></td></tr></tbody></table></figure>
<h3 id="location指令"><a class="header-anchor" href="#location指令">¶</a>location指令</h3>
<p>location：用来设置请求的URI</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>location [  =  |   ~  |  ~*   |   ^~   |@ ] uri{…}</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>server,location</td>
</tr>
</tbody>
</table>
<blockquote>
<p>uri变量是待匹配的请求字符串，可以不包含正则表达式，也可以包含正则表达式，那么nginx服务器在搜索匹配location的时候，是先使用不包含正则表达式进行匹配，找到一个匹配度最高的一个，然后在通过包含正则表达式的进行匹配，如果能匹配到直接访问，匹配不到，就使用刚才匹配度最高的那个location来处理请求。</p>
</blockquote>
<p><strong>不带符号，要求必须以指定模式开始：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	listen 80;<br>	server_name 127.0.0.1;<br>	location /abc{<br>		default_type text/plain;<br>		return 200 "access success";<br>	}<br>}<br>以下访问都是正确的<br>http://192.168.200.133/abc<br>http://192.168.200.133/abc?p1=TOM<br>http://192.168.200.133/abc/<br>http://192.168.200.133/abcdef<br></code></pre></td></tr></tbody></table></figure>
<p><strong><code>=</code> :  用于不包含正则表达式的uri前，必须与指定的模式精确匹配</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	listen 80;<br>	server_name 127.0.0.1;<br>	location =/abc{<br>		default_type text/plain;<br>		return 200 "access success";<br>	}<br>}<br>可以匹配到<br>http://192.168.200.133/abc<br>http://192.168.200.133/abc?p1=TOM<br>匹配不到<br>http://192.168.200.133/abc/<br>http://192.168.200.133/abcdef<br></code></pre></td></tr></tbody></table></figure>
<p><strong><code>~</code> ： 用于表示当前uri中包含了正则表达式，并且区分大小写</strong><br>
<strong><code>~*</code>:  用于表示当前uri中包含了正则表达式，并且不区分大小写</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	listen 80;<br>	server_name 127.0.0.1;<br>	location ~^/abc\w${<br>		default_type text/plain;<br>		return 200 "access success";<br>	}<br>}<br>server {<br>	listen 80;<br>	server_name 127.0.0.1;<br>	location ~*^/abc\w${<br>		default_type text/plain;<br>		return 200 "access success";<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong><code>^~</code>: 用于不包含正则表达式的uri前，功能和不加符号的一致，唯一不同的是，如果模式匹配，那么就停止搜索其他模式了。</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">server {<br>	listen 80;<br>	server_name 127.0.0.1;<br>	location ^~/abc{<br>		default_type text/plain;<br>		return 200 "access success";<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="root-alias指令"><a class="header-anchor" href="#root-alias指令">¶</a>root / alias指令</h3>
<p><strong>root：设置请求的根目录</strong></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>root path;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>root html;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>path为Nginx服务器接收到请求以后查找资源的根目录路径。</p>
<p><strong>alias：用来更改location的URI</strong></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>alias path;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>location</td>
</tr>
</tbody>
</table>
<p>path为修改后的根路径。</p>
<p><strong>以上两个指令都可以来指定访问资源的路径，那么这两者之间的区别是什么?</strong></p>
<p>在<code>/usr/local/nginx/html</code>目录下创建一个 images目录,并在目录下放入一张图片<code>mv.png</code>图片</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /images {<br>	root /usr/local/nginx/html;<br>}<br><span class="hljs-meta">#</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/nginx/html/images/mv.png</span><br><br><span class="hljs-meta">#</span><span class="bash"> root改为<span class="hljs-built_in">alias</span> 无法访问</span><br>location /images {<br>	alias /usr/local/nginx/html;<br>}<br><span class="hljs-meta">#</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/nginx/html/images</span><br></code></pre></td></tr></tbody></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li>root的处理结果是：root路径+location路径。</li>
<li>alias的处理结果是：使用alias路径替换location路径。</li>
<li>alias是一个目录别名的定义，root则是最上层目录的含义。</li>
<li>如果location路径是以/结尾，则alias也必须是以/结尾，root没有要求。（可以在error.log中查看日志得到访问的路径！）</li>
</ul>
<p><strong>解决：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 改为</span><br>location /images {<br>	alias /usr/local/nginx/html/images;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="index指令"><a class="header-anchor" href="#index指令">¶</a>index指令</h3>
<p>index：设置网站的默认首页。</p>
<p>index后面可以跟多个设置，如果访问的时候没有指定具体访问的资源，则会依次进行查找，找到第一个为止。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>index file …;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>index index.html;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>举例说明：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">location / {<br>	root /usr/local/nginx/html;<br>	index index.html index.htm;<br>}<br><span class="hljs-meta">#</span><span class="bash"> 访问该location的时候，可以通过 http://ip:port/，地址后面如果不添加任何内容，则默认依次访问index.html和index.htm，找到第一个来进行返回</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="error-page指令"><a class="header-anchor" href="#error-page指令">¶</a>error_page指令</h3>
<p>error_page：设置网站的错误页面。当出现对应的响应code后，如何来处理。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>error_page code … [=[response]] uri;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location…</td>
</tr>
</tbody>
</table>
<p>1、可以指定具体跳转的地址</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	error_page 404 http://www.itcast.cn;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>2、可以指定重定向地址</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">server{<br>	error_page 404 /50x.html;<br>	error_page 500 502 503 504 /50x.html;<br>	location =/50x.html{<br>		root html;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>3、使用location的@符合完成错误信息展示</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">server{<br>	error_page 404 @jump_to_error;<br>	location @jump_to_error {<br>		default_type text/plain;<br>		return 404 'Not Found Page...';<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>4、可选项<code>=[response]</code>的作用是用来将相应代码更改为另外一个</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 这样的话，当返回404找不到对应的资源的时候，在浏览器上可以看到，最终返回的状态码是200，这块需要注意下，编写error_page后面的内容，404后面需要加空格，200前面不能加空格</span><br>server{<br>	error_page 404 =200 /50x.html;<br>	location =/50x.html{<br>		root html;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3、静态资源优化配置语法"><a class="header-anchor" href="#3、静态资源优化配置语法">¶</a>3、静态资源优化配置语法</h2>
<h3 id="sendﬁle"><a class="header-anchor" href="#sendﬁle">¶</a>sendﬁle</h3>
<p>用来开启高效的文件传输模式。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>sendﬁle on |oﬀ;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>sendﬁle oﬀ;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location…</td>
</tr>
</tbody>
</table>
<p><strong>请求静态资源的过程：</strong></p>
<p><strong>使用了sendfile后少了进程切换和两次copy！http底层使用tcp，tcp使用socket传输！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@e7dc4bfcb9bec9a69bc35f73552d9dbe504e117e/2021/09/18/842789cb4052150cc14681587f6cff2f.png" alt=""></p>
<h3 id="tcp-nopush"><a class="header-anchor" href="#tcp-nopush">¶</a>tcp_nopush</h3>
<p>该指令必须在sendfile打开的状态下才会生效，主要是用来提升网络包的传输’效率’。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>tcp_nopush on|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>tcp_nopush oﬀ;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<h3 id="tcp-nodelay"><a class="header-anchor" href="#tcp-nodelay">¶</a>tcp_nodelay</h3>
<p>该指令必须在keep-alive连接开启的情况下才生效，来提高网络包传输的’实时性’。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>tcp_nodelay on|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>tcp_nodelay on;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p><strong>tcp_nopush和tcp_nodelay区别：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@d2989ee87343051834b3af940e4163584573506b/2021/09/18/4702ca37d6fafd88056ccb488a989e8f.png" alt=""></p>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<p><strong>经过刚才的分析，“tcp_nopush"和”tcp_nodelay“看起来是"互斥的”，那么为什么要将这两个值都打开？</strong></p>
<p>这个大家需要知道的是在linux2.5.9以后的版本中两者是可以兼容的，三个指令都开启的好处是：</p>
<ul>
<li>sendfile可以开启高效的文件传输模式</li>
<li>tcp_nopush开启可以确保在发送到客户端之前数据包已经充分“填满”， 这大大减少了网络开销，并加快了文件发送的速度。</li>
<li>然后，当它到达最后一个可能因为没有“填满”而暂停的数据包时，Nginx会忽略tcp_nopush参数， 然后，tcp_nodelay强制套接字发送数据。</li>
</ul>
<p>由此可知，TCP_NOPUSH可以与TCP_NODELAY<strong>一起设置</strong>，它比单独配置TCP_NODELAY具有更强的性能。所以我们可以使用如下配置来优化Nginx静态资源的处理</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sendfile on;<br>tcp_nopush on;<br>tcp_nodelay on;<br></code></pre></td></tr></tbody></table></figure>
<h2 id="4、Nginx静态资源压缩实战"><a class="header-anchor" href="#4、Nginx静态资源压缩实战">¶</a>4、Nginx静态资源压缩实战</h2>
<blockquote>
<p>在Nginx的配置文件中可以通过配置gzip来对静态资源进行压缩，相关的指令可以配置在http块、server块和location块。</p>
</blockquote>
<p>相关指令依赖如下模块进行解析：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">ngx_http_gzip_module模块<br>ngx_http_gzip_static_module模块<br>ngx_http_gunzip_module模块<br></code></pre></td></tr></tbody></table></figure>
<h3 id="Gzip模块配置指令"><a class="header-anchor" href="#Gzip模块配置指令">¶</a>Gzip模块配置指令</h3>
<p>接下来的指令都来自ngx_http_gzip_module模块，该模块会在nginx安装的时候内置到nginx的安装环境中，也就是说我们可以直接使用这些指令。</p>
<p>1、gzip指令：该指令用于开启或者关闭gzip功能</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>gzip on|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>gzip off;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location…</td>
</tr>
</tbody>
</table>
<p>注意只有该指令为打开状态，下面的指令才有效果</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">http{<br>   gzip on;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>2、gzip_types指令：该指令可以根据响应页的MIME类型选择性地开启Gzip压缩功能</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>gzip_types mime-type …;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>gzip_types text/html;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>所选择的值可以从mime.types文件中进行查找，也可以使用"*"代表所有。(不建议使用<code>*</code>浪费服务器资源，例如视频和图片)</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">http{<br>	gzip_types application/javascript;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>3、gzip_comp_level指令：该指令用于设置Gzip压缩程度，级别从1-9,1表示要是程度最低，要是效率最高，9刚好相反，压缩程度最高，但是效率最低最费时间。</p>
<p><strong>建议设置为6！</strong> 级别更高，压缩效率慢，压缩的也不会更加厉害！</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>gzip_comp_level level;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>gzip_comp_level 1;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">http{<br>	gzip_comp_level 6;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>4、gzip_vary指令：该指令用于设置使用Gzip进行压缩发送是否携带“Vary:Accept-Encoding”头域的响应头部。主要是告诉接收方，所发送的数据经过了Gzip压缩处理</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>gzip_vary on|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>gzip_vary off;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@46a092ba5cc04ac285ab4b4e6bbd87cb6153c458/2021/09/18/63a64aaa315b9d9ad8c7787b76ff5015.png" alt=""></p>
<p>5、gzip_buffers指令：该指令用于处理请求压缩的缓冲区数量和大小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>gzip_buffers number size;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>gzip_buffers 32 4k|16 8k;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<ul>
<li>number：指定Nginx服务器向系统申请缓存空间个数，size指的是每个缓存空间的大小。主要实现的是申请number个每个大小为size的内存空间。这个值的设定一般会和服务器的操作系统有关，所以建议此项不设置，使用默认值即可。</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gzip_buffers 4 16K;	  #缓存空间大小<br></code></pre></td></tr></tbody></table></figure>
<p>6、gzip_disable指令：针对不同种类客户端发起的请求，可以选择性地开启和关闭Gzip功能。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>gzip_disable regex …;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>regex：根据客户端的浏览器标志(user-agent)来设置，支持使用正则表达式。指定的浏览器标志不使用Gzip。该指令一般是用来排除一些明显不支持Gzip的浏览器。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 例如IE浏览器</span><br>gzip_disable "MSIE [1-6]\.";<br></code></pre></td></tr></tbody></table></figure>
<p>7、gzip_http_version指令：针对不同的HTTP协议版本，可以选择性地开启和关闭Gzip功能。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>gzip_http_version 1.0|1.1;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>gzip_http_version 1.1;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>该指令是指定使用Gzip的HTTP最低版本，该指令一般采用默认值即可。</p>
<p>8、gzip_min_length指令：该指令针对传输数据的大小，可以选择性地开启和关闭Gzip功能</p>
<blockquote>
<p>Gzip压缩功能对大数据的压缩效果明显，但是如果要压缩的数据比较小的化，可能出现越压缩数据量越大的情况，因此我们需要根据响应内容的大小来决定是否使用Gzip功能，响应页面的大小可以通过头信息中的<code>Content-Length</code>来获取。但是如何使用了Chunk编码动态压缩，该指令将被忽略。建议设置为1K或以上。</p>
</blockquote>
<table>
<thead>
<tr>
<th>语法</th>
<th>gzip_min_length length;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>gzip_min_length 20;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">nignx计量大小的单位：bytes[字节] / kb[千字节] / M[兆]<br>例如: 1024 / 10k|K / 10m|M<br></code></pre></td></tr></tbody></table></figure>
<p>9、gzip_proxied指令：该指令设置是否对服务端返回的结果进行Gzip压缩。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>gzip_proxied  off|expired|no-cache|<br>no-store|private|no_last_modified|no_etag|auth|any;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>gzip_proxied off;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>off：关闭Nginx服务器对后台服务器返回结果的Gzip压缩<br>
expired：启用压缩，如果header头中包含 “Expires” 头信息<br>
no-cache：启用压缩，如果header头中包含 “Cache-Control:no-cache” 头信息<br>
no-store：启用压缩，如果header头中包含 “Cache-Control:no-store” 头信息<br>
private：启用压缩，如果header头中包含 “Cache-Control:private” 头信息<br>
no_last_modified：启用压缩,如果header头中不包含 “Last-Modified” 头信息<br>
no_etag：启用压缩 ,如果header头中不包含 “ETag” 头信息<br>
auth：启用压缩 , 如果header头中包含 “Authorization” 头信息<br>
any：无条件启用压缩</p>
<h3 id="Gzip压缩功能的实例配置"><a class="header-anchor" href="#Gzip压缩功能的实例配置">¶</a>Gzip压缩功能的实例配置</h3>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">gzip on;  			  #开启gzip功能<br>gzip_types *;		  #压缩源文件类型,根据具体的访问资源类型设定<br>gzip_comp_level 6;	  #gzip压缩级别<br>gzip_min_length 1024; #进行压缩响应页面的最小长度,content-length<br>gzip_buffers 4 16K;	  #缓存空间大小<br>gzip_http_version 1.1; #指定压缩响应所需要的最低HTTP请求版本<br>gzip_vary  on;		  #往头信息中添加压缩标识<br>gzip_disable "MSIE [1-6]\."; #对IE6以下的版本都不进行压缩<br>gzip_proxied  off； #nginx作为反向代理压缩服务端返回数据的条件<br></code></pre></td></tr></tbody></table></figure>
<p><strong>我们可以将这些内容抽取到一个配置文件中，然后通过include指令把配置文件再次加载到nginx.conf配置文件中：</strong></p>
<p>nginx_gzip.conf</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">gzip on;<br>gzip_types *;<br>gzip_comp_level 6;<br>gzip_min_length 1024;<br>gzip_buffers 4 16K;<br>gzip_http_version 1.1;<br>gzip_vary  on;<br>gzip_disable "MSIE [1-6]\.";<br>gzip_proxied  off;<br></code></pre></td></tr></tbody></table></figure>
<p>nginx.conf</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">include nginx_gzip.conf<br></code></pre></td></tr></tbody></table></figure>
<h3 id="Gzip和sendfile共存问题"><a class="header-anchor" href="#Gzip和sendfile共存问题">¶</a>Gzip和sendfile共存问题</h3>
<blockquote>
<p>前面在讲解sendfile的时候，提到过，开启sendfile以后，在读取磁盘上的静态资源文件的时候，可以减少拷贝的次数，可以<strong>不经过</strong>用户进程将静态文件通过网络设备发送出去，但是Gzip要想对资源压缩，是<strong>需要经过</strong>用户进程进行操作的。所以如何解决两个设置的共存问题。</p>
</blockquote>
<p>可以使用ngx_http_gzip_static_module模块的gzip_static指令来解决。（<strong>默认没有这个模块</strong>）</p>
<h4 id="添加模块到Nginx的实现步骤"><a class="header-anchor" href="#添加模块到Nginx的实现步骤">¶</a>添加模块到Nginx的实现步骤</h4>
<p>1、查询当前Nginx的配置参数（主要用于记录以前配置过的默认信息）</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -V<br></code></pre></td></tr></tbody></table></figure>
<p>2、将nginx安装目录下sbin目录中的nginx二进制文件进行更名</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/sbin<br>mv nginx nginxold<br></code></pre></td></tr></tbody></table></figure>
<p>3、进入Nginx的安装目录</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /opt/nginx-1.16.1<br></code></pre></td></tr></tbody></table></figure>
<p>4、执行make clean清空之前编译的内容</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make clean<br></code></pre></td></tr></tbody></table></figure>
<p>5、使用configure来配置参数</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./configure --with-http_gzip_static_module<br></code></pre></td></tr></tbody></table></figure>
<p>6、使用make命令进行编译</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br></code></pre></td></tr></tbody></table></figure>
<p>7、将objs目录下的nginx二进制执行文件移动到nginx安装目录下的sbin目录中</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv objs/nginx /usr/local/nginx/sbin<br></code></pre></td></tr></tbody></table></figure>
<p>8、执行更新命令（在nginx解压目录下执行）</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make upgrade<br></code></pre></td></tr></tbody></table></figure>
<h4 id="gzip-static指令"><a class="header-anchor" href="#gzip-static指令">¶</a>gzip_static指令</h4>
<p><strong>注意</strong>：需要关了gzip开关，无需在应用程序中压缩，<code>gzip off;</code></p>
<p>gzip_static: 检查与访问资源同名的.gz文件时，response中以gzip相关的header返回.gz文件的内容。先进行服务器上的压缩为.gz文件，再进行资源传输。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th><strong>gzip_static</strong> on | off | always;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>gzip_static off;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<h4 id="gzip-static测试使用"><a class="header-anchor" href="#gzip-static测试使用">¶</a>gzip_static测试使用</h4>
<p>1、直接访问<code>http://192.168.200.133/jquery.js</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@93223c6988047cc2e1b064450a8b2423d13eb835/2021/09/18/0e340262898399859f4762cad0065a10.png" alt=""></p>
<p>2、使用gzip命令进行压缩</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/nginx/htmlgzip jquery.js<br></code></pre></td></tr></tbody></table></figure>
<p>3、再次访问<code>http://192.168.200.133/jquery.js</code></p>
<p><strong>多了Content-Encoding：gzip 和 Vary：Accept-Encoding</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@23a85ee7980fb57a0dc2d590614c0275d7b2ad60/2021/09/18/45d728a04f91dad0fbb9e5c5ee3f8a7a.png" alt=""></p>
<h2 id="5、静态资源的缓存处理"><a class="header-anchor" href="#5、静态资源的缓存处理">¶</a>5、静态资源的缓存处理</h2>
<h3 id="什么是缓存"><a class="header-anchor" href="#什么是缓存">¶</a>什么是缓存</h3>
<p>缓存（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用DRAM技术，而使用昂贵但较快速的SRAM技术。缓存的设置是所有现代计算机系统发挥高性能的重要因素之一。</p>
<h3 id="什么是web缓存"><a class="header-anchor" href="#什么是web缓存">¶</a>什么是web缓存</h3>
<p>Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。</p>
<p>比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页</p>
<h3 id="web缓存的种类"><a class="header-anchor" href="#web缓存的种类">¶</a>web缓存的种类</h3>
<p>客户端缓存：浏览器缓存</p>
<p>服务端缓存：Nginx / Redis / Memcached等</p>
<h3 id="浏览器缓存"><a class="header-anchor" href="#浏览器缓存">¶</a>浏览器缓存</h3>
<p>是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览.</p>
<p>是<strong>成本最低的一种缓存实现</strong>减少网络带宽消耗降低服务器压力减少网络延迟，加快页面打开速度！</p>
<h3 id="浏览器缓存的执行流程"><a class="header-anchor" href="#浏览器缓存的执行流程">¶</a>浏览器缓存的执行流程</h3>
<p><strong>HTTP协议中和页面缓存相关的字段：</strong></p>
<table>
<thead>
<tr>
<th>header</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Expires</td>
<td>缓存过期的日期和时间</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>设置和缓存相关的配置信息</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源最后修改时间</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值，比如文件的MD5值</td>
</tr>
</tbody>
</table>
<p><strong>缓存执行流程示意图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@dc94e077385ebcb098d4a85ae3deee830aefe5e1/2021/09/18/c1184cadb15dd8b1f753005f9c6fab91.png" alt=""></p>
<p><strong>执行过程如下：</strong></p>
<ol>
<li>用户首次通过浏览器发送请求到服务端获取数据，客户端是没有对应的缓存，所以需要发送request请求来获取数据；</li>
<li>服务端接收到请求后，获取服务端的数据及服务端缓存的允许后，返回200的成功状态码并且在响应头上附上对应资源以及缓存信息；</li>
<li>当用户再次访问相同资源的时候，客户端会在浏览器的缓存目录中查找是否存在响应的缓存文件</li>
<li>如果没有找到对应的缓存文件，则走<strong>第二步</strong></li>
<li>如果有缓存文件，接下来对缓存文件是否过期进行判断，过期的判断标准是(Expires),</li>
<li>如果没有过期，则直接从本地缓存中返回数据进行展示（<strong>强缓存</strong>）</li>
<li>如果Expires过期，接下来需要判断缓存文件是否发生过变化</li>
<li>判断的标准有两个，一个是ETag(Entity Tag),一个是Last-Modified</li>
<li>判断结果是未发生变化，则服务端返回<strong>304</strong>，直接从缓存文件中获取数据（<strong>弱缓存</strong>）</li>
<li>如果判断是发生了变化，重新从服务端获取数据，并根据缓存协商(服务端所设置的是否需要进行缓存数据的设置)来进行数据缓存。</li>
</ol>
<p><strong>弱缓存请求头图示：</strong> 记得去掉浏览器disabled cache的勾。</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@6248328a92f367269b8ab988238cecec28e419ef/2021/09/18/b62f6936b16bf0ee27aded2eca2da178.png" alt=""></p>
<p><strong>注意</strong>：直接刷新页面和F5会导致<strong>强缓存失效</strong>。一定要在开一个页面，提前打开浏览器控制台的网络选项卡查看！</p>
<p><strong>强缓存图示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@352f0124abad7b82c1366f0f47015ddb7fba7f34/2021/09/21/3f1c3af4ec7c38f94ed9e63f3caba8df.png" alt=""></p>
<h3 id="浏览器缓存相关指令"><a class="header-anchor" href="#浏览器缓存相关指令">¶</a>浏览器缓存相关指令</h3>
<h4 id="expires指令"><a class="header-anchor" href="#expires指令">¶</a>expires指令</h4>
<p>该指令用来控制页面缓存的作用。可以通过该指令控制HTTP应答中的“Expires"和”Cache-Control"。（单位默认秒）</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>expires   [modified] time<br>expires epoch|max|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>expires off;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>time：可以整数也可以是负数，指定过期时间。如果是负数，Cache-Control则为no-cache；如果为整数或0，则Cache-Control的值为max-age=time；</p>
<ul>
<li>max-age为新的http1.1使用的，和expires类似。expires会由于服务器和本地时间不一致而不使用缓存！</li>
</ul>
</li>
<li>
<p>epoch：指定Expires的值为’1 January,1970,00:00:01 GMT’(1970-01-01 00:00:00)，Cache-Control的值no-cache</p>
</li>
<li>
<p>max：指定Expires的值为’31 December2037 23:59:59GMT’ (2037-12-31 23:59:59) ，Cache-Control的值为10年</p>
</li>
<li>
<p>off：默认不缓存。</p>
</li>
</ul>
<p><strong>给静态资源设置缓存：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ，">location ~ .*\.(html|js|css|png|jpg) {<br>	expires 1000;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>分别为没有设置、设置为max，1000，负数 响应头示意图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@70ce1034598233cd356e403f9128bc8c2a2f7ac7/2021/09/18/5bbd022e3be8e72719904155537e9922.png" alt=""></p>
<h4 id="add-header指令"><a class="header-anchor" href="#add-header指令">¶</a>add_header指令</h4>
<p>add_header指令是用来添加指定的响应头和响应值。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>add_header name value [always];</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location…</td>
</tr>
</tbody>
</table>
<p>Cache-Control作为响应头信息，可以设置如下值：</p>
<p><strong>缓存响应指令：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">Cache-control: must-revalidate<br>Cache-control: no-cache<br>Cache-control: no-store<br>Cache-control: no-transform<br>Cache-control: public<br>Cache-control: private<br>Cache-control: proxy-revalidate<br>Cache-Control: max-age=&lt;seconds&gt;<br>Cache-control: s-maxage=&lt;seconds&gt;<br></code></pre></td></tr></tbody></table></figure>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>must-revalidate</td>
<td>可缓存但必须再向源服务器进行确认</td>
</tr>
<tr>
<td>no-cache</td>
<td><strong>缓存前必须确认其有效性</strong></td>
</tr>
<tr>
<td>no-store</td>
<td><strong>不缓存请求或响应的任何内容</strong></td>
</tr>
<tr>
<td>no-transform</td>
<td>代理不可更改媒体类型</td>
</tr>
<tr>
<td>public</td>
<td>可向任意方提供响应的缓存</td>
</tr>
<tr>
<td>private</td>
<td>仅向特定用户返回响应</td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>要求中间缓存服务器对缓存的响应有效性再进行确认</td>
</tr>
<tr>
<td>max-age=&lt;秒&gt;</td>
<td>响应最大Age值</td>
</tr>
<tr>
<td>s-maxage=&lt;秒&gt;</td>
<td>公共缓存服务器响应的最大Age值</td>
</tr>
</tbody>
</table>
<h2 id="6、Nginx的跨域问题解决"><a class="header-anchor" href="#6、Nginx的跨域问题解决">¶</a>6、Nginx的跨域问题解决</h2>
<h3 id="同源策略"><a class="header-anchor" href="#同源策略">¶</a>同源策略</h3>
<p><strong>浏览器的同源策略</strong>：是一种约定，是浏览器最核心也是最基本的安全功能，如果浏览器少了同源策略，则浏览器的正常功能可能都会受到影响。</p>
<p><strong>同源</strong>:  协议、域名(IP)、端口相同即为同源</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plain">http://192.168.200.131/user/1<br>https://192.168.200.131/user/1<br>不<br><br>http://192.168.200.131/user/1<br>http://192.168.200.132/user/1<br>不<br><br>http://192.168.200.131/user/1<br>http://192.168.200.131:8080/user/1<br>不<br><br>http://www.nginx.com/user/1<br>http://www.nginx.org/user/1<br>不<br><br>http://192.168.200.131/user/1<br>http://192.168.200.131:8080/user/1<br>不<br><br>http://www.nginx.org:80/user/1<br>http://www.nginx.org/user/1<br>满足<br></code></pre></td></tr></tbody></table></figure>
<h3 id="跨域问题"><a class="header-anchor" href="#跨域问题">¶</a>跨域问题</h3>
<p>简单描述下：有两台服务器分别为A,B，如果从服务器A的页面发送异步请求到服务器B获取数据，如果服务器A和服务器B不满足同源策略，则就会出现跨域问题。</p>
<h3 id="跨域问题演示"><a class="header-anchor" href="#跨域问题演示">¶</a>跨域问题演示</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@465f98fad733b643c82247275d7e581add1035c4/2021/09/18/b9a26fe2092c8e69fc9bf267737e0a66.png" alt=""></p>
<p>1、nginx的html目录下新建一个a.html</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>跨域问题演示<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"jquery.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">            $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</span><br><span class="javascript">                $(<span class="hljs-string">"#btn"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</span><br><span class="javascript">                        $.get(<span class="hljs-string">'http://192.168.200.133:8080/getUser'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{</span><br><span class="javascript">                                alert(<span class="hljs-built_in">JSON</span>.stringify(data));</span><br>                        });<br>                });<br>            });<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"获取数据"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"btn"</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></tbody></table></figure>
<p>2、在nginx.conf配置如下内容</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">server{<br>        listen  8080;<br>        server_name localhost;<br>        location /getUser{<br>                default_type application/json;<br>                return 200 '{"id":1,"name":"TOM","age":18}';<br>        }<br>}<br>server{<br>	listen 	80;<br>	server_name localhost;<br>	location /{<br>		root html;<br>		index index.html;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>3、通过浏览器访问测试</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@2f0fa10a8039d8f849cfa6d9bdb0177de2006d4f/2021/09/18/3663ee8d61743ddbc1fcb48dbbf59a4a.png" alt=""></p>
<h3 id="解决方案"><a class="header-anchor" href="#解决方案">¶</a>解决方案</h3>
<p>使用add_header指令，该指令可以用来添加一些头信息：</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>add_header name  value…</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>此处用来解决跨域问题，需要添加两个头信息：<code>Access-Control-Allow-Origin</code>,<code>Access-Control-Allow-Methods</code></p>
<ul>
<li>Access-Control-Allow-Origin: 直译过来是允许跨域访问的源地址信息，可以配置多个(多个用逗号分隔)，也可以使用<code>*</code>代表所有源</li>
<li>Access-Control-Allow-Methods：直译过来是允许跨域访问的请求方式，值可以为 GET POST PUT DELETE…,可以全部设置，也可以根据需要设置，多个用逗号分隔</li>
</ul>
<p><strong>具体配置方式：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /getUser{<br>    add_header Access-Control-Allow-Origin *;<br>    add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE;<br>    default_type application/json;<br>    return 200 '{"id":1,"name":"TOM","age":18}';<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="7、静态资源防盗链"><a class="header-anchor" href="#7、静态资源防盗链">¶</a>7、静态资源防盗链</h2>
<h3 id="什么是资源盗链"><a class="header-anchor" href="#什么是资源盗链">¶</a>什么是资源盗链</h3>
<p>资源盗链指的是此内容不在自己服务器上，而是通过技术手段，绕过别人的限制将别人的内容放到自己页面上最终展示给用户。以此来盗取大网站的空间和流量。简而言之就是用别人的东西成就自己的网站。</p>
<p><strong>效果演示：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">京东：https://img14.360buyimg.com/n7/jfs/t1/101062/37/2153/254169/5dcbd410E6d10ba22/4ddbd212be225fcd.jpg<br><br>百度：https://pics7.baidu.com/feed/cf1b9d16fdfaaf516f7e2011a7cda1e8f11f7a1a.jpeg?token=551979a23a0995e5e5279b8fa1a48b34&amp;s=BD385394D2E963072FD48543030030BB<br></code></pre></td></tr></tbody></table></figure>
<p><strong>我们自己准备一个html页面，在页面上img标签引入这两个图片查看效果：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@701de75fe3a93cb22d6f8807d7162c2c73940270/2021/09/18/795c6d8cfd009ecdc303e6e7cbc83b1e.png" alt=""></p>
<h3 id="Nginx防盗链原理"><a class="header-anchor" href="#Nginx防盗链原理">¶</a>Nginx防盗链原理</h3>
<p>了解防盗链的原理之前，我们得先学习一个HTTP的头信息Referer，当浏览器向web服务器发送请求的时候，一般都会带上Referer，来告诉浏览器该网页是从哪个页面链接过来的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@be66fb5ac746756b1a0294e60d21c2e20abacc5d/2021/09/18/87e2911bfcc23c6c2abaf07fd36b3913.png" alt=""></p>
<p><strong>后台服务器可以根据获取到的这个Referer信息来判断是否为自己信任的网站地址，如果是则放行继续访问，如果不是则可以返回403(服务端拒绝访问)的状态信息。</strong></p>
<p><strong>Nginx防盗链的具体实现:</strong></p>
<p>valid_referers：nginx会通就过查看referer自动和valid_referers后面的内容进行匹配，如果匹配到了就将$invalid_referer变量置0，如果没有匹配到，则将$invalid_referer变量置为1，匹配的过程中不区分大小写。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>valid_referers none|blocked|server_names|string…</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>server、location</td>
</tr>
</tbody>
</table>
<ul>
<li>none：如果Header中的Referer为空，允许访问</li>
<li>blocked：在Header中的Referer不为空，但是该值被防火墙或代理进行伪装过，如不带"http://" 、"https://"等协议头的资源允许访问。</li>
<li>server_names：指定具体的域名或者IP</li>
<li>string：可以支持正则表达式和*的字符串。如果是正则表达式，需要以<code>~</code>开头表示，例如</li>
</ul>
<p><strong>注意：</strong> if后面必须有空格</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">location ~*\.(png|jpg|gif){<br>           valid_referers none blocked www.baidu.com 192.168.200.222 *.example.com example.*  www.example.org  ~\.google\.;<br>           if ($invalid_referer){<br>                return 403;<br>           }<br>           root /usr/local/nginx/html;<br><br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="针对目录进行防盗链"><a class="header-anchor" href="#针对目录进行防盗链">¶</a>针对目录进行防盗链</h3>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /images {<br>           valid_referers none blocked www.baidu.com 192.168.200.222 *.example.com example.*  www.example.org  ~\.google\.;<br>           if ($invalid_referer){<br>                return 403;<br>           }<br>           root /usr/local/nginx/html;<br><br>}<br></code></pre></td></tr></tbody></table></figure>
<p>这样我们可以对一个目录下的所有资源进行了防盗操作。</p>
<p><strong>遇到的问题：Referer的限制比较粗，比如随意加一个Referer，上面的方式是无法进行限制的。那么这个问题改如何解决？</strong></p>
<p>此处我们需要用到Nginx的第三方模块<code>ngx_http_accesskey_module</code>，后面模块篇内容介绍！</p>
<h1 id="七、Rewrite功能配置"><a class="header-anchor" href="#七、Rewrite功能配置">¶</a>七、Rewrite功能配置</h1>
<blockquote>
<p>Rewrite是Nginx服务器提供的一个重要基本功能，是Web服务器产品中几乎必备的功能。主要的作用是用来实现URL的重写。</p>
<p>注意：Nginx服务器的Rewrite功能的实现依赖于PCRE的支持，因此在编译安装Nginx服务器之前，需要安装PCRE库。</p>
<p>Nginx使用的是ngx_http_rewrite_module模块来解析和处理Rewrite功能的相关配置。（内置，无需安装）</p>
</blockquote>
<h2 id="1、地址重写与地址转发"><a class="header-anchor" href="#1、地址重写与地址转发">¶</a>1、地址重写与地址转发</h2>
<ul>
<li>地址重写浏览器地址会发生变化而地址转发则不变</li>
<li>一次地址重写会产生两次请求而一次地址转发只会产生一次请求</li>
<li>地址重写到的页面必须是一个完整的路径而地址转发则不需要</li>
<li>地址重写因为是两次请求所以request范围内属性不能传递给新页面而地址转发因为是一次请求所以可以传递值</li>
<li>地址转发速度快于地址重写</li>
</ul>
<h2 id="2、Rewrite的相关指令"><a class="header-anchor" href="#2、Rewrite的相关指令">¶</a>2、Rewrite的相关指令</h2>
<h3 id="set指令"><a class="header-anchor" href="#set指令">¶</a>set指令</h3>
<p>该指令用来设置一个新的变量。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>set $variable value;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>server、location、if</td>
</tr>
</tbody>
</table>
<p>variable：变量的名称，该变量名称要用"$"作为变量的第一个字符，且不能与Nginx服务器预设的全局变量同名。</p>
<p>value：变量的值，可以是字符串、其他变量或者变量的组合等。</p>
<h3 id="Rewrite常用全局变量"><a class="header-anchor" href="#Rewrite常用全局变量">¶</a>Rewrite常用全局变量</h3>
<p><strong>不一定是nginx的全局变量！</strong></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$args</td>
<td>变量中存放了请求URL中的请求指令。比如 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://192.168.200.133:8080?arg1=value1&amp;args2=value2">http://192.168.200.133:8080?arg1=value1&amp;args2=value2</a> 中的"arg1=value1&amp;arg2=value2"，功能和$query_string一样</td>
</tr>
<tr>
<td>$http_user_agent</td>
<td>变量存储的是用户访问服务的代理信息(如果通过浏览器访问，记录的是浏览器的相关版本信息)</td>
</tr>
<tr>
<td>$host</td>
<td>变量存储的是访问服务器的server_name值</td>
</tr>
<tr>
<td>$document_uri</td>
<td>变量存储的是当前访问地址的URI。比如 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://192.168.200.133/server?id=10&amp;name=zhangsan">http://192.168.200.133/server?id=10&amp;name=zhangsan</a> 中的"/server"，功能和$uri一样</td>
</tr>
<tr>
<td>$document_root</td>
<td>变量存储的是当前请求对应location的root值，如果未设置，默认指向Nginx自带html目录所在位置</td>
</tr>
<tr>
<td>$content_length</td>
<td>变量存储的是请求头中的Content-Length的值</td>
</tr>
<tr>
<td>$content_type</td>
<td>变量存储的是请求头中的Content-Type的值</td>
</tr>
<tr>
<td>$http_cookie</td>
<td>变量存储的是客户端的cookie信息，可以通过add_header Set-Cookie 'cookieName=cookieValue’来添加cookie数据</td>
</tr>
<tr>
<td>$limit_rate</td>
<td>变量中存储的是Nginx服务器对网络连接速率的限制，也就是Nginx配置中对limit_rate指令设置的值，默认是0，不限制。</td>
</tr>
<tr>
<td>$remote_addr</td>
<td>变量中存储的是客户端的IP地址</td>
</tr>
<tr>
<td>$remote_port</td>
<td>变量中存储了客户端与服务端建立连接的端口号</td>
</tr>
<tr>
<td>$remote_user</td>
<td>变量中存储了客户端的用户名，需要有认证模块才能获取</td>
</tr>
<tr>
<td>$scheme</td>
<td>变量中存储了访问协议</td>
</tr>
<tr>
<td>$server_addr</td>
<td>变量中存储了服务端的地址</td>
</tr>
<tr>
<td>$server_name</td>
<td>变量中存储了客户端请求到达的服务器的名称</td>
</tr>
<tr>
<td>$server_port</td>
<td>变量中存储了客户端请求到达服务器的端口号</td>
</tr>
<tr>
<td>$server_protocol</td>
<td>变量中存储了客户端请求协议的版本，比如"HTTP/1.1"</td>
</tr>
<tr>
<td>$request_body_file</td>
<td>变量中存储了发给后端服务器的本地文件资源的名称</td>
</tr>
<tr>
<td>$request_method</td>
<td>变量中存储了客户端的请求方式，比如"GET","POST"等</td>
</tr>
<tr>
<td>$request_filename</td>
<td>变量中存储了当前请求的资源文件的路径名</td>
</tr>
<tr>
<td>$request_uri</td>
<td>变量中存储了当前请求的URI，并且携带请求参数，比如 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://192.168.200.133/server?id=10&amp;name=zhangsan">http://192.168.200.133/server?id=10&amp;name=zhangsan</a> 中的"/server?id=10&amp;name=zhangsan"</td>
</tr>
</tbody>
</table>
<h3 id="if指令"><a class="header-anchor" href="#if指令">¶</a>if指令</h3>
<p>该指令用来支持条件判断，并根据条件判断结果选择不同的Nginx配置。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>if  (condition){…}</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>server、location</td>
</tr>
</tbody>
</table>
<p>condition为判定条件，可以支持以下写法：</p>
<p>1、变量名。如果变量名对应的值为空<strong>字符串或"0"</strong>，if都判断为false,其他条件为true。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">if ($param){<br>	<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>2、使用"=“和”!="比较变量和字符串是否相等，满足条件为true，不满足为false</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">if ($request_method = POST){<br>	return 405;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>此处和Java不太一样的地方是字符串不需要添加引号。</li>
<li>浏览器无法直接发送post请求，可以编写form表单提交发送。也可以直接使用<code>curl -X post 请求地址</code>来发送！</li>
</ul>
<p>3、使用正则表达式对变量进行匹配，匹配成功返回true，否则返回false。</p>
<ul>
<li><code>~</code>代表匹配正则表达式过程中区分大小写</li>
<li><code>~*</code>代表匹配正则表达式过程中不区分大小写</li>
<li><code>!~</code>和<code>!~</code>刚好和上面取相反值，如果匹配上返回false,匹配不上返回true</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">if ($http_user_agent ~ MSIE){<br><span class="hljs-meta">	#</span><span class="bash"><span class="hljs-variable">$http_user_agent</span>的值中是否包含MSIE字符串，如果包含返回<span class="hljs-literal">true</span></span><br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>注意：</strong> 正则表达式字符串一般不需要加引号，但是如果字符串中包含"}“或者是”;"等字符时，就需要把引号加上。</p>
<p>4、判断请求的文件是否存在使用"-f"和"!-f",</p>
<ul>
<li><code>-f</code>：如果请求的文件存在返回true，不存在返回false。</li>
<li><code>!f</code>：如果请求文件不存在，但该文件所在目录存在返回true,文件和目录都不存在返回false,如果文件存在返回false</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">if (-f $request_filename){<br><span class="hljs-meta">	#</span><span class="bash">判断请求的文件是否存在</span><br>}<br>if (!-f $request_filename){<br><span class="hljs-meta">	#</span><span class="bash">判断请求的文件是否不存在</span><br>}<br></code></pre></td></tr></tbody></table></figure>
<p>5、判断请求的目录是否存在使用"-d"和"!-d",</p>
<p>6、判断请求的目录或者文件是否存在使用"-e"和"!-e"</p>
<p>7、判断请求的文件是否可执行使用"-x"和"!-x"</p>
<h3 id="break指令"><a class="header-anchor" href="#break指令">¶</a>break指令</h3>
<p>该指令用于中断当前相同作用域中的其他Nginx配置。与该指令处于同一作用域的Nginx配置中，位于它前面的指令配置生效，位于后面的指令配置无效。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>break;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>server、location、if</td>
</tr>
</tbody>
</table>
<p><strong>例子:</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /testbreak {<br>    default_type text/plain;<br>    set $username TOM;<br>    if ($args){<br>        set $username JERRY;<br>		break ;<br>        set $username ROSE;<br>    }<br>    add_header username $username;<br>    return 200 $username;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>解释：有了参数后走if，但是直接报错404，因为break会终止此次匹配，直接跳转到location的路径去重定向访问，导致跳转到/usr/local/nginx/html/testbreak目录，该目录下没有默认的index.html，因此报错404。</p>
<p>当我们创建了该目录和默认html文件后，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@3cbcbb65c492559d627c2ec94ab65ca872604503/2021/09/18/72579af508647dc17784aa18a2c05d7c.png" alt=""></p>
<p>301表示永久重定向，重定向到?1，状态码为200，响应头多了一个username为JERRY，即break后面的不会执行（同一作用域内）。</p>
<h3 id="return指令"><a class="header-anchor" href="#return指令">¶</a>return指令</h3>
<p>该指令用于完成对请求的处理，直接向客户端返回响应状态代码。在return后的所有Nginx配置都是无效的。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>return code [text];<br>return code URL;<br>return URL;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>server、location、if</td>
</tr>
</tbody>
</table>
<ul>
<li>code：为返回给客户端的HTTP状态代理。可以返回的状态代码为0~999的任意HTTP状态代理</li>
<li>text：为返回给客户端的响应体内容，支持变量的使用</li>
<li>URL：为返回给客户端的URL地址。重定向，地址栏改变，状态码为302，临时重定向！</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">return 302 https://www.baidu.com/;<br>return https://www.baidu.com/;<br><span class="hljs-meta">#</span><span class="bash"> 二者效果一样！</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="rewrite指令"><a class="header-anchor" href="#rewrite指令">¶</a>rewrite指令</h3>
<p>该指令通过正则表达式的使用来改变URI。可以同时存在一个或者多个指令，按照顺序依次对URL进行匹配和处理。</p>
<ul>
<li>
<p>URI：统一资源标识符</p>
</li>
<li>
<p>URL：统一资源定位符</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>rewrite regex replacement [flag];</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>server、location、if</td>
</tr>
</tbody>
</table>
<p>regex：用来匹配URI的正则表达式</p>
<p>replacement：匹配成功后，用于替换URI中被截取内容的字符串。<strong>如果该字符串是以"http://"或者"https://"开头的，则不会继续向下对URI进行其他处理</strong>，而是直接返回重写后的URI给客户端。</p>
<p>flag：用来设置rewrite对URI的处理行为，可选值有如下：</p>
<ul>
<li>last：终止继续在本location块中处理接收到的URI，并将此处重写的URl作为一个新的URI，使用各location块进行处理。该标志将重写后的URI重写在server块中执行，为重写后的URI提供了转入到<strong>其他location块</strong>的机会。</li>
<li>break：将此处重写的URI作为一个新的URl,在本块中继续进行处理。该标志将重写后的地址在<strong>当前的location块</strong>中执行，不会将新的URI转向其他的location块。</li>
<li>redirect：将重写后的URI返回给客户端，状态码为302，指明是<strong>临时重定向</strong>URI,主要用在replacement变量不是以"http:/“或者"https:/”"开头的情况。</li>
<li>permanent：将重写后的URI返回给客户端，状态码为301，指明是<strong>永久重定向</strong>URl,主要用在replacement变量不是以"http:/"“或者"https:/八”"开头的情况。</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /rewrite {<br>    rewrite ^/rewrite/url\w*$ https://www.baidu.com;<br>    rewrite ^/rewrite/(test)\w*$ /$1;<br>    rewrite ^/rewrite/(demo)\w*$ /$1;<br>    <br>    # break<br>    rewrite ^/rewrite/(test)\w*$ /$1 break;<br>    # 默认会去/usr/lcoal/nginx/html/test/index.html中去找。可以查看error.log看到！<br>    <br>    # redirect 临时重定向<br>    rewrite ^/rewrite/(test)\w*$ /$1 redirect;<br>    <br>    # permanent 永久重定向<br>    rewrite ^/rewrite/(test)\w*$ /$1 permanent;<br>}<br>location /test {<br>    default_type text/plain;<br>    return 200 test_success;<br>}<br>location /demo {<br>	default_type text/plain;<br>	return 200 demo_success;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>补充：301 302和搜索引擎seo优化有关！</strong></p>
<h3 id="rewrite-log指令"><a class="header-anchor" href="#rewrite-log指令">¶</a>rewrite_log指令</h3>
<p>该指令配置是否开启URL重写日志的输出功能。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>rewrite_log on|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>rewrite_log off;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location、if</td>
</tr>
</tbody>
</table>
<p>开启后，URL重写的相关日志将以notice级别输出到error_log指令配置的日志文件汇总。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /rewrite {<br>	error_log logs/error.log notice;<br>	rewrite_log on;<br>	<br>    rewrite ^/rewrite/url\w*$ https://www.baidu.com;<br>    rewrite ^/rewrite/(test)\w*$ /$1;<br>    rewrite ^/rewrite/(demo)\w*$ /$1;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3、Rewrite的案例"><a class="header-anchor" href="#3、Rewrite的案例">¶</a>3、Rewrite的案例</h2>
<h3 id="域名跳转"><a class="header-anchor" href="#域名跳转">¶</a>域名跳转</h3>
<ul>
<li>准备三个域名：</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/hosts<br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1   www.itcast.cn<br>127.0.0.1   www.itheima.cn<br>127.0.0.1   www.itheima.com<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://xn--Nginxwww-jn5ou93qyk1cvdk24ac11d.itcast.cn">通过Nginx实现访问www.itcast.cn</a></li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	listen 80;<br>	server_name www.itcast.cn;<br>	location /{<br>		default_type text/html;<br>		return 200 '&lt;h1&gt;welcome to itcast&lt;/h1&gt;';<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>通过Rewrite完成将 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.ithema.com">www.ithema.com</a> 和 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.itheima.cn">www.itheima.cn</a> 的请求跳转到 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.itcast.com">www.itcast.com</a></li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	listen 80;<br>	server_name www.itheima.com www.itheima.cn;<br>	rewrite ^/ http://www.itcast.cn;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>问题描述：如何在域名跳转的过程中携带请求的URI？</strong></p>
<p>修改配置信息：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	listen 80;<br>	server_name www.itheima.com www.itheima.cn;<br>	rewrite ^(.*) http://www.itcast.cn$1；<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="域名镜像"><a class="header-anchor" href="#域名镜像">¶</a>域名镜像</h3>
<blockquote>
<p>镜像网站指定是将一个完全相同的网站分别放置到几台服务器上，并分别使用独立的URL进行访问。其中一台服务器上的网站叫主站，其他的为镜像网站。镜像网站和主站没有太大的区别，可以把镜像网站理解为主站的一个备份节点。可以通过镜像网站提供网站在不同地区的响应速度。镜像网站可以平衡网站的流量负载、可以解决网络宽带限制、封锁等。</p>
</blockquote>
<p>为其中某一个子目录下的资源做镜像，我们可以在location块中配置rewrite功能：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>    listen          80;<br>    server_name     www.itheima.cn www.itheima.com;<br>    location /user {<br>    	rewrite ^/user(.*)$ http://www.itcast.cn$1;<br>    }<br>    location /emp{<br>        default_type text/html;<br>        return 200 '&lt;h1&gt;emp_success&lt;/h1&gt;';<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="独立域名"><a class="header-anchor" href="#独立域名">¶</a>独立域名</h3>
<p>一个完整的项目包含多个模块，比如购物网站有商品搜索模块、商品详情模块和购物车模块等，那么我们如何为每一个模块设置独立的域名。</p>
<p>需求：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://search.itcast.com:81   #访问商品搜索模块<br>http://item.itcast.com:82	  #访问商品详情模块<br>http://cart.itcast.com:83	  #访问商品购物车模块<br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">server{<br>	listen 81;<br>	server_name search.itcast.com;<br>	rewrite ^(.*) http://www.itcast.cn/search$1;<br>}<br>server{<br>	listen 82;<br>	server_name item.itcast.com;<br>	rewrite ^(.*) http://www.itcast.cn/item$1;<br>}<br>server{<br>	listen 83;<br>	server_name cart.itcast.com;<br>	rewrite ^(.*) http://www.itcast.cn/cart$1;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="目录自动添加"><a class="header-anchor" href="#目录自动添加">¶</a>目录自动添加"/"</h3>
<p>问题描述</p>
<p>通过一个例子来演示下问题:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">server {<br>	listen	8082;<br>	server_name localhost;<br>	location /heima {<br>		root html;<br>		index index.html;<br>	}<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<p><strong>通过 <code>http://192.168.200.133:8082/heima</code> 和通过 <code>http://192.168.200.133:8082/heima/</code> 访问的区别？</strong></p>
<p>如果不加斜杠，Nginx服务器内部会自动做一个301的重定向，重定向的地址会有一个指令叫server_name_in_redirect on|off;来决定重定向的地址：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">如果该指令为on<br>	重定向的地址为:  http://server_name:8082/目录名/;<br>	http://localhost:8082/heima/<br>如果该指令为off<br>	重定向的地址为:  http://原URL中的域名:8082/目录名/;<br>	http://192.168.200.133:8082/heima/<br></code></pre></td></tr></tbody></table></figure>
<p>所以就拿刚才的地址来说，<a target="_blank" rel="noopener external nofollow noreferrer" href="http://192.168.200.133:8082/heima">http://192.168.200.133:8082/heima</a> 如果不加斜杠，那么按照上述规则，如果指令server_name_in_redirect为on，则301重定向地址变为 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://localhost:8082/heima/">http://localhost:8082/heima/</a> , 如果为off，则301重定向地址变为 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://192.168.200.133:8082/heima/%E3%80%82%E5%90%8E%E9%9D%A2%E8%BF%99%E4%B8%AA%E6%98%AF%E6%AD%A3%E5%B8%B8%E7%9A%84%EF%BC%8C%E5%89%8D%E9%9D%A2%E5%9C%B0%E5%9D%80%E5%B0%B1%E6%9C%89%E9%97%AE%E9%A2%98%E3%80%82">http://192.168.200.133:8082/heima/。后面这个是正常的，前面地址就有问题。</a></p>
<p>注意server_name_in_redirect指令在Nginx的0.8.48版本之前默认都是on，之后改成了off, <strong>所以现在我们这个版本不需要考虑这个问题</strong>，但是如果是0.8.48以前的版本并且server_name_in_redirect设置为on，我们如何通过rewrite来解决这个问题？</p>
<p><strong>旧版本解决方案：</strong></p>
<p>我们可以使用rewrite功能为末尾没有斜杠的URL自动添加一个斜杠。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	listen	80;<br>	server_name localhost;<br>	server_name_in_redirect on;<br>	location /heima {<br>		if (-d $request_filename){<br><span class="hljs-meta">			#</span><span class="bash"> 匹配/xxx不匹配/xxx/，匹配成功修改为/xxx/。[^/]匹配处理/的其它字符</span><br>			rewrite ^/(.*)([^/])$ http://$host/$1$2/ permanent;<br>		}<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="合并目录"><a class="header-anchor" href="#合并目录">¶</a>合并目录</h3>
<blockquote>
<p>搜索引擎优化(SEO)是一种利用搜索引擎的搜索规则来提高目的网站在有关搜索引擎内排名的方式。我们在创建自己的站点时，可以通过很多中方式来有效的提供搜索引擎优化的程度。其中有一项就包含<strong>URL的目录层级一般不要超过三层</strong>，否则的话不利于搜索引擎的搜索也给客户端的输入带来了负担，但是将所有的文件放在一个目录下又会导致文件资源管理混乱并且访问文件的速度也会随着文件增多而慢下来，这两个问题是相互矛盾的，那么使用rewrite如何解决上述问题?</p>
</blockquote>
<p><strong>举例：</strong></p>
<p>网站中有一个资源文件的访问路径时 /server/11/22/33/44/20.html, 也就是说20.html存在于第5级目录下，如果想要访问该资源文件，客户端的URL地址就要写成 <code>http://192.168.200.133/server/11/22/33/44/20.html</code></p>
<p>但是这个是非常不利于SEO搜索引擎优化的，同时客户端也不好记，使用rewrite我们可以进行如下配置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	listen 8083;<br>	server_name localhost;<br>	location /server{<br><span class="hljs-meta">		#</span><span class="bash"> 解释：匹配/server-11-22-33-44-20.html后重写为/server/11/22/33/44/20.html，由于是last，重新发起请求匹配/server/11/22/33/44/20.html。</span><br><span class="hljs-meta">		#</span><span class="bash"> 再次进入本location匹配，并不满足rewrite规则，直接去服务器对应层级目录去找20.html文件，找到了直接显示，若没有会报错404！</span><br><span class="hljs-meta">		#</span><span class="bash">若这里为<span class="hljs-built_in">break</span>，则不会再次发起请求匹配location而是会直接继续执行下方代码，由于下方没有代码，则默认找对应层级目录的20.html。</span><br>		rewrite ^/server-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)\.html$ /server/$1/$2/$3/$4/$5.html last;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>客户端只需要输入http://www.web.name/server-11-22-33-44-20.html就可以访问到20.html页面了。</p>
<h3 id="防盗链"><a class="header-anchor" href="#防盗链">¶</a>防盗链</h3>
<blockquote>
<p>防盗链之前我们已经介绍过了相关的知识，在rewrite中的防盗链和之前的原理其实都是一样的，只不过通过rewrite可以将防盗链的功能进行完善下，当出现防盗链的情况，我们可以使用rewrite将请求转发到自定义的一张图片和页面，给用户比较好的提示信息。</p>
</blockquote>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /images {<br>    root html;<br>    valid_referers none blocked www.baidu.com;<br>    if ($invalid_referer){<br>        #return 403;<br>        rewrite ^/    /images/forbidden.png break;<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<h1 id="八、Nginx反向代理"><a class="header-anchor" href="#八、Nginx反向代理">¶</a>八、Nginx反向代理</h1>
<h2 id="1、Nginx正向代理"><a class="header-anchor" href="#1、Nginx正向代理">¶</a>1、Nginx正向代理</h2>
<p><strong>正向代理代理的对象是客户端，反向代理代理的是服务端，这是两者之间最大的区别。</strong></p>
<p>Nginx即可以实现正向代理，也可以实现反向代理。</p>
<p><strong>需求：</strong> 客服端为192.168.200.1，代理为192.168.200.146，服务端为192.168.133</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@20702967fd6ab99bd90e05127a45aa3bb53b4223/2021/09/18/9e3386ab9850dcedef2122fc27c3dab0.png" alt=""></p>
<p><strong>1、服务端的设置</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">http {<br>  log_format main 'client send request=&gt;clientIp=$remote_addr serverIp=&gt;$host';<br>	server{<br>		listen 80;<br>		server_name	localhost;<br>		access_log logs/access.log main;<br>		location {<br>			root html;<br>			index index.html index.htm;<br>		}<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>2、使用客户端访问服务端，打开日志查看结果</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@db65588d2f1c4a2523700d49e0c373627bb9e433/2021/09/18/794d1a51eae1d53d481003846bfc380e.png" alt=""></p>
<p><strong>3、代理服务器设置</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br><br>        listen  82;<br>        # dns地址，可配可不配<br>        resolver 8.8.8.8;<br>        location /{<br>        		# <br>                proxy_pass http://$host$request_uri;<br>        }<br>    }<br><br></code></pre></td></tr></tbody></table></figure>
<p><strong>4、查看代理服务器的IP(192.168.200.146)和Nginx配置监听的端口(82)</strong></p>
<p><strong>5、在客户端配置代理服务器</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@84edf72614f17b19f7778219fcefc225dfc8909d/2021/09/18/6cbc65dd0830582ffcfab83d486d6735.png" alt=""></p>
<p><strong>6、设置完成后，再次通过浏览器访问服务端</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@d415a610d3913777c16756fbf41490a098fdb5da/2021/09/18/8d17f1d3a38472597dcd26f697199821.png" alt=""></p>
<p>通过对比，上下两次的日志记录，会发现虽然我们是客户端访问服务端，但是使用了代理，那么服务端能看到的只是代理发送过去的请求，这样的话，就使用Nginx实现了正向代理的设置。</p>
<p>但是Nginx正向代理，在实际的应用中不是特别多！</p>
<h2 id="2、Nginx反向代理"><a class="header-anchor" href="#2、Nginx反向代理">¶</a>2、Nginx反向代理</h2>
<p>Nginx反向代理模块的指令是由<code>ngx_http_proxy_module</code>模块进行解析，默认已经内置！</p>
<h3 id="proxy-pass"><a class="header-anchor" href="#proxy-pass">¶</a>proxy_pass</h3>
<p>该指令用来<strong>设置被代理服务器地址</strong>，可以是主机名称、IP地址加端口号形式。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_pass URL;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>location</td>
</tr>
</tbody>
</table>
<p>URL：为要设置的被代理服务器地址，包含传输协议(<code>http</code>,<code>https://</code>)、主机名称或IP地址加端口号、URI等要素。</p>
<p><strong>大家在编写proxy_pass的时候，后面的值要不要加"/"?</strong></p>
<p>接下来通过例子来说明刚才我们提到的问题：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	listen 80;<br>	server_name localhost;<br>	location /{<br><span class="hljs-meta">		#</span><span class="bash">proxy_pass http://192.168.200.146;</span><br>		proxy_pass http://192.168.200.146/;<br>	}<br>}<br><span class="hljs-meta">#</span><span class="bash"> 当客户端访问 http://localhost/index.html,效果是一样的</span><br><br>server{<br>	listen 80;<br>	server_name localhost;<br>	location /server{<br><span class="hljs-meta">		#</span><span class="bash">proxy_pass http://192.168.200.146;</span><br>		proxy_pass http://192.168.200.146/;<br>	}<br>}<br><br><span class="hljs-meta">#</span><span class="bash"> 当客户端访问 http://localhost/server/index.html</span><br><span class="hljs-meta">#</span><span class="bash"> 这个时候，第一个proxy_pass就变成了http://localhost/server/index.html</span><br><span class="hljs-meta">#</span><span class="bash"> 第二个proxy_pass就变成了http://localhost/index.html效果就不一样了。</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="proxy-set-header"><a class="header-anchor" href="#proxy-set-header">¶</a>proxy_set_header</h3>
<p>该指令可以更改Nginx服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给代理的服务器</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_set_header field value;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>proxy_set_header Host $proxy_host;<br>proxy_set_header Connection close;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>需要注意的是，如果想要看到结果，必须在被代理的服务器上来获取添加的头信息。</p>
<p><strong>被代理服务器： [192.168.200.146]</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>        listen  8080;<br>        server_name localhost;<br>        default_type text/plain;<br>        # $http_请求头属性名<br>        return 200 $http_username;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>代理服务器: [192.168.200.133]</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>        listen  8080;<br>        server_name localhost;<br>        location /server {<br>                proxy_pass http://192.168.200.146:8080/;<br>                proxy_set_header username TOM;<br>        }<br>    }<br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="proxy-redirect"><a class="header-anchor" href="#proxy-redirect">¶</a>proxy_redirect</h3>
<p>该指令是用来重置头信息中的"Location"和"Refresh"的值。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_redirect redirect replacement;<br>proxy_redirect default;<br>proxy_redirect off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>proxy_redirect default;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<ul>
<li>redirect：目标,Location的值</li>
<li>replacement：要替换的值</li>
<li>proxy_redirect default：带有默认规则的替换，将location块的uri变量作为replacement，将proxy_pass变量作为redirect进行替换</li>
<li>proxy_redirect off：关闭proxy_redirect的功能</li>
</ul>
<p><strong>为什么要用该指令?</strong></p>
<p><strong>服务端[192.168.200.146]</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>    listen  8081;<br>    server_name localhost;<br>    if (!-f $request_filename){<br>    	return 302 http://192.168.200.146;<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<p><strong>代理服务端[192.168.200.133]</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	listen  80;<br>	server_name localhost;<br>	location / {<br>		root html;<br>		index index.html;<br>	}<br>}<br>server {<br>	listen  8081;<br>	server_name localhost;<br>	location / {<br>		proxy_pass http://192.168.200.146:8081/;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>问题发现：</strong></p>
<p>访问 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://192.168.200.133:8081/abc.html">http://192.168.200.133:8081/abc.html</a> 会先进入133的代理，再进入服务端146的if条件，302状态，地址栏变为146的ip！头信息的Location值也变为146服务端ip！</p>
<p><strong>这时候服务端ip地址已经暴露！</strong></p>
<p><strong>解决：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 133代理服务器修改如下即可！</span><br>server {<br>	listen  8081;<br>	server_name localhost;<br>	location / {<br>		proxy_pass http://192.168.200.146:8081/;<br>		proxy_redirect http://192.168.200.146 http://192.168.200.133;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>又有问题</strong>：是跳转到了133代理服务器，但是获取的页面是133的默认80端口的值！即133的默认nginx欢迎页面！而不是想要得到的146服务端的nginx欢迎页面！</p>
<p><strong>133代理服务器80端口修改一下即可：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>	listen  80;<br>	server_name localhost;<br>	location / {<br><span class="hljs-meta">		#</span><span class="bash"> 再次通过location拦截跳到真实146服务端即可！</span><br>		proxy_pass http://192.168.200.146/;<br>	}<br>}<br>server {<br>	listen  8081;<br>	server_name localhost;<br>	location / {<br>		proxy_pass http://192.168.200.146:8081/;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3、Nginx反向代理实战"><a class="header-anchor" href="#3、Nginx反向代理实战">¶</a>3、Nginx反向代理实战</h2>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@22ab9f1cfc77363cb06099a8feaf8f9eb42945df/2021/09/18/2e652b00643e49889ede7818977214e2.png" alt=""></p>
<p>服务器1,2,3存在两种情况：</p>
<ul>
<li>三台服务器的内容不一样。反向代理！</li>
<li>三台服务器的内容是一样。负载均衡！</li>
</ul>
<p><strong>配置：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">代理服务器</span><br>server {<br>        listen          8082;<br>        server_name     localhost;<br>        location /server1 {<br>                proxy_pass http://192.168.200.146:9001/;<br>        }<br>        location /server2 {<br>                proxy_pass http://192.168.200.146:9002/;<br>        }<br>        location /server3 {<br>                proxy_pass http://192.168.200.146:9003/;<br>        }<br>}<br><br><span class="hljs-meta">#</span><span class="bash">服务端server1</span><br>server {<br>        listen          9001;<br>        server_name     localhost;<br>        default_type text/html;<br>        return 200 '&lt;h1&gt;192.168.200.146:9001&lt;/h1&gt;'<br>}<br><span class="hljs-meta">#</span><span class="bash">server2</span><br>server {<br>        listen          9002;<br>        server_name     localhost;<br>        default_type text/html;<br>        return 200 '&lt;h1&gt;192.168.200.146:9002&lt;/h1&gt;'<br>}<br><span class="hljs-meta">#</span><span class="bash">server3</span><br>server {<br>        listen          9003;<br>        server_name     localhost;<br>        default_type text/html;<br>        return 200 '&lt;h1&gt;192.168.200.146:9003&lt;/h1&gt;'<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="4、Nginx的安全控制"><a class="header-anchor" href="#4、Nginx的安全控制">¶</a>4、Nginx的安全控制</h2>
<p>关于web服务器的安全是比较大的一个话题，里面所涉及的内容很多，Nginx反向代理是如何来提升web服务器的安全呢？</p>
<p>安全隔离！</p>
<p><strong>什么是安全隔离?</strong></p>
<p>通过代理分开了客户端到应用程序服务器端的连接，实现了安全措施。在反向代理之前设置防火墙，仅留一个入口供代理服务器访问。</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@b29312dd7368afcf99bd344cfaed843d437b43ea/2021/09/18/e60dcd747e8f1639e050fca1f5992a87.png" alt=""></p>
<h2 id="5、如何使用SSL对流量进行加密"><a class="header-anchor" href="#5、如何使用SSL对流量进行加密">¶</a>5、如何使用SSL对流量进行加密</h2>
<blockquote>
<p>就是将我们常用的http请求转变成https请求，那么这两个之间的区别简单的来说两个都是HTTP协议，只不过https是身披SSL外壳的http！</p>
</blockquote>
<p>HTTPS是一种通过计算机网络进行安全通信的传输协议。它经由HTTP进行通信，利用SSL/TLS建立全通信，加密数据包，确保数据的安全性。</p>
<ul>
<li>SSL(Secure Sockets Layer)安全套接层</li>
<li>TLS(Transport Layer Security)传输层安全</li>
</ul>
<p>上述这两个是为网络通信提供安全及数据完整性的一种安全协议，TLS和SSL在<strong>传输层和应用层</strong>对网络连接进行加密。</p>
<p><strong>总结来说为什么要使用https？</strong></p>
<p>http协议是明文传输数据，存在安全问题，而https是加密传输，相当于http+ssl，并且可以防止流量劫持。</p>
<p>Nginx要想使用SSL，需要满足一个条件即需要添加一个模块<code>--with-http_ssl_module</code>,而该模块在编译的过程中又需要OpenSSL的支持，这个我们之前已经准备好了。</p>
<h3 id="nginx添加SSL的支持"><a class="header-anchor" href="#nginx添加SSL的支持">¶</a>nginx添加SSL的支持</h3>
<p>1、完成 <code>--with-http_ssl_module</code>模块的增量添加</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">》拷贝nginx之前的配置信息 ./nginx -V 备份一份configure的参数信息！<br>》将原有/usr/local/nginx/sbin/nginx进行备份<br>》在nginx的安装源码进行配置指定对应模块  ./configure --with-http_ssl_module<br>》通过make模板进行编译<br>》将objs下面的nginx移动到/usr/local/nginx/sbin下<br>》在源码目录下执行 make upgrade 进行升级，这个可以实现不停机添加新模块的功能<br><br>root@VM-8-2-centos nginx-1.21.3]# nginx -V<br>nginx version: nginx/1.21.3<br>built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) <br>built with OpenSSL 1.0.2k-fips  26 Jan 2017<br>TLS SNI support enabled<br>configure arguments: --with-http_gzip_static_module --with-http_ssl_module<br></code></pre></td></tr></tbody></table></figure>
<h3 id="Nginx的SSL相关指令"><a class="header-anchor" href="#Nginx的SSL相关指令">¶</a>Nginx的SSL相关指令</h3>
<p>ssl：该指令用来在指定的服务器开启HTTPS,可以使用 listen 443 ssl,后面这种方式更通用些。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>ssl on | off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>ssl off;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">server{<br>	listen 443 ssl;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>ssl_certificate：为当前这个虚拟主机指定一个带有PEM格式证书的证书。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>ssl_certificate file;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>http、server</td>
</tr>
</tbody>
</table>
<p>ssl_certificate_key：该指令用来指定PEM secret key文件的路径</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>ssl_ceritificate_key file;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>http、server</td>
</tr>
</tbody>
</table>
<p>ssl_session_cache：该指令用来配置用于SSL会话的缓存</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>ssl_sesion_cache off|none|[builtin[:size]] [shared:name:size]</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>ssl_session_cache none;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server</td>
</tr>
</tbody>
</table>
<ul>
<li>off：禁用会话缓存，客户端不得重复使用会话</li>
<li>none：禁止使用会话缓存，客户端可以重复使用，但是并没有在缓存中存储会话参数</li>
<li>builtin：内置OpenSSL缓存，仅在一个工作进程中使用。</li>
<li>shared：所有工作进程之间共享缓存，缓存的相关信息用name和size来指定</li>
</ul>
<p>ssl_session_timeout：开启SSL会话功能后，设置客户端能够反复使用储存在缓存中的会话参数时间。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>ssl_session_timeout time;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>ssl_session_timeout 5m;（m：分钟）</td>
</tr>
<tr>
<td>位置</td>
<td>http、server</td>
</tr>
</tbody>
</table>
<p>ssl_ciphers：指出允许的密码，密码指定为OpenSSL支持的格式</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>ssl_ciphers ciphers;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>ssl_ciphers HIGH:!aNULL:!MD5;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server</td>
</tr>
</tbody>
</table>
<p>可以使用<code>openssl ciphers</code>查看openssl支持的格式。</p>
<p>ssl_prefer_server_ciphers：该指令指定是否服务器密码优先客户端密码</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>ssl_perfer_server_ciphers on|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>ssl_perfer_server_ciphers off;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server</td>
</tr>
</tbody>
</table>
<h3 id="生成证书"><a class="header-anchor" href="#生成证书">¶</a>生成证书</h3>
<ul>
<li>方式一：使用阿里云/腾讯云等第三方服务进行购买或使用freessl申请！（有机构验证）</li>
<li>方式二：使用openssl生成证书。（无机构验证）</li>
</ul>
<p>1、先要确认当前系统是否有安装openssl</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl version<br></code></pre></td></tr></tbody></table></figure>
<p>2、安装下面的命令进行生成</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /root/cert<br>cd /root/cert<br>openssl genrsa -des3 -out server.key 1024<br>openssl req -new -key server.key -out server.csr<br>cp server.key server.key.org<br>openssl rsa -in server.key.org -out server.key<br>openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt<br></code></pre></td></tr></tbody></table></figure>
<h3 id="开启SSL实例"><a class="header-anchor" href="#开启SSL实例">¶</a>开启SSL实例</h3>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>    listen       443 ssl;<br>    # 域名配置<br>    server_name  localhost;<br><br><span class="hljs-meta">	#</span><span class="bash"> 修改证书位置即可</span><br>    ssl_certificate      /root/cert/server.cert;<br>    ssl_certificate_key  /root/cert/server.key;<br><br>    ssl_session_cache    shared:SSL:1m;<br>    ssl_session_timeout  5m;<br><br>    ssl_ciphers  HIGH:!aNULL:!MD5;<br>    ssl_prefer_server_ciphers  on;<br><br><span class="hljs-meta">	#</span><span class="bash"> 具体配置</span><br>    location / {<br>        root   html;<br>        index  index.html index.htm;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>强制重定向到https：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>        listen       80;<br>        server_name  localhost;<br><br>        #charset koi8-r;<br><br>        #access_log  logs/host.access.log  main;<br><br>        location / {<br>            #root   html;<br>            #index  index.html index.htm;<br>            rewrite ^(.*)$ https://$host$1 permanent;<br>        }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="6、反向代理系统调优"><a class="header-anchor" href="#6、反向代理系统调优">¶</a>6、反向代理系统调优</h2>
<p>反向代理Buffer和Cache！</p>
<p><strong>Buffer翻译过来是"缓冲"，Cache翻译过来是"缓存"。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@75ac3ed1b22f754773e7bb09d58b89d5decc535c/2021/09/21/1ad4883fb51cb2beeb31cf8071352d8e.png" alt=""></p>
<p><strong>总结下：</strong></p>
<p>相同点：两种方式都是用来提供IO吞吐效率，都是用来提升Nginx代理的性能。</p>
<p>不同点：</p>
<ul>
<li>缓冲主要用来解决不同设备之间数据传递速度不一致导致的性能低的问题，缓冲中的数据一旦此次操作完成后，就可以删除。</li>
<li>缓存主要是备份，将被代理服务器的数据缓存一份到代理服务器，这样的话，客户端再次获取相同数据的时候，就只需要从代理服务器上获取，效率较高，缓存中的数据可以重复使用，只有满足特定条件才会删除.</li>
</ul>
<p><strong>Proxy Buffer相关指令：</strong></p>
<p>proxy_buffering：该指令用来开启或者关闭代理服务器的缓冲区</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_buffering on|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>proxy_buffering on;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>proxy_buffers：该指令用来指定单个连接从代理服务器读取响应的缓存区的个数和大小</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_buffers number size;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>proxy_buffers 8 4k | 8K;(与系统平台有关)</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<ul>
<li>number：缓冲区的个数</li>
<li>size：每个缓冲区的大小，缓冲区的总大小就是number*size</li>
</ul>
<p>proxy_buffer_size：该指令用来设置从被代理服务器获取的第一部分响应数据的大小。保持与proxy_buffers中的size一致即可，当然也可以更小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_buffer_size size;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>proxy_buffer_size 4k | 8k;(与系统平台有关)</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>proxy_busy_buffers_size：该指令用来限制同时处于BUSY状态的缓冲总大小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_busy_buffers_size size;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>proxy_busy_buffers_size 8k|16K;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>proxy_temp_path：当缓冲区存满后，仍未被Nginx服务器完全接受，响应数据就会被临时存放在磁盘文件上，该指令设置文件路径</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_temp_path  path;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>proxy_temp_path proxy_temp;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>**注意：**path最多设置三层。</p>
<p>proxy_temp_file_write_size：该指令用来设置磁盘上缓冲文件的大小。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_temp_file_write_size size;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>proxy_temp_file_write_size 8K|16K;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p><strong>通用网站的配置：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">proxy_buffering on;<br>proxy_buffer_size 4 32k;<br>proxy_busy_buffers_size 64k;<br>proxy_temp_file_write_size 64k;<br></code></pre></td></tr></tbody></table></figure>
<p><strong>根据项目的具体内容进行相应的调节。</strong></p>
<h1 id="九、Nginx负载均衡"><a class="header-anchor" href="#九、Nginx负载均衡">¶</a>九、Nginx负载均衡</h1>
<h2 id="1、负载均衡概述"><a class="header-anchor" href="#1、负载均衡概述">¶</a>1、负载均衡概述</h2>
<p>早期的网站流量和业务功能都比较简单，单台服务器足以满足基本的需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也跟着越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器进行性能的水平扩展及避免单点故障出现。那么如何将不同用户的请求流量分发到不同的服务器上呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@d0a65a145b29bdeaf29492d01522a3eeb3b80212/2021/09/20/2a7497f7a17f4c185158713f1a0a9f41.png" alt=""></p>
<h2 id="2、负载均衡的原理及处理流程"><a class="header-anchor" href="#2、负载均衡的原理及处理流程">¶</a>2、负载均衡的原理及处理流程</h2>
<p>系统的扩展可以分为纵向扩展和横向扩展。</p>
<p>纵向扩展是从单机的角度出发，通过增加系统的硬件处理能力来提升服务器的处理能力</p>
<p><strong>横向扩展是通过添加机器来满足大型网站服务的处理能力。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@cc6592d0952bb4fce62cb867c70e7c3d04f40fe1/2021/09/20/6d0784f4af512f0c7092bbe5e7b6a44e.png" alt=""></p>
<p><strong>这里面涉及到两个重要的角色分别是"应用集群"和"负载均衡器"：</strong></p>
<ul>
<li>
<p>应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理并返回响应的数据。</p>
</li>
<li>
<p>负载均衡器：将用户访问的请求根据对应的负载均衡算法，分发到集群中的一台服务器进行处理。</p>
</li>
</ul>
<h2 id="3、负载均衡的作用"><a class="header-anchor" href="#3、负载均衡的作用">¶</a>3、负载均衡的作用</h2>
<ol>
<li>解决服务器的高并发压力，提高应用程序的处理性能。</li>
<li>提供故障转移，实现高可用。</li>
<li>通过添加或减少服务器数量，增强网站的可扩展性。</li>
<li>在负载均衡器上进行过滤，可以提高系统的安全性。</li>
</ol>
<h2 id="3、负载均衡常用的处理方式"><a class="header-anchor" href="#3、负载均衡常用的处理方式">¶</a>3、负载均衡常用的处理方式</h2>
<h3 id="方式一：用户手动选择"><a class="header-anchor" href="#方式一：用户手动选择">¶</a>方式一：用户手动选择</h3>
<p>这种方式比较原始，只要实现的方式就是在网站主页上面提供不同线路、不同服务器链接方式，让用户来选择自己访问的具体服务器，来实现负载均衡。</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@ae083912b666024f3339b8c6ee8ed989f29ff7ca/2021/09/20/a7a59285b372eab1c657c5262e56144a.png" alt=""></p>
<h3 id="方式二：DNS轮询方式"><a class="header-anchor" href="#方式二：DNS轮询方式">¶</a>方式二：DNS轮询方式</h3>
<p>大多域名注册商都支持对同一个主机名添加多条A记录，这就是DNS轮询，DNS服务器将解析请求按照A记录的顺序，随机分配到不同的IP上，这样就能完成简单的负载均衡。DNS轮询的成本非常低，在一些不重要的服务器，被经常使用。</p>
<p>可以在云服务器控制台添加多条A记录解析！</p>
<p><strong>简单验证：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping 域名<br></code></pre></td></tr></tbody></table></figure>
<p><strong>清空本地的dns缓存再次测试ping：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ipconfig/flushdns<br></code></pre></td></tr></tbody></table></figure>
<p><strong>我们发现使用DNS来实现轮询，不需要投入过多的成本，虽然DNS轮询成本低廉，但是DNS负载均衡存在明显的缺点：</strong></p>
<ul>
<li>可靠性低</li>
</ul>
<p>假设一个域名DNS轮询多台服务器，如果其中的一台服务器发生故障，那么所有的访问该服务器的请求将不会有所回应，即使你将该服务器的IP从DNS中去掉，但是由于各大宽带接入商将众多的DNS存放在缓存中，以节省访问时间，导致DNS不会实时更新。所以DNS轮流上一定程度上解决了负载均衡问题，但是却存在可靠性不高的缺点。</p>
<ul>
<li>负载均衡不均衡</li>
</ul>
<p>DNS负载均衡采用的是简单的轮询负载算法，不能区分服务器的差异，不能反映服务器的当前运行状态，不能做到为性能好的服务器多分配请求，另外本地计算机也会缓存已经解析的域名到IP地址的映射，这也会导致使用该DNS服务器的用户在一定时间内访问的是同一台Web服务器，从而引发Web服务器减的负载不均衡。</p>
<p>负载不均衡则会导致某几台服务器负荷很低，而另外几台服务器负荷确很高，处理请求的速度慢，配置高的服务器分配到的请求少，而配置低的服务器分配到的请求多。</p>
<h3 id="方式三：四-七层负载均衡"><a class="header-anchor" href="#方式三：四-七层负载均衡">¶</a>方式三：四/七层负载均衡</h3>
<p>介绍四/七层负载均衡之前，我们先了解一个概念，OSI(open system interconnection), 叫开放式系统互联模型，这个是由国际标准化组织ISO指定的一个不基于具体机型、操作系统或公司的网络体系结构。该模型将网络通信的工作分为七层。</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@59c85a84238bf7c49d51a938619472a66868501b/2021/09/20/be2e2184532d51dcf192fbf8ba5a8031.png" alt=""></p>
<p><strong>简单介绍，属于计网知识：</strong></p>
<p>应用层：为应用程序提供网络服务。</p>
<p>表示层：对数据进行格式化、编码、加密、压缩等操作。</p>
<p>会话层：建立、维护、管理会话连接。</p>
<p>传输层：建立、维护、管理端到端的连接，常见的有TCP/UDP。</p>
<p>网络层：IP寻址和路由选择</p>
<p>数据链路层：控制网络层与物理层之间的通信。</p>
<p>物理层：比特流传输。</p>
<p><strong>七层和四层指的是从下往上看的第七和第四层！</strong></p>
<p><strong>所谓四层负载均衡指的是OSI七层模型中的传输层，主要是基于IP+PORT的负载均衡：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">实现四层负载均衡的方式：<br>硬件：F5 BIG-IP、Radware等<br>软件：LVS、Nginx、Hayproxy等<br></code></pre></td></tr></tbody></table></figure>
<p><strong>所谓的七层负载均衡指的是在应用层，主要是基于虚拟的URL或主机IP的负载均衡：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">实现七层负载均衡的方式：<br>软件：Nginx、Hayproxy等<br></code></pre></td></tr></tbody></table></figure>
<p><strong>四层和七层负载均衡的区别：</strong></p>
<ul>
<li>四层负载均衡数据包是在底层就进行了分发，而七层负载均衡数据包则在最顶端进行分发，所以<strong>四层负载均衡的效率比七层负载均衡的要高</strong>。</li>
<li><strong>四层负载均衡不识别域名，而七层负载均衡识别域名</strong>。</li>
</ul>
<p><strong>了解：</strong></p>
<p>除了四层和七层负载以为其实还有二层、三层负载均衡，二层是在数据链路层基于mac地址来实现负载均衡，三层是在网络层一般采用虚拟IP地址的方式实现负载均衡。</p>
<p><strong>实际环境采用的模式：四层负载(LVS)+七层负载(Nginx)</strong></p>
<h2 id="4、Nginx七层负载均衡"><a class="header-anchor" href="#4、Nginx七层负载均衡">¶</a>4、Nginx七层负载均衡</h2>
<blockquote>
<p>Nginx要实现七层负载均衡需要用到proxy_pass代理模块配置。Nginx默认安装支持这个模块，我们不需要再做任何处理。Nginx的负载均衡是在Nginx的反向代理基础上把用户的请求根据指定的算法分发到一组 <strong>upstream虚拟服务池</strong>。</p>
</blockquote>
<h3 id="负载均衡指令"><a class="header-anchor" href="#负载均衡指令">¶</a>负载均衡指令</h3>
<p><strong>upstream指令：</strong></p>
<p>该指令是用来定义一组服务器，它们可以是监听不同端口的服务器，并且也可以是同时监听TCP和Unix socket的服务器。服务器可以指定不同的权重，默认为1。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>upstream name {…}</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>http</td>
</tr>
</tbody>
</table>
<p><strong>server指令：</strong></p>
<p>该指令用来指定后端服务器的名称和一些参数，可以使用域名、IP、端口或者unix socket</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>server name [paramerters]</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>upstream</td>
</tr>
</tbody>
</table>
<h3 id="七层负载均衡的实现流程"><a class="header-anchor" href="#七层负载均衡的实现流程">¶</a>七层负载均衡的实现流程</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@195994c67f40e67b41a52f3e3ebef1ac461e1c58/2021/09/20/2ad6c45893d795a1db6f141d72a880e5.png" alt=""></p>
<p><strong>服务端设置：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">server {<br>    listen   9001;<br>    server_name localhost;<br>    default_type text/html;<br>    location /{<br>    	return 200 '&lt;h1&gt;192.168.200.146:9001&lt;/h1&gt;';<br>    }<br>}<br>server {<br>    listen   9002;<br>    server_name localhost;<br>    default_type text/html;<br>    location /{<br>    	return 200 '&lt;h1&gt;192.168.200.146:9002&lt;/h1&gt;';<br>    }<br>}<br>server {<br>    listen   9003;<br>    server_name localhost;<br>    default_type text/html;<br>    location /{<br>    	return 200 '&lt;h1&gt;192.168.200.146:9003&lt;/h1&gt;';<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>负载均衡器设置：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend{<br>	server 192.168.200.146:9091;<br>	server 192.168.200.146:9092;<br>	server 192.168.200.146:9093;<br>}<br>server {<br>	listen 8083;<br>	server_name localhost;<br>	location /{<br>		proxy_pass http://backend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="负载均衡状态"><a class="header-anchor" href="#负载均衡状态">¶</a>负载均衡状态</h3>
<table>
<thead>
<tr>
<th>状态</th>
<th>概述</th>
</tr>
</thead>
<tbody>
<tr>
<td>down</td>
<td>当前的server暂时不参与负载均衡</td>
</tr>
<tr>
<td>backup</td>
<td>预留的备份服务器</td>
</tr>
<tr>
<td>max_fails</td>
<td>允许请求失败的次数</td>
</tr>
<tr>
<td>fail_timeout</td>
<td>经过max_fails失败后, 服务暂停时间</td>
</tr>
<tr>
<td>max_conns</td>
<td>限制最大的接收连接数</td>
</tr>
</tbody>
</table>
<p><strong>down：将该服务器标记为永久不可用，那么该代理服务器将不参与负载均衡。</strong></p>
<p>该状态一般会对需要停机维护的服务器进行设置。</p>
<p><strong>注意</strong>：谷歌浏览器在这种情况下不会进行轮询，其他浏览器没问题！可以通过cmd中的<code>curl 地址</code>进行测试！</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend{<br>	server 192.168.200.146:9001 down;<br>	server 192.168.200.146:9002<br>	server 192.168.200.146:9003;<br>}<br>server {<br>	listen 8083;<br>	server_name localhost;<br>	location /{<br>		proxy_pass http://backend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>backup：将该服务器标记为备份服务器，当主服务器不可用时，将用来传递请求。</strong></p>
<blockquote>
<p>此时需要将9003端口的访问禁止掉来模拟下唯一能对外提供访问的服务宕机以后，backup的备份服务器就要开始对外提供服务，此时为了测试验证，我们需要使用防火墙firewalld来进行拦截。</p>
</blockquote>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend{<br>	server 192.168.200.146:9001 down;<br>	server 192.168.200.146:9002 backup;<br>	server 192.168.200.146:9003;<br>}<br>server {<br>	listen 8083;<br>	server_name localhost;<br>	location /{<br>		proxy_pass http://backend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>max_conns=number：用来设置代理服务器同时活动链接的最大数量，默认为0，表示不限制，使用该配置可以根据后端服务器处理请求的并发量来进行设置，防止后端服务器被压垮。</strong></p>
<p><strong>max_fails=number：设置允许请求代理服务器失败的次数，默认为1。</strong></p>
<p><strong>fail_timeout=time：设置经过max_fails失败后，服务暂停的时间，默认是10秒。</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend{<br>	server 192.168.200.133:9001 down;<br>	server 192.168.200.133:9002 backup;<br>	server 192.168.200.133:9003 max_fails=3 fail_timeout=15;<br>}<br>server {<br>	listen 8083;<br>	server_name localhost;<br>	location /{<br>		proxy_pass http://backend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="负载均衡策略"><a class="header-anchor" href="#负载均衡策略">¶</a>负载均衡策略</h3>
<p><strong>Nginx的upstream支持如下六种方式的分配算法，分别是：</strong></p>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>轮询</td>
<td>默认方式</td>
</tr>
<tr>
<td>weight</td>
<td>权重方式</td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据ip分配方式</td>
</tr>
<tr>
<td>least_conn</td>
<td>依据最少连接方式</td>
</tr>
<tr>
<td>url_hash</td>
<td>依据URL分配方式</td>
</tr>
<tr>
<td>fair</td>
<td>依据响应时间方式</td>
</tr>
</tbody>
</table>
<h4 id="轮询"><a class="header-anchor" href="#轮询">¶</a>轮询</h4>
<p>是upstream模块负载均衡默认的策略。每个请求会按时间顺序逐个分配到不同的后端服务器。轮询不需要额外的配置。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend{<br>	server 192.168.200.146:9001 weight=1;<br>	server 192.168.200.146:9002;<br>	server 192.168.200.146:9003;<br>}<br>server {<br>	listen 8083;<br>	server_name localhost;<br>	location /{<br>		proxy_pass http://backend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="weight加权轮询"><a class="header-anchor" href="#weight加权轮询">¶</a>weight加权轮询</h4>
<p>weight=number：用来设置服务器的权重，默认为1，权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的，所有此策略比较适合服务器的硬件配置差别比较大的情况。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend{<br>	server 192.168.200.146:9001 weight=10;<br>	server 192.168.200.146:9002 weight=5;<br>	server 192.168.200.146:9003 weight=3;<br>}<br>server {<br>	listen 8083;<br>	server_name localhost;<br>	location /{<br>		proxy_pass http://backend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="ip-hash"><a class="header-anchor" href="#ip-hash">¶</a>ip_hash</h4>
<p>当对后端的多台动态应用服务器做负载均衡时，ip_hash指令能够将某个客户端IP的请求通过哈希算法定位到同一台后端服务器上。这样，当来自某一个IP的用户在后端Web服务器A上登录后，在访问该站点的其他URL，能保证其访问的还是后端web服务器A。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>ip_hash;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>upstream</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend{<br>	ip_hash;<br>	server 192.168.200.146:9001;<br>	server 192.168.200.146:9002;<br>	server 192.168.200.146:9003;<br>}<br>server {<br>	listen 8083;<br>	server_name localhost;<br>	location /{<br>		proxy_pass http://backend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>需要额外多说一点的是使用ip_hash指令无法保证后端服务器的负载均衡，可能导致有些后端服务器接收到的请求多，有些后端服务器接收的请求少，而且设置后端服务器权重等方法将不起作用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@1f8a334a37771a672532cbb321975622033b71ca/2021/09/20/a4ba018fdb2645ffce5caeea717f0cf1.png" alt=""></p>
<h4 id="least-conn"><a class="header-anchor" href="#least-conn">¶</a>least_conn</h4>
<p>最少连接，把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least_conn这种方式就可以达到更好的负载均衡效果。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend{<br>	least_conn;<br>	server 192.168.200.146:9001;<br>	server 192.168.200.146:9002;<br>	server 192.168.200.146:9003;<br>}<br>server {<br>	listen 8083;<br>	server_name localhost;<br>	location /{<br>		proxy_pass http://backend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@dbe0b03da73c4d1d9c9a06a5f95ffdd980abefe7/2021/09/20/92f8a6f3734bd169392e1e5c0f86b996.png" alt=""></p>
<h4 id="url-hash"><a class="header-anchor" href="#url-hash">¶</a>url_hash</h4>
<p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，要配合缓存命中来使用。同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费。而使用url_hash，可以使得同一个url（也就是同一个资源请求）会到达同一台服务器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend{<br>	hash &amp;request_uri;<br>	server 192.168.200.146:9001;<br>	server 192.168.200.146:9002;<br>	server 192.168.200.146:9003;<br>}<br>server {<br>	listen 8083;<br>	server_name localhost;<br>	location /{<br>		proxy_pass http://backend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>访问如下地址：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">http://192.168.200.133:8083/a<br>http://192.168.200.133:8083/b<br>http://192.168.200.133:8083/c<br></code></pre></td></tr></tbody></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@87cf5ce2765f4ee9de0bcfb5d07615e2889f69e1/2021/09/21/3961edaa589501a260fe10db2f8e8abe.png" alt=""></p>
<h4 id="fair"><a class="header-anchor" href="#fair">¶</a>fair</h4>
<p>fair采用的不是内置负载均衡使用的轮换的均衡算法，而是可以根据页面大小、加载时间长短智能的进行负载均衡。那么如何使用第三方模块的fair负载均衡策略。</p>
<p>fair属于第三方模块实现的负载均衡。需要添加<code>nginx-upstream-fair</code>,如何添加对应的模块:</p>
<p>1、下载nginx-upstream-fair模块</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">下载地址为:<br>	https://github.com/gnosek/nginx-upstream-fair<br></code></pre></td></tr></tbody></table></figure>
<p>2、将下载的文件上传到服务器并进行解压缩</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">unzip nginx-upstream-fair-master.zip<br></code></pre></td></tr></tbody></table></figure>
<p>3、重命名资源</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">mv nginx-upstream-fair-master fair<br></code></pre></td></tr></tbody></table></figure>
<p>4、使用./configure命令将资源添加到Nginx模块中</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">./configure --add-module=/root/fair<br></code></pre></td></tr></tbody></table></figure>
<p>5、编译</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">make<br></code></pre></td></tr></tbody></table></figure>
<p><strong>编译可能会出现如下错误，ngx_http_upstream_srv_conf_t结构中缺少default_port</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@0ad3184adefd68a6fd53f61559049cfe9518743b/2021/09/20/514fb1170c24f30b7cf15ff8d0ef1503.png" alt=""></p>
<p><strong>解决方案：</strong></p>
<p>在Nginx的源码中 src/http/ngx_http_upstream.h,找到<code>ngx_http_upstream_srv_conf_s</code>，在模块中添加添加default_port属性</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">in_port_t</span>	   default_port<br></code></pre></td></tr></tbody></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@b6bb5b6a29524645b90feab6c2f4361bf1168c02/2021/09/21/f450fb757cd336b23d3560a21b660b37.png" alt=""></p>
<p>然后再进行make.</p>
<p>6、更新Nginx</p>
<p>​</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 6.1 将sbin目录下的nginx进行备份</span><br>mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginxold<br><span class="hljs-meta">#</span><span class="bash"> 6.2 将安装目录下的objs中的nginx拷贝到sbin目录</span><br>cd objs<br>cp nginx /usr/local/nginx/sbin<br><span class="hljs-meta">#</span><span class="bash"> 6.3 更新Nginx</span><br>cd ../<br>make upgrade<br></code></pre></td></tr></tbody></table></figure>
<p>​</p>
<p>7、编译测试使用Nginx</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend{<br>	fair;<br>	server 192.168.200.146:9001;<br>	server 192.168.200.146:9002;<br>	server 192.168.200.146:9003;<br>}<br>server {<br>	listen 8083;<br>	server_name localhost;<br>	location /{<br>		proxy_pass http://backend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="负载均衡案例"><a class="header-anchor" href="#负载均衡案例">¶</a>负载均衡案例</h3>
<p><strong>案例一：对所有请求实现一般轮询规则的负载均衡</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend{<br>	server 192.168.200.146:9001;<br>	server 192.168.200.146:9002;<br>	server 192.168.200.146:9003;<br>}<br>server {<br>	listen 8083;<br>	server_name localhost;<br>	location /{<br>		proxy_pass http://backend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>案例二：对所有请求实现加权轮询规则的负载均衡</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend{<br>	server 192.168.200.146:9001 weight=7;<br>	server 192.168.200.146:9002 weight=5;<br>	server 192.168.200.146:9003 weight=3;<br>}<br>server {<br>	listen 8083;<br>	server_name localhost;<br>	location /{<br>		proxy_pass http://backend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>案例三：对特定资源实现负载均衡</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream videobackend{<br>	server 192.168.200.146:9001;<br>	server 192.168.200.146:9002;<br>}<br>upstream filebackend{<br>	server 192.168.200.146:9003;<br>	server 192.168.200.146:9004;<br>}<br>server {<br>	listen 8084;<br>	server_name localhost;<br>	location /video/ {<br>		proxy_pass http://videobackend;<br>	}<br>	location /file/ {<br>		proxy_pass http://filebackend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>案例四：对不同域名实现负载均衡</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream itcastbackend{<br>	server 192.168.200.146:9001;<br>	server 192.168.200.146:9002;<br>}<br>upstream itheimabackend{<br>	server 192.168.200.146:9003;<br>	server 192.168.200.146:9004;<br>}<br>server {<br>	listen	8085;<br>	server_name www.itcast.cn;<br>	location / {<br>		proxy_pass http://itcastbackend;<br>	}<br>}<br>server {<br>	listen	8086;<br>	server_name www.itheima.cn;<br>	location / {<br>		proxy_pass http://itheimabackend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>案例五：实现带有URL重写的负载均衡</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend{<br>	server 192.168.200.146:9001;<br>	server 192.168.200.146:9002;<br>	server 192.168.200.146:9003;<br>}<br>server {<br>	listen	80;<br>	server_name localhost;<br>	location /file/ {<br>		rewrite ^(/file/.*) /server/$1 last;<br>	}<br>	location / {<br>		proxy_pass http://backend;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="5、Nginx四层负载均衡"><a class="header-anchor" href="#5、Nginx四层负载均衡">¶</a>5、Nginx四层负载均衡</h2>
<blockquote>
<p>Nginx在1.9之后，增加了一个stream模块，用来实现四层协议的转发、代理、负载均衡等。stream模块的用法跟http的用法类似，允许我们配置一组TCP或者UDP等协议的监听，然后通过proxy_pass来转发我们的请求，通过upstream添加多个后端服务，实现负载均衡。</p>
<p>四层协议负载均衡的实现，一般都会用到LVS、HAProxy、F5等，要么很贵要么配置很麻烦，而Nginx的配置相对来说更简单，更能快速完成工作。</p>
</blockquote>
<h3 id="添加stream模块的支持"><a class="header-anchor" href="#添加stream模块的支持">¶</a>添加stream模块的支持</h3>
<p>Nginx默认是没有编译这个模块的，需要使用到stream模块，那么需要在编译的时候加上<code>--with-stream</code>。</p>
<p>完成添加<code>--with-stream</code>的实现步骤:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">》将原有/usr/local/nginx/sbin/nginx进行备份<br>》拷贝nginx之前的配置信息<br>》在nginx的安装源码进行配置指定对应模块  ./configure --with-stream<br>》通过make模板进行编译<br>》将objs下面的nginx移动到/usr/local/nginx/sbin下<br>》在源码目录下执行  make upgrade进行升级，这个可以实现不停机添加新模块的功能<br></code></pre></td></tr></tbody></table></figure>
<h3 id="负载均衡的指令"><a class="header-anchor" href="#负载均衡的指令">¶</a>负载均衡的指令</h3>
<p><strong>stream指令：该指令提供在其中指定流服务器指令的配置文件上下文。和http指令同级。</strong></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>stream { … }</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>main</td>
</tr>
</tbody>
</table>
<p><strong>upstream指令：该指令和http的upstream指令是类似的。</strong></p>
<h3 id="四层负载均衡的案例"><a class="header-anchor" href="#四层负载均衡的案例">¶</a>四层负载均衡的案例</h3>
<p><strong>需求分析：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@41e7df43f5f768880828eeae21cdfcb380047d16/2021/09/21/baf09946607db1723fe1d6aab4da11ef.png" alt=""></p>
<p><strong>实现步骤：</strong></p>
<p>准备Redis服务器：在一条服务器上准备三个Redis，端口分别是6379,6378</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将安装包进行解压缩</span><br>tar -zxf redis-4.0.14.tar.gz<br>cd redis-4.0.14<br><span class="hljs-meta">#</span><span class="bash"> 使用make和install进行编译和安装</span><br>make PREFIX=/usr/local/redis/redis01 install<br><span class="hljs-meta">#</span><span class="bash"> 拷贝redis配置文件`redis.conf`到/usr/<span class="hljs-built_in">local</span>/redis/redis01/bin目录中</span><br>cp redis.conf	/usr/local/redis/redis01/bin<br><span class="hljs-meta">#</span><span class="bash"> 修改redis.conf配置文件</span><br>port  6379      #redis的端口<br>daemonize yes   #后台启动redis<br><span class="hljs-meta">#</span><span class="bash"> 将redis01复制一份为redis02</span><br>cd /usr/local/rediscp -r redis01 redis02<br><span class="hljs-meta">#</span><span class="bash"> 将redis02文件文件夹中的redis.conf进行修改</span><br>port  6378      #redis的端口<br>daemonize yes   #后台启动redis<br><span class="hljs-meta">#</span><span class="bash"> 分别启动，即可获取两个Redis.并查看</span><br>ps -ef | grep redis<br></code></pre></td></tr></tbody></table></figure>
<p>准备Tomcat服务器：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zxf apache-tomcat-8.5.56.tar.gz<br>cd apache-tomcat-8.5.56/bin<br>./startup<br></code></pre></td></tr></tbody></table></figure>
<p><strong>nginx.conf配置：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">stream {<br>        upstream redisbackend {<br>                server 192.168.200.146:6379;<br>                server 192.168.200.146:6378;<br>        }<br>        upstream tomcatbackend {<br>        		server 192.168.200.146:8080;<br>        }<br>        server {<br>                listen  81;<br>                # 没有server_name这个指令<br>                proxy_pass redisbackend;<br>        }<br>        server {<br>        		listen	82;<br>        		proxy_pass tomcatbackend;<br>        }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>访问测试：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@a2d18ce7b0180988eb822b7a6a7e8032c5874cf3/2021/09/20/95b479e18b44c496b6976ecdb0c4e79c.png" alt=""></p>
<p><strong>问题： http和stream中都访问同一端口，会进入哪个进行处理?</strong></p>
<p>四层负载均衡在七层负载均衡前面，因此会进入stream访问！</p>
<h1 id="十、Nginx缓存集成"><a class="header-anchor" href="#十、Nginx缓存集成">¶</a>十、Nginx缓存集成</h1>
<h2 id="1、缓存的概念"><a class="header-anchor" href="#1、缓存的概念">¶</a>1、缓存的概念</h2>
<p>缓存就是数据交换的缓冲区(称作:Cache),当用户要获取数据的时候，会先从缓存中去查询获取数据，如果缓存中有就会直接返回给用户，如果缓存中没有，则会发请求从服务器重新查询数据，将数据返回给用户的同时将数据放入缓存，下次用户就会直接从缓存中获取数据。</p>
<p><strong>缓存流程图示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@f2ba35e791c0e065d132e672f2fc3fe85e506fbb/2021/09/20/27e4dcc8421bef5cecb0ee43f67613f3.png" alt=""></p>
<p><strong>缓存的优点：</strong></p>
<ul>
<li>减少数据传输，节省网络流量，加快响应速度，提升用户体验；</li>
<li>减轻服务器压力；</li>
<li>提供服务端的高可用性；</li>
</ul>
<p><strong>缓存的缺点：</strong></p>
<ul>
<li>数据的不一致</li>
<li>增加成本</li>
</ul>
<h2 id="2、Nginx的web缓存服务"><a class="header-anchor" href="#2、Nginx的web缓存服务">¶</a>2、Nginx的web缓存服务</h2>
<p>Nginx是从0.7.48版开始提供缓存功能。Nginx是基于Proxy Store来实现的，其原理是把URL及相关组合当做Key, 在使用MD5算法对Key进行哈希，得到硬盘上对应的哈希目录路径，从而将缓存内容保存在该目录中。它可以支持任意URL连接，同时也支持404/301/302这样的非200状态码。Nginx即可以支持对指定URL或者状态码设置过期时间，也可以使用purge命令来手动清除指定URL的缓存。</p>
<p><strong>Nginx中的步骤图示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@6ac0655236f06bca340ca4946f79824c997bff4f/2021/09/20/ade72ddca26dcb51879537d9ed49bf93.png" alt=""></p>
<h2 id="3、Nginx缓存相关指令"><a class="header-anchor" href="#3、Nginx缓存相关指令">¶</a>3、Nginx缓存相关指令</h2>
<p>Nginx的web缓存服务主要是使用<code>ngx_http_proxy_module</code>模块相关指令集来完成，接下来我们把常用的指令来进行介绍下。</p>
<h3 id="proxy-cache-path"><a class="header-anchor" href="#proxy-cache-path">¶</a>proxy_cache_path</h3>
<p>该指定用于设置缓存文件的存放路径</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_cache_path path [levels=number] <br>keys_zone=zone_name:zone_size [inactive=time][max_size=size];</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>http</td>
</tr>
</tbody>
</table>
<p>path：缓存路径地址</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/proxy_cache<br></code></pre></td></tr></tbody></table></figure>
<p>levels: 指定该缓存空间对应的目录，最多可以设置3层，每层取值为1|2</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">levels=1:2   #缓存空间有两层目录，第一次是1个字母，第二次是2个字母<br><span class="hljs-meta">#</span><span class="bash">举例说明:</span><br>itheima[key] #通过MD5加密以后的值为 43c8233266edce38c2c9af0694e2107d<br>levels=1:2   #最终的存储路径为/usr/local/proxy_cache/d/07<br>levels=2:1:2 #最终的存储路径为/usr/local/proxy_cache/7d/0/21<br>levels=2:2:2 #最终的存储路径为/usr/local/proxy_cache/7d/10/e2<br></code></pre></td></tr></tbody></table></figure>
<p>keys_zone：用来为这个缓存区设置名称和指定大小</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">keys_zone=itcast:200m  #缓存区的名称是itcast,大小为200M,1M大概能存储8000个keys<br></code></pre></td></tr></tbody></table></figure>
<p>inactive：指定缓存的数据多次时间未被访问就将被删除</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">inactive=1d   #缓存数据在1天内没有被访问就会被删除<br></code></pre></td></tr></tbody></table></figure>
<p>max_size：设置最大缓存空间，如果缓存空间存满，默认会覆盖缓存时间最长的资源，如:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">max_size=20g<br></code></pre></td></tr></tbody></table></figure>
<p>配置实例：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">http{<br>	proxy_cache_path /usr/local/proxy_cache keys_zone=itcast:200m  levels=1:2:1 inactive=1d max_size=20g;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="proxy-cache"><a class="header-anchor" href="#proxy-cache">¶</a>proxy_cache</h3>
<p>该指令用来开启或关闭代理缓存，如果是开启则自定使用哪个缓存区来进行缓存。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_cache zone_name|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>proxy_cache off;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>zone_name：指定使用缓存区的名称</p>
<h3 id="proxy-cache-key"><a class="header-anchor" href="#proxy-cache-key">¶</a>proxy_cache_key</h3>
<p>该指令用来设置web缓存的key值，Nginx会根据key值MD5哈希存缓存。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_cache_key key;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>proxy_cache_key $scheme$proxy_host$request_uri;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<h3 id="proxy-cache-valid"><a class="header-anchor" href="#proxy-cache-valid">¶</a>proxy_cache_valid</h3>
<p>该指令用来对不同返回状态码的URL设置不同的缓存时间</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_cache_valid [code …] time;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">为200和302的响应URL设置10分钟缓存，为404的响应URL设置1分钟缓存</span><br>proxy_cache_valid 200 302 10m;<br>proxy_cache_valid 404 1m;<br>proxy_cache_valid any 1m; #对所有响应状态码的URL都设置1分钟缓存<br></code></pre></td></tr></tbody></table></figure>
<h3 id="proxy-cache-min-uses"><a class="header-anchor" href="#proxy-cache-min-uses">¶</a>proxy_cache_min_uses</h3>
<p>该指令用来设置资源被访问多少次后被缓存</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_cache_min_uses number;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>proxy_cache_min_uses 1;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<h3 id="proxy-cache-methods"><a class="header-anchor" href="#proxy-cache-methods">¶</a>proxy_cache_methods</h3>
<p>该指令用户设置缓存哪些HTTP方法</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_cache_methods GET|HEAD|POST;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>proxy_cache_methods GET HEAD;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>默认缓存HTTP的GET和HEAD方法，不缓存POST方法。</p>
<h2 id="4、Nginx缓存设置案例"><a class="header-anchor" href="#4、Nginx缓存设置案例">¶</a>4、Nginx缓存设置案例</h2>
<p><strong>需求分析：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@cf98643f3f7cc28f3201a56de4e9bdd7e2c31ac5/2021/09/20/666c5b0e3ef8bbd9495e4714b4c447d9.png" alt=""></p>
<p><strong>应用服务器的环境准备：</strong></p>
<ul>
<li>在192.168.200.146服务器上的tomcat的webapps下面添加一个js目录，并在js目录中添加一个jquery.js文件</li>
<li>启动tomcat</li>
<li>访问测试</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://192.168.200.146:8080/js/jquery.js<br></code></pre></td></tr></tbody></table></figure>
<p><strong>Nginx的环境准备：</strong></p>
<p>1、完成Nginx反向代理配置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">http{<br>	upstream backend{<br>		server 192.168.200.146:8080;<br>	}<br>	server {<br>		listen       8080;<br>        server_name  localhost;<br>        location / {<br>        	proxy_pass http://backend/js/;<br>        }<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>2、添加缓存配置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">http{<br>	proxy_cache_path /usr/local/proxy_cache levels=2:1 keys_zone=itcast:200m inactive=1d max_size=20g;<br>	upstream backend{<br>		server 192.168.200.146:8080;<br>	}<br>	server {<br>		listen       8080;<br>        server_name  localhost;<br>        location / {<br>        	proxy_cache itcast;<br>        	# 默认应该为变值，这里测试使用了固定字串。默认为$scheme$proxy_host$request_uri;<br>            proxy_cache_key itheima;<br>            proxy_cache_min_uses 5;<br>            proxy_cache_valid 200 5d;<br>            proxy_cache_valid 404 30s;<br>            proxy_cache_valid any 1m;<br>            add_header nginx-cache "$upstream_cache_status";<br>        	proxy_pass http://backend/js/;<br>        }<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>add_header nginx-cache “$upstream_cache_status”;</strong></p>
<p>第一次为MISS表示没有命中nginx缓存，再次访问变为HIT表示命中缓存！</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@71ebb3a6977240db5a70df12943ed265df2cd008/2021/09/20/d38dfaef4d6330bcda4cb366a29b2029.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@e9d2978c232ee44e9ccd66ca94a6671a7f401266/2021/09/20/9108de1d213dc3cec96328bec7d43ae7.png" alt=""></p>
<h2 id="5、Nginx缓存的清除"><a class="header-anchor" href="#5、Nginx缓存的清除">¶</a>5、Nginx缓存的清除</h2>
<h3 id="方式一：删除对应的缓存目录"><a class="header-anchor" href="#方式一：删除对应的缓存目录">¶</a>方式一：删除对应的缓存目录</h3>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf /usr/local/proxy_cache/......<br></code></pre></td></tr></tbody></table></figure>
<h3 id="方式二：使用第三方扩展模块（推荐）"><a class="header-anchor" href="#方式二：使用第三方扩展模块（推荐）">¶</a>方式二：使用第三方扩展模块（推荐）</h3>
<p>使用ngx_cache_purge模块，默认没有，需要安装！</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载ngx_cache_purge模块对应的资源包，并上传到服务器上</span><br>ngx_cache_purge-2.3.tar.gz<br>wget http://labs.frickle.com/files/ngx_cache_purge-2.3.tar.gz<br><span class="hljs-meta">#</span><span class="bash"> 对资源文件进行解压缩</span><br>tar -zxf ngx_cache_purge-2.3.tar.gz<br><span class="hljs-meta">#</span><span class="bash"> 修改文件夹名称，方便后期配置</span><br>mv ngx_cache_purge-2.3 purge<br><span class="hljs-meta">#</span><span class="bash"> 查询Nginx的配置参数</span><br>nginx -V<br><span class="hljs-meta">#</span><span class="bash"> 进入Nginx的安装目录，使用./configure进行参数配置</span><br>./configure --add-module=/root/nginx/module/purge<br><span class="hljs-meta">#</span><span class="bash"> 使用make进行编译</span><br>make<br><span class="hljs-meta">#</span><span class="bash"> 将nginx安装目录的nginx二级制可执行文件备份</span><br>mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginxold<br><span class="hljs-meta">#</span><span class="bash"> 将编译后的objs中的nginx拷贝到nginx的sbin目录下</span><br>cp objs/nginx /usr/local/nginx/sbin<br><span class="hljs-meta">#</span><span class="bash"> 使用make进行升级</span><br>make upgrade<br></code></pre></td></tr></tbody></table></figure>
<p><strong>在nginx配置文件中进行如下配置：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">server{<br>	location ~/purge(/.*) {<br><span class="hljs-meta">		#</span><span class="bash"> 缓存名称 缓存key</span><br>		proxy_cache_purge itcast itheima;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>直接访问/purge/文件…即可自动删除！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@d6560b12999df2ba1e4ff852a3ff573f683ba213/2021/09/20/df641183ffd8410c5288339243a89c71.png" alt=""></p>
<p><strong>proxy_cache_purge</strong>：若是key动态的，则也应该与缓存设置中的key一致，即 <code>$scheme$proxy_host$request_uri</code></p>
<p>会发现并不能正常删除，可以在nginx.conf中添加log_format指定日志文件格式：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">log_format main $scheme$proxy_host$request_uri;<br><br>server {<br>    listen       8080;<br>    server_name  localhost;<br>    location / {<br>        # 指定使用的日志格式和位置<br>        access_log logs/access.log main;<br><br>        proxy_cache itcast;<br>        # 默认应该为变值，这里测试使用了固定字串。默认为$scheme$proxy_host$request_uri;<br>        proxy_cache_key itheima;<br>        proxy_cache_min_uses 5;<br>        proxy_cache_valid 200 5d;<br>        proxy_cache_valid 404 30s;<br>        proxy_cache_valid any 1m;<br>        add_header nginx-cache "$upstream_cache_status";<br>        proxy_pass http://backend/js/;<br>    }<br>}<br><br>server{<br>	location ~/purge(/.*) {<br>		access_log logs/access.log main;<br><span class="hljs-meta">		#</span><span class="bash"> 缓存名称 缓存key</span><br>		proxy_cache_purge itcast itheima;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>日志打印如下</strong>：两次访问路径不一致，因此不会删除！真实场景应该写为一致！</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@5068f5a14c31168a862ae6a08a5a3714e192519a/2021/09/20/db9d113302505af6e58493db411a8fc7.png" alt=""></p>
<h2 id="6、Nginx设置资源不缓存"><a class="header-anchor" href="#6、Nginx设置资源不缓存">¶</a>6、Nginx设置资源不缓存</h2>
<blockquote>
<p>前面咱们已经完成了Nginx作为web缓存服务器的使用。但是我们得思考一个问题就是不是所有的数据都适合进行缓存。比如说对于一些经常发生变化的数据。如果进行缓存的话，就很容易出现用户访问到的数据不是服务器真实的数据。所以对于这些资源我们在缓存的过程中就需要进行过滤，不进行缓存。</p>
</blockquote>
<p>Nginx也提供了这块的功能设置，需要使用到如下两个指令</p>
<p><strong>1、proxy_no_cache</strong></p>
<p>该指令是用来定义不将数据进行缓存的条件。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_no_cache string …;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>配置实例</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">proxy_no_cache $cookie_nocache $arg_nocache $arg_comment;<br></code></pre></td></tr></tbody></table></figure>
<p><strong>2、proxy_cache_bypass</strong></p>
<p>该指令是用来设置不从缓存中获取数据的条件。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>proxy_cache_bypass string …;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>配置实例</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">proxy_cache_bypass $cookie_nocache $arg_nocache $arg_comment;<br></code></pre></td></tr></tbody></table></figure>
<p><strong>解释：</strong></p>
<p>上述两个指令都有一个指定的条件，这个条件可以是多个，并且多个条件中至少有一个<strong>不为空且不等于"0"</strong>,则条件满足成立。上面给的配置实例是从官方网站获取的，里面使用到了三个变量，分别是$cookie_nocache、$arg_nocache、$arg_comment</p>
<ul>
<li><code>$cookie_nocache</code>：指的是当前请求的<strong>cookie中键</strong>的名称为nocache对应的值</li>
<li><code>$arg_nocache和$arg_comment</code>：指的是当前<strong>请求的参数</strong>中属性名为nocache和comment对应的属性值</li>
</ul>
<p><strong>案例演示如下:</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">log_format params $cookie_nocache | $arg_nocache | $arg_comment；<br>server{<br>	listen	8081;<br>	server_name localhost;<br>	location /{<br>		access_log logs/access_params.log params;<br>		add_header Set-Cookie 'nocache=999';<br>		root html;<br>		index index.html;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>访问</strong>：<code>https://ip:8081?nocache=888&amp;comment=777</code></p>
<p>日志文件就会出现999 888 777获取到的值!</p>
<h3 id="案例实现"><a class="header-anchor" href="#案例实现">¶</a>案例实现</h3>
<p>设置不缓存资源的配置方案</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">server{<br>	listen	8080;<br>	server_name localhost;<br>	location / {<br><span class="hljs-meta">		#</span><span class="bash"> 请求文件地址和正则匹配</span><br>		if ($request_uri ~ /.*\.js$){<br>		   # 设置其他变量也可，只需将该变量加到	proxy_no_cache 值中即可！<br>           set $nocache 1;<br>        }<br>        add_header nginx-cache "$upstream_cache_status";<br>		proxy_no_cache $nocache $cookie_nocache $arg_nocache $arg_comment;<br>        proxy_cache_bypass $nocache $cookie_nocache $arg_nocache $arg_comment;<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>若使用proxy_cache_bypass，将proxy_no_cache注释，访问会发现 nginx-cache值已经变为了BYPASS表示配置生效！</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@58e2c7c11bc55916523863f33a8ee0670fb00f6b/2021/09/20/d9bfab4e8cd8706604285b6d92fb88ed.png" alt=""></p>
<p><strong>官方推荐两个配置都开启，保证数据最新！</strong></p>
<h1 id="十一、Nginx服务器端集群搭建"><a class="header-anchor" href="#十一、Nginx服务器端集群搭建">¶</a>十一、Nginx服务器端集群搭建</h1>
<h2 id="1、Nginx实现动静分离"><a class="header-anchor" href="#1、Nginx实现动静分离">¶</a>1、Nginx实现动静分离</h2>
<p><strong>什么是动静分离?</strong></p>
<ul>
<li>
<p>动：后台应用程序的业务处理</p>
</li>
<li>
<p>静：网站的静态资源(html,javaScript,css,images等文件)</p>
</li>
<li>
<p>分离：将两者进行分开部署访问，提供用户进行访问。举例说明就是以后所有和静态资源相关的内容都交给Nginx来部署访问，非静态内容则交个类似于Tomcat的服务器来部署访问。</p>
</li>
</ul>
<p><strong>为什么要动静分离?</strong></p>
<p>前面我们介绍过Nginx在<strong>处理静态资源</strong>的时候，效率是非常高的，而且Nginx的<strong>并发</strong>访问量也是名列前茅，而Tomcat则相对比较弱一些，所以把静态资源交给Nginx后，<strong>可以减轻Tomcat服务器的访问压力并提高静态资源的访问速度</strong>。</p>
<p>动静分离以后，<strong>降低了动态资源和静态资源的耦合度</strong>。如动态资源宕机了也不影响静态资源的展示。</p>
<p><strong>如何实现动静分离?</strong></p>
<p>实现动静分离的方式很多，比如静态资源可以部署到CDN、Nginx等服务器上，动态资源可以部署到Tomcat,weblogic或者websphere上。我们<strong>使用Nginx+Tomcat来实现动静分离。</strong></p>
<p><strong>需求分析：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@16e54b05be7fc5bb533016c30560705e8af73555/2021/09/20/5f1b9b461b6e43b4d0b6a6fc63b2716f.png" alt=""></p>
<p><strong>动静分离实现步骤：</strong></p>
<p>1、将demo.war包部署到tomcat中，把之前部署的内容删除掉</p>
<p>2、在Nginx所在服务器创建如下目录，并将对应的静态资源放入指定的位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@441a4412b2b41be6c2b190e2d0333a1872976472/2021/09/20/6536ed1df6cc2bd6d191e221e0917061.png" alt=""></p>
<p>index.html：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</span><br><span class="javascript">           $.get(<span class="hljs-string">'http://192.168.200.133/demo/getAddress'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{</span><br><span class="javascript">               $(<span class="hljs-string">"#msg"</span>).html(data);</span><br>           });<br>        });<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"images/logo.png"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Nginx如何将请求转发到后端服务器<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"msg"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"images/mv.png"</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></tbody></table></figure>
<p>3、配置Nginx的静态资源与动态资源的访问</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream webservice{<br>   server 192.168.200.146:8080;<br>}<br>server {<br>        listen       80;<br>        server_name  localhost;<br><br>        #动态资源<br>        location /demo {<br>                proxy_pass http://webservice;<br>        }<br>        #静态资源<br>        location ~/.*\.(png|jpg|gif|js){<br>                root html/web;<br>                gzip on;<br>        }<br><br>        location / {<br>            root   html/web;<br>            index  index.html index.htm;<br>        }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>4、启动测试，访问 <code>http://192.168.200.133/</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@265a47eb5fbbaf4d4484a8fda7c2551db6949251/2021/09/20/911c8b1870724242bb473f6ab0ec2d50.png" alt=""></p>
<p><strong>小结</strong>：</p>
<p>假如某个时间点，由于某个原因导致Tomcat后的服务器宕机了，我们再次访问Nginx，用户还是能看到页面，只是缺失了访问端口的展示，这就是前后端耦合度降低的效果，并且整个请求只和后的服务器交互了一次，js和images都直接从Nginx返回，提供了效率，降低了后的服务器的压力。</p>
<h2 id="2、Nginx实现Tomcat集群搭建"><a class="header-anchor" href="#2、Nginx实现Tomcat集群搭建">¶</a>2、Nginx实现Tomcat集群搭建</h2>
<p>一台服务器容易宕机，那就多搭建几台Tomcat服务器，这样的话就提升了后的服务器的可用性。这也就是我们常说的集群，搭建Tomcat的集群需要用到了Nginx的反向代理和负载均衡的知识，具体如何来实现?我们先来分析下原理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@35d06e9c898d62d7e5c3f71f2022af4a07aee05e/2021/09/20/f06f9bf110d4ed26a23224d7d8331381.png" alt=""></p>
<p><strong>环境准备：</strong></p>
<p>1、准备3台tomcat，使用端口进行区分[实际环境应该是三台服务器]，修改server.xml，将端口修改分别修改为8080,8180,8280。将shutdown端口也修改了不要一样！</p>
<p>2、启动tomcat并访问测试</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">http://192.168.200.146:8080/demo/getAddress<br>http://192.168.200.146:8180/demo/getAddress<br>http://192.168.200.146:8280/demo/getAddress<br></code></pre></td></tr></tbody></table></figure>
<p>3、在Nginx对应的配置文件中添加如下内容</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream webservice{<br>    server 192.168.200.146:8080;<br>    server 192.168.200.146:8180;<br>    server 192.168.200.146:8280;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3、Nginx高可用解决方案"><a class="header-anchor" href="#3、Nginx高可用解决方案">¶</a>3、Nginx高可用解决方案</h2>
<blockquote>
<p>需要两台以上的Nginx服务器对外提供服务，这样的话就可以解决其中一台宕机了，另外一台还能对外提供服务，但是如果是两台Nginx服务器的话，会有两个IP地址，用户该访问哪台服务器，用户怎么知道哪台是好的，哪台是宕机了的?</p>
<p>这就要用到 Keepalived 了！</p>
</blockquote>
<h3 id="Keepalived"><a class="header-anchor" href="#Keepalived">¶</a>Keepalived</h3>
<p>使用Keepalived来解决，Keepalived 软件由 C 编写的，最初是专为 LVS 负载均衡软件设计的，Keepalived 软件主要是通过 VRRP 协议实现高可用功能。</p>
<h3 id="VRRP介绍"><a class="header-anchor" href="#VRRP介绍">¶</a>VRRP介绍</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@2fd53841181b8f25bbe9a42734c072ae50189af0/2021/09/20/516ac58e49de49f012a010bf2569e2da.png" alt=""></p>
<p><strong>VRRP（Virtual Route Redundancy Protocol）协议</strong>：翻译过来为虚拟路由冗余协议。VRRP协议将两台或多台路由器设备虚拟成一个设备，对外提供虚拟路由器IP,而在路由器组内部，如果实际拥有这个对外IP的路由器如果工作正常的话就是MASTER, MASTER实现针对虚拟路由器IP的各种网络功能。其他设备不拥有该虚拟IP，状态为BACKUP,处了接收MASTER的VRRP状态通告信息以外，不执行对外的网络功能。当主机失效时，BACKUP将接管原先MASTER的网络功能。</p>
<p><strong>从上面的介绍信息获取到的内容就是VRRP是一种协议，那这个协议是用来干什么的？</strong></p>
<ul>
<li><strong>选择协议</strong>：VRRP可以把一个虚拟路由器的责任动态分配到局域网上的 VRRP 路由器中的一台。其中的虚拟路由即Virtual路由是由VRRP路由群组创建的一个不真实存在的路由，这个虚拟路由也是有对应的IP地址。而且VRRP路由1和VRRP路由2之间会有竞争选择，通过选择会产生一个Master路由和一个Backup路由。</li>
<li><strong>路由容错协议</strong>：Master路由和Backup路由之间会有一个心跳检测，Master会定时告知Backup自己的状态，如果在指定的时间内，Backup没有接收到这个通知内容，Backup就会替代Master成为新的Master。Master路由有一个特权就是虚拟路由和后端服务器都是通过Master进行数据传递交互的，而备份节点则会直接丢弃这些请求和数据，不做处理，只是去监听Master的状态</li>
</ul>
<p><strong>用了Keepalived后，解决方案如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@940fcc089b51deb8ca559dceed3747548b22597e/2021/09/20/c4fed4170b6aa736a428923643496b97.png" alt=""></p>
<h3 id="环境搭建"><a class="header-anchor" href="#环境搭建">¶</a>环境搭建</h3>
<p><strong>环境准备：</strong></p>
<table>
<thead>
<tr>
<th>VIP</th>
<th>IP</th>
<th>主机名</th>
<th>主/从</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>192.168.200.133</td>
<td>keepalived1</td>
<td>Master</td>
</tr>
<tr>
<td>192.168.200.222</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>192.168.200.122</td>
<td>keepalived2</td>
<td>Backup</td>
</tr>
</tbody>
</table>
<p><strong>keepalived的安装：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 步骤1:从官方网站下载keepalived,官网地址https://keepalived.org/</span><br><span class="hljs-meta">#</span><span class="bash"> 步骤2:将下载的资源上传到服务器 keepalived-2.0.20.tar.gz</span><br><span class="hljs-meta">#</span><span class="bash"> 步骤3:创建keepalived目录，方便管理资源</span><br>mkdir keepalived<br><span class="hljs-meta">#</span><span class="bash"> 步骤4:将压缩文件进行解压缩，解压缩到指定的目录</span><br>tar -zxf keepalived-2.0.20.tar.gz -C keepalived/<br><span class="hljs-meta">#</span><span class="bash"> 步骤5:对keepalived进行配置，编译和安装</span><br>cd keepalived/keepalived-2.0.20<br>./configure --sysconf=/etc --prefix=/usr/local<br>make &amp;&amp; make install<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><code>/etc/keepalived/keepalived.conf</code>：keepalived的系统配置文件</li>
<li><code>/usr/local/sbin/keepalived</code>：是系统配置脚本，用来启动和关闭keepalived</li>
</ul>
<h3 id="Keepalived配置文件介绍"><a class="header-anchor" href="#Keepalived配置文件介绍">¶</a>Keepalived配置文件介绍</h3>
<p><strong>这里面会分三部，第一部分是global全局配置、第二部分是vrrp相关配置、第三部分是LVS相关配置。</strong></p>
<p>我们主要是使用keepalived实现高可用部署，没有用到LVS，所以我们重点关注的是前两部分！</p>
<p><strong>配置介绍：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">global全局部分：</span><br>global_defs {<br><span class="hljs-meta">   #</span><span class="bash">通知邮件，当keepalived发送切换时需要发email给具体的邮箱地址</span><br>   notification_email {<br>     tom@itcast.cn<br>     jerry@itcast.cn<br>   }<br><span class="hljs-meta">   #</span><span class="bash">设置发件人的邮箱信息</span><br>   notification_email_from zhaomin@itcast.cn<br><span class="hljs-meta">   #</span><span class="bash">指定smpt服务地址</span><br>   smtp_server 192.168.200.1<br><span class="hljs-meta">   #</span><span class="bash">指定smpt服务连接超时时间</span><br>   smtp_connect_timeout 30<br><span class="hljs-meta">   #</span><span class="bash">运行keepalived服务器的一个标识，可以用作发送邮件的主题信息</span><br>   router_id LVS_DEVEL<br>   <br><span class="hljs-meta">   #</span><span class="bash">默认是不跳过检查。检查收到的VRRP通告中的所有地址可能会比较耗时，设置此命令的意思是，如果通告与接收的上一个通告来自相同的master路由器，则不执行检查(跳过检查)</span><br>   vrrp_skip_check_adv_addr<br><span class="hljs-meta">   #</span><span class="bash">严格遵守VRRP协议。</span><br>   vrrp_strict<br><span class="hljs-meta">   #</span><span class="bash">在一个接口发送的两个免费ARP之间的延迟。可以精确到毫秒级。默认是0</span><br>   vrrp_garp_interval 0<br><span class="hljs-meta">   #</span><span class="bash">在一个网卡上每组na消息之间的延迟时间，默认为0</span><br>   vrrp_gna_interval 0<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>VRRP实例配置：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> VRRP部分，该部分可以包含以下四个子模块</span><br><span class="hljs-meta">#</span><span class="bash"> 1. vrrp_script</span><br><span class="hljs-meta">#</span><span class="bash"> 2. vrrp_sync_group</span><br><span class="hljs-meta">#</span><span class="bash"> 3. garp_group</span><br><span class="hljs-meta">#</span><span class="bash"> 4. vrrp_instance</span><br><span class="hljs-meta">#</span><span class="bash"> 我们会用到第一个和第四个</span><br><span class="hljs-meta">#</span><span class="bash"> 设置keepalived实例的相关信息，VI_1为VRRP实例名称</span><br>vrrp_instance VI_1 {<br>    state MASTER  		#有两个值可选MASTER主 BACKUP备<br>    interface ens33		#vrrp实例绑定的接口，用于发送VRRP包[当前服务器使用的网卡名称]<br>    virtual_router_id 51#指定VRRP实例ID，范围是0-255<br>    priority 100		#指定优先级，优先级高的将成为MASTER<br>    advert_int 1		#指定发送VRRP通告的间隔，单位是秒<br>    authentication {	#vrrp之间通信的认证信息<br>        auth_type PASS	#指定认证方式。PASS简单密码认证(推荐)<br>        auth_pass 1111	#指定认证使用的密码，最多8位<br>    }<br>    virtual_ipaddress { #虚拟IP地址设置虚拟IP地址，供用户访问使用，可设置多个，一行一个<br>        192.168.200.222<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>完整配置服务器1：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">global_defs {<br>   notification_email {<br>        tom@itcast.cn<br>        jerry@itcast.cn<br>   }<br>   notification_email_from zhaomin@itcast.cn<br>   smtp_server 192.168.200.1<br>   smtp_connect_timeout 30<br>   router_id keepalived1<br>   vrrp_skip_check_adv_addr<br>   vrrp_strict<br>   vrrp_garp_interval 0<br>   vrrp_gna_interval 0<br>}<br><br>vrrp_instance VI_1 {<br>    state MASTER<br>    interface ens33<br>    virtual_router_id 51<br>    priority 100<br>    advert_int 1<br>    authentication {<br>        auth_type PASS<br>        auth_pass 1111<br>    }<br>    virtual_ipaddress {<br>        192.168.200.222<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>完整配置服务器2：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">global_defs {<br>   notification_email {<br>        tom@itcast.cn<br>        jerry@itcast.cn<br>   }<br>   notification_email_from zhaomin@itcast.cn<br>   smtp_server 192.168.200.1<br>   smtp_connect_timeout 30<br>   router_id keepalived2<br>   vrrp_skip_check_adv_addr<br>   vrrp_strict<br>   vrrp_garp_interval 0<br>   vrrp_gna_interval 0<br>}<br><br>vrrp_instance VI_1 {<br>    state BACKUP<br>    interface ens33<br>    virtual_router_id 51<br>    priority 90<br>    advert_int 1<br>    authentication {<br>        auth_type PASS<br>        auth_pass 1111<br>    }<br>    virtual_ipaddress {<br>        192.168.200.222<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="访问测试"><a class="header-anchor" href="#访问测试">¶</a>访问测试</h3>
<p>1、启动keepalived之前，先使用命令 <code>ip a</code>, 查看192.168.200.133和192.168.200.122这两台服务器的IP情况。</p>
<p>2、分别启动两台服务器的keepalived</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/local/sbin<br>./keepalived<br></code></pre></td></tr></tbody></table></figure>
<p>再次通过 <code>ip a</code>查看ip：</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@9312cf6a722e3ea18f9e406c67467e169720601c/2021/09/20/2cdc6358d5d7314c8e2bc64994a64cfb.png" alt=""></p>
<p>3、当把192.168.200.133服务器上的keepalived关闭后，再次查看ip</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@c06dc6a7bdd4e7775a2d35f2b4228dd50524f8d7/2021/09/20/ddf7e9e89216ab72194a2a0fd45c8d6f.png" alt=""></p>
<p><strong>总结：</strong></p>
<ul>
<li>我们会发现，虚拟IP(VIP)会在MASTER节点上，当MASTER节点上的keepalived出问题以后，因为BACKUP无法收到MASTER发出的VRRP状态通过信息，就会直接升为MASTER。VIP也会"<strong>漂移</strong>"到新的MASTER。</li>
<li>我们把192.168.200.133服务器的keepalived再次启动下，由于它的<strong>优先级高</strong>于服务器192.168.200.122的，所有它会再次成为MASTER，VIP也会"漂移"过去，然后我们再次通过浏览器访问：<code>http://192.168.200.222/</code></li>
<li><strong>我们会发现要想让vip进行切换，就必须要把服务器上的keepalived进行关闭</strong></li>
</ul>
<h3 id="keepalived之vrrp-script"><a class="header-anchor" href="#keepalived之vrrp-script">¶</a>keepalived之vrrp_script</h3>
<ul>
<li>keepalived<strong>只能做到对网络故障和keepalived本身的监控</strong>，即当出现网络故障或者keepalived本身出现问题时，进行切换。</li>
<li>但是这些还不够，我们还需要监控keepalived所在服务器上的其他业务，比如Nginx,如果Nginx出现异常了，仅仅keepalived保持正常，是无法完成系统的正常工作的，因此需要根据业务进程的运行状态决定是否需要进行主备切换，这个时候，我们可以通过<strong>编写脚本</strong>对业务进程进行检测监控。</li>
</ul>
<p><strong>实现步骤：</strong></p>
<p><strong>在keepalived配置文件中添加对应的配置：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">vrrp_script 脚本名称<br>{<br>    script "脚本位置"<br>    interval 3 #执行时间间隔<br>    weight -20 #动态调整vrrp_instance的优先级<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>编写脚本 ck_nginx.sh：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>num=`ps -C nginx --no-header | wc -l`<br>if [ $num -eq 0 ];then<br> /usr/local/nginx/sbin/nginx<br> sleep 2<br> if [ `ps -C nginx --no-header | wc -l` -eq 0 ]; then<br>  killall keepalived<br> fi<br>fi<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>ps命令：用于显示当前进程 (process) 的状态</li>
<li>-C(command)：指定命令的所有进程</li>
<li>–no-header：排除标题</li>
</ul>
<p><strong>为脚本文件设置权限：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 755 ck_nginx.sh<br></code></pre></td></tr></tbody></table></figure>
<p><strong>将脚本添加到配置文件：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">vrrp_script ck_nginx {<br>   script "/etc/keepalived/ck_nginx.sh" #执行脚本的位置<br>   interval 2		#执行脚本的周期，秒为单位<br>   weight -20		#权重的计算方式，表示当前Master挂了后，将自身权重降低20，降到小于Backup的优先级即可，这样可以保证当前nginx正常后，不会自动再切换回当前服务器<br>}<br>vrrp_instance VI_1 {<br>    state MASTER<br>    interface ens33<br>    virtual_router_id 10<br>    priority 100<br>    advert_int 1<br>    authentication {<br>        auth_type PASS<br>        auth_pass 1111<br>    }<br>    virtual_ipaddress {<br>        192.168.200.111<br>    }<br>    track_script {<br>      ck_nginx<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>如果效果没有出来，可以使用 <code>tail -f /var/log/messages</code>查看日志信息，找对应的错误信息。</strong></p>
<p><strong>问题思考？</strong></p>
<p>通常如果master服务死掉后backup会变成master，但是当master服务又好了的时候 master此时会抢占VIP，这样就会发生两次切换对业务繁忙的网站来说是不好的。可以设置vrrp_script中的weight来动态调整当前nginx的优先级！</p>
<h1 id="十二、Nginx制作下载站点"><a class="header-anchor" href="#十二、Nginx制作下载站点">¶</a>十二、Nginx制作下载站点</h1>
<p><strong>首先我们先要清楚什么是下载站点?</strong></p>
<p>我们先来看一个网站<code>http://nginx.org/download/</code>这个我们刚开始学习Nginx的时候给大家看过这样的网站，该网站主要就是用来提供用户来下载相关资源的网站，就叫做下载网站。</p>
<p><strong>如何制作一个下载站点？</strong></p>
<p>nginx使用的是模块ngx_http_autoindex_module来实现的，该模块处理以斜杠(“/”)结尾的请求，并生成目录列表。</p>
<p>nginx编译的时候会自动加载该模块，但是该模块默认是关闭的，我们需要使用下来指令来完成对应的配置。</p>
<p>1、autoindex：启用或禁用目录列表输出</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>autoindex on|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>autoindex off;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>2、autoindex_exact_size：对应HTLM格式，指定是否在目录列表展示文件的详细大小</p>
<ul>
<li>默认为on，显示出文件的确切大小，单位是bytes。</li>
<li>改为off后，显示出文件的大概大小，单位是kB或者MB或者GB</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>autoindex_exact_size  on|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>autoindex_exact_size  on;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>3、autoindex_format：设置目录列表的格式</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>autoindex_format html|xml|json|jsonp;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>autoindex_format html;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong></p>
<ul>
<li>
<p>该指令在1.7.9及以后版本中出现</p>
</li>
<li>
<p>XML/JSON格式一般不用这两种方式！</p>
</li>
</ul>
<p>4、autoindex_localtime：对应HTML格式，是否在目录列表上显示时间。</p>
<ul>
<li>默认为off，显示的文件时间为GMT时间。</li>
<li>改为on后，显示的文件时间为文件的服务器时间</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>autoindex_localtime on | off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>autoindex_localtime off;</td>
</tr>
<tr>
<td>位置</td>
<td>http、server、location</td>
</tr>
</tbody>
</table>
<p>配置方式如下:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /download{<br>    root /usr/local;<br>    autoindex on;<br>    autoindex_exact_size on;<br>    autoindex_format html;<br>    autoindex_localtime on;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h1 id="十三、Nginx的用户认证模块"><a class="header-anchor" href="#十三、Nginx的用户认证模块">¶</a>十三、Nginx的用户认证模块</h1>
<blockquote>
<p>对应系统资源的访问，我们往往需要限制谁能访问，谁不能访问。这块就是我们通常所说的认证部分，认证需要做的就是根据用户输入的用户名和密码来判定用户是否为合法用户，如果是则放行访问，如果不是则拒绝访问。</p>
<p>Nginx对应用户认证这块是通过 <code>ngx_http_auth_basic_module</code> 模块来实现的，它允许通过使用"HTTP基本身份验证"协议验证用户名和密码来限制对资源的访问。默认情况下nginx是已经安装了该模块，如果不需要则使用 <code>--without-http_auth_basic_module</code>。</p>
</blockquote>
<p>1、auth_basic：使用“ HTTP基本认证”协议启用用户名和密码的验证</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>auth_basic string|off;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>auth_basic off;</td>
</tr>
<tr>
<td>位置</td>
<td>http,server,location,limit_except</td>
</tr>
</tbody>
</table>
<p>开启后，服务端会返回401，指定的字符串会返回到客户端，给用户以提示信息，但是不同的浏览器对内容的展示不一致。</p>
<p>2、auth_basic_user_file：指定用户名和密码所在文件</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>auth_basic_user_file file;</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认值</td>
<td>—</td>
</tr>
<tr>
<td>位置</td>
<td>http,server,location,limit_except</td>
</tr>
</tbody>
</table>
<p>指定文件路径，该文件中的用户名和密码的设置，<strong>密码需要进行加密。可以采用工具自动生成</strong></p>
<p><strong>nginx.conf 添加如下内容：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /download{<br>    root /usr/local;<br>    autoindex on;<br>    autoindex_exact_size on;<br>    autoindex_format html;<br>    autoindex_localtime on;<br>    auth_basic 'please input your auth';<br>    auth_basic_user_file htpasswd; # 文件路径/usr/local/nginx/conf/htpasswd<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>我们需要使用<code>htpasswd</code>工具生成用户名和密码：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y httpd-tools<br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">htpasswd -c /usr/local/nginx/conf/htpasswd username #创建一个新文件记录用户名和密码<br>htpasswd -b /usr/local/nginx/conf/htpasswd username password #在指定文件新增一个用户名和密码<br>htpasswd -D /usr/local/nginx/conf/htpasswd username #从指定文件删除一个用户信息<br>htpasswd -v /usr/local/nginx/conf/htpasswd username #验证用户名和密码是否正确<br></code></pre></td></tr></tbody></table></figure>
<p><strong>效果如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@c68204e5fd984844940b517151e85db298f00e2e/2021/09/20/b131a6f43326a2f1c47da030ad08c20d.png" alt=""></p>
<p><strong>小结：</strong></p>
<p>上述方式虽然能实现用户名和密码的验证，但是大家也看到了，所有的用户名和密码信息都记录在文件里面，如果用户量过大的话，这种方式就显得有点麻烦了，这时候我们就得通过<strong>后台业务代码来进行用户权限的校验</strong>了。</p>
<h1 id="十四、Nginx的扩展模块"><a class="header-anchor" href="#十四、Nginx的扩展模块">¶</a>十四、Nginx的扩展模块</h1>
<blockquote>
<p>Nginx是可扩展的，可用于处理各种使用场景。本节中，我们将探讨使用<strong>Lua扩展Nginx的功能</strong>。</p>
</blockquote>
<h2 id="1、Lua"><a class="header-anchor" href="#1、Lua">¶</a>1、Lua</h2>
<h3 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h3>
<p>Lua是一种轻量、小巧的脚本语言，用标准C语言编写并以源代码形式开发。设计的目的是为了嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
<h3 id="特性"><a class="header-anchor" href="#特性">¶</a>特性</h3>
<p>跟其他语言进行比较，Lua有其自身的特点：</p>
<ul>
<li>轻量级：Lua用标准C语言编写并以源代码形式开发，编译后仅仅一百余千字节，可以很方便的嵌入到其他程序中。</li>
<li>可扩展：Lua提供非常丰富易于使用的扩展接口和机制，由宿主语言(通常是C或C++)提供功能，Lua可以使用它们，就像内置的功能一样。</li>
<li>支持面向过程编程和函数式编程</li>
</ul>
<h3 id="应用场景"><a class="header-anchor" href="#应用场景">¶</a>应用场景</h3>
<p>Lua在不同的系统中得到大量应用，场景的应用场景如下:</p>
<p>游戏开发、独立应用脚本、web应用脚本、扩展和数据库插件、系统安全上。</p>
<h3 id="Lua的安装"><a class="header-anchor" href="#Lua的安装">¶</a>Lua的安装</h3>
<p>在linux上安装Lua非常简单，只需要下载源码包并在终端解压、编译即可使用。</p>
<p>Lua的官网地址为:<code>https://www.lua.org</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://www.lua.org/ftp/lua-5.4.1.tar.gz<br>cd lua-5.4.1<br>make linux test<br>make install<br><span class="hljs-meta">#</span><span class="bash"> 验证是否安装成功</span><br>lua -v<br></code></pre></td></tr></tbody></table></figure>
<h3 id="Lua的语法"><a class="header-anchor" href="#Lua的语法">¶</a>Lua的语法</h3>
<p>Lua和C/C++语法非常相似，整体上比较清晰，简洁。条件语句、循环语句、函数调用都与C/C++基本一致。如果对C/C++不太熟悉的同学来说，也没关系，因为天下语言是一家，基本上理解起来都不会太困难。我们一点点来讲。</p>
<h4 id="第一个Lua程序"><a class="header-anchor" href="#第一个Lua程序">¶</a>第一个Lua程序</h4>
<ul>
<li>
<p>Lua交互式编程模式：可以通过命令lua -i 或lua来启用</p>
</li>
<li>
<p>Lua脚本式编程模式：是将代码保存到一个以lua为扩展名的文件中并执行的方式</p>
</li>
</ul>
<p><strong>脚本式方式一：</strong></p>
<p>我们需要一个文件名为 hello.lua,在文件中添加要执行的代码，然后通过命令 <code>lua hello.lua</code>来执行，会在控制台输出对应的结果。</p>
<p>hello.lua</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello World!!"</span>)<br></code></pre></td></tr></tbody></table></figure>
<p><strong>脚本式方式二：</strong></p>
<p>将hello.lua做如下修改</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">#!/usr/<span class="hljs-keyword">local</span>/bin/lua<br><span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello World!!!"</span>)<br></code></pre></td></tr></tbody></table></figure>
<p>第一行用来指定Lua解释器所在位置为 <code>/usr/local/bin/lua</code>，加上#号标记解释器会忽略它。一般情况下<code>#!</code>就是用来指定用哪个程序来运行本文件。但是hello.lua并不是一个可执行文件，需要通过chmod来设置可执行权限，最简单的方式为：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 755 hello.lua<br><br><span class="hljs-meta">#</span><span class="bash"> 执行即可</span><br>./hello.lua<br></code></pre></td></tr></tbody></table></figure>
<p>可以使用dofile函数指明lua脚本路径在交互式命令行中运行：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">dofile</span>(<span class="hljs-string">"lua_demo/hello.lua"</span>)<br></code></pre></td></tr></tbody></table></figure>
<p><strong>注意：在Lua语言中，连续语句之间的分隔符并不是必须的，也就是说后面不需要加分号，当然加上也不会报错</strong></p>
<p>在Lua语言中，表达式之间的换行也起不到任何作用。如以下四个写法，其实都是等效的</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--写法一</span><br>a=<span class="hljs-number">1</span><br>b=a+<span class="hljs-number">2</span><br><span class="hljs-comment">--写法二</span><br>a=<span class="hljs-number">1</span>;<br>b=a+<span class="hljs-number">2</span>;<br><span class="hljs-comment">--写法三</span><br>a=<span class="hljs-number">1</span>; b=a+<span class="hljs-number">2</span>;<br><span class="hljs-comment">--写法四</span><br>a=<span class="hljs-number">1</span> b=a+<span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure>
<p><strong>不建议使用第四种方式，可读性太差。</strong></p>
<h4 id="Lua的注释"><a class="header-anchor" href="#Lua的注释">¶</a>Lua的注释</h4>
<p>关于Lua的注释要分两种，第一种是单行注释，第二种是多行注释。</p>
<p><strong>单行注释的语法为：</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--注释内容</span><br></code></pre></td></tr></tbody></table></figure>
<p><strong>多行注释的语法为:</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--[[</span><br><span class="hljs-comment">	注释内容</span><br><span class="hljs-comment">	注释内容</span><br><span class="hljs-comment">--]]</span><br></code></pre></td></tr></tbody></table></figure>
<p><strong>如果想取消多行注释，只需要在第一个–之前在加一个-即可</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">---[[</span><br>	注释内容<br>	注释内容<br><span class="hljs-comment">--]]</span><br></code></pre></td></tr></tbody></table></figure>
<h4 id="标识符"><a class="header-anchor" href="#标识符">¶</a>标识符</h4>
<p>换句话说标识符就是我们的变量名，Lua定义变量名以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字（0到9）。这块建议大家最好不要使用下划线加大写字母的标识符，因为Lua的保留字也是这样定义的，容易发生冲突。注意Lua是区分大小写字母的。</p>
<h4 id="关键字"><a class="header-anchor" href="#关键字">¶</a>关键字</h4>
<p>下列是Lua的关键字，大家在定义常量、变量或其他用户自定义标识符都要避免使用以下这些关键字：</p>
<table>
<thead>
<tr>
<th>and</th>
<th>break</th>
<th>do</th>
<th>else</th>
</tr>
</thead>
<tbody>
<tr>
<td>elseif</td>
<td>end</td>
<td>false</td>
<td>for</td>
</tr>
<tr>
<td>function</td>
<td>if</td>
<td>in</td>
<td>local</td>
</tr>
<tr>
<td>nil</td>
<td>not</td>
<td>or</td>
<td>repeat</td>
</tr>
<tr>
<td>return</td>
<td>then</td>
<td>true</td>
<td>until</td>
</tr>
<tr>
<td>while</td>
<td>goto</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。这个也是上面我们不建议这么定义标识符的原因。</p>
<h4 id="运算符"><a class="header-anchor" href="#运算符">¶</a>运算符</h4>
<p>Lua中支持的运算符有算术运算符、关系运算符、逻辑运算符、其他运算符。</p>
<p><strong>算术运算符：</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">+   加法<br>-	减法<br>*	乘法<br>/	除法<br>%	取余<br>^	乘幂<br>-	负号<br></code></pre></td></tr></tbody></table></figure>
<p><strong>关系运算符：</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">==	等于<br>~=	不等于<br>&gt;	大于<br>&lt;	小于<br>&gt;=	大于等于<br>&lt;=	小于等于<br></code></pre></td></tr></tbody></table></figure>
<p><strong>逻辑运算符：</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">and</span>	逻辑与<br><span class="hljs-keyword">or</span>	逻辑或<br><span class="hljs-keyword">not</span>	逻辑非<br></code></pre></td></tr></tbody></table></figure>
<p><strong>其他运算符：</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">..	<span class="hljs-comment">-- 连接两个字符串</span><br>#	<span class="hljs-comment">-- 一元运算符，返回字符串或表的长度</span><br></code></pre></td></tr></tbody></table></figure>
<p>例如:</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">&gt; <span class="hljs-string">"HELLO "</span>..<span class="hljs-string">"WORLD"</span>		<span class="hljs-comment">--&gt;HELLO WORLD</span><br>&gt; #<span class="hljs-string">"HELLO"</span>			<span class="hljs-comment">--&gt;5</span><br></code></pre></td></tr></tbody></table></figure>
<h4 id="全局变量-局部变量"><a class="header-anchor" href="#全局变量-局部变量">¶</a>全局变量&amp;局部变量</h4>
<ul>
<li>在Lua语言中，全局变量无须声明即可使用。在默认情况下，变量总是认为是全局的，如果未提前赋值，默认为nil</li>
<li>要想声明一个局部变量，需要使用local来声明</li>
</ul>
<h4 id="Lua数据类型"><a class="header-anchor" href="#Lua数据类型">¶</a>Lua数据类型</h4>
<p><strong>Lua有8个数据类型：</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-literal">nil</span>(空，无效值)<br>boolean(布尔，<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>)<br>number(数值)<br><span class="hljs-built_in">string</span>(字符串)<br><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(函数)</span></span><br><span class="hljs-built_in">table</span>（表）<br>thread(线程)<br>userdata（用户数据）<br></code></pre></td></tr></tbody></table></figure>
<p><strong>可以使用type函数测试给定变量或者的类型：</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-literal">nil</span>))				<span class="hljs-comment">--&gt;nil</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-literal">true</span>))               <span class="hljs-comment">--&gt; boolean</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-number">1.1</span>*<span class="hljs-number">1.1</span>))             <span class="hljs-comment">--&gt; number</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-string">"Hello world"</span>))      <span class="hljs-comment">--&gt; string</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">io</span>.<span class="hljs-built_in">stdin</span>))			<span class="hljs-comment">--&gt;userdata</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">print</span>))              <span class="hljs-comment">--&gt; function</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">type</span>))               <span class="hljs-comment">--&gt;function</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>{})					<span class="hljs-comment">--&gt;table</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">type</span>(X)))            <span class="hljs-comment">--&gt; string</span><br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>nil</strong>：nil是一种只有一个nil值的类型，它的作用可以用来与其他所有值进行区分，也可以当想要移除一个变量时，只需要将该变量名赋值为nil,垃圾回收就会会释放该变量所占用的内存。</li>
<li><strong>boolean</strong>：具有两个值，true和false。boolean类型一般被用来做条件判断的真与假。在Lua语言中，<strong>只会将false和nil视为假</strong>，其他的都视为真，特别是在条件检测中<strong>0和空字符串都会认为是真</strong>，这个和我们熟悉的大多数语言不太一样。</li>
<li><strong>number</strong>：在Lua5.3版本开始，Lua语言为数值格式提供了两种选择：integer(整型)和float(双精度浮点型)[和其他语言不太一样，float不代表单精度类型。</li>
</ul>
<p><strong>数值常量的表示方式：</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">&gt;<span class="hljs-number">4</span>			<span class="hljs-comment">--&gt;4</span><br>&gt;<span class="hljs-number">0.4</span>		<span class="hljs-comment">--&gt;0.4</span><br>&gt;<span class="hljs-number">4.75e-3</span>	<span class="hljs-comment">--&gt;0.00475</span><br>&gt;<span class="hljs-number">4.75e3</span>		<span class="hljs-comment">--&gt;4750</span><br></code></pre></td></tr></tbody></table></figure>
<p>不管是整型还是双精度浮点型，使用type()函数来取其类型，都会返回的是number：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">&gt;<span class="hljs-built_in">type</span>(<span class="hljs-number">3</span>)	<span class="hljs-comment">--&gt;number</span><br>&gt;<span class="hljs-built_in">type</span>(<span class="hljs-number">3.3</span>)	<span class="hljs-comment">--&gt;number</span><br></code></pre></td></tr></tbody></table></figure>
<p>所以它们之间是可以相互转换的，同时，具有相同算术值的整型值和浮点型值在Lua语言中是相等的。</p>
<ul>
<li><strong>string</strong>：Lua语言中的字符串即可以表示单个字符，也可以表示一整本书籍。在Lua语言中，操作100K或者1M个字母组成的字符串的程序很常见。可以使用单引号或双引号来声明字符串。</li>
</ul>
<p>如果声明的字符串比较长或者有多行，则可以使用如下方式进行声明</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">html = <span class="hljs-string">[[</span><br><span class="hljs-string">&lt;html&gt;</span><br><span class="hljs-string">&lt;head&gt;</span><br><span class="hljs-string">&lt;title&gt;Lua-string&lt;/title&gt;</span><br><span class="hljs-string">&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">&lt;a href="http://www.lua.org"&gt;Lua&lt;/a&gt;</span><br><span class="hljs-string">&lt;/body&gt;</span><br><span class="hljs-string">&lt;/html&gt;</span><br><span class="hljs-string">]]</span><br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>table</strong>：是Lua语言中最主要和强大的数据结构。使用表， Lua 语言可以以一种简单、统一且高效的方式表示数组、集合、记录和其他很多数据结构。 Lua语言中的表本质上是一种辅助数组。这种数组比Java中的数组更加灵活，可以使用数值做索引，也可以使用字符串或其他任意类型的值作索引(除nil外)。</li>
</ul>
<p>创建表的最简单方式：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">&gt; a = {}<br></code></pre></td></tr></tbody></table></figure>
<p>创建数组：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">&gt;arr = {<span class="hljs-string">"TOM"</span>,<span class="hljs-string">"JERRY"</span>,<span class="hljs-string">"ROSE"</span>}<br></code></pre></td></tr></tbody></table></figure>
<p>要想获取数组中的值，我们可以通过如下内容来获取:</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(arr[<span class="hljs-number">0</span>])		<span class="hljs-literal">nil</span><br><span class="hljs-built_in">print</span>(arr[<span class="hljs-number">1</span>])		TOM<br><span class="hljs-built_in">print</span>(arr[<span class="hljs-number">2</span>])		JERRY<br><span class="hljs-built_in">print</span>(arr[<span class="hljs-number">3</span>])		ROSE<br></code></pre></td></tr></tbody></table></figure>
<p>从上面的结果可以看出来，<strong>数组的下标默认是从1开始的</strong>。所以上述创建数组，也可以通过如下方式来创建。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">&gt;arr = {}<br>&gt;arr[<span class="hljs-number">1</span>] = <span class="hljs-string">"TOM"</span><br>&gt;arr[<span class="hljs-number">2</span>] = <span class="hljs-string">"JERRY"</span><br>&gt;arr[<span class="hljs-number">3</span>] = <span class="hljs-string">"ROSE"</span><br></code></pre></td></tr></tbody></table></figure>
<p>上面我们说过了，<strong>表的索引既可以是数字，也可以是字符串等其他的内容</strong>，所以我们也可以将索引更改为字符串来创建</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">&gt;arr = {}<br>&gt;arr[<span class="hljs-string">"X"</span>] = <span class="hljs-number">10</span><br>&gt;arr[<span class="hljs-string">"Y"</span>] = <span class="hljs-number">20</span><br>&gt;arr[<span class="hljs-string">"Z"</span>] = <span class="hljs-number">30</span><br></code></pre></td></tr></tbody></table></figure>
<p>当然，如果想要获取这些数组中的值，可以使用下面的方式</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 方式一</span><br>&gt;<span class="hljs-built_in">print</span>(arr[<span class="hljs-string">"X"</span>])<br>&gt;<span class="hljs-built_in">print</span>(arr[<span class="hljs-string">"Y"</span>])<br>&gt;<span class="hljs-built_in">print</span>(arr[<span class="hljs-string">"Z"</span>])<br><span class="hljs-comment">-- 方式二</span><br>&gt;<span class="hljs-built_in">print</span>(arr.X)<br>&gt;<span class="hljs-built_in">print</span>(arr.Y)<br>&gt;<span class="hljs-built_in">print</span>(arr.Z)<br></code></pre></td></tr></tbody></table></figure>
<p>当前table的灵活不进于此，还有更灵活的声明方式</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">&gt;arr = {<span class="hljs-string">"TOM"</span>,X=<span class="hljs-number">10</span>,<span class="hljs-string">"JERRY"</span>,Y=<span class="hljs-number">20</span>,<span class="hljs-string">"ROSE"</span>,Z=<span class="hljs-number">30</span>}<br></code></pre></td></tr></tbody></table></figure>
<p>如何获取上面的值?</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">TOM :  arr[<span class="hljs-number">1</span>]<br><span class="hljs-number">10</span>  :  arr[<span class="hljs-string">"X"</span>] | arr.X<br>JERRY: arr[<span class="hljs-number">2</span>]<br><span class="hljs-number">20</span>  :  arr[<span class="hljs-string">"Y"</span>] | arr.Y<br>ROESE: arr[<span class="hljs-number">3</span>]<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>function</strong>：在 Lua语言中，函数（ Function ）是对语句和表达式进行抽象的主要方式。</li>
</ul>
<p>定义函数的语法为：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">functionName</span><span class="hljs-params">(params)</span></span><br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure>
<p>函数被调用的时候，传入的参数个数与定义函数时使用的参数个数不一致的时候，Lua 语言会通过 抛弃多余参数和将不足的参数设为 nil 的方式来调整参数的个数：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">f</span><span class="hljs-params">(a,b)</span></span><br>	<span class="hljs-built_in">print</span>(a,b)<br><span class="hljs-keyword">end</span><br><br>f()		<span class="hljs-comment">--&gt; nil  nil</span><br>f(<span class="hljs-number">2</span>)	<span class="hljs-comment">--&gt; 2 nil</span><br>f(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)	<span class="hljs-comment">--&gt; 2 6</span><br>f(<span class="hljs-number">2.6</span><span class="hljs-number">.8</span>)	<span class="hljs-comment">--&gt; 2 6 (8被丢弃)</span><br></code></pre></td></tr></tbody></table></figure>
<p>可变长参数函数：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(...)</span></span><br>    a,b,c=...<br>    <span class="hljs-built_in">print</span>(a)<br>    <span class="hljs-built_in">print</span>(b)<br>    <span class="hljs-built_in">print</span>(c)<br><span class="hljs-keyword">end</span><br><br>add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)  <span class="hljs-comment">--&gt; 1 2 3</span><br></code></pre></td></tr></tbody></table></figure>
<p>函数返回值可以有多个，这点和Java不太一样：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(a,b)</span></span><br>	<span class="hljs-keyword">return</span> a,b<br><span class="hljs-keyword">end</span><br><br>x,y=f(<span class="hljs-number">11</span>,<span class="hljs-number">22</span>)	<span class="hljs-comment">--&gt; x=11,y=22	</span><br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p><strong>thread</strong>：翻译过来是线程的意思，在Lua中，thread用来表示执行的独立线路，用来执行协同程序。</p>
</li>
<li>
<p><strong>userdata</strong>：是一种用户自定义数据，用于表示一种由应用程序或C/C++语言库所创建的类型。</p>
</li>
</ul>
<h4 id="Lua控制结构"><a class="header-anchor" href="#Lua控制结构">¶</a>Lua控制结构</h4>
<blockquote>
<p>Lua 语言提供了一组精简且常用的控制结构，包括用于条件执行的证 以及用于循环的 while、 repeat 和 for。 所有的控制结构语法上都有一个显式的终结符： end 用于终结 if、 for 及 while 结构， until 用于终结 repeat 结构。</p>
</blockquote>
<h5 id="if-then-elseif-else"><a class="header-anchor" href="#if-then-elseif-else">¶</a>if then elseif else</h5>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testif</span><span class="hljs-params">(a)</span></span><br>    <span class="hljs-keyword">if</span> a&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"a是正数"</span>)<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"a是负数"</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span><span class="hljs-params">(age)</span></span><br>    <span class="hljs-keyword">if</span> age&lt;=<span class="hljs-number">18</span> <span class="hljs-keyword">then</span><br>     	<span class="hljs-keyword">return</span> <span class="hljs-string">"青少年"</span><br>    <span class="hljs-keyword">elseif</span> age&gt;<span class="hljs-number">18</span> <span class="hljs-keyword">and</span> age&lt;=<span class="hljs-number">45</span> <span class="hljs-keyword">then</span><br>     	<span class="hljs-keyword">return</span> <span class="hljs-string">"青年"</span><br>    <span class="hljs-keyword">elseif</span> age&gt;<span class="hljs-number">45</span> <span class="hljs-keyword">and</span> age&lt;=<span class="hljs-number">60</span> <span class="hljs-keyword">then</span><br>     	<span class="hljs-keyword">return</span> <span class="hljs-string">"中年人"</span><br>    <span class="hljs-keyword">elseif</span> age&gt;<span class="hljs-number">60</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"老年人"</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure>
<h5 id="while循环"><a class="header-anchor" href="#while循环">¶</a>while循环</h5>
<p><strong>语法：</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">while</span> 条件 <span class="hljs-keyword">do</span><br>  循环体<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testWhile</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> i&lt;=<span class="hljs-number">10</span> <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">print</span>(i)<br>        i=i+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure>
<h5 id="repeat循环"><a class="header-anchor" href="#repeat循环">¶</a>repeat循环</h5>
<p><strong>语法：</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">repeat</span><br> 循环体<br> <span class="hljs-keyword">until</span> 条件<br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testRepeat</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> i = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">repeat</span><br>        <span class="hljs-built_in">print</span>(i)<br>        i=i<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">until</span> i &lt; <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure>
<h5 id="for循环"><a class="header-anchor" href="#for循环">¶</a>for循环</h5>
<p><strong>数值型for循环：</strong></p>
<p>语法：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> param=exp1,exp2,exp3 <span class="hljs-keyword">do</span><br>    循环体<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure>
<p>param的值从exp1变化到exp2之前的每次循环会执行 循环体，并在每次循环结束后将步长(step)exp3增加到param上。exp3可选，如果不设置默认为1。</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-number">10</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure>
<p><strong>泛型for循环：</strong></p>
<p>泛型for循环通过一个迭代器函数来遍历所有值，类似于java中的foreach语句。</p>
<p>语法：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(x) <span class="hljs-keyword">do</span><br>    循环体<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure>
<p>i是数组索引值，v是对应索引的数组元素值，<strong>ipairs</strong>是Lua提供的一个迭代器函数，用来迭代数组，x是要遍历的数组。</p>
<p>例如:</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">arr = {<span class="hljs-string">"TOME"</span>,<span class="hljs-string">"JERRY"</span>,<span class="hljs-string">"ROWS"</span>,<span class="hljs-string">"LUCY"</span>}<br><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(arr) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(i,v)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure>
<p>但是如果将arr的值进行修改为</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">arr = {<span class="hljs-string">"TOME"</span>,<span class="hljs-string">"JERRY"</span>,<span class="hljs-string">"ROWS"</span>,x=<span class="hljs-string">"JACK"</span>,<span class="hljs-string">"LUCY"</span>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>其中的x为JACK就无法遍历出来，缺失了数据，如果解决呢?</strong></p>
<p>我们可以将迭代器函数变成<strong>pairs</strong>：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(arr) <span class="hljs-keyword">do</span><br> <span class="hljs-built_in">print</span>(i,v)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></tbody></table></figure>
<p>上述实例就输出的结果为：</p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-number">1</span>	TOM<br><span class="hljs-number">2</span>	JERRY<br><span class="hljs-number">3</span>	ROWS<br><span class="hljs-number">4</span>	LUCY<br>x	JACK<br></code></pre></td></tr></tbody></table></figure>
<h2 id="2、ngx-lua模块概念"><a class="header-anchor" href="#2、ngx-lua模块概念">¶</a>2、ngx_lua模块概念</h2>
<p>淘宝开发的ngx_lua模块通过将lua解释器集成进Nginx，可以采用lua脚本实现业务逻辑，由于lua的紧凑、快速以及内建协程，所以在保证高并发服务能力的同时极大地降低了业务逻辑实现成本。</p>
<h2 id="3、ngx-lua模块环境准备"><a class="header-anchor" href="#3、ngx-lua模块环境准备">¶</a>3、ngx_lua模块环境准备</h2>
<h3 id="方式一：lua-nginx-module"><a class="header-anchor" href="#方式一：lua-nginx-module">¶</a>方式一：lua-nginx-module</h3>
<p>一般不使用这种方式，比较繁杂，推荐使用下方的方式二！</p>
<h3 id="方式二：OpenRestry（推荐）"><a class="header-anchor" href="#方式二：OpenRestry（推荐）">¶</a>方式二：OpenRestry（推荐）</h3>
<h4 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h4>
<blockquote>
<p>前面我们提到过，OpenResty是由淘宝工程师开发的，所以其官方网站 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://openresty.org/">http://openresty.org/</a> 我们读起来是非常的方便。OpenResty是一个基于Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。所以<strong>本身OpenResty内部就已经集成了Nginx和Lua</strong>，所以我们使用起来会更加方便。</p>
</blockquote>
<p><strong>openresty已经内置了nginx，因此先将之前的nginx关掉！</strong></p>
<h4 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h4>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua">(<span class="hljs-number">1</span>) 下载OpenResty：https://openresty.org/download/openresty<span class="hljs-number">-1.15</span><span class="hljs-number">.8</span><span class="hljs-number">.2</span>.tar.gz<br>(<span class="hljs-number">2</span>)使用wget下载: wget https://openresty.org/download/openresty<span class="hljs-number">-1.15</span><span class="hljs-number">.8</span><span class="hljs-number">.2</span>.tar.gz<br>(<span class="hljs-number">3</span>)解压缩: tar -zxf openresty<span class="hljs-number">-1.15</span><span class="hljs-number">.8</span><span class="hljs-number">.2</span>.tar.gz<br>(<span class="hljs-number">4</span>)进入OpenResty目录: cd openresty<span class="hljs-number">-1.15</span><span class="hljs-number">.8</span><span class="hljs-number">.2</span><br>(<span class="hljs-number">5</span>) 执行命令:./configure<br>(<span class="hljs-number">6</span>) 执行命令:make &amp;&amp; make install<br>(<span class="hljs-number">7</span>)进入OpenResty的目录，找到nginx：cd /usr/<span class="hljs-keyword">local</span>/openresty/nginx/<br>(<span class="hljs-number">8</span>)在conf目录下的nginx.conf添加如下内容<br>location /lua{<br>    default_type <span class="hljs-string">'text/html'</span>;<br>    content_by_lua <span class="hljs-string">'ngx.say("&lt;h1&gt;HELLO,OpenRestry&lt;/h1&gt;")'</span>;<br>}<br>(<span class="hljs-number">9</span>)在sbin目录下启动nginx<br>(<span class="hljs-number">10</span>)通过浏览器访问测试<br></code></pre></td></tr></tbody></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@290dddd7f73e8df5decd5cecfd527c89ce43de65/2021/09/20/905e4010e1416f2deef097eb7aff0024.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@a66598e90ca8a30776484ccac4fa84096f95281e/2021/09/20/bd392858d64778fb185eff366acaf0f3.png" alt=""></p>
<h2 id="4、ngx-lua的使用"><a class="header-anchor" href="#4、ngx-lua的使用">¶</a>4、ngx_lua的使用</h2>
<p>使用Lua编写Nginx脚本的基本构建块是指令。指令用于指定何时运行用户Lua代码以及如何使用结果。下图显示了执行指令的顺序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@99e68ee0d651f1a882344d76741e876352d699d7/2021/09/20/6c33362ae76fd3ffecfdff03cc6e92f3.png" alt=""></p>
<p><strong>先来解释下*的作用：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">*：无 ， 即 xxx_by_lua ,指令后面跟的是 lua指令<br>*:_file，即 xxx_by_lua_file 指令后面跟的是 lua文件<br>*:_block,即 xxx_by_lua_block 在0.9.17版后替换init_by_lua_file<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>init_by_lua*：该指令在每次Nginx重新加载配置时执行，可以用来完成一些耗时模块的加载，或者初始化一些全局配置。</p>
</li>
<li>
<p>init_worker_by_lua*：该指令用于启动一些定时任务，如心跳检查、定时拉取服务器配置等。</p>
</li>
<li>
<p>set_by_lua*：该指令只要用来做变量赋值，这个指令一次只能返回一个值，并将结果赋值给Nginx中指定的变量。</p>
</li>
<li>
<p>rewrite_by_lua*：该指令用于执行内部URL重写或者外部重定向，典型的如伪静态化URL重写，本阶段在rewrite处理阶段的最后默认执行。</p>
</li>
<li>
<p>access_by_lua*：该指令用于访问控制。例如，如果只允许内网IP访问。</p>
</li>
<li>
<p>content_by_lua*：该指令是应用最多的指令，大部分任务是在这个阶段完成的，其他的过程往往为这个阶段准备数据，正式处理基本都在本阶段。</p>
</li>
<li>
<p>header_filter_by_lua*：该指令用于设置应答消息的头部信息。</p>
</li>
<li>
<p>body_filter_by_lua*：该指令是对响应数据进行过滤，如截断、替换。</p>
</li>
<li>
<p>log_by_lua*：该指令用于在log请求处理阶段，用Lua代码处理日志，但并不替换原有log处理。</p>
</li>
<li>
<p>balancer_by_lua*：该指令主要的作用是用来实现上游服务器的负载均衡器算法*</p>
</li>
<li>
<p>ssl_certificate_by_*：该指令作用在Nginx和下游服务开始一个SSL握手操作时将允许本配置项的Lua代码。</p>
</li>
</ul>
<p><strong>需求：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">http://192.168.200.133?name=张三&amp;gender=1<br>Nginx接收到请求后，根据gender传入的值，如果gender传入的是1，则在页面上展示<br>张三先生,如果gender传入的是0，则在页面上展示张三女士,如果未传或者传入的不是1和2则在页面上展示张三。<br></code></pre></td></tr></tbody></table></figure>
<p><strong>实现代码：</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /getByGender {<br>	default_type 'text/html';<br>	set_by_lua $name "<br>		local uri_args = ngx.req.get_uri_args()<br>		gender = uri_args['gender']<br>		name = uri_args['name']<br>		if gender=='1' then<br>			return name..'先生'<br>		elseif gender=='0' then<br>			return name..'女士'<br>		else<br>			return name<br>		end<br>	";<br>	header_filter_by_lua "<br>		ngx.header.aaa='bbb'<br>	";<br><span class="hljs-meta">	#</span><span class="bash"> 解决中文乱码</span><br>	charset utf-8;<br>	return 200 $name;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="5、ngx-lua操作Redis"><a class="header-anchor" href="#5、ngx-lua操作Redis">¶</a>5、ngx_lua操作Redis</h2>
<p>Redis在系统中经常作为数据缓存、内存数据库使用，在大型系统中扮演着非常重要的作用。</p>
<p>在Nginx核心系统中，Redis是常备组件。</p>
<p>Nginx支持3种方法访问Redis, 分别是HttpRedis模块、HttpRedis2Module、lua-resty-redis库。这三种方式中HttpRedis模块提供的指令少，功能单一，适合做简单缓存，HttpRedis2Module模块比HttpRedis模块操作更灵活，功能更强大。而<strong>Lua-resty-redis库是OpenResty提供的一个操作Redis的接口库</strong>，可根据自己的业务情况做一些逻辑处理，适合做复杂的业务逻辑。我们主要以Lua-resty-redis来学习。</p>
<h3 id="lua-resty-redis环境准备"><a class="header-anchor" href="#lua-resty-redis环境准备">¶</a>lua-resty-redis环境准备</h3>
<p><strong>步骤一：准备一个Redis环境</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">连接地址host= 192.168.200.111port=6379<br></code></pre></td></tr></tbody></table></figure>
<p><strong>步骤二：准备对应的API</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">lua-resty-redis提供了访问Redis的详细API，包括创建对接、连接、操作、数据处理等。这些API基本上与Redis的操作一一对应。<br>（1）redis = require "resty.redis"<br>（2）new<br>	语法: redis,err = redis:new(),创建一个Redis对象。<br>（3）connect<br>	语法:ok,err=redis:connect(host,port[,options_table]),设置连接Redis的连接信息。<br>	ok:连接成功返回 1，连接失败返回nil<br>	err:返回对应的错误信息<br>（4）set_timeout<br>	语法: redis:set_timeout(time) ，设置请求操作Redis的超时时间。<br>（5）close<br>	语法: ok,err = redis:close(),关闭当前连接，成功返回1，失败返回nil和错误信息<br>（6）redis命令对应的方法<br>	在lua-resty-redis中，所有的Redis命令都有自己的方法，方法名字和命令名字相同，只是全部为小写。<br><br></code></pre></td></tr></tbody></table></figure>
<p><strong>步骤三：效果实现</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">location / {<br>    default_type "text/html";<br>    content_by_lua_block{<br>        local redis = require "resty.redis" -- 引入Redis<br>        local redisObj = redis:new()  --创建Redis对象<br>        redisObj:set_timeout(1000) --设置超时数据为1s<br>        local ok,err = redisObj:connect("192.168.200.1",6379) --设置redis连接信息<br>        if not ok then --判断是否连接成功<br>         ngx.say("failed to connection redis",err)<br>         return<br>        end<br>        ok,err = redisObj:set("username","TOM")--存入数据<br>        if not ok then --判断是否存入成功<br>         ngx.say("failed to set username",err)<br>         return<br>        end<br>        local res,err = redisObj:get("username") --从redis中获取数据<br>        ngx.say(res)	--将数据写会消息体中<br>        redisObj:close()<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>步骤四：运行测试效果</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@7886b3fe0f1c5c43590a6badf8ef252e645c10e6/2021/09/20/007459aa108ebadef4015cb4a56f9222.png" alt=""></p>
<h2 id="6、ngx-lua操作Mysql"><a class="header-anchor" href="#6、ngx-lua操作Mysql">¶</a>6、ngx_lua操作Mysql</h2>
<p>MySQL是一个使用广泛的关系型数据库。在ngx_lua中，MySQL有两种访问模式, 分别是</p>
<ol>
<li>使用ngx_lua模块和lua-resty-mysql模块：这两个模块是安装OpenResty时默认安装的。</li>
<li>使用drizzle_nginx_module(HttpDrizzleModule)模块：需要单独安装，这个库现不在OpenResty中。</li>
</ol>
<h3 id="lua-resty-mysql"><a class="header-anchor" href="#lua-resty-mysql">¶</a>lua-resty-mysql</h3>
<p>lua-resty-mysql是OpenResty开发的模块，使用灵活、功能强大，适合复杂的业务场景，同时支持存储过程的访问。</p>
<h4 id="使用lua-resty-mysql实现数据库的查询"><a class="header-anchor" href="#使用lua-resty-mysql实现数据库的查询">¶</a>使用lua-resty-mysql实现数据库的查询</h4>
<p><strong>步骤一：准备MYSQL</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">host: 192.168.200.111<br>port: 3306<br>username:root<br>password:123456<br></code></pre></td></tr></tbody></table></figure>
<p>创建一个数据库表及表中的数据。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database nginx_db;<br><br>use nginx_db;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> users(<br>   id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> <span class="hljs-keyword">key</span> auto_increment,<br>   username <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>),<br>   birthday <span class="hljs-type">date</span>,<br>   salary <span class="hljs-keyword">double</span><br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users(id,username,birthday,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,"TOM","1988-11-11",<span class="hljs-number">10000.0</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users(id,username,birthday,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,"JERRY","1989-11-11",<span class="hljs-number">20000.0</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users(id,username,birthday,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,"ROWS","1990-11-11",<span class="hljs-number">30000.0</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users(id,username,birthday,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,"LUCY","1991-11-11",<span class="hljs-number">40000.0</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> users(id,username,birthday,salary) <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,"JACK","1992-11-11",<span class="hljs-number">50000.0</span>);<br></code></pre></td></tr></tbody></table></figure>
<p><strong>步骤二：API学习</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs shell">（1）引入"resty.mysql"模块<br>	local mysql = require "resty.mysql"<br>（2）new<br>	创建一个MySQL连接对象，遇到错误时，db为nil，err为错误描述信息<br>	语法: db,err = mysql:new()<br>（3）connect<br>	尝试连接到一个MySQL服务器<br>	语法:ok,err=db:connect(options),options是一个参数的Lua表结构，里面包含数据库连接的相关信息<br>    host:服务器主机名或IP地址<br>    port:服务器监听端口，默认为3306<br>    user:登录的用户名<br>    password:登录密码<br>    database:使用的数据库名<br>（4）set_timeout<br>	设置子请求的超时时间(ms)，包括connect方法<br>	语法:db:set_timeout(time)<br>（5）close<br>	关闭当前MySQL连接并返回状态。如果成功，则返回1；如果出现任何错误，则将返回nil和错误描述。<br>	语法:db:close()<br>（6）send_query<br>	异步向远程MySQL发送一个查询。如果成功则返回成功发送的字节数；如果错误，则返回nil和错误描述<br>	语法:bytes,err=db:send_query(sql)<br>（7）read_result<br>	从MySQL服务器返回结果中读取一行数据。res返回一个描述OK包或结果集包的Lua表,语法:<br>	res, err, errcode, sqlstate = db:read_result() <br>	res, err, errcode, sqlstate = db:read_result(rows) :rows指定返回结果集的最大值，默认为4<br>	如果是查询，则返回一个容纳多行的数组。每行是一个数据列的key-value对，如<br><br>    {<br>      {id=1,username="TOM",birthday="1988-11-11",salary=10000.0},<br>      {id=2,username="JERRY",birthday="1989-11-11",salary=20000.0}<br>    }<br>	如果是增删改，则返回类上如下数据<br>    {<br>    	insert_id = 0,<br>    	server_status=2,<br>    	warning_count=1,<br>    	affected_rows=2,<br>    	message=nil<br>    }<br>	返回值:<br>		res:操作的结果集<br>		err:错误信息<br>		errcode:MySQL的错误码，比如1064<br>		sqlstate:返回由5个字符组成的标准SQL错误码，比如42000<br><br></code></pre></td></tr></tbody></table></figure>
<p><strong>步骤三：效果实现</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /{<br>    content_by_lua_block{<br>        local mysql = require "resty.mysql"<br>        local db = mysql:new()<br>        local ok,err = db:connect{<br>            host="192.168.200.111",<br>            port=3306,<br>            user="root",<br>            password="123456",<br>            database="nginx_db"<br>        }<br>        db:set_timeout(1000)<br><br>        db:send_query("select * from users where id =1")<br>        local res,err,errcode,sqlstate = db:read_result()<br>        	ngx.say(res[1].id..","..res[1].username..","..res[1].birthday..","..res[1].salary)<br>    	db:close()<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="使用lua-cjson处理查询结果"><a class="header-anchor" href="#使用lua-cjson处理查询结果">¶</a>使用lua-cjson处理查询结果</h4>
<blockquote>
<p>通过上述的案例学习，read_result()得到的结果res都是table类型，要想在页面上展示，就必须知道table的具体数据结构才能进行遍历获取。处理起来比较麻烦，接下来我们介绍一种简单方式cjson，使用它就可以将table类型的数据转换成json字符串，把json字符串展示在页面上即可。具体如何使用?</p>
</blockquote>
<p><strong>步骤一：引入cjson</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> cjson = <span class="hljs-built_in">require</span> <span class="hljs-string">"cjson"</span><br></code></pre></td></tr></tbody></table></figure>
<p><strong>步骤二：调用cjson的encode方法进行类型转换</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">cjson.encode(res) <br></code></pre></td></tr></tbody></table></figure>
<p><strong>步骤三:使用</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /{<br>    content_by_lua_block{<br><br>        local mysql = require "resty.mysql"<br>        local cjson = require "cjson"<br><br>        local db = mysql:new()<br><br>        local ok,err = db:connect{<br>            host="192.168.200.111",<br>            port=3306,<br>            user="root",<br>            password="123456",<br>            database="nginx_db"<br>        }<br>        db:set_timeout(1000)<br><br>        --db:send_query("select * from users where id = 2")<br>        db:send_query("select * from users")<br>        local res,err,errcode,sqlstate = db:read_result()<br>        ngx.say(cjson.encode(res))<br>         for i,v in ipairs(res) do<br>       ngx.say(v.id..","..v.username..","..v.birthday..","..v.salary)<br>        end<br>    	db:close()<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="lua-resty-mysql实现数据库的增删改"><a class="header-anchor" href="#lua-resty-mysql实现数据库的增删改">¶</a>lua-resty-mysql实现数据库的增删改</h4>
<p><strong>优化send_query和read_result ！</strong></p>
<p>本方法是send_query和read_result组合的快捷方法。</p>
<p><strong>语法：</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">res, err, errcode, sqlstate = db:query(sql[,rows])<br></code></pre></td></tr></tbody></table></figure>
<p>有了该API，上面的代码我们就可以进行对应的优化，如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">location /{<br>    content_by_lua_block{<br><br>        local mysql = require "resty.mysql"<br><br>        local db = mysql:new()<br><br>        local ok,err = db:connect{<br>        host="192.168.200.1",<br>        port=3306,<br>        user="root",<br>        password="123456",<br>        database="nginx_db",<br>        max_packet_size=1024,<br>        compact_arrays=false<br>        }<br>        db:set_timeout(1000)<br>        local res,err,errcode,sqlstate = db:query("select * from users")<br>        --local res,err,errcode,sqlstate = db:query("insert into users(id,username,birthday,salary) values(null,'zhangsan','2020-11-11',32222.0)")<br>        --local res,err,errcode,sqlstate = db:query("update users set username='lisi' where id = 6")<br>        --local res,err,errcode,sqlstate = db:query("delete from users where id = 6")<br>        db:close()<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="综合小案例"><a class="header-anchor" href="#综合小案例">¶</a>综合小案例</h3>
<p>使用ngx_lua模块完成Redis缓存预热。</p>
<p>分析:</p>
<p>1、先得有一张表(users)</p>
<p>2、浏览器输入如下地址</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">http://191.168.200.133?username=TOM<br></code></pre></td></tr></tbody></table></figure>
<p>3、从表中查询出符合条件的记录，此时获取的结果为table类型</p>
<p>4、使用cjson将table数据转换成json字符串</p>
<p>5、将查询的结果数据存入Redis中</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs shell">init_by_lua_block{<br><br>	redis = require "resty.redis"<br>    mysql = require "resty.mysql"<br>    cjson = require "cjson"<br>}<br>location /{<br>			default_type "text/html";<br>			content_by_lua_block{<br>				<br>				--获取请求的参数username<br>				local param = ngx.req.get_uri_args()["username"]<br>				--建立mysql数据库的连接<br>				local db = mysql:new()<br>				local ok,err = db:connect{<br>					host="192.168.200.111",<br>					port=3306,<br>					user="root",<br>					password="123456",<br>					database="nginx_db"<br>				}<br>				if not ok then<br>				 ngx.say("failed connect to mysql:",err)<br>				 return<br>				end<br>				--设置连接超时时间<br>				db:set_timeout(1000)<br>				--查询数据<br>				local sql = "";<br>				if not param then<br>					sql="select * from users"<br>				else<br>					sql="select * from users where username=".."'"..param.."'"<br>				end<br>				local res,err,errcode,sqlstate=db:query(sql)<br>				if not res then<br>				 ngx.say("failed to query from mysql:",err)<br>				 return<br>				end<br>				--连接redis<br>				local rd = redis:new()<br>				ok,err = rd:connect("192.168.200.111",6379)<br>				if not ok then<br>				 ngx.say("failed to connect to redis:",err)<br>				 return<br>				end<br>				rd:set_timeout(1000)<br>				--循环遍历数据<br>				for i,v in ipairs(res) do<br>				 rd:set("user_"..v.username,cjson.encode(v))<br>				end<br>				ngx.say("success")<br>				rd:close()<br>				db:close()<br>			}<br>			<br>		}<br></code></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">ITNXD</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.itnxd.cn/posts/16211.html">https://www.itnxd.cn/posts/16211.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.itnxd.cn" target="_blank">小牛博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Nginx/">Nginx</a><a class="post-meta__tags" href="/tags/Lua/">Lua</a><a class="post-meta__tags" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a><a class="post-meta__tags" href="/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/">反向代理</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/niuxvdong/pic@ed6c32c3f3cc5f9a904e8a63ae2dd23d118bfd21/2021/09/20/8214792608475af375dedc1e855d8a07.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/WeChantQR.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/WeChantQR.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/AliPayQR.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/AliPayQR.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/8790.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@f40038c439ba561a382d434777da7ac61833a01c/2021/09/23/54de8d8441dfdce96e726f7fb173c689.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">轻量应用容器框架、开源软件部署解决方案之Docker从入门到精通</div></div></a></div><div class="next-post pull-right"><a href="/posts/6406.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@487db38b807cb664754f8da6f5278b50bbe5d9f3/2021/09/13/6f9a05265d5267b2a5cfcc173404af27.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL数据库索引、索引失效、B树、B+树、聚簇索引、非聚簇索引</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Nginx%E7%AE%80%E4%BB%8B"><span class="toc-text">一、Nginx简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、背景介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-text">2、名词解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WEB%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">WEB服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POP3-SMTP-IMAP"><span class="toc-text">POP3&#x2F;SMTP&#x2F;IMAP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">反向代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%B9%E6%AF%94"><span class="toc-text">3、常见服务器对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IIS"><span class="toc-text">IIS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat"><span class="toc-text">Tomcat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Apache"><span class="toc-text">Apache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lighttpd"><span class="toc-text">Lighttpd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">其他的服务器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Nginx%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">4、Nginx的优点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9F%E5%BA%A6%E6%9B%B4%E5%BF%AB%E3%80%81%E5%B9%B6%E5%8F%91%E6%9B%B4%E9%AB%98"><span class="toc-text">速度更快、并发更高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%AE%80%E5%8D%95%EF%BC%8C%E6%89%A9%E5%B1%95%E6%80%A7%E5%BC%BA"><span class="toc-text">配置简单，扩展性强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">高可靠性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E9%83%A8%E7%BD%B2"><span class="toc-text">热部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E6%9C%AC%E4%BD%8E%E3%80%81BSD%E8%AE%B8%E5%8F%AF%E8%AF%81"><span class="toc-text">成本低、BSD许可证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Nginx%E7%9A%84%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">5、Nginx的功能特性及常用功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%ACHTTP%E6%9C%8D%E5%8A%A1"><span class="toc-text">基本HTTP服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7HTTP%E6%9C%8D%E5%8A%A1"><span class="toc-text">高级HTTP服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1"><span class="toc-text">邮件服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97"><span class="toc-text">Nginx常用的功能模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90"><span class="toc-text">Nginx的核心组成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Nginx%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">二、Nginx环境准备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Nginx%E7%89%88%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、Nginx版本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%8E%B7%E5%8F%96Nginx%E6%BA%90%E7%A0%81"><span class="toc-text">2、获取Nginx源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%87%86%E5%A4%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-text">3、准备服务器系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Nginx%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%E5%8D%B3%E4%BE%9D%E8%B5%96%E4%BB%8B%E7%BB%8D"><span class="toc-text">4、Nginx安装方式即依赖介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Nginx%E7%9A%84%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85"><span class="toc-text">5、Nginx的源码简单安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81yum%E5%AE%89%E8%A3%85"><span class="toc-text">6、yum安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E5%92%8Cyum%E5%AE%89%E8%A3%85%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-text">7、源码简单安装和yum安装的差异</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Nginx%E7%9A%84%E6%BA%90%E7%A0%81%E5%A4%8D%E6%9D%82%E5%AE%89%E8%A3%85"><span class="toc-text">8、Nginx的源码复杂安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E8%A7%A3%E5%8E%8BNginx%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">9、解压Nginx目录介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81Nginx%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-text">10、Nginx目录结构分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%81%9C%E5%91%BD%E4%BB%A4"><span class="toc-text">11、Nginx服务器启停命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BF%A1%E5%8F%B7%E6%8E%A7%E5%88%B6"><span class="toc-text">Nginx服务的信号控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8E%A7%E5%88%B6"><span class="toc-text">Nginx的命令行控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%92%8C%E6%96%B0%E5%A2%9E%E6%A8%A1%E5%9D%97"><span class="toc-text">12、Nginx服务器版本升级和新增模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Nginx%E6%9C%8D%E5%8A%A1%E4%BF%A1%E5%8F%B7%E8%BF%9B%E8%A1%8C%E5%8D%87%E7%BA%A7"><span class="toc-text">使用Nginx服务信号进行升级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Nginx%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E7%9A%84make%E5%91%BD%E4%BB%A4%E5%AE%8C%E6%88%90%E5%8D%87%E7%BA%A7"><span class="toc-text">使用Nginx安装目录的make命令完成升级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Nginx%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">三、Nginx核心配置文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、配置文件介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%85%A8%E5%B1%80%E5%9D%97"><span class="toc-text">2、全局块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#user%E6%8C%87%E4%BB%A4"><span class="toc-text">user指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#work-process%E6%8C%87%E4%BB%A4"><span class="toc-text">work process指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4"><span class="toc-text">其他指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81events%E5%9D%97"><span class="toc-text">3、events块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81http%E5%9D%97"><span class="toc-text">4、http块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="toc-text">5、自定义服务日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="toc-text">6、其他配置指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81server%E5%9D%97%E5%92%8Clocation%E5%9D%97"><span class="toc-text">7、server块和location块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B"><span class="toc-text">四、Nginx服务器基础配置实例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%9B%AE%E6%A0%87%E9%9C%80%E6%B1%82"><span class="toc-text">1、目标需求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%85%8D%E7%BD%AE%E5%86%85%E5%AE%B9"><span class="toc-text">2、配置内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Nginx%E6%9C%8D%E5%8A%A1%E6%93%8D%E4%BD%9C%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">五、Nginx服务操作的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Nginx%E9%85%8D%E7%BD%AE%E6%88%90%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="toc-text">1、Nginx配置成系统服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Nginx%E5%91%BD%E4%BB%A4%E9%85%8D%E7%BD%AE%E5%88%B0%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83"><span class="toc-text">2、Nginx命令配置到系统环境</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81Nginx%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2"><span class="toc-text">六、Nginx静态资源部署</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Nginx%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%A6%82%E8%BF%B0"><span class="toc-text">1、Nginx静态资源概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Nginx%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="toc-text">2、Nginx静态资源的配置指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#listen%E6%8C%87%E4%BB%A4"><span class="toc-text">listen指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#server-name%E6%8C%87%E4%BB%A4"><span class="toc-text">server_name指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#location%E6%8C%87%E4%BB%A4"><span class="toc-text">location指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#root-alias%E6%8C%87%E4%BB%A4"><span class="toc-text">root &#x2F; alias指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#index%E6%8C%87%E4%BB%A4"><span class="toc-text">index指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error-page%E6%8C%87%E4%BB%A4"><span class="toc-text">error_page指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95"><span class="toc-text">3、静态资源优化配置语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#send%EF%AC%81le"><span class="toc-text">sendﬁle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-nopush"><span class="toc-text">tcp_nopush</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-nodelay"><span class="toc-text">tcp_nodelay</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Nginx%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9%E5%AE%9E%E6%88%98"><span class="toc-text">4、Nginx静态资源压缩实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Gzip%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="toc-text">Gzip模块配置指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gzip%E5%8E%8B%E7%BC%A9%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E4%BE%8B%E9%85%8D%E7%BD%AE"><span class="toc-text">Gzip压缩功能的实例配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gzip%E5%92%8Csendfile%E5%85%B1%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-text">Gzip和sendfile共存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97%E5%88%B0Nginx%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">添加模块到Nginx的实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gzip-static%E6%8C%87%E4%BB%A4"><span class="toc-text">gzip_static指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gzip-static%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8"><span class="toc-text">gzip_static测试使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86"><span class="toc-text">5、静态资源的缓存处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98"><span class="toc-text">什么是缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFweb%E7%BC%93%E5%AD%98"><span class="toc-text">什么是web缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web%E7%BC%93%E5%AD%98%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">web缓存的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-text">浏览器缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">浏览器缓存的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-text">浏览器缓存相关指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#expires%E6%8C%87%E4%BB%A4"><span class="toc-text">expires指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add-header%E6%8C%87%E4%BB%A4"><span class="toc-text">add_header指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Nginx%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">6、Nginx的跨域问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-text">同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-text">跨域问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%BC%94%E7%A4%BA"><span class="toc-text">跨域问题演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%98%B2%E7%9B%97%E9%93%BE"><span class="toc-text">7、静态资源防盗链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B5%84%E6%BA%90%E7%9B%97%E9%93%BE"><span class="toc-text">什么是资源盗链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E9%98%B2%E7%9B%97%E9%93%BE%E5%8E%9F%E7%90%86"><span class="toc-text">Nginx防盗链原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E7%9B%AE%E5%BD%95%E8%BF%9B%E8%A1%8C%E9%98%B2%E7%9B%97%E9%93%BE"><span class="toc-text">针对目录进行防盗链</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81Rewrite%E5%8A%9F%E8%83%BD%E9%85%8D%E7%BD%AE"><span class="toc-text">七、Rewrite功能配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%9C%B0%E5%9D%80%E9%87%8D%E5%86%99%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E5%8F%91"><span class="toc-text">1、地址重写与地址转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Rewrite%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-text">2、Rewrite的相关指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E6%8C%87%E4%BB%A4"><span class="toc-text">set指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rewrite%E5%B8%B8%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">Rewrite常用全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if%E6%8C%87%E4%BB%A4"><span class="toc-text">if指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#break%E6%8C%87%E4%BB%A4"><span class="toc-text">break指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#return%E6%8C%87%E4%BB%A4"><span class="toc-text">return指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rewrite%E6%8C%87%E4%BB%A4"><span class="toc-text">rewrite指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rewrite-log%E6%8C%87%E4%BB%A4"><span class="toc-text">rewrite_log指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Rewrite%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-text">3、Rewrite的案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC"><span class="toc-text">域名跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E9%95%9C%E5%83%8F"><span class="toc-text">域名镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E5%9F%9F%E5%90%8D"><span class="toc-text">独立域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0"><span class="toc-text">目录自动添加&quot;&#x2F;&quot;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E7%9B%AE%E5%BD%95"><span class="toc-text">合并目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E7%9B%97%E9%93%BE"><span class="toc-text">防盗链</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">八、Nginx反向代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Nginx%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">1、Nginx正向代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">2、Nginx反向代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-pass"><span class="toc-text">proxy_pass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-set-header"><span class="toc-text">proxy_set_header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-redirect"><span class="toc-text">proxy_redirect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98"><span class="toc-text">3、Nginx反向代理实战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Nginx%E7%9A%84%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6"><span class="toc-text">4、Nginx的安全控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8SSL%E5%AF%B9%E6%B5%81%E9%87%8F%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86"><span class="toc-text">5、如何使用SSL对流量进行加密</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nginx%E6%B7%BB%E5%8A%A0SSL%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">nginx添加SSL的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E7%9A%84SSL%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-text">Nginx的SSL相关指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6"><span class="toc-text">生成证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AFSSL%E5%AE%9E%E4%BE%8B"><span class="toc-text">开启SSL实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98"><span class="toc-text">6、反向代理系统调优</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">九、Nginx负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A6%82%E8%BF%B0"><span class="toc-text">1、负载均衡概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">2、负载均衡的原理及处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">3、负载均衡的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%B8%B8%E7%94%A8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">3、负载均衡常用的处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%94%A8%E6%88%B7%E6%89%8B%E5%8A%A8%E9%80%89%E6%8B%A9"><span class="toc-text">方式一：用户手动选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9ADNS%E8%BD%AE%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-text">方式二：DNS轮询方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%9B%9B-%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">方式三：四&#x2F;七层负载均衡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Nginx%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">4、Nginx七层负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%8C%87%E4%BB%A4"><span class="toc-text">负载均衡指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-text">七层负载均衡的实现流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%8A%B6%E6%80%81"><span class="toc-text">负载均衡状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-text">负载均衡策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2"><span class="toc-text">轮询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#weight%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2"><span class="toc-text">weight加权轮询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ip-hash"><span class="toc-text">ip_hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#least-conn"><span class="toc-text">least_conn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#url-hash"><span class="toc-text">url_hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fair"><span class="toc-text">fair</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A1%88%E4%BE%8B"><span class="toc-text">负载均衡案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Nginx%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">5、Nginx四层负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0stream%E6%A8%A1%E5%9D%97%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">添加stream模块的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-text">负载均衡的指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-text">四层负载均衡的案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81Nginx%E7%BC%93%E5%AD%98%E9%9B%86%E6%88%90"><span class="toc-text">十、Nginx缓存集成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%BC%93%E5%AD%98%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1、缓存的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Nginx%E7%9A%84web%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1"><span class="toc-text">2、Nginx的web缓存服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Nginx%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-text">3、Nginx缓存相关指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-cache-path"><span class="toc-text">proxy_cache_path</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-cache"><span class="toc-text">proxy_cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-cache-key"><span class="toc-text">proxy_cache_key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-cache-valid"><span class="toc-text">proxy_cache_valid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-cache-min-uses"><span class="toc-text">proxy_cache_min_uses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-cache-methods"><span class="toc-text">proxy_cache_methods</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Nginx%E7%BC%93%E5%AD%98%E8%AE%BE%E7%BD%AE%E6%A1%88%E4%BE%8B"><span class="toc-text">4、Nginx缓存设置案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Nginx%E7%BC%93%E5%AD%98%E7%9A%84%E6%B8%85%E9%99%A4"><span class="toc-text">5、Nginx缓存的清除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%88%A0%E9%99%A4%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BC%93%E5%AD%98%E7%9B%AE%E5%BD%95"><span class="toc-text">方式一：删除对应的缓存目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">方式二：使用第三方扩展模块（推荐）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Nginx%E8%AE%BE%E7%BD%AE%E8%B5%84%E6%BA%90%E4%B8%8D%E7%BC%93%E5%AD%98"><span class="toc-text">6、Nginx设置资源不缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">案例实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-text">十一、Nginx服务器端集群搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Nginx%E5%AE%9E%E7%8E%B0%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB"><span class="toc-text">1、Nginx实现动静分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Nginx%E5%AE%9E%E7%8E%B0Tomcat%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-text">2、Nginx实现Tomcat集群搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Nginx%E9%AB%98%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">3、Nginx高可用解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Keepalived"><span class="toc-text">Keepalived</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VRRP%E4%BB%8B%E7%BB%8D"><span class="toc-text">VRRP介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Keepalived%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-text">Keepalived配置文件介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%B5%8B%E8%AF%95"><span class="toc-text">访问测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keepalived%E4%B9%8Bvrrp-script"><span class="toc-text">keepalived之vrrp_script</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81Nginx%E5%88%B6%E4%BD%9C%E4%B8%8B%E8%BD%BD%E7%AB%99%E7%82%B9"><span class="toc-text">十二、Nginx制作下载站点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81Nginx%E7%9A%84%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%A8%A1%E5%9D%97"><span class="toc-text">十三、Nginx的用户认证模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81Nginx%E7%9A%84%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97"><span class="toc-text">十四、Nginx的扩展模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Lua"><span class="toc-text">1、Lua</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">Lua的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">Lua的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AALua%E7%A8%8B%E5%BA%8F"><span class="toc-text">第一个Lua程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lua%E7%9A%84%E6%B3%A8%E9%87%8A"><span class="toc-text">Lua的注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">全局变量&amp;局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lua%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">Lua数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lua%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-text">Lua控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#if-then-elseif-else"><span class="toc-text">if then elseif else</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-text">while循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#repeat%E5%BE%AA%E7%8E%AF"><span class="toc-text">repeat循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-text">for循环</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81ngx-lua%E6%A8%A1%E5%9D%97%E6%A6%82%E5%BF%B5"><span class="toc-text">2、ngx_lua模块概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81ngx-lua%E6%A8%A1%E5%9D%97%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">3、ngx_lua模块环境准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9Alua-nginx-module"><span class="toc-text">方式一：lua-nginx-module</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9AOpenRestry%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">方式二：OpenRestry（推荐）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-text">安装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81ngx-lua%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4、ngx_lua的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81ngx-lua%E6%93%8D%E4%BD%9CRedis"><span class="toc-text">5、ngx_lua操作Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lua-resty-redis%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">lua-resty-redis环境准备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81ngx-lua%E6%93%8D%E4%BD%9CMysql"><span class="toc-text">6、ngx_lua操作Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lua-resty-mysql"><span class="toc-text">lua-resty-mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8lua-resty-mysql%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-text">使用lua-resty-mysql实现数据库的查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8lua-cjson%E5%A4%84%E7%90%86%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C"><span class="toc-text">使用lua-cjson处理查询结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lua-resty-mysql%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9"><span class="toc-text">lua-resty-mysql实现数据库的增删改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E5%B0%8F%E6%A1%88%E4%BE%8B"><span class="toc-text">综合小案例</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By ITNXD</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">CDN BY <a target="_blank" rel="external nofollow" href="https://www.jsdelivr.com/"><b>jsDelivr</b></a> | HOST BY  <a target="_blank" rel="external nofollow" href="https://vercel.com/"><b>Vercel</b></a> && <a target="_blank" rel="external nofollow" href="https://github.com/"><b>Github</b></a><br><img style="vertical-align:middle" src="https://cdn.jsdelivr.net/gh/lzyblog/image@4b122354dee27f3056fd3a7fc6a43dbf68cebf33/2020/11/16/025e5329f3592dfa03a13c5365323ba1.png" alt=""> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.beian.miit.gov.cn/"><b>晋ICP备19005025号-2</b></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'itnxd-8g1z2i760e99f516',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'itnxd-8g1z2i760e99f516',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'itnxd-8g1z2i760e99f516',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><div class="aplayer no-destroy" data-id="1551071404" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/6dc9e8f9.js","daovoice")
</script><script>var isChatBtn = true
daovoice('init', {
  app_id: '6dc9e8f9',},{
  launcher: { 
     disableLauncherIcon: isChatBtn // 悬浮 ICON 是否显示
  },
});
daovoice('update');

if (isChatBtn) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      daovoice('show')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: true // 悬浮 ICON 是否显示
        },
      });
    }
    function chatBtnShow () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: false // 悬浮 ICON 是否显示
        },
      });
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>