<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM学习总结 | 小牛博客</title><meta name="keywords" content="JVM"><meta name="author" content="ITNXD"><meta name="copyright" content="ITNXD"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="¶一、什么是JVM ¶定义 Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境） ¶好处  一次编写，到处运行 自动内存管理，垃圾回收机制 数组下标越界检查 多态，使用虚方法机制调用实现  ¶比较 JVM JRE JDK的区别  ¶二、内存结构 ¶0、整体结构   方法区：类保存位置 堆：实例、对象保存位置 虚拟机栈、程序计数器、本地方法栈：实例对象调">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习总结">
<meta property="og:url" content="https://itnxd.eu.org/posts/43777.html">
<meta property="og:site_name" content="小牛博客">
<meta property="og:description" content="¶一、什么是JVM ¶定义 Java Virtual Machine，JAVA程序的运行环境（JAVA二进制字节码的运行环境） ¶好处  一次编写，到处运行 自动内存管理，垃圾回收机制 数组下标越界检查 多态，使用虚方法机制调用实现  ¶比较 JVM JRE JDK的区别  ¶二、内存结构 ¶0、整体结构   方法区：类保存位置 堆：实例、对象保存位置 虚拟机栈、程序计数器、本地方法栈：实例对象调">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/08/06/d625a577df424a8e480bb87940d0debc.png">
<meta property="article:published_time" content="2022-01-14T05:31:39.000Z">
<meta property="article:modified_time" content="2025-01-26T10:39:16.834Z">
<meta property="article:author" content="ITNXD">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/08/06/d625a577df424a8e480bb87940d0debc.png"><link rel="shortcut icon" href="https://cdn.itnxd.eu.org/gh/niuxvdong/images/img/favicon.ico"><link rel="canonical" href="https://itnxd.eu.org/posts/43777"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="H9LW1qdxrkJ55YbkfWulMvpaexxx3Rk0Yo6dVANeNHc"/><meta name="baidu-site-verification" content="code-YglH3DObCb"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8d3bd59bf6303bd5f44677445d369df5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":300,"languages":{"author":"作者: ITNXD","link":"链接: ","source":"来源: 小牛博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM学习总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-26 18:39:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="/css/my.css"><style type="text/css">#toggle-sidebar {bottom: 80px}</style><link rel="stylesheet" href="//at.alicdn.com/t/font_1828588_zrw9f0qqie.css"><link rel="stylesheet" href="/self/atom-one-light.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="小牛博客" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2021/02/06/e373babbf340391956b673128a84185d.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">261</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">214</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/08/06/d625a577df424a8e480bb87940d0debc.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小牛博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM学习总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-14T05:31:39.000Z" title="发表于 2022-01-14 13:31:39">2022-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-26T10:39:16.834Z" title="更新于 2025-01-26 18:39:16">2025-01-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">36.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>144分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM学习总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、什么是JVM"><a class="header-anchor" href="#一、什么是JVM">¶</a>一、什么是JVM</h1>
<h2 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h2>
<p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>
<h2 id="好处"><a class="header-anchor" href="#好处">¶</a>好处</h2>
<ul>
<li>一次编写，到处运行</li>
<li>自动内存管理，垃圾回收机制</li>
<li>数组下标越界检查</li>
<li>多态，使用虚方法机制调用实现</li>
</ul>
<h2 id="比较"><a class="header-anchor" href="#比较">¶</a>比较</h2>
<p>JVM JRE JDK的区别</p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/14/0b9147ca101a32aa7733d8a650b385bc.png" alt=""></p>
<h1 id="二、内存结构"><a class="header-anchor" href="#二、内存结构">¶</a>二、内存结构</h1>
<h2 id="0、整体结构"><a class="header-anchor" href="#0、整体结构">¶</a>0、整体结构</h2>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/14/b84becadbc0a8cba98a5ee2ad7ae5634.png" alt=""></p>
<ul>
<li>方法区：类保存位置</li>
<li>堆：实例、对象保存位置</li>
<li>虚拟机栈、程序计数器、本地方法栈：实例对象调用方法时用到</li>
<li>解释器：解释字节码变为机器码</li>
<li>JIT即时编译器：对热点数据优化处理</li>
<li>本地方法接口：Java无法实现的部分，根操作系统底层打交道的接口</li>
</ul>
<h2 id="1、程序计数器"><a class="header-anchor" href="#1、程序计数器">¶</a>1、程序计数器</h2>
<h3 id="定义-2"><a class="header-anchor" href="#定义-2">¶</a>定义</h3>
<p>Program Counter Register 程序计数器（寄存器）</p>
<h3 id="作用"><a class="header-anchor" href="#作用">¶</a>作用</h3>
<p><strong>用于保存JVM中下一条所要执行的指令的地址</strong></p>
<h3 id="特点"><a class="header-anchor" href="#特点">¶</a>特点</h3>
<ul>
<li>线程私有
<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li>
<li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li>
</ul>
</li>
<li>不会存在内存溢出
<ul>
<li>JVM中唯一一个内存不会溢出的规范</li>
</ul>
</li>
</ul>
<h2 id="2、虚拟机栈"><a class="header-anchor" href="#2、虚拟机栈">¶</a>2、虚拟机栈</h2>
<h3 id="定义-3"><a class="header-anchor" href="#定义-3">¶</a>定义</h3>
<p>Java Virtual Machine Stacks （Java 虚拟机栈）</p>
<ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong>，多个线程多个虚拟机栈</li>
<li>每个栈由多个<strong>栈帧</strong>组成，对应着每个方法运行时所占用的内存（操作数栈，局部变量表、方法返回地址、动态链接）</li>
<li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li>
</ul>
<h3 id="问题辨析"><a class="header-anchor" href="#问题辨析">¶</a>问题辨析</h3>
<ul>
<li>垃圾回收是否涉及栈内存？
<ul>
<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>
<li>垃圾回收主要是回收<strong>堆中</strong>的无用对象</li>
</ul>
</li>
<li>栈内存的分配越大越好吗？
<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>
<li><strong>解释</strong>：物理内存空间一定，栈内存设置越大，由于每个线程都会占用一个虚拟机栈，因此虚拟机栈的个数，即线程数会大大降低</li>
<li><code>-Xss</code>：可以指定栈大小</li>
</ul>
</li>
<li>方法内的局部变量是否是线程安全的？（<strong>逃逸分析</strong>）
<ul>
<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li>
<li>如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li>
</ul>
</li>
</ul>
<h3 id="栈内存溢出"><a class="header-anchor" href="#栈内存溢出">¶</a>栈内存溢出</h3>
<p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p>
<p><strong>发生原因</strong></p>
<ul>
<li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li>
<li>每个栈帧<strong>所占用过大</strong></li>
</ul>
<h3 id="线程运行诊断"><a class="header-anchor" href="#线程运行诊断">¶</a>线程运行诊断</h3>
<p>CPU占用过高</p>
<ul>
<li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程
<ul>
<li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li>
<li><strong>ps H -eo pid, tid（线程id） %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li>
<li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li>
<li>可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号</li>
</ul>
</li>
</ul>
<h2 id="3、本地方法栈"><a class="header-anchor" href="#3、本地方法栈">¶</a>3、本地方法栈</h2>
<p><strong>Native Method Stack</strong></p>
<p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法！</p>
<h2 id="4、堆"><a class="header-anchor" href="#4、堆">¶</a>4、堆</h2>
<h4 id="定义-4"><a class="header-anchor" href="#定义-4">¶</a>定义</h4>
<p>Heap 堆</p>
<p>通过new关键字创建的对象都会被放在堆内存</p>
<h4 id="特点-2"><a class="header-anchor" href="#特点-2">¶</a>特点</h4>
<ul>
<li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li>
<li>有垃圾回收机制</li>
</ul>
<h4 id="堆内存溢出"><a class="header-anchor" href="#堆内存溢出">¶</a>堆内存溢出</h4>
<p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p>
<ul>
<li><code>-Xmx</code>：设置堆内存大小</li>
</ul>
<h4 id="堆内存诊断"><a class="header-anchor" href="#堆内存诊断">¶</a>堆内存诊断</h4>
<ol>
<li>jps 工具：查看当前系统中有哪些 java 进程</li>
<li>jmap 工具：查看堆内存占用情况  jmap -heap 进程id</li>
<li>jconsole 工具：图形界面的，多功能的监测工具，可以连续监测</li>
</ol>
<h2 id="5、方法区"><a class="header-anchor" href="#5、方法区">¶</a>5、方法区</h2>
<p>Method Area</p>
<h3 id="结构"><a class="header-anchor" href="#结构">¶</a>结构</h3>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/14/33d7471bdee5af88e9c8d887b27958b2.png" alt=""></p>
<p>方法区类似接口，做规范！永久代和元空间为方法区的实现！</p>
<p>StringTable：字符串常量</p>
<ul>
<li>jdk1.8以前：永久代PermGen作为方法区的实现，字符串常量放在永久代的常量池</li>
<li>jdk1.8及以后：元空间Metaspace作为方法区的实现，字符串常量和静态变量移动到了堆中</li>
</ul>
<h3 id="内存溢出"><a class="header-anchor" href="#内存溢出">¶</a>内存溢出</h3>
<p><code>-XX:MetaspaceSize=8m</code>：指定元空间大小</p>
<ul>
<li><strong>java.lang.OutofMemoryError</strong> ：Metaspace</li>
</ul>
<p><code>-XX:MaxPermSize=8m</code>：指定永久代大小</p>
<ul>
<li><strong>java.lang.OutofMemoryError</strong> ：PermGen sapce</li>
</ul>
<p><code>-Xmx10m</code>：字符串常量池爆了之后的错误</p>
<ul>
<li><strong>java.lang.OutofMemoryError</strong> ：GC overhead limit exceeded</li>
</ul>
<p><code>-Xmx10m -XX:-UseGCOverheadLimit</code>：会关掉堆的GC</p>
<ul>
<li><strong>java.lang.OutofMemoryError</strong> ：java heap space</li>
</ul>
<h3 id="常量池"><a class="header-anchor" href="#常量池">¶</a>常量池</h3>
<p>二进制字节码的组成：</p>
<ul>
<li>类的基本信息</li>
<li>常量池：地址和数据的映射关系，就是一张表</li>
<li>类的方法定义（包含了虚拟机指令）会用到常量池进行查表</li>
</ul>
<p><strong>通过反编译来查看类的信息</strong>：javap -v xxx.class</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java">❯ javap -v .\Demo1.class<br><span class="hljs-comment">// 类基本信息</span><br>Classfile /E:/IdeaProject/JVM/target/classes/com/itnxd/jvm/constant/Demo1.class<br>  Last modified <span class="hljs-number">2022</span>年<span class="hljs-number">1</span>月<span class="hljs-number">14</span>日; size <span class="hljs-number">564</span> bytes<br>  SHA-<span class="hljs-number">256</span> checksum 9ccef1cb17e18fe2ec9045cbbc224e3645fa43545466c2f0fdf327728e75d265<br>  Compiled from <span class="hljs-string">"Demo1.java"</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">itnxd</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">constant</span>.<span class="hljs-title">Demo1</span></span><br>  minor version: 0<br>  major version: <span class="hljs-number">52</span><br>  flags: (<span class="hljs-number">0x0021</span>) ACC_PUBLIC, ACC_SUPER<br>  this_class: #5                          // com/itnxd/jvm/constant/Demo1<br>  super_class: #6                         // java/lang/Object<br>  interfaces: <span class="hljs-number">0</span>, fields: <span class="hljs-number">0</span>, methods: <span class="hljs-number">2</span>, attributes: <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 常量池</span><br>Constant pool:<br>   #1 = Methodref          #6.#20         // java/lang/Object."&lt;init&gt;":()V<br>   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;<br>   #3 = String             #23            // hello world<br>   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V<br>   #5 = Class              #26            // com/itnxd/jvm/constant/Demo1<br>   #6 = Class              #27            // java/lang/Object<br>   #7 = Utf8               &lt;init&gt;<br>   #8 = Utf8               ()V<br>   #9 = Utf8               Code<br>  #10 = Utf8               LineNumberTable<br>  #11 = Utf8               LocalVariableTable<br>  #12 = Utf8               this<br>  #13 = Utf8               Lcom/itnxd/jvm/constant/Demo1;<br>  #14 = Utf8               main<br>  #15 = Utf8               ([Ljava/lang/String;)V<br>  #16 = Utf8               args<br>  #17 = Utf8               [Ljava/lang/String;<br>  #18 = Utf8               SourceFile<br>  #19 = Utf8               Demo1.java<br>  #20 = NameAndType        #7:#8          // "&lt;init&gt;":()V<br>  #21 = Class              #28            // java/lang/System<br>  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;<br>  #23 = Utf8               hello world<br>  #24 = Class              #31            // java/io/PrintStream<br>  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V<br>  #26 = Utf8               com/itnxd/jvm/constant/Demo1<br>  #27 = Utf8               java/lang/Object<br>  #28 = Utf8               java/lang/System<br>  #29 = Utf8               out<br>  #30 = Utf8               Ljava/io/PrintStream;<br>  #31 = Utf8               java/io/PrintStream<br>  #32 = Utf8               println<br>  #33 = Utf8               (Ljava/lang/String;)V<br><span class="hljs-comment">// 类的方法定义</span><br>{<br>  <span class="hljs-keyword">public</span> com.itnxd.jvm.constant.Demo1();<br>    descriptor: ()V<br>    flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V<br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/itnxd/jvm/constant/Demo1;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: (<span class="hljs-number">0x0009</span>) ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>                  <br>         <span class="hljs-comment">// 虚拟机中执行编译的方法（框内的是真正编译执行的内容，#号的内容需要在常量池中查找）</span><br>                  <br>         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>         3: ldc           #3                  // String hello world<br>         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">10</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">8</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>}<br>SourceFile: <span class="hljs-string">"Demo1.java"</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="运行时常量池"><a class="header-anchor" href="#运行时常量池">¶</a>运行时常量池</h3>
<ul>
<li><strong>常量池</strong>
<ul>
<li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li>
</ul>
</li>
<li><strong>运行时常量池</strong>
<ul>
<li>常量池是*.class文件中的，当该<strong>类被加载以后</strong>，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></li>
</ul>
</li>
</ul>
<h3 id="字符串常量池-StringTable"><a class="header-anchor" href="#字符串常量池-StringTable">¶</a>字符串常量池 StringTable</h3>
<p>StringTable：字符串常量池底层就是HashTable，不能扩容！</p>
<p>jdk1.8串池被移动到了堆中！</p>
<p><strong>原因：</strong></p>
<ul>
<li>jdk1.7及以前：方法区实现是永久代，永久代只有老年代满了才会执行一次full gc，因此字符串常量池会很晚才会垃圾回收，真个系统会占用大量的字符串常量，若不及时回收，会导致内存占用，效率低下</li>
<li>jdk1.8及以后：</li>
</ul>
<p><strong>特征</strong></p>
<ul>
<li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong>
<ul>
<li>被用到：就是包含该符号的指令或方法真正被加载执行</li>
</ul>
</li>
<li>串池中的字符串常量都是<strong>不重复</strong>的：利用串池的机制，来避免重复创建字符串对象</li>
</ul>
<h3 id="字符串常量拼接"><a class="header-anchor" href="#字符串常量拼接">¶</a>字符串常量拼接</h3>
<ul>
<li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li>
<li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>只要拼接双方有一个是变量则结果都在堆中！</li>
<li>若修饰双方变量的都有final，则此时就是编译期常量了，拼接的结果在字符串常量池中</li>
<li><strong>建议</strong>：针对final修饰类、方法、引用数据类型、基本数据类型时，建议加上final，可以使得加载的时机更早一些</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><br>    String s1 = <span class="hljs-string">"a"</span>;<br>    String s2 = <span class="hljs-string">"b"</span>;<br>    String s3 = <span class="hljs-string">"ab"</span>; <span class="hljs-comment">// 处于堆中的字符串常量池</span><br>    <br>    <span class="hljs-comment">// 常量拼接编译器优化：编译期间可以确定，相当于 String s4 = "ab"; 不会改变，直接从字符串常量池中获取了</span><br>    String s4 = <span class="hljs-string">"a"</span> + <span class="hljs-string">"b"</span>;<br>    <br>    <span class="hljs-comment">// 变量拼接StringBuilder：编译期间无法确定，运行时动态确定</span><br>    String s5 = s1 + s2; <span class="hljs-comment">// 处于堆中，为一个new出来的对象</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	String s5 = s1 + s2; 流程：</span><br><span class="hljs-comment">	</span><br><span class="hljs-comment">	    1. new StringBuilder()</span><br><span class="hljs-comment">        2. StringBuilder.append(a)</span><br><span class="hljs-comment">        2. StringBuilder.append(b)</span><br><span class="hljs-comment">        3. StringBuilder.toString() 调用的是new String(byte[])</span><br><span class="hljs-comment">        4. new String(byte[])</span><br><span class="hljs-comment">        	注意：这里构造函数传入的不是""，因此这里不会在字符串常量池中放一份</span><br><span class="hljs-comment">	*/</span><br>    <br>    System.out.println(s3 == s5); <span class="hljs-comment">// false</span><br>}<br><br><br><span class="hljs-comment">// 反编译截取</span><br><br> 		 0: ldc           #2                  // String a<br>         <span class="hljs-number">2</span>: astore_1<br>         3: ldc           #3                  // String b<br>         <span class="hljs-number">5</span>: astore_2<br>         6: ldc           #4                  // String ab<br>         <span class="hljs-number">8</span>: astore_3<br>         9: ldc           #4                  // String ab<br>        <span class="hljs-number">11</span>: astore        <span class="hljs-number">4</span><br>        13: new           #5                  // class java/lang/StringBuilder<br>        <span class="hljs-number">16</span>: dup<br>        17: invokespecial #6                  // Method java/lang/StringBuilder."&lt;init&gt;":()V<br>        <span class="hljs-number">20</span>: aload_1<br>        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;<br>        <span class="hljs-number">24</span>: aload_2<br>        25: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;<br>        28: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;<br>        <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span><br><br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="intern方法"><a class="header-anchor" href="#intern方法">¶</a>intern方法</h3>
<ul>
<li>
<p>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</p>
</li>
<li>
<p><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</p>
</li>
<li>
<p>jdk1.7及以后：将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池为<strong>对象的引用地址复制</strong>，会把串池中的对象返回</p>
<ul>
<li>1.7及以后，由于字符串常量池移到了堆中，因此更好的操作是一个空间放一份即可，放多了浪费</li>
<li>因此：intern方法执行完后，s2指向的是堆中的地址"ab"，s指向的是字符串常量池中的一个对象地址，该对象指向堆中的"ab"，也就是s2指向的就是堆中的"ab"</li>
</ul>
</li>
<li>
<p>jdk1.6及以前：将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此<strong>对象复制一份</strong>，放入串池，会把串池中的对象返回</p>
<ul>
<li>因此：intern方法返回的对象其实指向的是新拷贝的对象在字符串常量池的地址</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><br>    String x = <span class="hljs-string">"ab"</span>;<br><br>    <span class="hljs-comment">// 注意：字符串常量池不会有"ab"，调用的不是new String(""),而是new String(byte[])</span><br>    String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"b"</span>);<br><br>    <span class="hljs-comment">// 将堆中的数据放一份到字符串常量池，如已有则不放，最终都是返回常量池中的对象</span><br>    String s2 = s.intern();<br><br>    <span class="hljs-comment">// 一、若前面注释掉x一行</span><br>    System.out.println(s2 == <span class="hljs-string">"ab"</span>); <span class="hljs-comment">// true 都是字符串常量池</span><br>    System.out.println(s == <span class="hljs-string">"ab"</span>); <span class="hljs-comment">// jdk6 false jdk7/8 true</span><br><br>    <span class="hljs-comment">// 二、添加x一行</span><br>    System.out.println(s == <span class="hljs-string">"ab"</span>); <span class="hljs-comment">// false</span><br>    <br>    System.out.println(s2 == <span class="hljs-string">"ab"</span>); <span class="hljs-comment">// true 都是常量池中的同一个对象</span><br><br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="new-String-创建几个对象"><a class="header-anchor" href="#new-String-创建几个对象">¶</a>new String()创建几个对象</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"a"</span>);<br>创建的对象有：<br><span class="hljs-number">1.</span> 堆中一个<br><span class="hljs-number">2.</span> 字符串常量池中的<span class="hljs-string">"a"</span>一个<br><br>String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"b"</span>);<br>创建的对象有：<br><span class="hljs-number">1.</span> <span class="hljs-keyword">new</span> StringBuilder()<br><span class="hljs-number">2.</span> <span class="hljs-keyword">new</span> String(<span class="hljs-string">"a"</span>)<br><span class="hljs-number">3.</span> <span class="hljs-keyword">new</span> String(<span class="hljs-string">"b"</span>)<br><span class="hljs-number">4.</span> 字符串常量池的<span class="hljs-string">"a"</span><br><span class="hljs-number">5.</span> 字符串常量池的<span class="hljs-string">"b"</span><br><span class="hljs-number">6.</span> StringBuilder.toString() 调用的 <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">byte</span>[])<br>    注意：<span class="hljs-keyword">new</span> String(<span class="hljs-string">"xxx"</span>)：会向字符串常量池放一份<br>         <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">byte</span>[])：不会操作字符串常量池<br></code></pre></td></tr></tbody></table></figure>
<h3 id="StringTable-垃圾回收"><a class="header-anchor" href="#StringTable-垃圾回收">¶</a>StringTable 垃圾回收</h3>
<p>StringTable在内存紧张时，会发生垃圾回收</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示 StringTable 垃圾回收</span><br><span class="hljs-comment"> * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_7</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++) { <span class="hljs-comment">// j=100, j=10000</span><br>                String.valueOf(j).intern();<br>                i++;<br>            }<br>        } <span class="hljs-keyword">catch</span> (Throwable e) {<br>            e.printStackTrace();<br>        } <span class="hljs-keyword">finally</span> {<br>            System.out.println(i);<br>        }<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="StringTable-性能调优"><a class="header-anchor" href="#StringTable-性能调优">¶</a>StringTable 性能调优</h3>
<ul>
<li>
<p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:StringTableSize=桶个数（最小值为<span class="hljs-number">1009</span>）<br>桶太少会导致一个桶里放的数据太多，哈希冲突也会变大<br></code></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>考虑是否需要将字符串对象入池：可以通过<strong>intern方法减少重复入池</strong></p>
</li>
</ul>
<h3 id="直接内存"><a class="header-anchor" href="#直接内存">¶</a>直接内存</h3>
<p>Direct Memory</p>
<ul>
<li><strong>属于操作系统</strong>，常见于NIO操作时，<strong>用于数据缓冲区</strong></li>
<li><strong>分配回收成本较高，但读写性能高</strong></li>
<li><strong>不受JVM内存回收管理</strong></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_9</span> </span>{<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FROM = <span class="hljs-string">"E:\\编程资料\\第三方教学视频\\youtube\\Getting Started with Spring Boot-sbPSjI4tt10.mp4"</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TO = <span class="hljs-string">"E:\\a.mp4"</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1Mb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        io(); <span class="hljs-comment">// io 用时：1535.586957 1766.963399 1359.240226</span><br>        directBuffer(); <span class="hljs-comment">// directBuffer 用时：479.295165 702.291454 562.56592</span><br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">directBuffer</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">try</span> (FileChannel from = <span class="hljs-keyword">new</span> FileInputStream(FROM).getChannel();<br>             FileChannel to = <span class="hljs-keyword">new</span> FileOutputStream(TO).getChannel();<br>        ) {<br>            ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {<br>                <span class="hljs-keyword">int</span> len = from.read(bb);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) {<br>                    <span class="hljs-keyword">break</span>;<br>                }<br>                bb.flip();<br>                to.write(bb);<br>                bb.clear();<br>            }<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            e.printStackTrace();<br>        }<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(<span class="hljs-string">"directBuffer 用时："</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">io</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">try</span> (FileInputStream from = <span class="hljs-keyword">new</span> FileInputStream(FROM);<br>             FileOutputStream to = <span class="hljs-keyword">new</span> FileOutputStream(TO);<br>        ) {<br>            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_1Mb];<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {<br>                <span class="hljs-keyword">int</span> len = from.read(buf);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) {<br>                    <span class="hljs-keyword">break</span>;<br>                }<br>                to.write(buf, <span class="hljs-number">0</span>, len);<br>            }<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            e.printStackTrace();<br>        }<br>        <span class="hljs-keyword">long</span> end = System.nanoTime();<br>        System.out.println(<span class="hljs-string">"io 用时："</span> + (end - start) / <span class="hljs-number">1000_000.0</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>使用普通流读写数据：会有两次复制操作</strong></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/b187842fc4be99d0fcb27ce7c1dd9087.png" alt=""></p>
<p><strong>使用NIO读写会分配直接内存，少了一次复制</strong></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/4aa202a219bcc1ab633de6160612fd03.png" alt=""></p>
<h3 id="直接内存溢出"><a class="header-anchor" href="#直接内存溢出">¶</a>直接内存溢出</h3>
<p><strong>java.lang.OutofMemoryError</strong> ：Direct buffer Memory</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_10</span> </span>{<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _100Mb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        List&lt;ByteBuffer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {<br>                ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_100Mb);<br>                list.add(byteBuffer);<br>                i++;<br>            }<br>        } <span class="hljs-keyword">finally</span> {<br>            System.out.println(i);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="直接内存回收释放原理"><a class="header-anchor" href="#直接内存回收释放原理">¶</a>直接内存回收释放原理</h3>
<ul>
<li>直接内存回收不是Java虚拟机的垃圾回收</li>
<li>使用的是底层的Unsafe方法，调用的是顶层操作系统的释放内存方法</li>
</ul>
<p><strong>通过反射得到Unsafe方法来对直接内存进行释放：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_27</span> </span>{<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1Gb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        Unsafe unsafe = getUnsafe();<br>        <span class="hljs-comment">// 分配内存</span><br>        <span class="hljs-keyword">long</span> base = unsafe.allocateMemory(_1Gb);<br>        unsafe.setMemory(base, _1Gb, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);<br>        System.in.read();<br><br>        <span class="hljs-comment">// 释放内存</span><br>        unsafe.freeMemory(base);<br>        System.in.read();<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">try</span> {<br>            Field f = Unsafe.class.getDeclaredField(<span class="hljs-string">"theUnsafe"</span>);<br>            f.setAccessible(<span class="hljs-keyword">true</span>);<br>            Unsafe unsafe = (Unsafe) f.get(<span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">return</span> unsafe;<br>        } <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>详细原理</strong></p>
<p>DirectByteBuffer实现如下：<strong>虚引用机制</strong><br>
1. 分配和回收都是调用操作系统的UNSAFE方法<br>
2. Cleaner 方法关联了一个任务回调对象，回调方法实现了Runnable接口，run方法调用了UNSAFE的释放内存方法<br>
3. Cleaner是一个虚引用对象，当他关联的对象（ByteBuffer）被Java才能进回收时，就会触发自己的clean方法<br>
4. clean方法会调用Runnable线程的run方法进行释放内存（底层会有一个引用handler监控虚引用对象）</p>
<ul>
<li>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法</li>
<li>ByteBuﬀer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuﬀer 对象，一旦ByteBuﬀer 对象被垃圾回收，那么就会由 <strong>ReferenceHandler 线程</strong>通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过ByteBuffer申请1M的直接内存</span><br>ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);<br></code></pre></td></tr></tbody></table></figure>
<p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p>
<p><strong>allocateDirect的实现</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>DirectByteBuffer类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-keyword">int</span> cap) {   <span class="hljs-comment">// package-private</span><br>   <br>    <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);<br>    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();<br>    <span class="hljs-keyword">int</span> ps = Bits.pageSize();<br>    <span class="hljs-keyword">long</span> size = Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-keyword">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));<br>    Bits.reserveMemory(size, cap);<br><br>    <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> {<br>        base = unsafe.allocateMemory(size); <span class="hljs-comment">//申请内存</span><br>    } <span class="hljs-keyword">catch</span> (OutOfMemoryError x) {<br>        Bits.unreserveMemory(size, cap);<br>        <span class="hljs-keyword">throw</span> x;<br>    }<br>    unsafe.setMemory(base, size, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) {<br>        <span class="hljs-comment">// Round up to page boundary</span><br>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));<br>    } <span class="hljs-keyword">else</span> {<br>        address = base;<br>    }<br>    <span class="hljs-comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对</span><br>    cleaner = Cleaner.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Deallocator(base, size, cap)); 象<br>    att = <span class="hljs-keyword">null</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>{<br>       <span class="hljs-keyword">if</span> (remove(<span class="hljs-keyword">this</span>)) {<br>           <span class="hljs-keyword">try</span> {<br>               <span class="hljs-keyword">this</span>.thunk.run(); <span class="hljs-comment">//调用run方法</span><br>           } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) {<br>               AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() {<br>                   <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-keyword">null</span>) {<br>                           (<span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Cleaner terminated abnormally"</span>, var2)).printStackTrace();<br>                       }<br><br>                       System.exit(<span class="hljs-number">1</span>);<br>                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                   }<br>               });<br>           }Copy<br></code></pre></td></tr></tbody></table></figure>
<p>对应对象的run方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) {<br>        <span class="hljs-comment">// Paranoia</span><br>        <span class="hljs-keyword">return</span>;<br>    }<br>    unsafe.freeMemory(address); <span class="hljs-comment">//释放直接内存中占用的内存</span><br>    address = <span class="hljs-number">0</span>;<br>    Bits.unreserveMemory(size, capacity);<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="禁用显示垃圾回收对直接内存释放影响"><a class="header-anchor" href="#禁用显示垃圾回收对直接内存释放影响">¶</a>禁用显示垃圾回收对直接内存释放影响</h3>
<ul>
<li>-XX:+DisableExplicitGC：禁用显示垃圾回收，System.gc()将会失效，因此直接内存释放会受到影响</li>
<li>直接内存只有等到真正发生GC的时候才会去释放</li>
<li>但也可以通过Unsafe的方法手动释放直接内存</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_26</span> </span>{<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> _1Gb = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * -XX:+DisableExplicitGC 显式的</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1Gb);<br>        System.out.println(<span class="hljs-string">"分配完毕..."</span>);<br>        System.in.read();<br>        System.out.println(<span class="hljs-string">"开始释放..."</span>);<br>        byteBuffer = <span class="hljs-keyword">null</span>;<br>        System.gc(); <span class="hljs-comment">// 显式的垃圾回收，Full GC</span><br>        System.in.read();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h1 id="三、垃圾回收"><a class="header-anchor" href="#三、垃圾回收">¶</a>三、垃圾回收</h1>
<h2 id="1、如何判断对象可以回收"><a class="header-anchor" href="#1、如何判断对象可以回收">¶</a>1、如何判断对象可以回收</h2>
<h3 id="引用计数法"><a class="header-anchor" href="#引用计数法">¶</a>引用计数法</h3>
<p><strong>弊端</strong>：<strong>循环引用</strong>时，两个对象的计数都为1，导致两个对象都无法被释放</p>
<h3 id="可达性分析算法"><a class="header-anchor" href="#可达性分析算法">¶</a>可达性分析算法</h3>
<ul>
<li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li>
<li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li>
<li>可以作为GC Root的对象
<ul>
<li>本地方法栈：本地方法栈中JNI（即一般说的<strong>Native方法</strong>）引用的对象</li>
<li>Thread：虚拟机栈（<strong>栈帧</strong>中的<strong>本地变量表</strong>）中<strong>引用的对象</strong>。</li>
<li>System Class：<strong>系统核心类</strong></li>
<li>Busy Monitor：正在使用的<strong>被加锁的对象</strong></li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/9fcfeeb1071535145539b24ce349a687.png" alt=""></p>
<h3 id="五种引用"><a class="header-anchor" href="#五种引用">¶</a>五种引用</h3>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/b79dc1b4f389e18ccc33bcbedced7a85.png" alt=""></p>
<ol>
<li>
<p><strong>强引用</strong></p>
<ol>
<li>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li>
<li>如上图B、C对象<strong>都不强引用</strong>A1对象时，A1对象才会被回收</li>
</ol>
</li>
<li>
<p><strong>软引用（SoftReference）</strong></p>
<ol>
<li>仅有软引用引用该对象时，在垃圾回收后，<strong>内存仍不足</strong>时会<strong>再次</strong>出发垃圾回收，回收软引用对象</li>
<li>可以配合引用队列来释放软引用自身</li>
<li>如上图如果B对象<strong>不再强引用</strong>A2对象<strong>且内存不足</strong>时，软引用所引用的A2对象就会被回收</li>
</ol>
</li>
<li>
<p><strong>弱引用（WeakReference）</strong></p>
<ol>
<li>仅有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收，回收弱引用对象</li>
<li>可以配合引用队列来释放弱引用自身</li>
<li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li>
</ol>
</li>
<li>
<p><strong>虚引用（PhantomReference）</strong></p>
<ol>
<li>必须配合引用队列使用，<strong>主要配合 ByteBuﬀer</strong> 使用，被引用对象回收时，会将虚引用入队，由 <strong>Reference Handler 线程</strong>调用虚引用相关方法释放直接内存</li>
<li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>
<li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li>
</ol>
</li>
<li>
<p><strong>终结器引用（FinalReference）</strong></p>
<ol>
<li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用<strong>先入队</strong>（被引用对象<strong>暂时没有被回收</strong>），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 ﬁnalize方法，<strong>第二次 GC</strong> 时才能回收被引用对象</li>
<li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li>
</ol>
</li>
</ol>
<p><strong>终接器引用补充：</strong></p>
<ul>
<li>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li>
<li>处理终接器引用的FinalizeHandler的<strong>线程优先级很低</strong>，被执行机会很少，可能导致被引用对象迟迟不会释放，因此<strong>不推荐使用finalize方法释放内存</strong></li>
</ul>
<p><strong>引用队列</strong></p>
<ul>
<li>软引用和弱引用<strong>可以配合</strong>引用队列
<ul>
<li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li>
</ul>
</li>
<li>虚引用和终结器引用<strong>必须配合</strong>引用队列
<ul>
<li>虚引用和终结器引用在使用时会关联一个引用队列</li>
</ul>
</li>
</ul>
<h3 id="软引用应用"><a class="header-anchor" href="#软引用应用">¶</a>软引用应用</h3>
<ul>
<li>强引用：内存占满后会 java.lang.OutofMemoryError：java heap space</li>
<li>弱引用：内存紧张会时会<strong>再次</strong>出触发一次垃圾回收Full GC，使得内存一定可以放下下一步的占用</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示软引用</span><br><span class="hljs-comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_3</span> </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br><br><br>    <span class="hljs-comment">// 强引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        <span class="hljs-comment">/*List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span><br><span class="hljs-comment">        for (int i = 0; i &lt; 5; i++) {</span><br><span class="hljs-comment">            list.add(new byte[_4MB]);</span><br><span class="hljs-comment">        }</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        System.in.read();*/</span><br>        soft();<br><br><br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">soft</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-comment">// list --&gt; SoftReference --&gt; byte[]</span><br><br>        List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {<br>            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br><br>        }<br>        System.out.println(<span class="hljs-string">"循环结束："</span> + list.size());<br>        <span class="hljs-keyword">for</span> (SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref : list) {<br>            <span class="hljs-comment">// 四个null 一个有值</span><br>            System.out.println(ref.get());<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="软引用引用队列"><a class="header-anchor" href="#软引用引用队列">¶</a>软引用引用队列</h3>
<ul>
<li>关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</li>
<li>从队列中获取无用的软引用对象，并移除（从队列移除后自然软引用自身也会被下一次GC掉）</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示软引用, 配合引用队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_4</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-comment">// 引用队列</span><br>        ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {<br>            <span class="hljs-comment">// 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span><br>            SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB], queue);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br>        }<br><br>        <span class="hljs-comment">// 从队列中获取无用的 软引用对象，并移除（从队列移除后自然软引用自身也会被下一次GC掉）</span><br>        Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span>( poll != <span class="hljs-keyword">null</span>) {<br>            list.remove(poll);<br>            poll = queue.poll();<br>        }<br><br>        System.out.println(<span class="hljs-string">"==========================="</span>);<br>        <span class="hljs-keyword">for</span> (SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; reference : list) {<br>            <span class="hljs-comment">// 此时由于移除了软引用为null的，因此只会打印一次有值</span><br>            System.out.println(reference.get());<br>        }<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="弱引用"><a class="header-anchor" href="#弱引用">¶</a>弱引用</h3>
<ul>
<li>软引用内存不够会再次触发一次Full GC</li>
<li>弱引用在垃圾回收时就会将一些弱引用对象进行回收，内存非常吃紧时候才会进行一次Full GC</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2_5</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4MB = <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-comment">//  list --&gt; WeakReference --&gt; byte[]</span><br>        List&lt;WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {<br>            WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4MB]);<br>            list.add(ref);<br>            <span class="hljs-keyword">for</span> (WeakReference&lt;<span class="hljs-keyword">byte</span>[]&gt; w : list) {<br>                System.out.print(w.get()+<span class="hljs-string">" "</span>);<br>            }<br>            System.out.println();<br><br>        }<br>        System.out.println(<span class="hljs-string">"循环结束："</span> + list.size());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="2、垃圾回收算法"><a class="header-anchor" href="#2、垃圾回收算法">¶</a>2、垃圾回收算法</h2>
<h3 id="标记清除"><a class="header-anchor" href="#标记清除">¶</a>标记清除</h3>
<p>Mark Sweep</p>
<p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾回收器根据标识清除相应的内容，给堆内存腾出相应的空间</p>
<ul>
<li>这里的腾出内存空间并不是将内存空间的字节清0，而是<strong>记录下这段内存的起始结束地址</strong>，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li>
</ul>
<p>优点：速度快</p>
<p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p>
<h3 id="标记整理"><a class="header-anchor" href="#标记整理">¶</a>标记整理</h3>
<p>Mark Compact</p>
<p>标记-整理：会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以<strong>效率较低</strong></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/8f304731c0f2286838026d6f481e7869.png" alt=""></p>
<h3 id="复制算法"><a class="header-anchor" href="#复制算法">¶</a>复制算法</h3>
<p>Copy</p>
<p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。</p>
<p>优点：这样也可以避免内存碎片的问题</p>
<p>缺点：但是会占用双倍的内存空间</p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/205fe28736db1a8067c231dffd276e7d.png" alt=""></p>
<h3 id="复制与标记整理对比"><a class="header-anchor" href="#复制与标记整理对比">¶</a>复制与标记整理对比</h3>
<p><strong>复制的性能好于标记整理？</strong></p>
<ul>
<li>复制：直接进行大片内存移动即可，</li>
<li>标记整理：整理本身就是复制的过程，但是确比复制更加复制，产生很多碎片，得判断碎片大小，移动位置</li>
</ul>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<p>JVM是根据具体情况，选择一个或多个垃圾回收算法协同工作！</p>
<h2 id="3、分代垃圾回收"><a class="header-anchor" href="#3、分代垃圾回收">¶</a>3、分代垃圾回收</h2>
<h3 id="堆内存划分"><a class="header-anchor" href="#堆内存划分">¶</a>堆内存划分</h3>
<p><strong>堆内存被划分为：</strong></p>
<ul>
<li>新生代：适合用完就回收的 <strong>Minor GC</strong> <strong>默认空间比例：8:1:1</strong>
<ul>
<li>伊甸园区</li>
<li>幸存区From</li>
<li>幸存区To</li>
</ul>
</li>
<li>老年代：后续还要使用的</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/1f5e14c33e17ea8fbb77ef128025a038.png" alt=""></p>
<h3 id="GC流程"><a class="header-anchor" href="#GC流程">¶</a>GC流程</h3>
<ol>
<li>对象首先分配在伊甸园区域</li>
<li>伊甸园空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且<strong>交换 from to</strong></li>
<li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 （防止线程使用的内存地址不匹配，出现问题，回收时间很快）</li>
<li>当对象寿命超过阈值时，会晋升至老年代，<strong>最大</strong>寿命是15（4bit）（最大不是一定，某些情到不了15）</li>
<li>当老年代空间不足，会先尝试触发 <strong>minor gc</strong>，如果之后空间仍不足，那么触发 <strong>full gc</strong>，<strong>STW</strong>（stop the world）的<strong>时间更长</strong></li>
</ol>
<h3 id="相关-JVM-参数"><a class="header-anchor" href="#相关-JVM-参数">¶</a>相关 JVM 参数</h3>
<ul>
<li>堆初始大小：-Xms</li>
<li>堆最大大小：-Xmx 或 -XX:MaxHeapSize=size</li>
<li>新生代大小：-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</li>
<li>幸存区比例（动态）：-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</li>
<li>幸存区比例：-XX:SurvivorRatio=ratio</li>
<li>晋升阈值：-XX:MaxTenuringThreshold=threshold</li>
<li>GC详情：-XX:+PrintGCDetails -verbose:gc</li>
<li>晋升详情：-XX:+PrintTenuringDistribution</li>
<li>FullGC 前 MinorGC：-XX:+ScavengeBeforeFullGC</li>
</ul>
<h3 id="GC-分析"><a class="header-anchor" href="#GC-分析">¶</a>GC 分析</h3>
<h4 id="大对象处理策略"><a class="header-anchor" href="#大对象处理策略">¶</a>大对象处理策略</h4>
<p>当遇到一个<strong>较大的对象</strong>时，在新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p>
<h4 id="线程内存溢出"><a class="header-anchor" href="#线程内存溢出">¶</a>线程内存溢出</h4>
<p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p>
<p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p>
<h2 id="4、垃圾回收器"><a class="header-anchor" href="#4、垃圾回收器">¶</a>4、垃圾回收器</h2>
<h3 id="串行"><a class="header-anchor" href="#串行">¶</a>串行</h3>
<ul>
<li>单线程</li>
<li>堆内存较小，适合个人电脑</li>
<li>-XX:+UseSerialGC = Serial + SerialOld</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/5cede90cbd52c231f4d2ebd92a9f75fa.png" alt=""></p>
<p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p>
<p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p>
<h4 id="Serial-回收器"><a class="header-anchor" href="#Serial-回收器">¶</a>Serial 回收器</h4>
<p>Serial 回收器是最基本的、发展历史最悠久的回收器</p>
<p><strong>特点：</strong> <strong>单线程</strong>、简单高效（与其他回收器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial回收器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。回收器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p>
<h4 id="ParNew-回收器"><a class="header-anchor" href="#ParNew-回收器">¶</a>ParNew 回收器</h4>
<p>ParNew回收器其实就是Serial回收器的多线程版本</p>
<p><strong>特点</strong>：<strong>多线程</strong>、ParNew回收器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial回收器一样存在Stop The World问题</p>
<h4 id="Serial-Old-回收器"><a class="header-anchor" href="#Serial-Old-回收器">¶</a>Serial Old 回收器</h4>
<p>Serial Old是Serial回收器的老年代版本</p>
<p><strong>特点</strong>：同样是<strong>单线程</strong>回收器，采用<strong>标记-整理算法</strong></p>
<h3 id="吞吐量优先"><a class="header-anchor" href="#吞吐量优先">¶</a>吞吐量优先</h3>
<h4 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h4>
<ul>
<li>多线程</li>
<li>堆内存较大，多核 cpu</li>
<li>让单位时间内，STW 的时间最短，垃圾回收时间占比最低，这样就称吞吐量高（多食少餐）</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/284ee66db633400c039378e8a3c76938.png" alt=""></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:+UseParallelGC ~ -XX:+UseParallelOldGC <br>-XX:+UseAdaptiveSizePolicy<br>-XX:GCTimeRatio=ratio <br>-XX:MaxGCPauseMillis=ms <br>-XX:ParallelGCThreads=n<br></code></pre></td></tr></tbody></table></figure>
<p><strong>Parallel：并行</strong></p>
<ul>
<li>即用户线程和垃圾回收线程并行执行</li>
</ul>
<h4 id="Parallel-Scavenge-回收器"><a class="header-anchor" href="#Parallel-Scavenge-回收器">¶</a>Parallel Scavenge 回收器</h4>
<ul>
<li>与吞吐量关系密切，故也称为吞吐量优先回收器</li>
<li><strong>特点</strong>：属于新生代回收器也是采用<strong>复制算法</strong>的回收器（用到了新生代的幸存区），又是并行的多线程回收器（与ParNew回收器类似）</li>
<li>该回收器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew回收器最重要的一个区别）</li>
</ul>
<h4 id="Parallel-Old-回收器"><a class="header-anchor" href="#Parallel-Old-回收器">¶</a>Parallel Old 回收器</h4>
<ul>
<li>是Parallel Scavenge回收器的老年代版本</li>
<li><strong>特点</strong>：<strong>多线程</strong>，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</li>
<li>响应时间优先</li>
</ul>
<h4 id="GC自适应调节策略"><a class="header-anchor" href="#GC自适应调节策略">¶</a>GC自适应调节策略</h4>
<ul>
<li>
<p>Parallel Scavenge回收器可设置-XX:+UseAdptiveSizePolicy参数。</p>
</li>
<li>
<p>当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等</p>
</li>
<li>
<p>虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p>
</li>
<li>
<p>Parallel Scavenge回收器使用三个参数<strong>控制吞吐量</strong>：</p>
<ul>
<li>
<p>XX:MaxGCPauseMillis=ms：控制最大的垃圾收集停顿时间，与下一个互斥，堆大了，每次垃圾回收耗时就会增加，默认为200ms</p>
</li>
<li>
<p>XX:GCTimeRatio=radio：（堆调大了）直接设置吞吐量的大小，非垃圾回收时间与总时间占比，即吞吐量：1 / (1+ radio)，一般设置为19</p>
</li>
<li>
<p>-XX:ParallelGCThreads：控制线程数</p>
</li>
</ul>
</li>
</ul>
<h3 id="响应时间优先"><a class="header-anchor" href="#响应时间优先">¶</a>响应时间优先</h3>
<h4 id="简介-2"><a class="header-anchor" href="#简介-2">¶</a>简介</h4>
<ul>
<li>多线程</li>
<li>堆内存较大，多核 cpu</li>
<li>尽可能让单次 STW 的时间最短 （少食多餐，尽可能不影响其他人）</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/d524db8ff677cb9382456b9d32fae393.png" alt=""></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:+UseConcMarkSweepGC（并发标记清除） ~ -XX:+UseParNewGC ~ SerialOld <br>-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads <br>-XX:CMSInitiatingOccupancyFraction=percent<br>-XX:+CMSScavengeBeforeRemark<br></code></pre></td></tr></tbody></table></figure>
<h4 id="参数介绍"><a class="header-anchor" href="#参数介绍">¶</a>参数介绍</h4>
<p><strong>Concurrent：并发</strong></p>
<ul>
<li>即用户线程和垃圾回收线程并发执行，互不影响</li>
</ul>
<p><strong>ConcMarkSweep：并发标记清除CMS</strong></p>
<p><strong>-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld ：</strong></p>
<ul>
<li>从左往后：
<ul>
<li>CMS（老年代，<strong>标记清除</strong>算法）</li>
<li>ParNew回收器（新生代，复制算法）</li>
<li>CMS<strong>并发失败</strong>的补救措施，<strong>退化</strong>为单线程的Serial Old基于<strong>标记整理</strong>回收器（单线程）
<ul>
<li>CMS基于标记清除算法，因此会有大量的内存碎片</li>
<li>新生代和老年代内存都不足就会造成并发失败（内存碎片太多）</li>
<li>退化为SerialOld回收器，做一次单线程串行的<strong>内存整理</strong></li>
<li>一旦发生并发失败，垃圾回收的处理时间会一下子飙升，完成一次Full GC（单线程的内存整理慢）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads</strong></p>
<ul>
<li>从左往右：
<ul>
<li>设置并行总的线程数，默认4</li>
<li>设置并发时GC线程数，建议设置为并行线程数的1/4</li>
</ul>
</li>
</ul>
<p><strong>-XX:CMSInitiatingOccupancyFraction=percent</strong></p>
<ul>
<li>指浮动垃圾清理的时机为堆内存占用的percent的百分比，相当于预留空间给浮动垃圾，也就是给用户进程留出空间</li>
</ul>
<p><strong>-XX:+CMSScavengeBeforeRemark</strong></p>
<ul>
<li>重新标记前先对新生代进行一次垃圾回收，这样可以减轻重新标记的压力</li>
</ul>
<h4 id="CMS-回收器"><a class="header-anchor" href="#CMS-回收器">¶</a>CMS 回收器</h4>
<p>Concurrent Mark Sweep，并发标记清除回收器，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>回收器</p>
<p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、<strong>低停顿</strong>，但是<strong>会产生内存碎片</strong></p>
<p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统<strong>停顿时间最短</strong>，给用户带来更好的体验等场景下。如web程序、b/s服务</p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/d524db8ff677cb9382456b9d32fae393.png" alt=""></p>
<p><strong>CMS回收器的运行过程分为下列4步：</strong></p>
<ul>
<li><strong>初始标记</strong>：由于老年代内存不足导致，标记GC Roots能直接到的对象。<strong>速度很快</strong>但是<strong>仍存在Stop The World问题</strong>（<strong>耗时最短</strong>）</li>
<li><strong>并发标记</strong>：进行<strong>可达性分析的过程</strong>，遍历整个对象图，找出存活对象且用户线程可并发执行（这里的并发指的宏观上用户线程和垃圾回收线程同时存在）（<strong>耗时最长</strong>）</li>
<li><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生<strong>变动</strong>的那一部分对象的标记记录。<strong>仍然存在Stop The World问题</strong></li>
<li><strong>并发清除</strong>：对标记的对象进行清除回收（这里的并发指的宏观上用户线程和垃圾回收线程同时存在）</li>
</ul>
<p>CMS回收器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p>
<h4 id="CMS的目的"><a class="header-anchor" href="#CMS的目的">¶</a>CMS的目的</h4>
<p>最大可能减少STW的占用时间，发生STW的为两个阶段</p>
<ul>
<li>初始标记：标记的东西少，速度很快</li>
<li>重新标记：只是为了修正并发标记的变动，速度很快</li>
</ul>
<h4 id="CMS的缺点"><a class="header-anchor" href="#CMS的缺点">¶</a>CMS的缺点</h4>
<p>虽然做到了响应时间优先，但<strong>占有了一定的CPU使用量</strong>（尤其是重新标记），对系统的吞吐量是有影响的！</p>
<ul>
<li>进行垃圾会收的次数也相对之下多了不少</li>
<li>例如，并发清理时候，由于用户线程也在运行，又会产生新的垃圾（<strong>浮动垃圾</strong>）</li>
<li>此方式又不会向其他回收器一样，等到下一次堆空间不足GC；也就是浮动垃圾不会等到堆内存不足才清理，提前清理
<ul>
<li>详见上面讲的这个参数：<strong>-XX:CMSInitiatingOccupancyFraction=percent</strong></li>
</ul>
</li>
</ul>
<h3 id="默认垃圾回收器"><a class="header-anchor" href="#默认垃圾回收器">¶</a>默认垃圾回收器</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:+PrintCommandLineFlags 参数可查看默认设置收集器类型<br>-XX:+PrintGCDetails 亦可通过打印的GC日志的新生代、老年代名称判断<br><br>JDK8：Parallel Scavenge（新生代）+ Serial Old（老年代）<br>JDK9：G1<br></code></pre></td></tr></tbody></table></figure>
<h3 id="G1"><a class="header-anchor" href="#G1">¶</a>G1</h3>
<h4 id="简介-3"><a class="header-anchor" href="#简介-3">¶</a>简介</h4>
<p>定义：Garbage First</p>
<ul>
<li>2004 论文发布</li>
<li>2009 JDK 6u14 体验</li>
<li>2012 JDK 7u4 官方支持</li>
<li>2017 JDK 9 默认，而且替代了CMS 收集器</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/84fc3158676faf3bd95af8ce6411526d.png" alt=""></p>
<p><strong>流程：</strong></p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>筛选回收</li>
</ol>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>同时</strong>注重<strong>吞吐量</strong>（Throughput）和<strong>低延迟</strong>（Low latency），默认的暂停目标是 <strong>200 ms</strong></li>
<li>超大堆内存，会将堆<strong>划分为多个大小相等的Region</strong>
<ul>
<li>每个region都<strong>只放一类</strong>：伊甸园区，幸存者区，老年代</li>
<li>划分的目的：分治，速度会加快</li>
</ul>
</li>
<li>整体上是 <strong>标记+整理</strong>  算法，两个区域之间是 <strong>复制</strong>  算法</li>
</ul>
<p>相关 JVM 参数</p>
<ul>
<li>-XX:+UseG1GC：jdk9以后默认，无需显示指定</li>
<li>-XX:G1HeapRegionSize=size ：设置G1每个堆分区大小</li>
<li>-XX:MaxGCPauseMillis=time：设置最大暂停目标时长，也就是垃圾处理最大STW时间，可以调大一点来增加吞吐量</li>
</ul>
<h4 id="G1垃圾回收阶段"><a class="header-anchor" href="#G1垃圾回收阶段">¶</a>G1垃圾回收阶段</h4>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/f673d4a96b76ce1d520ffa02df567fe6.png" alt=""></p>
<p>新生代内存超过阈值—–&gt;新生代回收+并发标记—–&gt;混合回收，回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p>
<h4 id="Young-Collection"><a class="header-anchor" href="#Young-Collection">¶</a>Young Collection</h4>
<p>E：伊甸园区</p>
<p>S：幸存者区</p>
<p>O：老年区</p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/a8fc1dd147b359145427bdde4669f0c9.png" alt=""></p>
<p><strong>Young Collection：会 STW</strong></p>
<ol>
<li>G1划分了的堆的分区Region</li>
<li><strong>分代</strong>是按对象的生命周期划分</li>
<li><strong>分区</strong>则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</li>
</ol>
<h4 id="Young-Collection-CM"><a class="header-anchor" href="#Young-Collection-CM">¶</a>Young Collection + CM</h4>
<p>CM：并发标记</p>
<ul>
<li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li>
<li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行<strong>并发标记</strong>（<strong>不会STW</strong>），阈值可以根据用户来进行设定
<ul>
<li>-XX:InitiatingHeapOccupancyPercent=percent （默认45%)</li>
</ul>
</li>
</ul>
<h4 id="Mixed-Collection"><a class="header-anchor" href="#Mixed-Collection">¶</a>Mixed Collection</h4>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/84fc3158676faf3bd95af8ce6411526d.png" alt=""></p>
<p>会对 E、S、O 进行全面垃圾回收</p>
<ul>
<li><strong>最终标记</strong>（<strong>也叫重新标记，Remark</strong>）：处于并发标记之后，并发标记时，也有用户线程，会产生垃圾，再进行一次重新标记，<strong>会 STW</strong></li>
<li><strong>拷贝存活（筛选回收）</strong>（Evacuation）：回收最不紧要的垃圾，拷贝最有价值的对象到新的老年区，这时旧的只有不仅要的垃圾用于回收 <strong>会STW</strong></li>
<li>-XX:MaxGCPauseMillis=ms：用于指定最长的停顿时间</li>
<li>局部是复制，整体是标记整理，没有碎片产生</li>
</ul>
<p><strong>为什么有的老年代被拷贝了，有的没拷贝？</strong></p>
<ul>
<li>例如下图只有两个红色的O复制到了一个新的黄色的O，其他旧的O并没有<strong>复制</strong>过去？</li>
</ul>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>选择回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p>
<ul>
<li>这样复制的次数和内存都少了，降低了回收的暂停停顿时间
<ul>
<li>复制一方面为了<strong>保留存活对象</strong></li>
<li>另一方面为了<strong>整理内存，减少碎片</strong></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/66085803ce7310c4f5a790453fc7eed2.png" alt=""></p>
<h3 id="垃圾回收器辨析"><a class="header-anchor" href="#垃圾回收器辨析">¶</a>垃圾回收器辨析</h3>
<h4 id="SerialGC"><a class="header-anchor" href="#SerialGC">¶</a>SerialGC</h4>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
<h4 id="ParallelGC"><a class="header-anchor" href="#ParallelGC">¶</a>ParallelGC</h4>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
<h4 id="CMS"><a class="header-anchor" href="#CMS">¶</a>CMS</h4>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足
<ul>
<li>CMS并发失败，老年代退化为串行时，才会触发一次Full GC</li>
</ul>
</li>
</ul>
<h4 id="G1-2"><a class="header-anchor" href="#G1-2">¶</a>G1</h4>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足
<ul>
<li>G1在老年代内存不足时（老年代所占内存超过阈值）
<ul>
<li>如果垃圾回收速度<strong>快于</strong>垃圾产生速度，<strong>不会触发</strong>Full GC，而是<strong>进行并发清理</strong></li>
<li>如果垃圾回收速度<strong>慢于</strong>垃圾产生速度，便<strong>会触发</strong>Full GC，为多线程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="新生代跨代引用"><a class="header-anchor" href="#新生代跨代引用">¶</a>新生代跨代引用</h3>
<p><strong>新生代回收的跨代引用（老年代引用新生代）问题？</strong></p>
<p>新生代回收垃圾对象过程：</p>
<ul>
<li>找到Root根对象，根对象进行可达性分析找到存活对象
<ul>
<li>根对象有一部分来自老年代，老年代的根对象非常多，遍历查找效率会很低</li>
<li>因此采用一种<strong>卡表CardTable</strong>技术，将老年代区域进行<strong>细分</strong>，每个Card大小为512B</li>
<li>老年代某个Card引用了新生代伊甸园对象，我们将其标记为<strong>脏卡</strong></li>
<li>因此我们找根对象可以直接找脏卡，减小搜索范围，提高效率</li>
<li>新生代会有 <strong>Remembered Set</strong> 来记录脏卡对自己的引用</li>
<li>如果对伊甸园做垃圾回收，可以直接通过 Remembered Set 找到老年代的根对象脏卡</li>
<li>通过脏卡根对象遍历Root，提高了效率</li>
</ul>
</li>
<li>存活对象复制到幸存区</li>
</ul>
<p><strong>名词：</strong></p>
<ul>
<li><strong>卡表</strong>：老年区划分为一个个Card，所有Card构成了CardTable</li>
<li>Remembered Set：记录脏卡对自己的引用</li>
<li>post-write barrier + dirty card queue：<strong>写屏障 + 脏卡队列</strong>
<ul>
<li>在脏卡对象引用变更时通过写屏障更新脏卡（异步）</li>
<li>脏卡不会立即更新，会先放到脏卡队列，将来使用一个线程去队列完成脏卡更新操作
<ul>
<li>concurrent refinement threads <strong>更新 Remembered Set</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/f123563089607b90b85bfab6216264f4.png" alt=""></p>
<h3 id="Remark"><a class="header-anchor" href="#Remark">¶</a>Remark</h3>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/84fc3158676faf3bd95af8ce6411526d.png" alt=""></p>
<p>Remark叫重新标记，也叫最终标记！</p>
<p><strong>并发标记阶段时，对象的处理状态：</strong></p>
<p>pre-write barrier + satb_mark_queue：写屏障 + 重新标记队列</p>
<ul>
<li>黑色：处理完毕，但有强引用指向，不会回收</li>
<li>灰色：正在处理，也有强引用，处理完也会变为黑色不会回收</li>
<li>白色：未处理，也有强引用，不会回收</li>
<li>单独的白色：被回收</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/ba9346c6b47661c4829002ea1c6d2bf7.png" alt=""></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 来自深入理解JVM</span><br><br>我们引入三色标记（Tri-color Marking）[<span class="hljs-number">1</span>]作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色：<br>·白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。<br>·黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。<br>·灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。<br><br>如果用户线程此时是冻结的，只有收集器线程在工作，那不会有任何问题。但如果用户线程与收集器是并发工作呢？收集器在对象图上标记颜色，同时用户线程在修改引用关系——即修改对象图的结构，这样可能出现两种后果。<br><br>一种是把原本消亡的对象错误标记为存活，这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。<br>另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误。<br>    <br>Wilson于<span class="hljs-number">1994</span>年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：<br>·赋值器插入了一条或多条从黑色对象到白色对象的新引用；<br>·赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。<br>因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别 <br><br>产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。<br><br>增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。<br><br>原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。<br><br>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。在HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现。<br></code></pre></td></tr></tbody></table></figure>
<p>来自深入理解JVM：</p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/fa3a5280ede2ed36fbd83e1b7e0b5b80.png" alt=""></p>
<p><strong>仍然是并发标记阶段</strong></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/2b5ce2f7c730dee0071a86e4b97e5496.png" alt=""></p>
<p><strong>并发标记过程中</strong></p>
<ul>
<li>由于用户线程和并发标记线程同时存在
<ul>
<li><strong>情况一</strong>：因此B和C可能由于用户线程的加入而断掉引用</li>
<li>由于此时C变为了孤立的白色，并发标记结束就会被回收掉</li>
<li><strong>情况二</strong>：用户线程改变了C的引用，指向了A</li>
<li>由于A被处理过了，因此并发标记过程不会再次处理到C</li>
<li>我们仍然认为C是垃圾，会在并发标记结束将其回收掉
<ul>
<li>但这里不对的，由于C有来自A的强引用，无法回收</li>
<li>因此需要对其进行<strong>重新标记</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>重新标记流程：</strong></p>
<ul>
<li>当C的引用发生改变时，JVM就会加入<strong>写屏障</strong>，该段代码就会执行</li>
<li><strong>写屏障</strong>：会将C加入队列，并将其变为灰色，表示未处理完</li>
<li>此时<strong>重新标记</strong>就会STW，暂停所有用户线程，从队列中进一步检查，发现是灰色的</li>
<li>则进行进一步处理，发现有强引用在引用，因此将其变为黑色，有强引用指向，不会被回收</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/15/92a58a8e455439f7fa8b680805cbb2ac.png" alt=""></p>
<h3 id="JDK-8U20字符串去重"><a class="header-anchor" href="#JDK-8U20字符串去重">¶</a>JDK 8U20字符串去重</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 字符串去重</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * -XX:+UseStringDeduplication （默认打开）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022-01-16 10:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// char[]{'h','e','l','l','o'}</span><br>        String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"hello"</span>); <span class="hljs-comment">// char[]{'h','e','l','l','o'}</span><br>        <span class="hljs-comment">// 只是char[]数组指向一致，s1和s2指向不一致</span><br>        System.out.println(s1 == s2); <span class="hljs-comment">// false</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>将所有新分配的字符串（char[]）放入一个队列</li>
<li>当新生代回收时，G1<strong>并发检查</strong>是否有字符串重复</li>
<li><strong>如果它们值一样，让它们引用同一个 char[]</strong></li>
<li>注意，与   String.intern() 不一样
<ul>
<li>String.intern() 关注的是字符串对象</li>
<li>而字符串去重关注的是 char[]</li>
<li>在 JVM 内部，使用了不同的字符串表</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：节省大量内存</p>
<p><strong>缺点</strong>：略微多占用了 cpu 时间，新生代回收时间略微增加</p>
<h3 id="JDK-8u40-并发标记类卸载"><a class="header-anchor" href="#JDK-8u40-并发标记类卸载">¶</a>JDK 8u40 并发标记类卸载</h3>
<p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个<strong>类加载器的所有类都不再使用</strong>，则<strong>卸载它所加载的所有类</strong></p>
<p>-XX:+ClassUnloadingWithConcurrentMark 默认启用</p>
<h3 id="JDK-8u60-回收巨型对象"><a class="header-anchor" href="#JDK-8u60-回收巨型对象">¶</a>JDK 8u60 回收巨型对象</h3>
<p><strong>巨型对象</strong> ：一个对象大于 region（相同大小的堆分区） 的一半时，称之为巨型对象</p>
<ul>
<li>不拷贝：G1 不会对巨型对象进行拷贝</li>
<li>优先回收：回收时被优先考虑</li>
<li>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉
<ul>
<li>当老年代的卡表不再引用巨型对象时，就会在新生代被回收</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/9cc15bb6f98e542991d3e15d405ce7be.png" alt=""></p>
<h3 id="JDK-9-并发标记起始时间的调整"><a class="header-anchor" href="#JDK-9-并发标记起始时间的调整">¶</a>JDK 9 并发标记起始时间的调整</h3>
<ul>
<li>并发标记必须在堆空间占满前完成，否则<strong>退化</strong>为 FullGC
<ul>
<li>如果垃圾回收速度<strong>慢于</strong>垃圾产生速度，便<strong>会触发</strong>Full GC，为多线程</li>
<li>Full GC 触发的 STW 时间更长，要尽可能避免
<ul>
<li>可以提前让并发标记，混合收集开始</li>
</ul>
</li>
</ul>
</li>
<li>JDK 9 之前需要使用   -XX:InitiatingHeapOccupancyPercent：老年代在堆内存的占比阈值，默认45%</li>
<li>JDK 9 可以动态调整
<ul>
<li>-XX:InitiatingHeapOccupancyPercent 用来设置<strong>初始值</strong></li>
<li>进行数据采样并<strong>动态调整</strong></li>
<li>总会添加一个安全的空档空间</li>
</ul>
</li>
</ul>
<h3 id="JDK-9-更高效的回收"><a class="header-anchor" href="#JDK-9-更高效的回收">¶</a>JDK 9 更高效的回收</h3>
<ul>
<li>250+增强</li>
<li>180+bug修复</li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.oracle.com/en/java/javase/12/gctuning">https://docs.oracle.com/en/java/javase/12/gctuning</a></li>
</ul>
<h2 id="5、垃圾回收器调优"><a class="header-anchor" href="#5、垃圾回收器调优">¶</a>5、垃圾回收器调优</h2>
<p>查看虚拟机参数命令：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java -XX:+PrintFlagsFinal -version | findstr <span class="hljs-string">"GC"</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="调优领域"><a class="header-anchor" href="#调优领域">¶</a>调优领域</h3>
<ul>
<li>内存</li>
<li>锁竞争</li>
<li>cpu 占用</li>
<li>io</li>
</ul>
<h3 id="确定目标"><a class="header-anchor" href="#确定目标">¶</a>确定目标</h3>
<p>低延迟/高吞吐量？ 选择合适的GC</p>
<ul>
<li>低延迟、响应时间优先：CMS G1 ZGC（jdk12使用）</li>
<li>高吞吐量：ParallelGC</li>
<li>Zing（据说零延迟。。。）</li>
</ul>
<h3 id="最快的GC是不发生GC"><a class="header-anchor" href="#最快的GC是不发生GC">¶</a>最快的GC是不发生GC</h3>
<p>首先排除减少因为自身编写的代码而引发的内存问题</p>
<ul>
<li>查看Full GC前后的内存占用，考虑以下几个问题
<ul>
<li>数据是不是太多？
<ul>
<li>数据库查表将整张表加入内存</li>
</ul>
</li>
<li>数据表示是否太臃肿
<ul>
<li>对象图</li>
<li>对象大小
<ul>
<li>包装类型占用内存大于基本类型</li>
</ul>
</li>
</ul>
</li>
<li>是否存在内存泄漏
<ul>
<li>不使用本地静态Map作为缓存，可能会内存泄露</li>
<li>可以使用软引用和弱引用，在内存吃紧时进行一次GC</li>
<li>使用第三方缓存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="新生代调优"><a class="header-anchor" href="#新生代调优">¶</a>新生代调优</h3>
<ul>
<li><strong>新生代的特点</strong>
<ul>
<li>所有的new操作分配内存都是非常廉价的
<ul>
<li>TLAB：thread-local allocation buﬀer，线程局部本地分配缓存区</li>
<li>TLAB可以保证线程内存分配时的并发安全，仅在自身线程缓存区内进行再分配</li>
</ul>
</li>
<li>死亡对象回收零代价
<ul>
<li>伊甸园和幸存区From复制到幸存区To，则伊甸园和幸存区From的垃圾就可以零代价回收掉</li>
</ul>
</li>
<li>大部分对象用过即死（朝生夕死）</li>
<li>MInor GC 所用时间远小于Full GC</li>
</ul>
</li>
<li><strong>新生代内存越大越好么？</strong>
<ul>
<li>参数：-Xmn</li>
<li><strong>不是</strong>
<ul>
<li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li>
</ul>
</li>
<li>新生代内存设置为内容纳**[并发量*(请求+响应)]**的数据为宜</li>
</ul>
</li>
</ul>
<h3 id="幸存区调优"><a class="header-anchor" href="#幸存区调优">¶</a>幸存区调优</h3>
<ul>
<li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升
<ul>
<li>-XX:MaxTenuringThreshold=threshold</li>
<li>-XX:+PrintTenuringDistribution：显示晋升详细信息</li>
</ul>
</li>
</ul>
<h3 id="老年代调优"><a class="header-anchor" href="#老年代调优">¶</a>老年代调优</h3>
<p>以 CMS 为例</p>
<ul>
<li>CMS 的老年代内存越大越好</li>
<li>先尝试不做调优，先尝试调优新生代</li>
<li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3
<ul>
<li>-XX:CMSInitiatingOccupancyFraction=percent：老年代占用达到多少进行Full GC</li>
<li>一般设置为75%-80%</li>
</ul>
</li>
</ul>
<h3 id="案例"><a class="header-anchor" href="#案例">¶</a>案例</h3>
<ul>
<li>案例1 Full GC 和 Minor GC频繁
<ul>
<li>新生代空间小，幸存区小，更快进入老年区，Full GC 频繁</li>
<li>解决：增大新生代和老年代内存空间，提高晋升阈值</li>
</ul>
</li>
<li>案例2 请求高峰期发生 Full GC，单次暂停时间特别长  （<strong>CMS</strong>）
<ul>
<li>业务要求低延迟，响应时间，选择了CMS</li>
<li>CMS并发标记最慢，业务高峰期新生代对象比较多，重新扫描一次就会很费时间，单词暂停时间特别长</li>
<li>解决：在并发标记前先进行一次Minor GC 减轻扫描压力</li>
</ul>
</li>
<li>案例3 老年代充裕情况下，发生 Full GC （<strong>CMS jdk1.7</strong>）
<ul>
<li>jdk1.7方法区实现为永久代，1.8位元空间</li>
<li>永久代空间不足也会导致Full GC</li>
<li>元空间内存则不是有Java控制了，使用的是操作系统，空间充裕，一般不会发生GC</li>
<li>解决：增大永久代内存</li>
</ul>
</li>
</ul>
<h1 id="四、类加载与字节码"><a class="header-anchor" href="#四、类加载与字节码">¶</a>四、类加载与字节码</h1>
<h2 id="1、类文件结构"><a class="header-anchor" href="#1、类文件结构">¶</a>1、类文件结构</h2>
<h3 id="简介-4"><a class="header-anchor" href="#简介-4">¶</a>简介</h3>
<p>一个简单的 HelloWorld.java</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t5; <br><span class="hljs-comment">// HelloWorld 示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        System.out.println(<span class="hljs-string">"hello world"</span>); <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>执行 <code>javac -parameters -d . HellowWorld.java</code></p>
<p>编译为 HelloWorld.class 后是这个样子的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">[root@localhost ~]# od -t xC HelloWorld.class<br><span class="hljs-number">0000000</span> ca fe ba be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">34</span> <span class="hljs-number">00</span> <span class="hljs-number">23</span> 0a <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> 09<br><span class="hljs-number">0000020</span> <span class="hljs-number">00</span> <span class="hljs-number">16</span> <span class="hljs-number">00</span> <span class="hljs-number">17</span> 08 <span class="hljs-number">00</span> <span class="hljs-number">18</span> 0a <span class="hljs-number">00</span> <span class="hljs-number">19</span> <span class="hljs-number">00</span> 1a <span class="hljs-number">07</span> <span class="hljs-number">00</span> 1b <span class="hljs-number">07</span><br><span class="hljs-number">0000040</span> <span class="hljs-number">00</span> 1c <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> 3c <span class="hljs-number">69</span> 6e <span class="hljs-number">69</span> <span class="hljs-number">74</span> 3e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">28</span> <span class="hljs-number">29</span><br><span class="hljs-number">0000060</span> <span class="hljs-number">56</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">43</span> <span class="hljs-number">6f</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0f</span> 4c <span class="hljs-number">69</span> 6e <span class="hljs-number">65</span> 4e<br><span class="hljs-number">0000100</span> <span class="hljs-number">75</span> <span class="hljs-number">6d</span> <span class="hljs-number">62</span> <span class="hljs-number">65</span> <span class="hljs-number">72</span> <span class="hljs-number">54</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> 6c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> 4c <span class="hljs-number">6f</span> <span class="hljs-number">63</span><br><span class="hljs-number">0000120</span> <span class="hljs-number">61</span> 6c <span class="hljs-number">56</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> 6c <span class="hljs-number">65</span> <span class="hljs-number">54</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> 6c <span class="hljs-number">65</span> <span class="hljs-number">01</span><br><span class="hljs-number">0000140</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">69</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">1d</span> 4c <span class="hljs-number">63</span> 6e <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">63</span><br><span class="hljs-number">0000160</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">2f</span> 6a <span class="hljs-number">76</span> <span class="hljs-number">6d</span> <span class="hljs-number">2f</span> <span class="hljs-number">74</span> <span class="hljs-number">35</span> <span class="hljs-number">2f</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> 6c 6c <span class="hljs-number">6f</span><br><span class="hljs-number">0000200</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> 6c <span class="hljs-number">64</span> 3b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">6d</span> <span class="hljs-number">61</span> <span class="hljs-number">69</span> 6e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">16</span><br><span class="hljs-number">0000220</span> <span class="hljs-number">28</span> 5b 4c 6a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> 6c <span class="hljs-number">61</span> 6e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span><br><span class="hljs-number">0000240</span> <span class="hljs-number">69</span> 6e <span class="hljs-number">67</span> 3b <span class="hljs-number">29</span> <span class="hljs-number">56</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">67</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span><br><span class="hljs-number">0000260</span> 5b 4c 6a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> 6c <span class="hljs-number">61</span> 6e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span><br><span class="hljs-number">0000300</span> 6e <span class="hljs-number">67</span> 3b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">4d</span> <span class="hljs-number">65</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">6f</span> <span class="hljs-number">64</span> <span class="hljs-number">50</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">61</span><br><span class="hljs-number">0000320</span> <span class="hljs-number">6d</span> <span class="hljs-number">65</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">72</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> 0a <span class="hljs-number">53</span> <span class="hljs-number">6f</span> <span class="hljs-number">75</span> <span class="hljs-number">72</span> <span class="hljs-number">63</span> <span class="hljs-number">65</span> <span class="hljs-number">46</span><br><span class="hljs-number">0000340</span> <span class="hljs-number">69</span> 6c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0f</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> 6c 6c <span class="hljs-number">6f</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> 6c <span class="hljs-number">64</span><br><span class="hljs-number">0000360</span> 2e 6a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> 0c <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> 08 <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">1d</span> 0c <span class="hljs-number">00</span> 1e<br><span class="hljs-number">0000400</span> <span class="hljs-number">00</span> <span class="hljs-number">1f</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> 0b <span class="hljs-number">68</span> <span class="hljs-number">65</span> 6c 6c <span class="hljs-number">6f</span> <span class="hljs-number">20</span> <span class="hljs-number">77</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> 6c <span class="hljs-number">64</span><br><span class="hljs-number">0000420</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">20</span> 0c <span class="hljs-number">00</span> <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">22</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> 1b <span class="hljs-number">63</span> 6e <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">74</span><br><span class="hljs-number">0000440</span> <span class="hljs-number">63</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">2f</span> 6a <span class="hljs-number">76</span> <span class="hljs-number">6d</span> <span class="hljs-number">2f</span> <span class="hljs-number">74</span> <span class="hljs-number">35</span> <span class="hljs-number">2f</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> 6c 6c<br><span class="hljs-number">0000460</span> <span class="hljs-number">6f</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> 6c <span class="hljs-number">64</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> 6a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> 6c <span class="hljs-number">61</span><br><span class="hljs-number">0000500</span> 6e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">4f</span> <span class="hljs-number">62</span> 6a <span class="hljs-number">65</span> <span class="hljs-number">63</span> <span class="hljs-number">74</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> 6a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span><br><span class="hljs-number">0000520</span> <span class="hljs-number">2f</span> 6c <span class="hljs-number">61</span> 6e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">79</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">6d</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">6f</span><br><span class="hljs-number">0000540</span> <span class="hljs-number">75</span> <span class="hljs-number">74</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> 4c 6a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">6f</span> <span class="hljs-number">2f</span> <span class="hljs-number">50</span> <span class="hljs-number">72</span><br><span class="hljs-number">0000560</span> <span class="hljs-number">69</span> 6e <span class="hljs-number">74</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">61</span> <span class="hljs-number">6d</span> 3b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> 6a <span class="hljs-number">61</span> <span class="hljs-number">76</span><br><span class="hljs-number">0000600</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">6f</span> <span class="hljs-number">2f</span> <span class="hljs-number">50</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> 6e <span class="hljs-number">74</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">61</span> <span class="hljs-number">6d</span><br><span class="hljs-number">0000620</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">70</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> 6e <span class="hljs-number">74</span> 6c 6e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">28</span> 4c 6a<br><span class="hljs-number">0000640</span> <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> 6c <span class="hljs-number">61</span> 6e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> 6e <span class="hljs-number">67</span> 3b<br><span class="hljs-number">0000660</span> <span class="hljs-number">29</span> <span class="hljs-number">56</span> <span class="hljs-number">00</span> <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span><br><span class="hljs-number">0000700</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> 08 <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> 09 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">2f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span><br><span class="hljs-number">0000720</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> 2a b7 <span class="hljs-number">00</span> <span class="hljs-number">01</span> b1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> 0a <span class="hljs-number">00</span><br><span class="hljs-number">0000740</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> 0b <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> 0c <span class="hljs-number">00</span><br><span class="hljs-number">0000760</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> 0c <span class="hljs-number">00</span> <span class="hljs-number">0d</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> 09 <span class="hljs-number">00</span> 0e <span class="hljs-number">00</span><br><span class="hljs-number">0001000</span> <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> 09 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">37</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">0001020</span> 09 b2 <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">12</span> <span class="hljs-number">03</span> b6 <span class="hljs-number">00</span> <span class="hljs-number">04</span> b1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> 0a<br><span class="hljs-number">0001040</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> 0a <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> 08 <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> 0b<br><span class="hljs-number">0001060</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> 0c <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> 09 <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">0001100</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">00</span><br><span class="hljs-number">0001120</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">14</span><br></code></pre></td></tr></tbody></table></figure>
<p>根据 JVM 规范，<strong>类文件结构</strong>如下：</p>
<p>u4：表示字节顺序，前四个字节…依次类推</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassFile {<br>&nbsp;  u4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; magic;<br>&nbsp;  u2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minor_version;<br>&nbsp;  u2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; major_version;<br>&nbsp;  u2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constant_pool_count;<br>&nbsp;  cp_info &nbsp; &nbsp; &nbsp;  constant_pool[constant_pool_count-<span class="hljs-number">1</span>]; <br>&nbsp;  u2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; access_flags;<br>&nbsp;  u2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_class;<br>&nbsp;  u2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; super_class;<br>&nbsp;  u2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interfaces_count;<br>&nbsp;  u2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interfaces[interfaces_count]; <br>&nbsp;  u2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fields_count;<br>&nbsp;  field_info &nbsp; &nbsp; fields[fields_count]; <br>&nbsp;  u2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; methods_count;<br>&nbsp;  method_info &nbsp;  methods[methods_count]; <br>&nbsp;  u2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributes_count;<br>&nbsp;  attribute_info attributes[attributes_count]; <br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="魔数"><a class="header-anchor" href="#魔数">¶</a>魔数</h3>
<p>u4 magic</p>
<p>0 ~3 字节，表示它是否是【class】类型的文件</p>
<p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<h3 id="版本"><a class="header-anchor" href="#版本">¶</a>版本</h3>
<p>u2 minor_version;</p>
<p>u2 major_version;</p>
<p>4~7 字节，表示类的版本 00 34（52）  表示是 Java 8</p>
<p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p>
<p>34H = 52，代表JDK8</p>
<h3 id="常量池-2"><a class="header-anchor" href="#常量池-2">¶</a>常量池</h3>
<p>u2  constant_pool_count</p>
<p>8~9 字节，表示常量池长度，00 23 （35）  表示常量池有 #1~#34项，注意 #0 项不计入，也没有值</p>
<p>0000000 ca fe ba be 00 00 00 34 <strong>00 23</strong> 0a 00 06 00 15 09</p>
<p>简单来说：就是通过字节对应的信息去找常量表对应信息，后面就是：含义-长度-具体内存</p>
<p>具体查看官方文档！</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p>
<h3 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h3>
<ul>
<li>访问标识与继承信息</li>
<li>Field 信息</li>
<li>Method 信息</li>
<li>附加属性</li>
</ul>
<h2 id="2、字节码指令"><a class="header-anchor" href="#2、字节码指令">¶</a>2、字节码指令</h2>
<h3 id="JavaP工具"><a class="header-anchor" href="#JavaP工具">¶</a>JavaP工具</h3>
<p>自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javap -v 类名.class<br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java">❯ javap -v .\Demo3.class<br>Classfile /E:/IdeaProject/JVM/target/classes/com/itnxd/jvm/constant/Demo3.class<br>  Last modified <span class="hljs-number">2022</span>年<span class="hljs-number">1</span>月<span class="hljs-number">16</span>日; size <span class="hljs-number">564</span> bytes<br>  SHA-<span class="hljs-number">256</span> checksum 1b57bc932cf3e94ddf755cdddc124232bb98f8a3ef47554d17aa5717564b78fc<br>  Compiled from <span class="hljs-string">"Demo3.java"</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">itnxd</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">constant</span>.<span class="hljs-title">Demo3</span></span><br>  minor version: 0<br>  major version: <span class="hljs-number">52</span> <span class="hljs-comment">// JDK8</span><br>  flags: (<span class="hljs-number">0x0021</span>) ACC_PUBLIC, ACC_SUPER <span class="hljs-comment">// 类访问修饰符 public</span><br>  this_class: #5                          // com/itnxd/jvm/constant/Demo3<br>  super_class: #6                         // java/lang/Object<br>  interfaces: <span class="hljs-number">0</span>, fields: <span class="hljs-number">0</span>, methods: <span class="hljs-number">2</span>, attributes: <span class="hljs-number">1</span><br>Constant pool: <span class="hljs-comment">// 常量池</span><br>   #1 = Methodref          #6.#20         // java/lang/Object."&lt;init&gt;":()V<br>   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;<br>   #3 = String             #23            // hello world<br>   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V<br>   #5 = Class              #26            // com/itnxd/jvm/constant/Demo3<br>   #6 = Class              #27            // java/lang/Object<br>   #7 = Utf8               &lt;init&gt;<br>   #8 = Utf8               ()V<br>   #9 = Utf8               Code<br>  #10 = Utf8               LineNumberTable<br>  #11 = Utf8               LocalVariableTable<br>  #12 = Utf8               this<br>  #13 = Utf8               Lcom/itnxd/jvm/constant/Demo3;<br>  #14 = Utf8               main<br>  #15 = Utf8               ([Ljava/lang/String;)V<br>  #16 = Utf8               args<br>  #17 = Utf8               [Ljava/lang/String;<br>  #18 = Utf8               SourceFile<br>  #19 = Utf8               Demo3.java<br>  #20 = NameAndType        #7:#8          // "&lt;init&gt;":()V<br>  #21 = Class              #28            // java/lang/System<br>  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;<br>  #23 = Utf8               hello world<br>  #24 = Class              #31            // java/io/PrintStream<br>  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V<br>  #26 = Utf8               com/itnxd/jvm/constant/Demo3<br>  #27 = Utf8               java/lang/Object<br>  #28 = Utf8               java/lang/System<br>  #29 = Utf8               out<br>  #30 = Utf8               Ljava/io/PrintStream;<br>  #31 = Utf8               java/io/PrintStream<br>  #32 = Utf8               println<br>  #33 = Utf8               (Ljava/lang/String;)V<br> <br><span class="hljs-comment">// 方法信息</span><br>{<br>  <span class="hljs-comment">// 构造方法</span><br>  <span class="hljs-keyword">public</span> com.itnxd.jvm.constant.Demo3();<br>    descriptor: ()V <span class="hljs-comment">// 空参</span><br>    flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC <span class="hljs-comment">// 访问修饰符 public</span><br>    <span class="hljs-comment">// 代码段</span><br>    Code:<br>      <span class="hljs-comment">// 栈深度，局部变量表大小，参数个数</span><br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-comment">// 0 1 4 代表字节码文件的行号</span><br>         <span class="hljs-number">0</span>: aload_0<br>         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V<br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      <span class="hljs-comment">// 行号表</span><br>      LineNumberTable:<br>    	<span class="hljs-comment">// java文件行号 字节码行号</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">0</span><br>      <span class="hljs-comment">// 本地变量表</span><br>      LocalVariableTable:<br>        <span class="hljs-comment">// 5行字节码 slot 槽位号 局部变量名this 类型 Demo3</span><br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/itnxd/jvm/constant/Demo3;<br><br>  <span class="hljs-comment">// 主方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    descriptor: ([Ljava/lang/String;)V <span class="hljs-comment">// 参数字符串数组</span><br>    flags: (<span class="hljs-number">0x0009</span>) ACC_PUBLIC, ACC_STATIC <span class="hljs-comment">// 访问修饰符 public static</span><br>    Code:<br>      <span class="hljs-comment">// 栈深度，局部变量表大小，参数个数</span><br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>         3: ldc           #3                  // String hello world<br>         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>      <span class="hljs-comment">// 行号表</span><br>      LineNumberTable:<br>        <span class="hljs-comment">// java文件行号 字节码行号</span><br>        line <span class="hljs-number">14</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">15</span>: <span class="hljs-number">8</span><br>      <span class="hljs-comment">// 本地变量表</span><br>      LocalVariableTable:<br>        <span class="hljs-comment">// 9行字节码 slot 槽位号 局部变量名args 类型 String</span><br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>}<br>SourceFile: <span class="hljs-string">"Demo3.java"</span><br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="图解方法执行流程"><a class="header-anchor" href="#图解方法执行流程">¶</a>图解方法执行流程</h3>
<h4 id="原始Java代码"><a class="header-anchor" href="#原始Java代码">¶</a>原始Java代码</h4>
<ul>
<li>a和字节码指令存储在一起，寄存器中（由于缓存了-128-127）</li>
<li>b存储在运行时常量池</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span> </span>{    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{        <br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;        <br>        <span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;        <br>        <span class="hljs-keyword">int</span> c = a + b;        <br>        System.out.println(c);   <br>    } <br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="编译后的字节码文件"><a class="header-anchor" href="#编译后的字节码文件">¶</a>编译后的字节码文件</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java">❯ javap -v .\Demo3.class<br>Classfile /E:/IdeaProject/JVM/target/classes/com/itnxd/jvm/constant/Demo3.class<br>  Last modified <span class="hljs-number">2022</span>年<span class="hljs-number">1</span>月<span class="hljs-number">16</span>日; size <span class="hljs-number">623</span> bytes<br>  SHA-<span class="hljs-number">256</span> checksum 6659bf5f03d9bff0a1aa9e3c1ace941ac1be502fb0df539ec7eccb3123a65a01<br>  Compiled from <span class="hljs-string">"Demo3.java"</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">itnxd</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">constant</span>.<span class="hljs-title">Demo3</span></span><br>  minor version: 0<br>  major version: <span class="hljs-number">52</span><br>  flags: (<span class="hljs-number">0x0021</span>) ACC_PUBLIC, ACC_SUPER<br>  this_class: #6                          // com/itnxd/jvm/constant/Demo3<br>  super_class: #7                         // java/lang/Object<br>  interfaces: <span class="hljs-number">0</span>, fields: <span class="hljs-number">0</span>, methods: <span class="hljs-number">2</span>, attributes: <span class="hljs-number">1</span><br>Constant pool:<br>   #1 = Methodref          #7.#25         // java/lang/Object."&lt;init&gt;":()V<br>   #2 = Class              #26            // java/lang/Short<br>   #3 = Integer            32768<br>   #4 = Fieldref           #27.#28        // java/lang/System.out:Ljava/io/PrintStream;<br>   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(I)V<br>   #6 = Class              #31            // com/itnxd/jvm/constant/Demo3<br>   #7 = Class              #32            // java/lang/Object<br>   #8 = Utf8               &lt;init&gt;<br>   #9 = Utf8               ()V<br>  #10 = Utf8               Code<br>  #11 = Utf8               LineNumberTable<br>  #12 = Utf8               LocalVariableTable<br>  #13 = Utf8               this<br>  #14 = Utf8               Lcom/itnxd/jvm/constant/Demo3;<br>  #15 = Utf8               main<br>  #16 = Utf8               ([Ljava/lang/String;)V<br>  #17 = Utf8               args<br>  #18 = Utf8               [Ljava/lang/String;<br>  #19 = Utf8               a<br>  #20 = Utf8               I<br>  #21 = Utf8               b<br>  #22 = Utf8               c<br>  #23 = Utf8               SourceFile<br>  #24 = Utf8               Demo3.java<br>  #25 = NameAndType        #8:#9          // "&lt;init&gt;":()V<br>  #26 = Utf8               java/lang/Short<br>  #27 = Class              #33            // java/lang/System<br>  #28 = NameAndType        #34:#35        // out:Ljava/io/PrintStream;<br>  #29 = Class              #36            // java/io/PrintStream<br>  #30 = NameAndType        #37:#38        // println:(I)V<br>  #31 = Utf8               com/itnxd/jvm/constant/Demo3<br>  #32 = Utf8               java/lang/Object<br>  #33 = Utf8               java/lang/System<br>  #34 = Utf8               out<br>  #35 = Utf8               Ljava/io/PrintStream;<br>  #36 = Utf8               java/io/PrintStream<br>  #37 = Utf8               println<br>  #38 = Utf8               (I)V<br>{<br>  <span class="hljs-keyword">public</span> com.itnxd.jvm.constant.Demo3();<br>    descriptor: ()V<br>    flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V<br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">11</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/itnxd/jvm/constant/Demo3;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: (<span class="hljs-number">0x0009</span>) ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>         <span class="hljs-number">2</span>: istore_1<br>         3: ldc           #3                  // int 32768<br>         <span class="hljs-number">5</span>: istore_2<br>         <span class="hljs-number">6</span>: iload_1<br>         <span class="hljs-number">7</span>: iload_2<br>         <span class="hljs-number">8</span>: iadd<br>         <span class="hljs-number">9</span>: istore_3<br>        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>        <span class="hljs-number">13</span>: iload_3<br>        14: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V<br>        <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">14</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">15</span>: <span class="hljs-number">3</span><br>        line <span class="hljs-number">16</span>: <span class="hljs-number">6</span><br>        line <span class="hljs-number">17</span>: <span class="hljs-number">10</span><br>        line <span class="hljs-number">18</span>: <span class="hljs-number">17</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">18</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">3</span>      <span class="hljs-number">15</span>     <span class="hljs-number">1</span>     a   I<br>            <span class="hljs-number">6</span>      <span class="hljs-number">12</span>     <span class="hljs-number">2</span>     b   I<br>           <span class="hljs-number">10</span>       <span class="hljs-number">8</span>     <span class="hljs-number">3</span>     c   I<br>}<br>SourceFile: <span class="hljs-string">"Demo3.java"</span><br><br></code></pre></td></tr></tbody></table></figure>
<h4 id="常量池载入运行时常量池"><a class="header-anchor" href="#常量池载入运行时常量池">¶</a>常量池载入运行时常量池</h4>
<p>运行时常量池应该在方法区，由于特殊拎了出来！</p>
<p>Class常量池载入运行时常量池</p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/907fb88366a8a9e5b3973188f3550880.png" alt=""></p>
<h4 id="方法字节码载入方法区"><a class="header-anchor" href="#方法字节码载入方法区">¶</a>方法字节码载入方法区</h4>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/22b33d00055b1233e8584cd636eb991f.png" alt=""></p>
<h4 id="main-线程开始运行，分配栈帧内存"><a class="header-anchor" href="#main-线程开始运行，分配栈帧内存">¶</a>main 线程开始运行，分配栈帧内存</h4>
<p>（stack=2，locals=4）对应操作数栈有 2 个空间（每个空间 4 个字节），局部变量表中有 4 个槽位。</p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/a24878c0214d42b6c8e2f8e45d304b21.png" alt=""></p>
<h4 id="执行引擎开始执行字节码"><a class="header-anchor" href="#执行引擎开始执行字节码">¶</a>执行引擎开始执行字节码</h4>
<p><strong>bipush 10</strong></p>
<ul>
<li><strong>将一个 byte 压入操作数栈</strong>（其长度会<strong>补齐</strong> 4 个字节），类似的指令还有</li>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（分<strong>两次</strong>压入，因为 long 是 8 个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/ce55ea80e0e599bc1d9a3a5f37d4f575.png" alt=""></p>
<p><strong>istore_1</strong></p>
<ul>
<li>将操作数栈顶数据弹出，存入局部变量表的 slot 1</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/1e43aa67463a8bc063a0dbe412804350.png" alt=""></p>
<p><strong>ldc #3</strong></p>
<ul>
<li>从常量池加载 #3 数据到操作数栈</li>
<li>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/cba0e0085749e323aac079f4502254fa.png" alt=""></p>
<p><strong>istore_2</strong></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/9945b5e47765d16f49f87d222ba712c8.png" alt=""></p>
<p><strong>iload_1</strong></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/8995dd4238018a336d42dee081072b37.png" alt=""></p>
<p><strong>iload_2</strong></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/6a79a8666eee3fb93720b3e7622ac409.png" alt=""></p>
<p><strong>iadd</strong></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/d74b123fe1fa08cacd8dcc7f1b4bbd93.png" alt=""></p>
<p><strong>istore_3</strong></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/b70bfceec9f1c707f367d93561df5fa0.png" alt=""></p>
<p><strong>getstatic #4</strong></p>
<ul>
<li>在运行时常量池中找到#4，发现是一个对象</li>
<li>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/241e1cbad891fa4450d541d3b199733a.png" alt=""></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/0865a5ae1d18ec4046a102f858587d42.png" alt=""></p>
<p><strong>iload_3</strong></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/890f9a7876cee187802fd2b086258504.png" alt=""></p>
<p><strong>invokevirtual #5</strong></p>
<ul>
<li>找到常量池 #5 项</li>
<li>定位到方法区   java/io/PrintStream.println:(I)V 方法</li>
<li>生成新的栈帧（分配 locals、stack等）</li>
<li>传递参数，执行新栈帧中的字节码</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/421289d6891a8d646aa3c45d30a083d2.png" alt=""></p>
<ul>
<li>执行完毕，弹出栈帧</li>
<li>清除 main 操作数栈内容</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/63211caa2df2267bc969326165be80b6.png" alt=""></p>
<p><strong>return</strong></p>
<ul>
<li>完成 main 方法调用，<strong>弹出 main 栈帧</strong></li>
<li>程序结束</li>
</ul>
<h3 id="字节码分析a"><a class="header-anchor" href="#字节码分析a">¶</a>字节码分析a++</h3>
<ul>
<li><strong>注意 iinc 指令是直接在局部变量 slot 上进行运算</strong></li>
<li><strong>a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc</strong></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 从字节码角度分析       a++  相关题目 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_2</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">int</span> b = a++ + ++a + a--; <br>        System.out.println(a); <span class="hljs-comment">// 11</span><br>        System.out.println(b); <span class="hljs-comment">// 34</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>对应字节码：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>       <span class="hljs-number">2</span>: istore_1 <span class="hljs-comment">// 存到slot1</span><br>       <span class="hljs-number">3</span>: iload_1 <span class="hljs-comment">// 加载slot1的a到操作数栈 此时slot1的a=10仍然存在</span><br>       <span class="hljs-number">4</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <span class="hljs-comment">// 对slot1执行自增1 a++ </span><br>       <span class="hljs-number">7</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <span class="hljs-comment">// 对slot1执行增增1 ++a</span><br>      <span class="hljs-number">10</span>: iload_1 <span class="hljs-comment">// 加载slot1的a=12到操作数栈</span><br>      <span class="hljs-number">11</span>: iadd <span class="hljs-comment">// 操作数栈中的10和12执行一次加法 22</span><br>      <span class="hljs-number">12</span>: iload_1 <span class="hljs-comment">// 加载slot1的a=12到操作数栈</span><br>      <span class="hljs-number">13</span>: iinc          <span class="hljs-number">1</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">// 对slot1的a执行减1 a = 11 </span><br>      <span class="hljs-number">16</span>: iadd <span class="hljs-comment">// 操作数栈的22和12执行一次加法 34</span><br>      <span class="hljs-number">17</span>: istore_2 <span class="hljs-comment">// 存储操作数栈中的34到slot2</span><br><br></code></pre></td></tr></tbody></table></figure>
<h3 id="条件判断指令"><a class="header-anchor" href="#条件判断指令">¶</a>条件判断指令</h3>
<p>几点说明：</p>
<ul>
<li>byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节</li>
<li>goto 用来进行跳转到指定行号的字节码</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/86eb6001dfce606f934b5cbe2fa11e3f.png" alt=""></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_3</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) { <br>            a = <span class="hljs-number">10</span>; <br>        } <span class="hljs-keyword">else</span> {<br>            a = <span class="hljs-number">20</span>; <br>        }<br>    } <br>}<br></code></pre></td></tr></tbody></table></figure>
<p>字节码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: iconst_0 <span class="hljs-comment">// -1 5之间使用iconst</span><br><span class="hljs-number">1</span>: istore_1<br><span class="hljs-number">2</span>: iload_1 &nbsp; &nbsp; &nbsp;<br><span class="hljs-number">3</span>: ifne &nbsp; &nbsp; &nbsp; &nbsp;  <span class="hljs-number">12</span> <span class="hljs-comment">// 条件判断指令，成立直接向下执行，不成立跳转到后面的行数12</span><br><span class="hljs-number">6</span>: bipush &nbsp; &nbsp; &nbsp;  <span class="hljs-number">10</span> <br><span class="hljs-number">8</span>: istore_1<br><span class="hljs-number">9</span>: goto &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">15</span> <span class="hljs-comment">// 跳出等于的逻辑</span><br><span class="hljs-number">12</span>: bipush &nbsp; &nbsp; &nbsp; <span class="hljs-number">20</span> <br><span class="hljs-number">14</span>: istore_1<br><span class="hljs-number">15</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="循环控制指令"><a class="header-anchor" href="#循环控制指令">¶</a>循环控制指令</h3>
<p>do while for类似！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_4</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (a &lt; <span class="hljs-number">10</span>) { <br>            a++;<br>        } <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>字节码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: iconst_0 <br><span class="hljs-number">1</span>: istore_1 <br><span class="hljs-number">2</span>: iload_1<br><span class="hljs-number">3</span>: bipush &nbsp; &nbsp; &nbsp;  <span class="hljs-number">10</span> <br><span class="hljs-number">5</span>: if_icmpge &nbsp; &nbsp; <span class="hljs-number">14</span> <br><span class="hljs-number">8</span>: iinc &nbsp; &nbsp; &nbsp; &nbsp;  <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <br><span class="hljs-number">11</span>: goto &nbsp; &nbsp; &nbsp; &nbsp;  <span class="hljs-number">2</span> <br><span class="hljs-number">14</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="小面试题"><a class="header-anchor" href="#小面试题">¶</a>小面试题</h3>
<p>很明显，每次赋值操作赋值的都是0，即最后是0！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_6_1</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) { <br>            x = x++;<br>            i++; <br>        }<br>        System.out.println(x); <span class="hljs-comment">// 结果是    0 </span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>字节码原理解释：</p>
<ul>
<li>x++的操作对应：iload iinc两条指令</li>
<li>第一步将x=0放入slot（局部变量表）</li>
<li>第二步执行iload，将0压入操作数栈</li>
<li>第三步执行iinc，在slot内进行自增</li>
<li>第四步执行赋值操作，将操作数栈的0把slot的1进行覆盖</li>
<li>因此：最终一定是0</li>
</ul>
<h3 id="构造方法"><a class="header-anchor" href="#构造方法">¶</a>构造方法</h3>
<h4 id="cinit"><a class="header-anchor" href="#cinit">¶</a>cinit</h4>
<p><code>&lt;cinit&gt;()V</code>：类构造方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_8_1</span> </span>{ <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>; <br>    <span class="hljs-keyword">static</span> {<br>        i = <span class="hljs-number">20</span>; <br>    }<br>    <span class="hljs-keyword">static</span> { <br>        i = <span class="hljs-number">30</span>; <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>编译器会按从上到下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 <code>&lt;cinit&gt;()V</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: bipush &nbsp; &nbsp; &nbsp;  <span class="hljs-number">10</span><br>2: putstatic &nbsp; &nbsp; #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // Field i:I <br><span class="hljs-number">5</span>: bipush &nbsp; &nbsp; &nbsp;  <span class="hljs-number">20</span><br>7: putstatic &nbsp; &nbsp; #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // Field i:I <br><span class="hljs-number">10</span>: bipush &nbsp; &nbsp; &nbsp;  <span class="hljs-number">30</span><br>12: putstatic &nbsp; &nbsp; #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // Field i:I <br><span class="hljs-number">15</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></tbody></table></figure>
<p><code>&lt;cinit&gt;()V</code> 方法会在类加载的初始化阶段被调用</p>
<p>练习<br>
同学们可以自己调整一下 static 变量和静态代码块的位置，观察字节码的改动</p>
<h4 id="init"><a class="header-anchor" href="#init">¶</a>init</h4>
<p><code>&lt;init&gt;()V</code>：对象构造方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_8_2</span> </span>{ <br>    <span class="hljs-keyword">private</span> String a = <span class="hljs-string">"s1"</span>; <br>    {<br>        b = <span class="hljs-number">20</span>; <br>    }<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>; <br>    {<br>        a = <span class="hljs-string">"s2"</span>; <br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo3_8_2</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>{ <br>        <span class="hljs-keyword">this</span>.a = a;<br>        <span class="hljs-keyword">this</span>.b = b; <br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        Demo3_8_2 d = <span class="hljs-keyword">new</span> Demo3_8_2(<span class="hljs-string">"s3"</span>, <span class="hljs-number">30</span>); <br>        System.out.println(d.a);<br>        System.out.println(d.b); <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但<strong>原始构造方法内的代码总是在最后</strong>！</p>
<p><strong>顺序：静态代码块、代码块、构造方法</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">{<br>  <span class="hljs-keyword">public</span> com.itnxd.jvm.constant.Demo3(java.lang.String, <span class="hljs-keyword">int</span>);<br>    descriptor: (Ljava/lang/String;I)V<br>    flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span><br>         <span class="hljs-number">0</span>: aload_0<br>         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V<br>         <span class="hljs-number">4</span>: aload_0<br>         5: ldc           #2                  // String s1<br>         7: putfield      #3                  // Field a:Ljava/lang/String;<br>        <span class="hljs-number">10</span>: aload_0<br>        <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span><br>        13: putfield      #4                  // Field b:I<br>        <span class="hljs-number">16</span>: aload_0<br>        <span class="hljs-number">17</span>: bipush        <span class="hljs-number">10</span><br>        19: putfield      #4                  // Field b:I<br>        <span class="hljs-number">22</span>: aload_0<br>        23: ldc           #5                  // String s2<br>        25: putfield      #3                  // Field a:Ljava/lang/String;<br>        <span class="hljs-comment">//原始构造方法在最后执行</span><br>        <span class="hljs-number">28</span>: aload_0<br>        <span class="hljs-number">29</span>: aload_1<br>        30: putfield      #3                  // Field a:Ljava/lang/String;<br>        <span class="hljs-number">33</span>: aload_0<br>        <span class="hljs-number">34</span>: iload_2<br>        35: putfield      #4                  // Field b:I<br>        <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">21</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">13</span>: <span class="hljs-number">4</span><br>        line <span class="hljs-number">15</span>: <span class="hljs-number">10</span><br>        line <span class="hljs-number">17</span>: <span class="hljs-number">16</span><br>        line <span class="hljs-number">19</span>: <span class="hljs-number">22</span><br>        line <span class="hljs-number">22</span>: <span class="hljs-number">28</span><br>        line <span class="hljs-number">23</span>: <span class="hljs-number">33</span><br>        line <span class="hljs-number">24</span>: <span class="hljs-number">38</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">39</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/itnxd/jvm/constant/Demo3;<br>            <span class="hljs-number">0</span>      <span class="hljs-number">39</span>     <span class="hljs-number">1</span>     a   Ljava/lang/String;<br>            <span class="hljs-number">0</span>      <span class="hljs-number">39</span>     <span class="hljs-number">2</span>     b   I<br></code></pre></td></tr></tbody></table></figure>
<h3 id="方法调用"><a class="header-anchor" href="#方法调用">¶</a>方法调用</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_9</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo3_9</span><span class="hljs-params">()</span> </span>{ }<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{ }<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>{ }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>{ }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>{ }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        Demo3_9 d = <span class="hljs-keyword">new</span> Demo3_9();<br>        d.test1();<br>        d.test2();<br>        d.test3();<br>        d.test4();<br>        Demo3_9.test4(); <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>字节码：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">0: new &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // class cn/itcast/jvm/t3/bytecode/Demo3_9 <br><span class="hljs-number">3</span>: dup<br>4: invokespecial #3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // Method "&lt;init&gt;":()V <br><span class="hljs-number">7</span>: astore_1<br><span class="hljs-number">8</span>: aload_1<br>9: invokespecial #4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // Method test1:()V <br><span class="hljs-number">12</span>: aload_1<br>13: invokespecial #5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // Method test2:()V <br><span class="hljs-number">16</span>: aload_1<br>17: invokevirtual #6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // Method test3:()V <br><span class="hljs-number">20</span>: aload_1<br><span class="hljs-number">21</span>: pop<br>22: invokestatic #7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Method test4:()V <br>25: invokestatic #7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Method test4:()V <br><span class="hljs-number">28</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></tbody></table></figure>
<p><strong>各方法区别？</strong></p>
<ul>
<li>私有、构造、被 final 修饰的方法，在调用时都使用 invokespecial 指令</li>
<li>普通成员方法在调用时，使用 invokevirtual 指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定（重写的问题）</li>
<li>静态方法在调用时使用 invokestatic 指令</li>
<li>invokespecial 和 invokestatic 的效率都要比 invokevirtual 高，<strong>静态绑定和动态绑定</strong></li>
</ul>
<p><strong>字节码详细解释：</strong></p>
<ul>
<li>new 是创建【对象】
<ul>
<li>给对象分配堆内存</li>
<li>执行成功会将【<strong>对象引用</strong>】压入操作数栈</li>
</ul>
</li>
<li>dup 是<strong>复制</strong>操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，
<ul>
<li>一个是要<strong>配合 invokespecial 调用该对象的构造方法</strong>   <code>&lt;init&gt;:()V</code> ，（会消耗掉栈顶一个引用），调用完成后从栈中清除</li>
<li><strong>另一个要配合 astore_1 赋值给局部变量或非static方法</strong></li>
</ul>
</li>
<li>最终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于<strong>静态绑定</strong></li>
<li>普通成员方法是由 <strong>invokevirtual</strong> 调用，属于<strong>动态绑定</strong>，即支持<strong>多态</strong></li>
<li><strong>成员方法与静态方法调用的另一个区别是，  执行方法前是否需要【对象引用】</strong></li>
<li>比较有意思的是   d.test4()：（<strong>对象调用类的静态方法 aload_1  pop 两条无意义指令</strong>）
<ul>
<li>是通过【对象引用】调用一个静态方法（<strong>静态方法不需要通过对象引用来调用，因此多了两条无意义指令</strong>）</li>
<li>可以看到在调用invokestatic 之前执行了 pop 指令</li>
<li>把【对象引用】从操作数栈弹掉了</li>
</ul>
</li>
<li>还有一个执行 invokespecial 的情况是通过 super 调用父类方法</li>
</ul>
<h3 id="多态原理"><a class="header-anchor" href="#多态原理">¶</a>多态原理</h3>
<p>当执行 invokevirtual 指令时：</p>
<ol>
<li>先通过栈帧中的对象引用找到对象</li>
<li>分析对象头，找到对象的实际 Class指针</li>
<li>Class 结构中有 <strong>vtable虚方法表</strong>（多态相关的，ﬁnal，static 不会列入）它在类加载的<strong>链接阶段</strong>就已经根据方法的重写规则生成好了</li>
<li>查表得到方法的具体地址</li>
<li>执行方法的字节码</li>
</ol>
<h3 id="异常处理"><a class="header-anchor" href="#异常处理">¶</a>异常处理</h3>
<h4 id="try-catch"><a class="header-anchor" href="#try-catch">¶</a>try-catch</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_1</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> {<br>            i = <span class="hljs-number">10</span>;<br>        } <span class="hljs-keyword">catch</span> (Exception e) { <br>            i = <span class="hljs-number">20</span>;<br>        } <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>字节码</strong></p>
<ul>
<li>可以看到多出来一个 <strong>Exception table （异常表）的结构</strong>，[from, to) 是<strong>前闭后开</strong>的检测范围</li>
<li>一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li>
<li>8 行的字节码指令 astore_2 是将<strong>异常对象引用</strong>存入<strong>局部变量表</strong>的 slot 2 位置</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: (<span class="hljs-number">0x0009</span>) ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: iconst_0<br>         <span class="hljs-number">1</span>: istore_1<br>         <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span><br>         <span class="hljs-number">4</span>: istore_1<br>         <span class="hljs-number">5</span>: goto          <span class="hljs-number">12</span> <span class="hljs-comment">// 不发生异常这里就直接return了</span><br>         <span class="hljs-number">8</span>: astore_2  <span class="hljs-comment">// 查看局部变量表slot发现存储的是Exception</span><br>         <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span><br>        <span class="hljs-number">11</span>: istore_1<br>        <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span><br>      <span class="hljs-comment">// 异常表</span><br>      Exception table:<br>         <span class="hljs-comment">// [2,5)，值上面的字节码行号</span><br>         from    to  target type<br>             <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/Exception<br>      LineNumberTable:<br>        line <span class="hljs-number">14</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">16</span>: <span class="hljs-number">2</span><br>        line <span class="hljs-number">19</span>: <span class="hljs-number">5</span><br>        line <span class="hljs-number">17</span>: <span class="hljs-number">8</span><br>        line <span class="hljs-number">18</span>: <span class="hljs-number">9</span><br>        line <span class="hljs-number">20</span>: <span class="hljs-number">12</span><br>      <span class="hljs-comment">// 局部变量表slot</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">9</span>       <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     e   Ljava/lang/Exception;<br>            <span class="hljs-number">0</span>      <span class="hljs-number">13</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">2</span>      <span class="hljs-number">11</span>     <span class="hljs-number">1</span>     i   I<br>      StackMapTable: number_of_entries = <span class="hljs-number">2</span><br>        frame_type = <span class="hljs-number">255</span> <span class="hljs-comment">/* full_frame */</span><br>          offset_delta = <span class="hljs-number">8</span><br>          locals = [ class "[Ljava/lang/String;", int ]<br>          stack = [ class java/lang/Exception ]<br>        frame_type = <span class="hljs-number">3</span> <span class="hljs-comment">/* same */</span><br>}<br>SourceFile: <span class="hljs-string">"Demo3.java"</span><br><br></code></pre></td></tr></tbody></table></figure>
<h4 id="多-single-catch-块的情况"><a class="header-anchor" href="#多-single-catch-块的情况">¶</a>多 single-catch 块的情况</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_2</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> {&nbsp;<br>            因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot <span class="hljs-number">2</span> 位置被共用<br>                multi-<span class="hljs-keyword">catch</span> 的情况<br>                    i = <span class="hljs-number">10</span>;<br>        } <span class="hljs-keyword">catch</span> (ArithmeticException e) { <br>            i = <span class="hljs-number">30</span>;<br>        } <span class="hljs-keyword">catch</span> (NullPointerException e) { <br>            i = <span class="hljs-number">40</span>;<br>        } <span class="hljs-keyword">catch</span> (Exception e) { <br>            i = <span class="hljs-number">50</span>;<br>        } <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>字节码：</strong></p>
<p>因为异常出现时，只能进入 Exception table 中<strong>一个分支</strong></p>
<ul>
<li><strong>局部变量表 slot 2 位置被共用</strong></li>
<li>但是起始位置不同，</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: (<span class="hljs-number">0x0009</span>) ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: iconst_0<br>         <span class="hljs-number">1</span>: istore_1<br>         <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span><br>         <span class="hljs-number">4</span>: istore_1<br>         <span class="hljs-number">5</span>: goto          <span class="hljs-number">26</span><br>         <span class="hljs-number">8</span>: astore_2<br>         <span class="hljs-number">9</span>: bipush        <span class="hljs-number">30</span><br>        <span class="hljs-number">11</span>: istore_1<br>        <span class="hljs-number">12</span>: goto          <span class="hljs-number">26</span><br>        <span class="hljs-number">15</span>: astore_2<br>        <span class="hljs-number">16</span>: bipush        <span class="hljs-number">40</span><br>        <span class="hljs-number">18</span>: istore_1<br>        <span class="hljs-number">19</span>: goto          <span class="hljs-number">26</span><br>        <span class="hljs-number">22</span>: astore_2<br>        <span class="hljs-number">23</span>: bipush        <span class="hljs-number">50</span><br>        <span class="hljs-number">25</span>: istore_1<br>        <span class="hljs-number">26</span>: <span class="hljs-keyword">return</span><br>      Exception table:<br>         from    to  target type<br>             <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/ArithmeticException<br>             <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">15</span>   Class java/lang/NullPointerException<br>             <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">22</span>   Class java/lang/Exception<br>      LineNumberTable:<br>        line <span class="hljs-number">14</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">16</span>: <span class="hljs-number">2</span><br>        line <span class="hljs-number">23</span>: <span class="hljs-number">5</span><br>        line <span class="hljs-number">17</span>: <span class="hljs-number">8</span><br>        line <span class="hljs-number">18</span>: <span class="hljs-number">9</span><br>        line <span class="hljs-number">23</span>: <span class="hljs-number">12</span><br>        line <span class="hljs-number">19</span>: <span class="hljs-number">15</span><br>        line <span class="hljs-number">20</span>: <span class="hljs-number">16</span><br>        line <span class="hljs-number">23</span>: <span class="hljs-number">19</span><br>        line <span class="hljs-number">21</span>: <span class="hljs-number">22</span><br>        line <span class="hljs-number">22</span>: <span class="hljs-number">23</span><br>        line <span class="hljs-number">24</span>: <span class="hljs-number">26</span><br>      <span class="hljs-comment">// 局部变量表被slot2被共用了，但是起始位置不同</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">9</span>       <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     e   Ljava/lang/ArithmeticException;<br>           <span class="hljs-number">16</span>       <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     e   Ljava/lang/NullPointerException;<br>           <span class="hljs-number">23</span>       <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     e   Ljava/lang/Exception;<br>            <span class="hljs-number">0</span>      <span class="hljs-number">27</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">2</span>      <span class="hljs-number">25</span>     <span class="hljs-number">1</span>     i   I<br>      StackMapTable: number_of_entries = <span class="hljs-number">4</span><br>        frame_type = <span class="hljs-number">255</span> <span class="hljs-comment">/* full_frame */</span><br>          offset_delta = <span class="hljs-number">8</span><br>          locals = [ class "[Ljava/lang/String;", int ]<br>          stack = [ class java/lang/ArithmeticException ]<br>        frame_type = <span class="hljs-number">70</span> <span class="hljs-comment">/* same_locals_1_stack_item */</span><br>          stack = [ class java/lang/NullPointerException ]<br>        frame_type = <span class="hljs-number">70</span> <span class="hljs-comment">/* same_locals_1_stack_item */</span><br>          stack = [ class java/lang/Exception ]<br>        frame_type = <span class="hljs-number">3</span> <span class="hljs-comment">/* same */</span><br>}<br>SourceFile: <span class="hljs-string">"Demo3.java"</span><br></code></pre></td></tr></tbody></table></figure>
<h4 id="multi-catch-的情况"><a class="header-anchor" href="#multi-catch-的情况">¶</a>multi-catch 的情况</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_3</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        <span class="hljs-keyword">try</span> {<br>            Method test = Demo3_11_3.class.getMethod(<span class="hljs-string">"test"</span>); <br>            test.invoke(<span class="hljs-keyword">null</span>);<br>        } <span class="hljs-keyword">catch</span> (NoSuchMethodException | IllegalAccessException | <br>                 InvocationTargetException e) {<br>            e.printStackTrace(); <br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{ <br>        System.out.println(<span class="hljs-string">"ok"</span>); <br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure>
<p>字节码，基本和上一种类似！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>  descriptor: ([Ljava/lang/String;)V<br>  flags: (<span class="hljs-number">0x0009</span>) ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>       0: ldc           #2                  // class com/itnxd/jvm/constant/Demo3<br>       2: ldc           #3                  // String test<br>       <span class="hljs-number">4</span>: iconst_0<br>       5: anewarray     #4                  // class java/lang/Class<br>       8: invokevirtual #5                  // Method java/lang/Class.getMethod:(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;<br>      <span class="hljs-number">11</span>: astore_1<br>      <span class="hljs-number">12</span>: aload_1<br>      <span class="hljs-number">13</span>: aconst_null<br>      <span class="hljs-number">14</span>: iconst_0<br>      15: anewarray     #6                  // class java/lang/Object<br>      18: invokevirtual #7                  // Method java/lang/reflect/Method.invoke:(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;<br>      <span class="hljs-number">21</span>: pop<br>      <span class="hljs-number">22</span>: goto          <span class="hljs-number">30</span><br>      <span class="hljs-number">25</span>: astore_1 <span class="hljs-comment">// 发生异常将异常对象存储到slot1</span><br>      <span class="hljs-number">26</span>: aload_1 <span class="hljs-comment">// 加载异常对象引用到操作数栈</span><br>      27: invokevirtual #11                 // Method java/lang/ReflectiveOperationException.printStackTrace:()V 执行异常对象方法<br>      <span class="hljs-number">30</span>: <span class="hljs-keyword">return</span><br>    Exception table:<br>       from    to  target type<br>           <span class="hljs-number">0</span>    <span class="hljs-number">22</span>    <span class="hljs-number">25</span>   Class java/lang/NoSuchMethodException<br>           <span class="hljs-number">0</span>    <span class="hljs-number">22</span>    <span class="hljs-number">25</span>   Class java/lang/IllegalAccessException<br>           <span class="hljs-number">0</span>    <span class="hljs-number">22</span>    <span class="hljs-number">25</span>   Class java/lang/reflect/InvocationTargetException<br>    LineNumberTable:<br>      line <span class="hljs-number">18</span>: <span class="hljs-number">0</span><br>      line <span class="hljs-number">19</span>: <span class="hljs-number">12</span><br>      line <span class="hljs-number">23</span>: <span class="hljs-number">22</span><br>      line <span class="hljs-number">20</span>: <span class="hljs-number">25</span><br>      line <span class="hljs-number">22</span>: <span class="hljs-number">26</span><br>      line <span class="hljs-number">24</span>: <span class="hljs-number">30</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>         <span class="hljs-number">12</span>      <span class="hljs-number">10</span>     <span class="hljs-number">1</span>  test   Ljava/lang/reflect/Method;<br>         <span class="hljs-number">26</span>       <span class="hljs-number">4</span>     <span class="hljs-number">1</span>     e   Ljava/lang/ReflectiveOperationException;<br>          <span class="hljs-number">0</span>      <span class="hljs-number">31</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br><br></code></pre></td></tr></tbody></table></figure>
<h4 id="ﬁnally"><a class="header-anchor" href="#ﬁnally">¶</a>ﬁnally</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_11_4</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> {<br>            i = <span class="hljs-number">10</span>;<br>        } <span class="hljs-keyword">catch</span> (Exception e) { <br>            i = <span class="hljs-number">20</span>;<br>        } <span class="hljs-keyword">finally</span> { <br>            i = <span class="hljs-number">30</span>; <br>        }<br>    } <br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>字节码：</strong></p>
<p>可以看到 ﬁnally 中的代码被复制了 3 份，分别放入</p>
<ul>
<li>try 流程</li>
<li>catch 流程</li>
<li>catch 剩余的异常类型流程</li>
</ul>
<p>当然，finally中的代码只会执行一次</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>; <br>&nbsp; &nbsp;descriptor: ([Ljava/lang/String;)V<br>&nbsp; &nbsp;flags: ACC_PUBLIC, ACC_STATIC <br>&nbsp; &nbsp;Code:<br>&nbsp; &nbsp; &nbsp;stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span> <br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">0</span>: iconst_0<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">1</span>: istore_1 &nbsp; &nbsp;        <span class="hljs-comment">// 0 -&gt; i</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">2</span>: bipush &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">10</span> &nbsp; &nbsp;<span class="hljs-comment">// try -------------------------------------- </span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">4</span>: istore_1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 10 -&gt; i &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | </span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">5</span>: bipush &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">30</span> &nbsp; &nbsp;<span class="hljs-comment">// finally &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | </span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">7</span>: istore_1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 30 -&gt; i &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | // 复制到try</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">8</span>: goto &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">27</span> &nbsp; &nbsp;<span class="hljs-comment">// return ----------------------------------- </span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">11</span>: astore_2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// catch Exceptin -&gt; e ---------------------- </span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">12</span>: bipush &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">20</span> &nbsp; &nbsp;<span class="hljs-comment">// &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | </span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">14</span>: istore_1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 20 -&gt; i &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | </span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">15</span>: bipush &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">30</span> &nbsp; &nbsp;<span class="hljs-comment">// finally &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | </span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">17</span>: istore_1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 30 -&gt; i &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |  // 复制到catch</span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">18</span>: goto &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">27</span> &nbsp; &nbsp;<span class="hljs-comment">// return ----------------------------------- </span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">21</span>: astore_3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// catch any -&gt; slot 3 ---------------------- </span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">22</span>: bipush &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">30</span> &nbsp; &nbsp;<span class="hljs-comment">// finally &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | </span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">24</span>: istore_1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 30 -&gt; i &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | // 复制到finally,即catch并没有捕获到异常</span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">25</span>: aload_3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// &lt;- slot 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | </span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">26</span>: athrow &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// throw ------------------------------------ // finally出现异常也会抛出</span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">27</span>: <span class="hljs-keyword">return</span><br>&nbsp; &nbsp; &nbsp;Exception table:<br>&nbsp; &nbsp; &nbsp; &nbsp; from &nbsp; &nbsp;to &nbsp;target type<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">2</span> &nbsp; &nbsp; <span class="hljs-number">5</span> &nbsp; &nbsp;<span class="hljs-number">11</span> &nbsp; Class java/lang/Exception<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">2</span> &nbsp; &nbsp; <span class="hljs-number">5</span> &nbsp; &nbsp;<span class="hljs-number">21</span> &nbsp; any &nbsp; &nbsp;<span class="hljs-comment">// 剩余的异常类型，比如 Error </span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">11</span> &nbsp; &nbsp;<span class="hljs-number">15</span> &nbsp; &nbsp;<span class="hljs-number">21</span> &nbsp; any &nbsp; &nbsp;<span class="hljs-comment">// 剩余的异常类型，比如 Error </span><br>&nbsp; &nbsp; &nbsp;LineNumberTable: ...<br>&nbsp; &nbsp; &nbsp;LocalVariableTable:<br>&nbsp; &nbsp; &nbsp; &nbsp;Start &nbsp;Length &nbsp;Slot &nbsp;Name &nbsp; Signature<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">12</span> &nbsp; &nbsp; &nbsp; <span class="hljs-number">3</span> &nbsp; &nbsp; <span class="hljs-number">2</span> &nbsp; &nbsp; e &nbsp; Ljava/lang/Exception; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">0</span> &nbsp; &nbsp; &nbsp;<span class="hljs-number">28</span> &nbsp; &nbsp; <span class="hljs-number">0</span> &nbsp;args &nbsp; [Ljava/lang/String; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">2</span> &nbsp; &nbsp; &nbsp;<span class="hljs-number">26</span> &nbsp; &nbsp; <span class="hljs-number">1</span> &nbsp; &nbsp; i &nbsp; I<br>&nbsp; &nbsp; &nbsp;StackMapTable: ... <br>&nbsp; &nbsp;MethodParameters: ...<br></code></pre></td></tr></tbody></table></figure>
<h3 id="ﬁnally-面试题"><a class="header-anchor" href="#ﬁnally-面试题">¶</a>ﬁnally 面试题</h3>
<h4 id="finally-中的-return"><a class="header-anchor" href="#finally-中的-return">¶</a>finally 中的 return</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_12_2</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        <span class="hljs-keyword">int</span> result = test();<br>        System.out.println(result);  <span class="hljs-comment">// 20</span><br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{ <br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>; <br>        } <span class="hljs-keyword">finally</span> { <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>; <br>        }<br>    } <br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>字节码：</strong></p>
<ul>
<li>由于 ﬁnally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 ﬁnally 的为准</li>
<li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li>
<li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow</strong> 了，这告诉我们：
<ul>
<li><strong>如果在 ﬁnally 中出现了 return，会吞掉异常</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>; <br>&nbsp; &nbsp;descriptor: ()I<br>&nbsp; &nbsp;flags: ACC_PUBLIC, ACC_STATIC <br>&nbsp; &nbsp;Code:<br>&nbsp; &nbsp; &nbsp;stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">0</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">0</span>: bipush &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">10</span> &nbsp; &nbsp;<span class="hljs-comment">// &lt;- 10 放入栈顶</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">2</span>: istore_0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 10 -&gt; slot 0 (从栈顶移除了) </span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">3</span>: bipush &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">20</span> &nbsp; &nbsp;<span class="hljs-comment">// &lt;- 20 放入栈顶</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">5</span>: ireturn &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 返回栈顶    int(20)</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">6</span>: astore_1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// catch any -&gt; slot 1 </span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">7</span>: bipush &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">20</span> &nbsp; &nbsp;<span class="hljs-comment">// &lt;- 20 放入栈顶</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">9</span>: ireturn &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 返回栈顶    int(20) </span><br>&nbsp; &nbsp; &nbsp;Exception table:<br>&nbsp; &nbsp; &nbsp; &nbsp; from &nbsp; &nbsp;to &nbsp;target type <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">0</span> &nbsp; &nbsp; <span class="hljs-number">3</span> &nbsp; &nbsp; <span class="hljs-number">6</span> &nbsp; any <br>&nbsp; &nbsp; &nbsp;LineNumberTable: ...<br>&nbsp; &nbsp; &nbsp;StackMapTable: ...<br></code></pre></td></tr></tbody></table></figure>
<p><strong>例如下面这个例子：虽然有除零异常，但并不会抛出异常，而是会正常返回！</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_12_1</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        <span class="hljs-keyword">int</span> result = test();<br>        System.out.println(result); <br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{ <br>        <span class="hljs-keyword">try</span> {&nbsp;<br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>; <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>; <br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>; <br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="ﬁnally-对返回值影响"><a class="header-anchor" href="#ﬁnally-对返回值影响">¶</a>ﬁnally 对返回值影响</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_12_2</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        <span class="hljs-keyword">int</span> result = test();<br>        System.out.println(result); <span class="hljs-comment">// 10</span><br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{ <br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-keyword">return</span> i; <br>        } <span class="hljs-keyword">finally</span> { <br>            i = <span class="hljs-number">20</span>; <br>        }<br>    } <br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>字节码：</strong></p>
<ul>
<li>看下方反编译的内容会发现：</li>
<li>try中的return数据被存储到了slot</li>
<li>执行finally，20会被加入操作数栈</li>
<li><strong>重点</strong>：会再次将暂存的slot1加入操作数栈（此时栈顶两个元素20和10）</li>
<li>返回栈顶</li>
<li><strong>即</strong>：<strong>istore_1暂存是为了固定返回值，防止被finally中的改动所影响</strong></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>; <br>&nbsp; &nbsp;descriptor: ()I<br>&nbsp; &nbsp;flags: ACC_PUBLIC, ACC_STATIC <br>&nbsp; &nbsp;Code:<br>&nbsp; &nbsp; &nbsp;stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">0</span>: bipush &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">10</span> &nbsp; &nbsp;<span class="hljs-comment">// &lt;- 10 放入栈顶 </span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">2</span>: istore_0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 10 -&gt; i</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">3</span>: iload_0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// &lt;- i(10)</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">4</span>: istore_1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 10 -&gt; slot 1，暂存至    slot 1，目的是为了固定返回值 </span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">5</span>: bipush &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">20</span> &nbsp; &nbsp;<span class="hljs-comment">// &lt;- 20 放入栈顶</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">7</span>: istore_0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 20 -&gt; i</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">8</span>: iload_1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// &lt;- slot 1(10) 载入    slot 1 暂存的值 </span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">9</span>: ireturn &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 返回栈顶的    int(10)</span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">10</span>: astore_2<br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">11</span>: bipush &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">20</span> <br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">13</span>: istore_0<br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">14</span>: aload_2 <br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">15</span>: athrow<br>&nbsp; &nbsp; &nbsp;Exception table:<br>&nbsp; &nbsp; &nbsp; &nbsp; from &nbsp; &nbsp;to &nbsp;target type <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">3</span> &nbsp; &nbsp; <span class="hljs-number">5</span> &nbsp; &nbsp;<span class="hljs-number">10</span> &nbsp; any <br>&nbsp; &nbsp; &nbsp;LineNumberTable: ...<br>&nbsp; &nbsp; &nbsp;LocalVariableTable:<br>&nbsp; &nbsp; &nbsp; &nbsp;Start &nbsp;Length &nbsp;Slot &nbsp;Name &nbsp; Signature <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">3</span> &nbsp; &nbsp; &nbsp;<span class="hljs-number">13</span> &nbsp; &nbsp; <span class="hljs-number">0</span> &nbsp; &nbsp; i &nbsp; I2<span class="hljs-number">.13</span> <span class="hljs-keyword">synchronized</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="synchronized"><a class="header-anchor" href="#synchronized">¶</a>synchronized</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_13</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        Object lock = <span class="hljs-keyword">new</span> Object();<br>        <span class="hljs-keyword">synchronized</span> (lock) {<br>            System.out.println(<span class="hljs-string">"ok"</span>); <br>        }<br>    }&nbsp;&nbsp;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>字节码：</strong></p>
<p><strong>注意</strong>：方法级别的 synchronized 不会在字节码指令中有所体现</p>
<p><strong>异常表机制可以保证加锁解锁成对完成：</strong></p>
<ul>
<li>正常流程为：11-22加解锁操作</li>
<li>发生异常流程为：根据异常表，12-22出现异常会跳到25
<ul>
<li>存储异常对象引用到slot3，加载slot2即lock到操作数栈进行后续解锁操作</li>
<li>解锁完毕，加载异常对象引用slot3到操作数栈，进行抛异常操作</li>
<li>根据异常表，若25-28发生异常会重新进入25</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>; <br>&nbsp; &nbsp;descriptor: ([Ljava/lang/String;)V<br>&nbsp; &nbsp;flags: ACC_PUBLIC, ACC_STATIC <br>&nbsp; &nbsp;Code:<br>&nbsp; &nbsp; &nbsp;stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br>&nbsp; &nbsp; &nbsp; &nbsp; 0: new &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #2 &nbsp; &nbsp; &nbsp; &nbsp;// new Object <br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">3</span>: dup					   <span class="hljs-comment">// 复制一份引用到操作数栈，一份调用构造方法使用然后出栈，一份为了调用成员方法变量</span><br>&nbsp; &nbsp; &nbsp; &nbsp; 4: invokespecial #1 &nbsp; &nbsp; &nbsp; &nbsp;// invokespecial &lt;init&gt;:()V <br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">7</span>: astore_1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// lock引用    -&gt; lock</span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">8</span>: aload_1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// &lt;- lock （synchronized开始） </span><br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">9</span>: dup					   <span class="hljs-comment">// 复制一份，一份用于monitorenter加锁，一份用于monitorexit解锁操作</span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">10</span>: astore_2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// lock引用    -&gt; slot 2</span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">11</span>: monitorenter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// monitorenter(lock引用) </span><br>&nbsp; &nbsp; &nbsp; &nbsp;12: getstatic &nbsp; &nbsp; #3 &nbsp; &nbsp; &nbsp; &nbsp;// &lt;- System.out<br>&nbsp; &nbsp; &nbsp; &nbsp;15: ldc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #4 &nbsp; &nbsp; &nbsp; &nbsp;// &lt;- "ok"<br>&nbsp; &nbsp; &nbsp; &nbsp;17: invokevirtual #5 &nbsp; &nbsp; &nbsp; &nbsp;// invokevirtual println: <br>(Ljava/lang/String;)V<br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">20</span>: aload_2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// &lt;- slot 2(lock引用) </span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">21</span>: monitorexit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// monitorexit(lock引用) </span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">22</span>: goto &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">30</span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">25</span>: astore_3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// any -&gt; slot 3</span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">26</span>: aload_2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// &lt;- slot 2(lock引用) </span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">27</span>: monitorexit &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// monitorexit(lock引用) </span><br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">28</span>: aload_3<br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">29</span>: athrow<br>&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">30</span>: <span class="hljs-keyword">return</span><br>      <span class="hljs-comment">// 异常表</span><br>&nbsp; &nbsp; &nbsp;Exception table:<br>&nbsp; &nbsp; &nbsp; &nbsp; from &nbsp; &nbsp;to &nbsp;target type <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">12</span> &nbsp; &nbsp;<span class="hljs-number">22</span> &nbsp; &nbsp;<span class="hljs-number">25</span> &nbsp; any <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">25</span> &nbsp; &nbsp;<span class="hljs-number">28</span> &nbsp; &nbsp;<span class="hljs-number">25</span> &nbsp; any <br>&nbsp; &nbsp; &nbsp;LineNumberTable: ...<br>&nbsp; &nbsp; &nbsp;LocalVariableTable:<br>&nbsp; &nbsp; &nbsp; &nbsp;Start &nbsp;Length &nbsp;Slot &nbsp;Name &nbsp; Signature<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">0</span> &nbsp; &nbsp; &nbsp;<span class="hljs-number">31</span> &nbsp; &nbsp; <span class="hljs-number">0</span> &nbsp;args &nbsp; [Ljava/lang/String; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">8</span> &nbsp; &nbsp; &nbsp;<span class="hljs-number">23</span> &nbsp; &nbsp; <span class="hljs-number">1</span> &nbsp;lock &nbsp; Ljava/lang/Object; <br>&nbsp; &nbsp; &nbsp;StackMapTable: ...<br>&nbsp; &nbsp;MethodParameters: ...<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3、编译期处理"><a class="header-anchor" href="#3、编译期处理">¶</a>3、编译期处理</h2>
<blockquote>
<p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 <strong>.java 源码编译为 .class 字节码的过程</strong>中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利。</p>
<p>注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p>
</blockquote>
<h3 id="默认构造函数"><a class="header-anchor" href="#默认构造函数">¶</a>默认构造函数</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>{<br><br>}<br></code></pre></td></tr></tbody></table></figure>
<p>经过编译期优化后</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>{<br>    <span class="hljs-comment">//这个无参构造器是java编译器帮我们加上的</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy1</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object." &lt;init&gt;":()V</span><br>        <span class="hljs-keyword">super</span>();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="自动拆装箱"><a class="header-anchor" href="#自动拆装箱">¶</a>自动拆装箱</h3>
<p>基本类型和其包装类型的相互转换过程，称为拆装箱</p>
<p>在JDK 5以后，它们的转换可以在编译期自动完成</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        Integer x = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> y = x;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>转换过程如下</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-comment">//基本类型赋值给包装类型，称为装箱</span><br>        Integer x = Integer.valueOf(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//包装类型赋值给基本类型，称谓拆箱</span><br>        <span class="hljs-keyword">int</span> y = x.intValue();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="泛型集合取值"><a class="header-anchor" href="#泛型集合取值">¶</a>泛型集合取值</h3>
<ul>
<li>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作</li>
<li>即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-number">10</span>); <span class="hljs-comment">// 实际调用的是    List.add(Object e)</span><br>        Integer x = list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 实际调用的是    Object obj = List.get(int index);</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>所以调用get函数取值时，有一个类型转换的操作</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = (Integer) list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></tbody></table></figure>
<p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x = (Integer) list.get(<span class="hljs-number">0</span>).intValue();<br></code></pre></td></tr></tbody></table></figure>
<p><strong>对应字节码</strong></p>
<ul>
<li><strong>擦除的是字节码上的泛型信息</strong>，可以看到 <strong>LocalVariableTypeTable</strong> 仍然保留了方法参数泛型的信息</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>       0: new           #2                  // class java/util/ArrayList<br>       <span class="hljs-number">3</span>: dup<br>       4: invokespecial #3                  // Method java/util/ArrayList."&lt;init&gt;":()V<br>       <span class="hljs-number">7</span>: astore_1<br>       <span class="hljs-number">8</span>: aload_1<br>       <span class="hljs-number">9</span>: bipush        <span class="hljs-number">10</span><br>      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;<br>      <span class="hljs-comment">//这里进行了泛型擦除，实际调用的是add(Objcet o)</span><br>      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z<br><br>      <span class="hljs-number">19</span>: pop<br>      <span class="hljs-number">20</span>: aload_1<br>      <span class="hljs-number">21</span>: iconst_0<br>      <span class="hljs-comment">//这里也进行了泛型擦除，实际调用的是get(Object o)   </span><br>      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;<br>	  <span class="hljs-comment">//这里进行了类型转换，将Object转换成了Integer</span><br>      27: checkcast     #7                  // class java/lang/Integer<br>      <span class="hljs-number">30</span>: astore_2<br>      <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span><br>    LineNumberTable:<br>&nbsp; &nbsp; &nbsp; &nbsp;line <span class="hljs-number">8</span>: <span class="hljs-number">0</span><br>&nbsp; &nbsp; &nbsp; &nbsp;line <span class="hljs-number">9</span>: <span class="hljs-number">8</span><br>&nbsp; &nbsp; &nbsp; &nbsp;line <span class="hljs-number">10</span>: <span class="hljs-number">20</span><br>&nbsp; &nbsp; &nbsp; &nbsp;line <span class="hljs-number">11</span>: <span class="hljs-number">31</span><br>&nbsp; &nbsp; &nbsp;LocalVariableTable:<br>&nbsp; &nbsp; &nbsp; &nbsp;Start &nbsp;Length &nbsp;Slot &nbsp;Name &nbsp; Signature<br>           <span class="hljs-number">0</span> &nbsp; &nbsp; &nbsp;<span class="hljs-number">32</span> &nbsp; &nbsp; <span class="hljs-number">0</span> &nbsp;args &nbsp; [Ljava/lang/String; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">8</span> &nbsp; &nbsp; &nbsp;<span class="hljs-number">24</span> &nbsp; &nbsp; <span class="hljs-number">1</span> &nbsp;list &nbsp; Ljava/util/List; <br>&nbsp; &nbsp; &nbsp;LocalVariableTypeTable:<br>&nbsp; &nbsp; &nbsp; &nbsp;Start &nbsp;Length &nbsp;Slot &nbsp;Name &nbsp; Signature<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">8</span> &nbsp; &nbsp; &nbsp;<span class="hljs-number">24</span> &nbsp; &nbsp; <span class="hljs-number">1</span> &nbsp;list &nbsp; Ljava/util/List&lt;Ljava/lang/Integer;&gt;;<br></code></pre></td></tr></tbody></table></figure>
<p><strong>使用反射，仍然能够获得这些信息：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Integer&gt; <span class="hljs-title">test</span><span class="hljs-params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> </span>{ <br>}<br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Method test = Candy3.class.getMethod(<span class="hljs-string">"test"</span>, List.class, Map.class); <br>Type[] types = test.getGenericParameterTypes();<br><span class="hljs-keyword">for</span> (Type type : types) {<br>    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ParameterizedType) {<br>        ParameterizedType parameterizedType = (ParameterizedType) type; <br>        System.out.println(<span class="hljs-string">"原始类型    - "</span> + parameterizedType.getRawType()); <br>        Type[] arguments = parameterizedType.getActualTypeArguments(); <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arguments.length; i++) {<br>            System.out.printf(<span class="hljs-string">"泛型参数[%d] - %s\n"</span>, i, arguments[i]); <br>        }<br>    } <br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">原始类型    - interface java.util.List <br>泛型参数[0] - class java.lang.String <br>原始类型    - interface java.util.Map <br>泛型参数[0] - class java.lang.Integer <br>泛型参数[1] - class java.lang.Object<br></code></pre></td></tr></tbody></table></figure>
<h3 id="可变参数"><a class="header-anchor" href="#可变参数">¶</a>可变参数</h3>
<p>可变参数也是 JDK5 开始加入的新特性：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>{<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String... args)</span> </span>{<br>      <span class="hljs-comment">//将args赋值给arr，可以看出String...实际就是String[] </span><br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   }<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>      foo(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>);<br>   }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>{<br>   <span class="hljs-keyword">public</span> Demo4 {}<br><br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String[] args)</span> </span>{<br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   }<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>      foo(<span class="hljs-keyword">new</span> String[]{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>});<br>   }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p>
<h3 id="foreach"><a class="header-anchor" href="#foreach">¶</a>foreach</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-comment">//数组赋初值的简化写法也是一种语法糖。</span><br>        <span class="hljs-keyword">int</span>[] arr = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : arr) {<br>            System.out.println(x);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>编译器会帮我们转换为</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>{<br>    <span class="hljs-keyword">public</span> Demo5 {}<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; ++i) {<br>            <span class="hljs-keyword">int</span> x = arr[i];<br>            System.out.println(x);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>如果是集合使用foreach</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span> (Integer x : list) {<br>            System.out.println(x);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>{<br>    <span class="hljs-keyword">public</span> Demo5 {}<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-comment">//获得该集合的迭代器</span><br>        Iterator&lt;Integer&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span>(iterator.hasNext()) {<br>            Integer x = iterator.next();<br>            System.out.println(x);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="switch字符串"><a class="header-anchor" href="#switch字符串">¶</a>switch字符串</h3>
<p>从 JDK 7 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        String str = <span class="hljs-string">"hello"</span>;<br>        <span class="hljs-keyword">switch</span> (str) {<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">"hello"</span> :<br>                System.out.println(<span class="hljs-string">"h"</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">"world"</span> :<br>                System.out.println(<span class="hljs-string">"w"</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>在编译器中执行的操作</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo6</span><span class="hljs-params">()</span> </span>{<br><br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        String str = <span class="hljs-string">"hello"</span>;<br>        <span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//通过字符串的hashCode+value来判断是否匹配</span><br>        <span class="hljs-keyword">switch</span> (str.hashCode()) {<br>                <span class="hljs-comment">//hello的hashCode</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :<br>                <span class="hljs-comment">//再次比较，因为字符串的hashCode有可能相等</span><br>                <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">"hello"</span>)) {<br>                    x = <span class="hljs-number">0</span>;<br>                }<br>                <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">//world的hashCode</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :<br>                <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">"world"</span>)) {<br>                    x = <span class="hljs-number">1</span>;<br>                }<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        }<br><br>        <span class="hljs-comment">//用第二个switch在进行输出判断</span><br>        <span class="hljs-keyword">switch</span> (x) {<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                System.out.println(<span class="hljs-string">"h"</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                System.out.println(<span class="hljs-string">"w"</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>过程说明：</strong></p>
<ul>
<li>在编译期间，单个的switch被分为了两个
<ul>
<li>第一个用来匹配字符串，并给x赋值
<ul>
<li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li>
<li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li>
</ul>
</li>
<li>第二个用来根据x的值来决定输出语句</li>
</ul>
</li>
</ul>
<h3 id="switch枚举"><a class="header-anchor" href="#switch枚举">¶</a>switch枚举</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>{<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-keyword">switch</span> (sex) {<br>         <span class="hljs-keyword">case</span> MALE:<br>            System.out.println(<span class="hljs-string">"man"</span>); <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> FEMALE:<br>            System.out.println(<span class="hljs-string">"woman"</span>); <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      }<br>   }<br>}<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>{<br>   MALE, FEMALE;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>编译器中执行的代码如下</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>{<br>   <span class="hljs-comment">/**     </span><br><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><br><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><br><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><br><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><br><span class="hljs-comment">    */</span> <br>   <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">MAP</span> </span>{<br>      <span class="hljs-comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span><br>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">static</span> {<br>         <span class="hljs-comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span><br>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;<br>         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;<br>      }<br>   }<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>      SEX sex = SEX.MALE;<br>      <span class="hljs-comment">//将对应位置枚举元素的值赋给x，用于case操作</span><br>      <span class="hljs-keyword">int</span> x = $MAP.map[sex.ordinal()];<br>      <span class="hljs-keyword">switch</span> (x) {<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">"man"</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            System.out.println(<span class="hljs-string">"woman"</span>);<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>      }<br>   }<br>}<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>{<br>   MALE, FEMALE;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="枚举类"><a class="header-anchor" href="#枚举类">¶</a>枚举类</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SEX</span> </span>{<br>   MALE, FEMALE;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>转换后的代码</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">Sex</span>&gt; </span>{   <br>    <span class="hljs-comment">//对应枚举类中的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;<br><br>    <span class="hljs-keyword">static</span> {       <br>        <span class="hljs-comment">//调用构造函数，传入枚举元素的值及ordinal</span><br>        MALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">"MALE"</span>, <span class="hljs-number">0</span>);    <br>        FEMALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">"FEMALE"</span>, <span class="hljs-number">1</span>);   <br>        $VALUES = <span class="hljs-keyword">new</span> Sex[]{MALE, FEMALE}; <br>    }<br><br>    <span class="hljs-comment">//调用父类中的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Sex</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>{     <br>        <span class="hljs-keyword">super</span>(name, ordinal);    <br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() {  <br>        <span class="hljs-keyword">return</span> $VALUES.clone();  <br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>{ <br>        <span class="hljs-keyword">return</span> Enum.valueOf(Sex.class, name);  <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="try-with-resources"><a class="header-anchor" href="#try-with-resources">¶</a>try-with-resources</h3>
<p>JDK 7 开始新增了对需要关闭的资源处理的特殊语法<code>try-with-resources</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(资源变量    = 创建资源对象){ <br>} <span class="hljs-keyword">catch</span>( ) {<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>其中资源对象需要实现 AutoCloseable接口，例如工InputStream、OutputStream 、Connection、Statement、Resultset等接口都实现了Autocloseable，使用try-with-resources可以不用写finally语句块，编译器会帮助生成关闭资源代码，例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-keyword">try</span>(InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"d:\\1.txt"</span>)) { <br>            System.out.println(is);<br>        } <span class="hljs-keyword">catch</span> (IOException e) { <br>            e.printStackTrace(); <br>        }<br>    } <br>}<br></code></pre></td></tr></tbody></table></figure>
<p>会被转换为：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy9</span> </span>{ <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy9</span><span class="hljs-params">()</span> </span>{ <br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        <span class="hljs-keyword">try</span> {<br>            InputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"d:\\1.txt"</span>); <br>            Throwable t = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span> {<br>                System.out.println(is); <br>            } <span class="hljs-keyword">catch</span> (Throwable e1) { <br>                <span class="hljs-comment">// t 是我们代码出现的异常 </span><br>                t = e1;<br>                <span class="hljs-keyword">throw</span> e1;<br>            } <span class="hljs-keyword">finally</span> {<br>                <span class="hljs-comment">// 判断了资源不为空</span><br>                <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) {<br>                    <span class="hljs-comment">// 如果我们代码有异常 </span><br>                    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) { <br>                        <span class="hljs-keyword">try</span> {<br>                            is.close();<br>                        } <span class="hljs-keyword">catch</span> (Throwable e2) {<br>                            <span class="hljs-comment">// 如果    close 出现异常，作为被压制异常添加 </span><br>                            t.addSuppressed(e2);<br>                        } <br>                    } <span class="hljs-keyword">else</span> {<br>                        <span class="hljs-comment">// 如果我们代码没有异常，close 出现的异常就是最后    catch 块中的    e </span><br>                        is.close();<br>                    } <br>                }<br>            }<br>        }<br>    } <span class="hljs-keyword">catch</span> (IOException e) { <br>        e.printStackTrace(); <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>为什么要设计一个 addSuppressed(Throwable e) （添加被压制异常）的方法呢？</p>
<p>是为了<strong>防止异常信息的丢失</strong>（ try-with-resources 生成的 ﬁanlly中如果抛出了异常）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test6</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-keyword">try</span> (MyResource resource = <span class="hljs-keyword">new</span> MyResource()) { <br>            <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>        } <span class="hljs-keyword">catch</span> (Exception e) { <br>            e.printStackTrace(); <br>        }<br>    } <br>}<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AutoCloseable</span> </span>{ <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{ <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"close 异常"</span>); <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>输出：</strong></p>
<p>如以上代码所示，两个异常信息都不会丢。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.ArithmeticException: / by zero<br>	at test.Test6.main(Test6.java:<span class="hljs-number">7</span>) <br>	Suppressed: java.lang.Exception: close 异常<br>        at test.MyResource.close(Test6.java:<span class="hljs-number">18</span>) <br>        at test.Test6.main(Test6.java:<span class="hljs-number">6</span>)<br></code></pre></td></tr></tbody></table></figure>
<h3 id="方法重写时的桥接方法"><a class="header-anchor" href="#方法重写时的桥接方法">¶</a>方法重写时的桥接方法</h3>
<p>我们都知道，方法重写时对返回值分两种情况：</p>
<ul>
<li>父子类的返回值完全一致</li>
<li>子类返回值可以是父类返回值的子类（比较绕口，见下面的例子）</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>{ <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    } <br>}<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>{ <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">// 子类m 方法的返回值是Integer 是父类m 方法返回值 Number 的子类 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>对于子类，java 编译器会做如下处理</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>{ <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    }<br>    <span class="hljs-comment">// 此方法才是真正重写了父类 public Number m() 方法 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge Number <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-comment">// 调用 public Integer m() </span><br>        <span class="hljs-keyword">return</span> m();<br>    } <br>}<br></code></pre></td></tr></tbody></table></figure>
<p>其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以用下面反射代码来验证：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Method m : B.class.getDeclaredMethods()) { <br>    System.out.println(m);<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>会输出：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> java.lang.Integer test.candy.B.m() <br><span class="hljs-keyword">public</span> java.lang.Number test.candy.B.m()<br></code></pre></td></tr></tbody></table></figure>
<h3 id="匿名内部类"><a class="header-anchor" href="#匿名内部类">¶</a>匿名内部类</h3>
<p><strong>源代码：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        Runnable runnable = <span class="hljs-keyword">new</span> Runnable() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                System.out.println(<span class="hljs-string">"running..."</span>);<br>            }<br>        };<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>转换后的代码</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-comment">//用额外创建的类来创建匿名内部类对象</span><br>        Runnable runnable = <span class="hljs-keyword">new</span> Demo8$<span class="hljs-number">1</span>();<br>    }<br>}<br><br><span class="hljs-comment">//创建了一个额外的类，实现了Runnable接口</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{<br>    <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>() {}<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>        System.out.println(<span class="hljs-string">"running..."</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>如果匿名内部类中引用了<strong>局部变量</strong></p>
<p><strong>注意</strong>：内部类引用局部变量，必须是final类型</p>
<ul>
<li><strong>为了避免方法内的变量脱离方法而存在的现象发生</strong>，于是jdk1.8之前java规定局部内部类不能访问一般的局部变量，但能访问被final修饰的变量</li>
<li>jdk1.8之后不需要手动添加final，jvm底层会帮你添加，被称之为 effectively final</li>
</ul>
<p>这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 ﬁnal 的：</p>
<p>因为在创建 <code>Candy11$1</code> 对象时，将 x 的值赋值给了   <code>Candy11$1</code> 对象的 <code>val$x</code> 属性，所以 x 不应该再发生变化了，如果变化，那么 <code>val$x</code> 属性没有机会再跟着一起变化！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x)</span> </span>{ <br>        Runnable runnable = <span class="hljs-keyword">new</span> Runnable() { <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                System.out.println(<span class="hljs-string">"ok:"</span> + x); <br>            }<br>        }; <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>转化后代码</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 额外生成的类</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{ <br>    <span class="hljs-keyword">int</span> val$x;<br>    Candy11$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span> x) { <br>        <span class="hljs-keyword">this</span>.val$x = x; <br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>        System.out.println(<span class="hljs-string">"ok:"</span> + <span class="hljs-keyword">this</span>.val$x); <br>    }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy11</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x)</span> </span>{ <br>        Runnable runnable = <span class="hljs-keyword">new</span> Candy11$<span class="hljs-number">1</span>(x); <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="4、类加载阶段"><a class="header-anchor" href="#4、类加载阶段">¶</a>4、类加载阶段</h2>
<h3 id="加载"><a class="header-anchor" href="#加载">¶</a>加载</h3>
<ul>
<li>将类的字节码载入方法区（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 <strong>instanceKlass</strong> 描述 java 类，它的重要 ﬁeld 有：
<ul>
<li>_java_mirror 即 java 的<strong>类镜像</strong>，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li>
<li>_super 即父类</li>
<li>_ﬁelds 即成员变量</li>
<li>_methods 即方法</li>
<li>_constants 即常量池</li>
<li>_class_loader 即类加载器</li>
<li>_vtable 虚方法表</li>
<li>_itable 接口方法</li>
</ul>
</li>
<li>如果这个类还有父类没有加载，<strong>先加载父类</strong></li>
<li>加载和链接可能是<strong>交替运行</strong>的</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>
<p><strong>instanceKlass</strong> 这样的【<strong>元数据</strong>】是存储在<strong>方法区</strong>（1.8 后的元空间内）</p>
</li>
<li>
<p>但 <strong>_java_mirror</strong> 是存储在<strong>堆中</strong></p>
</li>
<li>
<p>类的对象在对象头中保存了<code>*.class</code>的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</p>
</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/799c41ce1d6bed10e1a0eade4ec4b3a7.png" alt=""></p>
<h3 id="链接"><a class="header-anchor" href="#链接">¶</a>链接</h3>
<h4 id="验证"><a class="header-anchor" href="#验证">¶</a>验证</h4>
<p>验证类是否符合 JVM规范，安全性检查</p>
<h4 id="准备"><a class="header-anchor" href="#准备">¶</a>准备</h4>
<p>为 static 变量分配空间，设置默认值</p>
<ul>
<li>static变量在<strong>JDK 7以前是存储于instanceKlass末尾</strong>。但在<strong>JDK 7以后就存储在_java_mirror末尾了</strong></li>
<li>static变量在分配空间和赋值是在<strong>两个阶段</strong>完成的。
<ul>
<li><strong>分配空间</strong>在准备阶段完成</li>
<li><strong>赋值</strong>在**初始化阶段（类构造方法）**完成（反编译字节码可以看到）</li>
</ul>
</li>
<li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li>
<li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>{<br><br>    <span class="hljs-comment">// 没有出现在构造方法中(只进行了分配空间操作)</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-comment">// 出现在构造方法中（分配空间 + 赋值（发生在构造方法中，即类加载的第三个阶段：初始化阶段））</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">5</span>;<br>	<span class="hljs-comment">// final修饰 基本类型 字符串常量 编译阶段即可确定，赋值在 准备阶段</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String d = <span class="hljs-string">"hello"</span>;<br>    <span class="hljs-comment">// final修饰 引用类型，赋值在初始化阶段完成（类构造方法）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object o = <span class="hljs-keyword">new</span> Object();<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>字节码反编译结果：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java">{<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;<br>    descriptor: I<br>    flags: (<span class="hljs-number">0x0008</span>) ACC_STATIC<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b;<br>    descriptor: I<br>    flags: (<span class="hljs-number">0x0008</span>) ACC_STATIC<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> c;<br>    descriptor: I<br>    flags: (<span class="hljs-number">0x0018</span>) ACC_STATIC, ACC_FINAL<br>    ConstantValue: <span class="hljs-keyword">int</span> <span class="hljs-number">10</span><br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.String d;<br>    descriptor: Ljava/lang/String;<br>    flags: (<span class="hljs-number">0x0018</span>) ACC_STATIC, ACC_FINAL<br>    ConstantValue: String hello<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.Object o;<br>    descriptor: Ljava/lang/Object;<br>    flags: (<span class="hljs-number">0x0018</span>) ACC_STATIC, ACC_FINAL<br><br>  <span class="hljs-keyword">public</span> com.itnxd.jvm.constant.Demo3();<br>    descriptor: ()V<br>    flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0 <span class="hljs-comment">// 指this</span><br>         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V<br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">14</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/itnxd/jvm/constant/Demo3;<br><br>  <span class="hljs-keyword">static</span> {}; <span class="hljs-comment">// 类构造方法信息</span><br>    descriptor: ()V<br>    flags: (<span class="hljs-number">0x0008</span>) ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span><br>         <span class="hljs-number">0</span>: iconst_5<br>         1: putstatic     #2                  // Field b:I 为常量池中的b赋值<br>         4: new           #3                  // class java/lang/Object<br>         <span class="hljs-number">7</span>: dup<br>         8: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V<br>        11: putstatic     #4                  // Field o:Ljava/lang/Object;<br>        <span class="hljs-number">14</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">17</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">22</span>: <span class="hljs-number">4</span><br>}<br>SourceFile: <span class="hljs-string">"Demo3.java"</span><br><br></code></pre></td></tr></tbody></table></figure>
<h4 id="解析"><a class="header-anchor" href="#解析">¶</a>解析</h4>
<p>将常量池中的符号引用解析为直接引用</p>
<ul>
<li><strong>未解析时（即new C()注释）</strong>，常量池中的看到的对象仅是符号，未真正的存在于内存中</li>
<li>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</li>
<li><strong>解析以后（即new C()取消注释）</strong>，<strong>会将常量池中的符号引用解析为直接引用</strong></li>
<li>可以看到，此时已加载并解析了类C和类D</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>{<br>        ClassLoader loader = Demo1.class.getClassLoader();<br>        <span class="hljs-comment">//只加载不解析</span><br>        Class&lt;?&gt; c = loader.loadClass(<span class="hljs-string">"com.nyima.JVM.day8.C"</span>);<br>        <br>        <span class="hljs-comment">// new C();</span><br>        <br>        System.in.read();<br>    }<br>}<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>{<br>    D d = <span class="hljs-keyword">new</span> D();<br>}<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>{<br><br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="初始化"><a class="header-anchor" href="#初始化">¶</a>初始化</h3>
<p><code>&lt;cinit&gt;()V </code>方法</p>
<p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p>
<ul>
<li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li>
<li><strong>注意</strong>：编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong></li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/16/044cc27924dce9f85a6176651875b5b3.png" alt=""></p>
<p><strong>发生的时机？</strong></p>
<p>概括得说，类初始化是【<strong>懒惰的</strong>】</p>
<ul>
<li>main 方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 会导致初始化</li>
</ul>
<p><strong>不会导致类初始化的情况？</strong></p>
<ul>
<li>访问类的 static ﬁnal 静态常量（基本类型和字符串）不会触发初始化 （链接的准备阶段发生）</li>
<li>类对象.class 不会触发初始化（加载阶段发生）</li>
<li>创建该类的数组不会触发初始化</li>
<li>类加载器的 loadClass 方法</li>
<li>Class.forName 的参数 2 为 false 时</li>
</ul>
<p><strong>实验验证？</strong></p>
<ul>
<li>只要能打印出类中静态代码块的内容，则说明发生了初始化！</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; &nbsp; &nbsp;<br>    <span class="hljs-keyword">static</span> {<br>        System.out.println(<span class="hljs-string">"a init"</span>); <br>    }<br>}<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>{<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> b = <span class="hljs-number">5.0</span>; <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> c = <span class="hljs-keyword">false</span>; <br>    <span class="hljs-keyword">static</span> {<br>        System.out.println(<span class="hljs-string">"b init"</span>); <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>验证（实验时请先全部注释，每次只执行其中一个）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load3</span> </span>{ <br>    <span class="hljs-keyword">static</span> {<br>        System.out.println(<span class="hljs-string">"main init"</span>); <br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{ <br>        <span class="hljs-comment">// 1. 静态常量（基本类型和字符串）不会触发初始化</span><br>        System.out.println(B.b);<br>        <span class="hljs-comment">// 2. 类对象.class 不会触发初始化 </span><br>        System.out.println(B.class); <br>        <span class="hljs-comment">// 3. 创建该类的数组不会触发初始化 </span><br>        System.out.println(<span class="hljs-keyword">new</span> B[<span class="hljs-number">0</span>]); <br>        <span class="hljs-comment">// 4. 不会初始化类    B，但会加载    B、A</span><br>        ClassLoader cl = Thread.currentThread().getContextClassLoader();<br>        cl.loadClass(<span class="hljs-string">"cn.itcast.jvm.t3.B"</span>); <br>        <span class="hljs-comment">// 5. 不会初始化类    B，但会加载    B、A</span><br>        ClassLoader c2 = Thread.currentThread().getContextClassLoader(); <br>        Class.forName(<span class="hljs-string">"cn.itcast.jvm.t3.B"</span>, <span class="hljs-keyword">false</span>, c2);<br>        <span class="hljs-comment">// 1. 首次访问这个类的静态变量或静态方法时 </span><br>        System.out.println(A.a);<br>        <span class="hljs-comment">// 2. 子类初始化，如果父类还没初始化，会引发 </span><br>        System.out.println(B.c);<br>        <span class="hljs-comment">// 3. 子类访问父类静态变量，只触发父类初始化 </span><br>        System.out.println(B.a);<br>        <span class="hljs-comment">// 4. 会初始化类    B，并先初始化类    A</span><br>        Class.forName(<span class="hljs-string">"cn.itcast.jvm.t3.B"</span>); <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="小练习"><a class="header-anchor" href="#小练习">¶</a>小练习</h3>
<p>从字节码分析，使用 a，b，c 这三个常量是否会导致 E 初始化</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load4</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        System.out.println(E.a); <span class="hljs-comment">// 不会</span><br>        System.out.println(E.b); <span class="hljs-comment">// 不会</span><br>        System.out.println(E.c);  <span class="hljs-comment">// 会</span><br>    }<br>}<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span> </span>{<br>    <span class="hljs-comment">// 链接的准备阶段就直接编译确定了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String b = <span class="hljs-string">"hello"</span>;<br>    <br>    <span class="hljs-comment">// 其实是一个自动包装过程，会进入初始化阶段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer c = <span class="hljs-number">20</span>; <br>    <br>    <span class="hljs-keyword">static</span>{<br>        System.out.println(<span class="hljs-string">"E init"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>典型应用 - 完成懒惰初始化单例模式</strong></p>
<p>以上的实现特点是：</p>
<ul>
<li><strong>懒惰实例化</strong>
<ul>
<li>只有调用了getInstance方法才会触发初始化</li>
</ul>
</li>
<li>初始化时的<strong>线程安全</strong>是有保障的
<ul>
<li>内部类的静态变量赋值操作和静态代码块是<strong>由类加载器包装线程安全性的</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>{ <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>{ } <br>    <span class="hljs-comment">// 内部类中保存单例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>{<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton(); <br>        <span class="hljs-keyword">static</span>{<br>            System.out.println(<span class="hljs-string">"LazyHolder init"</span>);<br>        }<br>    }<br>    <span class="hljs-comment">// 第一次调用  getInstance 方法，才会导致内部类加载和初始化其静态成员 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> LazyHolder.INSTANCE; <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="5、类加载器"><a class="header-anchor" href="#5、类加载器">¶</a>5、类加载器</h2>
<h3 id="类与类加载器"><a class="header-anchor" href="#类与类加载器">¶</a>类与类加载器</h3>
<p>Java虚拟机设计团队有意把类加载阶段中的**“通过一个类的全限定名来获取描述该类的二进制字节流”<strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为</strong>“类加载器”**（ClassLoader）</p>
<p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p>
<p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<p>以JDK 8为例</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>加载的类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bootstrap ClassLoader（启动类加载器）</td>
<td>JAVA_HOME/jre/lib</td>
<td>无法直接访问</td>
</tr>
<tr>
<td>Extension ClassLoader(拓展类加载器)</td>
<td>JAVA_HOME/jre/lib/ext</td>
<td>上级为Bootstrap，<strong>显示为null</strong></td>
</tr>
<tr>
<td>Application ClassLoader(应用程序类加载器)</td>
<td>classpath</td>
<td>上级为Extension</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为Application</td>
</tr>
</tbody>
</table>
<ul>
<li>拓展类加载器上级是启动类加载器，但是启动类加载器是C++/C写的，因此getParent获取不到，为null</li>
<li>流程：
<ul>
<li>由下往上问加载了没，加载了就不加载了</li>
<li>若没加载，则由上往下问谁可以加载</li>
</ul>
</li>
</ul>
<h3 id="启动类加载器"><a class="header-anchor" href="#启动类加载器">¶</a>启动类加载器</h3>
<p>用 Bootstrap 类加载器加载类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span> </span>{<br>    <span class="hljs-keyword">static</span> {<br>        System.out.println(<span class="hljs-string">"bootstrap F init"</span>); <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>执行</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load5_1</span> </span>{<br>&nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{ <br>&nbsp; &nbsp; &nbsp; &nbsp;Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">"cn.itcast.jvm.t3.load.F"</span>);<br>       <span class="hljs-comment">// 启动类 null(获取不到位null) 拓展类 ExtClassLoader 应用程序类 AppClassLoader </span><br>&nbsp; &nbsp; &nbsp; &nbsp;System.out.println(aClass.getClassLoader()); <span class="hljs-comment">// null</span><br>&nbsp;}<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p><code>-Xbootclasspath</code> 表示设置 <code>bootclasspath</code></p>
</li>
<li>
<p>其中 <code>/a:.</code> 表示将当前目录追加至 <code>bootclasspath</code> 之后</p>
</li>
<li>
<p>可以用这个办法替换核心类</p>
<ul>
<li>
<p><code>java -Xbootclasspath:&lt;new bootclasspath&gt;</code></p>
</li>
<li>
<p><code>java -Xbootclasspath/a:&lt;追加路径&gt;</code>：后追加</p>
</li>
<li>
<p><code>java -Xbootclasspath/p:&lt;追加路径&gt;</code>：前追加</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">E:\git\jvm\out\production\jvm&gt;java -Xbootclasspath/a:. <br>cn.itcast.jvm.t3.load.Load5<br>bootstrap F init <br><span class="hljs-keyword">null</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="扩展类加载器"><a class="header-anchor" href="#扩展类加载器">¶</a>扩展类加载器</h3>
<p>如果classpath（应用程序）和JAVA_HOME/jre/lib/ext（拓展类） 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。</p>
<p>当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> </span>{<br>    <span class="hljs-keyword">static</span> {<br>        System.out.println(<span class="hljs-string">"classpath G init"</span>); <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>执行</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load5_2</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{ <br>        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">"cn.itcast.jvm.t3.load.G"</span>);<br>        System.out.println(aClass.getClassLoader());  <span class="hljs-comment">// AppClassLoader</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">classpath G init<br>    sun.misc.Launcher$AppClassLoader@18b4aac2<br></code></pre></td></tr></tbody></table></figure>
<p>写一个同名的类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.jvm.t3.load; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span> </span>{<br>    <span class="hljs-keyword">static</span> {<br>        System.out.println(<span class="hljs-string">"ext G init"</span>); <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>打个 jar 包</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">E:\git\jvm\out\production\jvm&gt;jar -cvf my.jar cn/itcast/jvm/t3/load/G.class <br>    已添加清单<br>    正在添加: cn/itcast/jvm/t3/load/G.class(输入    = <span class="hljs-number">481</span>) (输出    = <span class="hljs-number">322</span>)(压缩了    <span class="hljs-number">33</span>%)<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>将 jar 包拷贝到   JAVA_HOME/jre/lib/ext</li>
<li>重新执行 Load5_2</li>
</ul>
<p>输出</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ext G init<br>    sun.misc.Launcher$ExtClassLoader@29453f44<br></code></pre></td></tr></tbody></table></figure>
<h3 id="双亲委派模式"><a class="header-anchor" href="#双亲委派模式">¶</a>双亲委派模式</h3>
<p>所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则</p>
<p><strong>注意</strong></p>
<p>这里的双亲，翻译为上级似乎更为合适，因为它们并没有继承关系</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve) <br>    <span class="hljs-keyword">throws</span> ClassNotFoundException {<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) { <br>        <span class="hljs-comment">// 1. 检查该类是否已经加载过</span><br>        Class&lt;?&gt; c = findLoadedClass(name); <br>        <span class="hljs-comment">// 未加载过</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-keyword">long</span> t0 = System.nanoTime(); <br>            <span class="hljs-keyword">try</span> {<br>                <span class="hljs-comment">// 看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) {<br>                    <span class="hljs-comment">// 2. 有上级的话，委派上级    loadClass (递归)</span><br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>); <br>                } <span class="hljs-keyword">else</span> {<br>                    <span class="hljs-comment">// 3. 如果没有上级了（ExtClassLoader），则委派 </span><br>                    BootstrapClassLoader<br>                        c = findBootstrapClassOrNull(name); <br>                }<br>            } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) { <span class="hljs-comment">//捕获异常，但不做任何处理</span><br>            }<br>            <span class="hljs-comment">//如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span><br>            <span class="hljs-comment">//然后让应用类加载器去classpath下找该类</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) {<br>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                <span class="hljs-comment">// 4. 每一层找不到，调用    findClass 方法（每个类加载器自己扩展）来加载 </span><br>                c = findClass(name);<br>                <span class="hljs-comment">// 5. 记录耗时</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment(); <br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (resolve) {<br>            resolveClass(c); <br>        }<br>        <span class="hljs-keyword">return</span> c; <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load5_3</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{ <br>        Class&lt;?&gt; aClass = Load5_3.class.getClassLoader()<br>            .loadClass(<span class="hljs-string">"cn.itcast.jvm.t3.load.H"</span>); <br>        System.out.println(aClass.getClassLoader()); <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>执行流程为：</strong></p>
<p>递归过程：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> sun.misc.Launcher$AppClassLoader <span class="hljs-comment">//1 处，开始查看已加载的类，结果没有</span><br><span class="hljs-number">2.</span> sun.misc.Launcher$AppClassLoader <span class="hljs-comment">// 2 处，委派上级</span><br>   sun.misc.Launcher$ExtClassLoader.loadClass()<br><span class="hljs-number">3.</span> sun.misc.Launcher$ExtClassLoader <span class="hljs-comment">// 1 处，查看已加载的类，结果没有</span><br><span class="hljs-number">4.</span> sun.misc.Launcher$ExtClassLoader <span class="hljs-comment">// 3 处，没有上级了，则委派 BootstrapClassLoader 查找</span><br><span class="hljs-number">5.</span> BootstrapClassLoader 是在 JAVA_HOME/jre/lib 下找 H 这个类，显然没有<br><span class="hljs-number">6.</span> sun.misc.Launcher$ExtClassLoader <span class="hljs-comment">// 4 处，调用它自己的 ﬁndClass 方法，在JAVA_HOME/jre/lib/ext 下找 H 这个类，显然没有，回到 sun.misc.Launcher$AppClassLoader //2处                                            </span><br><span class="hljs-number">7.</span> 继续执行到 sun.misc.Launcher$AppClassLoader <span class="hljs-comment">// 4 处，调用它自己的 ﬁndClass 方法，在 classpath 下查找，找到了</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="线程上下文类加载器"><a class="header-anchor" href="#线程上下文类加载器">¶</a>线程上下文类加载器</h3>
<p>我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>)<br></code></pre></td></tr></tbody></table></figure>
<p>也是可以让 com.mysql.jdbc.Driver 正确加载的，你知道是怎么做的吗？</p>
<p>让我们追踪一下源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DriverManager</span> </span>{<br>    <span class="hljs-comment">// 注册驱动的集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers<br>        = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<br>    <span class="hljs-comment">// 初始化驱动</span><br>    <span class="hljs-keyword">static</span> {<br>        loadInitialDrivers();<br>        println(<span class="hljs-string">"JDBC DriverManager initialized"</span>);<br>    }<br></code></pre></td></tr></tbody></table></figure>
<p>先不看别的，看看 DriverManager 的类加载器：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(DriverManager.class.getClassLoader());<br></code></pre></td></tr></tbody></table></figure>
<p><strong>打印 null</strong>，表示它的<strong>类加载器是 Bootstrap ClassLoader</strong>，会到 JAVA_HOME/jre/lib 下搜索类，但 JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在DriverManager 的静态代码块中，<strong>怎么能正确加载 com.mysql.jdbc.Driver 呢？</strong></p>
<p><strong>继续看 loadInitialDrivers() 方法：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadInitialDrivers</span><span class="hljs-params">()</span> </span>{<br>    String drivers;<br>    <span class="hljs-keyword">try</span> {<br>        drivers = AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;String&gt;() {<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>                <span class="hljs-keyword">return</span> System.getProperty(<span class="hljs-string">"jdbc.drivers"</span>);<br>            }<br>        });<br>    } <span class="hljs-keyword">catch</span> (Exception ex) {<br>        drivers = <span class="hljs-keyword">null</span>;<br>    }<br>    <span class="hljs-comment">// 1）使用 ServiceLoader 机制加载驱动，即 SPI</span><br>    AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() {<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>            ServiceLoader&lt;Driver&gt; loadedDrivers =<br>                ServiceLoader.load(Driver.class);<br>            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>            <span class="hljs-keyword">try</span>{<br>                <span class="hljs-keyword">while</span>(driversIterator.hasNext()) {<br>                    driversIterator.next();<br>                }<br>            } <span class="hljs-keyword">catch</span>(Throwable t) {<br>                <span class="hljs-comment">// Do nothing</span><br>            }<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        }<br>    });<br>    println(<span class="hljs-string">"DriverManager.initialize: jdbc.drivers = "</span> + drivers);<br>    <span class="hljs-comment">// 2）使用 jdbc.drivers 定义的驱动名加载驱动</span><br>    <span class="hljs-keyword">if</span> (drivers == <span class="hljs-keyword">null</span> || drivers.equals(<span class="hljs-string">""</span>)) {<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    String[] driversList = drivers.split(<span class="hljs-string">":"</span>);<br>    println(<span class="hljs-string">"number of Drivers:"</span> + driversList.length);<br>    <span class="hljs-keyword">for</span> (String aDriver : driversList) {<br>        <span class="hljs-keyword">try</span> {<br>            println(<span class="hljs-string">"DriverManager.Initialize: loading "</span> + aDriver);<br>            <span class="hljs-comment">// 这里的 ClassLoader.getSystemClassLoader() 就是应用程序类加载器</span><br>            Class.forName(aDriver, <span class="hljs-keyword">true</span>,<br>                          ClassLoader.getSystemClassLoader());<br>        } <span class="hljs-keyword">catch</span> (Exception ex) {<br>            println(<span class="hljs-string">"DriverManager.Initialize: load failed: "</span> + ex);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>先看 2）发现它最后是使用 Class.forName 完成类的加载和初始化，关联的是<strong>应用程序类加载器</strong>，因此可以顺利完成类加载</li>
<li>再看 1）它就是大名鼎鼎的 <strong>Service Provider Interface （SPI）</strong></li>
<li>约定如下，在 jar 包的 META-INF/services 包下，以<strong>接口全限定名</strong>名为文件，<strong>文件内容是实现类名称</strong></li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/17/cf8db3ef70987b80290cea67acc51841.png" alt=""></p>
<p>这样就可以使用：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class);<br>Iterator&lt;接口类型&gt; iter = allImpls.iterator();<br><span class="hljs-keyword">while</span>(iter.hasNext()) {<br>    iter.next();<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>来得到实现类，体现的是【面向接口编程+解耦】的思想，在下面一些框架中都运用了此思想：</p>
<ul>
<li>JDBC</li>
<li>Servlet 初始化器</li>
<li>Spring 容器</li>
<li>Dubbo（对 SPI 进行了扩展）</li>
</ul>
<p><strong>接着看 ServiceLoader.load 方法：</strong></p>
<ul>
<li>获取<strong>线程上下文类加载器</strong></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-function">ServiceLoader&lt;S&gt; <span class="hljs-title">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> </span>{<br>    <span class="hljs-comment">// 获取线程上下文类加载器</span><br>    ClassLoader cl = Thread.currentThread().getContextClassLoader();<br>    <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<p>线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器，它内部又是由Class.forName 调用了线程上下文类加载器完成类加载，具体代码在 ServiceLoader 的内部类LazyIterator 中：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> S <span class="hljs-title">nextService</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">if</span> (!hasNextService())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    String cn = nextName;<br>    nextName = <span class="hljs-keyword">null</span>;<br>    Class&lt;?&gt; c = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> {<br>        c = Class.forName(cn, <span class="hljs-keyword">false</span>, loader);<br>    } <span class="hljs-keyword">catch</span> (ClassNotFoundException x) {<br>        fail(service,<br>             <span class="hljs-string">"Provider "</span> + cn + <span class="hljs-string">" not found"</span>);<br>    }<br>    <span class="hljs-keyword">if</span> (!service.isAssignableFrom(c)) {<br>        fail(service,<br>             <span class="hljs-string">"Provider "</span> + cn + <span class="hljs-string">" not a subtype"</span>);<br>    }<br>    <span class="hljs-keyword">try</span> {<br>        S p = service.cast(c.newInstance());<br>        providers.put(cn, p);<br>        <span class="hljs-keyword">return</span> p;<br>    } <span class="hljs-keyword">catch</span> (Throwable x) {<br>        fail(service,<br>             <span class="hljs-string">"Provider "</span> + cn + <span class="hljs-string">" could not be instantiated"</span>,<br>             x);<br>    }<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(); <span class="hljs-comment">// This cannot happen</span><br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>小总结？</strong></p>
<ul>
<li>DriverManager本身是使用的启动类加载器</li>
<li>但是启动类加载器无法找到数据库驱动</li>
<li>因此最终还是使用的应用程序加载器</li>
<li>通过 ServiceLoader 利用 Service Provider Interface （<strong>SPI 服务提供接口</strong>）该机制实现
<ul>
<li>jar 包的 META-INF/services 包下，以<strong>接口全限定名</strong>名为文件，<strong>文件内容是实现类名称</strong></li>
<li>遵循SPI接口的就可以利用ServiceLoader 来找到实现类进行类加载的进行</li>
</ul>
</li>
<li>ServiceLoader 内部其实就是使用的<strong>线程上下文加载器</strong>（就是<strong>应用程序加载器</strong>）来加载数据库驱动的实现类</li>
<li>这就破<strong>坏了双亲委派机制</strong>，不是使用启动类加载器加载的，也不遵循从上到下的关系，直接使用了应用程序加载器加载</li>
</ul>
<h3 id="自定义类加载器"><a class="header-anchor" href="#自定义类加载器">¶</a>自定义类加载器</h3>
<p><strong>什么时候需要自定义类加载器？</strong></p>
<ul>
<li>想加载非 classpath <strong>随意路径</strong>中的类文件</li>
<li>都是通过接口来使用实现，希望<strong>解耦</strong>时，常用在<strong>框架设计</strong></li>
<li>这些类希望予以隔离，不同应用的<strong>同名类都可以加载</strong>，不冲突，常见于 <strong>tomcat 容器</strong></li>
</ul>
<p><strong>步骤：</strong></p>
<ol>
<li>继承 ClassLoader 父类</li>
<li>要<strong>遵从双亲委派机制</strong>，重写 findClass 方法</li>
<li>注意不是重写 loadClass 方法，否则不会走双亲委派机制</li>
<li>读取类文件的字节码</li>
<li>调用父类的 defineClass 方法来加载类</li>
<li>使用者调用该类加载器的 loadClass 方法</li>
</ol>
<p>示例：</p>
<p>准备好两个类文件放入 E:\myclasspath，它实现了 java.util.Map 接口</p>
<p><strong>判断类是否完全一致？</strong></p>
<ul>
<li>全限定类名一致</li>
<li>类加载器一致</li>
<li>不同类加载器相互隔离，不会冲突</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Load7</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        MyClassLoader classLoader = <span class="hljs-keyword">new</span> MyClassLoader();<br>        Class&lt;?&gt; c1 = classLoader.loadClass(<span class="hljs-string">"MapImpl1"</span>);<br>        Class&lt;?&gt; c2 = classLoader.loadClass(<span class="hljs-string">"MapImpl1"</span>);<br>        System.out.println(c1 == c2); <span class="hljs-comment">// true</span><br><br>        MyClassLoader classLoader2 = <span class="hljs-keyword">new</span> MyClassLoader();<br>        Class&lt;?&gt; c3 = classLoader2.loadClass(<span class="hljs-string">"MapImpl1"</span>);<br>        System.out.println(c1 == c3); <span class="hljs-comment">// false</span><br><br>        c1.newInstance();<br>    }<br>}<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>{<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// name 就是类名称</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException {<br>        String path = <span class="hljs-string">"e:\\myclasspath\\"</span> + name + <span class="hljs-string">".class"</span>;<br><br>        <span class="hljs-keyword">try</span> {<br>            ByteArrayOutputStream os = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>            Files.copy(Paths.get(path), os);<br><br>            <span class="hljs-comment">// 得到字节数组</span><br>            <span class="hljs-keyword">byte</span>[] bytes = os.toByteArray();<br><br>            <span class="hljs-comment">// byte[] -&gt; *.class</span><br>            <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);<br><br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(<span class="hljs-string">"类文件未找到"</span>, e);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="6、运行期优化"><a class="header-anchor" href="#6、运行期优化">¶</a>6、运行期优化</h2>
<h3 id="即时编译器-JIT"><a class="header-anchor" href="#即时编译器-JIT">¶</a>即时编译器 JIT</h3>
<h4 id="分层编译"><a class="header-anchor" href="#分层编译">¶</a>分层编译</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JIT1</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) {<br>            <span class="hljs-keyword">long</span> start = System.nanoTime(); <br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) { <br>                <span class="hljs-keyword">new</span> Object();<br>            }<br>            <span class="hljs-keyword">long</span> end = System.nanoTime();<br>            System.out.printf(<span class="hljs-string">"%d\t%d\n"</span>,i,(end - start)); <br>        }<br>    } <br>}<br></code></pre></td></tr></tbody></table></figure>
<p>会发现，时间会越来越短！</p>
<p><strong>原因如下：</strong></p>
<p>JVM 将执行状态分成了 5 个层次：</p>
<ul>
<li>0层：解释执行，用解释器将字节码翻译为机器码</li>
<li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li>
<li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用 C2 即时编译器编译执行</li>
</ul>
<p><strong>proﬁling</strong> 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p>
<h5 id="即时编译器（JIT）与解释器的区别"><a class="header-anchor" href="#即时编译器（JIT）与解释器的区别">¶</a>即时编译器（JIT）与解释器的区别</h5>
<ul>
<li>解释器
<ul>
<li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行<strong>重复</strong>的解释</li>
<li>是将字节码解释为针对所有平台都<strong>通用</strong>的机器码</li>
</ul>
</li>
<li>即时编译器
<ul>
<li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，<strong>无需再编译</strong></li>
<li>根据平台类型，生成平台<strong>特定</strong>的机器码</li>
</ul>
</li>
</ul>
<p><strong>策略？</strong></p>
<ul>
<li>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；</li>
<li>另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。</li>
<li>执行效率上简单比较一下 Interpreter（解释器） &lt; C1（JIT） &lt; C2（JIT），总的目标是发现热点代码（hotspot名称的由来），并优化这些热点代码</li>
</ul>
<p>刚才的一种优化手段称之为【逃逸分析】，发现新建的对象是否逃逸。可以使用 -XX:-DoEscapeAnalysis 关闭逃逸分析，再运行刚才的示例观察结果</p>
<h5 id="逃逸分析"><a class="header-anchor" href="#逃逸分析">¶</a>逃逸分析</h5>
<p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以<strong>分析新创建对象的使用范围</strong>，并决定<strong>是否在 Java 堆上</strong>分配内存的一项技术!</p>
<ul>
<li>通过逃逸分析的对象，可将对象直接在栈上分配，而非堆上，极大降低了GC次数，从而提升整体执行效率</li>
</ul>
<p>逃逸分析的 JVM 参数如下：</p>
<ul>
<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>
<li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li>
<li>显示分析结果：-XX:+PrintEscapeAnalysis</li>
</ul>
<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p>
<p><strong>对象逃逸状态</strong></p>
<ul>
<li><strong>全局逃逸（GlobalEscape）</strong>
<ul>
<li>即一个对象的作用范围逃出了<strong>当前方法或者当前线程</strong>，有以下几种场景：
<ul>
<li>对象是一个静态变量</li>
<li>对象是一个已经发生逃逸的对象</li>
<li>对象作为当前方法的返回值</li>
</ul>
</li>
</ul>
</li>
<li><strong>参数逃逸（ArgEscape）</strong>
<ul>
<li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li>
</ul>
</li>
<li><strong>没有逃逸</strong>
<ul>
<li>即方法中的对象没有发生逃逸</li>
</ul>
</li>
</ul>
<p><strong>逃逸分析优化</strong></p>
<p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p>
<p><strong>1、锁消除</strong></p>
<p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会<strong>移除</strong>该对象的同步锁</p>
<p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p>
<p>锁消除的 JVM 参数如下：</p>
<ul>
<li>开启锁消除：-XX:+EliminateLocks</li>
<li>关闭锁消除：-XX:-EliminateLocks</li>
</ul>
<p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p>
<p><strong>2、标量替换</strong></p>
<p>首先要明白标量和聚合量：</p>
<ul>
<li>
<p><strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们<strong>不能被进一步分解</strong>。</p>
</li>
<li>
<p>而能被进一步分解的量就是<strong>聚合量</strong>，比如：对象，对象是聚合量，它又<strong>可以被进一步分解成标量</strong></p>
</li>
<li>
<p>将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p>
</li>
</ul>
<p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在<strong>栈或者寄存器上</strong>创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p>
<p>标量替换的 JVM 参数如下：</p>
<ul>
<li>开启标量替换：-XX:+EliminateAllocations</li>
<li>关闭标量替换：-XX:-EliminateAllocations</li>
<li>显示标量替换详情：-XX:+PrintEliminateAllocations</li>
</ul>
<p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p>
<p><strong>3、栈上分配</strong></p>
<p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，<strong>随着栈帧出栈时销毁</strong>，减少了 GC 压力，提高了应用程序性能。</p>
<h3 id="方法内联"><a class="header-anchor" href="#方法内联">¶</a>方法内联</h3>
<p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i)</span> </span>{ <br>    <span class="hljs-keyword">return</span> i * i;<br>}<br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(square(<span class="hljs-number">9</span>));<br></code></pre></td></tr></tbody></table></figure>
<p>如果发现 square 是热点方法，并且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝、粘贴到调用者的位置：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">9</span> * <span class="hljs-number">9</span>);<br></code></pre></td></tr></tbody></table></figure>
<p>还能够进行<strong>常量折叠</strong>（constant folding）的优化</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">81</span>);<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>-XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining （解锁隐藏参数）打印inlining 信息</li>
<li>-XX:CompileCommand=dontinline,<code>*</code>JIT2.square：<code>*</code>代表任意包，类名.方法名，禁止某个方法 inlining</li>
<li>-XX:+PrintCompilation 打印编译信息</li>
</ul>
<h5 id="JVM内联函数"><a class="header-anchor" href="#JVM内联函数">¶</a>JVM内联函数</h5>
<p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。</p>
<p>Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>{  <br>    <span class="hljs-comment">// to do something  </span><br>}<br></code></pre></td></tr></tbody></table></figure>
<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p>
<p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p>
<p>第二个原因则更重要：<strong>方法内联</strong></p>
<p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>{ <br>    <span class="hljs-comment">//这里调用了add2方法</span><br>    <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);  <br>}  <br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2)</span> </span>{  <br>    <span class="hljs-keyword">return</span> x1 + x2;  <br>}<br></code></pre></td></tr></tbody></table></figure>
<p>方法调用被替换后</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>{  <br>    <span class="hljs-comment">//被替换为了方法本身</span><br>    <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;  <br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="反射优化"><a class="header-anchor" href="#反射优化">¶</a>反射优化</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reflect1</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{<br>        System.out.println(<span class="hljs-string">"foo..."</span>);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>{<br>        Method foo = Demo3.class.getMethod(<span class="hljs-string">"foo"</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">16</span>; i++) {<br>            foo.invoke(<span class="hljs-keyword">null</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p>
<ul>
<li>内部是调用的native方法，效率偏低</li>
</ul>
<p>invoke方法源码</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,InvocationTargetException</span>{<br>    <span class="hljs-keyword">if</span> (!override) {<br>        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {<br>            Class&lt;?&gt; caller = Reflection.getCallerClass();<br>            checkAccess(caller, clazz, obj, modifiers);<br>        }<br>    }<br>    <span class="hljs-comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span><br>    MethodAccessor ma = methodAccessor;             <span class="hljs-comment">// read volatile</span><br>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-keyword">null</span>) {<br>        ma = acquireMethodAccessor();<br>    }<br>    <span class="hljs-keyword">return</span> ma.invoke(obj, args);<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p>
<p><strong>NativeMethodAccessorImpl源码：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeMethodAccessorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MethodAccessorImpl</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method method;<br>    <span class="hljs-keyword">private</span> DelegatingMethodAccessorImpl parent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numInvocations;<br><br>    NativeMethodAccessorImpl(Method var1) {<br>        <span class="hljs-keyword">this</span>.method = var1;<br>    }<br><br>    <span class="hljs-comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span><br>    <span class="hljs-comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object var1, Object[] var2)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>{<br>        <span class="hljs-keyword">if</span> (++<span class="hljs-keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="hljs-keyword">this</span>.method.getDeclaringClass())) {<br>            &nbsp;<span class="hljs-comment">// 使用 ASM 动态生成的新实现代替本地实现，速度较本地实现快    20 倍左右</span><br>            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="hljs-keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="hljs-keyword">this</span>.method.getDeclaringClass(), <span class="hljs-keyword">this</span>.method.getName(), <span class="hljs-keyword">this</span>.method.getParameterTypes(), <span class="hljs-keyword">this</span>.method.getReturnType(), <span class="hljs-keyword">this</span>.method.getExceptionTypes(), <span class="hljs-keyword">this</span>.method.getModifiers());<br>            <span class="hljs-keyword">this</span>.parent.setDelegate(var3);<br>        }<br>		<span class="hljs-comment">// 调用本地实现</span><br>        <span class="hljs-keyword">return</span> invoke0(<span class="hljs-keyword">this</span>.method, var1, var2);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParent</span><span class="hljs-params">(DelegatingMethodAccessorImpl var1)</span> </span>{<br>        <span class="hljs-keyword">this</span>.parent = var1;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">invoke0</span><span class="hljs-params">(Method var0, Object var1, Object[] var2)</span></span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ReflectionFactory.inflationThreshold()方法的返回值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> inflationThreshold = <span class="hljs-number">15</span>;<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>一开始if条件不满足，就会调用本地方法invoke0</li>
<li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率
<ul>
<li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li>
</ul>
</li>
</ul>
<p><strong>注意：通过查看   ReflectionFactory 源码可知</strong></p>
<ul>
<li>sun.reﬂect.noInﬂation 可以用来禁用膨胀（直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算）</li>
<li>sun.reﬂect.inﬂationThreshold 可以修改膨胀阈值</li>
</ul>
<h1 id="五、内存模型"><a class="header-anchor" href="#五、内存模型">¶</a>五、内存模型</h1>
<h2 id="1、Java-内存模型"><a class="header-anchor" href="#1、Java-内存模型">¶</a>1、Java 内存模型</h2>
<p>很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java Memory Model（JMM）的意思。</p>
<p>简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障</p>
<ul>
<li>原子性 - 保证指令不会受到线程上下文切换的影响</li>
<li>可见性 - 保证指令不会受 cpu 缓存的影响</li>
<li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li>
</ul>
<p><strong>内存模型如下：</strong></p>
<ul>
<li>主内存</li>
<li>工作内存</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/17/69979e1c38516743c6bac5036c4c6a1b.png" alt=""></p>
<h2 id="2、原子性"><a class="header-anchor" href="#2、原子性">¶</a>2、原子性</h2>
<h3 id="问题提出"><a class="header-anchor" href="#问题提出">¶</a>问题提出</h3>
<p>问题提出，两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p>
<h3 id="问题分析"><a class="header-anchor" href="#问题分析">¶</a>问题分析</h3>
<p><strong>以上的结果可能是正数、负数、零。<strong>为什么呢？因为 Java 中对静态变量的自增，自减并</strong>不是原子操作</strong>。</p>
<ul>
<li>静态变量：将静态变量放到操作数栈运算iadd</li>
<li>非静态变量自增：iinc在slot直接自增</li>
</ul>
<p>例如对于 i++ 而言（i 为静态变量）实际会产生如下的 JVM 字节码指令：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic &nbsp; &nbsp; i  <span class="hljs-comment">// 获取静态变量i的值 </span><br>iconst_1 &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 准备常量1</span><br>iadd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 加法</span><br>putstatic &nbsp; &nbsp; i <span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></td></tr></tbody></table></figure>
<p>而对应 i-- 也类似：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic &nbsp; &nbsp; i  <span class="hljs-comment">// 获取静态变量i的值 </span><br>iconst_1 &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 准备常量1</span><br>isub &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 减法</span><br>putstatic &nbsp; &nbsp; i <span class="hljs-comment">// 将修改后的值存入静态变量i</span><br></code></pre></td></tr></tbody></table></figure>
<p>而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和线程内存中进行数据交换：</p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/17/69979e1c38516743c6bac5036c4c6a1b.png" alt=""></p>
<p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatic &nbsp; &nbsp; i  <span class="hljs-comment">// 线程1-获取静态变量i的值    线程内i=0 </span><br>iconst_1 &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程1-准备常量1</span><br>iadd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程1-自增    线程内i=1</span><br>putstatic &nbsp; &nbsp; i  <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1 </span><br>getstatic &nbsp; &nbsp; i  <span class="hljs-comment">// 线程1-获取静态变量i的值    线程内i=1</span><br>iconst_1 &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程1-准备常量1 </span><br>isub &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程1-自减    线程内i=0</span><br>putstatic &nbsp; &nbsp; i <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=0</span><br></code></pre></td></tr></tbody></table></figure>
<p><strong>但多线程下这 8 行代码可能交错运行！</strong></p>
<p>出现负数的情况：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatic &nbsp; &nbsp; i <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0 </span><br>getstatic &nbsp; &nbsp; i <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0 </span><br>iconst_1 &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程1-准备常量1</span><br>iadd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程1-自增    线程内i=1</span><br>putstatic &nbsp; &nbsp; i  <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1 </span><br>iconst_1 &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程2-准备常量1</span><br>isub &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程2-自减    线程内i=-1</span><br>putstatic &nbsp; &nbsp; i <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></code></pre></td></tr></tbody></table></figure>
<p>出现正数的情况：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatic &nbsp; &nbsp; i <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0 </span><br>getstatic &nbsp; &nbsp; i <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0 </span><br>iconst_1 &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程1-准备常量1</span><br>iadd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程1-自增    线程内i=1 </span><br>iconst_1 &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程2-准备常量1 </span><br>isub &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程2-自减    线程内i=-1</span><br>putstatic &nbsp; &nbsp; i  <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1 </span><br>putstatic &nbsp; &nbsp; i  <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="问题解决"><a class="header-anchor" href="#问题解决">¶</a>问题解决</h3>
<p><strong>synchronized（同步关键字）</strong></p>
<p><strong>注意</strong>：上例中 t1 和 t2 线程必须用 synchronized 锁住同一个 obj 对象，如果 t1 锁住的是 m1 对象，t2 锁住的是 m2 对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。</p>
<ul>
<li>可以优化synchronized关键字放到循环外，可以将加解锁monitor操作降低为一次</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{ <br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) { <br>            <span class="hljs-keyword">synchronized</span> (obj) {<br>                i++; <br>            }<br>        } <br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) { <br>            <span class="hljs-keyword">synchronized</span> (obj) {<br>                i--; <br>            }<br>        }<br>    });<br>    t1.start(); <br>    t2.start();<br>    t1.join(); <br>    t2.join();<br>    System.out.println(i); <br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="3、可见性"><a class="header-anchor" href="#3、可见性">¶</a>3、可见性</h2>
<h3 id="退不出的循环"><a class="header-anchor" href="#退不出的循环">¶</a>退不出的循环</h3>
<p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{ <br>    Thread t = <span class="hljs-keyword">new</span> Thread(()-&gt;{<br>        <span class="hljs-keyword">while</span>(run){ <br>            <span class="hljs-comment">// .... </span><br>        }<br>    });<br>    t.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    run = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来 </span><br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>为什么呢？分析一下：</strong></p>
<ul>
<li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/17/99e92cac4fe9cc2e9b583a4cd14afcdd.png" alt=""></p>
<ul>
<li>因为 t 线程要<strong>频繁</strong>从主内存中读取 <strong>run 的值</strong>，JIT 编译器会将 run 的值<strong>缓存</strong>至自己工作内存中的<strong>高速缓存</strong>中，减少对主存中 run 的访问，提高效率</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/17/6ae835697471041240631d06e8452e1c.png" alt=""></p>
<ul>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是<strong>旧值</strong></li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/17/ba6ed6d226ef92d1f9107b146fbd6dfc.png" alt=""></p>
<h3 id="问题解决-2"><a class="header-anchor" href="#问题解决-2">¶</a>问题解决</h3>
<p><strong>volatile（易变关键字）</strong></p>
<ul>
<li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong></li>
<li>他可以<strong>避免</strong>线程从自己的<strong>工作缓存</strong>中查找变量的值，<strong>必须到主存</strong>中获取它的值，线程操作 volatile 变量都是直接操作主存</li>
</ul>
<h3 id="可见性"><a class="header-anchor" href="#可见性">¶</a>可见性</h3>
<p>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，<strong>一个线程对 volatile 变量的修改对另一个线程可见</strong></p>
<ul>
<li><strong>不能保证原子性</strong></li>
<li><strong>仅用在一个写线程，多个读线程的情况</strong></li>
<li><strong>不能解决指令交错</strong></li>
</ul>
<p>上例从字节码理解是这样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">getstatic &nbsp; &nbsp; run &nbsp; <span class="hljs-comment">// 线程    t 获取    run true</span><br>getstatic &nbsp; &nbsp; run &nbsp; <span class="hljs-comment">// 线程    t 获取    run true</span><br>getstatic &nbsp; &nbsp; run &nbsp; <span class="hljs-comment">// 线程    t 获取    run true</span><br>getstatic &nbsp; &nbsp; run &nbsp; <span class="hljs-comment">// 线程    t 获取    run true</span><br>putstatic &nbsp; &nbsp; run  <span class="hljs-comment">//  线程    main 修改    run 为    false，    仅此一次 </span><br>getstatic &nbsp; &nbsp; run &nbsp; <span class="hljs-comment">// 线程    t 获取    run false</span><br></code></pre></td></tr></tbody></table></figure>
<p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i-- ，只能保证看到最新值，<strong>不能解决指令交错</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设i的初始值为0</span><br>getstatic &nbsp; &nbsp; i <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0 </span><br>getstatic &nbsp; &nbsp; i <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0 </span><br>iconst_1 &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程1-准备常量1</span><br>iadd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程1-自增    线程内i=1</span><br>putstatic &nbsp; &nbsp; i  <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1 </span><br>iconst_1 &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程2-准备常量1</span><br>isub &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 线程2-自减    线程内i=-1</span><br>putstatic &nbsp; &nbsp; i <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></code></pre></td></tr></tbody></table></figure>
<p><strong>注意</strong></p>
<ul>
<li><strong>synchronized</strong> 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。但缺点是synchronized是属于重量级操作，<strong>性能相对更低</strong></li>
<li>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？
<ul>
<li><strong>原因：println添加了synchronized关键字，synchronized会保证可见性，因此会破坏JIT的缓存优化</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4_2</span> </span>{<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> run = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>        Thread t = <span class="hljs-keyword">new</span> Thread(()-&gt;{<br>            <span class="hljs-keyword">while</span>(run){<br>                <span class="hljs-comment">// ....</span><br>                System.out.println(<span class="hljs-number">1</span>);<br>            }<br>        });<br>        t.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        run = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>println方法如下，添加了synchronized：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{<br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) {<br>        <span class="hljs-keyword">this</span>.print(x);<br>        <span class="hljs-keyword">this</span>.newLine();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="4、有序性"><a class="header-anchor" href="#4、有序性">¶</a>4、有序性</h2>
<h3 id="诡异的结果"><a class="header-anchor" href="#诡异的结果">¶</a>诡异的结果</h3>
<p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">boolean</span> ready = <span class="hljs-keyword">false</span>; <br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>{ <br>    <span class="hljs-keyword">if</span>(ready) {<br>        r.r1 = num + num; <br>    } <span class="hljs-keyword">else</span> {<br>        r.r1 = <span class="hljs-number">1</span>; <br>    }<br>}<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>{ <br>    num = <span class="hljs-number">2</span>;<br>    ready = <span class="hljs-keyword">true</span>; <br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1</li>
<li>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1</li>
<li>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</li>
<li><strong>情况4</strong>：这种情况下是：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2
<ul>
<li>actor2执行的顺序是乱的</li>
</ul>
</li>
</ul>
<p>这种现象叫做<strong>指令重排</strong>，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现：</p>
<p>借助 java 并发压测工具 jcstress <a target="_blank" rel="noopener external nofollow noreferrer" href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p>
<p>可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。</p>
<h3 id="解决方法"><a class="header-anchor" href="#解决方法">¶</a>解决方法</h3>
<p><strong>volatile 修饰的变量，可以禁用指令重排</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> ready = <span class="hljs-keyword">false</span>; <br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>{ <br>    <span class="hljs-keyword">if</span>(ready) {<br>        r.r1 = num + num; <br>    } <span class="hljs-keyword">else</span> {<br>        r.r1 = <span class="hljs-number">1</span>; <br>    }<br>}<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>{ <br>    num = <span class="hljs-number">2</span>;<br>    ready = <span class="hljs-keyword">true</span>; <br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="有序性理解"><a class="header-anchor" href="#有序性理解">¶</a>有序性理解</h3>
<p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i; <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j;<br><span class="hljs-comment">// 在某个线程内执行如下赋值操作</span><br>i = ...; <span class="hljs-comment">// 较为耗时的操作</span><br>j = ...;<br></code></pre></td></tr></tbody></table></figure>
<p>可以看到，至于是先执行 i  还是  先执行  j ，对最终的结果不会产生影响。所以，上面代码真正执行时会有两种情况：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 情况一</span><br>i = ...; <span class="hljs-comment">// 较为耗时的操作</span><br>j = ...;<br><br><span class="hljs-comment">// 情况二</span><br>j = ...;<br>i = ...; <span class="hljs-comment">// 较为耗时的操作</span><br></code></pre></td></tr></tbody></table></figure>
<p>这种特性称之为『<strong>指令重排</strong>』！</p>
<p>多线程下『指令重排』会影响正确性，例如著名的 **double-checked locking （双检锁）**模式实现单例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>{ <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>{ }<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块 </span><br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-comment">// 为了以防多个线程同时到达此位置进行进行加锁创建对象，可以在锁内再加一层判断</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) {<br>                <span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次 </span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) {<br>                    INSTANCE = <span class="hljs-keyword">new</span> Singleton(); <br>                }<br>            } <br>        }<br>        <span class="hljs-keyword">return</span> INSTANCE; <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>以上的实现特点是：</strong></p>
<ul>
<li>懒惰实例化</li>
<li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li>
<li>但在<strong>多线程环境下，上面的代码是有问题的</strong>，INSTANCE = new Singleton() 对应的字节码为：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">0: new &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // class cn/itcast/jvm/t4/Singleton <br><span class="hljs-number">3</span>: dup<br>4: invokespecial #3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // Method "&lt;init&gt;":()V <br>7: putstatic &nbsp; &nbsp; #4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // Field<br>INSTANCE:Lcn/itcast/jvm/t4/Singleton;<br></code></pre></td></tr></tbody></table></figure>
<p>其中 4 7 两步的顺序不是固定的，也许 jvm 会优化为：</p>
<p>先将引用地址赋值给 INSTANCE 变量后，再执行构造方法，如果两个线程 t1，t2 按如下时间序列执行：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">时间<span class="hljs-number">1</span>  t1 线程执行到    INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>时间<span class="hljs-number">2</span>  t1 线程分配空间，为Singleton对象生成了引用地址（<span class="hljs-number">0</span> 处）<br>时间<span class="hljs-number">3</span>  t1 线程将引用地址赋值给    INSTANCE，这时    INSTANCE != <span class="hljs-keyword">null</span>（<span class="hljs-number">7</span> 处）<br>时间<span class="hljs-number">4</span>  t2 线程进入getInstance() 方法，发现    INSTANCE != <span class="hljs-keyword">null</span>（<span class="hljs-keyword">synchronized</span>块外），直接 <br>返回    INSTANCE<br>时间<span class="hljs-number">5</span>  t1 线程执行Singleton的构造方法（<span class="hljs-number">4</span> 处）<br></code></pre></td></tr></tbody></table></figure>
<p><strong>若 t1 还未完全将构造方法执行完毕</strong>，如果在构造方法中要执行很多初始化操作，那么 <strong>t2 拿到的是将是一个未初始化完毕的单例</strong></p>
<p><strong>解决方法：</strong></p>
<ul>
<li>对 INSTANCE 使用 <strong>volatile</strong> 修饰即可，可以<strong>禁用指令重排</strong></li>
<li>但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</li>
</ul>
<h3 id="happens-before"><a class="header-anchor" href="#happens-before">¶</a>happens-before</h3>
<p>happens-before <strong>规定了哪些写操作对其它线程的读操作可见</strong>，它是<strong>可见性与有序性</strong>的一<strong>套规则</strong>总结。</p>
<p>抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见。</p>
<ul>
<li>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">static</span> Object m = <span class="hljs-keyword">new</span> Object(); <br><br><span class="hljs-keyword">new</span> Thread(()-&gt;{<br>    <span class="hljs-keyword">synchronized</span>(m) { <br>        x = <span class="hljs-number">10</span>;<br>    }<br>},<span class="hljs-string">"t1"</span>).start();<br><span class="hljs-keyword">new</span> Thread(()-&gt;{<br>    <span class="hljs-keyword">synchronized</span>(m) {<br>        System.out.println(x); <br>    }<br>},<span class="hljs-string">"t2"</span>).start();<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>线程对 volatile 变量的写，接下来其它线程对该变量的读可见</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x; <br><br><span class="hljs-keyword">new</span> Thread(()-&gt;{<br>    x = <span class="hljs-number">10</span>;<br>},<span class="hljs-string">"t1"</span>).start(); <br><span class="hljs-keyword">new</span> Thread(()-&gt;{<br>    System.out.println(x); <br>},<span class="hljs-string">"t2"</span>).start();<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>线程 start 前对变量的写，对该线程开始后对该变量的读可见</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x; <br><br>x = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;{<br>    System.out.println(x); <br>},<span class="hljs-string">"t2"</span>).start();<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;{ <br>    x = <span class="hljs-number">10</span>;<br>},<span class="hljs-string">"t1"</span>); <br>t1.start();<br>t1.join();<br>System.out.println(x);<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）
<ul>
<li>这里的打断只是做的标记，t2线程还是可以运行的</li>
<li>t2被打断后由于t1已经对遍历进行了写，因此t2线程是可以读到的，可见</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{ <br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;{<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) {<br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) { <br>                System.out.println(x);<br>                <span class="hljs-keyword">break</span>; <br>            }<br>        }<br>    },<span class="hljs-string">"t2"</span>);<br>    t2.start();<br>    <span class="hljs-keyword">new</span> Thread(()-&gt;{ <br>        <span class="hljs-keyword">try</span> {<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        } <span class="hljs-keyword">catch</span> (InterruptedException e) { <br>            e.printStackTrace();<br>        }<br>        x = <span class="hljs-number">10</span>;<br>        t2.interrupt(); <br>    },<span class="hljs-string">"t1"</span>).start();<br>    <span class="hljs-keyword">while</span>(!t2.isInterrupted()) { <br>        Thread.yield();<br>    }<br>    System.out.println(x);<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</li>
<li>具有<strong>传递性</strong>，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z（hb 即 happens-before）</li>
<li>变量都是指成员变量或静态成员变量</li>
</ul>
<h2 id="5、CAS与原子类"><a class="header-anchor" href="#5、CAS与原子类">¶</a>5、CAS与原子类</h2>
<h3 id="CAS"><a class="header-anchor" href="#CAS">¶</a>CAS</h3>
<p>CAS 即   Compare and Swap，它体现的一种<strong>乐观锁的思想</strong>，也被称之为<strong>无锁并发</strong>！</p>
<p>比如多个线程要对一个共享的整型变量执行 +1 操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要不断尝试 </span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) {<br>    <span class="hljs-keyword">int</span> 旧值 = 共享变量; <span class="hljs-comment">// 比如拿到了当前值 0</span><br>    <span class="hljs-keyword">int</span> 结果 = 旧值 + <span class="hljs-number">1</span>; <span class="hljs-comment">// 在旧值 0 的基础上增加 1 ，正确结果是 1 </span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">&nbsp; &nbsp;这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作废了，这时候 </span><br><span class="hljs-comment">&nbsp; &nbsp;compareAndSwap 返回 false，重新尝试，（重新读取共享变量最新值）直到：</span><br><span class="hljs-comment">&nbsp; &nbsp;compareAndSwap 返回 true，表示我本线程做修改的同时，别的线程没有干扰 </span><br><span class="hljs-comment">&nbsp;*/</span><br>    <span class="hljs-keyword">if</span>( compareAndSwap ( 旧值, 结果 )) { <br>        <span class="hljs-comment">// 成功，退出循环</span><br>    } <br>}<br></code></pre></td></tr></tbody></table></figure>
<p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。<strong>结合 CAS 和 volatile 可以实现无锁并发</strong>，适用于<strong>竞争不激烈、多核 CPU</strong> 的场景下。</p>
<ul>
<li><strong>多核CPU</strong>：
<ul>
<li>若为单核其他线程抢占到后，本线程的CAS就无法抢占CPU进行自旋</li>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
</ul>
</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
<p><strong>CAS 底层</strong>依赖于一个 <strong>Unsafe 类</strong>来直接调用<strong>操作系统底层的 CAS 指令</strong>。</p>
<p>下面是直接使用 Unsafe 对象进行线程安全保护的一个例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> sun.misc.Unsafe; <br><span class="hljs-keyword">import</span> java.lang.reflect.Field; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCAS</span> </span>{<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{ <br>        DataContainer dc = <span class="hljs-keyword">new</span> DataContainer();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">5</span>;&nbsp; &nbsp; &nbsp; &nbsp;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) { <br>                dc.increase();<br>            }<br>        });<br>        t1.start(); <br>        t1.join();<br>        System.out.println(dc.getData()); <br>    }<br>}<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataContainer</span> </span>{<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> DATA_OFFSET;<br>    <span class="hljs-keyword">static</span> { <br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// Unsafe 对象不能直接调用，只能通过反射获得</span><br>            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">"theUnsafe"</span>); <br>            theUnsafe.setAccessible(<span class="hljs-keyword">true</span>);<br>            unsafe = (Unsafe) theUnsafe.get(<span class="hljs-keyword">null</span>);<br>        } <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) { <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);<br>        }<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// data 属性在    DataContainer 对象中的偏移量，用于    Unsafe 直接访问该属性 </span><br>            DATA_OFFSET = unsafe.objectFieldOffset(DataContainer.class.getDeclaredField(<span class="hljs-string">"data"</span>)); <br>        } <span class="hljs-keyword">catch</span> (NoSuchFieldException e) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e); <br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>{ <br>        <span class="hljs-keyword">int</span> oldValue;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) {<br>            <span class="hljs-comment">// 获取共享变量旧值，可以在这一行加入断点，修改    data 调试来加深理解 </span><br>            oldValue = data;<br>            <span class="hljs-comment">// cas 尝试修改    data 为    旧值    + 1，如果期间旧值被别的线程改了，返回    false</span><br>            <span class="hljs-keyword">if</span> (unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, DATA_OFFSET, oldValue, oldValue + <span class="hljs-number">1</span>)) {<br>                <span class="hljs-keyword">return</span>; <br>            }<br>        } <br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrease</span><span class="hljs-params">()</span> </span>{ <br>        <span class="hljs-keyword">int</span> oldValue;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) {<br>            oldValue = data;<br>            <span class="hljs-keyword">if</span> (unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, DATA_OFFSET, oldValue, oldValue - <span class="hljs-number">1</span>)) {<br>                <span class="hljs-keyword">return</span>; <br>            }<br>        } <br>    }<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>{ <br>        <span class="hljs-keyword">return</span> data;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="乐观锁与悲观锁"><a class="header-anchor" href="#乐观锁与悲观锁">¶</a>乐观锁与悲观锁</h3>
<ul>
<li><strong>CAS 是基于乐观锁的思想</strong>：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li>
<li><strong>synchronized 是基于悲观锁的思想</strong>：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>
</ul>
<h3 id="原子操作类"><a class="header-anchor" href="#原子操作类">¶</a>原子操作类</h3>
<p>juc（java.util.concurrent）中提供了原子操作类，可以<strong>提供线程安全的操作</strong>，例如：AtomicInteger、 AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的。</p>
<p>可以使用 AtomicInteger 改写之前的例子：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建原子整数对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{ <br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) {<br>            i.getAndIncrement(); &nbsp;<span class="hljs-comment">// 获取并且自增         i++</span><br>            <span class="hljs-comment">// i.incrementAndGet();  // 自增并且获取         ++i</span><br>        } <br>    });<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) {<br>            i.getAndDecrement(); <span class="hljs-comment">// 获取并且自减         i-- </span><br>        }<br>    });<br>    t1.start(); <br>    t2.start(); <br>    t1.join(); <br>    t2.join();<br>    System.out.println(i);<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="6、synchronized-优化"><a class="header-anchor" href="#6、synchronized-优化">¶</a>6、synchronized 优化</h2>
<p>Java HotSpot 虚拟机中，<strong>每个对象都有对象头</strong>（包括 class 指针和 Mark Word）。</p>
<ul>
<li>Mark Word 平时存储这个对象的<strong>哈希码、分代年龄</strong></li>
<li>当加锁时，这些信息就根据情况被替换为 <strong>标记位、线程锁记录指针、重量级锁指针、线程ID</strong> 等内容</li>
</ul>
<h3 id="轻量级锁"><a class="header-anchor" href="#轻量级锁">¶</a>轻量级锁</h3>
<p>如果一个对象虽然有多线程访问，但<strong>多线程访问的时间是错开</strong>的（也就是<strong>没有竞争</strong>），那么可以使用<strong>轻量级锁来优化</strong>。</p>
<p><strong>这就好比：</strong></p>
<p>学生（线程 A）用课本占座，上了半节课，出门了（CPU时间到），回来一看，发现课本没变，说明没有竞争，继续上他的课。</p>
<p>如果这期间有其它学生（线程 B）来了，会告知（线程A）有并发访问，线程 A 随即<strong>升级为重量级锁</strong>，进入重量级锁的流程。</p>
<p>而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前，把座位用一个铁栅栏围起来</p>
<p>假设有两个方法同步块，<strong>利用同一个对象加锁</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object(); <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>{ <br>    <span class="hljs-keyword">synchronized</span>( obj ) {<br>        <span class="hljs-comment">// 同步块 A </span><br>        method2(); <br>    }<br>}<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>{ <br>    <span class="hljs-keyword">synchronized</span>( obj ) {<br>        <span class="hljs-comment">// 同步块 B </span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>每个线程都的<strong>栈帧</strong>都会包含一个<strong>锁记录的结构</strong>，内部可以存储锁定对象的 <strong>Mark Word</strong></p>
<ul>
<li>对象头的MarkWord 8个字节，存储的信息时很<strong>金贵</strong>的</li>
<li>将对象加锁后，需要将MarkWord的原来旧的信息存储起来，<strong>存到栈帧内</strong></li>
<li>解了锁之后，再将栈帧信息<strong>恢复</strong>到MarkWord</li>
</ul>
<p><strong>下图：</strong></p>
<ul>
<li>指的是<strong>多个线程交错运行</strong>的情况</li>
<li>且两个同步块锁的是一个对象</li>
<li>因此同一个线程是<strong>可以重入</strong>的</li>
</ul>
<p><strong>上面代码过程如下：</strong></p>
<ul>
<li>线程1、2指的是存储数据的栈</li>
<li>对象MarkWord指的是存储数据的堆中的对象头</li>
</ul>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/17/d3790cf0fae5f7938ca3acbc19956d9b.png" alt=""></p>
<h3 id="锁膨胀"><a class="header-anchor" href="#锁膨胀">¶</a>锁膨胀</h3>
<p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争）</p>
<p>这时需要进行<strong>锁膨胀</strong>，<strong>将轻量级锁变为重量级锁</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object(); <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>{ <br>    <span class="hljs-keyword">synchronized</span>( obj ) {<br>        <span class="hljs-comment">// 同步块 </span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>下图：</strong></p>
<ul>
<li>指的是<strong>多个线程发生抢占</strong>的情况</li>
<li>线程2会抢占失败，会将MarkWord的锁记录地址改为重量级锁标记</li>
<li>线程1执行完毕无法通过轻量级锁解锁成功，会唤醒阻塞的线程2</li>
<li>线程2继续抢占锁</li>
</ul>
<p><strong>两个线程执行过程：</strong></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/17/9690af5ec32239c677e8b56df0ec7e06.png" alt=""></p>
<h3 id="重量锁"><a class="header-anchor" href="#重量锁">¶</a>重量锁</h3>
<p><strong>重量级锁竞争</strong>的时候，还可以使用<strong>自旋</strong>来进行<strong>优化</strong>！</p>
<p>如果当前线程<strong>自旋成功</strong>（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等待时间长了划算）</li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<p><strong>自旋重试成功的情况</strong></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/17/d9215beea5edd022585d58f9f9ee3cc5.png" alt=""></p>
<p><strong>自旋重试失败的情况</strong></p>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/17/d7300eeebf43d7e37f212a5162d3acb0.png" alt=""></p>
<h3 id="偏向锁"><a class="header-anchor" href="#偏向锁">¶</a>偏向锁</h3>
<p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p>
<p>Java 6 中引入了<strong>偏向锁</strong>来做进一步<strong>优化</strong>：只有<strong>第一次</strong>使用 CAS 将<strong>线程 ID（不是锁记录地址）</strong> 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。</p>
<ul>
<li><strong>撤销偏向</strong>需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（<strong>STW</strong>）
<ul>
<li>有其他锁竞争</li>
</ul>
</li>
<li>访问对象的 <strong>hashCode</strong> 也会撤销偏向锁
<ul>
<li>对象头无锁状态存的是hashCode</li>
<li>偏向锁时存的是线程ID</li>
<li>另一个线程访问hashCode时，由于对象头没有，因此会撤销偏向锁</li>
</ul>
</li>
<li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，<strong>重偏向</strong>会<strong>重置</strong>对象的 Thread ID</li>
<li>撤销偏向和重偏向都是批量进行的，以类为单位</li>
<li>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</li>
<li>可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</li>
</ul>
<p>可以参考这篇论文：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf">https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf</a></p>
<p><strong>假设有两个方法同步块，利用同一个对象加锁</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object(); <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>{ <br>    <span class="hljs-keyword">synchronized</span>( obj ) {<br>        <span class="hljs-comment">// 同步块 A </span><br>        method2(); <br>    }<br>}<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>{ <br>    <span class="hljs-keyword">synchronized</span>( obj ) {<br>        <span class="hljs-comment">// 同步块    B </span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><img src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/01/17/0f30e000d10c8b04ab4f29255b38c066.png" alt=""></p>
<h2 id="7、其他优化"><a class="header-anchor" href="#7、其他优化">¶</a>7、其他优化</h2>
<h3 id="减少上锁时间"><a class="header-anchor" href="#减少上锁时间">¶</a>减少上锁时间</h3>
<p>同步代码块中尽量短</p>
<ul>
<li>防止轻量级锁升级为重量级锁</li>
</ul>
<h3 id="减少锁的粒度"><a class="header-anchor" href="#减少锁的粒度">¶</a>减少锁的粒度</h3>
<p>将一个锁拆分为多个锁提高并发度，例如：</p>
<ul>
<li>ConcurrentHashMap</li>
<li>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的</li>
<li>LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高</li>
</ul>
<h3 id="锁粗化"><a class="header-anchor" href="#锁粗化">¶</a>锁粗化</h3>
<p>多次循环进入同步块不如同步块内多次循环。</p>
<p>另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> StringBuffer().append(<span class="hljs-string">"a"</span>).append(<span class="hljs-string">"b"</span>).append(<span class="hljs-string">"c"</span>);<br></code></pre></td></tr></tbody></table></figure>
<h3 id="锁消除"><a class="header-anchor" href="#锁消除">¶</a>锁消除</h3>
<p>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。</p>
<h3 id="读写分离"><a class="header-anchor" href="#读写分离">¶</a>读写分离</h3>
<p>直接读不用同步，写的话复制一份进行同步</p>
<ul>
<li>CopyOnWriteArrayList</li>
<li>ConyOnWriteSet</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">ITNXD</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://itnxd.eu.org/posts/43777.html">https://itnxd.eu.org/posts/43777.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://itnxd.eu.org" target="_blank">小牛博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2022/08/06/d625a577df424a8e480bb87940d0debc.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.itnxd.eu.org/gh/niuxvdong/images/img/WeChantQR.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://cdn.itnxd.eu.org/gh/niuxvdong/images/img/WeChantQR.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.itnxd.eu.org/gh/niuxvdong/images/img/AliPayQR.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://cdn.itnxd.eu.org/gh/niuxvdong/images/img/AliPayQR.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/40062.html"><img class="next-cover" src="https://cdn.itnxd.eu.org/gh/niuxvdong/pic/2021/11/27/5d8b1ee0b25fc82e480fff0b66fc87f5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机操作系统 - 详细版</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJVM"><span class="toc-text">一、什么是JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-text">好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-text">比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">二、内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0%E3%80%81%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-text">0、整体结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">1、程序计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-text">2、虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%BE%A8%E6%9E%90"><span class="toc-text">问题辨析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">栈内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%AF%8A%E6%96%AD"><span class="toc-text">线程运行诊断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">3、本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%A0%86"><span class="toc-text">4、堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">堆内存溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E8%AF%8A%E6%96%AD"><span class="toc-text">堆内存诊断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">5、方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0-StringTable"><span class="toc-text">字符串常量池 StringTable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%8B%BC%E6%8E%A5"><span class="toc-text">字符串常量拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#intern%E6%96%B9%E6%B3%95"><span class="toc-text">intern方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-String-%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-text">new String()创建几个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">StringTable 垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringTable-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-text">StringTable 性能调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">直接内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">直接内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E9%87%8A%E6%94%BE%E5%8E%9F%E7%90%86"><span class="toc-text">直接内存回收释放原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E6%98%BE%E7%A4%BA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%AF%B9%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E5%BD%B1%E5%93%8D"><span class="toc-text">禁用显示垃圾回收对直接内存释放影响</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">三、垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="toc-text">1、如何判断对象可以回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-text">五种引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E5%BA%94%E7%94%A8"><span class="toc-text">软引用应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97"><span class="toc-text">软引用引用队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-text">弱引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">2、垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-text">标记清除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86"><span class="toc-text">标记整理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E5%AF%B9%E6%AF%94"><span class="toc-text">复制与标记整理对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">3、分代垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="toc-text">堆内存划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E6%B5%81%E7%A8%8B"><span class="toc-text">GC流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3-JVM-%E5%8F%82%E6%95%B0"><span class="toc-text">相关 JVM 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-%E5%88%86%E6%9E%90"><span class="toc-text">GC 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-text">大对象处理策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-text">线程内存溢出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">4、垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C"><span class="toc-text">串行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial-%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">Serial 回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew-%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">ParNew 回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial-Old-%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">Serial Old 回收器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-text">吞吐量优先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Scavenge-%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">Parallel Scavenge 回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Old-%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">Parallel Old 回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E8%87%AA%E9%80%82%E5%BA%94%E8%B0%83%E8%8A%82%E7%AD%96%E7%95%A5"><span class="toc-text">GC自适应调节策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-text">响应时间优先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-text">参数介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS-%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">CMS 回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">CMS的目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">CMS的缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">默认垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1"><span class="toc-text">G1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5"><span class="toc-text">G1垃圾回收阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection"><span class="toc-text">Young Collection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Young-Collection-CM"><span class="toc-text">Young Collection + CM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mixed-Collection"><span class="toc-text">Mixed Collection</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%BE%A8%E6%9E%90"><span class="toc-text">垃圾回收器辨析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SerialGC"><span class="toc-text">SerialGC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParallelGC"><span class="toc-text">ParallelGC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS"><span class="toc-text">CMS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1-2"><span class="toc-text">G1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8"><span class="toc-text">新生代跨代引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Remark"><span class="toc-text">Remark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-8U20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D"><span class="toc-text">JDK 8U20字符串去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-8u40-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%B1%BB%E5%8D%B8%E8%BD%BD"><span class="toc-text">JDK 8u40 并发标记类卸载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-8u60-%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-text">JDK 8u60 回收巨型对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-9-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E8%B5%B7%E5%A7%8B%E6%97%B6%E9%97%B4%E7%9A%84%E8%B0%83%E6%95%B4"><span class="toc-text">JDK 9 并发标记起始时间的调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-9-%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-text">JDK 9 更高效的回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%B0%83%E4%BC%98"><span class="toc-text">5、垃圾回收器调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E9%A2%86%E5%9F%9F"><span class="toc-text">调优领域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%9B%AE%E6%A0%87"><span class="toc-text">确定目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%BF%AB%E7%9A%84GC%E6%98%AF%E4%B8%8D%E5%8F%91%E7%94%9FGC"><span class="toc-text">最快的GC是不发生GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-text">新生代调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B8%E5%AD%98%E5%8C%BA%E8%B0%83%E4%BC%98"><span class="toc-text">幸存区调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-text">老年代调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-text">四、类加载与字节码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">1、类文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AD%94%E6%95%B0"><span class="toc-text">魔数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC"><span class="toc-text">版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0-2"><span class="toc-text">常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="toc-text">2、字节码指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaP%E5%B7%A5%E5%85%B7"><span class="toc-text">JavaP工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">图解方法执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8BJava%E4%BB%A3%E7%A0%81"><span class="toc-text">原始Java代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6"><span class="toc-text">编译后的字节码文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%BD%BD%E5%85%A5%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-text">常量池载入运行时常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AD%97%E8%8A%82%E7%A0%81%E8%BD%BD%E5%85%A5%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">方法字节码载入方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#main-%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%A7%8B%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%88%86%E9%85%8D%E6%A0%88%E5%B8%A7%E5%86%85%E5%AD%98"><span class="toc-text">main 线程开始运行，分配栈帧内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-text">执行引擎开始执行字节码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90a"><span class="toc-text">字节码分析a++</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="toc-text">条件判断指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-text">循环控制指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">小面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cinit"><span class="toc-text">cinit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init"><span class="toc-text">init</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-text">方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86"><span class="toc-text">多态原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch"><span class="toc-text">try-catch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A-single-catch-%E5%9D%97%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">多 single-catch 块的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multi-catch-%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">multi-catch 的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%AC%81nally"><span class="toc-text">ﬁnally</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%AC%81nally-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">ﬁnally 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#finally-%E4%B8%AD%E7%9A%84-return"><span class="toc-text">finally 中的 return</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%AC%81nally-%E5%AF%B9%E8%BF%94%E5%9B%9E%E5%80%BC%E5%BD%B1%E5%93%8D"><span class="toc-text">ﬁnally 对返回值影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-text">synchronized</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-text">3、编译期处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">默认构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-text">自动拆装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%E5%8F%96%E5%80%BC"><span class="toc-text">泛型集合取值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach"><span class="toc-text">foreach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">switch字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E6%9E%9A%E4%B8%BE"><span class="toc-text">switch枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-with-resources"><span class="toc-text">try-with-resources</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E6%97%B6%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95"><span class="toc-text">方法重写时的桥接方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-text">4、类加载阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-text">验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-text">准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%83%E4%B9%A0"><span class="toc-text">小练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">5、类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">类与类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">启动类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">扩展类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F"><span class="toc-text">双亲委派模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">线程上下文类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96"><span class="toc-text">6、运行期优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8-JIT"><span class="toc-text">即时编译器 JIT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91"><span class="toc-text">分层编译</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%88JIT%EF%BC%89%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">即时编译器（JIT）与解释器的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-text">逃逸分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="toc-text">方法内联</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JVM%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">JVM内联函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96"><span class="toc-text">反射优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">五、内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">1、Java 内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">2、原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%90%E5%87%BA"><span class="toc-text">问题提出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">问题解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">3、可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E4%B8%8D%E5%87%BA%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-text">退不出的循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-2"><span class="toc-text">问题解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">可见性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">4、有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A1%E5%BC%82%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-text">诡异的结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7%E7%90%86%E8%A7%A3"><span class="toc-text">有序性理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#happens-before"><span class="toc-text">happens-before</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">5、CAS与原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">乐观锁与悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB"><span class="toc-text">原子操作类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81synchronized-%E4%BC%98%E5%8C%96"><span class="toc-text">6、synchronized 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80"><span class="toc-text">锁膨胀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E9%94%81"><span class="toc-text">重量锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">偏向锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96"><span class="toc-text">7、其他优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E4%B8%8A%E9%94%81%E6%97%B6%E9%97%B4"><span class="toc-text">减少上锁时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="toc-text">减少锁的粒度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-text">锁粗化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-text">读写分离</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By ITNXD</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">CDN BY <a target="_blank" rel="external nofollow" href="https://www.jsdelivr.com/"><b>jsDelivr</b></a> | HOST BY  <a target="_blank" rel="external nofollow" href="https://vercel.com/"><b>Vercel</b></a> && <a target="_blank" rel="external nofollow" href="https://github.com/"><b>Github</b></a><br><img style="vertical-align:middle" src="https://cdn.itnxd.eu.org/gh/niuxvdong/img/pictures/2022/10/22_19_11_15_202210221911223.png" alt=""> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://beian.miit.gov.cn/"><b>晋ICP备19005025号-2</b></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.itnxd.eu.org/',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://twikoo.itnxd.eu.org/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.itnxd.eu.org/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><div class="aplayer no-destroy" data-id="1551071404" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/6dc9e8f9.js","daovoice")
</script><script>var isChatBtn = true
daovoice('init', {
  app_id: '6dc9e8f9',},{
  launcher: { 
     disableLauncherIcon: isChatBtn // 悬浮 ICON 是否显示
  },
});
daovoice('update');

if (isChatBtn) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      daovoice('show')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: true // 悬浮 ICON 是否显示
        },
      });
    }
    function chatBtnShow () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: false // 悬浮 ICON 是否显示
        },
      });
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>