<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>基于异步的、事件驱动的网络应用程序框架、快速开发高性能、高可靠性的网络服务器和客户端程序Netty介绍 | 小牛博客</title><meta name="keywords" content="Netty,NIO"><meta name="author" content="ITNXD"><meta name="copyright" content="ITNXD"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="¶一、BIO编程 ¶1、I&#x2F;O 模型  I&#x2F;O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能 Java 共支持 3 种网络编程模型 IO 模式：BIO、NIO、AIO Java BIO ： 同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 Ja">
<meta property="og:type" content="article">
<meta property="og:title" content="基于异步的、事件驱动的网络应用程序框架、快速开发高性能、高可靠性的网络服务器和客户端程序Netty介绍">
<meta property="og:url" content="https://www.itnxd.cn/posts/44402.html">
<meta property="og:site_name" content="小牛博客">
<meta property="og:description" content="¶一、BIO编程 ¶1、I&#x2F;O 模型  I&#x2F;O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能 Java 共支持 3 种网络编程模型 IO 模式：BIO、NIO、AIO Java BIO ： 同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 Ja">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/niuxvdong/pic@e915ec1da8f4fd93824ca93a53c42d6c2371d03d/2021/11/02/5a36755da549fd44dd641d57680b154c.png">
<meta property="article:published_time" content="2021-11-01T06:38:06.000Z">
<meta property="article:modified_time" content="2021-11-02T03:11:28.169Z">
<meta property="article:author" content="ITNXD">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="NIO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/niuxvdong/pic@e915ec1da8f4fd93824ca93a53c42d6c2371d03d/2021/11/02/5a36755da549fd44dd641d57680b154c.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/favicon.ico"><link rel="canonical" href="https://www.itnxd.cn/posts/44402"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="H9LW1qdxrkJ55YbkfWulMvpaexxx3Rk0Yo6dVANeNHc"/><meta name="baidu-site-verification" content="code-YglH3DObCb"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8d3bd59bf6303bd5f44677445d369df5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":300,"languages":{"author":"作者: ITNXD","link":"链接: ","source":"来源: 小牛博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基于异步的、事件驱动的网络应用程序框架、快速开发高性能、高可靠性的网络服务器和客户端程序Netty介绍',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-02 11:11:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="/css/my.css"><style type="text/css">#toggle-sidebar {bottom: 80px}</style><link rel="stylesheet" href="//at.alicdn.com/t/font_1828588_zrw9f0qqie.css"><link rel="stylesheet" href="/self/atom-one-light.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="小牛博客" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@2f11f173da64ba6a270c2e93d23e00911b1019d3/2021/02/06/e373babbf340391956b673128a84185d.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">260</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">213</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">30</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/niuxvdong/pic@e915ec1da8f4fd93824ca93a53c42d6c2371d03d/2021/11/02/5a36755da549fd44dd641d57680b154c.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小牛博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">基于异步的、事件驱动的网络应用程序框架、快速开发高性能、高可靠性的网络服务器和客户端程序Netty介绍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-01T06:38:06.000Z" title="发表于 2021-11-01 14:38:06">2021-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-02T03:11:28.169Z" title="更新于 2021-11-02 11:11:28">2021-11-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">29.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>112分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="基于异步的、事件驱动的网络应用程序框架、快速开发高性能、高可靠性的网络服务器和客户端程序Netty介绍"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、BIO编程"><a class="header-anchor" href="#一、BIO编程">¶</a>一、BIO编程</h1>
<h2 id="1、I-O-模型"><a class="header-anchor" href="#1、I-O-模型">¶</a>1、I/O 模型</h2>
<ul>
<li>I/O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</li>
<li>Java 共支持 3 种网络编程模型 IO 模式：<strong>BIO、NIO、AIO</strong></li>
<li><strong>Java BIO ： 同步并阻塞(传统阻塞型)</strong>，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</li>
<li><strong>Java NIO ： 同步非阻塞</strong>，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求就进行处理</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@29defda3efef0e650883e4397cf8c65b92d65ede/2021/11/01/3732838213a7ba45f5480b218471bed6.png" alt=""></p>
<ul>
<li><strong>Java AIO(NIO.2) ： 异步非阻塞</strong>，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于<strong>连接数较多且连接时间较长</strong>的应用</li>
</ul>
<h2 id="2、适用场景分析"><a class="header-anchor" href="#2、适用场景分析">¶</a>2、适用场景分析</h2>
<ul>
<li>BIO 方式适用于<strong>连接数目比较小且固定</strong>的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。</li>
<li>NIO 方式适用于<strong>连接数目多且连接比较短</strong>（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4 开始支持。</li>
<li>AIO 方式使用于<strong>连接数目多且连接比较长</strong>（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。</li>
</ul>
<h2 id="3、BIO-基本介绍"><a class="header-anchor" href="#3、BIO-基本介绍">¶</a>3、BIO 基本介绍</h2>
<ul>
<li>Java BIO 就是传统的 Java IO 编程，其相关的类和接口在 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://java.io">java.io</a></li>
<li>BIO(blocking I/O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器)。</li>
<li>BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解</li>
</ul>
<h2 id="4、BIO-编程流程"><a class="header-anchor" href="#4、BIO-编程流程">¶</a>4、BIO 编程流程</h2>
<ol>
<li>服务器端启动一个 ServerSocket</li>
<li>客户端启动 Socket 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯</li>
<li>客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</li>
<li>如果有响应，客户端线程会等待请求结束后，在继续执行</li>
</ol>
<h2 id="5、BIO-应用实例"><a class="header-anchor" href="#5、BIO-应用实例">¶</a>5、BIO 应用实例</h2>
<h3 id="实例说明"><a class="header-anchor" href="#实例说明">¶</a>实例说明</h3>
<ol>
<li>使用 BIO 模型编写一个服务器端，监听 6666 端口，当有客户端连接时，就启动一个线程与之通讯。</li>
<li>要求使用线程池机制改善，可以连接多个客户端.</li>
<li>服务器端可以接收客户端发送的数据(telnet 方式即可)。</li>
</ol>
<h3 id="代码实现"><a class="header-anchor" href="#代码实现">¶</a>代码实现</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * BIO测试，使用telnet 127.0.0.1 6666 进行测试，连接成功ctrl + ]进入控制！</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-10-25 20:41</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BIOServer</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        <span class="hljs-comment">// 1. 创建线程池</span><br>        ExecutorService threadPool = Executors.newCachedThreadPool();<br>        <span class="hljs-comment">// 2. 有客户端连接连接，就创建一个线程</span><br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);<br>        System.out.println(<span class="hljs-string">"服务器启动了..."</span>);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){<br>            <span class="hljs-comment">// 监听客户端连接</span><br>            System.out.println(<span class="hljs-string">"等待连接...."</span>); <span class="hljs-comment">// accept会阻塞</span><br>            <span class="hljs-keyword">final</span> Socket socket = serverSocket.accept();<br>            System.out.println(<span class="hljs-string">"已经连接到一个客户端！"</span>);<br>            <span class="hljs-comment">// 为客户端创建线程</span><br>            threadPool.execute(()-&gt;{<br>                Handler(socket);<br>            });<br>        }<br>    }<br><br>    <span class="hljs-comment">// 用于处理客户端通信</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handler</span><span class="hljs-params">(Socket socket)</span></span>{<br>        <span class="hljs-keyword">try</span> {<br>            System.out.println(<span class="hljs-string">"线程信息："</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-comment">// 通过socket获取输入流</span><br>            InputStream inputStream = socket.getInputStream();<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){<br>                System.out.println(<span class="hljs-string">"线程信息："</span> + Thread.currentThread().getName());<br><br>                System.out.println(<span class="hljs-string">"等待读 read ..."</span>);<br>                <span class="hljs-keyword">int</span> len = inputStream.read(bytes); <span class="hljs-comment">// read也会阻塞</span><br>                <span class="hljs-keyword">if</span>(len != -<span class="hljs-number">1</span>){<br>                    System.out.println(<span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, len));<br>                }<span class="hljs-keyword">else</span>{<br>                    <span class="hljs-keyword">break</span>;<br>                }<br>            }<br>        }<span class="hljs-keyword">catch</span> (Exception e){<br>            e.printStackTrace();<br>        }<span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 关闭与客户端的连接</span><br>            <span class="hljs-keyword">try</span> {<br>                socket.close();<br>            } <span class="hljs-keyword">catch</span> (IOException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="6、BIO-问题分析"><a class="header-anchor" href="#6、BIO-问题分析">¶</a>6、BIO 问题分析</h2>
<ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。</li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费</li>
</ol>
<h1 id="二、NIO编程"><a class="header-anchor" href="#二、NIO编程">¶</a>二、NIO编程</h1>
<h2 id="1、NIO-基本介绍"><a class="header-anchor" href="#1、NIO-基本介绍">¶</a>1、NIO 基本介绍</h2>
<h3 id="基本介绍"><a class="header-anchor" href="#基本介绍">¶</a>基本介绍</h3>
<ol>
<li>Java NIO 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO(即 New IO)，是<strong>同步非阻塞</strong>的</li>
<li>NIO 相关类都被放在 java.nio 包及子包下，并且对原 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://java.io">java.io</a> 包中的很多类进行改写。</li>
<li><strong>NIO 有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器)</strong></li>
<li>NIO 是 <strong>面向缓冲区 ，或者面向 块 编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络</li>
<li>Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</li>
<li>通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有 10000 个请求过来,根据实际情况，可以分配50 或者 100 个线程来处理。不像之前的阻塞 IO 那样，非得分配 10000 个。</li>
<li>HTTP2.0 使用了<strong>多路复用</strong>的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 HTTP1.1 大了好几个数量级</li>
</ol>
<h3 id="小案例"><a class="header-anchor" href="#小案例">¶</a>小案例</h3>
<p><strong>NIO buffer的简单使用：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicBuffer</span> </span>{<br><br>    <span class="hljs-comment">// Buffer使用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        <span class="hljs-comment">// 创建一个Buffer 可存放5个int</span><br>        IntBuffer intBuffer = IntBuffer.allocate(<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 放入数据</span><br>        <span class="hljs-comment">//intBuffer.put(10);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intBuffer.capacity(); i++) {<br>            intBuffer.put(i);<br>        }<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         将buffer读写转换 小标初始化为0</span><br><span class="hljs-comment">         public Buffer flip() {</span><br><span class="hljs-comment">            limit = position; // 当前上限就是插入的数据量</span><br><span class="hljs-comment">            position = 0;</span><br><span class="hljs-comment">            mark = -1;</span><br><span class="hljs-comment">            return this;</span><br><span class="hljs-comment">        }</span><br><span class="hljs-comment">         */</span><br>        intBuffer.flip();<br>        <span class="hljs-comment">// 设置从索引为1开始读取</span><br>        intBuffer.position(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 设置上限下标为3，即小标 &lt; 3</span><br>        intBuffer.limit(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">while</span>(intBuffer.hasRemaining()){<br>            System.out.println(intBuffer.get());<br>        }<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="2、NIO-和-BIO-的比较"><a class="header-anchor" href="#2、NIO-和-BIO-的比较">¶</a>2、NIO 和 BIO 的比较</h2>
<ol>
<li>BIO 以<strong>流的方式</strong>处理数据,而 NIO 以<strong>块的方式</strong>处理数据,块 I/O 的效率比流 I/O 高很多</li>
</ol>
<ol start="2">
<li>BIO 是阻塞的，NIO 则是<strong>非阻塞</strong>的</li>
<li>BIO 基于<strong>字节流和字符流</strong>进行操作，而 NIO 基于 **Channel(通道)和 Buffer(缓冲区)**进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</li>
</ol>
<h2 id="3、NIO-三大核心原理示意图"><a class="header-anchor" href="#3、NIO-三大核心原理示意图">¶</a>3、NIO 三大核心原理示意图</h2>
<p><strong>一张图描述 NIO 的 Selector 、 Channel 和 Buffer 的关系：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@9a4bcaa7c7fe8b62b809b7de645919e7b2c675c0/2021/11/01/1442e1a9271b1394f089af8aae0e881b.png" alt=""></p>
<p><strong>简单说明：</strong></p>
<ol>
<li>每个 channel 都会对应一个 Buffer</li>
<li>Selector 对应一个线程， 一个线程对应多个 channel(连接)</li>
<li>该图反应了有三个 channel 注册到 该 selector</li>
<li>程序切换到哪个 channel 是有事件决定的, Event 就是一个重要的概念</li>
<li>Selector 会根据不同的事件，在各个通道上切换</li>
<li>Buffer 就是一个内存块 ， 底层是有一个数组</li>
<li>数据的读取写入是通过 Buffer, 这个和 BIO , BIO 中要么是输入流，或者是输出流, 不能双向，但是 NIO 的 Buffer 是可以读也可以写, 需要 flip 方法切换channel 是双向的, 可以返回底层操作系统的情况, 比如 Linux ， 底层的操作系统通道就是双向的.</li>
</ol>
<h2 id="4、缓冲区-Buffer"><a class="header-anchor" href="#4、缓冲区-Buffer">¶</a>4、缓冲区 Buffer</h2>
<h3 id="基本介绍-2"><a class="header-anchor" href="#基本介绍-2">¶</a>基本介绍</h3>
<p><strong>缓冲区（Buffer）</strong>：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个容器对象(含数组)，该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer，</p>
<h3 id="Buffer-类及其子类"><a class="header-anchor" href="#Buffer-类及其子类">¶</a>Buffer 类及其子类</h3>
<ul>
<li>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类, 类的层级关系图：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@d8e47f71bf278f388adad6b2e46918c90e2acebc/2021/11/01/b3518ccd029e026d73efabc5f43c5e8b.png" alt=""></p>
<ul>
<li>Buffer 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@8750f2792bc0274d5f73ae58e0cac9164ff8d8ac/2021/11/01/d5ac82aa972b1b9267aa90c592a88e8d.png" alt=""></p>
<ul>
<li>Buffer 类相关方法一览：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@9fe5fe87d873c89a955b58fa32d350d926115b14/2021/11/01/44078b911e56e29466e13abd52e7a067.png" alt=""></p>
<h3 id="ByteBuffer"><a class="header-anchor" href="#ByteBuffer">¶</a>ByteBuffer</h3>
<p>从前面可以看出对于 Java 中的基本数据类型(boolean 除外)，都有一个 Buffer 类型与之相对应，最常用的自然是 ByteBuffer 类（二进制数据），该类的主要方法如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@4bb5caa313e68196093899e017b07fbd19210597/2021/11/01/38fa516dbe45924b5b41e12decfd0c44.png" alt=""></p>
<h2 id="5、通道-Channel"><a class="header-anchor" href="#5、通道-Channel">¶</a>5、通道 Channel</h2>
<h3 id="基本介绍-3"><a class="header-anchor" href="#基本介绍-3">¶</a>基本介绍</h3>
<ol>
<li>NIO 的通道类似于流，但有些区别如下：</li>
<li>通道可以<strong>同时进行读写</strong>，而流只能读或者只能写</li>
<li>通道可以实现<strong>异步读写</strong>数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:</li>
<li>BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)是双向的，可以读操作，也可以写操作。</li>
<li>Channel 在 NIO 中是一个接口 <code>public interface Channel extends Closeable{}</code></li>
<li>常 用 的 Channel 类 有 ： FileChannel 、 DatagramChannel 、 ServerSocketChannel 和 SocketChannel 。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</li>
<li><strong>FileChannel 用于文件的数据读写，DatagramChannel 用于 UDP 的数据读写，ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写。</strong></li>
</ol>
<h3 id="FileChannel-类"><a class="header-anchor" href="#FileChannel-类">¶</a>FileChannel 类</h3>
<p>FileChannel 主要用来对本地文件进行 IO 操作，常见的方法有：</p>
<ol>
<li>public int read(ByteBuffer dst) ，从通道读取数据并放到缓冲区中</li>
<li>public int write(ByteBuffer src) ，把缓冲区的数据写到通道中</li>
<li>public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道中复制数据到当前通道</li>
<li>public long transferTo(long position, long count, WritableByteChannel target)，把数据从当前通道复制给目标通道</li>
</ol>
<h3 id="本地文件写数据"><a class="header-anchor" href="#本地文件写数据">¶</a>本地文件写数据</h3>
<p>使用 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 “hello, 你好！” 写入到 file.txt 中：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel01</span> </span>{<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * byteBuffer -&gt; fileChannel -&gt; fileOutputStream -&gt; 文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> FileNotFoundException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        String str = <span class="hljs-string">"hello, 你好！"</span>;<br>        <span class="hljs-comment">// 创建输出流</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"E:\\file.txt"</span>));<br>        <span class="hljs-comment">// 通过输出流获取对应的FileChannel，真正实现是FileChannelImpl</span><br>        FileChannel fileChannel = fos.getChannel();<br>        <span class="hljs-comment">// 创建缓冲区</span><br>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-comment">// 将字符串放入buffer</span><br>        byteBuffer.put(str.getBytes());<br><br>        <span class="hljs-comment">// 将byteBuffer反转初始化position为读</span><br>        byteBuffer.flip();<br>        <span class="hljs-comment">// 将buffer写入到Channel</span><br>        fileChannel.write(byteBuffer);<br><br>        <span class="hljs-comment">// 关闭流</span><br>        fos.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="本地文件读数据"><a class="header-anchor" href="#本地文件读数据">¶</a>本地文件读数据</h3>
<p>使用 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 file.txt 中的数据读入到程序，并显示在控制台屏幕：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel02</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        <span class="hljs-comment">// 创建文件输入流</span><br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"E:\\file.txt"</span>);<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(file);<br>        <span class="hljs-comment">// 通过输入流获取对应的FileChannel，真正实现是FileChannelImpl</span><br>        FileChannel fileChannel = fis.getChannel();<br>        <span class="hljs-comment">// 创建缓冲区</span><br>        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="hljs-keyword">int</span>) file.length());<br>        <span class="hljs-comment">// 将channel读取到buffer</span><br>        fileChannel.read(byteBuffer);<br><br>        <span class="hljs-comment">// 将字节转换成字符串</span><br>        System.out.println(<span class="hljs-keyword">new</span> String(byteBuffer.array()));<br>        <span class="hljs-comment">// 关闭流</span><br>        fis.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="本地文件读写数据"><a class="header-anchor" href="#本地文件读写数据">¶</a>本地文件读写数据</h3>
<p>使用 FileChannel(通道) 和 方法 read , write，完成文件的拷贝！</p>
<p>拷贝一个文本文件 1.txt , 放在项目下即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel03</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"1.txt"</span>);<br>        FileChannel fileChannel01 = fis.getChannel();<br><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"2.txt"</span>);<br>        FileChannel fileChannel02 = fos.getChannel();<br><br>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">512</span>);<br><br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            每次循环进行重置复位</span><br><span class="hljs-comment">            public Buffer clear() {</span><br><span class="hljs-comment">                position = 0;</span><br><span class="hljs-comment">                limit = capacity;</span><br><span class="hljs-comment">                mark = -1;</span><br><span class="hljs-comment">                return this;</span><br><span class="hljs-comment">            }</span><br><span class="hljs-comment">            若不复位，则position=limit=文件的字节数，下次再进行读的话下标已经到达limit</span><br><span class="hljs-comment">            的可读的最大值，因此读不到东西返回read=0，后面再次flip将会再次将两个变量</span><br><span class="hljs-comment">            赋值为文件字节数，因此变成了死循环！</span><br><span class="hljs-comment">             */</span><br>            byteBuffer.clear();<br>            <span class="hljs-comment">// 读到buffer</span><br>            <span class="hljs-keyword">int</span> read = fileChannel01.read(byteBuffer);<br>            <span class="hljs-keyword">if</span>(read == -<span class="hljs-number">1</span>){<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-comment">// 写到channel02 继而写到2.txt</span><br>            byteBuffer.flip();<br>            fileChannel02.write(byteBuffer);<br>        }<br><br>        <span class="hljs-comment">// 关闭流</span><br>        fis.close();<br>        fos.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="拷贝文件-transferFrom-方法"><a class="header-anchor" href="#拷贝文件-transferFrom-方法">¶</a>拷贝文件 transferFrom 方法</h3>
<p>使用 FileChannel(通道) 和 方法 transferFrom ，完成文件的拷贝：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOFileChannel04</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        <span class="hljs-comment">// 创建流</span><br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"E:\\a.jpg"</span>);<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"E:\\b.jpg"</span>);<br>        <span class="hljs-comment">// 创建Channel</span><br>        FileChannel source = fis.getChannel();<br>        FileChannel dest = fos.getChannel();<br><br>        <span class="hljs-comment">// 直接使用：将source复制到dest</span><br>        dest.transferFrom(source, <span class="hljs-number">0</span>, source.size());<br><br>        <span class="hljs-comment">// 关闭相关流和Channel</span><br>        fis.close();<br>        fos.close();<br>        source.close();<br>        dest.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="6、Buffer-和-Channel-细节"><a class="header-anchor" href="#6、Buffer-和-Channel-细节">¶</a>6、Buffer 和 Channel 细节</h2>
<ul>
<li>ByteBuffer 支持类型化的 put 和 get, put 放入的是什么数据类型，get 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOByteBufferPutGet</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">255</span>);<br><br>        byteBuffer.putInt(<span class="hljs-number">33</span>);<br>        byteBuffer.putLong(<span class="hljs-number">22</span>);<br>        byteBuffer.putChar(<span class="hljs-string">'牛'</span>);<br>        byteBuffer.putShort((<span class="hljs-keyword">short</span>) <span class="hljs-number">4</span>);<br><br>        byteBuffer.flip();<br><br>        System.out.println(byteBuffer.getInt());<br>        System.out.println(byteBuffer.getLong());<br>        System.out.println(byteBuffer.getChar());<br>        <span class="hljs-comment">//System.out.println(byteBuffer.getShort());</span><br>        <span class="hljs-comment">// 抛出异常：short 2个字节要4个字节读，无法读取</span><br>        System.out.println(byteBuffer.getInt());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>可以将一个普通 Buffer 转成只读 Buffer</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadOnlyBuffer</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) {<br>            byteBuffer.put((<span class="hljs-keyword">byte</span>) i);<br>        }<br>        byteBuffer.flip();<br>        <span class="hljs-comment">// 创建只读的buffer</span><br>        ByteBuffer readOnlyBuffer = byteBuffer.asReadOnlyBuffer();<br>        <span class="hljs-comment">// class java.nio.HeapByteBufferR</span><br>        System.out.println(readOnlyBuffer.getClass());<br>        <span class="hljs-comment">// 读取</span><br>        <span class="hljs-keyword">while</span>(readOnlyBuffer.hasRemaining()){<br>            System.out.println(readOnlyBuffer.get());<br>        }<br>        <span class="hljs-comment">// 只读buffer，无法写入数据了 抛出 ReadOnlyBufferException</span><br>        readOnlyBuffer.put((<span class="hljs-keyword">byte</span>) <span class="hljs-number">100</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>NIO 还提供了 <code>MappedByteBuffer</code>， 可以让文件直接在内存（<strong>堆外的内存</strong>）中进行修改， 而如何同步到文件由 NIO 来完成</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MappedByteBufferTest</span> </span>{<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * MappedByteBuffer 可让文件直接在内存(堆外内存)修改, 操作系统不需要拷贝一次</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        RandomAccessFile randomAccessFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">"1.txt"</span>, <span class="hljs-string">"rw"</span>);<br>        FileChannel fileChannel = randomAccessFile.getChannel();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 参数 1: FileChannel.MapMode.READ_WRITE 使用的读写模式</span><br><span class="hljs-comment">         * 参数 2： 0 ： 可以直接修改的起始位置</span><br><span class="hljs-comment">         * 参数 3: 5: 是映射到内存的大小(不是索引位置) ,即将 1.txt 的多少个字节映射到内存</span><br><span class="hljs-comment">         * 可以直接修改的范围就是 0-5</span><br><span class="hljs-comment">         * 实际类型 DirectByteBuffer</span><br><span class="hljs-comment">         */</span><br>        MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        mappedByteBuffer.put(<span class="hljs-number">0</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">'H'</span>);<br>        mappedByteBuffer.put(<span class="hljs-number">3</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">'9'</span>);<br>        <span class="hljs-comment">// 抛出 IndexOutOfBoundsException</span><br>        mappedByteBuffer.put(<span class="hljs-number">5</span>, (<span class="hljs-keyword">byte</span>) <span class="hljs-string">'Y'</span>);<br><br>        randomAccessFile.close();<br>        fileChannel.close();<br>        <span class="hljs-comment">// 在文件管理器打开查看，IDEA没有刷新</span><br>        System.out.println(<span class="hljs-string">"修改成功！"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>前面的读写操作，都是通过一个 Buffer 完成的，NIO 还支持 通过多个 Buffer (即 Buffer 数组) 完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScatteringAndGatheringTest</span> </span>{<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散]</span><br><span class="hljs-comment">     * Gathering: 从 buffer 读取数据时，可以采用 buffer 数组，依次读</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        <span class="hljs-comment">// 使用 ServerSocketChannel SocketChannel</span><br>        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br>        InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">7000</span>);<br>        <span class="hljs-comment">// socket绑定端口7000</span><br>        serverSocketChannel.socket().bind(inetSocketAddress);<br><br>        <span class="hljs-comment">// 创建buffer数组</span><br>        ByteBuffer[] byteBuffers = <span class="hljs-keyword">new</span> ByteBuffer[<span class="hljs-number">2</span>];<br>        byteBuffers[<span class="hljs-number">0</span>] = ByteBuffer.allocate(<span class="hljs-number">5</span>);<br>        byteBuffers[<span class="hljs-number">1</span>] = ByteBuffer.allocate(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 等待客户端连接</span><br>        SocketChannel socketChannel = serverSocketChannel.accept();<br>        <span class="hljs-keyword">int</span> msgLen = <span class="hljs-number">8</span>;<br>        <span class="hljs-comment">// 循环读取</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){<br>            <span class="hljs-keyword">int</span> byteRead = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(byteRead &lt; msgLen){<br>                <span class="hljs-comment">// 读到buffer</span><br>                <span class="hljs-keyword">long</span> i = socketChannel.read(byteBuffers);<br>                <span class="hljs-comment">// 统计累积读取字节数</span><br>                byteRead += i;<br>                System.out.println(<span class="hljs-string">"byteRead = "</span> + byteRead);<br>                <span class="hljs-comment">// 使用流打印 buffer的position和limit</span><br>                Arrays.stream(byteBuffers).map(buffer-&gt;<br>                        <span class="hljs-string">"position="</span>+buffer.position()+<span class="hljs-string">" limit="</span>+buffer.limit())<br>                        .forEach(System.out::println);<br>            }<br>            <span class="hljs-comment">// 将buffer数据进行flip</span><br>            Arrays.asList(byteBuffers).forEach(ByteBuffer::flip);<br><br>            <span class="hljs-comment">// 将数据回显到客户端</span><br>            <span class="hljs-keyword">long</span> byteWrite = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(byteWrite &lt; msgLen){<br>                <span class="hljs-keyword">long</span> i = socketChannel.write(byteBuffers);<br>                byteWrite += i;<br>            }<br><br>            <span class="hljs-comment">// 将所有buffer clear</span><br>            Arrays.asList(byteBuffers).forEach(ByteBuffer::clear);<br><br>            System.out.println(<span class="hljs-string">"byteRead = "</span> + byteRead + <span class="hljs-string">" byteWrite = "</span> +<br>                    byteWrite + <span class="hljs-string">" msgLen = "</span> + msgLen);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="7、选择器-Selector"><a class="header-anchor" href="#7、选择器-Selector">¶</a>7、选择器 Selector</h2>
<h3 id="基本介绍-4"><a class="header-anchor" href="#基本介绍-4">¶</a>基本介绍</h3>
<ol>
<li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 Selector(选择器)</li>
<li>Selector 能够检测多个注册的通道上是否有事件发生(注意：多个 Channel 以事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</li>
<li>只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</li>
<li>避免了多线程之间的上下文切换导致的开销</li>
</ol>
<h3 id="Selector示意图"><a class="header-anchor" href="#Selector示意图">¶</a>Selector示意图</h3>
<ol>
<li>Netty 的 IO 线程 NioEventLoop 聚合了 Selector(选择器，也叫多路复用器)，可以同时并发处理成百上千个客户端连接。</li>
<li>当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li>
<li>线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。</li>
<li>由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 I/O 阻塞导致的线程挂起。</li>
<li>一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@09ea3d095ce85cf7ac8a0d83f5611cba99684b1e/2021/11/01/7c1525a53f949603587d8ccd436b2be4.png" alt=""></p>
<h3 id="Selector-类相关方法"><a class="header-anchor" href="#Selector-类相关方法">¶</a>Selector 类相关方法</h3>
<p><strong>Selector 类是一个抽象类, 常用方法和说明如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@a4e2e15295d408b6a62408414d3eeb7a815eb7b4/2021/11/01/4c5673686ee98194df35b78897759d05.png" alt=""></p>
<h3 id="注意事项"><a class="header-anchor" href="#注意事项">¶</a>注意事项</h3>
<ul>
<li>NIO 中的 ServerSocketChannel 功能类似 ServerSocket，SocketChannel 功能类似 Socket</li>
<li>selector 相关方法说明
<ul>
<li>selector.select()：阻塞</li>
<li>selector.select(1000)：阻塞 1000 毫秒，在 1000 毫秒后返回</li>
<li>selector.wakeup()：唤醒 selector</li>
<li>selector.selectNow()：不阻塞，立马返还</li>
</ul>
</li>
</ul>
<h2 id="8、NIO-非阻塞网络编程"><a class="header-anchor" href="#8、NIO-非阻塞网络编程">¶</a>8、NIO 非阻塞网络编程</h2>
<h3 id="原理分析图"><a class="header-anchor" href="#原理分析图">¶</a>原理分析图</h3>
<p>NIO 非阻塞 网络编程相关的(Selector、SelectionKey、ServerScoketChannel 和 SocketChannel) 关系梳理图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@5f7087c33cffaf9693fc9a1ce1fa045f38731858/2021/11/01/5ab85f05ff675f6cb1f771aebf818483.png" alt=""></p>
<p><strong>简单说明：</strong></p>
<ol>
<li>
<p>当客户端连接时，会通过 ServerSocketChannel 得到 SocketChannel</p>
</li>
<li>
<p>Selector 进行监听 select 方法, 返回有事件发生的通道的个数.</p>
</li>
<li>
<p>将 socketChannel 注册到 Selector 上, register(Selector sel, int ops), 一个 selector 上可以注册多个 SocketChannel</p>
</li>
<li>
<p>注册后返回一个 SelectionKey, 会和该 Selector 关联(集合)</p>
</li>
<li>
<p>进一步得到各个 SelectionKey (有事件发生)</p>
</li>
<li>
<p>在通过 SelectionKey 反向获取 SocketChannel , 方法 channel()</p>
</li>
<li>
<p>可以通过得到的 channel , 完成业务处理</p>
</li>
</ol>
<h3 id="案例实现"><a class="header-anchor" href="#案例实现">¶</a>案例实现</h3>
<p>编写一个 NIO 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</p>
<p>注释属实详细，可以参考！</p>
<p><strong>Server端：</strong></p>
<p><strong>注意：ServerSocketChannel和SocketChannel都要设置为非阻塞模式！</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * SelectionKey.OP_READ：读就绪事件。表示通道中已经有了可读的数据:可以执行读操作了(通道目前有数据。可以进行读操作了）</span><br><span class="hljs-comment"> * SelectionKey.OP_WRITE：写就绪事件。表示已经可以向通道写数据了(通道目前可以用于写操作)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 注册两次Channel:</span><br><span class="hljs-comment"> *  1. ServerSocketChannel：服务器端与Selector的关联，用于监听客户端的连接请求accept()</span><br><span class="hljs-comment"> *  2. SocketChannel：客户端与Selector的关联，Selector用于监听客户端的accept、read、write等请求</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  selector.keys(): 返回此选择器的键集。（所有key）</span><br><span class="hljs-comment"> *  selector.selectedKeys: 返回此选择器的选定键集。（有事件发生的key）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-10-26 19:12</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOServer</span> </span>{<br><br>    <span class="hljs-comment">// 一个selector多个channel</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br><br>        <span class="hljs-comment">// 创建ServerSocketChannel</span><br>        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br>        <span class="hljs-comment">// 创建Selector</span><br>        Selector selector = Selector.open();<br><br>        <span class="hljs-comment">// 绑定端口6666,在服务器端监听</span><br>        serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">6666</span>));<br>        <span class="hljs-comment">// 1. 设置为非阻塞</span><br>        serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-comment">// 服务端与Selector之间的ServerSocketChannel也要注册到Selector（类似Socket的accept进行监听）</span><br>        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-comment">// 得到selector上注册的key数量（所有key）</span><br>        System.out.println(<span class="hljs-string">"注册后selectionKey的数量："</span> + selector.keys().size());<br><br>        <span class="hljs-comment">// 循环等待客户端连接</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){<br>            <span class="hljs-comment">// 为0说明当前没有任何事件在serverSocketChannel上发生</span><br>            <span class="hljs-keyword">if</span>(selector.select(<span class="hljs-number">1000</span>) == <span class="hljs-number">0</span>){<br>                System.out.println(<span class="hljs-string">"服务器等待了一秒，无连接...."</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-comment">// 否则说明有事件监听，获取到有事件发生的集合 通过SelectionKey关联 channel 和 selector</span><br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br><br>            <span class="hljs-comment">// 获取所有有事件发生的selectionKey</span><br>            System.out.println(<span class="hljs-string">"有事件发生的selectionKey数量为："</span> + selectionKeys.size());<br><br>            <span class="hljs-comment">// 遍历selectionKeys</span><br>            <span class="hljs-comment">// selectionKeys.forEach(System.out::println);</span><br>            <span class="hljs-keyword">for</span> (SelectionKey selectionKey : selectionKeys) {<br>                <span class="hljs-comment">// 根据key的不同事件类型进行分别操作</span><br>                <span class="hljs-comment">// accept事件：有客户端连接，获取到连接的socketChannel注册到Selector等待操作</span><br>                <span class="hljs-keyword">if</span>(selectionKey.isAcceptable()){<br>                    <span class="hljs-comment">// 生成一个客户端的socketChannel，连接事件与其他事件不同，直接通过serverSocketChannel获取socketChannel</span><br>                    <span class="hljs-comment">// accept方法是阻塞的，但是这里是确定了有客户端连接才accept，因此是非阻塞的</span><br>                    SocketChannel socketChannel = serverSocketChannel.accept();<br><br>                    System.out.println(<span class="hljs-string">"客户端连接成功，生成了一个socketChannel "</span><br>                            + socketChannel.hashCode());<br><br>                    <span class="hljs-comment">// 2. 将SocketChannel设置为非阻塞模式</span><br>                    socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br><br>                    <span class="hljs-comment">// 将SocketChannel注册到selector上，同时关联一个Buffer（用于记录连接信息）</span><br>                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="hljs-number">1024</span>));<br><br>                    <span class="hljs-comment">// 客户端连接一个，总数量key +1</span><br>                    System.out.println(<span class="hljs-string">"客户端连接后，注册的selectionKey的数量："</span> + selector.keys().size());<br>                }<br>                <span class="hljs-keyword">if</span>(selectionKey.isReadable()){ <span class="hljs-comment">// read事件：客户端的read事件</span><br>                    <span class="hljs-comment">// 通过selectionKey反向获取到对应的客户端Channel，向下转型为SocketChannel</span><br>                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();<br><br>                    <span class="hljs-comment">// 可以通过interestOps设置为写事件</span><br>                    <span class="hljs-comment">// selectionKey.interestOps(SelectionKey.OP_WRITE);</span><br><br>                    <span class="hljs-comment">// 获取到 channel关联的buffer</span><br>                    ByteBuffer byteBuffer = (ByteBuffer) selectionKey.attachment();<br>                    <span class="hljs-comment">// 通过 channel 将数据读到 buffer</span><br>                    socketChannel.read(byteBuffer);<br>                    System.out.println(<span class="hljs-string">"from 客户端 "</span> + <span class="hljs-keyword">new</span> String(byteBuffer.array()));<br>                }<br>                <span class="hljs-comment">// 手动从集合中移动当前的 selectionKey, 防止重复操作</span><br>                selectionKeys.remove(selectionKey);<br>            }<br>        }<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>Client端：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOClient</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br><br>        <span class="hljs-comment">// 获取客户端与Selector之间的SocketChannel</span><br>        SocketChannel socketChannel = SocketChannel.open();<br>        <span class="hljs-comment">// 设置非阻塞</span><br>        socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">// 提供服务器端ip和端口</span><br>        InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6666</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         连接服务器 不会发生阻塞</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         如果此通道处于非阻塞模式，则调用此方法将启动非阻塞连接操作。</span><br><span class="hljs-comment">         如果立即建立连接（本地连接可能发生这种情况），则此方法返回 true。</span><br><span class="hljs-comment">         否则，此方法返回 false，并且稍后必须通过调用 finishConnect 方法来完成连接操作。</span><br><span class="hljs-comment">         如果此通道处于阻塞模式，则此方法的调用将阻塞，直到建立连接或发生 I/O 错误。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         简而言之：立即连接成功返回true，否则返回false，直到finishConnect返回true!</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span>(!socketChannel.connect(inetSocketAddress)){<br>            <span class="hljs-comment">// 未完成连接</span><br>            <span class="hljs-keyword">while</span>(!socketChannel.finishConnect()){<br>                System.out.println(<span class="hljs-string">"因连接需要时间，客户端不会阻塞，可以做其他工作..."</span>);<br>            }<br>        }<br><br>        <span class="hljs-comment">// 连接成功，发送数据</span><br>        String str = <span class="hljs-string">"hello, 世界！"</span>;<br>        <span class="hljs-comment">// 通过字符串大小自动指定buffer，自动完成创建buffer</span><br>        ByteBuffer byteBuffer = ByteBuffer.wrap(str.getBytes());<br>        <span class="hljs-comment">// 发送数据，将buffer数据写到channel</span><br>        socketChannel.write(byteBuffer);<br><br>        <span class="hljs-comment">// 阻塞</span><br>        System.in.read();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="9、几大组件介绍"><a class="header-anchor" href="#9、几大组件介绍">¶</a>9、几大组件介绍</h2>
<h3 id="SelectionKey"><a class="header-anchor" href="#SelectionKey">¶</a>SelectionKey</h3>
<p><strong>SelectionKey，表示 Selector 和网络通道的注册关系, 共四种：</strong></p>
<ul>
<li>int OP_ACCEPT：有新的网络连接可以 accept，值为 16</li>
<li>int OP_CONNECT：代表连接已经建立，值为 8</li>
<li>int OP_READ：代表读操作，值为 1</li>
<li>int OP_WRITE：代表写操作，值为 4</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_READ = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_WRITE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_CONNECT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OP_ACCEPT = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br></code></pre></td></tr></tbody></table></figure>
<p><strong>SelectionKey 相关方法：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@2aa3f948c99353084ef01cf8fef028907514772e/2021/11/01/6472933473279fa62e491cbb7a6c3ab6.png" alt=""></p>
<h3 id="ServerSocketChannel"><a class="header-anchor" href="#ServerSocketChannel">¶</a>ServerSocketChannel</h3>
<p>ServerSocketChannel 在服务器端监听新的客户端 Socket 连接：</p>
<p><strong>相关方法如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@0ae8ff7f6eaf01e2e9a90aa52ac8844e5b047626/2021/11/01/37709676e8cc96a27db47b04c8315836.png" alt=""></p>
<h3 id="SocketChannel"><a class="header-anchor" href="#SocketChannel">¶</a>SocketChannel</h3>
<p>SocketChannel，网络 IO 通道，具体负责进行读写操作。NIO 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</p>
<p><strong>相关方法如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@4cc989510bbf8a7886111db008dd150a2fc1c155/2021/11/01/2fef4113ca684419fc1e24d2c709cf0d.png" alt=""></p>
<h2 id="10、NIO实现群聊系统"><a class="header-anchor" href="#10、NIO实现群聊系统">¶</a>10、NIO实现群聊系统</h2>
<h3 id="实例要求"><a class="header-anchor" href="#实例要求">¶</a>实例要求</h3>
<ol>
<li>编写一个 NIO 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(有服务器转发得到)</li>
<li>示意图分析和代码</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@95d954cd364b6a0e9d5d865432c51c5c81351805/2021/11/01/0354086eb4eaebfa8df32c11ccba6549.png" alt=""></p>
<h3 id="服务器端"><a class="header-anchor" href="#服务器端">¶</a>服务器端</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 群聊系统服务器端！</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 处理是单线程的，只有一个main线程！</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-10-27 14:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServer</span> </span>{<br><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> ServerSocketChannel listenChannel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造器初始化工作！</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatServer</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 1. 得到selector</span><br>            selector = Selector.open();<br>            <span class="hljs-comment">// 2. 得到ServerSocketChannel</span><br>            listenChannel = ServerSocketChannel.open();<br>            <span class="hljs-comment">// 3. 绑定端口</span><br>            listenChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(PORT));<br>            <span class="hljs-comment">// 4. 设置为非阻塞模式</span><br>            listenChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 5. 将ServerSocketChannel注册到Selector</span><br>            listenChannel.register(selector, SelectionKey.OP_ACCEPT);<br>        }<span class="hljs-keyword">catch</span> (IOException e){<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务器监听方法！</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span></span>{<br>        System.out.println(<span class="hljs-string">"监听线程："</span> + Thread.currentThread().getName());<br><br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 循环处理</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){<br>                <span class="hljs-comment">// int count = selector.select(2000);</span><br>                <span class="hljs-comment">// 直接取消超时属性，没有连接阻塞即可</span><br>                System.out.println(<span class="hljs-string">"服务器端等待客户端连接..."</span>);<br>                <span class="hljs-comment">// select方法不添加超时属性，则会在读不到通道事件发生时一致阻塞！</span><br>                selector.select();<br>                <span class="hljs-comment">// 遍历selectionKeys</span><br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                <span class="hljs-keyword">for</span> (SelectionKey selectionKey : selectionKeys) {<br>                    <span class="hljs-comment">// 处理连接事件</span><br>                    <span class="hljs-keyword">if</span>(selectionKey.isAcceptable()){<br>                        <span class="hljs-comment">// 获取到socketChannel</span><br>                        SocketChannel socketChannel = listenChannel.accept();<br>                        <span class="hljs-comment">// 设置为非阻塞模式</span><br>                        socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>                        <span class="hljs-comment">// 注册到selector</span><br>                        socketChannel.register(selector, SelectionKey.OP_READ);<br><br>                        <span class="hljs-comment">// 给出提示，xxx上线了！substring(1)去掉地址前的斜杠</span><br>                        System.out.println(socketChannel.getRemoteAddress().toString().substring(<span class="hljs-number">1</span>) + <span class="hljs-string">"上线了..."</span>);<br>                    }<br>                    <span class="hljs-comment">// 处理可读事件</span><br>                    <span class="hljs-keyword">if</span>(selectionKey.isReadable()){<br>                        readData(selectionKey);<br>                    }<br>                    <span class="hljs-comment">// 移除当前key，防止重复处理</span><br>                    selectionKeys.remove(selectionKey);<br>                }<br>            }<br>        } <span class="hljs-keyword">catch</span> (Exception e) {<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务端读取客户端消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 传入有事件发生的SelectionKey</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readData</span><span class="hljs-params">(SelectionKey key)</span></span>{<br>        SocketChannel socketChannel = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// 得到SocketChannel和buffer</span><br>            socketChannel = (SocketChannel) key.channel();<br>            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-comment">// 读取客户端消息到buffer</span><br>            <span class="hljs-keyword">int</span> count = socketChannel.read(byteBuffer);<br>            <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>){<br>                String msg = <span class="hljs-keyword">new</span> String(byteBuffer.array());<br>                System.out.println(<span class="hljs-string">"from 客户端："</span> + msg);<br><br>                <span class="hljs-comment">// 向其他客户端(不包括自己)转发消息</span><br>                sendInfoToOtherClients(msg, socketChannel);<br>            }<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            <span class="hljs-comment">// 有异常，说明当前客户端已经离线</span><br>            <span class="hljs-keyword">try</span> {<br>                System.out.println(socketChannel.getRemoteAddress().toString().substring(<span class="hljs-number">1</span>) + <span class="hljs-string">"离线了..."</span>);<br>                <span class="hljs-comment">// 离线则取消注册并关闭通道</span><br>                key.channel();<br>                socketChannel.close();<br>            } <span class="hljs-keyword">catch</span> (IOException ex) {<br>                ex.printStackTrace();<br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 转发消息给其他客户端</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 转发的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> selfChannel 需要排除的自己本身</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfoToOtherClients</span><span class="hljs-params">(String msg, SocketChannel selfChannel)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        System.out.println(<span class="hljs-string">"服务器转发消息中..."</span>);<br>        System.out.println(<span class="hljs-string">"转发线程："</span> + Thread.currentThread().getName());<br><br>        <span class="hljs-comment">// 遍历所有注册到Selector的key并排除自己</span><br>        <span class="hljs-keyword">for</span> (SelectionKey selectionKey : selector.keys()) {<br>            Channel channel = selectionKey.channel();<br>            <span class="hljs-comment">// 排除自己</span><br>            <span class="hljs-keyword">if</span>(channel <span class="hljs-keyword">instanceof</span> SocketChannel &amp;&amp; channel != selfChannel){<br>                SocketChannel socketChannel = (SocketChannel) channel;<br>                <span class="hljs-comment">// 将消息存到buffer</span><br>                ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes());<br>                <span class="hljs-comment">// 将buffer数据写到channel</span><br>                socketChannel.write(byteBuffer);<br>            }<br>        }<br>    }<br><br>    <span class="hljs-comment">// 服务器端逻辑</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><br>        GroupChatServer chatServer = <span class="hljs-keyword">new</span> GroupChatServer();<br>        <span class="hljs-comment">// 监听</span><br>        chatServer.listen();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="客户端"><a class="header-anchor" href="#客户端">¶</a>客户端</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 群聊系统客户端！</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 客户端也需要一个selector 用来处理服务器端转发来的消息！</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-10-27 15:35</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClient</span> </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String HOST = <span class="hljs-string">"127.0.0.1"</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">6667</span>;<br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> SocketChannel socketChannel;<br>    <span class="hljs-keyword">private</span> String username;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造器中进行初始化！</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatClient</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">try</span> {<br>            selector = Selector.open();<br>            <span class="hljs-comment">// 连接服务器</span><br>            socketChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(HOST, PORT));<br>            <span class="hljs-comment">// 设置为非阻塞模式</span><br>            socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 注册到selector</span><br>            socketChannel.register(selector, SelectionKey.OP_READ);<br>            <span class="hljs-comment">// /127.0.0.1:4082 去掉第一个斜杠</span><br>            username = socketChannel.getLocalAddress().toString().substring(<span class="hljs-number">1</span>);<br>            System.out.println(username + <span class="hljs-string">" 客户端准备好了...."</span>);<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送消息到服务器端！</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> info 发送的消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendInfo</span><span class="hljs-params">(String info)</span> </span>{<br>        info = username + <span class="hljs-string">" 说："</span> + info;<br><br>        <span class="hljs-keyword">try</span> {<br>            socketChannel.write(ByteBuffer.wrap(info.getBytes()));<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取从服务器端发出的消息！</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readInfo</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">// select方法不添加超时属性，则会在读不到通道事件发生时一致阻塞！</span><br>            selector.select();<br>            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>            <span class="hljs-keyword">for</span> (SelectionKey selectionKey : selectionKeys) {<br>                <span class="hljs-keyword">if</span> (selectionKey.isReadable()) {<br>                    SocketChannel channel = (SocketChannel) selectionKey.channel();<br>                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    <span class="hljs-comment">// 获取到服务器发来消息</span><br>                    channel.read(byteBuffer);<br>                    String msg = <span class="hljs-keyword">new</span> String(byteBuffer.array());<br>                    <span class="hljs-comment">// 去掉消息首尾空格</span><br>                    System.out.println(msg.trim());<br>                }<br>                <span class="hljs-comment">// 溢出当前selectionKey，防止重复操作</span><br>                selectionKeys.remove(selectionKey);<br>            }<br>        } <span class="hljs-keyword">catch</span> (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 两个线程，一个读的线程（new Thread），一个写的线程（main主线程）</span><br><span class="hljs-comment">     * 注意：一定得是两个线程，读的线程在读不到的时候会阻塞，写的操作就无法完成！</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><br>        <span class="hljs-comment">// 启动客户端</span><br>        GroupChatClient chatClient = <span class="hljs-keyword">new</span> GroupChatClient();<br><br>        <span class="hljs-comment">// 客户端读取服务器端发送的消息，若读取数据不启动新的线程</span><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; {<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {<br>                chatClient.readInfo();<br>                <span class="hljs-keyword">try</span> {<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                    e.printStackTrace();<br>                }<br>            }<br>        }).start();<br><br>        <span class="hljs-comment">// 客户端发送消息给客户端</span><br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNextLine()) {<br>            String msg = scanner.nextLine();<br>            chatClient.sendInfo(msg);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="11、NIO-与零拷贝"><a class="header-anchor" href="#11、NIO-与零拷贝">¶</a>11、NIO 与零拷贝</h2>
<h3 id="零拷贝基本介绍"><a class="header-anchor" href="#零拷贝基本介绍">¶</a>零拷贝基本介绍</h3>
<ol>
<li>零拷贝是网络编程的关键，很多性能优化都离不开。</li>
<li>在 Java 程序中，常用的零拷贝有 <strong>mmap(内存映射) 和 sendFile</strong>。那么，他们在 OS 里，到底是怎么样的一个的设计？我们分析 mmap 和 sendFile 这两个零拷贝</li>
<li>另外我们看下 NIO 中如何使用零拷贝</li>
</ol>
<h3 id="传统-IO-模型"><a class="header-anchor" href="#传统-IO-模型">¶</a>传统 IO 模型</h3>
<p><strong>DMA: direct memory access 直接内存拷贝(不使用 CPU)</strong></p>
<p><strong>传统io：四次拷贝，三次切换（用户态和内核态）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@633168d7e88310efab160398cff0b1826eeeb9a6/2021/11/01/d7309b13e0381891ae723363c75eb2f6.png" alt=""></p>
<h3 id="mmap-优化"><a class="header-anchor" href="#mmap-优化">¶</a>mmap 优化</h3>
<p>mmap 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。</p>
<p><strong>mmap：三次拷贝，四次切换</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@2ba096b799bada5ac3f062e6b26cabd55abe8dbf/2021/11/01/b942f876a7a9fc388ee966350ed7f10a.png" alt=""></p>
<h3 id="sendFile-优化"><a class="header-anchor" href="#sendFile-优化">¶</a>sendFile 优化</h3>
<p>Linux 2.1 版本 提供了 sendFile 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换。</p>
<p><strong>sendfile linux2.1：三次拷贝，两次切换</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@831bdff8cabf0c3bbabde49cd7a48a8ebb6c5677/2021/11/01/b1eca553a2c7639b4befcd02ac29ee64.png" alt=""></p>
<p><strong>提示：零拷贝从操作系统角度，是没有 cpu 拷贝</strong></p>
<p>Linux 在 2.4 版本中，做了一些修改，避免了从内核缓冲区拷贝到 Socket buffer 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。</p>
<p>这里其实有 一次 cpu 拷贝 kernel buffer -&gt; socket buffer ，但是，拷贝的信息很少，比如 lenght , offset , 消耗低，可以忽略！</p>
<p><strong>sendfile linux2.4：两次拷贝，两次切换</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@00280216cf5d9fd525821c0e37016414b5a57cac/2021/11/01/a447e15e78bd38f77a1acce122c7349a.png" alt=""></p>
<h3 id="零拷贝的再次理解"><a class="header-anchor" href="#零拷贝的再次理解">¶</a>零拷贝的再次理解</h3>
<ol>
<li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 kernel buffer 有一份数据）。</li>
<li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 CPU 缓存伪共享以及无 CPU 校验和计算。</li>
</ol>
<h3 id="mmap-和-sendFile-的区别"><a class="header-anchor" href="#mmap-和-sendFile-的区别">¶</a>mmap 和 sendFile 的区别</h3>
<ol>
<li><strong>mmap 适合小数据量读写，sendFile 适合大文件传输。</strong></li>
<li>mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 2 次上下文切换，最少 2 次数据拷贝。</li>
<li>sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket 缓冲区）。</li>
</ol>
<h3 id="NIO-零拷贝案例"><a class="header-anchor" href="#NIO-零拷贝案例">¶</a>NIO 零拷贝案例</h3>
<ol>
<li>使用传统的 IO 方法传递一个大文件</li>
<li>使用 NIO 零拷贝方式传递(transferTo)一个大文件</li>
<li>看看两种传递方式耗时时间分别是多少</li>
</ol>
<h4 id="Old"><a class="header-anchor" href="#Old">¶</a>Old</h4>
<p><strong>OldIOServer</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OldIOServer</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">7001</span>);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {<br>            Socket socket = serverSocket.accept();<br>            DataInputStream dataInputStream = <span class="hljs-keyword">new</span> DataInputStream(socket.getInputStream());<br><br>            <span class="hljs-keyword">try</span> {<br>                <span class="hljs-keyword">byte</span>[] byteArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4096</span>];<br><br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {<br>                    <span class="hljs-keyword">int</span> readCount = dataInputStream.read(byteArray, <span class="hljs-number">0</span>, byteArray.length);<br><br>                    <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == readCount) {<br>                        <span class="hljs-keyword">break</span>;<br>                    }<br>                }<br>            } <span class="hljs-keyword">catch</span> (Exception ex) {<br>                ex.printStackTrace();<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>OldIOClient</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发送总字节数： 1007473, 耗时： 21</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OldIOClient</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">7001</span>);<br><br>        String fileName = <span class="hljs-string">"E:\\test.zip"</span>;<br>        InputStream inputStream = <span class="hljs-keyword">new</span> FileInputStream(fileName);<br><br>        DataOutputStream dataOutputStream = <span class="hljs-keyword">new</span> DataOutputStream(socket.getOutputStream());<br><br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4096</span>];<br>        <span class="hljs-keyword">long</span> readCount;<br>        <span class="hljs-keyword">long</span> total = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br><br>        <span class="hljs-keyword">while</span> ((readCount = inputStream.read(buffer)) &gt;= <span class="hljs-number">0</span>) {<br>            total += readCount;<br>            dataOutputStream.write(buffer);<br>        }<br><br>        System.out.println(<span class="hljs-string">"发送总字节数： "</span> + total + <span class="hljs-string">", 耗时： "</span> + (System.currentTimeMillis() - startTime));<br><br>        dataOutputStream.close();<br>        socket.close();<br>        inputStream.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="New"><a class="header-anchor" href="#New">¶</a>New</h4>
<p><strong>NewIOServer</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOServer</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br><br>        InetSocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">7001</span>);<br><br>        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br><br>        ServerSocket socket = serverSocketChannel.socket();<br>        socket.bind(address);<br><br>        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">4096</span>);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){<br>            <span class="hljs-comment">// accept阻塞</span><br>            SocketChannel socketChannel = serverSocketChannel.accept();<br><br>            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(count != -<span class="hljs-number">1</span>){<br>                <span class="hljs-keyword">try</span> {<br>                    count = socketChannel.read(byteBuffer);<br>                } <span class="hljs-keyword">catch</span> (IOException e) {<br>                    e.printStackTrace();<br>                }<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                倒带</span><br><span class="hljs-comment">                public Buffer rewind() {</span><br><span class="hljs-comment">                    position = 0;</span><br><span class="hljs-comment">                    mark = -1;</span><br><span class="hljs-comment">                    return this;</span><br><span class="hljs-comment">                }</span><br><span class="hljs-comment">                 */</span><br>                byteBuffer.rewind();<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>NewIOClient</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIOClient</span> </span>{<br><br>    <span class="hljs-comment">//  发 送 的 总 的 字 节 数 =1007473 耗 时 :5</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{<br>        SocketChannel socketChannel = SocketChannel.open();<br><br>        socketChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">7001</span>));<br><br>        String fileName = <span class="hljs-string">"E:\\test.zip"</span>;<br><br>        FileChannel fileChannel = <span class="hljs-keyword">new</span> FileInputStream(fileName).getChannel();<br><br>        <span class="hljs-comment">// 记录时间</span><br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br><br>        <span class="hljs-comment">// 在 linux 下一个 transferTo 方法就可以完成传输</span><br>        <span class="hljs-comment">// 在 windows 下 一次调用 transferTo 只能发送 8m , 就需要分段传输文件, 而且要主要</span><br>        <span class="hljs-comment">// 传输时的位置 =》 课后思考...</span><br>        <span class="hljs-comment">// transferTo 底层使用到零拷贝</span><br>        <span class="hljs-keyword">long</span> transferCount = fileChannel.transferTo(<span class="hljs-number">0</span>, fileChannel.size(), socketChannel);<br><br>        System.out.println(<span class="hljs-string">" 发 送 的 总 的 字 节 数 ="</span> + transferCount + <span class="hljs-string">" 耗 时 :"</span> + (System.currentTimeMillis() - start));<br>        <span class="hljs-comment">//关闭</span><br>        fileChannel.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="结果"><a class="header-anchor" href="#结果">¶</a>结果</h4>
<ul>
<li>old：21ms</li>
<li>new：5ms</li>
</ul>
<h2 id="12、AIO-基本介绍"><a class="header-anchor" href="#12、AIO-基本介绍">¶</a>12、AIO 基本介绍</h2>
<ol>
<li>JDK 7 引入了 Asynchronous I/O，即 AIO。在进行 I/O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理</li>
<li>AIO 即 NIO2.0，叫做异步不阻塞的 IO。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li>
<li>目前 AIO 还没有广泛应用，Netty 也是基于 NIO, 而不是 AIO， 因此我们就不详解 AIO 了，可以参考 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.52im.net/thread-306-1-1.html">Java 新 一 代 网 络 编 程 模 型 AIO 原 理 及 Linux 系 统 AIO 介绍</a></li>
</ol>
<h2 id="13、BIO、NIO、AIO-对比表"><a class="header-anchor" href="#13、BIO、NIO、AIO-对比表">¶</a>13、BIO、NIO、AIO 对比表</h2>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@f74d4d34d3ffb0eb10516e7984647beeefbfb869/2021/11/01/388c7b3ded2b5cf3c558468d93418c4f.png" alt=""></p>
<h1 id="三、Netty概述"><a class="header-anchor" href="#三、Netty概述">¶</a>三、Netty概述</h1>
<h2 id="1、Netty-介绍"><a class="header-anchor" href="#1、Netty-介绍">¶</a>1、Netty 介绍</h2>
<ol>
<li>Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github 上的独立项目。</li>
<li>Netty 是一个<strong>异步的、基于事件驱动</strong>的网络应用框架，用以快速开发高性能、高可靠性的网络 IO 程序。</li>
<li>Netty 主要针对在 TCP 协议下，面向 Clients 端的高并发应用，或者 Peer-to-Peer 场景下的大量数据持续传输的应用。</li>
<li>Netty 本质是一个 NIO 框架，适用于服务器通讯相关的多种应用场景</li>
</ol>
<h2 id="2、Netty-应用场景"><a class="header-anchor" href="#2、Netty-应用场景">¶</a>2、Netty 应用场景</h2>
<h3 id="互联网行业"><a class="header-anchor" href="#互联网行业">¶</a>互联网行业</h3>
<ol>
<li>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。</li>
<li>典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信</li>
</ol>
<h3 id="游戏行业"><a class="header-anchor" href="#游戏行业">¶</a>游戏行业</h3>
<ol>
<li>无论是手游服务端还是大型的网络游戏，Java 语言得到了越来越广泛的应用</li>
<li>Netty 作为高性能的基础通信组件，提供了 TCP/UDP 和 HTTP 协议栈，方便定制和开发私有协议栈，账号登录服务器</li>
<li>地图服务器之间可以方便的通过 Netty 进行高性能的通信</li>
</ol>
<h3 id="大数据领域"><a class="header-anchor" href="#大数据领域">¶</a>大数据领域</h3>
<ol>
<li>经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨界点通信</li>
<li>它的 Netty Service 基于 Netty 框架二次封装实现。</li>
</ol>
<h2 id="3、原生-NIO-存在的问题"><a class="header-anchor" href="#3、原生-NIO-存在的问题">¶</a>3、原生 NIO 存在的问题</h2>
<ol>
<li>NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</li>
<li>需要具备其他的额外技能：要熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。</li>
<li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</li>
<li>JDK NIO 的 Bug：例如臭名昭著的 <strong>Epoll Bug</strong>，它会导致 Selector 空轮询，最终导致 CPU 100%。直到 JDK 1.7版本该问题仍旧存在，没有被根本解决。</li>
</ol>
<h2 id="4、Netty-的优点"><a class="header-anchor" href="#4、Netty-的优点">¶</a>4、Netty 的优点</h2>
<p>Netty 对 JDK 自带的 NIO 的 API 进行了封装，解决了上述问题。</p>
<ol>
<li>设计优雅：适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池. 2) 使用方便：详细记录的 Javadoc，用户指南和示例；没有其他依赖项，JDK 5（Netty 3.x）或 6（Netty 4.x）就足够了。</li>
<li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li>
<li>安全：完整的 SSL/TLS 和 StartTLS 支持。</li>
<li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复，同时，更多的新功能会被加入</li>
</ol>
<h2 id="5、Netty-版本说明"><a class="header-anchor" href="#5、Netty-版本说明">¶</a>5、Netty 版本说明</h2>
<ol>
<li>netty 版本分为 netty3.x 和 netty4.x、netty5.x</li>
<li>因为 Netty5 出现重大 bug，已经被官网废弃了，目前推荐使用的是 Netty4.x 的稳定版本</li>
<li>目前在官网可下载的版本 netty3.x netty4.0.x 和 netty4.1.x</li>
<li>我们使用 Netty4.1.x 版本</li>
<li>netty 下载地址： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://bintray.com/netty/downloads/netty/">https://bintray.com/netty/downloads/netty/</a></li>
</ol>
<h1 id="四、Netty-高性能架构设计"><a class="header-anchor" href="#四、Netty-高性能架构设计">¶</a>四、Netty 高性能架构设计</h1>
<h2 id="1、线程模型基本介绍"><a class="header-anchor" href="#1、线程模型基本介绍">¶</a>1、线程模型基本介绍</h2>
<ol>
<li>不同的线程模式，对程序的性能有很大影响，为了搞清 Netty 线程模式，我们来系统的讲解下 各个线程模式，最后看看 Netty 线程模型有什么优越性.</li>
<li>目前存在的线程模型有：</li>
<li>传统阻塞 I/O 服务模型</li>
<li>Reactor 模式</li>
<li>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现：</li>
<li>单 Reactor 单线程；</li>
<li>单 Reactor 多线程；</li>
<li><strong>主从 Reactor 多线程</strong></li>
<li>Netty 线程模式(Netty 主要基于主从 Reactor 多线程模型做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor)</li>
</ol>
<h2 id="2、传统阻塞-I-O-服务模型"><a class="header-anchor" href="#2、传统阻塞-I-O-服务模型">¶</a>2、传统阻塞 I/O 服务模型</h2>
<h3 id="工作原理图"><a class="header-anchor" href="#工作原理图">¶</a>工作原理图</h3>
<ol>
<li>黄色的框表示对象， 蓝色的框表示线程</li>
<li>白色的框表示方法(API)</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@65329d57f408696f94eaabd3bbdd13b60a98820f/2021/11/01/b555657d6182d01a24c72d485706eaee.png" alt=""></p>
<h3 id="模型特点"><a class="header-anchor" href="#模型特点">¶</a>模型特点</h3>
<ol>
<li>采用阻塞 IO 模式获取输入的数据</li>
<li>每个连接都需要独立的线程完成数据的输入，业务处理, 数据返回</li>
</ol>
<h3 id="问题分析"><a class="header-anchor" href="#问题分析">¶</a>问题分析</h3>
<ol>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源</li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 read 操作，造成线程资源浪费</li>
</ol>
<h2 id="3、Reactor-模式"><a class="header-anchor" href="#3、Reactor-模式">¶</a>3、Reactor 模式</h2>
<p><strong>针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：</strong></p>
<ol>
<li><strong>基于 I/O 复用模型</strong>：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。Reactor 对应的叫法: 1. 反应器模式 2. 分发者模式(Dispatcher) 3. 通知者模式(notifier)</li>
<li><strong>基于线程池复用线程资源</strong>：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li>
</ol>
<p><strong>I/O 复用结合线程池，就是 Reactor 模式基本设计思想：</strong></p>
<ol>
<li>Reactor 模式，通过一个或多个输入同时传递给服务处理器的模式(<strong>基于事件驱动</strong>)</li>
<li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程， 因此 Reactor 模式也叫 Dispatcher模式</li>
<li>Reactor 模式使用 IO 复用监听事件, 收到事件后，分发给某个线程(进程), 这点就是网络服务器高并发处理关键</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@4f9372fda6f1da899af2f8d1e921fa48950c6bba/2021/11/01/5af093743efec5b2a030e28f6013354d.png" alt=""></p>
<p><strong>Reactor 模式核心组成：</strong></p>
<ol>
<li><strong>Reactor</strong>：Reactor 在一个单独的线程中运行，<strong>负责监听和分发事件</strong>，分发给适当的处理程序来对 IO 事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li>
<li><strong>Handlers</strong>：处理程序执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。</li>
</ol>
<p><strong>Reactor 模式分类：</strong></p>
<p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现：</p>
<ol>
<li>单 Reactor 单线程</li>
<li>单 Reactor 多线程</li>
<li><strong>主从 Reactor 多线程</strong></li>
</ol>
<h2 id="4、单-Reactor-单线程"><a class="header-anchor" href="#4、单-Reactor-单线程">¶</a>4、单 Reactor 单线程</h2>
<h3 id="工作原理图-2"><a class="header-anchor" href="#工作原理图-2">¶</a>工作原理图</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@3209f181c320fbe2bc4e52d7291af19aa252c2a3/2021/11/01/282c3b2196244bb4478f7fdb132dac75.png" alt=""></p>
<h3 id="简单说明"><a class="header-anchor" href="#简单说明">¶</a>简单说明</h3>
<ol>
<li>Select 是前面 I/O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求</li>
<li>Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发</li>
<li>如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理</li>
<li>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应</li>
<li>Handler 会完成 Read→业务处理→Send 的完整业务流程</li>
</ol>
<h3 id="方案优缺点分析"><a class="header-anchor" href="#方案优缺点分析">¶</a>方案优缺点分析</h3>
<ol>
<li><strong>优点</strong>：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li>
<li><strong>缺点</strong>：性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li><strong>缺点</strong>：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
<li>使用场景：客户端的数量有限，业务处理非常快速，比如 <strong>Redis</strong> 在业务处理的时间复杂度 O(1) 的情况</li>
</ol>
<h2 id="5、单-Reactor-多线程"><a class="header-anchor" href="#5、单-Reactor-多线程">¶</a>5、单 Reactor 多线程</h2>
<h3 id="工作原理图-3"><a class="header-anchor" href="#工作原理图-3">¶</a>工作原理图</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@bf43e13f2f3042df6864500c145cd8650c2bdde3/2021/11/01/a35c5f36aa50f14ef83487043737448f.png" alt=""></p>
<h3 id="简单说明-2"><a class="header-anchor" href="#简单说明-2">¶</a>简单说明</h3>
<ol>
<li>Reactor 对象通过 select 监控客户端请求事件, 收到事件后，通过 dispatch 进行分发</li>
<li>如果建立连接请求, 则右 Acceptor 通过accept 处理连接请求, 然后创建一个 Handler 对象处理完成连接后的各种事件</li>
<li>如果不是连接请求，则由 reactor 分发调用连接对应的 handler 来处理</li>
<li>handler 只负责响应事件，不做具体的业务处理, 通过 read 读取数据后，会分发给后面的 worker 线程池的某个线程处理业务</li>
<li>worker 线程池会分配独立线程完成真正的业务，并将结果返回给 handler</li>
<li>handler 收到响应后，通过 send 将结果返回给 client</li>
</ol>
<h3 id="方案优缺点分析-2"><a class="header-anchor" href="#方案优缺点分析-2">¶</a>方案优缺点分析</h3>
<ol>
<li><strong>优点</strong>：可以充分的利用多核 cpu 的处理能力</li>
<li><strong>缺点</strong>：多线程数据共享和访问比较复杂， reactor 处理所有的事件的监听和响应，在单线程运行， 在高并发场景容易出现性能瓶颈.</li>
</ol>
<h2 id="6、主从-Reactor-多线程"><a class="header-anchor" href="#6、主从-Reactor-多线程">¶</a>6、主从 Reactor 多线程</h2>
<h3 id="工作原理图-4"><a class="header-anchor" href="#工作原理图-4">¶</a>工作原理图</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@c4eed51c6d7c1143c5988159e9171a3957d04686/2021/11/01/423584d652205c806af1512d1db8fb8a.png" alt=""></p>
<h3 id="简单说明-3"><a class="header-anchor" href="#简单说明-3">¶</a>简单说明</h3>
<ol>
<li>Reactor 主线程 MainReactor 对象通过 select 监听连接事件, 收到事件后，通过 Acceptor 处理连接事件</li>
<li>当 Acceptor 处理连接事件后，MainReactor 将连接分配给 SubReactor</li>
<li>subreactor 将连接加入到连接队列进行监听,并创建 handler 进行各种事件处理</li>
<li>当有新事件发生时， subreactor 就会调用对应的 handler 处理</li>
<li>handler 通过 read 读取数据，分发给后面的 worker 线程处理</li>
<li>worker 线程池分配独立的 worker 线程进行业务处理，并返回结果</li>
<li>handler 收到响应的结果后，再通过 send 将结果返回给 client</li>
<li>Reactor 主线程可以对应多个 Reactor 子线程, 即 MainRecator 可以关联多个 SubReactor</li>
</ol>
<h3 id="方案优缺点分析-3"><a class="header-anchor" href="#方案优缺点分析-3">¶</a>方案优缺点分析</h3>
<ol>
<li><strong>优点</strong>：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li>
<li><strong>优点</strong>：父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</li>
<li><strong>缺点</strong>：编程复杂度较高</li>
<li>结合实例：这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持</li>
</ol>
<h3 id="Reactor-模式小结"><a class="header-anchor" href="#Reactor-模式小结">¶</a>Reactor 模式小结</h3>
<p><strong>用生活案例来理解：</strong></p>
<ol>
<li>单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服</li>
<li>单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待</li>
<li>主从 Reactor 多线程，多个前台接待员，多个服务生</li>
</ol>
<p><strong>Reactor 模式具有如下的优点：</strong></p>
<ol>
<li>响应快，不必为单个同步时间所阻塞，虽然 <strong>Reactor 本身依然是同步的</strong></li>
<li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的<strong>切换开销</strong></li>
<li><strong>扩展性好</strong>，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源</li>
<li>复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ol>
<h2 id="7、Netty-模型"><a class="header-anchor" href="#7、Netty-模型">¶</a>7、Netty 模型</h2>
<h3 id="简单版"><a class="header-anchor" href="#简单版">¶</a>简单版</h3>
<p>Netty 主要基于主从 Reactors 多线程模型（如图）做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor！</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@957016a95afd88b5f0885bf868a0c06f1824c4f4/2021/11/01/e65c0e66c4f66b80a438575678e9af0a.png" alt=""></p>
<p><strong>简单说明：</strong></p>
<ol>
<li>BossGroup 线程维护 Selector , 只关注 Accecpt</li>
<li>当接收到 Accept 事件，获取到对应的 SocketChannel, 封装成 NIOScoketChannel 并注册到 Worker 线程(事件循环), 并进行维护</li>
<li>当 Worker 线程监听到 selector 中通道发生自己感兴趣的事件后，就进行处理(就由 handler)， 注意 handler 已经加入到通道</li>
</ol>
<h3 id="进阶版"><a class="header-anchor" href="#进阶版">¶</a>进阶版</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@e396a1f8540672ee9a932c0eb79faccff4558b30/2021/11/01/f1dca1ed6258f5c80ac9c3e7fa7ff4be.png" alt=""></p>
<h3 id="详细版"><a class="header-anchor" href="#详细版">¶</a>详细版</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@835064609a79d598acfd1354c69eb890ca19b53e/2021/11/01/65fc294793dbb494213b18bf361d9628.png" alt=""></p>
<p><strong>简单说明：</strong></p>
<ol>
<li>
<p>Netty 抽象出两组线程池 BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写</p>
</li>
<li>
<p>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup</p>
</li>
<li>
<p>NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop</p>
</li>
<li>
<p>NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个 NioEventLoop 都有一个 selector , 用于监听绑定在其上的 socket 的网络通讯</p>
</li>
<li>
<p>NioEventLoopGroup 可以有多个线程, 即可以含有多个 NioEventLoop</p>
</li>
<li>
<p>每个 Boss NioEventLoop 循环执行的步骤有 3 步</p>
<ol>
<li>轮询 accept 事件</li>
<li>处理 accept 事件 , 与 client 建立连接 , 生成 NioScocketChannel , 并将其注册到某个 worker NIOEventLoop 上的 selector</li>
<li>处理任务队列的任务 ， 即 runAllTasks</li>
</ol>
</li>
<li>
<p>每个 Worker NIOEventLoop 循环执行的步骤</p>
</li>
<li>
<p>轮询 read, write 事件</p>
</li>
<li>
<p>处理 i/o 事件， 即 read , write 事件，在对应 NioScocketChannel 处理</p>
</li>
<li>
<p>处理任务队列的任务 ， 即 runAllTasks</p>
</li>
<li>
<p>每个Worker NIOEventLoop 处理业务时，会使用pipeline(管道), pipeline 中包含了 channel , 即通过pipeline可以获取到对应通道, 管道中维护了很多的 处理器</p>
</li>
</ol>
<h3 id="TCP服务案例"><a class="header-anchor" href="#TCP服务案例">¶</a>TCP服务案例</h3>
<p><strong>实例要求：</strong></p>
<ul>
<li>Netty 服务器在 6668 端口监听，客户端能发送消息给服务器 “hello, 服务器~”</li>
<li>服务器可以回复消息给客户端 “hello, 客户端~”</li>
</ul>
<p><strong>导入netty的包：</strong></p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.netty/netty-all --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.20.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>
<h4 id="NettyServer"><a class="header-anchor" href="#NettyServer">¶</a>NettyServer</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         1. 创建bossGroup workerGroup</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         说明：</span><br><span class="hljs-comment">            - 创建两个线程组 bossGroup 和 workerGroup</span><br><span class="hljs-comment">            - bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup 完成</span><br><span class="hljs-comment">            - 两个都是无限循环</span><br><span class="hljs-comment">            - bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span><br><span class="hljs-comment">         默认实际 线程数 * 2</span><br><span class="hljs-comment">         */</span><br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>); <span class="hljs-comment">// Boss分配一个线程即可</span><br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">4</span>);<br><br>        <span class="hljs-keyword">try</span> {<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             2. 创建服务端启动对象 ServerBootstrap 并使用链式编程设置参数</span><br><span class="hljs-comment">                 - 设置两个线程组</span><br><span class="hljs-comment">                 - 使用NioServerSocketChannel作为服务器Channel实现</span><br><span class="hljs-comment">                 - 设置线程队列的链接个数</span><br><span class="hljs-comment">                 - 设置保持活动连接状态</span><br><span class="hljs-comment">                 - 给我们的 workerGroup 的 EventLoop 对应的管道设置处理器</span><br><span class="hljs-comment">             */</span><br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)<br>                    <span class="hljs-comment">// .handler 给boss设置的handler</span><br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<br>                        <span class="hljs-comment">// 给 pipeline 设置处理器</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>                            <span class="hljs-comment">// 打印所有的客户端SocketChannel，可以使用集合管理所有channel,推送消息时将业</span><br>                            <span class="hljs-comment">// 务加入对应的NIOEventLoop的taskQueue中或scheduleTaskQueue中！</span><br>                            System.out.println(<span class="hljs-string">"客户socketChannel的hashCode："</span> + ch.hashCode());<br>                            <span class="hljs-comment">// 添加自定义处理器</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyServerHandler());<br>                        }<br>                    });<br><br>            System.out.println(<span class="hljs-string">".....服务器已经准备好了....."</span>);<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span><br><span class="hljs-comment">             3. 绑定端口并启动！</span><br><span class="hljs-comment">             */</span><br>            ChannelFuture cf = bootstrap.bind(<span class="hljs-number">6668</span>).sync();<br><br>            <span class="hljs-comment">// 为ChannelFuture注册一个监听器！</span><br>            cf.addListener( future -&gt; {<br>                <span class="hljs-keyword">if</span>(future.isSuccess()){<br>                    System.out.println(<span class="hljs-string">"监听端口 6668 成功！"</span>);<br>                }<span class="hljs-keyword">else</span>{<br>                    System.out.println(<span class="hljs-string">"监听端口 6668 失败！"</span>);<br>                }<br>            });<br><br>            <span class="hljs-comment">// 4. closeFuture 不是立马关闭通道（有关闭Channel事件才会去关闭）</span><br>            <span class="hljs-comment">// sync：该核心操作在另一个线程异步执行，本线程同步阻塞等待future结果（main线程）</span><br>            cf.channel().closeFuture().sync();<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 最终优雅关闭</span><br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="NettyServerHandler"><a class="header-anchor" href="#NettyServerHandler">¶</a>NettyServerHandler</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义的pipeline的处理器！</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-10-28 10:11</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>{<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务器读取客户端数据！ (这里我们可以读取客户端发送的消息)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象, 含有管道 pipeline、通道 channel、地址</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 就是客户端发送的数据 默认 Object</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     * 管道是真正处理业务的，通道是运送数据的！</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"服务器读取线程："</span> + Thread.currentThread().getName());<br>        System.out.println(<span class="hljs-string">"server ctx："</span> + ctx);<br><br>        System.out.println(<span class="hljs-string">"channel 和 pipeline 的关系："</span>);<br>        Channel channel = ctx.channel();<br>        <span class="hljs-comment">// pipeline 本质是一个双向链表</span><br>        ChannelPipeline pipeline = ctx.pipeline();<br><br><br>        <span class="hljs-comment">// 将msg转成byteBuf（netty提供的，不是ByteBuffer）</span><br>        ByteBuf byteBuf = (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">"客户端发送的信息是："</span> + byteBuf.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">"客户端地址："</span> + ctx.channel().remoteAddress());<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务器端读完消息后的业务处理！</span><br><span class="hljs-comment">     * 可以回传数据给客户端！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象，含有许多内容！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>        <span class="hljs-comment">// 将数据写到缓存并刷新（缓存再写到Channel）！</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"hello，客户端！"</span>, CharsetUtil.UTF_8));<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务器端出现异常的处理！</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause 异常信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 出现异常则关闭通道！</span><br>        ctx.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="NettyClient"><a class="header-anchor" href="#NettyClient">¶</a>NettyClient</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br><br>        <span class="hljs-comment">// 1. 客户端需要一个事件循环组</span><br>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>        <span class="hljs-keyword">try</span> {<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         2. 客户端创建启动对象Bootstrap并设置先关参数！</span><br><span class="hljs-comment">            设置线程组</span><br><span class="hljs-comment">            设置客户端通道的实现类(反射)</span><br><span class="hljs-comment">         */</span><br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(group)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>                            <span class="hljs-comment">// 添加自定义处理器</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler());<br>                        }<br>                    });<br><br>            System.out.println(<span class="hljs-string">".....客户端已经准备好了....."</span>);<br><br>            <span class="hljs-comment">// 3. 绑定服务器端</span><br>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6668</span>).sync();<br><br>            <span class="hljs-comment">// 4. 为关闭通道进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 5. 关闭线程池</span><br>            group.shutdownGracefully();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="NettyClientHandler"><a class="header-anchor" href="#NettyClientHandler">¶</a>NettyClientHandler</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>{<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当通道就绪时触发！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"client ctx："</span> + ctx);<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"hello，服务器！"</span>, CharsetUtil.UTF_8));<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取客户端发来的消息！有读取事件时触发！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 发来的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        ByteBuf byteBuf = (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">"服务器发来的消息："</span> + byteBuf.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">"服务器地址："</span> + ctx.channel().remoteAddress());<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发生异常回调！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        cause.printStackTrace();<br>        <span class="hljs-comment">// 关闭通道</span><br>        ctx.channel().close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="任务队列中的三种任务"><a class="header-anchor" href="#任务队列中的三种任务">¶</a>任务队列中的三种任务</h3>
<ol>
<li>用户程序自定义的普通任务</li>
<li>用户自定义定时任务</li>
<li>非当前 Reactor 线程调用 Channel 的各种方法：例如在推送系统的业务线程里面，根据用户的标识，找到对应的 Channel 引用，然后调用 Write 类方法向该用户推送消息，就会进入到这种场景。最终的 Write 会提交到任务队列中后被异步消费</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itnxd.netty.simple;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><span class="hljs-keyword">import</span> io.netty.channel.Channel;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelPipeline;<br><span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义的pipeline的处理器！</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-10-28 10:11</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该 channel 对应的</span><br><span class="hljs-comment">        NIOEventLoop 的 taskQueue 中。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// TimeUnit.SECONDS.sleep(10);</span><br>        <span class="hljs-comment">// ctx.writeAndFlush(Unpooled.copiedBuffer("sleep了十秒，hello，客户端！", CharsetUtil.UTF_8));</span><br><br>        System.out.println(<span class="hljs-string">"channelRead ....."</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         解决方案 1 用户程序自定义的普通任务</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         向taskQueue里放入两个任务，由于该队列只是一个线程处理，因此是先后处理的！</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// runnable接口</span><br>        ctx.channel().eventLoop().execute(()-&gt;{<br>            <span class="hljs-keyword">try</span> {<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>            } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                System.out.println(<span class="hljs-string">"发生异常："</span>);<br>                e.printStackTrace();<br>            }<br>            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"sleep了 10 秒，hello，客户端！\n"</span>, CharsetUtil.UTF_8));<br>        });<br>        <span class="hljs-comment">/*ctx.channel().eventLoop().execute(()-&gt;{</span><br><span class="hljs-comment">            try {</span><br><span class="hljs-comment">                TimeUnit.SECONDS.sleep(20);</span><br><span class="hljs-comment">            } catch (InterruptedException e) {</span><br><span class="hljs-comment">                System.out.println("发生异常：");</span><br><span class="hljs-comment">                e.printStackTrace();</span><br><span class="hljs-comment">            }</span><br><span class="hljs-comment">            ctx.writeAndFlush(Unpooled.copiedBuffer("sleep了 20 秒，hello，客户端！\n", CharsetUtil.UTF_8));</span><br><span class="hljs-comment">        });*/</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         解决方案 2 : 用户自定义定时任务 -》 该任务是提交到 scheduledTaskQueue 中！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         延迟指定时间的任务！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         普通任务执行完毕之后执行定时任务！</span><br><span class="hljs-comment">         定时任务的延迟时间从普通任务开始执行算起！</span><br><span class="hljs-comment">         */</span><br>        ctx.channel().eventLoop().schedule(()-&gt;{<br>            <span class="hljs-keyword">try</span> {<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>            } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>                System.out.println(<span class="hljs-string">"发生异常："</span>);<br>                e.printStackTrace();<br>            }<br>            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"schedule sleep了 5 秒，hello，客户端！\n"</span>, CharsetUtil.UTF_8));<br>        }, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br><br><br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务器端读完消息后的业务处理！</span><br><span class="hljs-comment">     * 可以回传数据给客户端！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象，含有许多内容！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>        <span class="hljs-comment">// 将数据写到缓存并刷新（缓存再写到Channel）！</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"hello，客户端！"</span>, CharsetUtil.UTF_8));<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务器端出现异常的处理！</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause 异常信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 出现异常则关闭通道！</span><br>        ctx.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="Netty模型再说明"><a class="header-anchor" href="#Netty模型再说明">¶</a>Netty模型再说明</h3>
<ol>
<li>Netty 抽象出两组线程池，BossGroup 专门负责接收客户端连接，WorkerGroup 专门负责网络读写操作。</li>
<li>NioEventLoop 表示一个不断循环执行处理任务的线程，每个 NioEventLoop 都有一个 selector，用于监听绑定在其上的 socket 网络通道。</li>
<li>NioEventLoop 内部采用串行化设计，从消息的读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送，始终由 IO 线程 NioEventLoop负责</li>
<li>NioEventLoopGroup 下包含多个 NioEventLoop</li>
<li>每个 NioEventLoop 中包含有一个 Selector，一个 taskQueue</li>
<li>每个 NioEventLoop 的 Selector 上可以注册监听多个 NioChannel</li>
<li>每个 NioChannel 只会绑定在唯一的 NioEventLoop 上</li>
<li>每个 NioChannel 都绑定有一个自己的 ChannelPipeline</li>
</ol>
<h2 id="8、异步模型"><a class="header-anchor" href="#8、异步模型">¶</a>8、异步模型</h2>
<h3 id="基本介绍-5"><a class="header-anchor" href="#基本介绍-5">¶</a>基本介绍</h3>
<ol>
<li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</li>
<li>Netty 中的 I/O 操作是异步的，包括 Bind、Write、Connect 等操作会简单的返回一个 ChannelFuture。</li>
<li>调用者并不能立刻获得结果，而是通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得IO 操作结果</li>
<li>Netty 的异步模型是建立在 future 和 callback 的之上的。callback 就是回调。</li>
<li>重点说 <strong>Future</strong>，它的核心思想是：假设一个方法 fun，计算过程可能非常耗时，等待 fun 返回显然不合适。那么可以在调用 fun 的时候，立马返回一个 Future，后续可以通过 Future 去监控方法 fun 的处理过程 (即 ： <strong>Future-Listener 机制</strong>)</li>
</ol>
<h3 id="Future-说明"><a class="header-anchor" href="#Future-说明">¶</a>Future 说明</h3>
<ul>
<li>表示异步的执行结果, 可以通过它提供的方法来检测执行是否完成，比如检索计算等等</li>
<li>ChannelFuture 是一个接口 ： <code>public interface ChannelFuture extends Future&lt;Void&gt;</code></li>
<li>我们可以添加监听器，当监听的事件发生时，就会通知到监听器.</li>
</ul>
<h3 id="工作原理示意图"><a class="header-anchor" href="#工作原理示意图">¶</a>工作原理示意图</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@87e38aa5f5e8e570067efcc9688b51446d0c2309/2021/11/01/6122e7d1e6dca277fbd6f2fd8836a09c.png" alt=""></p>
<p><strong>简单说明：</strong></p>
<ol>
<li>在使用 Netty 进行编程时，拦截操作和转换出入站数据只需要您提供 callback 或利用 future 即可。这使得链式操作简单、高效, 并有利于编写可重用的、通用的代码。</li>
<li>Netty 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来</li>
</ol>
<h3 id="Future-Listener-机制"><a class="header-anchor" href="#Future-Listener-机制">¶</a>Future-Listener 机制</h3>
<ol>
<li>
<p>当 Future 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 ChannelFuture 来获取操作执行的状态，注册监听函数来执行完成后的操作。</p>
</li>
<li>
<p>常见有如下操作：</p>
<ol>
<li>通过 isDone 方法来判断当前操作是否完成；</li>
<li>通过 isSuccess 方法来判断已完成的当前操作是否成功；</li>
<li>通过 getCause 方法来获取已完成的当前操作失败的原因；</li>
<li>通过 isCancelled 方法来判断已完成的当前操作是否被取消；</li>
<li>通过 addListener 方法来注册监听器，当操作已完成(isDone 方法返回完成)，将会通知指定的监听器；如果Future 对象已完成，则通知指定的监听器</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ChannelFuture cf = bootstrap.bind(<span class="hljs-number">6668</span>).sync();<br><br><span class="hljs-comment">// 为ChannelFuture注册一个监听器！</span><br>cf.addListener( future -&gt; {<br>    <span class="hljs-keyword">if</span>(future.isSuccess()){<br>        System.out.println(<span class="hljs-string">"监听端口 6668 成功！"</span>);<br>    }<span class="hljs-keyword">else</span>{<br>        System.out.println(<span class="hljs-string">"监听端口 6668 失败！"</span>);<br>    }<br>});<br><br>cf.channel().closeFuture().sync();<br></code></pre></td></tr></tbody></table></figure>
<h2 id="9、Http-服务案例"><a class="header-anchor" href="#9、Http-服务案例">¶</a>9、Http 服务案例</h2>
<p><strong>实例要求：</strong></p>
<ul>
<li>Netty 服务器在 6668 端口监听，浏览器发出请求 "<a target="_blank" rel="noopener external nofollow noreferrer" href="http://localhost:6668/">http://localhost:6668/</a> "</li>
<li>服务器可以回复消息给客户端 "Hello! 我是服务器 " , 并对特定请求资源进行过滤</li>
</ul>
<h3 id="TestServer"><a class="header-anchor" href="#TestServer">¶</a>TestServer</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServer</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>{<br><br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>        <span class="hljs-keyword">try</span> {<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)<br>                    .childHandler(<span class="hljs-keyword">new</span> TestServerInitializer());<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            6668无法访问！</span><br><span class="hljs-comment">            关于谷歌浏览器限制端口！</span><br><span class="hljs-comment">             https://blog.csdn.net/u010037020/article/details/83183690</span><br><span class="hljs-comment">             https://blog.csdn.net/weixin_33738982/article/details/85868513</span><br><span class="hljs-comment">             */</span><br>            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">8888</span>).sync();<br>            System.out.println(<span class="hljs-string">"服务器已启动...."</span>);<br><br>            channelFuture.channel().closeFuture().sync();<br>        }<span class="hljs-keyword">finally</span> {<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="TestServerInitializer"><a class="header-anchor" href="#TestServerInitializer">¶</a>TestServerInitializer</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         向管道pipeline添加handler处理器</span><br><span class="hljs-comment">         （netty提供的HttpServerCodec codec -&gt; code + decode）</span><br><span class="hljs-comment">         netty提供的编解码器！</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 1. 给pipeline添加编解码器！</span><br>        ChannelPipeline pipeline = ch.pipeline();<br>        pipeline.addLast(<span class="hljs-string">"MyHttpServerCodec"</span>, <span class="hljs-keyword">new</span> HttpServerCodec());<br><br>        <span class="hljs-comment">// 2. 给pipeline增加自定义的handler处理器</span><br>        pipeline.addLast(<span class="hljs-string">"MyTestHttpServerHandler"</span>, <span class="hljs-keyword">new</span> TestHttpServerHandler());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="TestHttpServerHandler"><a class="header-anchor" href="#TestHttpServerHandler">¶</a>TestHttpServerHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. SimpleChannelInboundHandler继承自ChannelInboundHandlerAdapter</span><br><span class="hljs-comment"> * 2. HttpObject 客户端和服务器端相互通讯的数据被封装成 HttpObject</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-10-28 22:06</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestHttpServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">HttpObject</span>&gt; </span>{<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取客户端数据！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 来自客户端的消息！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 是HttpRequest请求！</span><br>        <span class="hljs-keyword">if</span>(msg <span class="hljs-keyword">instanceof</span> HttpRequest){<br><br>            <span class="hljs-comment">// DefaultChannelHandlerContext</span><br>            System.out.println(<span class="hljs-string">"ctx 的真实类型："</span> + ctx.getClass());<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             每个客户端都有不同的handler，不同的pipeline（可以使用谷歌无痕模式测试）</span><br><span class="hljs-comment">             每次刷新都会返回不同的值，每个handler都是独享的！</span><br><span class="hljs-comment">             */</span><br>            System.out.println(<span class="hljs-string">"pipeline 的 hashcode："</span> + ctx.pipeline().hashCode());<br>            System.out.println(<span class="hljs-string">"TestHttpServerHandler 的 hashcode："</span> + <span class="hljs-keyword">this</span>.hashCode());<br><br>            System.out.println(<span class="hljs-string">"msg类型："</span> + msg.getClass());<br>            System.out.println(<span class="hljs-string">"客户端地址："</span> + ctx.channel().remoteAddress());<br><br>            <span class="hljs-comment">// 获取uri过滤资源！</span><br>            HttpRequest request = (HttpRequest) msg;<br>            URI uri = <span class="hljs-keyword">new</span> URI(request.uri());<br>            <span class="hljs-keyword">if</span>(<span class="hljs-string">"/favicon.ico"</span>.equals(uri.getPath())){<br>                System.out.println(<span class="hljs-string">"favicon.ico 不做响应！"</span>);<br>                <span class="hljs-keyword">return</span>;<br>            }<br><br>            <span class="hljs-comment">// 回复信息给浏览器（客户端），使用的是http协议</span><br>            ByteBuf content = Unpooled.copiedBuffer(<span class="hljs-string">"hello, 我是服务器！"</span>, CharsetUtil.UTF_8);<br><br>            <span class="hljs-comment">// 构造一个http的响应，即httpResponse</span><br>            FullHttpResponse httpResponse = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1,<br>                    HttpResponseStatus.OK, content);<br>            httpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="hljs-string">"text/plain;charset=utf-8"</span>);<br>            httpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());<br><br>            <span class="hljs-comment">// 将构造好的response返回！</span><br>            ctx.writeAndFlush(httpResponse);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h1 id="五、Netty-核心模块组件"><a class="header-anchor" href="#五、Netty-核心模块组件">¶</a>五、Netty 核心模块组件</h1>
<h2 id="1、Bootstrap、ServerBootstrap"><a class="header-anchor" href="#1、Bootstrap、ServerBootstrap">¶</a>1、Bootstrap、ServerBootstrap</h2>
<ol>
<li>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类</li>
<li>常见的方法有：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ServerBootstrap <span class="hljs-title">group</span><span class="hljs-params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> 该方法用于服务器端，用来设置两个 EventLoop</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> B <span class="hljs-title">group</span><span class="hljs-params">(EventLoopGroup group)</span> 该方法用于客户端，用来设置一个 EventLoop</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> B <span class="hljs-title">channel</span><span class="hljs-params">(Class&lt;? extends C&gt; channelClass)</span> 该方法用来设置一个服务器端的通道实现</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> &lt;T&gt; B <span class="hljs-title">option</span><span class="hljs-params">(ChannelOption&lt;T&gt; option, T value)</span> 用来给 ServerChannel 添加配置</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> &lt;T&gt; ServerBootstrap <span class="hljs-title">childOption</span><span class="hljs-params">(ChannelOption&lt;T&gt; childOption, T value)</span> 用来给接收到的通道添加配置</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ServerBootstrap <span class="hljs-title">childHandler</span><span class="hljs-params">(ChannelHandler childHandler)</span> 该方法用来设置业务处理类（自定义的</span><br><span class="hljs-function">handler）</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inetPort)</span>  该方法用于服务器端，用来设置占用的端口号</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(String inetHost, <span class="hljs-keyword">int</span> inetPort)</span>  该方法用于客户端，用来连接服务器端</span><br></code></pre></td></tr></tbody></table></figure>
<h2 id="2、Future、ChannelFuture"><a class="header-anchor" href="#2、Future、ChannelFuture">¶</a>2、Future、ChannelFuture</h2>
<blockquote>
<p>Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p>
</blockquote>
<p><strong>常见的方法有：</strong></p>
<ul>
<li>Channel channel()，返回当前正在进行 IO 操作的通道</li>
<li>ChannelFuture sync()，等待异步操作执行完毕</li>
</ul>
<h2 id="3、Channel"><a class="header-anchor" href="#3、Channel">¶</a>3、Channel</h2>
<ol>
<li>Netty 网络通信的组件，能够用于执行网络 I/O 操作。</li>
<li>通过 Channel 可获得当前网络连接的通道的状态</li>
<li>通过 Channel 可获得 网络连接的配置参数 （例如接收缓冲区大小）</li>
<li>Channel 提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成</li>
<li>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方</li>
<li>支持关联 I/O 操作与对应的处理程序</li>
<li>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，<strong>常用的 Channel 类型:</strong></li>
<li>NioSocketChannel，异步的客户端 TCP Socket 连接。</li>
<li>NioServerSocketChannel，异步的服务器端 TCP Socket 连接。</li>
<li>NioDatagramChannel，异步的 <strong>UDP</strong> 连接。</li>
<li>NioSctpChannel，异步的客户端 Sctp 连接。</li>
<li>NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</li>
</ol>
<h2 id="4、Selector"><a class="header-anchor" href="#4、Selector">¶</a>4、Selector</h2>
<ol>
<li>Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。</li>
<li>当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel</li>
</ol>
<h2 id="5、ChannelHandler"><a class="header-anchor" href="#5、ChannelHandler">¶</a>5、ChannelHandler</h2>
<ol>
<li>ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。</li>
<li>ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li>
<li>ChannelHandler 及其实现类一览图：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@56aa8c1d0f9d824c82f6ecd6e3491ff90ea37918/2021/11/01/caae81dd5fe2a773860bfed5a174e882.png" alt=""></p>
<ol start="4">
<li>我们经常需要自定义一个 Handler 类去继承 ChannelInboundHandlerAdapter，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@9b5c45332df685db47b12a9eaa9a60bc366ff4f8/2021/11/01/99b3615a5c166a13c45eb985f41db035.png" alt=""></p>
<h2 id="6、Pipeline、ChannelPipeline"><a class="header-anchor" href="#6、Pipeline、ChannelPipeline">¶</a>6、Pipeline、ChannelPipeline</h2>
<p><strong>ChannelPipeline 是一个重点：</strong></p>
<ol>
<li>ChannelPipeline 是一个 Handler 的集合，它负责处理和拦截 inbound 或者 outbound 的事件和操作，相当于一个贯穿 Netty 的链。(也可以这样理解：ChannelPipeline 是 保存 ChannelHandler 的 List，用于处理或拦截Channel 的入站事件和出站操作)</li>
<li>ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel中各个的 ChannelHandler 如何相互交互</li>
<li>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@f196b01211998238972f4274b1edf8fc6f1ffc9f/2021/11/01/37e494f98a2357ae942d01e999b6ef44.png" alt=""></p>
<ol start="4">
<li>常用方法
<ol>
<li>ChannelPipeline addFirst(ChannelHandler… handlers)，把一个业务处理类（handler）添加到链中的第一个位置</li>
<li>ChannelPipeline addLast(ChannelHandler… handlers)，把一个业务处理类（handler）添加到链中的最后一个位置</li>
</ol>
</li>
</ol>
<h2 id="7、ChannelHandlerContext"><a class="header-anchor" href="#7、ChannelHandlerContext">¶</a>7、ChannelHandlerContext</h2>
<ol>
<li>保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象</li>
<li>即 ChannelHandlerContext 中 包 含 一 个 具 体 的 事 件 处 理 器 ChannelHandler ， 同时 ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler 进行调用.</li>
<li>常用方法：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@e904278d6098950efc4af78c5e27075662180670/2021/11/01/9391bb54c078ee9dde83cc044d8bc688.png" alt=""></p>
<h2 id="8、ChannelOption"><a class="header-anchor" href="#8、ChannelOption">¶</a>8、ChannelOption</h2>
<ol>
<li>Netty 在创建 Channel 实例后,一般都需要设置 ChannelOption 参数。</li>
<li>ChannelOption 参数如下:</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@f7caeca8c4d0875e3f7979be7e5535de27023ee1/2021/11/01/595fbd2e8cffcb7534e659555a26f680.png" alt=""></p>
<h2 id="9、EventLoopGroup、NioEventLoopGroup"><a class="header-anchor" href="#9、EventLoopGroup、NioEventLoopGroup">¶</a>9、EventLoopGroup、NioEventLoopGroup</h2>
<ol>
<li>EventLoopGroup 是一组 EventLoop 的抽象，Netty 为了更好的利用多核 CPU 资源，一般会有多个 EventLoop同时工作，每个 EventLoop 维护着一个 Selector 实例。</li>
<li>EventLoopGroup 提供 next 接口，可以从组里面按照一定规则获取其中一个 EventLoop 来处理任务。在 Netty服 务 器 端编程中 ， 我们一般都需 要提供两个 EventLoopGroup ，例如 ： BossEventLoopGroup 和WorkerEventLoopGroup。</li>
<li>通常一个服务端口即一个 ServerSocketChannel 对应一个 Selector 和一个 EventLoop 线程。BossEventLoop 负责接收客户端的连接并将SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理</li>
<li>常用方法</li>
<li>public NioEventLoopGroup()，构造方法</li>
<li>public Future&lt;?&gt; shutdownGracefully()，断开连接，关闭线程</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@59ec8223a6bf9e9366d8737c30ab06167e4cd7c3/2021/11/01/b9d6753e2d7d140232f9792f57ff5b92.png" alt=""></p>
<h2 id="10、Unpooled"><a class="header-anchor" href="#10、Unpooled">¶</a>10、Unpooled</h2>
<ol>
<li>Netty 提供一个专门用来操作缓冲区(即 Netty 的数据容器)的工具类</li>
<li>常用方法如下所示</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@a3938038af3633f107cedd4c2deebb5fae996875/2021/11/01/5158af6e9869485c39526355013f8310.png" alt=""></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyByteBuf01</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1. 创建一个ByteBuf，该对象包含一个数组 byte[10]</span><br><span class="hljs-comment">        2. netty中的buffer不需要像nio一样的flip操作，因为维护了两个变量readerIndex writerIndex</span><br><span class="hljs-comment">        3. 通过 readerIndex 和 writerIndex 和 capacity， 将 buffer 分成三部分</span><br><span class="hljs-comment">         */</span><br>        ByteBuf buffer = Unpooled.buffer(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.capacity(); i++) {<br>            buffer.writeByte(i);<br>        }<br><br>        <span class="hljs-comment">/*for (int i = 0; i &lt; buffer.capacity(); i++) {</span><br><span class="hljs-comment">            System.out.println(buffer.getByte(i));</span><br><span class="hljs-comment">        }*/</span><br>        <span class="hljs-comment">// 返回设置的buffer大小</span><br>        System.out.println(buffer.capacity());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buffer.capacity(); i++) {<br>            System.out.println(buffer.readByte());<br>        }<br>    }<br>}<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyByteBuf02</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><br>        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="hljs-string">"hello, world"</span>, CharsetUtil.UTF_8);<br><br>        <span class="hljs-keyword">if</span>(byteBuf.hasArray()){<br>            <span class="hljs-keyword">byte</span>[] array = byteBuf.array();<br>            String msg = <span class="hljs-keyword">new</span> String(array, CharsetUtil.UTF_8);<br>            System.out.println(msg);<br><br>            <span class="hljs-comment">// byteBuf：UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(ridx: 0, widx: 12, cap: 36)</span><br>            System.out.println(<span class="hljs-string">"byteBuf："</span> + byteBuf);<br><br>            System.out.println(byteBuf.arrayOffset()); <span class="hljs-comment">// 0</span><br>            System.out.println(byteBuf.readerIndex()); <span class="hljs-comment">// 0</span><br>            System.out.println(byteBuf.writerIndex()); <span class="hljs-comment">// 12</span><br>            System.out.println(byteBuf.capacity()); <span class="hljs-comment">// 36</span><br>            <span class="hljs-comment">// 可读取数量：writerIndex - readerIndex</span><br>            System.out.println(byteBuf.readByte()); <span class="hljs-comment">// 会导致readerIndex后移</span><br>            System.out.println(byteBuf.getByte(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 不会导致readerIndex后移</span><br>            System.out.println(byteBuf.readableBytes()); <span class="hljs-comment">// 11</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = byteBuf.readerIndex(); i &lt;= byteBuf.readableBytes(); i++) {<br>                System.out.println((<span class="hljs-keyword">char</span>) byteBuf.getByte(i));<br>            }<br><br>            System.out.println(byteBuf.getCharSequence(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, CharsetUtil.UTF_8));<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="11、Netty-应用实例-群聊系统"><a class="header-anchor" href="#11、Netty-应用实例-群聊系统">¶</a>11、Netty 应用实例-群聊系统</h2>
<p><strong>实例要求:</strong></p>
<ol>
<li>编写一个 Netty 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(有服务器转发得到)</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@6653ed676d045ab2e04d121f0b4d407f00e76da1/2021/11/01/a24d2105be9922f51571a9899b4a003a.png" alt=""></p>
<h3 id="GroupChatServer"><a class="header-anchor" href="#GroupChatServer">¶</a>GroupChatServer</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServer</span> </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span></span>{<br>        <span class="hljs-keyword">this</span>.port = port;<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理客户端请求！</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>        <span class="hljs-comment">// 创建两个线程组</span><br>        NioEventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        NioEventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>        <span class="hljs-keyword">try</span> {<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br><br>            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>                            ChannelPipeline pipeline = ch.pipeline();<br>                            <span class="hljs-comment">// 添加解码器和编码器</span><br>                            pipeline.addLast(<span class="hljs-string">"decoder"</span>, <span class="hljs-keyword">new</span> StringDecoder());<br>                            pipeline.addLast(<span class="hljs-string">"encoder"</span>, <span class="hljs-keyword">new</span> StringEncoder());<br>                            <span class="hljs-comment">// 添加自定义handler</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> GroupChatServerHandler());<br>                        }<br>                    });<br>            System.out.println(<span class="hljs-string">"netty 服务器已经启动！"</span>);<br>            ChannelFuture channelFuture = serverBootstrap.bind(port).sync();<br><br>            <span class="hljs-comment">// 监听channel关闭时间</span><br>            channelFuture.channel().closeFuture().sync();<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 关闭两个线程组</span><br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>        <span class="hljs-comment">// 启动服务器</span><br>        <span class="hljs-keyword">new</span> GroupChatServer(<span class="hljs-number">7000</span>).run();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="GroupChatServerHandler"><a class="header-anchor" href="#GroupChatServerHandler">¶</a>GroupChatServerHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>{<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     定义一个channel组 每个客户端都会独享一个handler</span><br><span class="hljs-comment">     GlobalEventExecutor.INSTANCE 是全局的事件执行器，是一个单例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ChannelGroup channelGroup = <span class="hljs-keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);<br><br>    <span class="hljs-keyword">private</span> SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br><br>    <span class="hljs-comment">// 用于处理私聊（暂未实现）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Channel&gt; channels = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 建立连接后第一个被执行！</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        Channel channel = ctx.channel();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         将客户端加入聊天的信息推送到其他所有客户端！</span><br><span class="hljs-comment">         该方法会将 channelGroup 中所有的 channel 遍历，并发送 消息，</span><br><span class="hljs-comment">         我们不需要自己遍历</span><br><span class="hljs-comment">         */</span><br>        channelGroup.writeAndFlush(sdf.format(<span class="hljs-keyword">new</span> Date()) + <span class="hljs-string">"：[客户端]"</span> + channel.remoteAddress() + <span class="hljs-string">"加入聊天\n"</span>);<br>        channelGroup.add(channel);<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 断开连接后执行！</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        Channel channel = ctx.channel();<br>        channelGroup.writeAndFlush(sdf.format(<span class="hljs-keyword">new</span> Date()) + <span class="hljs-string">"：[客户端]"</span> + channel.remoteAddress() + <span class="hljs-string">"离开了\n"</span>);<br>        <span class="hljs-comment">// 自动触发，无需手动remove</span><br>        <span class="hljs-comment">// channelGroup.remove(channel);</span><br>        System.out.println(<span class="hljs-string">"当前channelGroup的channel数量："</span> + channelGroup.size());<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * channel处于活动状态（上线）时执行！</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">"上线了！"</span>);<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * channel处于非活动状态（离线）时调用！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">"离线了！"</span>);<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务器等待接收客户端消息！</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 客户端发来的消息！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        Channel channel = ctx.channel();<br><br>        channelGroup.forEach(ch -&gt; {<br>            <span class="hljs-comment">// 排除自己</span><br>            <span class="hljs-keyword">if</span>(ch != channel){<br>                ch.writeAndFlush(sdf.format(<span class="hljs-keyword">new</span> Date()) + <span class="hljs-string">"：[客户]"</span> + channel.remoteAddress() + <span class="hljs-string">"发送了消息："</span><br>                        + msg + <span class="hljs-string">"\n"</span>);<br>            }<span class="hljs-keyword">else</span>{<br>                ch.writeAndFlush(sdf.format(<span class="hljs-keyword">new</span> Date()) + <span class="hljs-string">"：[自己]发送了消息："</span> + msg + <span class="hljs-string">"\n"</span>);<br>            }<br>        });<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发生异常的处理！</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause 异常原因！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 关闭通道</span><br>        ctx.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="GroupChatClient"><a class="header-anchor" href="#GroupChatClient">¶</a>GroupChatClient</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClient</span> </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupChatClient</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span></span>{<br>        <span class="hljs-keyword">this</span>.host = host;<br>        <span class="hljs-keyword">this</span>.port = port;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>        NioEventLoopGroup eventExecutors = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>        <span class="hljs-keyword">try</span> {<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(eventExecutors).channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>                            ChannelPipeline pipeline = ch.pipeline();<br>                            <span class="hljs-comment">// 添加编码解码器</span><br>                            pipeline.addLast(<span class="hljs-string">"decoder"</span>, <span class="hljs-keyword">new</span> StringDecoder());<br>                            pipeline.addLast(<span class="hljs-string">"encoder"</span>, <span class="hljs-keyword">new</span> StringEncoder());<br>                            <span class="hljs-comment">// 加入自定义处理器</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> GroupChatClientHandler());<br>                        }<br>                    });<br><br>            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();<br>            Channel channel = channelFuture.channel();<br><br>            System.out.println(<span class="hljs-string">"-------"</span> + channel.localAddress() + <span class="hljs-string">"----------"</span>);<br><br>            Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>            <span class="hljs-keyword">while</span>(scanner.hasNextLine()){<br>                String msg = scanner.nextLine();<br>                <span class="hljs-comment">// 客户端发送消息给服务器端！</span><br>                channel.writeAndFlush(msg);<br>            }<br>            <span class="hljs-comment">// 关闭通道</span><br>            channelFuture.channel().closeFuture().sync();<br>        } <span class="hljs-keyword">finally</span> {<br>            eventExecutors.shutdownGracefully();<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br><br>        <span class="hljs-comment">// 启动客户端</span><br>        <span class="hljs-keyword">new</span> GroupChatClient(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">7000</span>).run();<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="GroupChatClientHandler"><a class="header-anchor" href="#GroupChatClientHandler">¶</a>GroupChatClientHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupChatClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(msg.trim());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="12、Netty-心跳检测机制案例"><a class="header-anchor" href="#12、Netty-心跳检测机制案例">¶</a>12、Netty 心跳检测机制案例</h2>
<p><strong>实例要求：</strong></p>
<ol>
<li>编写一个 Netty 心跳检测机制案例, 当服务器超过 3 秒没有读时，就提示读空闲</li>
<li>当服务器超过 5 秒没有写操作时，就提示写空闲</li>
<li>实现当服务器超过 7 秒没有读或者写操作时，就提示读写空闲</li>
</ol>
<h3 id="MyServer"><a class="header-anchor" href="#MyServer">¶</a>MyServer</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br><br>        <span class="hljs-comment">// 创建两个线程组</span><br>        NioEventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        NioEventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>        <span class="hljs-keyword">try</span> {<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)<br>                    <span class="hljs-comment">// 为boss添加日志处理器</span><br>                    .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>                            ChannelPipeline pipeline = ch.pipeline();<br>                            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                            说明</span><br><span class="hljs-comment">                            1. IdleStateHandler 是 netty 提供的处理空闲状态的处理器</span><br><span class="hljs-comment">                            2. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span><br><span class="hljs-comment">                            3. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接</span><br><span class="hljs-comment">                            4. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span><br><span class="hljs-comment">                            5. 文档说明</span><br><span class="hljs-comment">                            triggers an {@link IdleStateEvent} when a {@link Channel} has not performed</span><br><span class="hljs-comment">                            read, write, or both operation for a while.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                             6. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个 handler 去处理</span><br><span class="hljs-comment">                            通过调用(触发)下一个 handler 的 userEventTriggered , 在该方法中去处理 IdleStateEvent(读</span><br><span class="hljs-comment">                            空闲，写空闲，读写空闲)</span><br><span class="hljs-comment">                            */</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, TimeUnit.SECONDS));<br>                            <span class="hljs-comment">// 加入一个对空闲检测进一步处理的 handler(自定义)</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> MyServerHandler());<br>                        }<br>                    });<br><br>            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">7000</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br>        }<span class="hljs-keyword">finally</span> {<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="MyServerHandler"><a class="header-anchor" href="#MyServerHandler">¶</a>MyServerHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>{<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> evt 事件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-keyword">if</span>(evt <span class="hljs-keyword">instanceof</span> IdleStateEvent){<br>            IdleStateEvent event = (IdleStateEvent) evt;<br>            String eventType = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">switch</span> (event.state()){<br>                <span class="hljs-keyword">case</span> READER_IDLE:<br>                    eventType = <span class="hljs-string">"读空闲"</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> WRITER_IDLE:<br>                    eventType = <span class="hljs-string">"写空闲"</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> ALL_IDLE:<br>                    eventType = <span class="hljs-string">"读写空闲"</span>;<br>                    <span class="hljs-keyword">break</span>;<br>            }<br>            System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">"-----发生了"</span> + eventType);<br>            System.out.println(<span class="hljs-string">"服务器做相应处理！"</span>);<br><br>            <span class="hljs-comment">// 发生空闲则关闭通道！</span><br>            <span class="hljs-comment">// ctx.close();</span><br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="13、Netty-通过-WebSocket-实现长连接"><a class="header-anchor" href="#13、Netty-通过-WebSocket-实现长连接">¶</a>13、Netty 通过 WebSocket 实现长连接</h2>
<p><strong>实例要求:</strong></p>
<ol>
<li><strong>Http 协议是无状态的</strong>, 浏览器和服务器间的请求响应一次，下一次会重新创建连接.</li>
<li>要求：实现基于 webSocket 的长连接的<strong>全双工</strong>的交互</li>
<li>改变 Http 协议多次请求的约束，实现长连接了， 服务器可以发送消息给浏览器</li>
<li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li>
<li>运行界面</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@323561ad8b599e2f5f1169495763f89d11a577ad/2021/11/01/c28177e26be7cc9da211d1d0dbab002c.png" alt=""></p>
<h3 id="MyServer-2"><a class="header-anchor" href="#MyServer-2">¶</a>MyServer</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServer</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>{<br><br>        <span class="hljs-comment">// 创建两个线程组</span><br>        NioEventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        NioEventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>        <span class="hljs-keyword">try</span> {<br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)<br>                    <span class="hljs-comment">// 为boss添加日志处理器</span><br>                    .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>                            ChannelPipeline pipeline = ch.pipeline();<br>                            <span class="hljs-comment">//因为基于 http 协议，使用 http 的编码和解码器</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> HttpServerCodec());<br>                            <span class="hljs-comment">// 是以块方式写，添加 ChunkedWriteHandler 处理器(处理大数据传输)</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> ChunkedWriteHandler());<br>                            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                            1. http 数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合</span><br><span class="hljs-comment">                            2. 这就就是为什么，当浏览器发送大量数据时，就会发出多次 http 请求</span><br><span class="hljs-comment">                             */</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">8192</span>));<br>                            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                            1. 对应 websocket ，它的数据是以 帧(frame) 形式传递</span><br><span class="hljs-comment">                            2. 可以看到 WebSocketFrame 下面有六个子类</span><br><span class="hljs-comment">                            3. 浏览器请求时 ws://localhost:7000/hello 表示请求的 uri</span><br><span class="hljs-comment">                            4. WebSocketServerProtocolHandler 核心功能是将 http 协议升级为 ws 协议 , 保持长连接</span><br><span class="hljs-comment">                            5. 是通过一个 状态码 101</span><br><span class="hljs-comment">                             */</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> WebSocketServerProtocolHandler(<span class="hljs-string">"/hello"</span>));<br>                            <span class="hljs-comment">// 添加自定义处理器</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> MyTextWebSocketFrameHandler());<br><br>                        }<br>                    });<br><br>            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">7000</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br>        }<span class="hljs-keyword">finally</span> {<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="Handler"><a class="header-anchor" href="#Handler">¶</a>Handler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这里 TextWebSocketFrame 类型，表示一个文本帧(frame)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-10-29 21:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTextWebSocketFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">TextWebSocketFrame</span>&gt; </span>{<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务器处理客户端消息！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 客户端发来的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"服务器收到消息："</span> + msg.text());<br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);<br>        <span class="hljs-comment">// 回复浏览器消息(注意一定要用TextWebSocketFrame来封装)</span><br>        ctx.channel().writeAndFlush(<span class="hljs-keyword">new</span> TextWebSocketFrame(<span class="hljs-string">"服务器时间："</span> + LocalDateTime.now()<br>                + <span class="hljs-string">" "</span> + msg.text()));<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 客户端建立连接时执行！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">//id 表示唯一的值，LongText 是唯一的 ShortText</span><br>        System.out.println(<span class="hljs-string">"handlerAdded 被调用："</span> + ctx.channel().id().asLongText());<br>        System.out.println(<span class="hljs-string">"handlerAdded 被调用："</span> + ctx.channel().id().asShortText());<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 断开连接时执行！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"handlerRemoved 被调用："</span> + ctx.channel().id().asLongText());<br>        System.out.println(<span class="hljs-string">"handlerRemoved 被调用："</span> + ctx.channel().id().asShortText());<br>    }<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发生异常时调用！</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause 异常原因</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"异常发生："</span> + cause.getMessage());<br>        ctx.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="html"><a class="header-anchor" href="#html">¶</a>html</h3>
<p>右键 run html 即可！</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> socket;</span><br><span class="javascript">        <span class="hljs-comment">// 判断浏览器是否支持websocket</span></span><br><span class="javascript">        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.WebSocket){</span><br><span class="javascript">            socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">"ws://localhost:7000/hello"</span>);</span><br><span class="javascript">            <span class="hljs-comment">// ws的监听函数 ev参数为服务器发来的消息！</span></span><br><span class="javascript">            socket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>)</span>{</span><br><span class="javascript">                <span class="hljs-keyword">var</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"responseText"</span>);</span><br><span class="javascript">                rt.value = rt.value + <span class="hljs-string">"\n"</span> + ev.data;</span><br>            };<br><span class="javascript">            <span class="hljs-comment">// ws的连接建立时执行</span></span><br><span class="javascript">            socket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>)</span>{</span><br><span class="javascript">                <span class="hljs-keyword">var</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"responseText"</span>);</span><br><span class="javascript">                rt.value = <span class="hljs-string">"连接已经建立！"</span>;</span><br>            };<br><span class="javascript">            <span class="hljs-comment">// ws的连接关闭时执行</span></span><br><span class="javascript">            socket.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>)</span>{</span><br><span class="javascript">                <span class="hljs-keyword">var</span> rt = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"responseText"</span>);</span><br><span class="javascript">                rt.value = rt.value + <span class="hljs-string">"\n连接已经关闭！"</span>;</span><br>            };<br><span class="javascript">        }<span class="hljs-keyword">else</span>{</span><br><span class="javascript">            alert(<span class="hljs-string">"您的浏览器不支持websocket！"</span>);</span><br>        }<br><span class="javascript">        <span class="hljs-comment">// 处理发送消息的服务器逻辑</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params">message</span>) </span>{</span><br><span class="javascript">            <span class="hljs-comment">// 先判断ws是否创建成功</span></span><br><span class="javascript">            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">window</span>.socket){</span><br><span class="javascript">                <span class="hljs-keyword">return</span>;</span><br>            }<br><span class="javascript">            <span class="hljs-keyword">if</span>(socket.readyState == WebSocket.OPEN){</span><br><span class="javascript">                <span class="hljs-comment">// 通过socket发送消息</span></span><br>                socket.send(message);<br><span class="javascript">            }<span class="hljs-keyword">else</span>{</span><br><span class="javascript">                alert(<span class="hljs-string">"连接还没有开启！"</span>);</span><br>            }<br>        }<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">""</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">"return false;"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"height: 300px; width: 500px"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"发送消息"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"send(this.form.message.value)"</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"responseText"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"height: 300px; width: 500px"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"清空内容"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"document.getElementById('responseText').value=''"</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>
<h1 id="六、Google-Protobuf"><a class="header-anchor" href="#六、Google-Protobuf">¶</a>六、Google Protobuf</h1>
<h2 id="1、编码和解码的基本介绍"><a class="header-anchor" href="#1、编码和解码的基本介绍">¶</a>1、编码和解码的基本介绍</h2>
<ol>
<li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码</li>
<li>codec(编解码器) 的组成部分有两个：decoder(解码器)和 encoder(编码器)。encoder 负责把业务数据转换成字节码数据，decoder 负责把字节码数据转换成业务数据</li>
</ol>
<h2 id="2、Netty-本身编解码机制问题分析"><a class="header-anchor" href="#2、Netty-本身编解码机制问题分析">¶</a>2、Netty 本身编解码机制问题分析</h2>
<ol>
<li>Netty 自身提供了一些 codec(编解码器)</li>
<li>Netty 提供的编码器</li>
<li>StringEncoder，对字符串数据进行编码</li>
<li>ObjectEncoder，对 Java 对象进行编码</li>
<li>Netty 提供的解码器</li>
<li>StringDecoder, 对字符串数据进行解码</li>
<li>ObjectDecoder，对 Java 对象进行解码</li>
<li>Netty 本身自带的 ObjectDecoder 和 ObjectEncoder 可以用来实现 POJO 对象或各种业务对象的编码和解码</li>
<li>底层使用的仍是 Java 序列化技术 , 而 Java 序列化技术本身效率就不高，<strong>存在如下问题</strong>：</li>
<li>无法跨语言</li>
<li>序列化后的体积太大，是二进制编码的 5 倍多。</li>
<li>序列化性能太低</li>
<li><strong>引出新的解决方案 [Google 的 Protobuf]</strong></li>
<li>，</li>
</ol>
<h2 id="3、Protobuf"><a class="header-anchor" href="#3、Protobuf">¶</a>3、Protobuf</h2>
<ol>
<li>Protobuf 基本介绍和使用示意图</li>
<li>Protobuf 是 Google 发布的开源项目，全称 Google Protocol Buffers，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC[远程过程调用 remote procedure call ] 数据交换格式 。目前很多公司 <strong>http+json tcp+protobuf</strong></li>
<li>参考文档 : <a target="_blank" rel="noopener external nofollow noreferrer" href="https://developers.google.com/protocol-buffers/docs/proto">https://developers.google.com/protocol-buffers/docs/proto</a> 语言指南</li>
<li>Protobuf 是以 message 的方式来管理数据的.</li>
<li>支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的] （支持目前绝大多数语言，例如 C++、C#、Java、python 等）</li>
<li>高性能，高可靠性</li>
<li>使用 protobuf 编译器能自动生成代码，Protobuf 是将类的定义使用.proto 文件进行描述。说明，在 idea 中编写 .proto 文件时，会自动提示是否下载 .ptotot 编写插件. 可以让语法高亮。</li>
<li>然后通过 protoc.exe 编译器根据.proto 自动生成.java 文件</li>
<li>protobuf 使用示意图</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@0e4ccb6a1b12fd12db3070b856325e98c3f67b81/2021/11/01/d7294297e57fbcc9fd317c19ec4a6767.png" alt=""></p>
<h2 id="4、Protobuf-案例一"><a class="header-anchor" href="#4、Protobuf-案例一">¶</a>4、Protobuf 案例一</h2>
<p>编写程序，使用 Protobuf 完成如下功能：</p>
<ol>
<li>客户端可以发送一个 Student PoJo 对象到服务器 (通过 Protobuf 编码)</li>
<li>服务端能接收 Student PoJo 对象，并显示信息(通过 Protobuf 解码)</li>
</ol>
<h3 id="Student-proto"><a class="header-anchor" href="#Student-proto">¶</a>Student.proto</h3>
<p>使用<code>protoc.exe --java_out=. Student.proto</code> 编译为 StudentPOJO.java 放入项目使用！</p>
<figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">"proto3"</span>; <span class="hljs-comment">// 版本</span><br><span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">"StudentPojo"</span>; <span class="hljs-comment">// 生成的外部类名，同时也是文件名</span><br><span class="hljs-comment">// protobuf使用message管理数据 会在StudentPojo外部类里生成一个内部类，是真正发送的pojo对象</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">student</span></span>{<br>  <span class="hljs-comment">// 属性=序号（不是值）</span><br>  <span class="hljs-built_in">int32</span> id = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">string</span> name = <span class="hljs-number">2</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="NettyServer-2"><a class="header-anchor" href="#NettyServer-2">¶</a>NettyServer</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br><br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>); <span class="hljs-comment">// Boss分配一个线程即可</span><br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">4</span>);<br><br>        <span class="hljs-keyword">try</span> {<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<br>                        <span class="hljs-comment">// 给 pipeline 设置处理器</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>                            System.out.println(<span class="hljs-string">"客户socketChannel的hashCode："</span> + ch.hashCode());<br>                            <span class="hljs-comment">// 需要指定对谁解码</span><br>                            ch.pipeline().addLast(<span class="hljs-string">"decoder"</span>, <span class="hljs-keyword">new</span> ProtobufDecoder(StudentPojo.student.getDefaultInstance()));<br>                            <span class="hljs-comment">// 添加自定义处理器</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyServerHandler());<br>                        }<br>                    });<br><br>            System.out.println(<span class="hljs-string">".....服务器已经准备好了....."</span>);<br><br>            ChannelFuture cf = bootstrap.bind(<span class="hljs-number">6668</span>).sync();<br><br>            <span class="hljs-comment">// 为ChannelFuture注册一个监听器！</span><br>            cf.addListener( future -&gt; {<br>                <span class="hljs-keyword">if</span>(future.isSuccess()){<br>                    System.out.println(<span class="hljs-string">"监听端口 6668 成功！"</span>);<br>                }<span class="hljs-keyword">else</span>{<br>                    System.out.println(<span class="hljs-string">"监听端口 6668 失败！"</span>);<br>                }<br>            });<br>            cf.channel().closeFuture().sync();<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 最终优雅关闭</span><br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="NettyServerHandler-2"><a class="header-anchor" href="#NettyServerHandler-2">¶</a>NettyServerHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">StudentPojo</span>.<span class="hljs-title">student</span>&gt; </span>{<br><br>    <span class="hljs-comment">/*@Override</span><br><span class="hljs-comment">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        // 读取客户端发送的StudentPojo.student</span><br><span class="hljs-comment">        StudentPojo.student student = (StudentPojo.student) msg;</span><br><span class="hljs-comment">        System.out.println("客户端发送的数据 id = " + student.getId());</span><br><span class="hljs-comment">        System.out.println("客户端发送的数据 name = " + student.getName());</span><br><span class="hljs-comment">    }*/</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, StudentPojo.student msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>        <span class="hljs-comment">// 读取客户端发送的StudentPojo.student</span><br>        System.out.println(<span class="hljs-string">"客户端发送的数据 id = "</span> + msg.getId());<br>        System.out.println(<span class="hljs-string">"客户端发送的数据 name = "</span> + msg.getName());<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>        <span class="hljs-comment">// 将数据写到缓存并刷新（缓存再写到Channel）！</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"hello，客户端！"</span>, CharsetUtil.UTF_8));<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 出现异常则关闭通道！</span><br>        ctx.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="NettyClient-2"><a class="header-anchor" href="#NettyClient-2">¶</a>NettyClient</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br><br>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>        <span class="hljs-keyword">try</span> {<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(group)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>                            <span class="hljs-comment">// 添加protobuf处理器（最好放在前面）</span><br>                            ch.pipeline().addLast(<span class="hljs-string">"encoder"</span>, <span class="hljs-keyword">new</span> ProtobufEncoder());<br>                            <span class="hljs-comment">// 添加自定义处理器</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler());<br>                        }<br>                    });<br><br>            System.out.println(<span class="hljs-string">".....客户端已经准备好了....."</span>);<br><br>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6668</span>).sync();<br><br>            channelFuture.channel().closeFuture().sync();<br>        } <span class="hljs-keyword">finally</span> {<br>            group.shutdownGracefully();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="NettyClientHandler-2"><a class="header-anchor" href="#NettyClientHandler-2">¶</a>NettyClientHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 发送student对象到服务器</span><br>        StudentPojo.student tom = StudentPojo.student.newBuilder().setId(<span class="hljs-number">1</span>).setName(<span class="hljs-string">"tom"</span>).build();<br>        ctx.writeAndFlush(tom);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        ByteBuf byteBuf = (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">"服务器发来的消息："</span> + byteBuf.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">"服务器地址："</span> + ctx.channel().remoteAddress());<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        cause.printStackTrace();<br>        <span class="hljs-comment">// 关闭通道</span><br>        ctx.channel().close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="5、Protobuf-案例二"><a class="header-anchor" href="#5、Protobuf-案例二">¶</a>5、Protobuf 案例二</h2>
<p><strong>编写程序，使用 Protobuf 完成如下功能</strong></p>
<ul>
<li>客户端可以随机发送 Student PoJo/ Worker PoJo 对象到服务器 (通过 Protobuf 编码)</li>
<li>服务端能接收 Student PoJo/ Worker PoJo 对象(需要判断是哪种类型)，并显示信息(通过 Protobuf 解码)</li>
</ul>
<h3 id="Student-proto-2"><a class="header-anchor" href="#Student-proto-2">¶</a>Student.proto</h3>
<p>使用<code>protoc.exe --java_out=. Student.proto</code> 编译为 StudentPOJO.java 放入项目使用！</p>
<figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">"proto3"</span>; <span class="hljs-comment">// 版本</span><br><span class="hljs-keyword">option</span> optimize_for = SPEED; <span class="hljs-comment">// 加快解析</span><br><span class="hljs-keyword">option</span> java_package = <span class="hljs-string">"com.itnxd.netty.codec2"</span>; <span class="hljs-comment">// 指定生成到哪个包下</span><br><span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">"MyDataInfo"</span>; <span class="hljs-comment">// 生成的外部类名，同时也是文件名</span><br><br><span class="hljs-comment">// protoc.exe --java_out=. student.proto</span><br><span class="hljs-comment">// protobuf 可以使用 message 管理其他的 message</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">MyMessage</span></span>{<br>  <span class="hljs-comment">// 定义枚举类型</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DataType</span></span>{<br>    <span class="hljs-comment">// 枚举里面编号从0开始</span><br>    StudentType = <span class="hljs-number">0</span>;<br>    WorkerType = <span class="hljs-number">1</span>;<br>  }<br><br>  <span class="hljs-comment">// 用data_type标识传递的类型（属性=编号）</span><br>  DataType data_type = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 表示每次枚举类型最多只能出现其中的一个, 节省空间</span><br>  <span class="hljs-keyword">oneof</span> dataBody {<br>    Student student = <span class="hljs-number">2</span>;<br>    Worker worker = <span class="hljs-number">3</span>;<br>  }<br>  <span class="hljs-comment">// 三个属性，后两个同时只能传递一个！</span><br>}<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Student</span></span>{<br>  <span class="hljs-comment">// 属性=序号（不是值）</span><br>  <span class="hljs-built_in">int32</span> id = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">string</span> name = <span class="hljs-number">2</span>;<br>}<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Worker</span></span>{<br>  <span class="hljs-built_in">string</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">int32</span> age = <span class="hljs-number">2</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="NettyServer-3"><a class="header-anchor" href="#NettyServer-3">¶</a>NettyServer</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br><br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>); <span class="hljs-comment">// Boss分配一个线程即可</span><br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">4</span>);<br><br>        <span class="hljs-keyword">try</span> {<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<br>                        <span class="hljs-comment">// 给 pipeline 设置处理器</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>                            System.out.println(<span class="hljs-string">"客户socketChannel的hashCode："</span> + ch.hashCode());<br>                            <span class="hljs-comment">// 需要指定对谁解码</span><br>                            ch.pipeline().addLast(<span class="hljs-string">"decoder"</span>, <span class="hljs-keyword">new</span> ProtobufDecoder(MyDataInfo.MyMessage.getDefaultInstance()));<br>                            <span class="hljs-comment">// 添加自定义处理器</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyServerHandler());<br>                        }<br>                    });<br><br>            System.out.println(<span class="hljs-string">".....服务器已经准备好了....."</span>);<br><br>            ChannelFuture cf = bootstrap.bind(<span class="hljs-number">6668</span>).sync();<br><br>            <span class="hljs-comment">// 为ChannelFuture注册一个监听器！</span><br>            cf.addListener( future -&gt; {<br>                <span class="hljs-keyword">if</span>(future.isSuccess()){<br>                    System.out.println(<span class="hljs-string">"监听端口 6668 成功！"</span>);<br>                }<span class="hljs-keyword">else</span>{<br>                    System.out.println(<span class="hljs-string">"监听端口 6668 失败！"</span>);<br>                }<br>            });<br>            cf.channel().closeFuture().sync();<br>        } <span class="hljs-keyword">finally</span> {<br>            <span class="hljs-comment">// 最终优雅关闭</span><br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="NettyServerHandler-3"><a class="header-anchor" href="#NettyServerHandler-3">¶</a>NettyServerHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MyDataInfo</span>.<span class="hljs-title">MyMessage</span>&gt; </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MyDataInfo.MyMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>        <span class="hljs-comment">// 读取客户端发送的msg，根据dataType判断显示</span><br>        MyDataInfo.MyMessage.DataType dataType = msg.getDataType();<br>        <span class="hljs-keyword">if</span>(dataType == MyDataInfo.MyMessage.DataType.StudentType){<br>            MyDataInfo.Student student = msg.getStudent();<br>            System.out.println(<span class="hljs-string">"学生 id = "</span> + student.getId());<br>            System.out.println(<span class="hljs-string">"学生 name = "</span> + student.getName());<br>        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dataType == MyDataInfo.MyMessage.DataType.WorkerType){<br>            MyDataInfo.Worker worker = msg.getWorker();<br>            System.out.println(<span class="hljs-string">"工人 age = "</span> + worker.getAge());<br>            System.out.println(<span class="hljs-string">"工人 name = "</span> + worker.getName());<br>        }<span class="hljs-keyword">else</span>{<br>            System.out.println(<span class="hljs-string">"传输的类型不正确！"</span>);<br>        }<br><br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>        <span class="hljs-comment">// 将数据写到缓存并刷新（缓存再写到Channel）！</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"hello，客户端！"</span>, CharsetUtil.UTF_8));<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 出现异常则关闭通道！</span><br>        ctx.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="NettyClient-3"><a class="header-anchor" href="#NettyClient-3">¶</a>NettyClient</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br><br>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>        <span class="hljs-keyword">try</span> {<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(group)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>                            <span class="hljs-comment">// 添加protobuf处理器（最好放在前面）</span><br>                            ch.pipeline().addLast(<span class="hljs-string">"encoder"</span>, <span class="hljs-keyword">new</span> ProtobufEncoder());<br>                            <span class="hljs-comment">// 添加自定义处理器</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler());<br>                        }<br>                    });<br><br>            System.out.println(<span class="hljs-string">".....客户端已经准备好了....."</span>);<br><br>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6668</span>).sync();<br><br>            channelFuture.channel().closeFuture().sync();<br>        } <span class="hljs-keyword">finally</span> {<br>            group.shutdownGracefully();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="NettyClientHandler-3"><a class="header-anchor" href="#NettyClientHandler-3">¶</a>NettyClientHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>        <span class="hljs-comment">// 随机发送student和worker给服务器</span><br>        <span class="hljs-keyword">int</span> random = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>);<br>        MyDataInfo.MyMessage message = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(random == <span class="hljs-number">0</span>){<br>             message = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.StudentType)<br>                    .setStudent(MyDataInfo.Student.newBuilder().setId(<span class="hljs-number">1</span>).setName(<span class="hljs-string">"itnxd"</span>).build()).build();<br>        }<span class="hljs-keyword">else</span> {<br>            message = MyDataInfo.MyMessage.newBuilder().setDataType(MyDataInfo.MyMessage.DataType.WorkerType)<br>                    .setWorker(MyDataInfo.Worker.newBuilder().setAge(<span class="hljs-number">20</span>).setName(<span class="hljs-string">"nbnb"</span>).build()).build();<br>        }<br><br>        ctx.writeAndFlush(message);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        ByteBuf byteBuf = (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">"服务器发来的消息："</span> + byteBuf.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">"服务器地址："</span> + ctx.channel().remoteAddress());<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        cause.printStackTrace();<br>        <span class="hljs-comment">// 关闭通道</span><br>        ctx.channel().close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h1 id="七、Netty-编解码器"><a class="header-anchor" href="#七、Netty-编解码器">¶</a>七、Netty 编解码器</h1>
<h2 id="1、基本说明"><a class="header-anchor" href="#1、基本说明">¶</a>1、基本说明</h2>
<ol>
<li>netty 的组件设计：Netty 的主要组件有 Channel、EventLoop、ChannelFuture、ChannelHandler、ChannelPipe 等</li>
<li>ChannelHandler 充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现 ChannelInboundHandler 接口，你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时 ， 也可以从 ChannelInboundHandler 冲刷数据 。 业务逻辑通常写在一个或者多个ChannelInboundHandler 中。ChannelOutboundHandler 原理一样，只不过它是用来处理出站数据的</li>
<li>ChannelPipeline 提供了 ChannelHandler 链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过 pipeline 中的一系列ChannelOutboundHandler，并被这些 Handler 处理，反之则称为入站的</li>
</ol>
<h2 id="2、编码解码器"><a class="header-anchor" href="#2、编码解码器">¶</a>2、编码解码器</h2>
<ol>
<li>当 Netty 发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如 java 对象）；如果是出站消息，它会被编码成字节。</li>
<li>Netty 提供一系列实用的编解码器，他们都实现了 ChannelInboundHadnler 或者 ChannelOutboundHandler 接口。在这些类中，channelRead 方法已经被重写了。以入站为例，对于每个从入站 Channel 读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的 decode()方法进行解码，并将已经解码的字节转发给 ChannelPipeline中的下一个 ChannelInboundHandler。</li>
</ol>
<h2 id="3、解码器-ByteToMessageDecoder"><a class="header-anchor" href="#3、解码器-ByteToMessageDecoder">¶</a>3、解码器-ByteToMessageDecoder</h2>
<h3 id="关系继承图"><a class="header-anchor" href="#关系继承图">¶</a>关系继承图</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@dbce4c7739638bc24cc06ffe4e3f846fcb82080d/2021/11/02/01ea6a9f4251a467bebb91730c623440.png" alt=""></p>
<ol>
<li>由于不可能知道远程节点是否会一次性发送一个完整的信息，tcp 有可能出现<strong>粘包拆包</strong>的问题，这个类会对入站数据进行缓冲，直到它准备好被处理.</li>
<li>一个关于 ByteToMessageDecoder 实例分析</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@854e2aff88a08eaf96da5b6c21e48a4eec4683d6/2021/11/02/bd2e3d89a2a5c9ac0febeade256dd1e8.png" alt=""></p>
<h2 id="4、Netty-的-handler-链的调用机制"><a class="header-anchor" href="#4、Netty-的-handler-链的调用机制">¶</a>4、Netty 的 handler 链的调用机制</h2>
<p><strong>调用链示意图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@7230612cd36d9d905b969fe7407c64c1459cb73e/2021/11/02/da1599a4ded7cae000bbadda6d1358af.png" alt=""></p>
<p><strong>实例要求</strong>：使用自定义的编码器和解码器来说明 Netty 的 handler 调用机制</p>
<ul>
<li>客户端发送 long -&gt; 服务器</li>
<li>服务端发送 long -&gt; 客户端</li>
</ul>
<p><strong>小结论：</strong></p>
<ul>
<li>不论解码器 handler 还是 编码器 handler 即接收的消息类型必须与待处理的消息类型一致，否则该 handler 不会被执行</li>
<li>在解码器 进行数据解码时，需要判断 缓存区(ByteBuf)的数据是否足够 ，否则接收到的结果会期望结果可能不一致</li>
</ul>
<h3 id="MyLongToByteEncoder"><a class="header-anchor" href="#MyLongToByteEncoder">¶</a>MyLongToByteEncoder</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLongToByteEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">Long</span>&gt; </span>{<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重写编码方法！</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 待编码的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out 出站的buf</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>        System.out.println(<span class="hljs-string">"MyLongToByteEncoder encode 方法被调用！"</span>);<br>        System.out.println(<span class="hljs-string">"msg = "</span> + msg);<br>        out.writeLong(msg);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="MyByteToLongDecoder"><a class="header-anchor" href="#MyByteToLongDecoder">¶</a>MyByteToLongDecoder</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyByteToLongDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>{<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重写解码器！</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 该解码方法会根据传入的数据多次动态的调用！直到没有新的元素传入过来！</span><br><span class="hljs-comment">     * 若list out不为空，则将处理后的结果再次传递给下一个inboundHandler处理，</span><br><span class="hljs-comment">     * 该处理器也会根据数据量来判断动态的调用多次！</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx 上下文</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in 入站的buf</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out List集合，将解码后的数据传递给下一个inboundHandler处理</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>        System.out.println(<span class="hljs-string">"MyByteToLongDecoder decode被调用！"</span>);<br>        <span class="hljs-comment">// 大于八个字节再进行处理</span><br>        <span class="hljs-keyword">if</span>(in.readableBytes() &gt;= <span class="hljs-number">8</span>){<br>            out.add(in.readLong());<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="MyServerHandler-2"><a class="header-anchor" href="#MyServerHandler-2">¶</a>MyServerHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Long</span>&gt; </span>{<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Long msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"从客户端 "</span> + ctx.channel().remoteAddress() + <span class="hljs-string">" 读取到Long："</span> + msg);<br><br>        <span class="hljs-comment">// 服务端给客户端发送消息</span><br>        ctx.writeAndFlush(<span class="hljs-number">98765L</span>);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        cause.printStackTrace();<br>        ctx.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="MyClientHandler"><a class="header-anchor" href="#MyClientHandler">¶</a>MyClientHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端和服务器端都是使用的InboundHandler：</span><br><span class="hljs-comment"> * 原因：为了监听对方发来的数据因此使用inbound。</span><br><span class="hljs-comment"> *      使用ctx.writeAndFlush写数据时其实底层就是一个outbound操作！</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *      writeAndFlush：write(Object) and flush().</span><br><span class="hljs-comment"> *      ChannelOutboundInvoker flush(); flush方法就是outbound的！</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-10-30 10:59</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Long</span>&gt; </span>{<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Long msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>        <span class="hljs-comment">// 接收服务器发来的消息</span><br>        System.out.println(<span class="hljs-string">"服务器的地址："</span> + ctx.channel().remoteAddress());<br>        System.out.println(<span class="hljs-string">"服务器的消息："</span> + msg);<br>    }<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    MyLongToByteEncoder类的父类MessageToByteEncoder的write方法：</span><br><span class="hljs-comment">    @Override</span><br><span class="hljs-comment">    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {</span><br><span class="hljs-comment">        ByteBuf buf = null;</span><br><span class="hljs-comment">        try {</span><br><span class="hljs-comment">            if (acceptOutboundMessage(msg)) { // 判断msg是否是应该处理的类型</span><br><span class="hljs-comment">                @SuppressWarnings("unchecked")</span><br><span class="hljs-comment">                I cast = (I) msg;</span><br><span class="hljs-comment">                buf = allocateBuffer(ctx, cast, preferDirect);</span><br><span class="hljs-comment">                try {</span><br><span class="hljs-comment">                    encode(ctx, cast, buf); // 是就进行encode</span><br><span class="hljs-comment">                } finally {</span><br><span class="hljs-comment">                    ReferenceCountUtil.release(cast);</span><br><span class="hljs-comment">                }</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                if (buf.isReadable()) {</span><br><span class="hljs-comment">                    ctx.write(buf, promise);</span><br><span class="hljs-comment">                } else {</span><br><span class="hljs-comment">                    buf.release();</span><br><span class="hljs-comment">                    ctx.write(Unpooled.EMPTY_BUFFER, promise);</span><br><span class="hljs-comment">                }</span><br><span class="hljs-comment">                buf = null;</span><br><span class="hljs-comment">            } else {</span><br><span class="hljs-comment">                ctx.write(msg, promise); // 不是就直接写回去</span><br><span class="hljs-comment">            }</span><br><span class="hljs-comment">        } catch (EncoderException e) {</span><br><span class="hljs-comment">            throw e;</span><br><span class="hljs-comment">        } catch (Throwable e) {</span><br><span class="hljs-comment">            throw new EncoderException(e);</span><br><span class="hljs-comment">        } finally {</span><br><span class="hljs-comment">            if (buf != null) {</span><br><span class="hljs-comment">                buf.release();</span><br><span class="hljs-comment">            }</span><br><span class="hljs-comment">        }</span><br><span class="hljs-comment">    }</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    因此：编写的Encoder要注意传入的数据类型和处理的数据类型一致</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"MyClientHandler 发送数据..."</span>);<br>        ctx.writeAndFlush(<span class="hljs-number">123456L</span>);<br>        <span class="hljs-comment">// ctx.writeAndFlush(Unpooled.copiedBuffer("abcdabcdabcdabcd", CharsetUtil.UTF_8));</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="5、解码器-ReplayingDecoder"><a class="header-anchor" href="#5、解码器-ReplayingDecoder">¶</a>5、解码器-ReplayingDecoder</h2>
<ol>
<li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></li>
<li>ReplayingDecoder 扩展了 ByteToMessageDecoder 类，使用这个类，我们不必调用 readableBytes()方法。参数 S 指定了用户状态管理的类型，其中 Void 代表不需要状态管理</li>
<li>ReplayingDecoder 使用方便，但它也有一些局限性：</li>
<li>并不是所有的 ByteBuf 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个<code>UnsupportedOperationException</code>。</li>
<li>ReplayingDecoder 在某些情况下可能稍慢于 ByteToMessageDecoder，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li>
</ol>
<p><strong>应用实例：使用 ReplayingDecoder 编写解码器，对前面的案例进行简化</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ReplayingDecoder使用此父类可以自动完成数据字节判断！无需手动调用 readableBytes()方法</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-10-30 13:46</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyByteToLongDecoder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>{ <span class="hljs-comment">// Void 代表不需要状态管理</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"MyByteToLongDecoder2 被调用"</span>);<br>        <span class="hljs-comment">//在 ReplayingDecoder 不需要判断数据是否足够读取，内部会进行处理判断</span><br>        out.add(in.readLong());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="6、其它编解码器"><a class="header-anchor" href="#6、其它编解码器">¶</a>6、其它编解码器</h2>
<h3 id="解码器"><a class="header-anchor" href="#解码器">¶</a>解码器</h3>
<ol>
<li>LineBasedFrameDecoder：这个类在 Netty 内部也有使用，它使用行尾控制字符（\n 或者\r\n）作为分隔符来解析数据。</li>
<li>DelimiterBasedFrameDecoder：使用自定义的特殊字符作为消息的分隔符。</li>
<li>HttpObjectDecoder：一个 HTTP 数据的解码器</li>
<li>LengthFieldBasedFrameDecoder：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</li>
</ol>
<h3 id="编码器"><a class="header-anchor" href="#编码器">¶</a>编码器</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@376ac81b4e859790c4ec5a2ae3c4988c4fe84435/2021/11/02/e4cd29c6c3b5c31b1fdfcfd288e5c12f.png" alt=""></p>
<h2 id="7、Netty-整合-Log4j"><a class="header-anchor" href="#7、Netty-整合-Log4j">¶</a>7、Netty 整合 Log4j</h2>
<h3 id="pom-xml"><a class="header-anchor" href="#pom-xml">¶</a>pom.xml</h3>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="properties"><a class="header-anchor" href="#properties">¶</a>properties</h3>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">DEBUG, stdout</span><br><span class="hljs-meta">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">[%p] %C{1} - %m%n</span><br></code></pre></td></tr></tbody></table></figure>
<h1 id="八、TCP-粘包和拆包及解决方案"><a class="header-anchor" href="#八、TCP-粘包和拆包及解决方案">¶</a>八、TCP 粘包和拆包及解决方案</h1>
<h2 id="1、TCP-粘包和拆包基本介绍"><a class="header-anchor" href="#1、TCP-粘包和拆包基本介绍">¶</a>1、TCP 粘包和拆包基本介绍</h2>
<ol>
<li>TCP 是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的 socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（Nagle 算法），<strong>将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包</strong>。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是<strong>无消息保护边界</strong>的</li>
<li>由于 TCP 无消息保护边界, 需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题, 看一张图</li>
<li>示意图 TCP 粘包、拆包图解</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@bcbde0a8fdc7dd88aacf4a5c5c61c69f4b9144b3/2021/11/02/b1ae04cfd60c4173f5cbfa607168a406.png" alt=""></p>
<p><strong>简单说明：</strong></p>
<p>假设客户端分别发送了两个数据包 D1 和 D2 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</p>
<ol>
<li>服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2，没有粘包和拆包</li>
<li>服务端一次接受到了两个数据包，D1 和 D2 粘合在一起，称之为 TCP 粘包</li>
<li>服务端分两次读取到了数据包，第一次读取到了完整的 D1 包和 D2 包的部分内容，第二次读取到了 D2 包的剩余内容，这称之为 TCP 拆包</li>
<li>服务端分两次读取到了数据包，第一次读取到了 D1 包的部分内容 D1_1，第二次读取到了 D1 包的剩余部分内容 D1_2 和完整的 D2 包。</li>
</ol>
<h2 id="2、TCP-粘包和拆包现象实例"><a class="header-anchor" href="#2、TCP-粘包和拆包现象实例">¶</a>2、TCP 粘包和拆包现象实例</h2>
<h3 id="MyServerHandler-3"><a class="header-anchor" href="#MyServerHandler-3">¶</a>MyServerHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[msg.readableBytes()];<br>        msg.readBytes(buffer);<br>        String s = <span class="hljs-keyword">new</span> String(buffer, CharsetUtil.UTF_8);<br>        System.out.println(<span class="hljs-string">"服务器端接收数据："</span> + s);<br>        System.out.println(<span class="hljs-string">"服务器收到消息量："</span> + (++ count));<br><br>        <span class="hljs-comment">// 服务器回复消息给客户端</span><br>        ByteBuf byteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="hljs-string">" "</span>, CharsetUtil.UTF_8);<br>        ctx.writeAndFlush(byteBuf);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        ctx.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="MyClientHandler-2"><a class="header-anchor" href="#MyClientHandler-2">¶</a>MyClientHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 客户端发送十条数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {<br>            ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="hljs-string">"hello,Server"</span> + i + <span class="hljs-string">" "</span>, CharsetUtil.UTF_8);<br>            ctx.writeAndFlush(byteBuf);<br>        }<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 处理服务器发来的消息</span><br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[msg.readableBytes()];<br>        ByteBuf byteBuf = msg.readBytes(buffer);<br>        String s = <span class="hljs-keyword">new</span> String(buffer, CharsetUtil.UTF_8);<br>        System.out.println(<span class="hljs-string">"客户端接收到消息："</span> + s);<br>        System.out.println(<span class="hljs-string">"客户端接收消息数量："</span> + (++ count));<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        ctx.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="结果-2"><a class="header-anchor" href="#结果-2">¶</a>结果</h3>
<p>客户端发送十条消息，服务器端的接收不是十次，而小于十次，且每次接收的数据量不一定！</p>
<h2 id="3、TCP-粘包和拆包解决方案"><a class="header-anchor" href="#3、TCP-粘包和拆包解决方案">¶</a>3、TCP 粘包和拆包解决方案</h2>
<p><strong>使用自定义协议 + 编解码器 来解决</strong></p>
<p>关键就是要解决服务器端每次读取数据长度的问题, 这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 TCP 粘包、拆包 。</p>
<p><strong>实例要求：</strong></p>
<ol>
<li>要求客户端发送 5 个 Message 对象, 客户端每次发送一个 Message 对象</li>
<li>服务器端每次接收一个 Message, 分 5 次进行解码， 每读取到 一个 Message , 会回复一个 Message 对象 给客户端</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@44cab141a7622b1491a6a7d6a2261f9f9de39cb5/2021/11/02/132713db68bc065c207912e0c855db16.png" alt=""></p>
<h3 id="MessageProtocol"><a class="header-anchor" href="#MessageProtocol">¶</a>MessageProtocol</h3>
<p>自定义协议包！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义协议包！</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-10-30 15:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProtocol</span> </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> len;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] content;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLen</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> len;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>{<br>        <span class="hljs-keyword">this</span>.len = len;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getContent() {<br>        <span class="hljs-keyword">return</span> content;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] content)</span> </span>{<br>        <span class="hljs-keyword">this</span>.content = content;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="MyMessageDecoder"><a class="header-anchor" href="#MyMessageDecoder">¶</a>MyMessageDecoder</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReplayingDecoder</span>&lt;<span class="hljs-title">Void</span>&gt; </span>{<br>    <span class="hljs-comment">// 重写解码方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"MyMessageDecoder decode 被调用！"</span>);<br>        <span class="hljs-comment">// 将 字节 转成 MessageProtocol</span><br>        <span class="hljs-keyword">int</span> length = in.readInt();<br>        <span class="hljs-keyword">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];<br>        in.readBytes(content);<br><br>        <span class="hljs-comment">// 交给下一个handler</span><br>        MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();<br>        messageProtocol.setLen(length);<br>        messageProtocol.setContent(content);<br><br>        out.add(messageProtocol);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="MyMessageEncoder"><a class="header-anchor" href="#MyMessageEncoder">¶</a>MyMessageEncoder</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>{<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"MyMessageEncoder encode 方法被调用！"</span>);<br>        out.writeInt(msg.getLen());<br>        out.writeBytes(msg.getContent());<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="MyServerHandler-4"><a class="header-anchor" href="#MyServerHandler-4">¶</a>MyServerHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br><br>        <span class="hljs-comment">// 接收客户端消息处理</span><br>        <span class="hljs-keyword">int</span> len = msg.getLen();<br>        <span class="hljs-keyword">byte</span>[] content = msg.getContent();<br><br>        System.out.println(<span class="hljs-string">"服务器接受的信息："</span> + <span class="hljs-string">"长度 = "</span> + len + <span class="hljs-string">" 内容 = "</span><br>                + <span class="hljs-keyword">new</span> String(content, CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">"服务器接收到消息包数量："</span> + (++ count));<br><br>        <span class="hljs-comment">// 服务器回复客户端消息</span><br>        String response = UUID.randomUUID().toString();<br>        <span class="hljs-keyword">byte</span>[] responseContent = response.getBytes(CharsetUtil.UTF_8);<br>        <span class="hljs-keyword">int</span> responseLen = responseContent.length;<br>        <span class="hljs-comment">// 构建 协议包</span><br>        MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();<br>        messageProtocol.setLen(responseLen);<br>        messageProtocol.setContent(responseContent);<br><br>        ctx.writeAndFlush(messageProtocol);<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        ctx.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h3 id="MyClientHandler-3"><a class="header-anchor" href="#MyClientHandler-3">¶</a>MyClientHandler</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MessageProtocol</span>&gt; </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 客户端发送十条数据 "今天天气冷，吃火锅"</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {<br>            String msg = <span class="hljs-string">"今天天气冷，吃火锅"</span>;<br>            <span class="hljs-keyword">byte</span>[] content = msg.getBytes(CharsetUtil.UTF_8);<br>            <span class="hljs-keyword">int</span> length = content.length;<br><br>            <span class="hljs-comment">// 创建协议包</span><br>            MessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MessageProtocol();<br>            messageProtocol.setLen(length);<br>            messageProtocol.setContent(content);<br>            ctx.writeAndFlush(messageProtocol);<br>        }<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        <span class="hljs-comment">// 处理服务器发来的消息</span><br>        <span class="hljs-keyword">int</span> len = msg.getLen();<br>        <span class="hljs-keyword">byte</span>[] content = msg.getContent();<br>        System.out.println(<span class="hljs-string">"客户端接收到消息："</span> + <span class="hljs-string">"长度 = "</span> + len + <span class="hljs-string">" 内容 = "</span><br>                + <span class="hljs-keyword">new</span> String(content, CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">"客户单收到的消息包数量："</span> + (++ count));<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        ctx.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h1 id="九、Netty-核心源码剖析"><a class="header-anchor" href="#九、Netty-核心源码剖析">¶</a>九、Netty 核心源码剖析</h1>
<h2 id="1、Netty-启动过程"><a class="header-anchor" href="#1、Netty-启动过程">¶</a>1、Netty 启动过程</h2>
<ol>
<li>创建 2 个 EventLoopGroup 线程池数组。数组默认大小 CPU*2，方便 chooser 选择线程池时提高性能</li>
<li>BootStrap 将 boss 设置为 group 属性，将 worker 设置为 childer 属性</li>
<li>通过 bind 方法启动，内部重要方法为 initAndRegister 和 dobind 方法</li>
<li>initAndRegister 方法会反射创建 NioServerSocketChannel 及其相关的 NIO 的对象， pipeline ， unsafe，同时也为 pipeline 初始了 head 节点和 tail 节点。</li>
<li>在 register0 方法成功以后调用在 dobind 方法中调用 doBind0 方法，该方法会 调用 NioServerSocketChannel的 doBind 方法对 JDK 的 channel 和端口进行绑定，完成 Netty 服务器的所有启动，并开始监听连接事件</li>
</ol>
<h2 id="2、Netty-接受请求过程"><a class="header-anchor" href="#2、Netty-接受请求过程">¶</a>2、Netty 接受请求过程</h2>
<p><strong>EventLoop 的作用是一个死循环，而这个循环中做 3 件事情：</strong></p>
<ol>
<li>有条件的等待 Nio 事件。</li>
<li>处理 Nio 事件。</li>
<li>处理消息队列中的任务。</li>
<li>仍用前面的项目来分析：进入到 NioEventLoop 源码中后，在 private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) 方法开始调试最终我们要分析到 AbstractNioChannel 的 doBeginRead 方法， 当到这个方法时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</li>
</ol>
<p><strong>总体流程：接受连接-----&gt;创建一个新的 NioSocketChannel-----------&gt;注册到一个 worker EventLoop 上--------&gt; 注册 selecot Read 事件：</strong></p>
<ol>
<li>服务器轮询 Accept 事件，获取事件后调用 unsafe 的 read 方法，这个 unsafe 是 ServerSocket 的内部类，该方法内部由 2 部分组成</li>
<li>doReadMessages 用于创建 NioSocketChannel 对象，该对象包装 JDK 的 Nio Channel 客户端。该方法会像创建 ServerSocketChanel 类似创建相关的 pipeline ， unsafe，config</li>
<li>随后执行 执行 pipeline.fireChannelRead 方法，并将自己绑定到一个 chooser 选择器选择的 workerGroup 中的一个 EventLoop。并且注册一个 0，表示注册成功，但并没有注册读（1）事件</li>
</ol>
<h2 id="3、Pipeline-Handler-HandlerContext-创建"><a class="header-anchor" href="#3、Pipeline-Handler-HandlerContext-创建">¶</a>3、Pipeline Handler HandlerContext 创建</h2>
<p><strong>ChannelPipeline | ChannelHandler | ChannelHandlerContext 介绍</strong></p>
<p><strong>三者关系</strong></p>
<ol>
<li>每当 ServerSocket 创建一个新的连接，就会创建一个 Socket，对应的就是目标客户端。</li>
<li>每一个新创建的 Socket 都将会分配一个全新的 ChannelPipeline（以下简称 pipeline）</li>
<li>每一个 ChannelPipeline 内部都含有多个 ChannelHandlerContext（以下简称 Context）</li>
<li>他们一起组成了双向链表，这些 Context 用于包装我们调用 addLast 方法时添加的 ChannelHandler（以下简称handler）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@15a7f7a4872d52f12b8d7c1c55032a9434282218/2021/11/02/f2ec3adf77275539ca1b81bab951f2da.png" alt=""></p>
<ol>
<li>上图中：ChannelSocket 和 ChannelPipeline 是一对一的关联关系，而 pipeline 内部的多个 Context 形成了链表，Context 只是对 Handler 的封装。</li>
<li>当一个请求进来的时候，会进入 Socket 对应的 pipeline，并经过 pipeline 所有的 handler，对，就是设计模式中的过滤器模式。</li>
</ol>
<p><strong>pipeline 的接口设计</strong></p>
<p>该接口继承了 inBound，outBound，Iterable 接口，表示他可以调用<strong>数据出站的方法和入站的方法</strong>，同时也能遍历内部的链表， 看看他的几个代表性的方法，基本上都是针对 handler 链表的插入，追加，删除，替换操作，类似是一个 LinkedList。同时，也能返回 channel（也就是 socket）</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@fbd55b2d7a0025b626168d7f79475fa2cf103f45/2021/11/02/606381a96a916fd83c796f0905c1002d.png" alt=""></p>
<p><strong>对上图说明：</strong></p>
<ul>
<li>
<p>这是一个 handler 的 list，handler 用于处理或拦截入站事件和出站事件，pipeline 实现了过滤器的高级形式，以便用户控制事件如何处理以及 handler 在 pipeline 中如何交互。</p>
</li>
<li>
<p>上图描述了一个典型的 handler 在 pipeline 中处理 I/O 事件的方式，IO 事件由 inboundHandler 或者outBoundHandler 处理，并通过调用 ChannelHandlerContext.fireChannelRead 方法转发给其最近的处理程序 。</p>
</li>
<li>
<p>入站事件由入站处理程序以自下而上的方向处理，如图所示。入站处理程序通常处理由图底部的 I / O 线程生成入站数据。入站数据通常从如 SocketChannel.read(ByteBuffer) 获取。</p>
</li>
<li>
<p><strong>通常一个 pipeline 有多个 handler</strong>，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序</p>
<ul>
<li>协议解码器 - 将二进制数据转换为 Java 对象。</li>
<li>协议编码器 - 将 Java 对象转换为二进制数据。</li>
<li>业务逻辑处理程序 - <strong>执行实际业务逻辑</strong>（例如数据库访问）</li>
</ul>
</li>
<li>
<p>你的业务程序不能将线程阻塞，会影响 IO 的速度，进而影响整个 Netty 程序的性能。如果你的业务程序很快，就可以放在 IO 线程中，反之，你需要异步执行。或者在添加 handler 的时候添加一个线程池，例如：</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 下面这个任务执行的时候，将不会阻塞 IO 线程，执行的线程来自 group 线程池</span><br>pipeline.addLast(group，“handler”，<span class="hljs-keyword">new</span> MyBusinessLogicHandler());<br></code></pre></td></tr></tbody></table></figure>
<p><strong>ChannelHandler设计：</strong></p>
<p>ChannelHandler 的作用就是处理 IO 事件或拦截 IO 事件，并将其<strong>转发给下一个</strong>处理程序 ChannelHandler。Handler 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，Netty 定义了两个子接口继承 ChannelHandler</p>
<ul>
<li>ChannelInboundHandler 入站事件接口</li>
<li>ChannelDuplexHandler 处理出站和入站事件</li>
<li>ChannelOutboundHandler 出站事件接口</li>
</ul>
<p><strong>ChannelHandlerContext 设计：</strong></p>
<p>继承了 ChannelOutboundInvoker 和 ChannelInboundInvoker ，这两个 invoker 就是针对入站或出站方法来的，就是在 入站或出站 handler 的外层再包装一层，达到在方法前后拦截并做一些特定操作的目的。</p>
<ul>
<li>ChannelHandlerContext 不仅仅时继承了他们两个的方法，同时也定义了一些自己的方法</li>
<li>这些方法能够获取 Context 上下文环境中对应的比如 channel，executor，handler ，pipeline，内存分配器，关联的 handler 是否被删除。</li>
<li>Context 就是包装了 handler 相关的一切，以方便 Context 可以在 pipeline 方便的操作 handler</li>
</ul>
<p><strong>创建过程：</strong></p>
<ul>
<li>任何一个 ChannelSocket 创建的同时都会创建 一个 pipeline。</li>
<li>当用户或系统内部调用 pipeline 的 add*** 方法添加 handler 时，都会创建一个包装这 handler 的 Context。</li>
<li>这些 Context 在 pipeline 中组成了<strong>双向链表</strong>。</li>
</ul>
<p><strong>小总结：</strong></p>
<ol>
<li>每当创建 ChannelSocket 的时候都会创建一个绑定的 pipeline，一对一的关系，创建 pipeline 的时候也会创建tail 节点和 head 节点，形成最初的链表。</li>
<li>在调用 pipeline 的 addLast 方法的时候，会根据给定的 handler 创建一个 Context，然后，将这个 Context 插入到链表的尾端（<strong>tail 前面</strong>）。</li>
<li>Context 包装 handler，多个 Context 在 pipeline 中形成了双向链表</li>
<li>入站方向叫 inbound，由 head 节点开始，出站方法叫 outbound ，由 tail 节点开始</li>
</ol>
<h2 id="4、ChannelPipeline-调度-handler"><a class="header-anchor" href="#4、ChannelPipeline-调度-handler">¶</a>4、ChannelPipeline 调度 handler</h2>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@5b738e0afaebb59cf6e1dfa6f16e105896184b16/2021/11/02/1050ce24498ae2acddaa96d7b5a3d14d.png" alt=""></p>
<p><strong>简单说明：</strong></p>
<ol>
<li>pipeline 首先会调用 Context 的静态方法 fireXXX，并传入 Context</li>
<li>然后，静态方法调用 Context 的 invoker 方法，而 invoker 方法内部会调用该 Context 所包含的Handler 的真正的 XXX 方法，调用结束后，如果还需要继续向后传递，就调用 Context 的 fireXXX2 方法，循环往复。</li>
</ol>
<p><strong>小总结：</strong></p>
<ol>
<li>Context 包装 handler，多个 Context 在 pipeline 中形成了<strong>双向链表</strong>，入站方向叫 inbound，由 head 节点开始，出站方法叫 outbound ，由 tail 节点开始。</li>
<li>而节点中间的传递通过 AbstractChannelHandlerContext 类内部的 fire 系列方法，找到当前节点的下一个节点不断的循环传播。是一个过滤器形式完成对 handler 的调度</li>
</ol>
<h2 id="5、Netty-心跳-heartbeat-服务"><a class="header-anchor" href="#5、Netty-心跳-heartbeat-服务">¶</a>5、Netty 心跳(heartbeat)服务</h2>
<blockquote>
<p>Netty 作为一个网络框架，提供了诸多功能，比如编码解码等，Netty 还提供了非常重要的一个服务-----心跳机制 heartbeat。通过心跳检查对方是否有效，这是 RPC 框架中是必不可少的功能。</p>
</blockquote>
<p>Netty 提供了 IdleStateHandler ，ReadTimeoutHandler，WriteTimeoutHandler 三个 Handler 检测连接的有效性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@d84049983dae5d1594177a008d268d49069790bc/2021/11/02/6955953b1322d137a874992f6fa99a44.png" alt=""></p>
<p><strong>小总结：</strong></p>
<ol>
<li>IdleStateHandler 可以实现心跳功能，当服务器和客户端没有任何读写交互时，并超过了给定的时间，则会触发用户 handler 的 userEventTriggered 方法。用户可以在这个方法中尝试向对方发送信息，如果发送失败，则关闭连接。</li>
<li>IdleStateHandler 的实现基于 EventLoop 的<strong>定时任务</strong>，每次读写都会记录一个值，在定时任务运行的时候，通过计算当前时间和设置时间和上次事件发生时间的结果，来判断是否空闲。</li>
<li>内部有 3 个定时任务，分别对应<strong>读事件，写事件，读写事件</strong>。通常用户监听读写事件就足够了。</li>
<li>同时，IdleStateHandler 内部也考虑了一些极端情况：客户端接收缓慢，一次接收数据的速度超过了设置的空闲时间。Netty 通过构造方法中的 observeOutput 属性来决定是否对出站缓冲区的情况进行判断。</li>
<li>如果出站缓慢，Netty 不认为这是空闲，也就不触发空闲事件。但第一次无论如何也是要触发的。因为第一次无法判断是出站缓慢还是空闲。当然，出站缓慢的话，可能造成 OOM , OOM 比空闲的问题更大。</li>
<li>所以，当你的应用出现了内存溢出，OOM 之类，并且写空闲极少发生（使用了 observeOutput 为 true），那么就需要注意是不是数据出站速度过慢。</li>
<li>还有一个注意的地方：就是 ReadTimeoutHandler ，它继承自 IdleStateHandler，当触发读空闲事件的时候，就触发 ctx.fireExceptionCaught 方法，并传入一个 ReadTimeoutException，然后关闭 Socket。</li>
<li>而 WriteTimeoutHandler 的实现不是基于 IdleStateHandler 的，他的原理是，当调用 write 方法的时候，会创建一个定时任务，任务内容是根据传入的 promise 的完成情况来判断是否超出了写的时间。当定时任务根据指定时间开始运行，发现 promise 的 isDone 方法返回 false，表明还没有写完，说明超时了，则抛出异常。当 write方法完成后，会打断定时任务。</li>
</ol>
<h2 id="6、Netty-核心组件-EventLoop"><a class="header-anchor" href="#6、Netty-核心组件-EventLoop">¶</a>6、Netty 核心组件 EventLoop</h2>
<h3 id="示意图"><a class="header-anchor" href="#示意图">¶</a>示意图</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@74c274f46b86a3a47cf5b6282c1d61709ffefd7a/2021/11/02/bf96f8d22eb8d6ad8580fa1aaf30b524.png" alt=""></p>
<p><strong>简单说明：</strong></p>
<ol>
<li>ScheduledExecutorService 接口表示是一个定时任务接口，<strong>EventLoop 可以接受定时任务</strong>。</li>
<li>EventLoop 接口：Netty 接口文档说明该接口作用：一旦 Channel 注册了，就处理该 Channel 对应的所有I/O 操作。</li>
<li>SingleThreadEventExecutor 表示这是一个单个线程的线程池</li>
<li>EventLoop 是一个单例的线程池，里面含有一个死循环的线程不断的做着 3 件事情：<strong>监听端口，处理端口事件，处理队列事件</strong>。每个 EventLoop 都可以绑定多个 Channel，而每个 Channel 始终只能由一个 EventLoop 来处理</li>
</ol>
<p><strong>小总结：</strong></p>
<ol>
<li>每次执行 ececute 方法都是向队列中添加任务。当第一次添加时就启动线程，执行 run 方法，而 run 方法是整个 EventLoop 的核心，就像 EventLoop 的名字一样，Loop Loop ，不停的 Loop ，Loop 做什么呢？做 3 件事情。</li>
<li>调用 selector 的 select 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 0.5秒进行阻塞。当执行 execute 方法的时候，也就是添加任务的时候，唤醒 selecor，防止 selecotr 阻塞时间过长。</li>
<li>当 selector 返回的时候，回调用 processSelectedKeys 方法对 selectKey 进行处理。</li>
<li>当 processSelectedKeys 方法执行结束后，则按照 ioRatio 的比例执行 runAllTasks 方法，默认是 IO 任务时间和非 IO 任务时间是相同的，你也可以根据你的应用特点进行<strong>调优</strong> 。比如 非 IO 任务比较多，那么你就将ioRatio 调小一点，这样非 IO 任务就能执行的长一点。防止队列积攒过多的任务。</li>
</ol>
<h2 id="7、handler-中加入线程池和-Context-中添加线程池"><a class="header-anchor" href="#7、handler-中加入线程池和-Context-中添加线程池">¶</a>7、handler 中加入线程池和 Context 中添加线程池</h2>
<ol>
<li>在 Netty 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 Netty 对 Socket 的处理速度。</li>
<li>而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲，可以有 2 种方式，而且这 2 种方式实现的区别也蛮大的。</li>
<li>处理耗时业务的第一种方式—handler 中加入线程池</li>
<li>处理耗时业务的第二种方式—Context 中添加线程池</li>
</ol>
<p><strong>handler 中加入线程池：</strong></p>
<ol>
<li>当 IO 线程轮询到一个 socket 事件，然后，IO 线程开始处理，当走到耗时 handler 的时候，将耗时任务交给业务线程池。</li>
<li>当耗时任务执行完毕再执行 pipeline write 方法的时候 ，会将任务这个任务交给 IO 线程</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>{<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventExecutorGroup group = <span class="hljs-keyword">new</span> DefaultEventExecutorGroup(<span class="hljs-number">16</span>);<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException, InterruptedException </span>{<br>        <span class="hljs-keyword">final</span> Object msgCop = msg;<br>        <span class="hljs-keyword">final</span> ChannelHandlerContext cxtCop = ctx;<br>        group.submit(<span class="hljs-keyword">new</span> Callable&lt;Object&gt;() {<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>                ByteBuf buf = (ByteBuf) msgCop;<br>                <span class="hljs-keyword">byte</span>[] req = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buf.readableBytes()];<br>                buf.readBytes(req);<br>                String body = <span class="hljs-keyword">new</span> String(req, <span class="hljs-string">"UTF-8"</span>);<br>                Thread.sleep(<span class="hljs-number">10</span>*<span class="hljs-number">1000</span>);<br>                System.err.println(body + <span class="hljs-string">" "</span> + Thread.currentThread().getName());<br>                String reqString = <span class="hljs-string">"Hello i am server~~~"</span>;<br>                ByteBuf resp = Unpooled.copiedBuffer(reqString.getBytes());<br>                cxtCop.writeAndFlush(resp);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            }<br>        });<br>        System.out.println(<span class="hljs-string">"go on .."</span>);<br>    }<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>{<br>        ctx.flush();<br>    }<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>{<br>        <span class="hljs-comment">// Close the connection when an exception is raised. cause.printStackTrace();</span><br>        ctx.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>Context 中添加线程池：</strong></p>
<ol>
<li>handler 中的代码就使用普通的方式来处理耗时业务。</li>
<li>当我们在调用 addLast 方法添加线程池后，handler 将优先使用这个线程池，如果不添加，将使用 IO 线程</li>
<li>当走到 AbstractChannelHandlerContext 的 invokeChannelRead 方法的时候，executor.inEventLoop() 是不会通过的，因为当前线程是 IO 线程， Context（也就是 Handler）的 executor 是业务线程，所以会异步执行</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventExecutorGroup group = <span class="hljs-keyword">new</span> DefaultEventExecutorGroup(<span class="hljs-number">16</span>);<br>ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();<br>b.group(bossGroup, workerGroup)<br>    .channel(NioServerSocketChannel.class)<br>    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)<br>    .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))<br>    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>            ChannelPipeline p = ch.pipeline();<br>            <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) {<br>                p.addLast(sslCtx.newHandler(ch.alloc()));<br>            }<br>            <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span><br>            <span class="hljs-comment">//p.addLast(new EchoServerHandler());</span><br>            p.addLast(group,<span class="hljs-keyword">new</span> EchoServerHandler() );<br>        }<br>    });<br></code></pre></td></tr></tbody></table></figure>
<p><strong>小总结：</strong></p>
<ol>
<li>第一种方式在 handler 中添加异步，可能更加的自由，比如如果需要访问数据库，那我就异步，如果不需要，就不异步，异步会拖长接口响应时间。因为需要将任务放进 mpscTask 中。如果 IO 时间很短，task 很多，可能一个循环下来，都没时间执行整个 task，导致响应时间达不到指标。</li>
<li>第二种方式是 Netty 标准方式(即加入到队列)，但是，这么做会将整个 handler 都交给业务线程池。不论耗时不耗时，都加入到队列里，不够灵活。</li>
<li>各有优劣，从灵活性考虑，第一种较好</li>
</ol>
<h1 id="十、用-Netty-实现-dubbo-RPC"><a class="header-anchor" href="#十、用-Netty-实现-dubbo-RPC">¶</a>十、用 Netty 实现 dubbo RPC</h1>
<h2 id="1、RPC-基本介绍"><a class="header-anchor" href="#1、RPC-基本介绍">¶</a>1、RPC 基本介绍</h2>
<ol>
<li>RPC（Remote Procedure Call）— 远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</li>
<li>两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样</li>
<li>常见的 RPC 框架有: 比较知名的如阿里的Dubbo、google的gRPC、Go语言的rpcx、Apache的thrift，Spring 旗下的 Spring Cloud。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@06497d709d8ffd1f2320a97fbee37b4ce57b5049/2021/11/02/876c4573ae04b62337d097e492293bf0.png" alt=""></p>
<h2 id="2、RPC-调用流程图"><a class="header-anchor" href="#2、RPC-调用流程图">¶</a>2、RPC 调用流程图</h2>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@410464c89b196822d87d301b1dcde2f59fad79e9/2021/11/02/61d239ad2734fcc7db36472446dc2749.png" alt=""></p>
<h2 id="3、PRC-调用流程说明"><a class="header-anchor" href="#3、PRC-调用流程说明">¶</a>3、PRC 调用流程说明</h2>
<p>RPC 的目标就是将 2-8 这些步骤都封装起来，用户无需关心这些细节，可以像调用本地方法一样即可完成远程服务调用：</p>
<ol>
<li><strong>服务消费方(client)以本地调用方式调用服务</strong></li>
<li>client stub 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体</li>
<li>client stub 将消息进行编码并发送到服务端</li>
<li>server stub 收到消息后进行解码</li>
<li>server stub 根据解码结果调用本地的服务</li>
<li>本地服务执行并将结果返回给 server stub</li>
<li>server stub 将返回导入结果进行编码并发送至消费方</li>
<li>client stub 接收到消息并进行解码</li>
<li><strong>服务消费方(client)得到结果</strong></li>
</ol>
<h2 id="4、基于-Netty-实现-dubbo-RPC"><a class="header-anchor" href="#4、基于-Netty-实现-dubbo-RPC">¶</a>4、基于 Netty 实现 dubbo RPC</h2>
<h3 id="需求说明"><a class="header-anchor" href="#需求说明">¶</a>需求说明</h3>
<ol>
<li>dubbo 底层使用了 Netty 作为网络通讯框架，要求用 Netty 实现一个简单的 RPC 框架</li>
<li>模仿 dubbo，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 Netty 4.1.20</li>
</ol>
<h3 id="设计说明"><a class="header-anchor" href="#设计说明">¶</a>设计说明</h3>
<ol>
<li>创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。</li>
<li>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。</li>
<li>创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 Netty 请求提供者返回数据</li>
<li>开发的分析图</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@2285b1db006dc7f95e873b9c16e5edeeea0d56a1/2021/11/02/b12f41f724594ce202cdcab7f8fa3c70.png" alt=""></p>
<h3 id="代码实现-2"><a class="header-anchor" href="#代码实现-2">¶</a>代码实现</h3>
<p><img src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@204b4ecad617e90f6c323d9ffd183de35d786b80/2021/11/02/c40f83aea610be4b96a3cd70d459ee35.png" alt=""></p>
<h4 id="HelloService"><a class="header-anchor" href="#HelloService">¶</a>HelloService</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>{<br><br>    <span class="hljs-function">String <span class="hljs-title">hello</span><span class="hljs-params">(String msg)</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="HelloServiceImpl"><a class="header-anchor" href="#HelloServiceImpl">¶</a>HelloServiceImpl</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span> </span>{<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 当消费方调用该方法时就返回一个结果</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String msg)</span> </span>{<br>        System.out.println(<span class="hljs-string">"收到客户端消息："</span> + msg);<br>        <span class="hljs-comment">// 根据msg返回不同结果</span><br>        <span class="hljs-keyword">if</span>(msg != <span class="hljs-keyword">null</span>){<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"你好，客户端，我已经收到你的消息："</span> + msg + <span class="hljs-string">" 第 "</span> + (++count) + <span class="hljs-string">"次"</span>;<br>        }<span class="hljs-keyword">else</span>{<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"你好，客户端，我已经收到你的消息："</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="ServerBootstrap"><a class="header-anchor" href="#ServerBootstrap">¶</a>ServerBootstrap</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用来启动服务提供者，即nettyServer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ITNXD</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-11-01 9:29</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerBootstrap</span> </span>{<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br>        NettyServer.startServer(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6666</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="NettyServer-4"><a class="header-anchor" href="#NettyServer-4">¶</a>NettyServer</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>{<br><br>    <span class="hljs-comment">// 包一层</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startServer</span><span class="hljs-params">(String hostname, <span class="hljs-keyword">int</span> port)</span></span>{<br>        startServer0(hostname, port);<br>    }<br><br>    <span class="hljs-comment">// 完成对nettyServer的启动！</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startServer0</span><span class="hljs-params">(String hostname, <span class="hljs-keyword">int</span> port)</span></span>{<br>        NioEventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        NioEventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>        <span class="hljs-keyword">try</span> {<br><br>            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>                            ChannelPipeline pipeline = ch.pipeline();<br>                            <span class="hljs-comment">// 编解码器</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                            <span class="hljs-comment">// 自定义处理器</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> NettyServerHandler());<br>                        }<br>                    });<br>            ChannelFuture channelFuture = serverBootstrap.bind(hostname, port).sync();<br>            System.out.println(<span class="hljs-string">"服务提供方开始提供服务...."</span>);<br>            channelFuture.channel().closeFuture().sync();<br>        }<span class="hljs-keyword">catch</span> (Exception e){<br>            e.printStackTrace();<br>        }<span class="hljs-keyword">finally</span> {<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="NettyServerHandler-4"><a class="header-anchor" href="#NettyServerHandler-4">¶</a>NettyServerHandler</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>{<br><br>    <span class="hljs-comment">// 获取客户端发送消息，并调用服务</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"msg = "</span> + msg);<br>        <span class="hljs-comment">// 客户端在调用服务器api时，需要满足我们的规范（协议）</span><br>        <span class="hljs-comment">// 比如每次发送消息都要以：HelloService#hello# 开头 HelloService#hello#你好</span><br>        <span class="hljs-keyword">if</span>(msg.toString().startsWith(<span class="hljs-string">"HelloService#hello#"</span>)){<br>            String res = <span class="hljs-keyword">new</span> HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf(<span class="hljs-string">"#"</span>) + <span class="hljs-number">1</span>));<br>            ctx.writeAndFlush(res);<br>        }<br>    }<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        ctx.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="NettyClient-4"><a class="header-anchor" href="#NettyClient-4">¶</a>NettyClient</h4>
<p><strong>基于动态代理实现！</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>{<br><br>    <span class="hljs-comment">// 创建线程池</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> NettyClientHandler client;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 编写代理方法获取代理对象!</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> serviceClass</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> providerName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;?&gt; serviceClass, <span class="hljs-keyword">final</span> String providerName)</span></span>{<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),<br>                <span class="hljs-keyword">new</span> Class[] {serviceClass}, (proxy, method, args) -&gt; {<br><br>            System.out.println(<span class="hljs-string">"(proxy, method, args) 被调用 "</span> + (++count));<br><br><br>            <span class="hljs-comment">// 客户单每调用一次hello，就会进入该代码</span><br>            <span class="hljs-keyword">if</span>(client == <span class="hljs-keyword">null</span>){<br>                initClient();<br>            }<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             设置要发给服务器端的消息</span><br><span class="hljs-comment">             providerName：约定好的协议头</span><br><span class="hljs-comment">             args[0]：客户端调用的 hello(???)的参数</span><br><span class="hljs-comment">             */</span><br>            client.setParam(providerName + args[<span class="hljs-number">0</span>]);<br><br>            <span class="hljs-comment">// 提交client处理器到线程池执行，执行完毕get方法（阻塞的）返回服务器端处理的结果result</span><br>            <span class="hljs-keyword">return</span> executor.submit(client).get();<br>        });<br>    }<br><br>    <span class="hljs-comment">// 初始化客户端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initClient</span><span class="hljs-params">()</span></span>{<br>        client = <span class="hljs-keyword">new</span> NettyClientHandler();<br><br>        NioEventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>        bootstrap.group(group).channel(NioSocketChannel.class)<br>                .option(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)<br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>                        ChannelPipeline pipeline = ch.pipeline();<br>                        <span class="hljs-comment">// 添加编解码器</span><br>                        pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());<br>                        pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                        <span class="hljs-comment">// 添加自定义处理器</span><br>                        pipeline.addLast(client);<br>                    }<br>                });<br>        <span class="hljs-keyword">try</span> {<br>            bootstrap.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6666</span>).sync();<br>        } <span class="hljs-keyword">catch</span> (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="NettyClientHandler-4"><a class="header-anchor" href="#NettyClientHandler-4">¶</a>NettyClientHandler</h4>
<p>使用synchronized进行线程间通信，得到返回结果时候唤醒线程返回服务器结果！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>{<br><br>    <span class="hljs-keyword">private</span> ChannelHandlerContext context; <span class="hljs-comment">// 上下文</span><br>    <span class="hljs-keyword">private</span> String result; <span class="hljs-comment">// 客户端调用方法时返回的结果</span><br>    <span class="hljs-keyword">private</span> String param; <span class="hljs-comment">// 客户端调用方法时的参数</span><br><br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"channelActive 被调用"</span>);<br><br>        <span class="hljs-comment">// 其他方法会使用到当前handler的ctx</span><br>        context = ctx;<br>    }<br><br>    <span class="hljs-comment">// 4 同步方法：最主要的作用是用于线程间的通信（channelRead 和 call）</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"channelRead 被调用"</span>);<br><br>        result = msg.toString();<br>        <span class="hljs-comment">// 唤醒等待的线程</span><br>        notify();<br>    }<br><br>    <span class="hljs-comment">// 3 5 被代理对象调用，发送数据给服务器，wait 等待被channelRead唤醒 返回结果</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        System.out.println(<span class="hljs-string">"call-1 被调用"</span>);<br><br>        <span class="hljs-comment">// 将客户端远程调用的东西发给服务器端处理</span><br>        context.writeAndFlush(param);<br>        <span class="hljs-comment">// wait阻塞等待服务器返回结果</span><br>        wait();<br>        <span class="hljs-comment">// 服务器返回结果被channelRead唤醒后，返回服务器端返回的结果</span><br><br>        System.out.println(<span class="hljs-string">"call-2 被调用"</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>    <span class="hljs-comment">// 6</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{<br>        ctx.close();<br>    }<br><br>    <span class="hljs-comment">// 2 客户单代理对象用于设置发送服务器的数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setParam</span><span class="hljs-params">(String param)</span></span>{<br>        System.out.println(<span class="hljs-string">"setParam 被调用"</span>);<br><br>        <span class="hljs-keyword">this</span>.param = param;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="ClientBootstrap"><a class="header-anchor" href="#ClientBootstrap">¶</a>ClientBootstrap</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientBootstrap</span> </span>{<br><br>    <span class="hljs-comment">// 定义协议头</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String providerName = <span class="hljs-string">"HelloService#hello#"</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{<br>        <span class="hljs-comment">// 创建消费者</span><br>        NettyClient consumer = <span class="hljs-keyword">new</span> NettyClient();<br>        <span class="hljs-comment">// 创建代理对象</span><br>        HelloService helloService = (HelloService) consumer.getBean(HelloService.class, providerName);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) {<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>            <span class="hljs-comment">// 通过代理对象调用服务提供者的服务</span><br>            String res = helloService.hello(<span class="hljs-string">"你好，dubbo！"</span>);<br>            System.out.println(<span class="hljs-string">"调用的结果 res = "</span> + res);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">ITNXD</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.itnxd.cn/posts/44402.html">https://www.itnxd.cn/posts/44402.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.itnxd.cn" target="_blank">小牛博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Netty/">Netty</a><a class="post-meta__tags" href="/tags/NIO/">NIO</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/niuxvdong/pic@e915ec1da8f4fd93824ca93a53c42d6c2371d03d/2021/11/02/5a36755da549fd44dd641d57680b154c.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/WeChantQR.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/WeChantQR.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/AliPayQR.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/niuxvdong/images/img/AliPayQR.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/45102.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@b7d675e1b6ad07dd35414888d9b1abb96dc4ff6f/2021/11/20/59e6bed391110092545ed9ae79229f2f.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端知识点总结</div></div></a></div><div class="next-post pull-right"><a href="/posts/63819.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/niuxvdong/pic@02cbba2ae81a9022f8bc40d04c8ddb89124e18a8/2021/10/25/1d57ced3775c11d0e1c2f25bcd3b1f33.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">处理线程的工具包、JUC并发编程</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81BIO%E7%BC%96%E7%A8%8B"><span class="toc-text">一、BIO编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81I-O-%E6%A8%A1%E5%9E%8B"><span class="toc-text">1、I&#x2F;O 模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-text">2、适用场景分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81BIO-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">3、BIO 基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81BIO-%E7%BC%96%E7%A8%8B%E6%B5%81%E7%A8%8B"><span class="toc-text">4、BIO 编程流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81BIO-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-text">5、BIO 应用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">实例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81BIO-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">6、BIO 问题分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81NIO%E7%BC%96%E7%A8%8B"><span class="toc-text">二、NIO编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81NIO-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、NIO 基本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%A1%88%E4%BE%8B"><span class="toc-text">小案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81NIO-%E5%92%8C-BIO-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">2、NIO 和 BIO 的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81NIO-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">3、NIO 三大核心原理示意图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA-Buffer"><span class="toc-text">4、缓冲区 Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer-%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%AD%90%E7%B1%BB"><span class="toc-text">Buffer 类及其子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ByteBuffer"><span class="toc-text">ByteBuffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E9%80%9A%E9%81%93-Channel"><span class="toc-text">5、通道 Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileChannel-%E7%B1%BB"><span class="toc-text">FileChannel 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-text">本地文件写数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-text">本地文件读数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-text">本地文件读写数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6-transferFrom-%E6%96%B9%E6%B3%95"><span class="toc-text">拷贝文件 transferFrom 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Buffer-%E5%92%8C-Channel-%E7%BB%86%E8%8A%82"><span class="toc-text">6、Buffer 和 Channel 细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E9%80%89%E6%8B%A9%E5%99%A8-Selector"><span class="toc-text">7、选择器 Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-4"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">Selector示意图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector-%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-text">Selector 类相关方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81NIO-%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">8、NIO 非阻塞网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%9B%BE"><span class="toc-text">原理分析图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">案例实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%87%A0%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-text">9、几大组件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SelectionKey"><span class="toc-text">SelectionKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServerSocketChannel"><span class="toc-text">ServerSocketChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SocketChannel"><span class="toc-text">SocketChannel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81NIO%E5%AE%9E%E7%8E%B0%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F"><span class="toc-text">10、NIO实现群聊系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E8%A6%81%E6%B1%82"><span class="toc-text">实例要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-text">服务器端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81NIO-%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-text">11、NIO 与零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">零拷贝基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F-IO-%E6%A8%A1%E5%9E%8B"><span class="toc-text">传统 IO 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-%E4%BC%98%E5%8C%96"><span class="toc-text">mmap 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendFile-%E4%BC%98%E5%8C%96"><span class="toc-text">sendFile 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3"><span class="toc-text">零拷贝的再次理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-%E5%92%8C-sendFile-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">mmap 和 sendFile 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%A1%88%E4%BE%8B"><span class="toc-text">NIO 零拷贝案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Old"><span class="toc-text">Old</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#New"><span class="toc-text">New</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-text">结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81AIO-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">12、AIO 基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81BIO%E3%80%81NIO%E3%80%81AIO-%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-text">13、BIO、NIO、AIO 对比表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Netty%E6%A6%82%E8%BF%B0"><span class="toc-text">三、Netty概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Netty-%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、Netty 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Netty-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2、Netty 应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E8%81%94%E7%BD%91%E8%A1%8C%E4%B8%9A"><span class="toc-text">互联网行业</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E8%A1%8C%E4%B8%9A"><span class="toc-text">游戏行业</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%86%E5%9F%9F"><span class="toc-text">大数据领域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%8E%9F%E7%94%9F-NIO-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">3、原生 NIO 存在的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Netty-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">4、Netty 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Netty-%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="toc-text">5、Netty 版本说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Netty-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">四、Netty 高性能架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、线程模型基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9E-I-O-%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-text">2、传统阻塞 I&#x2F;O 服务模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-text">工作原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%89%B9%E7%82%B9"><span class="toc-text">模型特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">问题分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Reactor-%E6%A8%A1%E5%BC%8F"><span class="toc-text">3、Reactor 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%8D%95-Reactor-%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">4、单 Reactor 单线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE-2"><span class="toc-text">工作原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E"><span class="toc-text">简单说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-text">方案优缺点分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%8D%95-Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">5、单 Reactor 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE-3"><span class="toc-text">工作原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E-2"><span class="toc-text">简单说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90-2"><span class="toc-text">方案优缺点分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E4%B8%BB%E4%BB%8E-Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">6、主从 Reactor 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE-4"><span class="toc-text">工作原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E-3"><span class="toc-text">简单说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90-3"><span class="toc-text">方案优缺点分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reactor-%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93"><span class="toc-text">Reactor 模式小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Netty-%E6%A8%A1%E5%9E%8B"><span class="toc-text">7、Netty 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%89%88"><span class="toc-text">简单版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E7%89%88"><span class="toc-text">进阶版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%89%88"><span class="toc-text">详细版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%9C%8D%E5%8A%A1%E6%A1%88%E4%BE%8B"><span class="toc-text">TCP服务案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NettyServer"><span class="toc-text">NettyServer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NettyServerHandler"><span class="toc-text">NettyServerHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NettyClient"><span class="toc-text">NettyClient</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NettyClientHandler"><span class="toc-text">NettyClientHandler</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BB%BB%E5%8A%A1"><span class="toc-text">任务队列中的三种任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E6%A8%A1%E5%9E%8B%E5%86%8D%E8%AF%B4%E6%98%8E"><span class="toc-text">Netty模型再说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-text">8、异步模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-5"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-%E8%AF%B4%E6%98%8E"><span class="toc-text">Future 说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">工作原理示意图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-Listener-%E6%9C%BA%E5%88%B6"><span class="toc-text">Future-Listener 机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Http-%E6%9C%8D%E5%8A%A1%E6%A1%88%E4%BE%8B"><span class="toc-text">9、Http 服务案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TestServer"><span class="toc-text">TestServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TestServerInitializer"><span class="toc-text">TestServerInitializer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TestHttpServerHandler"><span class="toc-text">TestHttpServerHandler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Netty-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6"><span class="toc-text">五、Netty 核心模块组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Bootstrap%E3%80%81ServerBootstrap"><span class="toc-text">1、Bootstrap、ServerBootstrap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Future%E3%80%81ChannelFuture"><span class="toc-text">2、Future、ChannelFuture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Channel"><span class="toc-text">3、Channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Selector"><span class="toc-text">4、Selector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81ChannelHandler"><span class="toc-text">5、ChannelHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Pipeline%E3%80%81ChannelPipeline"><span class="toc-text">6、Pipeline、ChannelPipeline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81ChannelHandlerContext"><span class="toc-text">7、ChannelHandlerContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81ChannelOption"><span class="toc-text">8、ChannelOption</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81EventLoopGroup%E3%80%81NioEventLoopGroup"><span class="toc-text">9、EventLoopGroup、NioEventLoopGroup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81Unpooled"><span class="toc-text">10、Unpooled</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81Netty-%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F"><span class="toc-text">11、Netty 应用实例-群聊系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GroupChatServer"><span class="toc-text">GroupChatServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GroupChatServerHandler"><span class="toc-text">GroupChatServerHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GroupChatClient"><span class="toc-text">GroupChatClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GroupChatClientHandler"><span class="toc-text">GroupChatClientHandler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81Netty-%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6%E6%A1%88%E4%BE%8B"><span class="toc-text">12、Netty 心跳检测机制案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MyServer"><span class="toc-text">MyServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyServerHandler"><span class="toc-text">MyServerHandler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81Netty-%E9%80%9A%E8%BF%87-WebSocket-%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="toc-text">13、Netty 通过 WebSocket 实现长连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MyServer-2"><span class="toc-text">MyServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler"><span class="toc-text">Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#html"><span class="toc-text">html</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81Google-Protobuf"><span class="toc-text">六、Google Protobuf</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、编码和解码的基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Netty-%E6%9C%AC%E8%BA%AB%E7%BC%96%E8%A7%A3%E7%A0%81%E6%9C%BA%E5%88%B6%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">2、Netty 本身编解码机制问题分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Protobuf"><span class="toc-text">3、Protobuf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Protobuf-%E6%A1%88%E4%BE%8B%E4%B8%80"><span class="toc-text">4、Protobuf 案例一</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Student-proto"><span class="toc-text">Student.proto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyServer-2"><span class="toc-text">NettyServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyServerHandler-2"><span class="toc-text">NettyServerHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyClient-2"><span class="toc-text">NettyClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyClientHandler-2"><span class="toc-text">NettyClientHandler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Protobuf-%E6%A1%88%E4%BE%8B%E4%BA%8C"><span class="toc-text">5、Protobuf 案例二</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Student-proto-2"><span class="toc-text">Student.proto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyServer-3"><span class="toc-text">NettyServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyServerHandler-3"><span class="toc-text">NettyServerHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyClient-3"><span class="toc-text">NettyClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NettyClientHandler-3"><span class="toc-text">NettyClientHandler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81Netty-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-text">七、Netty 编解码器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="toc-text">1、基本说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-text">2、编码解码器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E7%A0%81%E5%99%A8-ByteToMessageDecoder"><span class="toc-text">3、解码器-ByteToMessageDecoder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E7%BB%A7%E6%89%BF%E5%9B%BE"><span class="toc-text">关系继承图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Netty-%E7%9A%84-handler-%E9%93%BE%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">4、Netty 的 handler 链的调用机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MyLongToByteEncoder"><span class="toc-text">MyLongToByteEncoder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyByteToLongDecoder"><span class="toc-text">MyByteToLongDecoder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyServerHandler-2"><span class="toc-text">MyServerHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyClientHandler"><span class="toc-text">MyClientHandler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%A7%A3%E7%A0%81%E5%99%A8-ReplayingDecoder"><span class="toc-text">5、解码器-ReplayingDecoder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%85%B6%E5%AE%83%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-text">6、其它编解码器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-text">解码器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-text">编码器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Netty-%E6%95%B4%E5%90%88-Log4j"><span class="toc-text">7、Netty 整合 Log4j</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pom-xml"><span class="toc-text">pom.xml</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#properties"><span class="toc-text">properties</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81TCP-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">八、TCP 粘包和拆包及解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81TCP-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、TCP 粘包和拆包基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81TCP-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E7%8E%B0%E8%B1%A1%E5%AE%9E%E4%BE%8B"><span class="toc-text">2、TCP 粘包和拆包现象实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MyServerHandler-3"><span class="toc-text">MyServerHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyClientHandler-2"><span class="toc-text">MyClientHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C-2"><span class="toc-text">结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81TCP-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">3、TCP 粘包和拆包解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MessageProtocol"><span class="toc-text">MessageProtocol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyMessageDecoder"><span class="toc-text">MyMessageDecoder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyMessageEncoder"><span class="toc-text">MyMessageEncoder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyServerHandler-4"><span class="toc-text">MyServerHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyClientHandler-3"><span class="toc-text">MyClientHandler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-text">九、Netty 核心源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Netty-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">1、Netty 启动过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Netty-%E6%8E%A5%E5%8F%97%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-text">2、Netty 接受请求过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Pipeline-Handler-HandlerContext-%E5%88%9B%E5%BB%BA"><span class="toc-text">3、Pipeline Handler HandlerContext 创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81ChannelPipeline-%E8%B0%83%E5%BA%A6-handler"><span class="toc-text">4、ChannelPipeline 调度 handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Netty-%E5%BF%83%E8%B7%B3-heartbeat-%E6%9C%8D%E5%8A%A1"><span class="toc-text">5、Netty 心跳(heartbeat)服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Netty-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-EventLoop"><span class="toc-text">6、Netty 核心组件 EventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">示意图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81handler-%E4%B8%AD%E5%8A%A0%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C-Context-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">7、handler 中加入线程池和 Context 中添加线程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E7%94%A8-Netty-%E5%AE%9E%E7%8E%B0-dubbo-RPC"><span class="toc-text">十、用 Netty 实现 dubbo RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81RPC-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、RPC 基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81RPC-%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">2、RPC 调用流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81PRC-%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">3、PRC 调用流程说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%9F%BA%E4%BA%8E-Netty-%E5%AE%9E%E7%8E%B0-dubbo-RPC"><span class="toc-text">4、基于 Netty 实现 dubbo RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E8%AF%B4%E6%98%8E"><span class="toc-text">需求说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E"><span class="toc-text">设计说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HelloService"><span class="toc-text">HelloService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HelloServiceImpl"><span class="toc-text">HelloServiceImpl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerBootstrap"><span class="toc-text">ServerBootstrap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NettyServer-4"><span class="toc-text">NettyServer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NettyServerHandler-4"><span class="toc-text">NettyServerHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NettyClient-4"><span class="toc-text">NettyClient</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NettyClientHandler-4"><span class="toc-text">NettyClientHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ClientBootstrap"><span class="toc-text">ClientBootstrap</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By ITNXD</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">CDN BY <a target="_blank" rel="external nofollow" href="https://www.jsdelivr.com/"><b>jsDelivr</b></a> | HOST BY  <a target="_blank" rel="external nofollow" href="https://vercel.com/"><b>Vercel</b></a> && <a target="_blank" rel="external nofollow" href="https://github.com/"><b>Github</b></a><br><img style="vertical-align:middle" src="https://cdn.jsdelivr.net/gh/lzyblog/image@4b122354dee27f3056fd3a7fc6a43dbf68cebf33/2020/11/16/025e5329f3592dfa03a13c5365323ba1.png" alt=""> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.beian.miit.gov.cn/"><b>晋ICP备19005025号-2</b></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'itnxd-8g1z2i760e99f516',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'itnxd-8g1z2i760e99f516',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'itnxd-8g1z2i760e99f516',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><div class="aplayer no-destroy" data-id="1551071404" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/6dc9e8f9.js","daovoice")
</script><script>var isChatBtn = true
daovoice('init', {
  app_id: '6dc9e8f9',},{
  launcher: { 
     disableLauncherIcon: isChatBtn // 悬浮 ICON 是否显示
  },
});
daovoice('update');

if (isChatBtn) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      daovoice('show')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: true // 悬浮 ICON 是否显示
        },
      });
    }
    function chatBtnShow () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: false // 悬浮 ICON 是否显示
        },
      });
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>