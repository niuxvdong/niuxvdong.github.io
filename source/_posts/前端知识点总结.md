---
title: 前端知识点总结
author: ITNXD
toc: true
abbrlink: 45102
top_img: >-
  https://gitcode.net/qq_43590403/pic/-/raw/master/2021/11/20/59e6bed391110092545ed9ae79229f2f.png
cover: >-
  https://gitcode.net/qq_43590403/pic/-/raw/master/2021/11/20/59e6bed391110092545ed9ae79229f2f.png
categories:
  - 前端知识
tags:
  - es6
  - vue
  - axios
  - webpack
  - babel
  - npm
date: 2021-11-20 17:33:21
updated:
---



# 一、Es6基础入门





> [更加全面的阮一峰Es6教程！](https://es6.ruanyifeng.com/)







## 1、简介



ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。



### ECMAScript 和 JavaScript 的关系

一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？

要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。

因此，**ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现**（另外的 ECMAScript方言还有 Jscript 和ActionScript）



### ES6 与 ECMAScript 2015 的关系



ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？

2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。

ES6 的第一个版本，在 2015 年 6 月发布，正式名称是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1版，因为两者的差异非常小，基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。

因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。





## 2、基础语法



ES标准中不包含 DOM 和 BOM的定义，只涵盖基本数据类型、关键字、语句、运算符、内建对象、内建函数等通用语法。



### let声明变量



```html
<script>
    // 1. 创建代码块，定义变量
    // var 声明的变量没有局部作用域
    // let 声明的变量 有局部作用域
    {
        // var 全局 let 局部
        var a = 1;
        let b = 2;
    }
    console.log(a);
    console.log(b); // Uncaught ReferenceError: b is not defined


    // var 可以声明多次
    // let 只能声明一次
    var m = 1
    var m = 2
    let n = 3
    let n = 4
    console.log(m) // 2
    console.log(n) // Identifier 'n' has already been declared

    // 1、声明之后不允许改变 
    const PI = "3.1415926"
    PI = 3 // TypeError: Assignment to constant variable.
    // 2、一但声明必须初始化，否则会报错
    const MY_AGE // SyntaxError: Missing initializer in const declaration

</script>
```





### const声明常量



```javascript
// 1、声明之后不允许改变 
const PI = "3.1415926"
PI = 3 // TypeError: Assignment to constant variable.
// 2、一但声明必须初始化，否则会报错
const MY_AGE // SyntaxError: Missing initializer in const declaration
```



### 解构赋值



- 解构赋值是对赋值运算符的扩展。
- 他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。
- 在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。



```html
<script>
    //1、数组解构
    // 传统
    let a = 1,
        b = 2,
        c = 3
    console.log(a, b, c)
    // ES6
    let [x, y, z] = [1, 2, 3]
    console.log(x, y, z)

    //2、对象解构
    let user = {
        name: 'Helen',
        age: 18
    }
    // 传统
    let name1 = user.name
    let age1 = user.age
    console.log(name1, age1)
    // ES6
    let {
        name,
        age
    } = user //注意：结构的变量必须是user中的属性
    console.log(name, age)
    
</script>
```



### 模板字符串



模板字符串相当于加强版的字符串，用反引号 **`** ,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。



```html
<script>
    // 1、多行字符串
    let string1 = `Hey,
can you stop angry now?`
    console.log(string1)
    // Hey,
    // can you stop angry now?

    // 2、字符串插入变量和表达式。变量名写在 ${} 中，${} 中可以放入 JavaScript 表达式。
    let name = "Mike"
    let age = 27
    let info = `My Name is ${name},I am ${age+1} years old next year.`
    console.log(info)
    // My Name is Mike,I am 28 years old next year.
    
    // 3、字符串中调用函数
    function f() {
        return "have fun!"
    }
    let string2 = `Game start,${f()}`
    console.log(string2); // Game start,have fun!
</script>
```



### 声明对象简写



```html
<script>
    const age = 12
    const name = "Amy"
    // 传统
    const person1 = {
        age: age,
        name: name
    }
    console.log(person1)
    // ES6
    const person2 = {
        age,
        name
    }
    console.log(person2) //{age: 12, name: "Amy"}
</script>
```



### 定义方法简写



```html
<script>
    // 传统
    const person1 = {
        sayHi: function () {
            console.log("Hi")
        }
    }
    person1.sayHi(); //"Hi"
    // ES6
    const person2 = {
        sayHi() {
            console.log("Hi")
        }
    }
    person2.sayHi() //"Hi"

</script>
```





### 对象拓展运算符



拓展运算符（...）用于取出参数对象所有可遍历属性然后拷贝到当前对象。





```html
<script>
    // 1、拷贝对象
    let person1 = {
        name: "Amy",
        age: 15
    }
    let someone = {
        ...person1
    }
    console.log(someone) //{name: "Amy", age: 15}
    // 2、合并对象
    let age = {
        age: 15
    }
    let name = {
        name: "Amy"
    }
    let person2 = {
        ...age,
        ...name
    }
    console.log(person2) //{age: 15, name: "Amy"}
</script>
```



### 箭头函数


箭头函数提供了一种更加简洁的函数书写方式。基本语法是：参数 => 函数体



```html
<script>
    // 传统
    var f1 = function (a) {
        return a
    }
    console.log(f1(1))
    // ES6
    var f2 = a => a
    console.log(f2(1))
    // 当箭头函数没有参数或者有多个参数，要用 () 括起来。
    // 当箭头函数函数体有多行语句，用 {} 包裹起来，表示代码块，
    // 当只有一行语句，并且需要返回结果时，可以省略 {} , 结果会自动返回。
    var f3 = (a, b) => {
        let result = a + b
        return result
    }
    console.log(f3(6, 2)) // 8
    // 前面代码相当于：
    var f4 = (a, b) => a + b
</script>
```





# 二、Vue基础入门



## 1、简介





Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。

Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。

官方网站：https://cn.vuejs.org





## 2、初始vue



这就是声明式渲染：Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统

这里的核心思想就是没有繁琐的DOM操作，例如jQuery中，我们需要先找到div节点，获取到DOM对象，然后进行一系列的节点操作.



```html
<body>

    <div id="app">
        <!-- {{}} 插值表达式，绑定vue中的data数据 -->
        {{ message }}
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>

    <script>
        // 创建一个vue对象
        new Vue({
            el: '#app', //绑定vue作用的范围
            data: { //定义页面中显示的模型数据
                message: 'Hello Vue!'
            }
        })
    </script>

</body>
```



## 3、vscode创建用户代码片段



在vs code中创建代码片段：

文件 => 首选项 => 用户代码片段 => 新建全局代码片段/或文件夹代码片段：`vue-html.code-snippets`

注意：制作代码片段的时候，字符串中如果包含文件中复制过来的“Tab”键的空格，要换成“空格键”的空格



```
{
	"vue htm": {
		"scope": "html",
		"prefix": "vuehtml",
		"body": [
			"<!DOCTYPE html>",
			"<html lang=\"en\">",
			"",
			"<head>",
			"    <meta charset=\"UTF-8\">",
			"    <meta name=\"viewport\" content=\"width=device-width, initialscale=1.0\">",
			"    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">",
			"    <title>Document</title>",
			"</head>",
			"",
			"<body>",
			"    <div id=\"app\">",
			"",
			"    </div>",
			"    <script src='https://cdn.jsdelivr.net/npm/vue@2'></script>",
			"    <script>",
			"        new Vue({",
			"            el: '#app',",
			"            data: {",
			"                $1",
			"            }",
			"        })",
			"    </script>",
			"</body>",
			"",
			"</html>",
		],
		"description": "my vue template in html"
	}
}
```





## 4、基本语法





### 单向和双向数据绑定



- 你看到的 `v-bind` 特性被称为指令。指令带有前缀 `v-`除了使用插值表达式`{{}}`进行数据渲染，也可以使用 `v-bind`指令，它的简写的形式就是一个冒号`:`
- 双向数据绑定和单向数据绑定：使用 `v-model` 进行双向数据绑定





```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initialscale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- v-bind 
            单向数据绑定
            一般用于标签属性内，获取值
        -->

        <h1 v-bind:title="message">
            {{content}}
        </h1>

        <!-- 简写 -->
        <h2 :title="message">
            {{content}}
        </h2>


        <!-- v-model
            双向数据绑定
         -->
         <input type="text" v-bind:value="searchMap.keyWord">
         <input type="text" v-model="searchMap.keyWord">

         <p>您要查询的是：{{searchMap.keyWord}}</p>

    </div>
    <script src='https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js'></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                content: '我是标题',
                message: '页面加载于 ' + new Date().toLocaleString(),
                searchMap: {
                    keyWord: '世界，你好！'
                }
            }
        })
    </script>
</body>

</html>
```



### 事件



```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initialscale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 
            v-on 指令绑定事件，click指定绑定的事件类型，事件发生时调用vue中methods节点中定义的
         -->
        <button v-on:click="search()">查询</button>
        <!-- 简写 () 也可以不添加 -->
        <button @click="search()">查询1</button>

        <p>您要查询的是：{{searchMap.keyWord}}</p>
        <p><a v-bind:href="result.site" target="_blank">{{result.title}}</a></p>

    </div>
    <script src='https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js'></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                searchMap: {
                    keyWord: '世界'
                },
                //查询结果
                result: {}
            },
            methods: {
                search() {
                    console.log('search...')
                    this.result = {
                        "title": "ITNXD",
                        "site": "https://www.itnxd.cn"
                    }
                },
                f1() {
                    console.log('f1...');
                }
            }
        })
    </script>
</body>

</html>
```





### 修饰符



修饰符 (Modifiers) 是以半角句号（`.`）指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`：即阻止事件原本的默认行为



```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initialscale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 修饰符用于指出一个指令应该以特殊方式绑定。
            这里的 .prevent 修饰符告诉 v-on 指令对于触发的事件调用js的
            event.preventDefault()：
            即阻止表单提交的默认行为 
        -->
        <form action="save" v-on:submit.prevent="onSubmit">
            <label for="username">
                <input type="text" id="username" v-model="user.username">
                <button type="submit">保存</button>
            </label>
        </form>


    </div>
    <script src='https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js'></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                user: {}
            },
            methods: {
                onSubmit() {
                    if (this.user.username) {
                        console.log('提交表单')
                    } else {
                        alert('请输入用户名')
                    }
                }
            }
        })
    </script>
</body>

</html>
```





### 条件渲染



- v-if：条件指令
- v-show：条件指令，初始渲染开销大



**区别：**



- v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
- v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
- 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。
- 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。



```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initialscale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <input type="checkbox" v-model="ok">同意许可协议
        <!-- v:if条件指令：还有v-else、v-else-if 切换开销大 -->
        <h1 v-if="ok">yes</h1>
        <h1 v-else>no</h1>
    </div>
    <script src='https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js'></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                ok: false
            }
        })
    </script>
</body>

</html>
```



### 列表渲染



v-for：列表循环指令



```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initialscale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 1、简单的列表渲染 -->
        <ul>
            <li v-for="n in 10">{{ n }} </li>
        </ul>
        <ul>
            <!-- 如果想获取索引，则使用index关键字，注意，圆括号中的index必须放在后面 -->
            <li v-for="(n, index) in 5">{{ n }} - {{ index }} </li>
        </ul>


        <!-- 2、遍历数据列表 -->
        <table border="1">
            <!-- <tr v-for="item in userList"></tr> -->
            <tr v-for="(item, index) in userList">
                <td>{{index}}</td>
                <td>{{item.id}}</td>
                <td>{{item.username}}</td>
                <td>{{item.age}}</td>
            </tr>
        </table>


    </div>
    <script src='https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js'></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                userList: [{
                        id: 1,
                        username: 'helen',
                        age: 18
                    },
                    {
                        id: 2,
                        username: 'peter',
                        age: 28
                    },
                    {
                        id: 3,
                        username: 'andy',
                        age: 38
                    }
                ]
            }
        })
    </script>
</body>

</html>
```





## 5、组件





- 组件（Component）是 Vue.js 最强大的功能之一。
- 组件可以扩展 HTML 元素，封装可重用的代码。
- 组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树。



### 局部组件



```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initialscale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- 使用组件 -->
        <Navbar></Navbar>
    </div>
    <script src='https://cdn.jsdelivr.net/npm/vue@2'></script>
    <script>
        new Vue({
            el: '#app',
            // 定义局部组件，这里可以定义多个局部组件
            components: {
                //组件的名字
                'Navbar': {
                    //组件的内容
                    template: '<ul><li>首页</li><li>学员管理</li></ul>'
                }
            }
        })
    </script>
</body>

</html>
```



### 全局组件

**Navbar.js**

```javascript
// 定义全局组件
Vue.component('Navbar', {
    template: '<ul><li>首页</li><li>学员管理</li><li>讲师管理</li></ul>'
})
```



**script标签引入**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initialscale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <Navbar></Navbar>
    </div>
    <script src='https://cdn.jsdelivr.net/npm/vue@2'></script>
    <script src="components/Navbar.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                
            },
            created() { // 页面渲染之前执行
                debugger // 表示断点
                console.log('created...')
            },
            mounted() { // 页面渲染之后执行
                debugger
                console.log('mounted...');
            },

        })
    </script>
</body>

</html>
```



## 6、路由



- Vue.js 路由允许我们通过不同的 URL 访问不同的内容。
- 通过 Vue.js 可以实现多视图的单页Web应用（single page web application，SPA）。
- Vue.js 路由需要载入 vue-router 库



```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initialscale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <h1>Hello App!</h1>
        <p>
            <!-- 使用 router-link 组件来导航. -->
            <!-- 通过传入 `to` 属性指定链接. -->
            <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->
            <router-link to="/">首页</router-link>
            <router-link to="/student">会员管理</router-link>
            <router-link to="/teacher">讲师管理</router-link>
        </p>
        <!-- 路由出口 -->
        <!-- 路由匹配到的组件将渲染在这里 -->
        <router-view></router-view>
    </div>
    <script src='https://cdn.jsdelivr.net/npm/vue@2.6.14'></script>
    <script src='https://cdn.jsdelivr.net/npm/vue-router@3.5.3'></script>
    <script>
        // 1. 定义（路由）组件。
        // 可以从其他文件 import 进来
        const Welcome = {
            template: '<div>欢迎</div>'
        }
        const Student = {
            template: '<div>student list</div>'
        }
        const Teacher = {
            template: '<div>teacher list</div>'
        }
        // 2. 定义路由
        // 每个路由应该映射一个组件。
        const routes = [{
                path: '/',
                redirect: '/welcome'
            }, //设置默认指向的路径
            {
                path: '/welcome',
                component: Welcome
            },
            {
                path: '/student',
                component: Student
            },
            {
                path: '/teacher',
                component: Teacher
            }
        ]
        // 3. 创建 router 实例，然后传 `routes` 配置
        const router = new VueRouter({
            routes // （缩写）相当于 routes: routes
        })
        // 4. 创建和挂载根实例。
        // 从而让整个应用都有路由功能
        const app = new Vue({
            el: '#app',
            router
        })
        // 现在，应用已经启动了！
    </script>
</body>

</html>
```













# 三、axios基础入门





## 1、简介



axios是独立于vue的一个项目，基于promise用于浏览器和node.js的http客户端

- 在浏览器中可以帮助我们完成 ajax请求的发送
- 在node.js中可以向远程接口发送请求





## 2、使用





**模拟数据：data.json**



```json
{
    "success": true,
    "code": 20000,
    "message": "成功",
    "data": {
        "items": [
            {"name": "lucy", "age": 20},
            {"name": "marry", "age": 30},
            {"name": "tom", "age": 22},
            {"name": "jack", "age": 25}
        ]
    }
}
```



**测试**



```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initialscale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <!-- userList 遍历显示 -->
        <div v-for="user in userList">
            {{user.name}} -- {{user.age}}
        </div>
    </div>

    <script src='https://cdn.jsdelivr.net/npm/vue@2'></script>
    <script src='https://cdn.jsdelivr.net/npm/axios@0.24.0'></script>

    <script>
        new Vue({
            el: '#app',
            data: { // 定义变量和初始值
                // 定义变量 空数组
                userList: []
            },
            created() { // 页面渲染之前执行 调方法

                this.getUserList();
            },
            methods: { // 编写具体方法

                getUserList() {
                    // 使用axios发送ajax请求(get请求)
                    axios.get('data.json')
                        .then((response) => { // 请求成功执行then方法
                            //console.log(response);
                            // 赋值给数据
                            this.userList = response.data.data.items;
                            console.log(this.userList);
                        })
                        .catch((error) => { // 发送异常捕获方法
                            console.log(error);
                        });

                }
            }
        })
    </script>
</body>

</html>
```











# 四、NodeJs基础入门



## 1、简介



**什么是Node.js**

简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。



**Node.js有什么用**

如果你是一个前端程序员，你不懂得像PHP、Python或Ruby等动态编程语言，然后你想创建自己的服务，那么Node.js是一个非常好的选择。Node.js 是运行在服务端的 JavaScript，如果你熟悉Javascript，那么你将会很容易的学会Node.js。当然，如果你是后端程序员，想部署一些高性能的服务，那么学习Node.js也是一个非常好的选择。



**浏览器的内核包括两部分核心：**

- DOM渲染引擎；
- js解析器（js引擎）
- js运行在浏览器中的内核中的js引擎内部
- Node.js是脱离浏览器环境运行的JavaScript程序，基于V8 引擎（Chrome 的 JavaScript的引擎）



## 2、使用



node + js文件运行！





## 3、服务器端应用开发



node + server.js 运行!



```javascript
const http = require('http');
http.createServer(function (request, response) {
    // 发送 HTTP 头部
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, { 'Content-Type': 'text/plain' });
    // 发送响应数据 "Hello World"
    response.end('Hello Server');
}).listen(8888);
// 终端打印如下信息
console.log('Server running at http://127.0.0.1:8888/');
```









# 五、Npm基础入门





## 1、什么是NPM



NPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，相当于前端的Maven 。



**NPM工具的安装位置**

我们通过npm 可以很方便地下载js库，管理前端工程。Node.js默认安装的npm包和工具的位置：Node.js目录\node_modules在这个目录下你可以看见 npm目录，npm本身就是被NPM包管理器管理的一个工具，说明Node.js已经集成了npm工具



```shell
#在命令提示符输入 npm -v 可查看当前npm版本
npm -v
```



## 2、使用npm管理项目



### 项目初始化

```shell
#建立一个空文件夹，在命令提示符进入该文件夹 执行命令初始化
npm init
#按照提示输入相关信息，如果是用默认值则直接回车即可。
#name: 项目名称
#version: 项目版本号
#description: 项目描述
#keywords: {Array}关键词，便于用户搜索到我们的项目
#最后会生成package.json文件，这个是包的配置文件，相当于maven的pom.xml
#我们之后也可以根据需要进行修改。
#如果想直接生成 package.json 文件，那么可以使用命令
npm init -y
```



**package.json文件**



```json
{
  "name": "npm",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "jquery": "^3.6.0"
  }
}
```









### 修改npm镜像



NPM官方的管理的包都是从 http://npmjs.com下载的，但是这个网站在国内速度很慢。这里推荐使用淘宝 NPM 镜像 http://npm.taobao.org/ ，淘宝 NPM 镜像是一个完整 npmjs.com 镜像，同步频率目前为 10分钟一次，以保证尽量与官方服务同步。



```shell
#经过下面的配置，以后所有的 npm install 都会经过淘宝的镜像地址下载
npm config set registry https://registry.npm.taobao.org
#查看npm配置信息
npm config list
```



### npm install命令



```shell
#使用 npm install 安装依赖包的最新版，
#模块安装的位置：项目目录\node_modules
#安装会自动在项目目录下添加 package-lock.json文件，这个文件帮助锁定安装包的版本
#同时package.json 文件中，依赖包会被添加到dependencies节点下，类似maven中的<dependencies>
npm install jquery
#npm管理的项目在备份和传输的时候一般不携带node_modules文件夹
npm install #根据package.json中的配置下载依赖，初始化项目
#如果安装时想指定特定的版本
npm install jquery@2.1.x
#devDependencies节点：开发时的依赖包，项目打包到生产环境的时候不包含的依赖
#使用 -D参数将依赖添加到devDependencies节点
npm install --save-dev eslint
#或
npm install -D eslint
#全局安装
#Node.js全局安装的npm包和工具的位置：用户目录\AppData\Roaming\npm\node_modules
#一些命令行工具常使用全局安装的方式
npm install -g webpack
```



### 其他命令



```shell
#更新包（更新到最新版本）
npm update 包名
#全局更新
npm update -g 包名
#卸载包
npm uninstall 包名
#全局卸载
npm uninstall -g 包名
```





# 六、Babel基础入门





## 1、简介



Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行执行。这意味着，你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持。



## 2、安装



安装命令行转码工具

Babel提供babel-cli工具，用于命令行转码。它的安装命令如下：



```shell
npm install --global babel-cli
#查看是否安装成功
babel --version
```



## 3、Babel的使用



**初始化项目**

```shell
# 初始化项目
npm init -y
```



**创建js文件**

```javascript
// 转码前 
// 定义数据
let input = [1, 2, 3]
// 将数组的每个元素 +1
input = input.map(item => item + 1)
console.log(input)

// 命令：babel .\es6\01.js -o .\dist\01.js
// 文件夹写法：babel es6 -d dist
```



**配置.babelrc**



Babel的配置文件是.babelrc，存放在项目的根目录下，该文件用来设置转码规则和插件，基本格式如下。

presets字段设定转码规则，将es2015规则加入 `.babelrc`：



```json
{
    "presets": [
        "es2015"
    ],
    "plugins": []
}
```



**安装转码器**



```shell
# 在项目中安装
npm install --save-dev babel-preset-es2015
```



**转码**



````shell
# 转码结果写入一个文件
mkdir dist1
# --out-file 或 -o 参数指定输出文件
babel src/example.js --out-file dist1/compiled.js
# 或者
babel src/example.js -o dist1/compiled.js
# 整个目录转码
mkdir dist2
# --out-dir 或 -d 参数指定输出目录
babel src --out-dir dist2
# 或者
babel src -d dist2
````



**最终转码结果：**



```javascript
"use strict";

// 转码前
// 定义数据
var input = [1, 2, 3];
// 将数组的每个元素 +1
input = input.map(function (item) {
  return item + 1;
});
console.log(input);
```



# 七、模块化开发







## 1、什么是模块化开发



**传统非模块化开发有如下的缺点：**

- 命名冲突
- 文件依赖

**模块化规范：**

- CommonJS模块化规范
- ES6模块化规范



## 2、CommonJS模块规范





每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。



**CommonJS使用 exports 和require 来导出、导入模块。**



**定义内容，导出为模块**



```javascript
// 定义成员：
const sum = function (a, b) {
    return parseInt(a) + parseInt(b)
}
const subtract = function (a, b) {
    return parseInt(a) - parseInt(b)
}
const multiply = function (a, b) {
    return parseInt(a) * parseInt(b)
}
const divide = function (a, b) {
    return parseInt(a) / parseInt(b)
}

// 导出成员：
/* module.exports = {
    sum: sum,
    subtract: subtract,
    multiply: multiply,
    divide: divide
} */

//简写
module.exports = {
    sum,
    subtract,
    multiply,
    divide
}
```



**导入模块**



```javascript
//引入模块，注意：当前路径必须写 ./
const m = require('./01.js')
console.log(m)
const result1 = m.sum(1, 2)
const result2 = m.subtract(1, 2)
console.log(result1, result2)
```



## 3、ES6模块化规范



**ES6使用 export 和 import 来导出、导入模块**





### 写法一



**定义内容，导出模块**



```javascript
export function getList() {
    console.log('获取数据列表')
}

export function save() {
    console.log('保存数据')
}
```



**导入模块使用**

```javascript
//只取需要的方法即可，多个方法用逗号分隔
import { getList, save } from "./03.js"
getList()
save()

// babel .\module_es6 -d .\module_es6_1\
```



**注意：**这时的程序无法运行的，因为ES6的模块化无法在Node.js中执行，需要用Babel编辑成ES5后再执行。





### 写法二（常用）



**定义内容，导出模块**



```javascript
export default {
    getList() {
        console.log('获取数据列表2')
    },
    save() {
        console.log('保存数据2')
    }
}
```



**导入模块使用**

```javascript
//只取需要的方法即可，多个方法用逗号分隔
import user from "./03.js"
user.getList()
user.save()

// babel .\module_es61 -d .\module_es61_1
```



**注意：**这时的程序无法运行的，因为ES6的模块化无法在Node.js中执行，需要用Babel编辑成ES5后再执行。





# 八、WebPack基础入门





## 1、什么是Webpack



Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。

Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。





## 2、Webpack安装



```shell
# 全局安装
npm install -g webpack webpack-cli
# 安装后查看版本号
webpack -v
```





## 3、初始化项目



```shell
# 初始化项目
npm init -y

# src下创建common.js

exports.info = function (str) {
 document.write(str);
}

# src下创建utils.js

exports.add = function (a, b) {
 return a + b;
}

# src下创建main.js

const common = require('./common');
const utils = require('./utils');
common.info('Hello world!' + utils.add(100, 200));
```



## 4、JS打包





webpack目录下创建配置文件`webpack.config.js`

以下配置的意思是：读取当前项目目录下src文件夹中的main.js（**入口文件**）内容，分析资源依赖，把相

关的js文件打包，打包后的文件放入当前目录的dist文件夹下，打包后的js文件名为`bundle.js`



```javascript
const path = require("path"); //Node.js内置模块
module.exports = {
    entry: './src/main.js', //配置入口文件
    output: {
        path: path.resolve(__dirname, './dist'), //输出路径，__dirname：当前文件所在路径
        filename: 'bundle.js' //输出文件
    }
}

// webpack --mode=development 不是一行 webpack --mode=production 一行
```



**命令行执行编译命令**

```shell
webpack #有黄色警告
webpack --mode=development #没有警告
# 执行后查看bundle.js 里面包含了上面两个js文件的内容并惊醒了代码压缩
```



**也可以配置项目的npm运行命令，修改package.json文件**



```javascript
"scripts": {
    //...,
    "dev": "webpack --mode=development"
}
```



**运行npm命令执行打包**



```shell
npm run dev
```



**webpack目录下创建index.html引入bundle.js使用**

```html
<body>
 <script src="dist/bundle.js"></script>
</body>
```



## 5、CSS打包



**安装style-loader和 css-loader**



- Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。
- Loader 可以理解为是模块和资源的转换器。
- 首先我们需要安装相关Loader插件，css-loader 是将 css 装载到 javascript；style-loader 是让 javascript认识css



```shell
npm install --save-dev style-loader css-loader
```



**修改webpack.config.js**

```javascript
const path = require("path"); //Node.js内置模块
module.exports = {
    entry: './src/main.js', //配置入口文件
    output: {
        path: path.resolve(__dirname, './dist'), //输出路径，__dirname：当前文件所在路径
        filename: 'bundle.js' //输出文件
    },
    // 打包css额外加入的配置
    module: {
        rules: [
            {
                test: /\.css$/, //打包规则应用到以css结尾的文件上
                use: ['style-loader', 'css-loader']
            }
        ]
    }
}

// webpack --mode=development 不是一行 webpack --mode=production 一行
```





**在src文件夹创建style.css**



```css
body{
    background:pink;
}
```





**修改main.js**

```javascript
require('./style.css');
```



**重新编译**

```shell
webpack #有黄色警告
webpack --mode=development #没有警告
#执行后查看bundle.js 里面包含了上面两个js文件的内容并惊醒了代码压缩
```



重新测试！





