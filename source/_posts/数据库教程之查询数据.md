---
title: 数据库教程之查询数据
author: Mr.Niu
toc: true
abbrlink: 16928
top_img: 'https://img.niuxvdong.top/thumb-1920-552086.jpg'
cover: 'https://img.niuxvdong.top/thumb-1920-552086.jpg'
categories:
  - 数据库
tags:
  - SELECT
  - 查询
date: 2020-06-02 17:37:39
updated:
---



# 首先来首歌曲来放松一下吧！

{% meting "1371353582" "netease" "song" "theme:#FF4081" "mode:circulation" "mutex:true" "listmaxheight:340px" "preload:auto"  %}



# 一、准备数据

> [廖雪峰SQL教程例子：例子代码点击这里！](https://github.com/michaelliao/learn-sql/blob/master/mysql/init-test-data.sql)
>
> 将上方链接或者下方代码保存到文本文件，改名为`init-test-data.sql`。然后再本地cmd运行`$ mysql -u root -p < init-test-data.sql`即可创建一个名为`test`的数据库，有两张表`classes`和`students`!
>
> 注意要在`cmd`，不要使用`powershell`，`powershell`无法识别命令行`<`这个符号！



```sql
-- 如果test数据库不存在，就创建test数据库：
CREATE DATABASE IF NOT EXISTS test;

-- 切换到test数据库
USE test;

-- 删除classes表和students表（如果存在）：
DROP TABLE IF EXISTS classes;
DROP TABLE IF EXISTS students;

-- 创建classes表：
CREATE TABLE classes (
    id BIGINT NOT NULL AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 创建students表：
CREATE TABLE students (
    id BIGINT NOT NULL AUTO_INCREMENT,
    class_id BIGINT NOT NULL,
    name VARCHAR(100) NOT NULL,
    gender VARCHAR(1) NOT NULL,
    score INT NOT NULL,
    PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 插入classes记录：
INSERT INTO classes(id, name) VALUES (1, '一班');
INSERT INTO classes(id, name) VALUES (2, '二班');
INSERT INTO classes(id, name) VALUES (3, '三班');
INSERT INTO classes(id, name) VALUES (4, '四班');

-- 插入students记录：
INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'M', 90);
INSERT INTO students (id, class_id, name, gender, score) VALUES (2, 1, '小红', 'F', 95);
INSERT INTO students (id, class_id, name, gender, score) VALUES (3, 1, '小军', 'M', 88);
INSERT INTO students (id, class_id, name, gender, score) VALUES (4, 1, '小米', 'F', 73);
INSERT INTO students (id, class_id, name, gender, score) VALUES (5, 2, '小白', 'F', 81);
INSERT INTO students (id, class_id, name, gender, score) VALUES (6, 2, '小兵', 'M', 55);
INSERT INTO students (id, class_id, name, gender, score) VALUES (7, 2, '小林', 'M', 85);
INSERT INTO students (id, class_id, name, gender, score) VALUES (8, 3, '小新', 'F', 91);
INSERT INTO students (id, class_id, name, gender, score) VALUES (9, 3, '小王', 'M', 89);
INSERT INTO students (id, class_id, name, gender, score) VALUES (10, 3, '小丽', 'F', 85);

-- OK:
SELECT 'ok' as 'result:';
```



# 二、基本查询



## 1、SELECT语句

> 使用`SELECT * FROM students`时，`SELECT`是关键字，表示将要执行一个查询，`*`表示“所有列”，`FROM`表示将要从哪个表查询，本例中是`students`表。
>
> 该SQL将查询出`students`表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。

```sql
$ USE test;
$ SELECT * FROM <表名>;
```



![](https://i.loli.net/2020/06/02/Fv2oYPO9Vj5iTAI.png)



## 2、用于计算的SELECT

> 上述查询会直接计算出表达式的结果。虽然`SELECT`可以用作计算，但它并不是SQL的强项。但是，不带`FROM`子句的`SELECT`语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条`SELECT 1;`来测试数据库连接。

```sql
$ mysql> SELECT 200 * 3000000000;
+------------------+
| 200 * 3000000000 |
+------------------+
|     600000000000 |
+------------------+
1 row in set (0.00 sec)
```



# 三、条件查询



## 1、WHERE 条件



> 使用`SELECT * FROM <表名>`可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。
>
> 格式如下：

```sql
$ SELECT * FROM <表名> WHERE <条件表达式>
```

效果如下：

![](https://i.loli.net/2020/06/02/A5L3UGt2wQeR1OK.png)



## 2、逻辑运算

> 与其他语言不同：等于号不是`==`而是`=`！		

### 2.1 AND

> 就是与`与`元算符！

```sql
$ mysql> SELECT * FROM students WHERE score >= 80 AND gender = 'M';
+----+----------+--------+--------+-------+
| id | class_id | name   | gender | score |
+----+----------+--------+--------+-------+
|  1 |        1 | 小明   | M      |    90 |
|  3 |        1 | 小军   | M      |    88 |
|  7 |        2 | 小林   | M      |    85 |
|  9 |        3 | 小王   | M      |    89 |
+----+----------+--------+--------+-------+
4 rows in set (0.00 sec)
```



### 2.2 OR

>就是与`或`元算符！

```sql
$ mysql> SELECT * FROM students WHERE score >= 80 OR gender = 'M';
+----+----------+--------+--------+-------+
| id | class_id | name   | gender | score |
+----+----------+--------+--------+-------+
|  1 |        1 | 小明   | M      |    90 |
|  2 |        1 | 小红   | F      |    95 |
|  3 |        1 | 小军   | M      |    88 |
|  5 |        2 | 小白   | F      |    81 |
|  6 |        2 | 小兵   | M      |    55 |
|  7 |        2 | 小林   | M      |    85 |
|  8 |        3 | 小新   | F      |    91 |
|  9 |        3 | 小王   | M      |    89 |
| 10 |        3 | 小丽   | F      |    85 |
+----+----------+--------+--------+-------+
9 rows in set (0.00 sec)
```



### 2.3 NOT

> 就是与`非`元算符！



```sql
$ mysql> SELECT * FROM students WHERE NOT class_id = 2;
+----+----------+--------+--------+-------+
| id | class_id | name   | gender | score |
+----+----------+--------+--------+-------+
|  1 |        1 | 小明   | M      |    90 |
|  2 |        1 | 小红   | F      |    95 |
|  3 |        1 | 小军   | M      |    88 |
|  4 |        1 | 小米   | F      |    73 |
|  8 |        3 | 小新   | F      |    91 |
|  9 |        3 | 小王   | M      |    89 |
| 10 |        3 | 小丽   | F      |    85 |
+----+----------+--------+--------+-------+
7 rows in set (0.00 sec)
```





### 2.4 多条件使用括号

> 同样：加括号改变了优先级！

```sql
$ mysql> SELECT * FROM students WHERE (score < 80 OR score > 90) AND gender = 'M';

+----+----------+--------+--------+-------+
| id | class_id | name   | gender | score |
+----+----------+--------+--------+-------+
|  6 |        2 | 小兵   | M      |    55 |
+----+----------+--------+--------+-------+
1 row in set (0.00 sec)
```



## 3、条件表达式符号



> 注意：不等于不是`!=`而是`<>`！
>
> 字符串要用引号引起来！
>
> `%`可以匹配任意字符，包括空字符且不一定是一个字符！



|         条件         |   表达式举例1   |   表达式举例2    |                       说明                        |
| :------------------: | :-------------: | :--------------: | :-----------------------------------------------: |
|    使用=判断相等     |   score = 80    |   name = 'abc'   |           字符串需要用**单引号**括起来            |
|    使用>判断大于     |   score > 80    |   name > 'abc'   | 字符串比较根据ASCII码，中文字符比较根据数据库设置 |
| 使用>=判断大于或相等 |   score >= 80   |  name >= 'abc'   |                                                   |
|    使用<判断小于     |   score < 80    |  name <= 'abc'   |                                                   |
| 使用<=判断小于或相等 |   score <= 80   |  name <= 'abc'   |                                                   |
|   使用<>判断不相等   |   score <> 80   |  name <> 'abc'   |                                                   |
|   使用LIKE判断相似   | name LIKE 'ab%' | name LIKE '%bc%' | %表示任意字符，例如'ab%'将匹配'ab'，'abc'，'abcd' |





# 四、投影查询

> 使用`SELECT * FROM <表名> WHERE <条件>`可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。
>
> 如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用`SELECT 列1, 列2, 列3 FROM ...`，让结果集仅包含指定列。这种操作称为投影查询。



投影查询：仅返回指定列！





## 1、普通投影

```sql
$ SELECT 列1, 列2, 列3 FROM ...，;
```

例子如下：

```sql
$ mysql> SELECT id, score, name FROM students;
+----+-------+--------+
| id | score | name   |
+----+-------+--------+
|  1 |    90 | 小明   |
|  2 |    95 | 小红   |
|  3 |    88 | 小军   |
|  4 |    73 | 小米   |
|  5 |    81 | 小白   |
|  6 |    55 | 小兵   |
|  7 |    85 | 小林   |
|  8 |    91 | 小新   |
|  9 |    89 | 小王   |
| 10 |    85 | 小丽   |
+----+-------+--------+
10 rows in set (0.01 sec)
```



## 2、别名投影



```sql
$ SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...;
```

例子如下：score 一列改别名为 points ！



```sql
$ mysql> SELECT id, score points, name FROM students;
+----+--------+--------+
| id | points | name   |
+----+--------+--------+
|  1 |     90 | 小明   |
|  2 |     95 | 小红   |
|  3 |     88 | 小军   |
|  4 |     73 | 小米   |
|  5 |     81 | 小白   |
|  6 |     55 | 小兵   |
|  7 |     85 | 小林   |
|  8 |     91 | 小新   |
|  9 |     89 | 小王   |
| 10 |     85 | 小丽   |
+----+--------+--------+
10 rows in set (0.00 sec)
```





## 3、复杂投影



> 将投影与别名与WHERE条件查询结合！

```sql
mysql> SELECT id, score points, name FROM students WHERE gender = 'M';
+----+--------+--------+
| id | points | name   |
+----+--------+--------+
|  1 |     90 | 小明   |
|  3 |     88 | 小军   |
|  6 |     55 | 小兵   |
|  7 |     85 | 小林   |
|  9 |     89 | 小王   |
+----+--------+--------+
5 rows in set (0.00 sec)
```







# 五、排序



> 我们使用SELECT查询时，细心的读者可能注意到，查询结果集通常是按照`id`排序的，也就是根据主键排序。这也是大部分数据库的做法。



## 1、升序



> 使用 `ORDER BY ***`语句；`ASC`：升序，可省略！

```sql
$ mysql> SELECT id, name, gender, score FROM students ORDER BY score;
+----+--------+--------+-------+
| id | name   | gender | score |
+----+--------+--------+-------+
|  6 | 小兵   | M      |    55 |
|  4 | 小米   | F      |    73 |
|  5 | 小白   | F      |    81 |
|  7 | 小林   | M      |    85 |
| 10 | 小丽   | F      |    85 |
|  3 | 小军   | M      |    88 |
|  9 | 小王   | M      |    89 |
|  1 | 小明   | M      |    90 |
|  8 | 小新   | F      |    91 |
|  2 | 小红   | F      |    95 |
+----+--------+--------+-------+
10 rows in set (0.00 sec)
```



## 2、降序

> 使用 `ORDER BY *** DESC`，`DESC`表示“倒序”，不可省略！

```sql
$ mysql> SELECT id, name, gender, score FROM students ORDER BY score DESC;
+----+--------+--------+-------+
| id | name   | gender | score |
+----+--------+--------+-------+
|  2 | 小红   | F      |    95 |
|  8 | 小新   | F      |    91 |
|  1 | 小明   | M      |    90 |
|  9 | 小王   | M      |    89 |
|  3 | 小军   | M      |    88 |
|  7 | 小林   | M      |    85 |
| 10 | 小丽   | F      |    85 |
|  5 | 小白   | F      |    81 |
|  4 | 小米   | F      |    73 |
|  6 | 小兵   | M      |    55 |
+----+--------+--------+-------+
10 rows in set (0.00 sec)
```





## 3、复杂排序



### 3.1 多列排序



> 若`score`列有相同的数据，要进一步排序，可以继续添加列名。
>
> 即先按`score`降序，再按`gender`升序（默认为ASC升序）。



```sql
$ mysql> SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;

+----+--------+--------+-------+
| id | name   | gender | score |
+----+--------+--------+-------+
|  2 | 小红   | F      |    95 |
|  8 | 小新   | F      |    91 |
|  1 | 小明   | M      |    90 |
|  9 | 小王   | M      |    89 |
|  3 | 小军   | M      |    88 |
| 10 | 小丽   | F      |    85 |
|  7 | 小林   | M      |    85 |
|  5 | 小白   | F      |    81 |
|  4 | 小米   | F      |    73 |
|  6 | 小兵   | M      |    55 |
+----+--------+--------+-------+
10 rows in set (0.00 sec)
```





### 3.2 条件排序



> 如果有`WHERE`子句，那么`ORDER BY`子句要放到`WHERE`子句后面！



```sql
$ mysql> SELECT id, name, gender, score
    -> FROM students
    -> WHERE class_id = 1
    -> ORDER BY score DESC;
+----+--------+--------+-------+
| id | name   | gender | score |
+----+--------+--------+-------+
|  2 | 小红   | F      |    95 |
|  1 | 小明   | M      |    90 |
|  3 | 小军   | M      |    88 |
|  4 | 小米   | F      |    73 |
+----+--------+--------+-------+
4 rows in set (0.00 sec)
```



# 六、分页查询



> 使用`SELECT`查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。
>
> 要实现分页功能，实际上就是从结果集中显示第1 ~ 100条记录作为第1页，显示第101 ~ 200条记录作为第2页，以此类推。
>
> 因此，分页实际上就是从结果集中“截取”出第M ~ N条记录。
>
> 通过`LIMIT <M> OFFSET <N>`子句实现：`LIMIT`表示每页最多三条信息，`OFFSET`表示从第几条开始。（SQL索引从0开始）



## 注意：

- `OFFSET`是可选的，如果只写`LIMIT 15`，那么相当于`LIMIT 15 OFFSET 0`。

- 在MySQL中，`LIMIT 15 OFFSET 30`还可以简写成`LIMIT 30, 15`。

- 使用`LIMIT <M> OFFSET <N>`分页时，随着`N`越来越大，查询效率也会越来越低。



## **规则**：

分页查询的关键在于，首先要确定每页需要显示的结果数量`pageSize`（这里是3），然后根据当前页的索引`pageIndex`（从1开始），确定`LIMIT`和`OFFSET`应该设定的值：



- `LIMIT`总是设定为`pageSize`；
- `OFFSET`计算公式为`pageSize * (pageIndex - 1)`。



## **如下**：



```sql
$ mysql> SELECT id, name, gender, score
    -> FROM students
    -> ORDER BY score DESC
    -> LIMIT 3 OFFSET 0;
+----+--------+--------+-------+
| id | name   | gender | score |
+----+--------+--------+-------+
|  2 | 小红   | F      |    95 |
|  8 | 小新   | F      |    91 |
|  1 | 小明   | M      |    90 |
+----+--------+--------+-------+
3 rows in set (0.00 sec)

$ mysql> SELECT id, name, gender, score
    -> FROM students
    -> ORDER BY score DESC
    -> LIMIT 3 OFFSET 3;
+----+--------+--------+-------+
| id | name   | gender | score |
+----+--------+--------+-------+
|  9 | 小王   | M      |    89 |
|  3 | 小军   | M      |    88 |
| 10 | 小丽   | F      |    85 |
+----+--------+--------+-------+
3 rows in set (0.00 sec)

...

$ mysql> SELECT id, name, gender, score
    -> FROM students
    -> ORDER BY score DESC
    -> LIMIT 3 OFFSET 9;
+----+--------+--------+-------+
| id | name   | gender | score |
+----+--------+--------+-------+
|  6 | 小兵   | M      |    55 |
+----+--------+--------+-------+
1 row in set (0.00 sec)
```





**若OFFSET设置的越界了，并不会报错，会返回一个空集合！**



```sql
$ mysql> SELECT id, name, gender, score
    -> FROM students
    -> ORDER BY score DESC
    -> LIMIT 3 OFFSET 20;
Empty set (0.00 sec)
```



# 七、聚合查询

> 对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。



## 1、COUNT()函数



>  `COUNT(*)`表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是`COUNT(*)`。
>
> 可以设置一个别名，便于处理结果：
>
> `COUNT(*)`和`COUNT(id)`实际上是一样的效果。



```sql
$ mysql> SELECT COUNT(*) FROM students;
+----------+
| COUNT(*) |
+----------+
|       10 |
+----------+
1 row in set (0.00 sec)

-- 取一个别名 num
mysql> SELECT COUNT(*) num FROM students;
+-----+
| num |
+-----+
|  10 |
+-----+
1 row in set (0.00 sec)
```



- 同样可以使用WHERE条件



```sql
mysql> SELECT COUNT(*) boys FROM students WHERE gender = 'M';
+------+
| boys |
+------+
|    5 |
+------+
1 row in set (0.00 sec)
```



## 2、其他函数

> 注意，`MAX()`和`MIN()`函数并不限于数值类型。如果是字符类型，`MAX()`和`MIN()`会返回排序最后和排序最前的字符。
>
> 注意：如果聚合查询的`WHERE`条件没有匹配到任何行，`COUNT()`会返回0，而`SUM()`、`AVG()`、`MAX()`和`MIN()`会返回`NULL`：



|  函数   |                  说明                  |
| :-----: | :------------------------------------: |
|   SUM   | 计算某一列的合计值，该列必须为数值类型 |
|   AVG   | 计算某一列的平均值，该列必须为数值类型 |
|   MAX   |           计算某一列的最大值           |
|   MIN   |           计算某一列的最小值           |
| CEILING |                 上取整                 |
|  FLOOR  |                 下取整                 |





```sql
$ mysql> SELECT AVG(score) average FROM students WHERE gender = 'M';
+---------+
| average |
+---------+
| 81.4000 |
+---------+
1 row in set (0.01 sec)

-- WHERE找不到返回NULL

$ mysql> SELECT AVG(score) average FROM students WHERE gender = 'X';
+---------+
| average |
+---------+
|    NULL |
+---------+
1 row in set (0.00 sec)

-- 计算页数

$ SELECT CEILING(COUNT(*) / 3)  pageSize FROM students;
mysql> SELECT CEILING(COUNT(*) / 3)  pageSize FROM students;
+----------+
| pageSize |
+----------+
|        4 |
+----------+
1 row in set (0.00 sec)
```



## 3、分组（GROUP）



> 用于统计一类数据的方法：`GROUP BY 某一列`

### 3.1 单列分组

```sql
$ mysql> SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;
+----------+-----+
| class_id | num |
+----------+-----+
|        1 |   4 |
|        2 |   3 |
|        3 |   3 |
+----------+-----+
3 rows in set (0.00 sec)
```



### 3.2 多列分组



```sql
$ mysql> SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;
+----------+--------+-----+
| class_id | gender | num |
+----------+--------+-----+
|        1 | M      |   2 |
|        1 | F      |   2 |
|        2 | F      |   1 |
|        2 | M      |   2 |
|        3 | F      |   2 |
|        3 | M      |   1 |
+----------+--------+-----+
6 rows in set (0.00 sec)
```



- **注意**：SQL引擎不能把多个`name`的值放入一行记录中。因此，聚合查询的列中，只能放入分组的列。



> 原因：class_id = 1 有 4 个人，他们班级名相同，但name不同，如果有了name列，应该显示几个名字呢？？？
>
> 所以干脆直接报错！ 



```sql
$ mysql> SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;
ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.students.name' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
```







# 八、多表查询

> 由于多表查询的笛卡尔乘积问题，会导致每行两表的数据并没有逻辑对应关系。。。
>
> 即直接查出来的数据对应不一定正确，需要进行条件限定，如students表的class_id 与 classes表的id相同才能唯一确定一个对应关系。
>
> 一般使用主键或外键进行多表关联查询，笛卡尔乘积没太多意义，而且很容易查询量爆炸，`不建议使用！`



## 1、语法：



- `SELECT * FROM <表1> <表2>`。



> 这种一次查询两个表的数据，查询的结果也是一个二维表，它是`students`表和`classes`表的“乘积”，即`students`表的每一行与`classes`表的每一行都两两拼在一起返回。结果集的列数是`students`表和`classes`表的列数之和，行数是`students`表和`classes`表的行数之积。
>
> 这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。
>
> 给表起别名，再给相同列起别名有助于查看！

```sql
$ mysql> SELECT
    ->     s.id sid,
    ->     s.name,
    ->     s.gender,
    ->     s.score,
    ->     c.id cid,
    ->     c.name cname
    -> FROM students s, classes c;
+-----+--------+--------+-------+-----+--------+
| sid | name   | gender | score | cid | cname  |
+-----+--------+--------+-------+-----+--------+
|   1 | 小明   | M      |    90 |   1 | 一班   |
|   1 | 小明   | M      |    90 |   2 | 二班   |
|   1 | 小明   | M      |    90 |   3 | 三班   |
|   1 | 小明   | M      |    90 |   4 | 四班   |
|   2 | 小红   | F      |    95 |   1 | 一班   |
|   2 | 小红   | F      |    95 |   2 | 二班   |
|   2 | 小红   | F      |    95 |   3 | 三班   |
|   2 | 小红   | F      |    95 |   4 | 四班   |
|   3 | 小军   | M      |    88 |   1 | 一班   |
|   3 | 小军   | M      |    88 |   2 | 二班   |
|   3 | 小军   | M      |    88 |   3 | 三班   |
|   3 | 小军   | M      |    88 |   4 | 四班   |
|   4 | 小米   | F      |    73 |   1 | 一班   |
|   4 | 小米   | F      |    73 |   2 | 二班   |
|   4 | 小米   | F      |    73 |   3 | 三班   |
|   4 | 小米   | F      |    73 |   4 | 四班   |
|   5 | 小白   | F      |    81 |   1 | 一班   |
|   5 | 小白   | F      |    81 |   2 | 二班   |
|   5 | 小白   | F      |    81 |   3 | 三班   |
|   5 | 小白   | F      |    81 |   4 | 四班   |
|   6 | 小兵   | M      |    55 |   1 | 一班   |
|   6 | 小兵   | M      |    55 |   2 | 二班   |
|   6 | 小兵   | M      |    55 |   3 | 三班   |
|   6 | 小兵   | M      |    55 |   4 | 四班   |
|   7 | 小林   | M      |    85 |   1 | 一班   |
|   7 | 小林   | M      |    85 |   2 | 二班   |
|   7 | 小林   | M      |    85 |   3 | 三班   |
|   7 | 小林   | M      |    85 |   4 | 四班   |
|   8 | 小新   | F      |    91 |   1 | 一班   |
|   8 | 小新   | F      |    91 |   2 | 二班   |
|   8 | 小新   | F      |    91 |   3 | 三班   |
|   8 | 小新   | F      |    91 |   4 | 四班   |
|   9 | 小王   | M      |    89 |   1 | 一班   |
|   9 | 小王   | M      |    89 |   2 | 二班   |
|   9 | 小王   | M      |    89 |   3 | 三班   |
|   9 | 小王   | M      |    89 |   4 | 四班   |
|  10 | 小丽   | F      |    85 |   1 | 一班   |
|  10 | 小丽   | F      |    85 |   2 | 二班   |
|  10 | 小丽   | F      |    85 |   3 | 三班   |
|  10 | 小丽   | F      |    85 |   4 | 四班   |
+-----+--------+--------+-------+-----+--------+
40 rows in set (0.00 sec)
```





## 2、使用WHERE



> 同样可以使用WHERE进行限制。



```sql
mysql> SELECT
    ->     s.id sid,
    ->     s.name,
    ->     s.gender,
    ->     s.score,
    ->     c.id cid,
    ->     c.name cname
    -> FROM students s, classes c
    -> WHERE s.gender = 'M' AND c.id = 1;
+-----+--------+--------+-------+-----+--------+
| sid | name   | gender | score | cid | cname  |
+-----+--------+--------+-------+-----+--------+
|   1 | 小明   | M      |    90 |   1 | 一班   |
|   3 | 小军   | M      |    88 |   1 | 一班   |
|   6 | 小兵   | M      |    55 |   1 | 一班   |
|   7 | 小林   | M      |    85 |   1 | 一班   |
|   9 | 小王   | M      |    89 |   1 | 一班   |
+-----+--------+--------+-------+-----+--------+
5 rows in set (0.01 sec)
```







# 九、连接查询



> 连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。





## 1、INNER JOIN查询（内连接）



> 现在问题来了，存放班级名称的`name`列存储在`classes`表中，只有根据`students`表的`class_id`，找到`classes`表对应的行，再取出`name`列，就可以获得班级名称。
>
> 这时，连接查询就派上了用场。
>
> 看下方结果，就知道这是连接了classes表的name列，尽可能满足两个表情况，不会出现NULL的情况。



1. 先确定主表，仍然使用`FROM <表1>`的语法；
2. 再确定需要连接的表，使用`INNER JOIN <表2>`的语法；
3. 然后确定连接条件，使用`ON <条件...>`，这里的条件是`s.class_id = c.id`，表示`students`表的`class_id`列与`classes`表的`id`列相同的行需要连接；
4. 可选：加上`WHERE`子句、`ORDER BY`等子句。



示例图如下：

![](https://i.loli.net/2020/06/03/FnVoJYyXKD5QpZf.png)



代码如下：



```sql
$ mysql> SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
    -> FROM students s
    -> INNER JOIN classes c
    -> ON s.class_id = c.id;
+----+--------+----------+------------+--------+-------+
| id | name   | class_id | class_name | gender | score |
+----+--------+----------+------------+--------+-------+
|  1 | 小明   |        1 | 一班       | M      |    90 |
|  2 | 小红   |        1 | 一班       | F      |    95 |
|  3 | 小军   |        1 | 一班       | M      |    88 |
|  4 | 小米   |        1 | 一班       | F      |    73 |
|  5 | 小白   |        2 | 二班       | F      |    81 |
|  6 | 小兵   |        2 | 二班       | M      |    55 |
|  7 | 小林   |        2 | 二班       | M      |    85 |
|  8 | 小新   |        3 | 三班       | F      |    91 |
|  9 | 小王   |        3 | 三班       | M      |    89 |
| 10 | 小丽   |        3 | 三班       | F      |    85 |
+----+--------+----------+------------+--------+-------+
10 rows in set (0.01 sec)
```







## 2、RIGHT OUTER JOIN（右外连接）

> 尽量满足第二个表的情况，第一个表若没有对应的信息，会以`NULL`显示：
>
> **注意**：左右外连接可以省略写`OUTER`。



示例图如下：



![](https://i.loli.net/2020/06/03/9wUZjqBb5Y4HpQI.png)



代码如下：

```sql
$ mysql> SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
    -> FROM students s
    -> RIGHT OUTER JOIN classes c
    -> ON s.class_id = c.id;
+------+--------+----------+------------+--------+-------+
| id   | name   | class_id | class_name | gender | score |
+------+--------+----------+------------+--------+-------+
|    1 | 小明   |        1 | 一班       | M      |    90 |
|    2 | 小红   |        1 | 一班       | F      |    95 |
|    3 | 小军   |        1 | 一班       | M      |    88 |
|    4 | 小米   |        1 | 一班       | F      |    73 |
|    5 | 小白   |        2 | 二班       | F      |    81 |
|    6 | 小兵   |        2 | 二班       | M      |    55 |
|    7 | 小林   |        2 | 二班       | M      |    85 |
|    8 | 小新   |        3 | 三班       | F      |    91 |
|    9 | 小王   |        3 | 三班       | M      |    89 |
|   10 | 小丽   |        3 | 三班       | F      |    85 |
| NULL | NULL   |     NULL | 四班       | NULL   |  NULL |
+------+--------+----------+------------+--------+-------+
11 rows in set (0.01 sec)
```







## 3、LEFT OUTER JOIN（左外连接）



> 尽量满足第一个表的情况，第二个表若没有对应信息，会以`NULL`显示：
>
> 由于`students`表都可以在`classes`表匹配，所以添加一行吧唧id为5的，来说明左外连接问题。



示例图如下：



![](https://i.loli.net/2020/06/03/yTozw3hQbYp8SKU.png)

代码如下：



```sql
-- 
$ mysql> INSERT INTO students (class_id, name, gender, score) values (5, '新生', 'M', 88);
Query OK, 1 row affected (0.01 sec)

$ mysql> SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
    -> FROM students s
    -> LEFT OUTER JOIN classes c
    -> ON s.class_id = c.id;
+----+--------+----------+------------+--------+-------+
| id | name   | class_id | class_name | gender | score |
+----+--------+----------+------------+--------+-------+
|  1 | 小明   |        1 | 一班       | M      |    90 |
|  2 | 小红   |        1 | 一班       | F      |    95 |
|  3 | 小军   |        1 | 一班       | M      |    88 |
|  4 | 小米   |        1 | 一班       | F      |    73 |
|  5 | 小白   |        2 | 二班       | F      |    81 |
|  6 | 小兵   |        2 | 二班       | M      |    55 |
|  7 | 小林   |        2 | 二班       | M      |    85 |
|  8 | 小新   |        3 | 三班       | F      |    91 |
|  9 | 小王   |        3 | 三班       | M      |    89 |
| 10 | 小丽   |        3 | 三班       | F      |    85 |
| 11 | 新生   |        5 | NULL       | M      |    88 |
+----+--------+----------+------------+--------+-------+
11 rows in set (0.01 sec)
```





## 4、FULL OUTER JOIN（全外连接）



> 也就是左右外连接的并集，没有的信息显示为`NULL`：
>
> MySQL并不支持全连接。。。

示例图如下：



![](https://i.loli.net/2020/06/03/rhCTO9VMHPtxiDF.png)



代码如下：



```sql
$ mysql> SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
    -> FROM students s
    -> FULL OUTER JOIN classes c
    -> ON s.class_id = c.id;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FULL OUTER JOIN classes c
ON s.class_id = c.id' at line 3
```



- 代替解决方案：使用`UNION`，左连接一次，有连接一次，再使用UNION合并。



代码如下：



```sql
mysql> SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
    -> FROM students s
    -> RIGHT OUTER JOIN classes c ON class_id = c.id
    -> UNION
    -> SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
    -> FROM students s
    -> LEFT OUTER JOIN classes c ON class_id = c.id;
+------+--------+----------+------------+--------+-------+
| id   | name   | class_id | class_name | gender | score |
+------+--------+----------+------------+--------+-------+
|    1 | 小明   |        1 | 一班       | M      |    90 |
|    2 | 小红   |        1 | 一班       | F      |    95 |
|    3 | 小军   |        1 | 一班       | M      |    88 |
|    4 | 小米   |        1 | 一班       | F      |    73 |
|    5 | 小白   |        2 | 二班       | F      |    81 |
|    6 | 小兵   |        2 | 二班       | M      |    55 |
|    7 | 小林   |        2 | 二班       | M      |    85 |
|    8 | 小新   |        3 | 三班       | F      |    91 |
|    9 | 小王   |        3 | 三班       | M      |    89 |
|   10 | 小丽   |        3 | 三班       | F      |    85 |
| NULL | NULL   |     NULL | 四班       | NULL   |  NULL |
|   11 | 新生   |        5 | NULL       | M      |    88 |
+------+--------+----------+------------+--------+-------+
12 rows in set (0.00 sec)
```









<center style="color: red; font-size: 25px">数据库教程之查询数据已完成！敬请期待后续内容！</center>