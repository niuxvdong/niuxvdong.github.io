{"meta":{"title":"小牛博客","subtitle":"每天进步一点点!","description":"一个大学生的博客，记录学习，记录成长，分享生活！","author":"Dreamy.NXD","url":"https://niuxvdong.top","root":"/"},"pages":[{"title":"404","date":"2020-02-05T05:33:10.000Z","updated":"2020-02-05T05:33:10.000Z","comments":true,"path":"404.html","permalink":"https://niuxvdong.top/404.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2020-02-02T04:27:52.000Z","updated":"2020-02-02T04:27:52.000Z","comments":true,"path":"about/index.html","permalink":"https://niuxvdong.top/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"books","date":"2020-02-05T03:09:36.000Z","updated":"2020-02-05T03:09:36.000Z","comments":true,"path":"books/index.html","permalink":"https://niuxvdong.top/books/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-02-02T04:26:28.000Z","updated":"2020-02-02T04:26:28.000Z","comments":true,"path":"categories/index.html","permalink":"https://niuxvdong.top/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2020-02-02T04:29:49.000Z","updated":"2020-02-02T04:29:49.000Z","comments":true,"path":"friends/index.html","permalink":"https://niuxvdong.top/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-02-02T04:31:45.000Z","updated":"2020-02-02T04:31:45.000Z","comments":true,"path":"contact/index.html","permalink":"https://niuxvdong.top/contact/index.html","excerpt":"","text":"有什么想说的，可以在下面留言哦，欢迎大家来讨论！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"movies","date":"2020-02-05T03:09:13.000Z","updated":"2020-02-05T03:09:13.000Z","comments":true,"path":"movies/index.html","permalink":"https://niuxvdong.top/movies/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"galleries","date":"2020-02-05T03:27:33.000Z","updated":"2020-02-05T03:27:33.000Z","comments":true,"path":"galleries/index.html","permalink":"https://niuxvdong.top/galleries/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"友情链接","date":"2020-05-18T14:17:49.000Z","updated":"2020-05-18T14:17:49.000Z","comments":true,"path":"link/index.html","permalink":"https://niuxvdong.top/link/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-02-05T09:18:22.000Z","updated":"2020-02-05T09:18:22.000Z","comments":true,"path":"tags/index.html","permalink":"https://niuxvdong.top/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"musics","date":"2020-02-05T03:08:51.000Z","updated":"2020-02-05T03:08:51.000Z","comments":true,"path":"musics/index.html","permalink":"https://niuxvdong.top/musics/index.html","excerpt":"","text":"我的歌单 欢迎下方留言自己喜欢的歌单链接！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"LeetCode刷题-2.两数相加","slug":"LeetCode刷题-2-两数相加","date":"2020-06-12T14:09:58.000Z","updated":"2020-06-12T14:09:58.000Z","comments":true,"path":"posts/1127.html","link":"","permalink":"https://niuxvdong.top/posts/1127.html","excerpt":"","text":"题目链接：2.两数相加 题解： 链表的简单操作！模拟数字相加。 题目简述：两个倒序链表：例如：234的链表为 4 -&gt; 3 -&gt; 2，给定两个倒序链表，返回两个链表正序相加后的倒序链表！ 题解：由于给出的顺序是倒序，可以直接像普通加法从个位开始加起，进位即可。 初始化时可以设置一个虚节点：ListNode* l3 = new ListNode(-1);，返回时直接返回l3-&gt;next即可。 用 t表示进位，while退出后若仍有进位，则链表末尾补 1 ； AC代码1：1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* l3 = new ListNode(-1); ListNode* res = l3; int t = 0; while(l1 || l2){ // 链表结束，之后全部置为0 int n1 = l1 ? l1-&gt;val : 0; int n2 = l2 ? l2-&gt;val : 0; int sum = n1 + n2 + t; // t 表示进位 t = sum / 10; res-&gt;next = new ListNode(sum % 10); res = res-&gt;next; if(l1) l1 = l1-&gt;next; if(l2) l2 = l2-&gt;next; } // 最高位有进位： if(t) res-&gt;next = new ListNode(1); // 返回除了第一个-1之外的节点 return l3-&gt;next; }}; AC代码2： 写法更加简洁：直接使用 t进行累加即可！ 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* l3 = new ListNode(-1); ListNode* res = l3; int t = 0; while(l1 || l2 || t){ if(l1) t += l1-&gt;val, l1 = l1-&gt;next; if(l2) t += l2-&gt;val, l2 = l2-&gt;next; res-&gt;next = new ListNode(t % 10); res = res-&gt;next; t /= 10; } return l3-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://niuxvdong.top/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://niuxvdong.top/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"链表","slug":"链表","permalink":"https://niuxvdong.top/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-1.两数之和","slug":"LeetCode刷题-1-两数之和","date":"2020-06-12T12:53:28.000Z","updated":"2020-06-12T12:53:28.000Z","comments":true,"path":"posts/43672.html","link":"","permalink":"https://niuxvdong.top/posts/43672.html","excerpt":"","text":"题目链接：1.两数之和 题解：1、暴力由于答案的解唯一，可以使用两层循环，找到直接返回！ 假如：最后为{i, j}， i &lt; j，两层循环如下方代码。 时间复杂度：O(N^2) AC代码：1234567891011121314class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { for(int i = 0; i &lt; nums.size(); i++) { for(int j = i + 1; j &lt; nums.size(); j++) { if(nums[i] + nums[j] == target) return {i, j}; } } return {}; }}; 2、使用哈希表本题的目标就是找一个数，target - nums[i] ，找到一个即为答案，对于快速的查找可以使用哈希表！ 这里的 下标 i 规定为 {j, i}，j &lt; i， 只需要每次从i - j 的范围找一个 target - nums[i]即可，找到即为答案，返回{hash[target - nums[i]], i}. 判断target - nums[i]是否在哈希表 不在则将当前数加到哈希表 哈希表： unordered_map： 增删改查复杂度为O(1) 两个函数： count()：统计个数，C++ unordered_map不允许有重复的 key，所以该返回值为1 或 0； find()：找到返回迭代器，找不到返回 hash.end() 时间复杂度：O(N) AC代码：12345678910111213141516171819class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; hash; for(int i = 0; i &lt; nums.size(); i++){ int r = target - nums[i]; // 使用find // if(hash.find(r) != hash.end()){ // return {hash[r], i}; // } // count if(hash.count(r)){ return {hash[r], i}; } hash[nums[i]] = i; } return {}; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://niuxvdong.top/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://niuxvdong.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"哈希表","slug":"哈希表","permalink":"https://niuxvdong.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"数据库教程之修改数据","slug":"数据库教程之修改数据","date":"2020-06-09T10:36:02.000Z","updated":"2020-06-09T10:36:02.000Z","comments":true,"path":"posts/26278.html","link":"","permalink":"https://niuxvdong.top/posts/26278.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve(检索)、Update、Delete。其中，对于查询，我们已经详细讲述了SELECT语句的详细用法。 而对于增、删、改，对应的SQL语句分别是： INSERT：插入新记录； UPDATE：更新已有记录； DELETE：删除已有记录。 一、INSERT1、插入一条记录 语法：INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...); id字段是一个自增主键，它的值可以由数据库自己推算出来。 如果一个字段有默认值，那么在INSERT语句中也可以不出现。 要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。 123456789101112131415161718192021$ mysql&gt; INSERT INTO students (class_id, name, gender, score) VALUES (2, '大牛', 'M', 80);Query OK, 1 row affected (0.03 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 73 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 55 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 |+----+----------+--------+--------+-------+12 rows in set (0.00 sec) 2、插入多条记录 语法：INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...), VALUES (值1, 值2, ...).....; 多条语句，逗号隔开！ 1234567891011121314151617181920212223242526$ mysql&gt; INSERT INTO students (class_id, name, gender, score) VALUES -&gt; (1, '大宝', 'M', 87), -&gt; (2, '二宝', 'M', 81);Query OK, 2 rows affected (0.01 sec)Records: 2 Duplicates: 0 Warnings: 0$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 73 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 55 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) 二、UPDATE1、更新一条记录 语法：UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...; 1234567891011$ mysql&gt; UPDATE students SET name='大牛', score=66 WHERE id=1;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0$ mysql&gt; SELECT * FROM students WHERE id=1;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 大牛 | M | 66 |+----+----------+--------+--------+-------+1 row in set (0.00 sec) 2、更新多条记录 语法：UPDATE students SET name='小牛', score=77 WHERE id&gt;=5 AND id&lt;=7; WHERE条件可与逻辑运算符结合，更新指定条件的记录。 如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。 123456789101112131415161718192021222324$ mysql&gt; UPDATE students SET score=score+10 WHERE score&lt;80;Query OK, 3 rows affected (0.01 sec)Rows matched: 3 Changed: 3 Warnings: 0$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 大牛 | M | 76 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) 3、不使用WHERE条件 此举动要小心，整个表的所有记录都会被更新。 eg：UPDATE students SET score=60; 效果：整个表的学生分数都变为了60. 注意：所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。 4、MySQL提示信息 使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。 123$ mysql&gt; UPDATE students SET name='大牛', score=66 WHERE id=1;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0 三、DELETE1、删除记录 语法：DELETE FROM &lt;表名&gt; WHERE ...; 同样：可以配合逻辑运算符实现多条删除！ 如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。 12345678910111213141516171819202122$ mysql&gt; DELETE FROM students WHERE id=1;Query OK, 1 row affected (0.01 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+13 rows in set (0.00 sec) 2、不使用WHERE条件 此举动要小心，整个表的所有记录都会被删除。 eg：DELETE FROM students; 效果：变成了一张空表。 注意：所以，在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。 4、MySQL提示信息 使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。 12$ mysql&gt; DELETE FROM students WHERE id=1;Query OK, 1 row affected (0.01 sec) 四、实用SQL语句1、插入或替换 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用REPLACE语句。 1234567891011121314151617181920212223$ mysql&gt; REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);Query OK, 1 row affected (0.01 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | F | 99 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) 2、插入或更新 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用INSERT INTO ... ON DUPLICATE KEY UPDATE ...语句： 1234567891011121314151617181920212223$ mysql&gt; INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, ' 小明', 'F', 99) ON DUPLICATE KEY UPDATE name='小明', gender='F', score=98;Query OK, 2 rows affected (0.00 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | F | 98 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) 3、插入或忽略 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用INSERT IGNORE INTO ...语句。 1234567891011121314151617181920212223$ mysql&gt; INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);Query OK, 0 rows affected, 1 warning (0.00 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | F | 98 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) 4、快照 如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT。 可选的复制复制了一份，和该表结构一致。 12345678910111213141516171819202122232425$ mysql&gt; CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1;Query OK, 5 rows affected (0.09 sec)Records: 5 Duplicates: 0 Warnings: 0$ mysql&gt; SHOW TABLES;+--------------------+| Tables_in_test |+--------------------+| classes || students || students_of_class1 |+--------------------+3 rows in set (0.01 sec)$ mysql&gt; SELECT * FROM students_of_class1;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | F | 98 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 13 | 1 | 大宝 | M | 87 |+----+----------+--------+--------+-------+5 rows in set (0.00 sec) 5、写入查询结果集 如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。 先创建满足需求的表 1234567$ mysql&gt; CREATE TABLE result ( -&gt; id BIGINT NOT NULL AUTO_INCREMENT, -&gt; class_id BIGINT NOT NULL, -&gt; average DOUBLE NOT NULL, -&gt; PRIMARY KEY (id) -&gt; );Query OK, 0 rows affected (0.03 sec) 使用INSERT INTO ... SELECT ... FROM... 1234567891011121314$ mysql&gt; INSERT INTO result (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;Query OK, 4 rows affected (0.01 sec)Records: 4 Duplicates: 0 Warnings: 0$ mysql&gt; SELECT * FROM result;+----+----------+--------------+| id | class_id | average |+----+----------+--------------+| 1 | 1 | 90.2 || 2 | 2 | 78.4 || 3 | 3 | 88.333333333 || 4 | 5 | 88 |+----+----------+--------------+4 rows in set (0.00 sec) 6、强制使用指定索引 在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。 指定索引前提是索引（idx_class_id）必须存在！ 1$ SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://niuxvdong.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"修改","slug":"修改","permalink":"https://niuxvdong.top/tags/%E4%BF%AE%E6%94%B9/"},{"name":"INSERT","slug":"INSERT","permalink":"https://niuxvdong.top/tags/INSERT/"},{"name":"UPDATE","slug":"UPDATE","permalink":"https://niuxvdong.top/tags/UPDATE/"},{"name":"DELETE","slug":"DELETE","permalink":"https://niuxvdong.top/tags/DELETE/"}],"author":"Mr.Niu"},{"title":"JS实战之油猴脚本编写之知乎一键转载","slug":"JS实战之油猴脚本编写之知乎一键转载","date":"2020-06-07T14:23:46.000Z","updated":"2020-06-07T14:23:46.000Z","comments":true,"path":"posts/1495.html","link":"","permalink":"https://niuxvdong.top/posts/1495.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、准备工作 根据所学JS知识以及又拍云小哥直播的讲解实战开发的一个小脚本！ 所有链接： 又拍云上直播地址：点击这里！ 又拍云油猴脚本开发：点击这里！ 我的油猴知乎实战脚本，点击这里！ 二、实现功能 隐藏回答界面的右边侧栏，提升阅读舒适性！ 加宽回答的可视区域，让您看的更加舒服！ 增加一个一键转载按钮（一键复制），禁止转载的给出提示信息！ 实现效果如下： 三、完整代码 脚本地址，点击这里！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// ==UserScript==// @name 知乎一键转载// @namespace http://tampermonkey.net/// @version 0.5// @description 模仿又拍云 demo 实现并修改的知乎一件转载，可以一键复制到剪贴板！隐藏知乎右边侧栏，加宽回答可视区域，使您阅读的更加舒服！欢迎食用！// @author NXD// @match https://www.zhihu.com/question/*// @grant GM_addStyle// ==/UserScript==// Question-sideColumn 隐藏右边栏GM_addStyle('.Question-sideColumn {display: none !important}');// 回答界面加宽GM_addStyle('.Question-mainColumn {width: 1000px !important}');(function() { 'use strict'; function createElement(eleName, text, attrs){ let ele = document.createElement(eleName); ele.innerText = text; for(let k in attrs){ ele.setAttribute(k, attrs[k]); } return ele; } // 复制到剪贴板函数 function addToClipboard(text){ navigator.clipboard.writeText(text).then(function() { // 一切都没问题的话会执行 alert 操作 alert('succeed copy'); }, function(err) { // 失败时执行的函数 console.info('failed copy', err); alert('faild copy') }); } // added 是一个全局变量, 用来保存已经添加过按钮的节点. let added = []; // 按钮样式 let btnStyle = 'background-color: #0084ff; margin-top: 15px; margin-bottom: 15px; margin-left:-5px; cursor:pointer; color: #fff; border-radius: 3px; border: 1px solid; padding: 3px 6px'; // 第一个回答 Card AnswerCard function addFirstBtn(){ // 获得第一个回答 let first = document.querySelector(\"#root &gt; div &gt; main &gt; div &gt; div.Question-main &gt; div.ListShortcut &gt; div &gt; div.Card.AnswerCard\"); // 获取每个回答的头部信息位置 let meta = first.querySelector('div[class=\"ContentItem-meta\"]'); // https://www.zhihu.com/question/398927155/answer/1266562835 获取到网址拿到最后的answer Id let who = meta.querySelector('meta[itemprop=\"url\"]').getAttribute('content').split('/').pop(); // 添加过的不再添加 if(added.indexOf(who) === -1){ // 没添加的插入数组 added.push(who); // 创建按钮 let btn = createElement('button', '转载按钮', {style: btnStyle}); // 获取文章内容 let text = first.querySelector('div[class=\"RichContent-inner\"]').innerText; // 将文章内容复制到剪贴板 btn.addEventListener('click', ()=&gt;{addToClipboard(text)}); meta.append(btn); } } // 更多回答：Card MoreAnswers function addBtn(){ // 更多回答 let all = document.querySelectorAll('div[class=\"List-item\"]'); for(let item of all){ // 获取每个回答的头部信息位置 let meta = item.querySelector('div[class=\"ContentItem-meta\"]'); // https://www.zhihu.com/question/398927155/answer/1266562835 获取到网址拿到最后的answer Id let who = meta.querySelector('meta[itemprop=\"url\"]').getAttribute('content').split('/').pop(); // 添加过的不再添加 if(added.indexOf(who) !== -1){ continue; } // 没添加的插入数组 added.push(who); // 创建按钮 let btn = createElement('button', '转载按钮', {style: btnStyle}); // 获取文章内容 let text = item.querySelector('div[class=\"RichContent-inner\"]').innerText; // 将文章内容复制到剪贴板 btn.addEventListener('click', ()=&gt;{addToClipboard(text)}); meta.append(btn); } } // 点击查看全部回答调用addBtn // 点击后 window.addEventListener('load', addBtn); // 点击前 // 1. 加载完调用 处理第一个回答 window.addEventListener('load', addFirstBtn); // 2. 随着滚动条调用后续方法 window.addEventListener('scroll', addBtn);})(); 四、代码实现介绍 模仿又拍云小哥demo实现，由于小哥原版的有一些bug，我做了简单修复，具体内容如下： 修复回答界面点击查看全部回答后第一个回答无法加载按钮的bug 修复点进回答界面第一个回答按钮无法加载需要触发滚动事件的bug 修复来修复去，又多了一个bug，点进查看全部回答界面似乎又不进行加载脚本了，我心累了！原脚本也有这个bug。 1、油猴脚本头部123456789// ==UserScript==// @name 知乎一键转载// @namespace http://tampermonkey.net/// @version 0.5// @description 模仿又拍云 demo 实现并修改的知乎一件转载，可以一键复制到剪贴板！隐藏知乎右边侧栏，加宽回答可视区域，使您阅读的更加舒服！欢迎食用！// @author NXD// @match https://www.zhihu.com/question/*// @grant GM_addStyle// ==/UserScript== name：脚本名称 version：版本 description：脚本描述 author：作者 match：匹配生效的网址 grant：导入油猴官方的API namespace：是命名空间，可以用你的网站名称 其他关键词及API请访问油猴文档！ 2、相关函数介绍2.1 GM_addStyle 油猴官方实现的接口用于写更方便的写CSS！ 怎么写CSS就怎么使用该方法。 1GM_addStyle('.Question-mainColumn {width: 1000px !important}'); 2.2 createElement 创建元素函数！ createElement(eleName, text, attrs)：元素名，元素内的文本信息，以及属性接收一个对象（即{}参数） 2.3 addToClipboard 复制到剪贴板函数！ 传入text参数，为复制的文本信息。 2.4 addFirstBtn 由于不点击查看全部回答第一个回答和后续回答不一样，要格外设置一个函数去处理第一个回答！ 第一个回答的 class：Card AnswerCard 点击查看全部回答后的 class：Card MoreAnswers 2.5 addBtn 同样：处理没点击查看全部回答的后续回答（除了第一个不一样的）以及点击查看全部回答的所有回答。 3、加载事件设置 window.addEventListener('load', addFirstBtn)：处理第一个不一样的回答 window.addEventListener('load', addBtn)：主要用于处理点击查看全部回答后的回答，加载完调用。 window.addEventListener('scroll', addBtn)：同时处理点击或每点击后续流式加载出现的回答，随滚动条加载。 防止出现重复添加按钮，使用added数组来判断：added.indexOf(who) !== -1 添加按钮即push到数组 没有添加则应该为 -1 12345678// 点击查看全部回答调用addBtn// 点击后window.addEventListener('load', addBtn);// 点击前// 1. 加载完调用 处理第一个回答window.addEventListener('load', addFirstBtn);// 2. 随着滚动条调用后续方法window.addEventListener('scroll', addBtn); 五、总结 一个脚本的编写需要去网页找到对应的元素class，获取到位置再进行操作 需要修复好多的bug，泪目啊！ 需要有HTML CSS JS知识，最好有强硬的JS能力。 这一次脚本编写也是极大的锻炼了我的JS实战能力，掌握了一些用法。虽然本脚本实现的功能较为简单与简陋，甚至有好多bug，但是我会在后续不断改进，完善的！ 很开心的一次实战！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JS实战","slug":"JS实战","permalink":"https://niuxvdong.top/categories/JS%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"油猴脚本","slug":"油猴脚本","permalink":"https://niuxvdong.top/tags/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"},{"name":"知乎","slug":"知乎","permalink":"https://niuxvdong.top/tags/%E7%9F%A5%E4%B9%8E/"}],"author":"Mr.Niu"},{"title":"数据库教程之查询数据","slug":"数据库教程之查询数据","date":"2020-06-02T09:37:39.000Z","updated":"2020-06-02T09:37:39.000Z","comments":true,"path":"posts/16928.html","link":"","permalink":"https://niuxvdong.top/posts/16928.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、准备数据 廖雪峰SQL教程例子：例子代码点击这里！ 将上方链接或者下方代码保存到文本文件，改名为init-test-data.sql。然后再本地cmd运行$ mysql -u root -p &lt; init-test-data.sql即可创建一个名为test的数据库，有两张表classes和students! 注意要在cmd，不要使用powershell，powershell无法识别命令行&lt;这个符号！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-- 如果test数据库不存在，就创建test数据库：CREATE DATABASE IF NOT EXISTS test;-- 切换到test数据库USE test;-- 删除classes表和students表（如果存在）：DROP TABLE IF EXISTS classes;DROP TABLE IF EXISTS students;-- 创建classes表：CREATE TABLE classes ( id BIGINT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 创建students表：CREATE TABLE students ( id BIGINT NOT NULL AUTO_INCREMENT, class_id BIGINT NOT NULL, name VARCHAR(100) NOT NULL, gender VARCHAR(1) NOT NULL, score INT NOT NULL, PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 插入classes记录：INSERT INTO classes(id, name) VALUES (1, '一班');INSERT INTO classes(id, name) VALUES (2, '二班');INSERT INTO classes(id, name) VALUES (3, '三班');INSERT INTO classes(id, name) VALUES (4, '四班');-- 插入students记录：INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'M', 90);INSERT INTO students (id, class_id, name, gender, score) VALUES (2, 1, '小红', 'F', 95);INSERT INTO students (id, class_id, name, gender, score) VALUES (3, 1, '小军', 'M', 88);INSERT INTO students (id, class_id, name, gender, score) VALUES (4, 1, '小米', 'F', 73);INSERT INTO students (id, class_id, name, gender, score) VALUES (5, 2, '小白', 'F', 81);INSERT INTO students (id, class_id, name, gender, score) VALUES (6, 2, '小兵', 'M', 55);INSERT INTO students (id, class_id, name, gender, score) VALUES (7, 2, '小林', 'M', 85);INSERT INTO students (id, class_id, name, gender, score) VALUES (8, 3, '小新', 'F', 91);INSERT INTO students (id, class_id, name, gender, score) VALUES (9, 3, '小王', 'M', 89);INSERT INTO students (id, class_id, name, gender, score) VALUES (10, 3, '小丽', 'F', 85);-- OK:SELECT 'ok' as 'result:'; 二、基本查询1、SELECT语句 使用SELECT * FROM students时，SELECT是关键字，表示将要执行一个查询，*表示“所有列”，FROM表示将要从哪个表查询，本例中是students表。 该SQL将查询出students表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。 12$ USE test;$ SELECT * FROM &lt;表名&gt;; 2、用于计算的SELECT 上述查询会直接计算出表达式的结果。虽然SELECT可以用作计算，但它并不是SQL的强项。但是，不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1;来测试数据库连接。 1234567$ mysql&gt; SELECT 200 * 3000000000;+------------------+| 200 * 3000000000 |+------------------+| 600000000000 |+------------------+1 row in set (0.00 sec) 三、条件查询1、WHERE 条件 使用SELECT * FROM &lt;表名&gt;可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。 格式如下： 1$ SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt; 效果如下： 2、逻辑运算 与其他语言不同：等于号不是==而是=！ 2.1 AND 就是与与元算符！ 12345678910$ mysql&gt; SELECT * FROM students WHERE score &gt;= 80 AND gender = 'M';+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 3 | 1 | 小军 | M | 88 || 7 | 2 | 小林 | M | 85 || 9 | 3 | 小王 | M | 89 |+----+----------+--------+--------+-------+4 rows in set (0.00 sec) 2.2 OR 就是与或元算符！ 123456789101112131415$ mysql&gt; SELECT * FROM students WHERE score &gt;= 80 OR gender = 'M';+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 55 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 |+----+----------+--------+--------+-------+9 rows in set (0.00 sec) 2.3 NOT 就是与非元算符！ 12345678910111213$ mysql&gt; SELECT * FROM students WHERE NOT class_id = 2;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 73 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 |+----+----------+--------+--------+-------+7 rows in set (0.00 sec) 2.4 多条件使用括号 同样：加括号改变了优先级！ 12345678$ mysql&gt; SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = 'M';+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 6 | 2 | 小兵 | M | 55 |+----+----------+--------+--------+-------+1 row in set (0.00 sec) 3、条件表达式符号 注意：不等于不是!=而是&lt;&gt;！ 字符串要用引号引起来！ %可以匹配任意字符，包括空字符且不一定是一个字符！ 条件 表达式举例1 表达式举例2 说明 使用=判断相等 score = 80 name = ‘abc’ 字符串需要用单引号括起来 使用&gt;判断大于 score &gt; 80 name &gt; ‘abc’ 字符串比较根据ASCII码，中文字符比较根据数据库设置 使用&gt;=判断大于或相等 score &gt;= 80 name &gt;= ‘abc’ 使用&lt;判断小于 score &lt; 80 name &lt;= ‘abc’ 使用&lt;=判断小于或相等 score &lt;= 80 name &lt;= ‘abc’ 使用&lt;&gt;判断不相等 score &lt;&gt; 80 name &lt;&gt; ‘abc’ 使用LIKE判断相似 name LIKE ‘ab%’ name LIKE ‘%bc%’ %表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’ 四、投影查询 使用SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。 如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用SELECT 列1, 列2, 列3 FROM ...，让结果集仅包含指定列。这种操作称为投影查询。 投影查询：仅返回指定列！ 1、普通投影1$ SELECT 列1, 列2, 列3 FROM ...，; 例子如下： 12345678910111213141516$ mysql&gt; SELECT id, score, name FROM students;+----+-------+--------+| id | score | name |+----+-------+--------+| 1 | 90 | 小明 || 2 | 95 | 小红 || 3 | 88 | 小军 || 4 | 73 | 小米 || 5 | 81 | 小白 || 6 | 55 | 小兵 || 7 | 85 | 小林 || 8 | 91 | 小新 || 9 | 89 | 小王 || 10 | 85 | 小丽 |+----+-------+--------+10 rows in set (0.01 sec) 2、别名投影1$ SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...; 例子如下：score 一列改别名为 points ！ 12345678910111213141516$ mysql&gt; SELECT id, score points, name FROM students;+----+--------+--------+| id | points | name |+----+--------+--------+| 1 | 90 | 小明 || 2 | 95 | 小红 || 3 | 88 | 小军 || 4 | 73 | 小米 || 5 | 81 | 小白 || 6 | 55 | 小兵 || 7 | 85 | 小林 || 8 | 91 | 小新 || 9 | 89 | 小王 || 10 | 85 | 小丽 |+----+--------+--------+10 rows in set (0.00 sec) 3、复杂投影 将投影与别名与WHERE条件查询结合！ 1234567891011mysql&gt; SELECT id, score points, name FROM students WHERE gender = 'M';+----+--------+--------+| id | points | name |+----+--------+--------+| 1 | 90 | 小明 || 3 | 88 | 小军 || 6 | 55 | 小兵 || 7 | 85 | 小林 || 9 | 89 | 小王 |+----+--------+--------+5 rows in set (0.00 sec) 五、排序 我们使用SELECT查询时，细心的读者可能注意到，查询结果集通常是按照id排序的，也就是根据主键排序。这也是大部分数据库的做法。 1、升序 使用 ORDER BY ***语句；ASC：升序，可省略！ 12345678910111213141516$ mysql&gt; SELECT id, name, gender, score FROM students ORDER BY score;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 6 | 小兵 | M | 55 || 4 | 小米 | F | 73 || 5 | 小白 | F | 81 || 7 | 小林 | M | 85 || 10 | 小丽 | F | 85 || 3 | 小军 | M | 88 || 9 | 小王 | M | 89 || 1 | 小明 | M | 90 || 8 | 小新 | F | 91 || 2 | 小红 | F | 95 |+----+--------+--------+-------+10 rows in set (0.00 sec) 2、降序 使用 ORDER BY *** DESC，DESC表示“倒序”，不可省略！ 12345678910111213141516$ mysql&gt; SELECT id, name, gender, score FROM students ORDER BY score DESC;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 2 | 小红 | F | 95 || 8 | 小新 | F | 91 || 1 | 小明 | M | 90 || 9 | 小王 | M | 89 || 3 | 小军 | M | 88 || 7 | 小林 | M | 85 || 10 | 小丽 | F | 85 || 5 | 小白 | F | 81 || 4 | 小米 | F | 73 || 6 | 小兵 | M | 55 |+----+--------+--------+-------+10 rows in set (0.00 sec) 3、复杂排序3.1 多列排序 若score列有相同的数据，要进一步排序，可以继续添加列名。 即先按score降序，再按gender升序（默认为ASC升序）。 1234567891011121314151617$ mysql&gt; SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 2 | 小红 | F | 95 || 8 | 小新 | F | 91 || 1 | 小明 | M | 90 || 9 | 小王 | M | 89 || 3 | 小军 | M | 88 || 10 | 小丽 | F | 85 || 7 | 小林 | M | 85 || 5 | 小白 | F | 81 || 4 | 小米 | F | 73 || 6 | 小兵 | M | 55 |+----+--------+--------+-------+10 rows in set (0.00 sec) 3.2 条件排序 如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面！ 12345678910111213$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; WHERE class_id = 1 -&gt; ORDER BY score DESC;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 2 | 小红 | F | 95 || 1 | 小明 | M | 90 || 3 | 小军 | M | 88 || 4 | 小米 | F | 73 |+----+--------+--------+-------+4 rows in set (0.00 sec) 六、分页查询 使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。 要实现分页功能，实际上就是从结果集中显示第1 ~ 100条记录作为第1页，显示第101 ~ 200条记录作为第2页，以此类推。 因此，分页实际上就是从结果集中“截取”出第M ~ N条记录。 通过LIMIT &lt;M&gt; OFFSET &lt;N&gt;子句实现：LIMIT表示每页最多三条信息，OFFSET表示从第几条开始。（SQL索引从0开始） 注意： OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。 在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15。 使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;分页时，随着N越来越大，查询效率也会越来越低。 规则：分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值： LIMIT总是设定为pageSize； OFFSET计算公式为pageSize * (pageIndex - 1)。 如下：1234567891011121314151617181920212223242526272829303132333435363738$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; ORDER BY score DESC -&gt; LIMIT 3 OFFSET 0;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 2 | 小红 | F | 95 || 8 | 小新 | F | 91 || 1 | 小明 | M | 90 |+----+--------+--------+-------+3 rows in set (0.00 sec)$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; ORDER BY score DESC -&gt; LIMIT 3 OFFSET 3;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 9 | 小王 | M | 89 || 3 | 小军 | M | 88 || 10 | 小丽 | F | 85 |+----+--------+--------+-------+3 rows in set (0.00 sec)...$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; ORDER BY score DESC -&gt; LIMIT 3 OFFSET 9;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 6 | 小兵 | M | 55 |+----+--------+--------+-------+1 row in set (0.00 sec) 若OFFSET设置的越界了，并不会报错，会返回一个空集合！ 12345$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; ORDER BY score DESC -&gt; LIMIT 3 OFFSET 20;Empty set (0.00 sec) 七、聚合查询 对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。 1、COUNT()函数 COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)。 可以设置一个别名，便于处理结果： COUNT(*)和COUNT(id)实际上是一样的效果。 12345678910111213141516$ mysql&gt; SELECT COUNT(*) FROM students;+----------+| COUNT(*) |+----------+| 10 |+----------+1 row in set (0.00 sec)-- 取一个别名 nummysql&gt; SELECT COUNT(*) num FROM students;+-----+| num |+-----+| 10 |+-----+1 row in set (0.00 sec) 同样可以使用WHERE条件 1234567mysql&gt; SELECT COUNT(*) boys FROM students WHERE gender = 'M';+------+| boys |+------+| 5 |+------+1 row in set (0.00 sec) 2、其他函数 注意，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。 注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL： 函数 说明 SUM 计算某一列的合计值，该列必须为数值类型 AVG 计算某一列的平均值，该列必须为数值类型 MAX 计算某一列的最大值 MIN 计算某一列的最小值 CEILING 上取整 FLOOR 下取整 12345678910111213141516171819202122232425262728$ mysql&gt; SELECT AVG(score) average FROM students WHERE gender = 'M';+---------+| average |+---------+| 81.4000 |+---------+1 row in set (0.01 sec)-- WHERE找不到返回NULL$ mysql&gt; SELECT AVG(score) average FROM students WHERE gender = 'X';+---------+| average |+---------+| NULL |+---------+1 row in set (0.00 sec)-- 计算页数$ SELECT CEILING(COUNT(*) / 3) pageSize FROM students;mysql&gt; SELECT CEILING(COUNT(*) / 3) pageSize FROM students;+----------+| pageSize |+----------+| 4 |+----------+1 row in set (0.00 sec) 3、分组（GROUP） 用于统计一类数据的方法：GROUP BY 某一列 3.1 单列分组123456789$ mysql&gt; SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;+----------+-----+| class_id | num |+----------+-----+| 1 | 4 || 2 | 3 || 3 | 3 |+----------+-----+3 rows in set (0.00 sec) 3.2 多列分组123456789101112$ mysql&gt; SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;+----------+--------+-----+| class_id | gender | num |+----------+--------+-----+| 1 | M | 2 || 1 | F | 2 || 2 | F | 1 || 2 | M | 2 || 3 | F | 2 || 3 | M | 1 |+----------+--------+-----+6 rows in set (0.00 sec) 注意：SQL引擎不能把多个name的值放入一行记录中。因此，聚合查询的列中，只能放入分组的列。 原因：class_id = 1 有 4 个人，他们班级名相同，但name不同，如果有了name列，应该显示几个名字呢？？？ 所以干脆直接报错！ 12$ mysql&gt; SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.students.name' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 八、多表查询 由于多表查询的笛卡尔乘积问题，会导致每行两表的数据并没有逻辑对应关系。。。 即直接查出来的数据对应不一定正确，需要进行条件限定，如students表的class_id 与 classes表的id相同才能唯一确定一个对应关系。 一般使用主键或外键进行多表关联查询，笛卡尔乘积没太多意义，而且很容易查询量爆炸，不建议使用！ 1、语法： SELECT * FROM &lt;表1&gt; &lt;表2&gt;。 这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。 这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。 给表起别名，再给相同列起别名有助于查看！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$ mysql&gt; SELECT -&gt; s.id sid, -&gt; s.name, -&gt; s.gender, -&gt; s.score, -&gt; c.id cid, -&gt; c.name cname -&gt; FROM students s, classes c;+-----+--------+--------+-------+-----+--------+| sid | name | gender | score | cid | cname |+-----+--------+--------+-------+-----+--------+| 1 | 小明 | M | 90 | 1 | 一班 || 1 | 小明 | M | 90 | 2 | 二班 || 1 | 小明 | M | 90 | 3 | 三班 || 1 | 小明 | M | 90 | 4 | 四班 || 2 | 小红 | F | 95 | 1 | 一班 || 2 | 小红 | F | 95 | 2 | 二班 || 2 | 小红 | F | 95 | 3 | 三班 || 2 | 小红 | F | 95 | 4 | 四班 || 3 | 小军 | M | 88 | 1 | 一班 || 3 | 小军 | M | 88 | 2 | 二班 || 3 | 小军 | M | 88 | 3 | 三班 || 3 | 小军 | M | 88 | 4 | 四班 || 4 | 小米 | F | 73 | 1 | 一班 || 4 | 小米 | F | 73 | 2 | 二班 || 4 | 小米 | F | 73 | 3 | 三班 || 4 | 小米 | F | 73 | 4 | 四班 || 5 | 小白 | F | 81 | 1 | 一班 || 5 | 小白 | F | 81 | 2 | 二班 || 5 | 小白 | F | 81 | 3 | 三班 || 5 | 小白 | F | 81 | 4 | 四班 || 6 | 小兵 | M | 55 | 1 | 一班 || 6 | 小兵 | M | 55 | 2 | 二班 || 6 | 小兵 | M | 55 | 3 | 三班 || 6 | 小兵 | M | 55 | 4 | 四班 || 7 | 小林 | M | 85 | 1 | 一班 || 7 | 小林 | M | 85 | 2 | 二班 || 7 | 小林 | M | 85 | 3 | 三班 || 7 | 小林 | M | 85 | 4 | 四班 || 8 | 小新 | F | 91 | 1 | 一班 || 8 | 小新 | F | 91 | 2 | 二班 || 8 | 小新 | F | 91 | 3 | 三班 || 8 | 小新 | F | 91 | 4 | 四班 || 9 | 小王 | M | 89 | 1 | 一班 || 9 | 小王 | M | 89 | 2 | 二班 || 9 | 小王 | M | 89 | 3 | 三班 || 9 | 小王 | M | 89 | 4 | 四班 || 10 | 小丽 | F | 85 | 1 | 一班 || 10 | 小丽 | F | 85 | 2 | 二班 || 10 | 小丽 | F | 85 | 3 | 三班 || 10 | 小丽 | F | 85 | 4 | 四班 |+-----+--------+--------+-------+-----+--------+40 rows in set (0.00 sec) 2、使用WHERE 同样可以使用WHERE进行限制。 12345678910111213141516171819mysql&gt; SELECT -&gt; s.id sid, -&gt; s.name, -&gt; s.gender, -&gt; s.score, -&gt; c.id cid, -&gt; c.name cname -&gt; FROM students s, classes c -&gt; WHERE s.gender = 'M' AND c.id = 1;+-----+--------+--------+-------+-----+--------+| sid | name | gender | score | cid | cname |+-----+--------+--------+-------+-----+--------+| 1 | 小明 | M | 90 | 1 | 一班 || 3 | 小军 | M | 88 | 1 | 一班 || 6 | 小兵 | M | 55 | 1 | 一班 || 7 | 小林 | M | 85 | 1 | 一班 || 9 | 小王 | M | 89 | 1 | 一班 |+-----+--------+--------+-------+-----+--------+5 rows in set (0.01 sec) 九、连接查询 连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。 1、INNER JOIN查询（内连接） 现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。 这时，连接查询就派上了用场。 看下方结果，就知道这是连接了classes表的name列，尽可能满足两个表情况，不会出现NULL的情况。 先确定主表，仍然使用FROM &lt;表1&gt;的语法； 再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法； 然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接； 可选：加上WHERE子句、ORDER BY等子句。 示例图如下： 代码如下： 12345678910111213141516171819$ mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; INNER JOIN classes c -&gt; ON s.class_id = c.id;+----+--------+----------+------------+--------+-------+| id | name | class_id | class_name | gender | score |+----+--------+----------+------------+--------+-------+| 1 | 小明 | 1 | 一班 | M | 90 || 2 | 小红 | 1 | 一班 | F | 95 || 3 | 小军 | 1 | 一班 | M | 88 || 4 | 小米 | 1 | 一班 | F | 73 || 5 | 小白 | 2 | 二班 | F | 81 || 6 | 小兵 | 2 | 二班 | M | 55 || 7 | 小林 | 2 | 二班 | M | 85 || 8 | 小新 | 3 | 三班 | F | 91 || 9 | 小王 | 3 | 三班 | M | 89 || 10 | 小丽 | 3 | 三班 | F | 85 |+----+--------+----------+------------+--------+-------+10 rows in set (0.01 sec) 2、RIGHT OUTER JOIN（右外连接） 尽量满足第二个表的情况，第一个表若没有对应的信息，会以NULL显示： 注意：左右外连接可以省略写OUTER。 示例图如下： 代码如下： 1234567891011121314151617181920$ mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; RIGHT OUTER JOIN classes c -&gt; ON s.class_id = c.id;+------+--------+----------+------------+--------+-------+| id | name | class_id | class_name | gender | score |+------+--------+----------+------------+--------+-------+| 1 | 小明 | 1 | 一班 | M | 90 || 2 | 小红 | 1 | 一班 | F | 95 || 3 | 小军 | 1 | 一班 | M | 88 || 4 | 小米 | 1 | 一班 | F | 73 || 5 | 小白 | 2 | 二班 | F | 81 || 6 | 小兵 | 2 | 二班 | M | 55 || 7 | 小林 | 2 | 二班 | M | 85 || 8 | 小新 | 3 | 三班 | F | 91 || 9 | 小王 | 3 | 三班 | M | 89 || 10 | 小丽 | 3 | 三班 | F | 85 || NULL | NULL | NULL | 四班 | NULL | NULL |+------+--------+----------+------------+--------+-------+11 rows in set (0.01 sec) 3、LEFT OUTER JOIN（左外连接） 尽量满足第一个表的情况，第二个表若没有对应信息，会以NULL显示： 由于students表都可以在classes表匹配，所以添加一行吧唧id为5的，来说明左外连接问题。 示例图如下： 代码如下： 123456789101112131415161718192021222324-- $ mysql&gt; INSERT INTO students (class_id, name, gender, score) values (5, '新生', 'M', 88);Query OK, 1 row affected (0.01 sec)$ mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; LEFT OUTER JOIN classes c -&gt; ON s.class_id = c.id;+----+--------+----------+------------+--------+-------+| id | name | class_id | class_name | gender | score |+----+--------+----------+------------+--------+-------+| 1 | 小明 | 1 | 一班 | M | 90 || 2 | 小红 | 1 | 一班 | F | 95 || 3 | 小军 | 1 | 一班 | M | 88 || 4 | 小米 | 1 | 一班 | F | 73 || 5 | 小白 | 2 | 二班 | F | 81 || 6 | 小兵 | 2 | 二班 | M | 55 || 7 | 小林 | 2 | 二班 | M | 85 || 8 | 小新 | 3 | 三班 | F | 91 || 9 | 小王 | 3 | 三班 | M | 89 || 10 | 小丽 | 3 | 三班 | F | 85 || 11 | 新生 | 5 | NULL | M | 88 |+----+--------+----------+------------+--------+-------+11 rows in set (0.01 sec) 4、FULL OUTER JOIN（全外连接） 也就是左右外连接的并集，没有的信息显示为NULL： MySQL并不支持全连接。。。 示例图如下： 代码如下： 123456$ mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; FULL OUTER JOIN classes c -&gt; ON s.class_id = c.id;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FULL OUTER JOIN classes cON s.class_id = c.id' at line 3 代替解决方案：使用UNION，左连接一次，有连接一次，再使用UNION合并。 代码如下： 123456789101112131415161718192021222324mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; RIGHT OUTER JOIN classes c ON class_id = c.id -&gt; UNION -&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; LEFT OUTER JOIN classes c ON class_id = c.id;+------+--------+----------+------------+--------+-------+| id | name | class_id | class_name | gender | score |+------+--------+----------+------------+--------+-------+| 1 | 小明 | 1 | 一班 | M | 90 || 2 | 小红 | 1 | 一班 | F | 95 || 3 | 小军 | 1 | 一班 | M | 88 || 4 | 小米 | 1 | 一班 | F | 73 || 5 | 小白 | 2 | 二班 | F | 81 || 6 | 小兵 | 2 | 二班 | M | 55 || 7 | 小林 | 2 | 二班 | M | 85 || 8 | 小新 | 3 | 三班 | F | 91 || 9 | 小王 | 3 | 三班 | M | 89 || 10 | 小丽 | 3 | 三班 | F | 85 || NULL | NULL | NULL | 四班 | NULL | NULL || 11 | 新生 | 5 | NULL | M | 88 |+------+--------+----------+------------+--------+-------+12 rows in set (0.00 sec) 数据库教程之查询数据已完成！敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://niuxvdong.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SELECT","slug":"SELECT","permalink":"https://niuxvdong.top/tags/SELECT/"},{"name":"查询","slug":"查询","permalink":"https://niuxvdong.top/tags/%E6%9F%A5%E8%AF%A2/"}],"author":"Mr.Niu"},{"title":"数据库教程之基础知识","slug":"数据库教程之基础知识","date":"2020-05-26T10:39:46.000Z","updated":"2020-05-26T10:39:46.000Z","comments":true,"path":"posts/15411.html","link":"","permalink":"https://niuxvdong.top/posts/15411.html","excerpt":"","text":"一、什么是数据库1、数据库（database） 保存有组织的数据的容器（通常是一个文件或一组文件）。 2、数据库与数据库软件 数据库（database）：数据库可以是保存在硬设备上的文件，但也可以不是。 数据库软件（DBMS数据库管理系统）：数据库是通过DBMS创建和操纵的容器，使用DBMS来替你访问数据库。 3、表 在你将资料放入自己的文件柜时，并不是随便将它们扔进某个抽屉就完事了，而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。 在数据库领域中，这种文件称为表。表是一种结构化的文件，可用来存储某种特定类型的数据。表可以保存顾客清单、产品目录，或者其他信息清单。 表（table）： 某种特定类型数据的结构化清单。 表名 数据库中的每个表都有一个名字，用来标识自己。此名字是唯一的，这表示数据库中没有其他表具有相同的名字。 表名的唯一性取决于多个因素，如数据库名和表名等的结合。这表示，虽然在相同数据库中不能两次使用相同的表名，但在不同的数据库中却可以使用相同的表名。 模式 表具有一些特性，这些特性定义了数据在表中如何存储，如可以存储什么样的数据，数据如何分解，各部分信息如何命名等等。描述表的这组信息就是所谓的模式，模式可以用来描述数据库中特定的表以及整个数据库（和其中表的关系）。 模式（schema）：关于数据库和表的布局及特性的信息。 4、列 表由列组成。列中存储着表中某部分的信息。 列（字段）定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串''。 通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。 列（column） ：表中的一个字段。所有表都是由一个或多个列组成的。 5、数据类型数据类型（datatype）： 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。 6、行 是记录还是行？ 你可能听到用户在提到行（row）时称其为数据库记录（record）。在很大程度上，这两个术语是可以互相替代的，但从技术上说，行才是正确的术语。 行（row）： 表中的一个记录。 7、主键 唯一标识表中每行的这个列（或这组列）称为主键。主键用来表示一个特定的行。没有主键，更新或删除表中特定行很难，因为没有安全的方法保证只涉及相关的行。 关键点：对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 主键（primary key）：一列（或一组列），其值能够唯一区分表中每个行。 7.1 可作为主键的条件： 任意两行都不具有相同的主键值； 每个行都必须具有一个主键值（主键列不允许NULL值）。 注意：主键通常定义在表的一列上，但这并不是必需的，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到构成主键的所有列，所有列值的组合必须是唯一的（但单个列的值可以不唯一）。 7.2 使用主键的好习惯 不更新主键列中的值； 不重用主键列的值； 不在主键列中使用可能会更改的值。 不使用任何业务相关的字段作为主键。（身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。会发生变更！） 7.3 主键id 作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。 对于大部分应用来说，通常自增类型的主键就能满足需求。 如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。 可作为id字段的类型有： 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键； 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。 7.4 联合主键 关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。 没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。 8、外键外键（FOREIGN KEY）：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。 关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。 如下面的表格，class_id就将student表与class表之间形成了关联！ 我们就可以根据class_id这个列直接定位出一个students表的记录应该对应到classes的哪条记录。 外键参考资料，点击这里！ id class_id name other columns… 1 1 小明 … 2 1 小红 … 5 2 小白 … 外键的实现 外键并不是通过列名实现的，而是通过定义外键约束实现的： 外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。 通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。 由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。 1234ALTER TABLE studentsADD CONSTRAINT fk_class_idFOREIGN KEY (class_id)REFERENCES classes (id); 要删除一个外键约束，也是通过ALTER TABLE实现的： 注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的。 12ALTER TABLE studentsDROP FOREIGN KEY fk_class_id; 两种关系 多对多 多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系！ 三个表：teachers表、classes表、teacher_class表（存放teacher ID 与 class ID对应信息） 一对一 一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。 有两个表：students表、contact表（存手机号） 实际上，一对一关系准确地说，是contacts表一对一对应students表。 因为有的学生没有手机号，如果都写道一个students表，会有空出现，写到另一个contact表则不会出现空。 还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度。 9、索引 在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。 索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。 可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。 对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。 使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引有多列直接括号里继续写。 12345ALTER TABLE studentsADD INDEX idx_score (score);ALTER TABLE studentsADD INDEX idx_name_score (name, score); 唯一索引 在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。 但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。 例如name不能重复（通过UNIQUE关键字我们就添加了一个唯一索引。） 12ALTER TABLE studentsADD UNIQUE INDEX uni_name (name); 只对某一列添加一个唯一约束而不创建唯一索引。（name列没有索引，但仍然具有唯一性保证。） 12ALTER TABLE studentsADD CONSTRAINT uni_name UNIQUE (name); 总结：无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。 二、什么是SQL1、什么是SQL 什么是SQL？(Structured Query Language)，SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。 虽然SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为PL/SQL，Microsoft把自己扩展的SQL称为T-SQL。 现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。 2、SQL的优点 SQL不是某个特定数据库供应商专有的语言。几乎所有重要的DBMS都支持SQL，所以，学习此语言使你几乎能与所有数据库打交道。 SQL简单易学。它的语句全都是由描述性很强的英语单词组成，而且这些单词的数目不多。 SQL尽管看上去很简单，但它实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。 3、SQL语言的能力 *DDL：Data Definition Language *：DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。 *DML：Data Manipulation Language *：DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。 *DQL：Data Query Language *：DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。 4、SQL语法特点 SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。 所以，本教程约定：SQL关键字总是大写，以示突出，表名和列名均使用小写。 5、数据模型 数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型： 随着时间的推移和市场竞争，最终，基于关系模型的关系数据库获得了绝对市场份额。 层次模型：层次模型就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树 网状模型：网状模型把每个数据节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网 关系模型：关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，它的数据模型看起来就是一个Excel表 6、数据类型 上面的表中列举了最常用的数据类型。很多数据类型还有别名，例如，REAL又可以写成FLOAT(24)。还有一些不常用的数据类型，例如，TINYINT（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如JSON。 选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，BIGINT能满足整数存储的需求，VARCHAR(N)能满足字符串存储的需求，这两种类型是使用最广泛的。 名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2020-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2020-06-22 12:20:59 7、主流关系数据库 商用数据库，例如：Oracle，SQL Server，DB2等； 开源数据库，例如：MySQL，PostgreSQL等； 桌面数据库，以微软Access为代表，适合桌面应用程序使用； 嵌入式数据库，以Sqlite为代表，适合手机应用和桌面程序。 三、什么是MySQL1、MySQL那些事 MySQL是目前应用最广泛的开源关系数据库。MySQL最早是由瑞典的MySQL AB公司开发，该公司在2008年被SUN公司收购，紧接着，SUN公司在2009年被Oracle公司收购，所以MySQL最终就变成了Oracle旗下的产品。 MySQL是一种DBMS，即它是一种数据库软件。 2、MySQL的优点 成本——MySQL是开放源代码的，一般可以免费使用（甚至可以免费修改）。 性能——MySQL执行很快（非常快）。 可信赖——某些非常重要和声望很高的公司、站点使用MySQL，这些公司和站点都用MySQL来处理自己的重要数据。 简单——MySQL很容易安装和使用。 3、MySQL数据引擎 和其他关系数据库有所不同的是，MySQL本身实际上只是一个SQL接口，它的内部还包含了多种数据引擎！ MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎（IE引擎或Webkit引擎）的关系。对用户而言，切换浏览器引擎不影响浏览器界面，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。 使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择InnoDB就好了。 InnoDB：由Innobase Oy公司开发的一款支持事务的数据库引擎，2006年被Oracle收购； MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。 4、MySQL衍生版本 因为MySQL一开始就是开源的，所以基于MySQL的开源版本，又衍生出了各种版本: MariaDB由MySQL的创始人创建的一个开源分支版本，使用XtraDB引擎。 Aurora由Amazon改进的一个MySQL版本，专门提供给在AWS托管MySQL用户，号称5倍的性能提升。 PolarDB由Alibaba改进的一个MySQL版本，专门提供给在阿里云托管的MySQL用户，号称6倍的性能提升。 MySQL官方版本 以下版本的功能依次递增，价格也依次递增。不过，功能增加的主要是监控、集群等管理功能，对于基本的SQL功能是完全一样的。 Community Edition：社区开源版本，免费； Standard Edition：标准版； Enterprise Edition：企业版； Cluster Carrier Grade Edition：集群版。 5、MySQL版本 4——InnoDB引擎，增加事务处理、并、改进全文本搜索等的支持。 4.1——对函数库、子查询、集成帮助等的重要增加。 5——存储过程、触发器、游标、视图等。 6、安装MySQL 安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。 嗯。。网上找一篇教程安装即可！有时间我再写一下安装教程！ MySQL Client 与 MySQL Server： MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。 在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是127.0.0.1:3306。 123┌──────────────┐ SQL ┌──────────────┐│ MySQL Client │───────&gt;│ MySQL Server │└──────────────┘ TCP └──────────────┘ 7、运行MySQL 管理员身份启动MySQL服务 使用命令登录MySQL 123$ net start mysql$ mysql -u root -pEnter password: ********** 如下图： -u：指定用户名 -p：输入密码 -h：主机名 ，本地默认为localhost，远程服务器为公网ip地址 -P：端口号 8、注意点 命令用;或\\g结束，Enter键不执行操作。 输入help或\\h获得帮助，也可以输入help select获取关于SELECT语句的帮助 输入quit或exit退出命令行程序（并没有关闭mysql服务） 9、管理MySQL数据库相关命令：9.1 列出数据库1$ mysql&gt; SHOW DATABASES; 其中，information_schema、mysql、performance_schema和sys是系统库，不要去改动它们。其他的是用户创建的数据库。 9.2 创建数据库12$ mysql&gt; CREATE DATABASE test;Query OK, 1 row affected (0.01 sec) 9.3 删除数据库12$ mysql&gt; CREATE DATABASE mytest;Query OK, 1 row affected (0.01 sec) 9.4 使用数据库 对一个数据库进行操作时，要首先将其切换为当前数据库： 12$ mysql&gt; USE test;Database changed 表相关命令：9.5 列出表 列出当前数据库的所有表: 1234567$ mysql&gt; SHOW TABLES;+------------------+| Tables_in_mytest |+------------------+| students |+------------------+1 row in set (0.00 sec) 9.6 创建表123456$ mysql&gt; CREATE TABLE students -&gt; ( -&gt; id INT(11), -&gt; name VARCHAR(25) -&gt; );Query OK, 0 rows affected, 1 warning (0.05 sec) 9.7 查看创建表的语句123456789101112$ mysql&gt; SHOW CREATE TABLE students;+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| students | CREATE TABLE `students` ( `id` int DEFAULT NULL, `name` varchar(25) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.01 sec) 9.7 查看表的结构123456789101112$ DESCRIBE &lt;表名&gt;;或$ DESC &lt;表名&gt;;$ mysql&gt; DESC students;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int | YES | | NULL | || name | varchar(25) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.01 sec) 9.8 删除表12$ mysql&gt; DROP TABLE students;Query OK, 0 rows affected (0.03 sec) 9.9 修改表 较为复杂，后续讲解！ 退出MySQL 两种，大小写都可！ 12345$ mysql&gt; EXITBye$ mysql&gt; QUITBye 10、SHOW语句10.1 SHOW TABLES;1234567$ mysql&gt; SHOW TABLES;+------------------+| Tables_in_mytest |+------------------+| students |+------------------+1 row in set (0.00 sec) 10.2 SHOW COLUMNS FROM &lt;表名&gt;; 它对每个字段返回一行，行中包含字段名、数据类型、是否允许 NULL 、键信息、默认值以及其他信息。 DESCRIBE&lt;表名&gt; 语句 SHOW COLUMNS FROM &lt;表名&gt;;的快捷方式！ 简写：DESC &lt;表名&gt; 12345678$ SHOW COLUMNS FROM students;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int | YES | | NULL | || name | varchar(25) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec) 10.3 SHOW STATUS; SHOW STATUS ，用于显示广泛的服务器状态信息。 12$ SHOW STATUS;.... 10.4 SHOW CREATE DATABASE &lt;数据库名&gt;; 显示创建数据库的语句： 12345678$ mysql&gt; SHOW CREATE DATABASE mytest;+----------+----------------------------------------------------------------------------------------------------------------------------------+| Database | Create Database |+----------+----------------------------------------------------------------------------------------------------------------------------------+| mytest | CREATE DATABASE `mytest` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */ |+----------+----------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 10.5 SHOW CREATE TABLE &lt;表名&gt;; 显示创建表的语句： 123456789101112$ mysql&gt; SHOW CREATE TABLE students;+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| students | CREATE TABLE `students` ( `id` int DEFAULT NULL, `name` varchar(25) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 10.6 SHOW GRANTS; 用来显示授予用户（所有用户或特定用户）的安全权限； 12345678910111213141516171819202122mysql&gt; SHOW GRANTS;+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Grants for root@localhost |+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, SHUTDOWN, PROCESS, FILE, REFERENCES, INDEX, ALTER, SHOW DATABASES, SUPER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION SLAVE, REPLICATION CLIENT, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE TABLESPACE, CREATE ROLE, DROP ROLE ON *.* TO `root`@`localhost` WITH GRANT OPTION || GRANT APPLICATION_PASSWORD_ADMIN,AUDIT_ADMIN,BACKUP_ADMIN,BINLOG_ADMIN,BINLOG_ENCRYPTION_ADMIN,CLONE_ADMIN,CONNECTION_ADMIN,ENCRYPTION_KEY_ADMIN,GROUP_REPLICATION_ADMIN,INNODB_REDO_LOG_ARCHIVE,PERSIST_RO_VARIABLES_ADMIN,REPLICATION_APPLIER,REPLICATION_SLAVE_ADMIN,RESOURCE_GROUP_ADMIN,RESOURCE_GROUP_USER,ROLE_ADMIN,SERVICE_CONNECTION_ADMIN,SESSION_VARIABLES_ADMIN,SET_USER_ID,SYSTEM_USER,SYSTEM_VARIABLES_ADMIN,TABLE_ENCRYPTION_ADMIN,XA_RECOVER_ADMIN ON *.* TO `root`@`localhost` WITH GRANT OPTION || GRANT PROXY ON ''@'' TO 'root'@'localhost' WITH GRANT OPTION |+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+3 rows in set (0.00 sec) 10.7 SHOW ERRORS ; 显示服务器错误信息： 12$ mysql&gt; SHOW ERRORS;Empty set (0.00 sec) SHOW WARNINGS; 显示服务器警告信息： 12$ mysql&gt; SHOW WARNINGS;Empty set (0.00 sec) 10.8 HELP SHOW; 用来显示允许SHOW语句的信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061mysql&gt; HELP SHOW;Name: 'SHOW'Description:SHOW has many forms that provide information about databases, tables,columns, or status information about the server. This section describesthose following:SHOW {BINARY | MASTER} LOGSSHOW BINLOG EVENTS [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]SHOW CHARACTER SET [like_or_where]SHOW COLLATION [like_or_where]SHOW [FULL] COLUMNS FROM tbl_name [FROM db_name] [like_or_where]SHOW CREATE DATABASE db_nameSHOW CREATE EVENT event_nameSHOW CREATE FUNCTION func_nameSHOW CREATE PROCEDURE proc_nameSHOW CREATE TABLE tbl_nameSHOW CREATE TRIGGER trigger_nameSHOW CREATE VIEW view_nameSHOW DATABASES [like_or_where]SHOW ENGINE engine_name {STATUS | MUTEX}SHOW [STORAGE] ENGINESSHOW ERRORS [LIMIT [offset,] row_count]SHOW EVENTSSHOW FUNCTION CODE func_nameSHOW FUNCTION STATUS [like_or_where]SHOW GRANTS FOR userSHOW INDEX FROM tbl_name [FROM db_name]SHOW MASTER STATUSSHOW OPEN TABLES [FROM db_name] [like_or_where]SHOW PLUGINSSHOW PROCEDURE CODE proc_nameSHOW PROCEDURE STATUS [like_or_where]SHOW PRIVILEGESSHOW [FULL] PROCESSLISTSHOW PROFILE [types] [FOR QUERY n] [OFFSET n] [LIMIT n]SHOW PROFILESSHOW RELAYLOG EVENTS [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]SHOW SLAVE HOSTSSHOW SLAVE STATUS [FOR CHANNEL channel]SHOW [GLOBAL | SESSION] STATUS [like_or_where]SHOW TABLE STATUS [FROM db_name] [like_or_where]SHOW [FULL] TABLES [FROM db_name] [like_or_where]SHOW TRIGGERS [FROM db_name] [like_or_where]SHOW [GLOBAL | SESSION] VARIABLES [like_or_where]SHOW WARNINGS [LIMIT [offset,] row_count]like_or_where: LIKE 'pattern' | WHERE exprIf the syntax for a given SHOW statement includes a LIKE 'pattern'part, 'pattern' is a string that can contain the SQL % and _ wildcardcharacters. The pattern is useful for restricting statement output tomatching values.Several SHOW statements also accept a WHERE clause that provides moreflexibility in specifying which rows to display. Seehttps://dev.mysql.com/doc/refman/8.0/en/extended-show.html.URL: https://dev.mysql.com/doc/refman/8.0/en/show.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://niuxvdong.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://niuxvdong.top/tags/SQL/"},{"name":"MySQL","slug":"MySQL","permalink":"https://niuxvdong.top/tags/MySQL/"}],"author":"Mr.Niu"},{"title":"Java教程系列之加密与安全","slug":"Java教程系列之加密与安全","date":"2020-04-20T12:12:43.000Z","updated":"2020-04-20T12:12:43.000Z","comments":true,"path":"posts/25096.html","link":"","permalink":"https://niuxvdong.top/posts/25096.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 这一节你一定会懵逼，不过这都是绝对会用到知识，先简单过一遍，用到了再细过一次！点击这里，查看原文！ 看的是真的艰难啊！坚持中！！！ 一、URL编码 URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分。 服务器只识别ASCII字符！ URL编码是编码算法，不是加密算法！（主要用来处理文本如汉字。。） 1、编码规则 如果字符是A ~ Z，a ~ z，0 ~ 9以及-、_、.、*、=，则保持不变； 如果是其他字符，先转换为UTF-8编码，然后对每个字节以%XX表示。都是大写。 例如：字符中的UTF-8编码是0xe4b8ad，因此，它的URL编码是%E4%B8%AD。URL编码总是大写。 2、使用URLEncoder 中的URL编码是%E4%B8%AD，文的URL编码是%E6%96%87，!虽然是ASCII字符，也要对其编码为%21。 URL编码与UTF-8编码相对应。 和标准的URL编码稍有不同，URLEncoder把空格字符编码成+，而现在的URL编码标准要求空格被编码为%20，不过，服务器都可以处理这两种情况。 浏览器加号和%20都可以处理为空格： 123456789101112131415161718package com.org;import java.net.URLDecoder;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;public class EnCode { public static void main(String[] args) { // https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87 // 编码： String encoded = URLEncoder.encode(\"中文!\", StandardCharsets.UTF_8); System.out.println(encoded); // %E4%B8%AD%E6%96%87%21 // 解码： String decoded = URLDecoder.decode(encoded, StandardCharsets.UTF_8); System.out.println(decoded); // 中文! }} 二、Base64编码 URL编码是对字符进行编码，表示成%xx的形式，而Base64编码是对二进制数据进行编码，表示成文本格式。 Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。 Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。（？？？不明白） 和URL编码一样，Base64编码是一种编码算法，不是加密算法。 如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。 1、编码规则将三字节的十六进制表示为二进制0和1，一共24bit，然后每6bit一组，得到四个十进制数：（6bit范围为0-63，可以用64个字符表示：） 字符A ~ Z对应索引0 ~ 25 字符a ~ z对应索引26 ~ 51 字符0 ~ 9对应索引52 ~ 61 最后两个索引62、63分别用字符+和/表示。 2、使用Base64 二进制数据就是byte[]数组。Java标准库提供了Base64来对byte[]数组进行编解码： 编码：3byte转6bit，转化为四个十六进制，将对应的十六进制转化为十进制再去上面的规则中查找，返回四个字符：5Lit 解码：将编码后字符按上面规则转化为十进制再转换为二进制，得到3byte，24bit的0和1，再将其转化为十进制输出，有正负区别：[-28, -72, -83] 123456789101112131415161718package com.org;import java.util.Arrays;import java.util.Base64;public class Base64EnCode { public static void main(String[] args) { // 0xe4b8ad // 编码：(3byte -&gt; 6bit一组进行十六进制转换【39, 0b, 22, 2d】) byte[] input = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad }; String b64encoded = Base64.getEncoder().encodeToString(input); System.out.println(b64encoded); // 5Lit // 解码： byte[] output = Base64.getDecoder().decode(b64encoded); System.out.println(Arrays.toString(output)); // [-28, -72, -83] }} 3、Byte数组长度不为3倍数 每三个元素为一组，不为3的倍数如何处理呢？ 这种情况下，需要对输入的末尾补一个或两个0x00，编码后，在结尾加一个=表示补充了1个0x00，加两个=表示补充了2个0x00，解码的时候，去掉末尾补充的一个或两个0x00即可。 编码后的长度加上=总是4的倍数，所以即使不加=也可以计算出原始输入的byte[]。 对于下方例子：前3byte按6bit一组为5Lit，最后1byte(0x21)，前6bit为I，后两个bit补充4个0，达到六bit，即对应Q。由于不够3倍数，会多加两个0x00，所以最终结果最后会多两个=号，代表加了两个0x00。 使用withoutPadding去除末尾等号！ 解码同样，变为8bit的字节，转化为带符号的十进制输出！ 1234567891011121314151617181920package com.org;import java.util.Arrays;import java.util.Base64;public class Base64EnCode { public static void main(String[] args) { byte[] input1 = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad, (byte) 0x21 }; // 编码： // 有=号： String b64encoded1 = Base64.getEncoder().encodeToString(input1); // 去等于号： String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input1); System.out.println(b64encoded1); // 5LitIQ== System.out.println(b64encoded2); // 5LitIQ // 解码： byte[] output1 = Base64.getDecoder().decode(b64encoded2); System.out.println(Arrays.toString(output1)); // [-28, -72, -83, 33] }} 4、将Base64转化为URL编码 URL编码允许出现的特殊符号：-、_、.、*、= Base64编码允许出现的特殊符号：+、/、=， 标准的Base64编码会出现+、/和=，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把+变成-，/变成_： 1234567891011121314151617package com.org;import java.util.Arrays;import java.util.Base64;public class Base64EnCode { public static void main(String[] args) { byte[] input2 = new byte[] { 0x01, 0x02, 0x7f, 0x00 }; // 针对URL的Base64编码：/ -&gt; _ String b64encoded3 = Base64.getUrlEncoder().encodeToString(input2); System.out.println(b64encoded3); // AQJ_AA== // 解码： byte[] output2 = Base64.getUrlDecoder().decode(b64encoded3); System.out.println(Arrays.toString(output2)); // [1, 2, 127, 0] }} 下面就是加密算法： 三、哈希算法1、哈希算法简介 哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。 哈希算法的目的就是为了验证原始数据是否被篡改。 Java字符串的hashCode()就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节int整数。 同样，有一个哈希冲突问题：（字节组合是有穷的，但输入组合是无穷的，一定会出现冲突。。） 特点： 相同的输入一定得到相同的输出； 不同的输入大概率得到不同的输出。 安全哈希算法条件： 碰撞概率低； 不能猜测输出。 一个hashCode例子： 123456789package com.org;public class HashAlgorithm { public static void main(String[] args) { System.out.println(\"hello\".hashCode()); // 99162322 // 使用Ingeter实现十六进制输出 System.out.println(Integer.toString(\"hello\".hashCode(), 16)); // 5e918d2 }} 2、常见哈希算法 算法 输出长度（位） 输出长度（字节） MD5 128 bits 16 bytes SHA-1 160 bits 20 bytes RipeMD-160 160 bits 20 bytes SHA-256 256 bits 32 bytes SHA-512 512 bits 64 bytes 2.1 MD5 使用MessageDigest时，我们首先根据哈希算法获取一个MessageDigest实例，然后，反复调用update(byte[])输入数据。当输入结束后，调用digest()方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。 123456789101112131415161718package com.org;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;public class HashAlgorithm { public static void main(String[] args) throws Exception { // 创建一个MessageDigest实例: MessageDigest md = MessageDigest.getInstance(\"MD5\"); // 反复调用update输入数据: md.update(\"Hello\".getBytes(StandardCharsets.UTF_8)); md.update(\"World\".getBytes(StandardCharsets.UTF_8)); byte[] result = md.digest(); // 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6 // BigInteger的第一个signum参数表示符号位（1：正数；-1：负数） System.out.println(new BigInteger(1, result).toString(16)); }} 2.2 其他哈希算法 将MessageDigest.getInstance(\"MD5\");的算法模式修改即可！ SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。 注意：MD5因为输出长度较短，短时间内破解是可能的，目前已经不推荐使用。 Java标准库支持的所有哈希算法可以在点击这里查到。 再举一个SHA-512算法： 1234567891011121314151617package com.org;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;public class HashAlgorithm { public static void main(String[] args) throws Exception { // 创建一个MessageDigest实例: MessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // 反复调用update输入数据: md1.update(\"Hello\".getBytes(StandardCharsets.UTF_8)); md1.update(\"World\".getBytes(StandardCharsets.UTF_8)); byte[] result1 = md1.digest(); // 64 bytes: 8ae6ae71a75d3fb2e0225deeb004faf95d816a0a58093eb4cb5a3aa0f197050d7a4dc0a2d5c6fbae5fb5b0d536a0a9e6b686369fa57a027687c3630321547596 System.out.println(new BigInteger(1, result1).toString(16)); }} 3、哈希算法的用途 验证文件完整性及是否篡改 数据库的用户口令密码的安全性和正确性 4、彩虹表 什么是彩虹表呢？上面讲到了，如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。 然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表。 这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因！ 解决方法： 如果用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）： 加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。 1digest = md5(salt+inputPassword) 四、BouncyCastle BouncyCastle就是一个提供了很多哈希算法和加密算法的第三方库。它提供了Java标准库没有的一些算法，例如，RipeMD160哈希算法。 首先，我们必须把BouncyCastle提供的jar包放到classpath中。这个jar包就是bcprov-jdk15on-xxx.jar，可以从官方网站下载。 IDEA下载下来将其移到lib目录下，然后file-&gt;project structure-&gt;dependencies中右边的加号选择导入jre即可！ 使用第三方算法前需要通过Security.addProvider()注册。（Java标准库的java.security包提供了一种标准机制，允许第三方提供商无缝接入。） 123456789101112131415161718192021package com.org;import org.bouncycastle.jce.provider.BouncyCastleProvider;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;import java.security.Security;public class BouncyCastle00 { public static void main(String[] args) throws Exception{ // 注册BouncyCastle: Security.addProvider(new BouncyCastleProvider()); // 按名称正常调用: MessageDigest md = MessageDigest.getInstance(\"RipeMD160\"); md.update(\"HelloWorld\".getBytes(StandardCharsets.UTF_8)); byte[] result = md.digest(); // ecabeaa2eb986c85e6a6ea2c22b248ab6916de35 System.out.println(new BigInteger(1, result).toString(16)); }} 五、Hmac算法 前面讲到哈希算法时，我们说，存储用户的哈希口令时，要加盐(salt)存储，目的就在于抵御彩虹表攻击。 这个salt可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。 Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。 Hmac算法总是和某种哈希算法配合起来用的。 HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加salt，有如下好处： HmacMD5使用的key长度是64字节，更安全； Hmac是标准算法，同样适用于SHA-1等其他哈希算法； Hmac输出和原有的哈希算法长度一致。 可见，Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。 为了保证安全，我们不会自己指定key，而是通过Java标准库的KeyGenerator生成一个安全的随机的key： 1、加密一般步骤： 通过名称HmacMD5获取KeyGenerator实例； 通过KeyGenerator创建一个SecretKey实例； 通过名称HmacMD5获取Mac实例； 用SecretKey初始化Mac实例； 对Mac实例反复调用update(byte[])输入数据； 调用Mac实例的doFinal()获取最终的哈希值。 12345678910111213141516171819202122232425262728package com.org;import javax.crypto.KeyGenerator;import javax.crypto.Mac;import javax.crypto.SecretKey;import java.math.BigInteger;import java.nio.charset.StandardCharsets;public class Hmac00 { public static void main(String[] args) throws Exception{ KeyGenerator keyGen = KeyGenerator.getInstance(\"HmacMD5\"); SecretKey key = keyGen.generateKey(); // 打印随机生成的key:(64byte) byte[] skey = key.getEncoded(); // 9e62a1d17f27ca9cad816dddce959e3d819e47eb1849adc4fb9a95ee8a2720b14aa9a054acf4a6e1c4028354ce322e58b4b787bab06294f737c606ac98ad6c43 System.out.println(new BigInteger(1, skey).toString(16)); Mac mac = Mac.getInstance(\"HmacMD5\"); // 使用随机key加盐： mac.init(key); mac.update(\"HelloWorld\".getBytes(StandardCharsets.UTF_8)); // salt + HelloWorld：转化为字节 byte[] result = mac.doFinal(); // 转化为16进制：(仍然是原长16byte) // cca902c5a59b5d7ac45bd856fcfdea34 System.out.println(new BigInteger(1, result).toString(16)); }} 2、解密 不知道为啥，解密输出和原来并不一样。。。 先放下。。。 12345678910111213141516171819202122232425262728293031323334353637383940package com.org;import javax.crypto.KeyGenerator;import javax.crypto.Mac;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.util.Arrays;public class Hmac00 { public static void main(String[] args) throws Exception{ KeyGenerator keyGen = KeyGenerator.getInstance(\"HmacMD5\"); SecretKey key = keyGen.generateKey(); // 打印随机生成的key: byte[] skey = key.getEncoded(); System.out.println(new BigInteger(1, skey).toString(16)); System.out.println(Arrays.toString(skey)); Mac mac = Mac.getInstance(\"HmacMD5\"); // 使用随机key加盐： mac.init(key); mac.update(\"HelloWorld\".getBytes(StandardCharsets.UTF_8)); // salt + HelloWorld：转化为字节 byte[] result = mac.doFinal(); // 转化为16进制： System.out.println(new BigInteger(1, result).toString(16)); /*解密：*/ SecretKey key1 = new SecretKeySpec(skey, \"HmacMD5\"); Mac mac1 = Mac.getInstance(\"HmacMD5\"); mac1.init(key1); mac1.update(\"HelloWorld\".getBytes(StandardCharsets.UTF_8)); byte[] result1 = mac.doFinal(); System.out.println(Arrays.toString(result1)); System.out.println(new BigInteger(1, result1).toString(16)); }} 六、对称加密算法 对称加密算法就是传统的用一个密码进行加密和解密。例如，我们常用的WinZIP和WinRAR对压缩包的加密和解密，就是使用对称加密算法。 1、常用对称加密算法 密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。Java标准库提供的算法实现并不包括所有的工作模式和所有填充模式，但是通常我们只需要挑选常用的使用就可以了。 最后注意，DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。 算法 密钥长度 工作模式 填充模式 DES 56/64 ECB/CBC/PCBC/CTR/… NoPadding/PKCS5Padding/… AES 128/192/256 ECB/CBC/PCBC/CTR/… NoPadding/PKCS5Padding/PKCS7Padding/… IDEA 128 ECB PKCS5Padding/PKCS7Padding/… 2、使用AES加密 AES算法是目前应用最广泛的加密算法。我们先用ECB模式加密并解密。 这鸡巴有点难搞。。。 一般步骤： 根据算法名称/工作模式/填充模式获取Cipher实例； 根据算法名称初始化一个SecretKey实例，密钥必须是指定长度； 使用SerectKey初始化Cipher实例，并设置加密或解密模式； 传入明文或密文，获得密文或明文。 2.1 ECB模式 ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低！ 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.org;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.util.Base64;public class AES00 { public static void main(String[] args) throws Exception{ // 原文: String message = \"Hello, world!\"; System.out.println(\"Message: \" + message); // 128位密钥 = 16 bytes Key:（必须指定密钥长度） byte[] key = \"1234567890abcdef\".getBytes(StandardCharsets.UTF_8); // 加密: byte[] data = message.getBytes(StandardCharsets.UTF_8); byte[] encrypted = encrypt(key, data); // Encrypted: 2xiGROlFBhC57b7EGu5c3g== System.out.println(\"Encrypted: \" + Base64.getEncoder().encodeToString(encrypted)); // 解密: byte[] decrypted = decrypt(key, encrypted); // Decrypted: Hello, world! System.out.println(\"Decrypted: \" + new String(decrypted, StandardCharsets.UTF_8)); } // 加密: public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); SecretKey keySpec = new SecretKeySpec(key, \"AES\"); cipher.init(Cipher.ENCRYPT_MODE, keySpec); return cipher.doFinal(input); } // 解密: public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); SecretKey keySpec = new SecretKeySpec(key, \"AES\"); cipher.init(Cipher.DECRYPT_MODE, keySpec); return cipher.doFinal(input); }} 2.2 CBC模式 更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同： 在CBC模式下，需要一个随机生成的16字节IV参数，必须使用SecureRandom生成。因为多了一个IvParameterSpec实例，因此，初始化方法需要调用Cipher的一个重载方法并传入IvParameterSpec。 观察输出，可以发现每次生成的IV不同，密文也不同。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.org;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.security.SecureRandom;import java.util.Base64;public class AES_CBC { public static void main(String[] args) throws Exception{ // 原文: String message = \"Hello, world!\"; System.out.println(\"Message: \" + message); // 256位密钥 = 32 bytes Key: byte[] key = \"1234567890abcdef1234567890abcdef\".getBytes(StandardCharsets.UTF_8); // 加密: byte[] data = message.getBytes(StandardCharsets.UTF_8); byte[] encrypted = encrypt(key, data); // Encrypted: DSXvNDWdzvPhMp9nGR0lXfiTE9lPcVbKSw4gWLGpxFU= System.out.println(\"Encrypted: \" + Base64.getEncoder().encodeToString(encrypted)); // 解密: byte[] decrypted = decrypt(key, encrypted); // Decrypted: Hello, world! System.out.println(\"Decrypted: \" + new String(decrypted, StandardCharsets.UTF_8));} // 加密: public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\"); // CBC模式需要生成一个16 bytes的initialization vector: SecureRandom sr = SecureRandom.getInstanceStrong(); byte[] iv = sr.generateSeed(16); IvParameterSpec ivps = new IvParameterSpec(iv); cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps); byte[] data = cipher.doFinal(input); // IV不需要保密，把IV和密文一起返回: return join(iv, data); } // 解密: public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException { // 把input分割成IV和密文: byte[] iv = new byte[16]; byte[] data = new byte[input.length - 16]; System.arraycopy(input, 0, iv, 0, 16); System.arraycopy(input, 16, data, 0, data.length); // 解密: Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\"); IvParameterSpec ivps = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, keySpec, ivps); return cipher.doFinal(data); } public static byte[] join(byte[] bs1, byte[] bs2) { byte[] r = new byte[bs1.length + bs2.length]; System.arraycopy(bs1, 0, r, 0, bs1.length); System.arraycopy(bs2, 0, r, bs1.length, bs2.length); return r; }} 七、口令加密算法 上一节我们讲的AES加密，细心的童鞋可能会发现，密钥长度是固定的128/192/256位，而不是我们用WinZip/WinRAR那样，随便输入几位都可以。 这是因为对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。 但是我们平时使用的加密软件，输入6位、8位都可以，难道加密方式不一样？ 实际上用户输入的口令并不能直接作为AES的密钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。 PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.org;import org.bouncycastle.jce.provider.BouncyCastleProvider;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.PBEKeySpec;import javax.crypto.spec.PBEParameterSpec;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.security.SecureRandom;import java.security.Security;import java.util.Base64;public class PBE00 { public static void main(String[] args) throws Exception { // 把BouncyCastle作为Provider添加到java.security: Security.addProvider(new BouncyCastleProvider()); // 原文: String message = \"Hello, world!\"; // 加密口令: String password = \"hello12345\"; // 16 bytes随机Salt: byte[] salt = SecureRandom.getInstanceStrong().generateSeed(16); // salt: salt: 9ae41dc05680b0fda28be0f1d6454f3a System.out.printf(\"salt: %032x\\n\", new BigInteger(1, salt)); // 加密: byte[] data = message.getBytes(StandardCharsets.UTF_8); byte[] encrypted = encrypt(password, salt, data); // encrypted: MHVOyeWBxGM7RhpN8xy9fA== System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(encrypted)); // 解密: byte[] decrypted = decrypt(password, salt, encrypted); // decrypted: Hello, world! System.out.println(\"decrypted: \" + new String(decrypted, StandardCharsets.UTF_8)); } // 加密: public static byte[] encrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException { PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray()); SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); SecretKey skey = skeyFactory.generateSecret(keySpec); PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000); Cipher cipher = Cipher.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps); return cipher.doFinal(input); } // 解密: public static byte[] decrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException { PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray()); SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); SecretKey skey = skeyFactory.generateSecret(keySpec); PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000); Cipher cipher = Cipher.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); cipher.init(Cipher.DECRYPT_MODE, skey, pbeps); return cipher.doFinal(input); }} 使用PBE时，我们还需要引入BouncyCastle，并指定算法是PBEwithSHA1and128bitAES-CBC-BC。观察代码，实际上真正的AES密钥是调用Cipher的init()方法时同时传入SecretKey和PBEParameterSpec实现的。在创建PBEParameterSpec的时候，我们还指定了循环次数1000，循环次数越多，暴力破解需要的计算量就越大。 如果我们把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，即使用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。 八、密钥交换算法 解决如何传递密钥的问题： 在不安全的信道上传递加密文件是没有问题的，因为黑客拿到加密文件没有用。但是，如何如何在不安全的信道上安全地传输密钥？ 要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。 DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。 我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做： 甲首选选择一个素数p，例如509，底数g，任选，例如5，随机数a，例如123，然后计算A=g^a mod p，结果是215，然后，甲发送p＝509，g=5，A=215给乙； 乙方收到后，也选择一个随机数b，例如，456，然后计算B=g^b mod p，结果是181，乙再同时计算s=A^b mod p，结果是121； 乙把计算的B=181发给甲，甲计算s＝B^a mod p的余数，计算结果与乙算出的结果一样，都是121。 所以最终双方协商出的密钥s是121。注意到这个密钥s并没有在网络上传输。而通过网络传输的p，g，A和B是无法推算出s的，因为实际算法选择的素数是非常大的。 所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。 如果我们把a看成甲的私钥，A看成甲的公钥，b看成乙的私钥，B看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥secretKey，DH算法通过数学定律保证了双方各自计算出的secretKey是相同的。 但是DH算法并未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。消除中间人攻击需要其他方法。 Java实现DH算法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.org;import javax.crypto.KeyAgreement;import java.math.BigInteger;import java.security.*;import java.security.spec.X509EncodedKeySpec;public class DH00 { public static void main(String[] args) {// Bob和Alice: Person bob = new Person(\"Bob\"); Person alice = new Person(\"Alice\"); // 各自生成KeyPair: bob.generateKeyPair(); alice.generateKeyPair(); // 双方交换各自的PublicKey: // Bob根据Alice的PublicKey生成自己的本地密钥: bob.generateSecretKey(alice.publicKey.getEncoded()); // Alice根据Bob的PublicKey生成自己的本地密钥: alice.generateSecretKey(bob.publicKey.getEncoded()); // 检查双方的本地密钥是否相同: bob.printKeys(); alice.printKeys(); // 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密... }}class Person { public final String name; public PublicKey publicKey; private PrivateKey privateKey; private byte[] secretKey; public Person(String name) { this.name = name; } // 生成本地KeyPair: public void generateKeyPair() { try { KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"DH\"); kpGen.initialize(512); KeyPair kp = kpGen.generateKeyPair(); this.privateKey = kp.getPrivate(); this.publicKey = kp.getPublic(); } catch (GeneralSecurityException e) { throw new RuntimeException(e); } } public void generateSecretKey(byte[] receivedPubKeyBytes) { try { // 从byte[]恢复PublicKey: X509EncodedKeySpec keySpec = new X509EncodedKeySpec(receivedPubKeyBytes); KeyFactory kf = KeyFactory.getInstance(\"DH\"); PublicKey receivedPublicKey = kf.generatePublic(keySpec); // 生成本地密钥: KeyAgreement keyAgreement = KeyAgreement.getInstance(\"DH\"); keyAgreement.init(this.privateKey); // 自己的PrivateKey keyAgreement.doPhase(receivedPublicKey, true); // 对方的PublicKey // 生成SecretKey密钥: this.secretKey = keyAgreement.generateSecret(); } catch (GeneralSecurityException e) { throw new RuntimeException(e); } } public void printKeys() { System.out.printf(\"Name: %s\\n\", this.name); System.out.printf(\"Private key: %x\\n\", new BigInteger(1, this.privateKey.getEncoded())); System.out.printf(\"Public key: %x\\n\", new BigInteger(1, this.publicKey.getEncoded())); System.out.printf(\"Secret key: %x\\n\", new BigInteger(1, this.secretKey)); }} 运行结果：（Secret key是相同的） 12345678Name: BobPrivate key: 3081d202010030819706092a864886f70d010301308189024100fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e170240678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca40202018004330231009b3e8e2cd56ae4b0501da4eeb6c2813370b5a3a73e8a1d9ccbbd6e30f27c1f1aa05d68d20da4bba167a8d141203b4d26Public key: 3081e030819706092a864886f70d010301308189024100fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e170240678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca4020201800344000241009b3b7b8ae229ff5f082b725d7f2f4f94c5cd61063e621776012d4a995df4f3ef8df2cadba6e2c54f1e639b7fa51ff84d3fbe74dd2bf55ec2f72cc7cf2a58947bSecret key: 2e516324b72d75e81da0e9c4d328d9401478a07baf667a87e39e3d7c841c892af27d1cddf4a41767a78a2799a2bbb5f3a08988c5c59f6c058cd84d3e790b9bc5Name: AlicePrivate key: 3081d202010030819706092a864886f70d010301308189024100fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e170240678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca4020201800433023100b5b2212c1d074a75eab86290b58d275252e062305ccc25a4b81e5cf96f41e053d15b8718b07cc414a2c0b800253d8df5Public key: 3081df30819706092a864886f70d010301308189024100fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e170240678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca40202018003430002404585b6c895f58eab57a3028f73d62beda35bea505b1a1ae11faafcc7c3054b61e5c4455d09fb1fd6c817147cb7ca9895620ced591183aa88d70a3fbf4b124213Secret key: 2e516324b72d75e81da0e9c4d328d9401478a07baf667a87e39e3d7c841c892af27d1cddf4a41767a78a2799a2bbb5f3a08988c5c59f6c058cd84d3e790b9bc5 九、非对称加密算法 从DH算法我们可以看到，公钥-私钥组成的密钥对是非常有用的加密方式，因为公钥是可以公开的，而私钥是完全保密的，由此奠定了非对称加密的基础。 非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。 因此，如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。 非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。 非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要N*(N-1)/2个密钥，因此每个人需要管理N-1个密钥，密钥管理难度大，而且非常容易泄漏。 既然非对称加密这么好，那我们抛弃对称加密，完全使用非对称加密行不行？也不行。因为非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多。 所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后： 小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红； 小红用自己的RSA私钥解密得到AES口令； 双方使用这个共享的AES口令用AES加密通信。 可见非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。 RSA算法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.org;import javax.crypto.Cipher;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.*;public class RSA00 { public static void main(String[] args) throws Exception { // 明文: byte[] plain = \"Hello, encrypt use RSA\".getBytes(StandardCharsets.UTF_8); // 创建公钥／私钥对: Person1 alice = new Person1(\"Alice\"); // 用Alice的公钥加密: byte[] pk = alice.getPublicKey(); System.out.println(String.format(\"public key: %x\", new BigInteger(1, pk))); byte[] encrypted = alice.encrypt(plain); System.out.println(String.format(\"encrypted: %x\", new BigInteger(1, encrypted))); // 用Alice的私钥解密: byte[] sk = alice.getPrivateKey(); System.out.println(String.format(\"private key: %x\", new BigInteger(1, sk))); byte[] decrypted = alice.decrypt(encrypted); System.out.println(new String(decrypted, StandardCharsets.UTF_8)); }}class Person1 { String name; // 私钥: PrivateKey sk; // 公钥: PublicKey pk; public Person1(String name) throws GeneralSecurityException { this.name = name; // 生成公钥／私钥对: KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"RSA\"); kpGen.initialize(1024); KeyPair kp = kpGen.generateKeyPair(); this.sk = kp.getPrivate(); this.pk = kp.getPublic(); } // 把私钥导出为字节 public byte[] getPrivateKey() { return this.sk.getEncoded(); } // 把公钥导出为字节 public byte[] getPublicKey() { return this.pk.getEncoded(); } // 用公钥加密: public byte[] encrypt(byte[] message) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(Cipher.ENCRYPT_MODE, this.pk); return cipher.doFinal(message); } // 用私钥解密: public byte[] decrypt(byte[] input) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(Cipher.DECRYPT_MODE, this.sk); return cipher.doFinal(input); }} 输出结果： 1234public key: 30819f300d06092a864886f70d010101050003818d003081890281810089411cd2ceb3f44d43641d265de1ba63f752eccf739f4e33e8e4c111ce261ba378729d354797afe6991d5e530c849f42390d0ed098a47b51dd130a1f7303b2ee04f589e9f1ca78d8167c8949e619653f6361f05dec81c44427dbd21ab088ad55790eafb7afedcd03472b57cc7d1aba30656db06210b97dba15c649962df42b5b0203010001encrypted: 7762b626f22c8671049c6114dbe070f551f9a444a11c0e8e9e41a1ff270d2d4515fa0be12c51df055a1ba71cc5360a4646b35498caf69381a959f7e272ede890d7d8d0422e063570116396e2f9bdc2f705c2f6bbc88bc5bdd110026bcbd008d93235a9d27093cfe238b1110115bd2d6d606f44b271152c3f423799fb5ffdda13private key: 30820275020100300d06092a864886f70d01010105000482025f3082025b0201000281810089411cd2ceb3f44d43641d265de1ba63f752eccf739f4e33e8e4c111ce261ba378729d354797afe6991d5e530c849f42390d0ed098a47b51dd130a1f7303b2ee04f589e9f1ca78d8167c8949e619653f6361f05dec81c44427dbd21ab088ad55790eafb7afedcd03472b57cc7d1aba30656db06210b97dba15c649962df42b5b0203010001028180653eb19b533c6d4e7d12a16a06c096b45ce13fabfb771cc1afdee608534fcafd77c0dbf44c5e3933d9e84f06e5ea026c601720c180877c2c33ee727e2662291ecc0cdc56c5144b47f312cf9021c97dc6adfa9573476a99fd27666f252affe3016699d4a9e739bf7aa8d08525f64b8e9f22bdd33bae5d23125145000219e01a49024100eda89fa24ac30b6b65db6592ba570f228cbfa4a656ccbb13cd8fd2f174e3d4dbc26789aad8c5c0e56e2415e807ff00e957183a3c4de14e6d51d7ed7539f90e9f02410093d8d1ec2e6302d5ea315673b1a44ac4d00f94f5b653fa5b84ff2137eeb8a7f0d3bc0b122f274aa8d4eb08595a6524116e91abe0d0e0e4bf5d019775799b35c50240606ab4b8c6d3f26213e4ba84988c915b56f6b8f9b2e5445078690d0f6078bdf69a1c1f41ecc7edc626b5051e29804f025b8f3cb1127781b5e02a55efe52121c9024019754b6884f04dabb220fec6fb3ed41521d29d0ed66f8d7bb6e20bc14add072623ff8c547c4422ca01a7db0f2fce9cb057bec3bef998d02ad7840fa58de419150240790e8dadbfd8adc0ce6b1eebf1c03d450adcae72e686ac8d9ecc71ce32a34e12ac768cb882ece363ea2f8d6236394ac30187b345d55eb4e42597a7114406ff09Hello, encrypt use RSA RSA的公钥和私钥都可以通过getEncoded()方法获得以byte[]表示的二进制数据，并根据需要保存到文件中。要从byte[]数组恢复公钥或私钥，可以这么写： 以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。 如果修改待加密的byte[]数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。 此外，只使用非对称加密算法不能防止中间人攻击。 123456789byte[] pkData = ...byte[] skData = ...KeyFactory kf = KeyFactory.getInstance(\"RSA\");// 恢复公钥:X509EncodedKeySpec pkSpec = new X509EncodedKeySpec(pkData);PublicKey pk = kf.generatePublic(pkSpec);// 恢复私钥:PKCS8EncodedKeySpec skSpec = new PKCS8EncodedKeySpec(skData);PrivateKey sk = kf.generatePrivate(skSpec); 十、签名算法 我们使用非对称加密算法的时候，对于一个公钥-私钥对，通常是用公钥加密，私钥解密。 如果使用私钥加密，公钥解密是否可行呢？实际上是完全可行的。 不过我们再仔细想一想，私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密。这个加密有什么意义？ 这个加密的意义在于，如果小明用自己的私钥加密了一条消息，比如小明喜欢小红，然后他公开了加密消息，由于任何人都可以用小明的公钥解密，从而使得任何人都可以确认小明喜欢小红这条消息肯定是小明发出的，其他人不能伪造这个消息，小明也不能抵赖这条消息不是自己写的。 因此，私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。 在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名。 对签名进行验证实际上就是用公钥解密。 然后把解密后的哈希与原始消息的哈希进行对比。 因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。 常用签名算法1.1 RSA签名 实际上就是指定某种哈希算法进行RSA签名的方式 MD5withRSA SHA1withRSA SHA256withRSA 使用其他公钥，或者验证签名的时候修改原始信息，都无法验证成功。 123456789101112131415161718192021222324252627282930313233package com.org;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.*;public class QianMing { public static void main(String[] args) throws Exception{ // 生成RSA公钥/私钥: KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"RSA\"); kpGen.initialize(1024); KeyPair kp = kpGen.generateKeyPair(); PrivateKey sk = kp.getPrivate(); PublicKey pk = kp.getPublic(); // 待签名的消息: byte[] message = \"Hello, I am Bob!\".getBytes(StandardCharsets.UTF_8); // 用私钥签名: Signature s = Signature.getInstance(\"SHA1withRSA\"); s.initSign(sk); s.update(message); byte[] signed = s.sign(); System.out.println(String.format(\"signature: %x\", new BigInteger(1, signed))); // 用公钥验证: Signature v = Signature.getInstance(\"SHA1withRSA\"); v.initVerify(pk); v.update(message); boolean valid = v.verify(signed); System.out.println(\"valid? \" + valid); }} 输出结果： 12signature: 7ce04446376358e2de5b5f299c780385f2e436154f6ad03df846fe4ec14f7de8d1a4acdade4a0951f99c02f4305c6ddb1327321ac4086737690b2bf2b9297050cba1a30451c989ef1512ec453625e289525e492ab707ec110b2928c13faa154b1ebd21f001cb0c61a273a8c74ac51ee6a2bdef5161a05f4e1997b364f5dfc889valid? true 1.2 DSA签名 除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。 和RSA数字签名相比，DSA的优点是更快。 DSA只能配合SHA使用，常用的算法有： SHA1withDSA SHA256withDSA SHA512withDSA 1.3 ECDSA签名 椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。 十一、数字证书 我们知道，摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。 因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。 数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。 我们在上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性。 要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用自签名的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。 在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。我们用下面的命令创建一个key store，并设定口令123456： 1$ keytool -storepass 123456 -genkeypair -keyalg RSA -keysize 1024 -sigalg SHA1withRSA -validity 3650 -alias mycert -keystore my.keystore -dname \"CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN\" 几个主要的参数是： keyalg：指定RSA加密算法； sigalg：指定SHA1withRSA签名算法； validity：指定证书有效期3650天； alias：指定证书在程序中引用的名称； dname：最重要的CN=www.sample.com指定了Common Name，如果证书用在HTTPS中，这个名称必须与域名完全一致。 执行上述命令，JDK会在当前目录创建一个my.keystore文件，并存储创建成功的一个私钥和一个证书，它的别名是mycert。 通过数字证书进行加解密和签名： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.org;import com.sun.tools.javac.Main;import javax.crypto.Cipher;import java.io.InputStream;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.security.KeyStore;import java.security.PrivateKey;import java.security.Signature;import java.security.cert.X509Certificate;public class NumberZhengShu { public static void main(String[] args) throws Exception { byte[] message = \"Hello, use X.509 cert!\".getBytes(StandardCharsets.UTF_8); // 读取KeyStore: KeyStore ks = loadKeyStore(\"my.keystore\", \"123456\"); // 读取私钥: PrivateKey privateKey = (PrivateKey) ks.getKey(\"mycert\", \"123456\".toCharArray()); // 读取证书: X509Certificate certificate = (X509Certificate) ks.getCertificate(\"mycert\"); // 加密: byte[] encrypted = encrypt(certificate, message); System.out.println(String.format(\"encrypted: %x\", new BigInteger(1, encrypted))); // 解密: byte[] decrypted = decrypt(privateKey, encrypted); System.out.println(\"decrypted: \" + new String(decrypted, StandardCharsets.UTF_8)); // 签名: byte[] sign = sign(privateKey, certificate, message); System.out.println(String.format(\"signature: %x\", new BigInteger(1, sign))); // 验证签名: boolean verified = verify(certificate, message, sign); System.out.println(\"verify: \" + verified); } static KeyStore loadKeyStore(String keyStoreFile, String password) { try (InputStream input = NumberZhengShu.class.getResourceAsStream(keyStoreFile)) { if (input == null) { throw new RuntimeException(\"file not found in classpath: \" + keyStoreFile); } KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType()); ks.load(input, password.toCharArray()); return ks; } catch (Exception e) { throw new RuntimeException(e); } } static byte[] encrypt(X509Certificate certificate, byte[] message) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(certificate.getPublicKey().getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, certificate.getPublicKey()); return cipher.doFinal(message); } static byte[] decrypt(PrivateKey privateKey, byte[] data) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateKey); return cipher.doFinal(data); } static byte[] sign(PrivateKey privateKey, X509Certificate certificate, byte[] message) throws GeneralSecurityException { Signature signature = Signature.getInstance(certificate.getSigAlgName()); signature.initSign(privateKey); signature.update(message); return signature.sign(); } static boolean verify(X509Certificate certificate, byte[] message, byte[] sig) throws GeneralSecurityException { Signature signature = Signature.getInstance(certificate.getSigAlgName()); signature.initVerify(certificate); signature.update(message); return signature.verify(sig); }} 输出结果： 1234encrypted: 7f88754e3e31ab5f6aa80d6a2f4610095bc0057b05fab78e5e9e14839103e8648d219a9bb43189d4896b5c5f95c82a85c94e242b6afdc54303650ce7513fa5877e3adb91afb38cbf036e419ade2406ea563bf7a7520454b689ea81281fdc999b58550178403094b44df047c188918b2743b98c5e46f7bcc8f50c3aa2bd8fb11cdecrypted: Hello, use X.509 cert!signature: 1d13d65d2a8928ccb6639f5d325f77e4b211b5cb3a120f6a182a05c4ddedde29cc8a3af1ee02473015514a8b65e743f6f58997aa5f00e464a68136f8b680682af5107bda5d4de925f3699f7d7327fee21c4b9e5c90641b91a6cb8be93a6f008006eb4052749a6cffa43a7e4749e4afc55293097baebc5a72e3a05b21dbba8a34verify: true 在上述代码中，我们从key store直接读取了私钥-公钥对，私钥以PrivateKey实例表示，公钥以X509Certificate表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。 以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下： 浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书； 浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器； 服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。 上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。 注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商DigiNotar就发生过私钥泄漏导致公司破产的事故。 这艰难的一节终于简单过了一遍，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"加密","slug":"加密","permalink":"https://niuxvdong.top/tags/%E5%8A%A0%E5%AF%86/"},{"name":"安全","slug":"安全","permalink":"https://niuxvdong.top/tags/%E5%AE%89%E5%85%A8/"}],"author":"Mr.Niu"},{"title":"Java教程系列之正则表达式","slug":"Java教程系列之正则表达式","date":"2020-04-18T10:06:42.000Z","updated":"2020-04-18T10:06:42.000Z","comments":true,"path":"posts/53926.html","link":"","permalink":"https://niuxvdong.top/posts/53926.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 由于学JavaScript时就已经学过了正则的规则，所以本文只介绍与其不同支出，大概的一个框架及用法！ 一、正则匹配规则 \\d ：一个数字 \\D：一个非数字 \\w ：一个数字或一个字母（大小写） \\W：与\\w相对。。。匹配其不能匹配的 \\s ：一个空格 \\S：与\\s相对，匹配其不能匹配的 \\u548c：匹配一个指定Unicode字符 . ：一个任意字符 \\. ：一个小数点 * ：任意个（包括0个） + ：至少一个 ？ ：0个或1个 {n,}：至少n个 {n} ：n个 {n, m} ：n 到 m 个 \\- ：一个- \\\\ ：一个\\ [abc]：匹配其中一个 [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串 [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就JavaScript允许的变量名 [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符） [^0-9]：不匹配数字，匹配其他任意字符一个 A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 ()：相当于提取公因式。。 ^和$写在正则表达式前后可以精确控制字符串，保证开头和结尾的规则，在JavaScript中，js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了；而在Java中，js不可以匹配'jsp'。 二、Java中使用String正则不同之处 Java没有专门的正则对象，所以用String字符串来表示一个正则表达式： 这样就会使得与正则表达式不一样了： 格式：标准正则 - - - - - - - -&gt; Java中字符串表示的正则 \\d -&gt; \\\\d \\\\ -&gt; \\\\\\\\ \\- -&gt; - \\_ -&gt; _ \\$ -&gt; $ \\\" -&gt; \\\" \\' -&gt; ' / -&gt; / 总结：java中的特殊字符可以直接用，双引号特殊得用斜杠转义： 标准正则两个斜杠代表一个斜杠，Java字符串则是四个斜杠代表一个斜杠，即前两个转义为1个，后两个转义为1个，前面再将后面的转义为斜杠。。。 大概就是这些。。。 1234567891011121314package com.org;public class Regex01 { public static void main(String[] args) { // /\\d\\\\\\-\\_\\$\\\"\\' String re = \"/\\\\d\\\\\\\\-_&amp;\\\"'\"; System.out.println(\"/3\\\\-_&amp;\\\"'\".matches(re));// true String re1 = \"[^1-9]*\"; System.out.println(\"h)fkd-+d\".matches(re1)); // true // 与JavaScript不同，特别的地方。。 String re3 = \"js\"; System.out.println(\"jsp\".matches(re3)); // false JavaScript可以匹配。。。 }} 三、分组匹配（引入regex包） ()的一个重要作用，用来分组： 使用String.matches()方法只能判断，要想获得匹配子串需要使用regex包的对象。 还有：Java的正则匹配和JavaScript有点不一样：（参考第一小节最后的内容！） 引入java.util.regex包，用Pattern对象匹配，匹配后获得一个Matcher对象，如果匹配成功，就可以直接从Matcher.group(index)返回子串： 下标为0返回原串，下标为1以后的则返回匹配的字串！ 1、一个例子123456789101112131415161718package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex02 { public static void main(String[] args) { Pattern p = Pattern.compile(\"(\\\\d{3,4})-(\\\\d{7,8})\"); Matcher m = p.matcher(\"010-12345678\"); if (m.matches()) { System.out.println(m.group(0)); // 010-12345678 System.out.println(m.group(1)); // 010 System.out.println(m.group(2)); // 12345678 } else { System.out.println(\"匹配失败!\"); } }} 2、Pattern 使用String和regex包，实际上这两种代码本质上是一样的，因为String.matches()方法内部调用的就是Pattern和Matcher类的方法。 反复使用String.matches()对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的Pattern对象。 完全可以先创建出一个Pattern对象，然后反复使用，就可以实现编译一次，多次匹配： 使用Matcher时，必须首先调用matches()判断是否匹配成功，匹配成功后，才能调用group()提取子串。 代码见上面例子： 四、贪婪匹配1、贪婪匹配 看下方例子，这就是贪婪匹配，\\d+将后面的所有数字都给匹配了，所以0*就无法匹配了！ 贪婪匹配：任何一个规则，它总是尽可能多地向后匹配，因此，\\d+总是会把后面的0包含进来。 123456789101112131415package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex04 { public static void main(String[] args) { Pattern pattern = Pattern.compile(\"(\\\\d+)(0*)\"); Matcher matcher = pattern.matcher(\"1230000\"); if (matcher.matches()) { System.out.println(matcher.group(1)); // \"1230000\" System.out.println(matcher.group(2)); // \"\" } }} 2、解决方法：（非贪婪匹配） 使用?，使其尽可能先去满足后面的规则，完事了在满足自己规则； 123456789101112131415package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex04 { public static void main(String[] args) { Pattern pattern = Pattern.compile(\"(\\\\d+?)(0*)\"); Matcher matcher = pattern.matcher(\"1230000\"); if (matcher.matches()) { System.out.println(matcher.group(1)); // \"123\" System.out.println(matcher.group(2)); // \"0000\" } }} 3、?? 连续两个问号：(针对没有+*的时候使用) 第一个：表示基础意思，匹配0个或1个。。 第二个：非贪婪匹配 只有一个问号：（+*符号后面） 默认就是：非贪婪匹配 只有一个问号：（没有+*符号） 默认就是：表示基础意思，匹配0个或1个。。 123456789101112131415package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex04 { public static void main(String[] args) { Pattern pattern = Pattern.compile(\"(\\\\d??)(0*)\"); Matcher matcher = pattern.matcher(\"10000\"); if (matcher.matches()) { System.out.println(matcher.group(1)); // \"1\" System.out.println(matcher.group(2)); // \"0000\" } }} 五、分割 使用split()方法，返回一个String数组。 1、使用Pattern的split方法12345678910111213package com.org;import java.util.regex.Pattern;public class Regex05 { public static void main(String[] args) { Pattern pattern = Pattern.compile(\"[\\s,\\\\\\\\*;]+\"); String[] str = pattern.split(\"2 ;;,43\\\\ 5* ,7\"); for (String s : str) { System.out.print(s + \" \"); // 2 43 5 7 } }} 2、使用String 的split方法 直接使用String的split方法更简单！ 1234567891011package com.org;public class Regex06 { public static void main(String[] args) { String[] str = \"2 ;;,43\\\\ 5* ,7\".split(\"[\\s,\\\\\\\\*;]+\"); for (String s : str) { System.out.print(s + \" \"); //2 43 5 7 } }} 六、搜索和替换1、搜索 使用Matcher.find()判断有没有匹配子串了。 使用Matcher.start()和Matcher.end()方法返回子串的起始下标位置，类似于迭代器，找完一个找下一个，直到找完。Matcher.find()方法也是，找过一个就不回去找了，直到找不到返回false！ 使用String.substring()来切割输出！ 12345678910111213141516package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex07 { public static void main(String[] args) { String s = \"the quick brown fox jumps over the lazy dog.\"; Pattern p = Pattern.compile(\"\\\\wo\\\\w\"); Matcher m = p.matcher(s); while (m.find()) { String sub = s.substring(m.start(), m.end()); System.out.println(sub); // row fox dog } }} 2、替换 使用正则表达式替换字符串可以直接调用String.replaceAll()，它的第一个参数是正则表达式，第二个参数是待替换的字符串： 如下例子：将多个空格替换为一个空格 123456789package com.org;public class Regex08 { public static void main(String[] args) { String s = \"The quick\\t\\t brown fox jumps over the lazy dog.\"; String r = s.replaceAll(\"\\\\s+\", \" \"); System.out.println(r); // \"The quick brown fox jumps over the lazy dog.\" }} 3、反向引用 第二个参数可以使用$1、$2来反向引用匹配到的子串。 $1指的是前面括号的一组内容，$2只第二个括号的内容，以此类推。。 一个例子：将四字母单词加上&lt;b&gt;&lt;/b&gt;，即HTML的加粗标签！ 即([a-z]{4})替换了$1。 123456789package com.org;public class Regex08 { public static void main(String[] args) { String ss = \"the quick brown fox jumps over the lazy dog.\"; String rr = ss.replaceAll(\"\\\\s([a-z]{4})\\\\s\", \" &lt;b&gt;$1&lt;/b&gt; \"); System.out.println(rr); // the quick brown fox jumps &lt;b&gt;over&lt;/b&gt; the &lt;b&gt;lazy&lt;/b&gt; dog. }} 正则表达式已完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Regex","slug":"Regex","permalink":"https://niuxvdong.top/tags/Regex/"}],"author":"Mr.Niu"},{"title":"Java教程系列之单元测试","slug":"Java教程系列之单元测试","date":"2020-04-16T10:05:18.000Z","updated":"2020-04-16T10:05:18.000Z","comments":true,"path":"posts/44270.html","link":"","permalink":"https://niuxvdong.top/posts/44270.html","excerpt":"","text":"一、编写Junit测试 单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。 实现测试与主程序分离，实现打印测试结果，可编写通用测试代码！ 1、Junit JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试。 使用JUnit编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。 JUnit目前最新版本是5。 2、步骤： 首先在src同级下建立test目录 设置为测试专用文件夹，右键test目录找到Mark Directory as 选择子选项的Test Sources Root 回到src，找到需要测试的方法，右键选择Go To的子选项Test，出现的选项中点击Creat new Test 后面用到的Junit等相关库，Idea会自动去导包，并加入classpath! 写好主程序和测试程序后，去测试程序运行即可： 3、编写举例 核心测试方法testFact()加上了@Test注解，这是JUnit要求的，它会把带有@Test的方法识别为测试方法。 习惯上将Test文件的名字命名为需测试类名+Test.java： eg：主程序：Factory.java 测试程序：FactoryTest.java 以计算阶乘的方法为例： 测试成功情况：Factory： 1234567891011package com.org;public class Factory { public static long fact(long n) { long r = 1; for (long i = 1; i &lt;= n; i++) { r = r * i; } return r; }} FactoryTest： 1234567891011121314151617package com.org;import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.*;public class FactoryTest { @Test void fact() { assertEquals(1, Factory.fact(1)); assertEquals(2, Factory.fact(2)); assertEquals(6, Factory.fact(3)); assertEquals(3628800, Factory.fact(10)); assertEquals(2432902008176640000L, Factory.fact(20)); }} 没有问题不会输出东西： 1Process finished with exit code 0 测试失败情况： 将测试程序认为改一下： assertEquals(1, Factory.fact(1)) -&gt; assertEquals(2, Factory.fact(1))： 输出结果： 会显示不一致的地方： 123456789org.opentest4j.AssertionFailedError: Expected :2Actual :1&lt;Click to see difference&gt; at org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:55) at org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:195) at ..... 浮点数的处理 由于浮点数运算会有误差，所以需要设置一个误差值来限定： 使用assertEquals()的重载方法，第三个参数指定误差范围即可： 1234567891011121314151617package com.org;import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.*;public class Double01Test { @Test void calc() { //assertEquals(0.1, Math.abs(1 - 9 / 10.0)); // 0.09999999999999998 assertEquals(0.1, Math.abs(1 - 9 / 10.0), 0.000001); assertEquals(0.2, Math.abs(1 - 8 / 10.0), 0.000001); //assertEquals(0.1, Math.abs(1 - 0.9)); // 0.09999999999999998 assertEquals(0.1, Math.abs(1 - 0.9), 0.0000001); }} 4、Assertion（断言） 在测试方法内部，我们用assertEquals(1, Factorial.fact(1))表示，期望Factorial.fact(1)返回1。assertEquals(expected, actual)是最常用的测试方法，它在Assertion类中定义。 在异常处理一节第六点提到过断言，点击这里！ Assertion还定义了其他断言方法，例如： assertTrue(): 期待结果为true assertFalse(): 期待结果为false assertNotNull(): 期待结果为非null assertArrayEquals(): 期待结果为数组并与期望数组每个元素的值均相等 … 5、单元测试总结 单元测试可以确保单个方法按照正确预期运行，如果修改了某个方法的代码，只需确保其对应的单元测试通过，即可认为改动正确。此外，测试代码本身就可以作为示例代码，用来演示如何调用该方法。 使用JUnit进行单元测试，我们可以使用断言（Assertion）来测试期望结果，可以方便地组织和运行测试，并方便地查看测试结果。此外，JUnit既可以直接在IDE中运行，也可以方便地集成到Maven这些自动化工具中运行。 在编写单元测试的时候，我们要遵循一定的规范： 一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试； 二是每个单元测试应当互相独立，不依赖运行的顺序； 三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为0，null，空字符串\"\"等情况。 二、使用Fixture 在一个单元测试中，我们经常编写多个@Test方法，来分组、分类对目标代码进行测试。 在测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个@Test方法都写一遍这样的重复代码，显然比较麻烦。 JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。 1、@BeforeEach 和 @AfterEach 在CalculatorTest测试中，有两个标记为@BeforeEach和@AfterEach的方法，它们会在运行每个@Test方法前后自动运行： 通过@BeforeEach来初始化，通过@AfterEach来清理资源： 试了一下，不用Fixture，也可以正常测试成功，所以我觉得Java默认是有这两个方法在每个test方法前后去执行的，不过自己加上更加明显，修改之类的都可以更加方便，所以还是自己写上为好：（Idea可以在go to 后直接选择添加，并不需要手写：） 举一个例子： Calculator类： 123456789101112131415package com.org;public class Calculator { private long n = 0; public long add(long x) { n = n + x; return n; } public long sub(long x) { n = n - x; return n; }} CalculatorTest类： 123456789101112131415161718192021222324252627282930313233343536package com.org;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.*;public class CalculatorTest { Calculator calculator; @BeforeEach void setUp() { this.calculator = new Calculator(); } @AfterEach void tearDown() { this.calculator = null; } @Test void add() { assertEquals(100, this.calculator.add(100)); assertEquals(150, this.calculator.add(50)); assertEquals(130, this.calculator.add(-20)); } @Test void sub() { assertEquals(-100, this.calculator.sub(100)); assertEquals(-150, this.calculator.sub(50)); assertEquals(-130, this.calculator.sub(-20)); }} 2、@BeforeAll 和 @AfterAll 它们在运行所有@Test前后运行： 因为@BeforeAll和@AfterAll在所有@Test方法运行前后仅运行一次，因此，它们只能初始化静态方法的静态变量： 有一些资源初始化和清理可能更加繁琐，而且会耗费较长的时间：（例如初始化数据库） 一般不会用到这两个！ 不举例子了，点击这里： 3、小结 大多数情况下，使用@BeforeEach和@AfterEach就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到@BeforeAll和@AfterAll。 注意到每次运行一个@Test方法前，JUnit首先创建一个XxxTest实例，因此，每个@Test方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个@Test方法带到另一个@Test方法。 这样说来就解释了第一点不使用Fixture仍然可以测试成功的原因： 对于实例变量，在@BeforeEach中初始化，在@AfterEach中清理，它们在各个@Test方法中互不影响，因为是不同的实例； 对于静态变量，在@BeforeAll中初始化，在@AfterAll中清理，它们在各个@Test方法中均是唯一实例，会影响各个@Test方法。 三、异常测试 在Java程序中，异常处理是非常重要的。 我们自己编写的方法，也经常抛出各种异常。对于可能抛出的异常进行测试，本身就是测试的重要环节。 因此，在编写JUnit测试的时候，除了正常的输入输出，我们还要特别针对可能导致异常的情况进行测试： 还是以Factory()方法举例： Factory类： 在方法入口，我们增加了对参数n的检查，如果为负数，则直接抛出IllegalArgumentException。 1234567891011121314package com.org;public class Factory { public static long fact(long n) { if(n &lt; 0){ throw new IllegalArgumentException(); } long r = 1; for (long i = 1; i &lt;= n; i++) { r = r * i; } return r; }} FactoryTest类： 我们希望对异常进行测试。在JUnit测试中，我们可以编写一个@Test方法专门测试异常testNegative()方法： JUnit提供assertThrows()来期望捕获一个指定的异常。第二个参数Executable封装了我们要执行的会产生异常的代码。当我们执行Factorial.fact(-1)时，必定抛出IllegalArgumentException。assertThrows()在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。 编写一个Executable的匿名类实在是太繁琐了。实际上，Java 8开始引入了函数式编程，所有单方法接口都可以简写如下testNegative1()方法： 1234567891011121314151617181920212223242526272829303132333435package com.org;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.function.Executable;import static org.junit.jupiter.api.Assertions.*;public class FactoryTest { @Test void fact() { assertEquals(1, Factory.fact(1)); assertEquals(2, Factory.fact(2)); assertEquals(6, Factory.fact(3)); assertEquals(3628800, Factory.fact(10)); assertEquals(2432902008176640000L, Factory.fact(20)); } // 普通写法： @Test void testNegative(){ assertThrows(IllegalArgumentException.class, new Executable() { @Override public void execute() throws Throwable { Factory.fact(-1); } }); } // 使用函数式编程简化： @Test void testNegative1(){ assertThrows(IllegalArgumentException.class, ()-&gt;{Factory.fact(-1);}); }} 四、条件测试 简单来说就是控制@test在什么条件下才执行： 在@test后面再加一些条件注解： 一些常用的条件注解： @Disabled(“bug-101”)：此测试不会执行，括号参数可选，为输出提示信息。 @EnabledOnOs(OS.WINDOWS)：在什么系统测试。 @DisabledOnOs(OS.WINDOWS)：不在什么系统测试。 @DisabledOnJre(JRE.JAVA_8)：不在Java8test。 @EnabledIfSystemProperty(named = “os.arch”, matches = “.64.“)：只能在六十四位系统测试。 @EnabledIfEnvironmentVariable(named = “DEBUG”, matches = “true”)：需要传入环境变量DEBUG=true才能执行的测试，即控制台里面传入该参数才可以。 @EnabledIf(“java.time.LocalDate.now().getDayOfWeek()==java.time.DayOfWeek.SUNDAY”)：万能判断语句，当前是星期日才会执行测试。 万能的@EnableIf可以执行任意Java语句并根据返回的boolean决定是否执行测试。 Config类： 1234567891011121314package com.org;public class Config { public String getConfigFile(String filename) { String os = System.getProperty(\"os.name\").toLowerCase(); if (os.contains(\"win\")) { return \"C:\\\\\" + filename; } if (os.contains(\"mac\") || os.contains(\"linux\") || os.contains(\"unix\")) { return \"/usr/local/\" + filename; } throw new UnsupportedOperationException(); }} ConfigTest类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.org;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.condition.*;import static org.junit.jupiter.api.Assertions.assertEquals;public class ConfigTest { Config config; @BeforeEach public void setUp() { this.config = new Config(); } @Test @EnabledOnOs(OS.WINDOWS) void testWindows() { assertEquals(\"C:\\\\test.ini\", config.getConfigFile(\"test.ini\")); } @Test @EnabledOnOs({ OS.LINUX, OS.MAC }) void testLinuxAndMac() { assertEquals(\"/usr/local/test.cfg\", config.getConfigFile(\"test.cfg\")); } @Test @Disabled(\"bug-101\") void testBug101() { // TODO: this test is disabled for bug fixing } @Test @DisabledOnOs(OS.WINDOWS) void testOnNonWindowsOs() { // TODO: this test is disabled on windows } @Test @DisabledOnJre(JRE.JAVA_8) void testOnJava9OrAbove() { // TODO: this test is disabled on java 8 } @Test @EnabledIfSystemProperty(named = \"os.arch\", matches = \".*64.*\") void testOnlyOn64bitSystem() { // TODO: this test is only run on 64 bit system } @Test @EnabledIfEnvironmentVariable(named = \"DEBUG\", matches = \"true\") void testOnlyOnDebugMode() { // TODO: this test is only run on DEBUG=true } @Test @EnabledIf(\"java.time.LocalDate.now().getDayOfWeek()==java.time.DayOfWeek.SUNDAY\") void testOnlyOnSunday() { // TODO: this test is only run on Sunday }} 测试输出结果及提示信息： 1234567891011Environment variable [DEBUG] does not existWarning: Nashorn engine is planned to be removed from a future JDK releaseScript `java.time.LocalDate.now().getDayOfWeek()==java.time.DayOfWeek.SUNDAY` evaluated to: falsebug-101Disabled on operating system: Windows 10Disabled on operating system: Windows 10 五、参数化测试 如果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法 参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。 JUnit提供了一个@ParameterizedTest注解，用来进行参数化测试。 与之前的测试不同，不再使用@test了！ 以下方例子进行测试：将字符串转化为第一个字母大写，后面小写的形式： 12345678910package com.org;public class ArgumentsN { public static String capitalize(String s) { if (s.length() == 0) { return s; } return Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase(); }} 1、使用@MethodSource 编写一个同名的静态方法来提供测试参数： 返回一个List&lt;Arguments&gt;，方法内使用Arguments.arguments()方法，指定输入和输出参数。 如果静态方法和测试方法的名称不同，@MethodSource也允许指定方法名。但使用默认同名方法最方便。 12345678910111213141516171819202122232425262728293031323334353637383940package com.org;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.Arguments;import org.junit.jupiter.params.provider.CsvFileSource;import org.junit.jupiter.params.provider.MethodSource;import java.util.List;import static org.junit.jupiter.api.Assertions.assertEquals;public class ArgumentsNTest { @ParameterizedTest @MethodSource void testCapitalize(String input, String result) { assertEquals(result, ArgumentsN.capitalize(input)); } static List&lt;Arguments&gt; testCapitalize() { return List.of( // arguments: Arguments.arguments(\"abc\", \"Abc\"), // Arguments.arguments(\"APPLE\", \"Apple\"), // Arguments.arguments(\"gooD\", \"Good\")); } // 静态方法名字不一致时：指定静态方法名：（一般不这样写） @ParameterizedTest @MethodSource(\"testCapitalize1\") void testCapitalize(String input, String result) { assertEquals(result, ArgumentsN.capitalize(input)); } static List&lt;Arguments&gt; testCapitalize1() { return List.of( // arguments: Arguments.arguments(\"abc\", \"Abc\"), // Arguments.arguments(\"APPLE\", \"Apple\"), // Arguments.arguments(\"gooD\", \"Good\")); }} 2、使用@CsvSource 它的每一个字符串表示一行，一行包含的若干参数用,分隔，如下： 12345678910111213141516171819package com.org;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.Arguments;import org.junit.jupiter.params.provider.CsvFileSource;import org.junit.jupiter.params.provider.MethodSource;import java.util.List;import static org.junit.jupiter.api.Assertions.assertEquals;public class ArgumentsNTest { @ParameterizedTest @CsvSource({ \"abc, Abc\", \"APPLE, Apple\", \"gooD, Good\" }) void testCapitalize(String input, String result) { assertEquals(result, ArgumentsN.capitalize(input)); }} 3、使用@CsvFileSource 如果有成百上千的测试输入，那么，直接写@CsvSource就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上@CsvFileSource：(使用参数指定csv的路径名) JUnit只在classpath中查找指定的CSV文件，因此，test-capitalize.csv这个文件要放到test目录下：（Idea可以写好路径，快捷进行创建文件：） CSV文件的内容：（逗号分隔，一行一个） 1234apple, AppleHELLO, HelloJUnit, JunitreSource, Resource 12345678910111213141516171819package com.org;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.Arguments;import org.junit.jupiter.params.provider.CsvFileSource;import org.junit.jupiter.params.provider.MethodSource;import java.util.List;import static org.junit.jupiter.api.Assertions.assertEquals;public class ArgumentsNTest { @ParameterizedTest @CsvFileSource(resources = { \"/test-capitalize.csv\" }) void testCapitalizeUsingCsvFile(String input, String result) { assertEquals(result, ArgumentsN.capitalize(input)); }} 单元测试一节已然完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JUnit","slug":"JUnit","permalink":"https://niuxvdong.top/tags/JUnit/"}],"author":"Mr.Niu"},{"title":"Java教程系列之日期与时间","slug":"Java教程系列之日期与时间","date":"2020-04-13T08:26:06.000Z","updated":"2020-04-13T08:26:06.000Z","comments":true,"path":"posts/51490.html","link":"","permalink":"https://niuxvdong.top/posts/51490.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、一些概念1、本地时间 当我们说当前时刻是2019年11月20日早上8:15的时候，我们说的实际上是本地时间。在国内就是北京时间。在这个时刻，如果地球上不同地方的人们同时看一眼手表，他们各自的本地时间是不同的！ 所以，不同的时区，在同一时刻，本地时间是不同的。全球一共分为24个时区，伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区！ eg：2020-1-1 20:21:59 2、时区 光靠本地时间还无法唯一确定一个准确的时刻，所以我们还需要给本地时间加上一个时区： 以GMT或者UTC加时区偏移表示，例如：GMT+08:00或者UTC+08:00表示东八区。（GMT和UTC可以认为基本是等价的，只是UTC使用更精确的原子钟计时，每隔几年会有一个闰秒，我们在开发程序的时候可以忽略两者的误差，因为计算机的时钟在联网的时候会自动与时间服务器同步时间。） 另一种是缩写，例如，CST表示China Standard Time，也就是中国标准时间。但是CST也可以表示美国中部时间Central Standard Time USA，因此，缩写容易产生混淆，我们尽量不要使用缩写。 最后一种是以洲／城市表示，例如，Asia/Shanghai，表示上海所在地的时区。特别注意城市名称不是任意的城市，而是由国际标准组织规定的城市。 3、夏令时 所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。我们国家实行过一段时间夏令时，1992年就废除了，但是矫情的美国人到现在还在使用，所以时间换算更加复杂。 实行夏令时的不同地区，进入和退出夏令时的时间很可能是不同的。同一个地区，根据历史上是否实行过夏令时，标准时间在不同年份换算成当地时间也是不同的。因此，计算夏令时，没有统一的公式，必须按照一组给定的规则来算，并且，该规则要定期更新。 计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。 时区 2019-11-20 2019-6-20 GMT-05:00 19:00 19:00 UTC-05:00 19:00 19:00 America/New_York 19:00 20:00 4、本地化 在计算机中，通常使用Locale表示一个国家或地区的日期、时间、数字、货币等格式。Locale由语言_国家的字母缩写构成，例如，zh_CN表示中文+中国，en_US表示英文+美国。语言使用小写，国家使用大写。 计算机用Locale在日期、时间、货币和字符串之间进行转换！ 对于日期来说，不同的Locale，例如，中国和美国的表示方式如下： zh_CN：2016-11-30 en_US：11/30/2016 二、Date和Calendar1、Epoch Time Epoch Time是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数！ Epoch Time又称为时间戳！ 1231574208900 = 北京时间2019-11-20 8:15:00 = 伦敦时间2019-11-20 0:15:00 = 纽约时间2019-11-19 19:15:00 因此，在计算机中，只需要存储一个整数1574208900表示某一时刻。当需要显示为某一地区的当地时间时，我们就把它格式化为一个字符串 时间戳在不同的编程语言中，会有几种存储方式： 以秒为单位的整数：1574208900，缺点是精度只能到秒； 以毫秒为单位的整数：1574208900123，最后3位表示毫秒数； 以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。 它们之间转换非常简单。而在Java程序中，时间戳通常是用long表示的毫秒数 1long t = 1574208900123L; 转换成北京时间就是2019-11-20T8:15:00.123。要获取当前时间戳，可以使用System.currentTimeMillis()，这是Java程序获取时间戳最常用的方法。 2、标准库APIJava标准库有两套处理日期和时间的API： 一套定义在java.util这个包里面，主要包括Date、Calendar和TimeZone这几个类； 一套新的API是在Java 8引入的，定义在java.time这个包里面，主要包括LocalDateTime、ZonedDateTime、ZoneId等。 为什么会有新旧两套API呢？因为历史遗留原因，旧的API存在很多问题，所以引入了新的API。 那么我们能不能跳过旧的API直接用新的API呢？如果涉及到遗留代码就不行，因为很多遗留代码仍然使用旧的API，所以目前仍然需要对旧的API有一定了解，很多时候还需要在新旧两种对象之间进行转换。 3、Date Date对象有几个严重的问题：它不能转换时区，除了toGMTString()可以按GMT+0:00输出外，Date总是以当前计算机系统的默认时区为基础进行输出。此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。 java.util.Date是用于表示一个日期和时间的对象，注意与java.sql.Date区分，后者用在数据库中。如果观察Date的源码，可以发现它实际上存储了一个long类型的以毫秒表示的时间戳： 123456public class Date implements Serializable, Cloneable, Comparable&lt;Date&gt; { private transient long fastTime; ...} 常用方法： 注意getYear()返回的年份必须加上1900，getMonth()返回的月份是011分别表示112月，所以要加1，而getDate()返回的日期范围是1~31，又不能加1。 1234567891011121314151617181920212223package com.learn.file;import java.util.Date;public class DateTest { public static void main(String[] args) { // 获取当前时间戳： long time = System.currentTimeMillis(); System.out.println(time); // 1586770437800 最后三位表示毫秒数，即0.xxx秒 // 获取当前时间: Date date = new Date(); System.out.println(date.getYear() + 1900); // 必须加上1900 System.out.println(date.getMonth() + 1); // 0~11，必须加上1 System.out.println(date.getDate()); // 1~31，不能加1 // 转换为String: 输出为CST格式（即China Standard Time缩写） System.out.println(date.toString()); // Mon Apr 13 17:43:12 CST 2020 // 转换为GMT时区: System.out.println(date.toGMTString()); // 13 Apr 2020 09:43:12 GMT // 转换为本地时区: System.out.println(date.toLocaleString()); // 2020年4月13日 下午5:43:12 }} 使用SimpleDateFormat进行格式化有如下格式： yyyy：年 MM：月 dd: 日 HH: 小时 mm: 分钟 ss: 秒 E: 周几 123456789101112package com.learn.file;import java.text.SimpleDateFormat;import java.util.Date;public class DateTest { public static void main(String[] args) { Date date1 = new Date(); var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(sdf.format(date1)); // 2020-04-13 17:48:42 }} Java的格式化预定义了许多不同的格式，我们以MMM和E为例： M：输出9 MM：输出09 MMM：输出Sep MMMM：输出September 12345678910111213141516171819package com.learn.file;import java.text.SimpleDateFormat;import java.util.Date;public class DateTest { public static void main(String[] args) { Date date2 = new Date(); var sdf2 = new SimpleDateFormat(\"E M dd, yyyy\"); var sdf3 = new SimpleDateFormat(\"E MM dd, yyyy\"); var sdf4 = new SimpleDateFormat(\"E MMM dd, yyyy\"); var sdf5 = new SimpleDateFormat(\"E MMMM dd, yyyy\"); System.out.println(sdf2.format(date2)); //周一 4 13, 2020 System.out.println(sdf3.format(date2)); //周一 04 13, 2020 System.out.println(sdf4.format(date2)); //周一 4月 13, 2020 System.out.println(sdf5.format(date2)); //周一 四月 13, 2020 }} 4、Calendar Calendar可以用于获取并设置年、月、日、时、分、秒，它和Date比，主要多了一个可以做简单的日期和时间运算的功能。 Calendar获取年月日这些信息变成了get(int field)，返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，1~7分别表示周日，周一，……，周六。 Calendar只有一种方式获取，即Calendar.getInstance()： 1234567891011121314151617181920package com.learn.file;import java.util.Calendar;public class CalendarTest { public static void main(String[] args) { // 获取当前时间: Calendar c = Calendar.getInstance(); int y = c.get(Calendar.YEAR); int m = 1 + c.get(Calendar.MONTH); int d = c.get(Calendar.DAY_OF_MONTH); int w = c.get(Calendar.DAY_OF_WEEK); int hh = c.get(Calendar.HOUR_OF_DAY); int mm = c.get(Calendar.MINUTE); int ss = c.get(Calendar.SECOND); int ms = c.get(Calendar.MILLISECOND); System.out.println(y + \"-\" + m + \"-\" + d + \" \" + w + \" \" + hh + \":\" + mm + \":\" + ss + \".\" + ms); // 2020-4-13 2 18:1:7.601 }} 设置成特定的一个日期和时间 必须先清除所有字段： 利用Calendar.getTime()可以将一个Calendar对象转换成Date对象，然后就可以用SimpleDateFormat进行格式化了。 1234567891011121314151617181920212223242526package com.learn.file;import java.text.SimpleDateFormat;import java.util.Calendar;public class CalendarTest { public static void main(String[] args) { // 获取当前时间: Calendar c = Calendar.getInstance(); // 清除所有: c.clear(); // 设置2020年: c.set(Calendar.YEAR, 2020); // 设置4月:注意3表示4月: c.set(Calendar.MONTH, 3); // 设置2日: c.set(Calendar.DATE, 13); // 设置时间: c.set(Calendar.HOUR_OF_DAY, 18); c.set(Calendar.MINUTE, 20); c.set(Calendar.SECOND, 23); // 使用getTime转化为Date对象，再使用SimpleDateFormat格式化输出： System.out.println(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(c.getTime())); // 2019-09-02 21:22:23 }} 5、TimeZone Calendar和Date相比，它提供了时区转换的功能。时区用TimeZone对象表示 1234567891011121314package com.learn.file;import java.util.TimeZone;public class TimeZoneTest { public static void main(String[] args) { TimeZone tzDefault = TimeZone.getDefault(); // 当前时区 TimeZone tzGMT9 = TimeZone.getTimeZone(\"GMT+09:00\"); // GMT+9:00时区 TimeZone tzNY = TimeZone.getTimeZone(\"America/New_York\"); // 纽约时区 System.out.println(tzDefault.getID()); // Asia/Shanghai System.out.println(tzGMT9.getID()); // GMT+09:00 System.out.println(tzNY.getID()); // America/New_York }} 时区的唯一标识是以字符串表示的ID，我们获取指定TimeZone对象也是以这个ID为参数获取，GMT+09:00、Asia/Shanghai都是有效的时区ID。 可使用TimeZone.getAvailableIDs()方法来列出系统支持的所有时区ID： 1System.out.println(Arrays.toString(TimeZone.getAvailableIDs())); 对指定时间进行转换利用Calendar进行时区转换的步骤是： 清除所有字段； 设定指定时区； 设定日期和时间； 创建SimpleDateFormat并设定目标时区； 格式化获取的Date对象（注意Date对象无时区信息，时区信息存储在SimpleDateFormat中）。 本质上时区转换只能通过SimpleDateFormat在显示的时候完成 将北京时间转换为纽约时间： 1234567891011121314151617181920212223242526272829package com.learn.file;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.TimeZone;public class TimeZoneTest { public static void main(String[] args) { // 当前时间: Calendar c = Calendar.getInstance(); // 清除所有: c.clear(); // 设置为北京时区: c.setTimeZone(TimeZone.getTimeZone(\"Asia/Shanghai\")); // 设置年月日时分秒: c.set(2020, 3 /* 4月 */, 13, 18, 15, 0); // 或者这样： c.set(2020, Calendar.APRIL /* 11月 */, 13, 18, 15, 0); // 显示时间: System.out.println(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(c.getTime())); // 2020-04-13 18:15:00 var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); sdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\")); System.out.println(sdf.format(c.getTime())); // 2020-04-13 06:15:00 }} 对日期和时间进行简单加减123456789101112131415161718192021222324package com.learn.file;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.TimeZone;public class TimeZoneTest { public static void main(String[] args) { // 当前时间: Calendar c1 = Calendar.getInstance(); // 清除所有: c1.clear(); // 设置年月日时分秒: c1.set(2020, 3 /* 4月 */, 13, 18, 15, 0); var sdf1 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(sdf1.format(c1.getTime())); // 2020-04-13 18:15:00 // 加5天并减去2小时: c1.add(Calendar.DAY_OF_MONTH, 5); c1.add(Calendar.HOUR_OF_DAY, -2); // 显示时间: System.out.println(sdf1.format(c1.getTime())); // 2020-04-18 16:15:00 }} 三、LocalDateTime 从Java 8开始，java.time包提供了新的日期和时间API： 和旧的API相比，新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便。 此外，新API修正了旧API不合理的常量设计： Month的范围用1~12表示1月到12月； Week的范围用1~7表示周一到周日。 最后，新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。 LocalDateTime无法与时间戳进行转换，因为LocalDateTime没有时区，无法确定某一时刻。后面我们要介绍的ZonedDateTime相当于LocalDateTime加时区的组合，它具有时区，可以与long表示的时间戳进行转换。 主要涉及的类型有： 本地日期和时间：LocalDateTime，LocalDate，LocalTime； 带时区的日期和时间：ZonedDateTime； 时刻：Instant； 时区：ZoneId，ZoneOffset； 时间间隔：Duration。 以及一套新的用于取代SimpleDateFormat的格式化类型DateTimeFormatter。 1、LocalDateTime 本地日期和时间通过now()获取到的总是以当前默认时区返回的，和旧API不同，LocalDateTime、LocalDate和LocalTime默认严格按照ISO 8601规定的日期和时间格式进行打印。 LocalTime的精度是纳秒！ 12345678910111213141516package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;public class LocalDateTimeTest { public static void main(String[] args) { LocalDate d = LocalDate.now(); // 当前日期 LocalTime t = LocalTime.now(); // 当前时间 LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间 System.out.println(d); // 严格按照ISO 8601格式打印 2020-04-13 System.out.println(t); // 严格按照ISO 8601格式打印 19:34:03.468952 System.out.println(dt); // 严格按照ISO 8601格式打印 2020-04-13T19:34:03.468952 }} LocalDate和LocalTime与LocalDateTime互转 下面代码其实有一个小问题，在获取3个类型的时候，由于执行一行代码总会消耗一点时间，因此，3个类型的日期和时间很可能对不上（时间的毫秒数基本上不同）。为了保证获取到同一时刻的日期和时间，可以改写如下： 123456789101112131415161718192021package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;public class LocalDateTimeTest { public static void main(String[] args) { // LocalDateTime -&gt; LocalDate/LocalTime LocalDateTime dt1 = LocalDateTime.now(); // 当前日期和时间 LocalDate d1 = dt1.toLocalDate(); // 转换到当前日期 LocalTime t1 = dt1.toLocalTime(); // 转换到当前时间 // // LocalDate/LocalTime -&gt; LocalDateTime // 指定日期和时间: LocalDate d2 = LocalDate.of(2019, 11, 30); // 2019-11-30, 注意11=11月 LocalTime t2 = LocalTime.of(15, 16, 17); // 15:16:17 LocalDateTime dt2 = LocalDateTime.of(2019, 11, 30, 15, 16, 17); LocalDateTime dt3 = LocalDateTime.of(d2, t2); }} 字符串转换为LocalDateTime12345678910111213package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;public class LocalDateTimeTest { public static void main(String[] args) { LocalDateTime dt4 = LocalDateTime.parse(\"2019-11-19T15:16:17\"); LocalDate d4 = LocalDate.parse(\"2019-11-19\"); LocalTime t4 = LocalTime.parse(\"15:16:17\"); }} 日期和时间之间的 ‘T’注意ISO 8601规定的日期和时间分隔符是T。标准格式如下： 日期：yyyy-MM-dd 时间：HH:mm:ss 带毫秒的时间：HH:mm:ss.SSS 日期和时间：yyyy-MM-dd’T’HH:mm:ss 带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS 2、DateTimeFormatter 自定义输出的格式，或者要把一个非ISO 8601格式的字符串解析成LocalDateTime： 123456789101112131415161718package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;public class LocalDateTimeTest { public static void main(String[] args) { // 自定义格式化: DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\"); System.out.println(dtf.format(LocalDateTime.now())); // 用自定义格式解析: LocalDateTime dt5 = LocalDateTime.parse(\"2019/11/30 15:16:17\", dtf); System.out.println(dt5); // 2019-11-30T15:16:17 }} 3、对日期和时间进行简单加减 注意到月份加减会自动调整日期，例如从2019-10-31减去1个月得到的结果是2019-09-30，因为9月没有31日： 12345678910111213141516171819package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;public class LocalDateTimeTest { public static void main(String[] args) { LocalDateTime dt6 = LocalDateTime.of(2019, 10, 26, 20, 30, 59); System.out.println(dt6); // 2019-10-26T20:30:59 // 加5天减3小时: LocalDateTime dt7 = dt6.plusDays(5).minusHours(3); System.out.println(dt7); // 2019-10-31T17:30:59 // 减1月: LocalDateTime dt8 = dt7.minusMonths(1); System.out.println(dt8); // 2019-09-30T17:30:59 }} 4、对日期和时间进行调整常用方法： 调整年：withYear() 调整月：withMonth() 调整日：withDayOfMonth() 调整时：withHour() 调整分：withMinute() 调整秒：withSecond() 同样注意到调整月份时，会相应地调整日期，即把2019-10-31的月份调整为9时，日期也自动变为30。 12345678910111213141516171819package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;public class LocalDateTimeTest { public static void main(String[] args) { LocalDateTime dt9 = LocalDateTime.of(2019, 10, 26, 20, 30, 59); System.out.println(dt9); // 2019-10-26T20:30:59 // 日期变为31日: LocalDateTime dt10 = dt9.withDayOfMonth(31); System.out.println(dt2); // 2019-10-31T20:30:59 // 月份变为9: LocalDateTime dt11 = dt10.withMonth(9); System.out.println(dt11); // 2019-09-30T20:30:59 }} 5、使用with()方法做更复杂的运算 对于计算某个月第1个周日这样的问题，新的API可以轻松完成。 基本就是first和last的组合吧！ 1234567891011121314151617181920212223242526package com.learn.file;import java.time.DayOfWeek;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.temporal.TemporalAdjusters;public class LocalTest { public static void main(String[] args) { // 本月第一天0:00时刻: LocalDateTime firstDay = LocalDate.now().withDayOfMonth(1).atStartOfDay(); System.out.println(firstDay); // 2020-04-01T00:00 // 本月最后1天: LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth()); System.out.println(lastDay); // 2020-04-30 // 下月第1天: LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth()); System.out.println(nextMonthFirstDay); // 2020-05-01 // 本月第1个周一: LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)); System.out.println(firstWeekday); // 2020-04-06 }} 6、判断时间先后 要判断两个LocalDateTime的先后，可以使用isBefore()、isAfter()方法，对于LocalDate和LocalTime类似： 1234567891011121314151617package com.learn.file;import java.time.DayOfWeek;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.temporal.TemporalAdjusters;public class LocalTest { public static void main(String[] args) { LocalDateTime now = LocalDateTime.now(); LocalDateTime target = LocalDateTime.of(2019, 11, 19, 8, 15, 0); System.out.println(now.isBefore(target)); // false System.out.println(LocalDate.now().isBefore(LocalDate.of(2019, 11, 19))); // false System.out.println(LocalTime.now().isAfter(LocalTime.parse(\"08:15:00\"))); // true }} 6、Duration和Period Duration表示两个时刻之间的时间间隔。 另一个类似的Period表示两个日期之间的天数： Duration和Period的表示方法也符合ISO 8601的格式，它以P...T...的形式表示，P...T之间表示日期间隔，T后面表示时间间隔。如果是PT...的格式表示仅有时间间隔： 123456789101112131415161718package com.learn;import java.time.Duration;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.Period;public class DurationAndPeriod { public static void main(String[] args) { LocalDateTime start = LocalDateTime.of(2019, 11, 19, 8, 15, 0); LocalDateTime end = LocalDateTime.of(2020, 1, 9, 19, 25, 30); Duration d = Duration.between(start, end); System.out.println(d); // PT1235H10M30S 表示1235小时10分钟30秒 Period p = LocalDate.of(2019, 11, 19).until(LocalDate.of(2020, 1, 9)); System.out.println(p); // P1M21D 表示1个月21天 }} 利用ofXxx()或者parse()方法也可以直接创建Duration： 1234567891011121314package com.learn;import java.time.Duration;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.Period;public class DurationAndPeriod { public static void main(String[] args) { Duration d1 = Duration.ofHours(10); // 10 hours Duration d2 = Duration.parse(\"P1DT2H3M\"); // 1 day, 2 hours, 3 minutes }} 四、ZonedDateTime LocalDateTime总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要ZonedDateTime。 可以简单地把ZonedDateTime理解成LocalDateTime加ZoneId。ZoneId是java.time引入的新的时区类，注意和旧的java.util.TimeZone区别。 1、创建ZonedDateTime对象1.1 一种是通过now()方法返回当前时间： 下面时区不同，但表示的时间都是同一时刻（毫秒数不同是执行语句时的时间差）： 时间相不同，时区不同，时刻相同： 12345678910111213package com.learn.file;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区 ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(\"America/New_York\")); // 用指定时区获取当前时间 System.out.println(zbj); // 2020-04-13T20:49:45.964482300+08:00[Asia/Shanghai] System.out.println(zny); // 2020-04-13T08:49:45.971487100-04:00[America/New_York] }} 1.2 通过给一个LocalDateTime附加一个ZoneId 以这种方式创建的ZonedDateTime，它的日期和时间与LocalDateTime相同，但附加的时区不同，因此是两个不同的时刻： 时间相同，时区不同，时刻不同： 123456789101112131415package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { LocalDateTime ldt = LocalDateTime.of(2019, 9, 15, 15, 16, 17); ZonedDateTime zbj1 = ldt.atZone(ZoneId.systemDefault()); ZonedDateTime zny1 = ldt.atZone(ZoneId.of(\"America/New_York\")); System.out.println(zbj1); // 2019-09-15T15:16:17+08:00[Asia/Shanghai] System.out.println(zny1); // 2019-09-15T15:16:17-04:00[America/New_York] }} 2、时区转换 通过withZoneSameInstant()将关联时区转换到另一个时区，转换后日期和时间都会相应调整： 时刻相同，时间改变，日期改变，时区改变： 12345678910111213141516package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { // 以中国时区获取当前时间: ZonedDateTime zbj2 = ZonedDateTime.now(ZoneId.of(\"Asia/Shanghai\")); // 转换为纽约时间: ZonedDateTime zny2 = zbj2.withZoneSameInstant(ZoneId.of(\"America/New_York\")); System.out.println(zbj2); // 2020-04-13T20:58:58.227352600+08:00[Asia/Shanghai] System.out.println(zny2); // 2020-04-13T08:58:58.227352600-04:00[America/New_York] }} 3、夏令时处理 时区转换的时候，由于夏令时的存在，不同的日期转换的结果很可能是不同的。 涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。 如下：有一个小时的夏令时时差： 123452019-09-15T21:05:50.187697+08:00[Asia/Shanghai]2019-09-15T09:05:50.187697-04:00[America/New_York]2019-11-15T21:05:50.187697+08:00[Asia/Shanghai]2019-11-15T08:05:50.187697-05:00[America/New_York] 使用ZonedDateTime处理 将一个未知时区转换为本地时间，转换为本地时间时，内部使用的就是ZonedDateTime的时区信息： 1234567891011121314package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(\"America/New_York\")); LocalDateTime ldt1 = zdt.toLocalDateTime(); System.out.println(zdt); // 2020-04-13T09:15:56.939055400-04:00[America/New_York] System.out.println(ldt1); // 2020-04-13T09:15:56.939055400 }} 4、对日期和时间进行简单加减 ZonedDateTime仍然提供了plusDays()等加减操作。 12345678910111213package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { ZonedDateTime zdt1 = ZonedDateTime.now(); System.out.println(zdt1); // 2020-04-13T21:21:24.013394800+08:00[Asia/Shanghai] System.out.println(zdt1.plusDays(5).minusHours(3)); // 2020-04-18T18:21:24.013394800+08:00[Asia/Shanghai] }} 5、一个时间转换例子 某航线从北京飞到纽约需要13小时20分钟，请根据北京起飞日期和时间计算到达纽约的当地日期和时间。 123456789101112131415161718192021222324252627282930313233343536package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { // 一个例子： LocalDateTime departureAtBeijing = LocalDateTime.of(2019, 9, 15, 13, 0, 0); int hours = 13; int minutes = 20; LocalDateTime arrivalAtNewYork = calculateArrivalAtNY(departureAtBeijing, hours, minutes); System.out.println(departureAtBeijing + \" -&gt; \" + arrivalAtNewYork); // 2019-09-15T13:00 -&gt; 2019-09-15T14:20 // test: if (!LocalDateTime.of(2019, 10, 15, 14, 20, 0) .equals(calculateArrivalAtNY(LocalDateTime.of(2019, 10, 15, 13, 0, 0), 13, 20))) { System.err.println(\"测试失败!\"); } else if (!LocalDateTime.of(2019, 11, 15, 13, 20, 0) .equals(calculateArrivalAtNY(LocalDateTime.of(2019, 11, 15, 13, 0, 0), 13, 20))) { System.err.println(\"测试失败!\"); } } static LocalDateTime calculateArrivalAtNY(LocalDateTime bj, int h, int m) { // 加上用时后转化为不带时区的LocalDateTime： bj = bj.plusHours(h).plusMinutes(m); // lbj和lbj1都可以：将时区转化为上海 ZonedDateTime lbj = ZonedDateTime.of(bj, ZoneId.of(\"Asia/Shanghai\")); ZonedDateTime lbj1 = bj.atZone(ZoneId.of(\"Asia/Shanghai\")); // 将时区转化为纽约： ZonedDateTime zdt = lbj1.withZoneSameInstant(ZoneId.of(\"America/New_York\")); // 返回LocalDateTime类型的时间： return zdt.toLocalDateTime(); }} 五、DateTimeFormatter 使用旧的Date对象时，我们用SimpleDateFormat进行格式化显示。使用新的LocalDateTime或ZonedLocalDateTime时，我们要进行格式化显示，就要使用DateTimeFormatter。 和SimpleDateFormat不同的是，DateTimeFormatter不但是不变对象，它还是线程安全的（后面会学到！）。 因为SimpleDateFormat不是线程安全的，使用的时候，只能在方法内部创建新的局部变量。而DateTimeFormatter可以只创建一个实例，到处引用。 1、创建DateTimeFormatter 传入字符串 123456789101112package com.learn.file;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;public class DateTimeFormatterTest { public static void main(String[] args) { DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\"); ZonedDateTime zonedDateTime = ZonedDateTime.now(); System.out.println(formatter.format(zonedDateTime)); // 2020-04-13 22:25 }} 同时传入Local 12345678910111213package com.learn.file;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.util.Locale;public class DateTimeFormatterTest { public static void main(String[] args) { DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern(\"E,yyyy-MMMM-dd HH:mm\", Locale.US); ZonedDateTime zonedDateTime1 = ZonedDateTime.now(); System.out.println(formatter1.format(zonedDateTime1)); // Mon,2020-April-13 22:30 }} 2、一些格式化例子 分别以默认方式、中国地区和美国地区对当前时间进行显示： 12345678910111213141516171819package com.learn.file;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.util.Locale;public class DateTimeFormatterTest { public static void main(String[] args) { ZonedDateTime zdt = ZonedDateTime.now(); var formatter2 = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm ZZZZ\"); System.out.println(formatter2.format(zdt)); // 2020-04-13T22:32 GMT+08:00 var zhFormatter = DateTimeFormatter.ofPattern(\"yyyy MMM dd EE HH:mm\", Locale.CHINA); System.out.println(zhFormatter.format(zdt)); // 2020 4月 13 周一 22:32 var usFormatter = DateTimeFormatter.ofPattern(\"E, MMMM/dd/yyyy HH:mm\", Locale.US); System.out.println(usFormatter.format(zdt)); // Mon, April/13/2020 22:32 }} 当我们直接调用System.out.println()对一个ZonedDateTime或者LocalDateTime实例进行打印的时候，实际上，调用的是它们的toString()方法，默认的toString()方法显示的字符串就是按照ISO 8601格式显示的，我们可以通过DateTimeFormatter预定义的几个静态变量来引用： 123456789101112131415package com.learn.file;import java.time.LocalDateTime;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.util.Locale;public class DateTimeFormatterTest { public static void main(String[] args) { var ldt = LocalDateTime.now(); System.out.println(DateTimeFormatter.ISO_DATE.format(ldt)); // 2020-04-13 System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt)); // 2020-04-13T22:36:25.9843329 }} 六、Instant 计算机存储的当前时间，本质上只是一个不断递增的整数。Java提供的System.currentTimeMillis()返回的就是以毫秒表示的当前时间戳。 这个当前时间戳在java.time中以Instant类型表示，我们用Instant.now()获取当前时间戳： Instant内部只有两个核心字段： 一个是以秒为单位的时间戳， 一个是更精确的纳秒精度。 它和System.currentTimeMillis()返回的long相比，只是多了更高精度的纳秒。 1、Instant的创建 直接输出Instant默认是伦敦的标准时区，和我们东八区差半个小时： 1234567891011121314151617package com.learn.file;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;public class InstantTest { public static void main(String[] args) { System.out.println(System.currentTimeMillis()); // 1586855486387 Instant instant = Instant.now(); System.out.println(instant); // 2020-04-14T09:55:19.411338900Z // 按秒表示： System.out.println(instant.getEpochSecond()); // 1586855486 // 按毫秒表示： System.out.println(instant.toEpochMilli()); // 1586855486388 }} 2、Instant +ZonedId = ZonedDateTime 既然Instant就是时间戳，那么，给它附加上一个时区，就可以创建出ZonedDateTime： 对于某一个时间戳，给它关联上指定的ZoneId，就得到了ZonedDateTime，继而可以获得了对应时区的LocalDateTime。 1234567891011121314151617package com.learn.file;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;public class InstantTest { public static void main(String[] args) { // 以指定时间戳创建Instant: Instant ins = Instant.now(); Instant ins1 = Instant.ofEpochSecond(1586855486); ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault()); ZonedDateTime zdt1 = ins1.atZone(ZoneId.of(\"Asia/Shanghai\")); System.out.println(zdt); // 2020-04-14T17:13:51.251631400+08:00[Asia/Shanghai] System.out.println(zdt1); // 2020-04-14T17:11:26+08:00[Asia/Shanghai] }} 3、类之间的相互转换 long指的是以long表示的一个时间戳： 123456789101112┌─────────────┐│LocalDateTime│────┐└─────────────┘ │ ┌─────────────┐ ├───&gt;│ZonedDateTime│┌─────────────┐ │ └─────────────┘│ ZoneId │────┘ ▲└─────────────┘ ┌─────────┴─────────┐ │ │ ▼ ▼ ┌─────────────┐ ┌─────────────┐ │ Instant │&lt;───&gt;│ long │ └─────────────┘ └─────────────┘ 七、新旧API的互相转换 由于Java提供了新旧两套日期和时间的API，除非涉及到遗留代码，否则我们应该坚持使用新的API。 如果需要与遗留代码打交道，则需要在新旧API之间进行互相转换！ 处理日期和时间时，尽量使用新的java.time包； 1、旧API转新API 把旧式的Date或Calendar转换为新API对象，可以通过toInstant()方法转换为Instant对象，再继续转换为ZonedDateTime： Calendar -&gt; ZonedDateTime时：应该使用本身自带的时区信息，calendar.getTimeZone().toZoneId()，即将旧的TimeZone转化为新的ZoneId。或者可以直接使用atZone()来指定时区： 123456789101112131415161718192021222324252627package com.learn;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;import java.util.Calendar;import java.util.Date;public class NewOldAPI { public static void main(String[] args) { // Date -&gt; Instant：（无时区） System.out.println(new Date()); // Tue Apr 14 18:12:07 CST 2020 Instant instant = new Date().toInstant(); System.out.println(instant); // Calendar -&gt; Instant -&gt; ZonedDateTime Calendar calendar = Calendar.getInstance(); Instant instant1 = calendar.toInstant(); ZonedDateTime zonedDateTime = instant1.atZone(ZoneId.systemDefault()); System.out.println(zonedDateTime); // 2020-04-14T18:19:18.108+08:00[Asia/Shanghai] ZonedDateTime zdt = instant1.atZone(calendar.getTimeZone().toZoneId()); System.out.println(zdt); // 2020-04-14T18:19:18.108+08:00[Asia/Shanghai] System.out.println(calendar.getTimeZone().toZoneId()); // Asia/Shanghai }} 2、新API转旧API 把新的ZonedDateTime转换为旧的API对象，只能借助long型时间戳做一个“中转”： 使用ZonedDateTime.toEpochSecond()方法，获得时间戳的秒数，乘以1000获得毫秒数，然后用Date创建即可：（Date接收的参数为毫秒，不是秒！） 123456789101112131415161718192021222324252627282930313233343536package com.learn;import java.text.SimpleDateFormat;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;import java.util.Calendar;import java.util.Date;import java.util.TimeZone;public class NewOldAPI { public static void main(String[] args) { // ZonedDateTime -&gt; long -&gt; Date ZonedDateTime zonedDateTime1 = ZonedDateTime.now(); long l = zonedDateTime1.toEpochSecond() * 1000; Date date = new Date(l); System.out.println(date); // Tue Apr 14 18:35:52 CST 2020 // ZonedDateTime -&gt; long -&gt; Calendar: ZonedDateTime zonedDateTime2 = ZonedDateTime.now(); // 创建Calender： Calendar calendar1 = Calendar.getInstance(); // 清空： calendar1.clear(); //设置时区TimeZone: (两者都可) calendar1.setTimeZone(TimeZone.getTimeZone(zonedDateTime2.getZone())); calendar1.setTimeZone(TimeZone.getTimeZone(zonedDateTime2.getZone().getId())); System.out.println(zonedDateTime2.getZone()); // Asia/Shanghai System.out.println(zonedDateTime2.getZone().getId()); // Asia/Shanghai // 设置时间戳：（传入毫秒，需要将秒*1000） calendar1.setTimeInMillis(zonedDateTime2.toEpochSecond() * 1000); // 将Calender转化为Date再使用SimpleDateFormat进行格式化： System.out.println(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(calendar1.getTime())); // 2020-04-14 18:45:59 }} 3、数据库中存储日期时间 除了旧式的java.util.Date，我们还可以找到另一个java.sql.Date，它继承自java.util.Date，但会自动忽略所有时间相关信息。这个奇葩的设计原因要追溯到数据库的日期与时间类型。 在数据库中，我们需要存储的最常用的是时刻（Instant），因为有了时刻信息，就可以根据用户自己选择的时区，显示出正确的本地时间。所以，最好的方法是直接用长整数long表示，在数据库中存储为BIGINT类型。 在数据库中存储时间戳时，尽量使用long型时间戳，它具有省空间，效率高，不依赖数据库的优点。 在数据库中，也存在几种日期和时间类型： DATETIME：表示日期和时间； DATE：仅表示日期； TIME：仅表示时间； TIMESTAMP：和DATETIME类似，但是数据库会在创建或者更新记录的时候同时修改TIMESTAMP。 数据库类型与Java新旧API的映射关系 数据库 对应Java类（旧） 对应Java类（新） DATETIME java.util.Date LocalDateTime DATE java.sql.Date LocalDate TIME java.sql.Time LocalTime TIMESTAMP java.sql.Timestamp LocalDateTime 4、为不同用户以不同的偏好来显示不同的本地时间 DateTimeFormatter：其中的ofLocalizedDateTime()方法，传入两个参数，一个日期格式，一个时间格式，具体的参数可以查看JDK源码，Idea直接按住Ctrl+左键即可跳转到源码对应位置： 123456789101112131415161718192021222324252627282930package com.learn;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.time.format.FormatStyle;import java.util.Locale;public class DateTimeWork { public static void main(String[] args) { Instant instant = Instant.now(); long l = instant.toEpochMilli(); System.out.println(instant.toEpochMilli()); System.out.println(timestampToString(l, Locale.CHINA, \"Asia/Shanghai\")); // 2020年4月14日 下午7:21 System.out.println(timestampToString(l, Locale.US, \"America/New_York\")); //Apr 14, 2020, 7:21 AM } static String timestampToString(long epochMilli, Locale lo, String zoneId) { // 将long转化为Instant： Instant ins = Instant.ofEpochMilli(epochMilli); // 创建格式化方法： DateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT); // 将Instant按照当前ZoneId转化为ZonedDateTime再使用DateTimeFormatter进行格式化： // 方式一：不传Local则会默认以中国格式输出： //return f.format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId))); // 2020年4月14日 上午7:28 // 方式二：传Local会以当前国家格式输出： return f.withLocale(lo).format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId))); // Apr 14, 2020, 7:28 AM }} 本节已经完结！敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Date","slug":"Date","permalink":"https://niuxvdong.top/tags/Date/"},{"name":"Time","slug":"Time","permalink":"https://niuxvdong.top/tags/Time/"}],"author":"Mr.Niu"},{"title":"Java教程系列之IO流","slug":"Java教程系列之IO流","date":"2020-04-10T14:12:52.000Z","updated":"2020-04-10T14:12:52.000Z","comments":true,"path":"posts/61053.html","link":"","permalink":"https://niuxvdong.top/posts/61053.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、IO介绍IO是指Input/Output，即输入和输出。以内存为中心： Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。 Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。 IO流是一种流式的数据输入/输出模型： 二进制数据以byte为最小单位在InputStream/OutputStream中单向流动； 字符数据以char为最小单位在Reader/Writer中单向流动。 Java标准库的java.io包提供了同步IO功能： 字节流接口：InputStream/OutputStream； 字符流接口：Reader/Writer。 注意：UTF-8编码下，英文字符占一个字节，中文字符占三个字节！ Java的读写数据在传输时都是byte[]，String这两种方式！ 1、Reader 和 Writer 如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照char来读写显然更方便，这种流称为字符流。 Reader和Writer本质上是一个能自动编解码的InputStream和OutputStream。 使用Reader，数据源虽然是字节，但我们读入的数据都是char类型的字符，原因是Reader内部把读入的byte做了解码，转换成了char。使用InputStream，我们读入的数据和原始二进制数据一模一样，是byte[]数组，但是我们可以自己把二进制byte[]数组按照某种编码转换为字符串。究竟使用Reader还是InputStream，要取决于具体的使用场景。如果数据源不是文本，就只能使用InputStream，如果数据源是文本，使用Reader更方便一些。Writer和OutputStream是类似的。 2、同步和异步 同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。 而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。 Java标准库的包java.io提供了同步IO，而java.nio则是异步IO。上面我们讨论的InputStream、OutputStream、Reader和Writer都是同步IO的抽象类，对应的具体实现类，以文件为例，有FileInputStream、FileOutputStream、FileReader和FileWriter。 二、File对象1、创建File对象 File file = new File(\"路径\"); 1.1 路径的写法 注意Windows平台使用\\作为路径分隔符，在Java字符串中需要用\\\\表示一个\\。Linux平台使用/作为路径分隔符： 用.表示当前目录，..表示上级目录。 12345678910111213141516171819202122package com.learn.file;import java.io.File;import java.io.FilenameFilter;import java.io.IOException;public class FileTest { public static void main(String[] args) throws IOException { File file = new File(\".\"); File file01 = new File(\".\\\\\"); File file02 = new File(\"..\\\\\"); File file1 = new File(\"..\"); File file2 = new File(\"Settings\\\\setting.properties\"); File file3 = new File(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\"); // 打印系统当前分隔符： System.out.println(File.separator); // / // Linux 下路径写法，斜杠换一下即可！ File f = new File(\"/usr/bin/javac\"); }} 1.2 获取路径 getPath()：返回构造方法传入的路径，直接输出File对象名效果一样！ getAbsolutePath()：返回绝对路径，若传入参数有.，则该方法也会出现.; getCanonicalPath()：返回的是规范路径，若传入参数有.，则该方法会将点翻译为正确路径; 路径如下： 12345678910111213141516171819202122232425262728293031323334353637383940package com.learn.file;import java.io.File;import java.io.FilenameFilter;import java.io.IOException;public class FileTest { public static void main(String[] args) throws IOException { File file = new File(\".\"); System.out.println(file); // . System.out.println(file.getPath()); // . System.out.println(file.getAbsolutePath()); // E:\\MyJavaProgram\\. System.out.println(file.getCanonicalPath()); // E:\\MyJavaProgram\\ System.out.println(\"---------------------------------------------\"); File file01 = new File(\".\\\\\"); System.out.println(file01.getCanonicalPath()); // E:\\MyJavaProgram System.out.println(\"---------------------------------------------\"); File file02 = new File(\"..\\\\\"); System.out.println(file02.getCanonicalPath()); // E:\\ System.out.println(\"---------------------------------------------\"); File file1 = new File(\"..\"); System.out.println(file1.getPath()); // .. System.out.println(file1.getAbsolutePath()); // E:\\MyJavaProgram\\.. System.out.println(file1.getCanonicalPath()); // E:\\ System.out.println(\"---------------------------------------------\"); File file2 = new File(\"Settings\\\\setting.properties\"); System.out.println(file2.getPath()); // Settings\\setting.properties System.out.println(file2.getAbsolutePath()); // E:\\MyJavaProgram\\Settings\\setting.properties System.out.println(file2.getCanonicalPath()); // E:\\MyJavaProgram\\Settings\\setting.properties System.out.println(\"---------------------------------------------\"); File file3 = new File(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\"); System.out.println(file3.getPath()); // E:\\MyJavaProgram\\Settings\\setting.properties System.out.println(file3.getAbsolutePath()); // E:\\MyJavaProgram\\Settings\\setting.properties System.out.println(file3.getCanonicalPath()); // E:\\MyJavaProgram\\Settings\\setting.properties } 2、文件目录判断 File对象既可以表示文件，也可以表示目录。 特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。 isFile()：判断是否是已存在文件 isDirectory()：判断是否是已存在目录 isAbsolute()：判断是否是完整路径 isHidden()：判断是否是隐藏文件 1234567891011121314File file1 = new File(\"..\");File file2 = new File(\"Settings\\\\setting.properties\");File file3 = new File(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\");System.out.println(file3.isAbsolute()); // trueSystem.out.println(file3.isDirectory()); // falseSystem.out.println(file3.isFile()); // trueSystem.out.println(file3.isHidden()); // falseSystem.out.println(\"---------------------------------------------\");System.out.println(file2.isAbsolute()); // falseSystem.out.println(file1.isAbsolute()); // falseSystem.out.println(file1.isFile()); // falseSystem.out.println(file1.isDirectory()); // true 3、File权限判断用File对象获取到一个文件时，还可以进一步判断文件的权限和大小： boolean canRead()：是否可读； boolean canWrite()：是否可写； boolean canExecute()：是否可执行； long length()：文件字节大小。 对目录而言，是否可执行表示能否列出它包含的文件和子目录。 123456System.out.println(\"---------------------------------------------\");File fileExe = new File(\"E:\\\\MyJavaProgram\\\\Settings\\\\test.exe\");System.out.println(fileExe.canRead()); // trueSystem.out.println(fileExe.canWrite()); // trueSystem.out.println(fileExe.canExecute()); // true 4、创建和删除文件 先将需要创建的文件test.txt传入File对象，再调用creatNewFile()方法来创建！ 可通过createTempFile()创建临时文件，以及deleteOnExit()在JVM退出时自动删除该文件。 createNewFile()：返回boolean值，若文件已存在返回false！ delete()：返回boolean值，若文件已不存在返回false！ createTempFile()：创建临时文件，创建位置为C盘某个位置，需要传入两个参数，一个前缀，一个后缀！ deleteOnExit()：JVM退出时自动删除，删除后仍然可获得File对象路径！ 12345678910111213141516// 创建文件：File file4 = new File(\"Settings\\\\test.txt\");if(file4.createNewFile()){ System.out.println(\"test.txt创建成功！\");}// 删除文件：if(file4.delete()){ System.out.println(\"test.txt删除成功！\");}// 创建临时文件，使用后删除File file5 = File.createTempFile(\"temp\",\".cpp\");System.out.println(file5.getCanonicalPath()); // C:\\Users\\15890\\AppData\\Local\\Temp\\temp10279290225517315464.cppfile5.deleteOnExit();// 删除后仍然可以获得路径：System.out.println(file5.getCanonicalPath()); // C:\\Users\\15890\\AppData\\Local\\Temp\\temp10279290225517315464.cpp 5、创建和删除目录 boolean mkdir()：创建当前File对象表示的目录； boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来； boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功，是能删除最内部的目录，并且只有目录为空才可删除！ 创建目录使用mkdirs()即可，mkdir()可以做到的，mkdirs()都可以做到！ 12345678910111213141516File file7 = new File(\".\\\\test\");//File file8 = new File(\".\");if(file7.mkdir()){ System.out.println(\"test目录创建成功！\");}if(file7.delete()){ System.out.println(\"test目录删除成功！\");}File file8 = new File(\".\\\\test\\\\test02\\\\test03\");if(file8.mkdirs()){ System.out.println(\"嵌套目录创建成功！\"); if(file8.delete()){ System.out.println(\"test03目录删除成功！\"); }} 6、遍历文件和目录 使用listFiles()获取当前目录层次关系，用File对象数组接收，可以传入FilenameFilter()方法来过滤不需要的文件或目录！ 1234567891011121314151617181920212223242526272829303132package com.learn.file;import java.io.File;import java.io.FilenameFilter;import java.io.IOException;public class FileTest { public static void main(String[] args) throws IOException { System.out.println(\"-----------------------------------------------\"); File file6 = new File(\".\"); File[] files = file6.listFiles(); printFiles(files); File[] files1 = file6.listFiles(new FilenameFilter() { @Override public boolean accept(File dir, String name) { return name.endsWith(\".idea\"); } }); printFiles(files1); } static void printFiles(File[] files){ System.out.println(\"-----------------------------------------------\"); if(files != null){ for(var file : files){ System.out.println(file); } } }} 7、Path对象 Java标准库还提供了一个Path对象，它位于java.nio.file包。Path对象和File对象类似，但操作更加简单： Paths.get()：参数可以有多个，表示路径，后面的一定得是前面路径的子路径！ toAbsolutePath()：转化为带.的绝对路径 normalize()：将构造路径的点去掉 toAbsolutePath().normalize()：将带点的绝对路径去掉点，转化为完整的路径！ toFile()：转化为File对象！ 12345678910111213141516171819202122232425262728package com.learn.file;import java.io.File;import java.io.IOException;import java.nio.file.Path;import java.nio.file.Paths;public class PathTest { public static void main(String[] args) throws IOException { Path path = Paths.get(\".\\\\Path\",\"PathTest\\\\test01\", \"test02\"); System.out.println(path); // .\\Path\\PathTest\\test01\\test02 System.out.println(path.toAbsolutePath()); // E:\\MyJavaProgram\\.\\Path\\PathTest\\test01\\test02 System.out.println(path.normalize()); // Path\\PathTest\\test01\\test02 System.out.println(path.toAbsolutePath().normalize()); // E:\\MyJavaProgram\\Path\\PathTest\\test01\\test02 File file = path.toFile(); System.out.println(file); // 嵌套目录遍历： for(var p : path){ System.out.println(p); } System.out.println(); for(var p : path.toAbsolutePath()){ System.out.println(p); } }} 8、遍历目录例子 为了有层次关系，可进行空格的控制输出，使用getName()方法获取目录或文件名！ 使用递归去进行层次遍历！ 12345678910111213141516171819202122232425262728293031323334package com.learn.file;import java.io.File;import java.io.IOException;/** @:实现打印当前目录的层次关系！* */public class FileWork { public static void main(String[] args) throws IOException { File file = new File(\".\"); ListDir(file, 0); } static void ListDir(File file, int level) { File[] files = file.listFiles(); if (files != null) { for (var ls : files) { for(int i = 0; i &lt; level; i++){ System.out.print(\" \"); } if (ls.isFile()) { System.out.println(ls.getName()); } else { System.out.println(ls.getName() + \"\\\\\"); } ListDir(ls, level + 1); } } }} 三、InputStream InputStream就是Java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步IO的功能。 要特别注意的一点是，InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()。 这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。 FileInputStream是InputStream的一个子类 1、读取和关闭FileInputStream 在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。 InputStream和OutputStream都是通过close()方法来关闭流。关闭流就会释放对应的底层资源。 我们还要注意到在读取或写入IO流的过程中，可能会发生错误，例如，文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成IOException异常并抛出。因此，所有与IO操作相关的代码都必须正确处理IOException。 1.1 手动关闭 + 未处理异常 如果读取过程中发生了IO错误，InputStream就没法正确地关闭，资源也就没法及时释放。 1234567891011121314151617181920package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ InputStream input = new FileInputStream(\"Settings\\\\readme.txt\"); int n; while((n = input.read()) != -1){ System.out.print(n + \" \"); } input.close(); }} 1.2 使用 try finally 来处理异常 无论是否异常，总会执行finally来关闭文件！ 注意：关闭流时要保证流不为null，否则会抛出NullPointerException 12345678910111213141516171819202122232425262728package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ System.out.println(); InputStream input1 = null; //input1.close(); // throws NullPointerException try{ input1 = new FileInputStream(\"Settings\\\\readme.txt\"); int n1; while((n1 = input1.read()) != -1){ System.out.print(n1 + \" \"); } }finally { if(input1 != null){ input1.close(); } } }} 1.3 使用 try(resource) 实现自动关闭流（推荐） 编译器自动为我们关闭资源 实际上，编译器并不会特别地为InputStream加上自动关闭。编译器只看try(resource = ...)中的对象是否实现了java.lang.AutoCloseable接口，如果实现了，就自动加上finally语句并调用close()方法。InputStream和OutputStream都实现了这个接口，因此，都可以用在try(resource)中。 只有实现了上述接口使用该语法才会进行自动关闭！ 123456789101112131415161718192021package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ System.out.println(); try(InputStream input2 = new FileInputStream(\"Settings\\\\readme.txt\")) { int n2; while((n2 = input2.read()) != -1){ System.out.print(n2 + \" \"); } } }} 2、读到缓存中 在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。 一次读取多个字节时，需要先定义一个byte[]数组作为缓冲区，read()方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。 read()方法的返回值不再是字节的int值，而是返回实际读取了多少个字节。如果返回-1，表示没有更多的数据了。 InputStream提供了两个重载方法来支持读取多个字节： int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数 int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数 12345678910111213141516171819202122package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ System.out.println(); try(InputStream input3 = new FileInputStream(\"Settings\\\\readme.txt\")) { int n2; byte[] buffer = new byte[10]; while((n2 = input3.read(buffer)) != -1){ System.out.println(\"读取了\" + n2 + \"个字节\"); } } }} 如下： 1234读取了10个字节读取了10个字节读取了10个字节读取了2个字节 3、阻塞 在调用InputStream的read()方法读取数据时，我们说read()方法是阻塞（Blocking）的！ 执行到第二行代码时，必须等read()方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定read()方法调用到底要花费多长时间。 123int n;n = input.read(); // 必须等待read()方法返回才能执行下一行代码int m = n; 4、InputStream实现类 除了FileInputStream可以从文件获取输入流，还有ByteArrayInputStream可以在内存中模拟一个InputStream： ByteArrayInputStream实际上是把一个byte[]数组在内存中变成一个InputStream，虽然实际应用不多，但测试的时候，可以用它来构造一个InputStream。 4.1 使用ByteArrayInputStream模拟InputStream12345678910111213141516171819package com.learn.file;import java.io.ByteArrayInputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { byte[] data = { 72, 101, 108, 108, 111, 33 }; try(InputStream input4 = new ByteArrayInputStream(data)){ int n3; while((n3 = input4.read()) != -1){ System.out.print((char)n3 + \" \"); // H e l l o ! } } }} 4.2 封装为函数进行测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.learn.file;import java.io.ByteArrayInputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ byte[] data = { 72, 101, 108, 108, 111, 33 }; try(InputStream input4 = new ByteArrayInputStream(data)){ int n3; while((n3 = input4.read()) != -1){ System.out.print((char)n3 + \" \"); // H e l l o ! } } System.out.println(); String s; try(InputStream input5 = new FileInputStream(\"Settings\\\\readme.txt\")) { int n5; StringBuilder sb = new StringBuilder(); while((n5 = input5.read()) != -1){ sb.append((char)n5); } s = sb.toString(); } System.out.println(s); // 输出结果： /* æµè¯è¾å¥æµï¼ hello world! */ // 使用封装函数来输出： String s1; try (InputStream input6 = new FileInputStream(\"Settings\\\\readme.txt\")) { s1 = readAsString(input6); } System.out.println(s1); // 直接通过ByteArrayInputStream的模拟来输出： try(InputStream input7 = new ByteArrayInputStream(data)){ String s2 = readAsString(input7); System.out.println(s2); // Hello! } } // 封装一个函数： public static String readAsString(InputStream input) throws IOException { int n; StringBuilder sb = new StringBuilder(); while ((n = input.read()) != -1) { sb.append((char) n); } return sb.toString(); }} 四、OutputStream 和InputStream相反，OutputStream是Java标准库提供的最基本的输出流。 和InputStream类似，OutputStream也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是void write(int b) 这个方法会写入一个字节到输出流。要注意的是，虽然传入的是int参数，但只会写入一个字节，即只写入int最低8位表示字节的部分： OutputStream也提供了close()方法关闭输出流，以便释放系统资源！ 1public abstract void write(int b) throws IOException; 1、flush方法 它的目的是将缓冲区的内容强制输出到目的地。 向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以OutputStream有个flush()方法，能强制把缓冲区内容输出。 通常情况下，我们不需要调用这个flush()方法，因为缓冲区写满了OutputStream会自动调用它，并且，在调用close()方法关闭OutputStream之前，也会自动调用flush()方法。 需要手动调用该方法的例子：实时聊天软件，不能等缓冲区满了在进行输出吧！ 2、写入和关闭FileOutStream 如下方，只有当append参数为true时才不会进行覆盖，默认为false！ 123new FileOutputStream(File file, boolean append); //append = falsenew FileWriter(File file, boolean append); //append = false 2.1 一个字节的去读1234567891011121314151617181920package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class OutputStreamTest { public static void main(String[] args) throws IOException { File file = new File(\"Settings\\\\input.txt\"); if(file.createNewFile()){ System.out.println(\"input.txt创建成功！\"); } OutputStream output = new FileOutputStream(\"Settings\\\\input.txt\"); output.write(72); // H output.write(101); // e output.write(108); // l output.write(108); // l output.write(111); // o output.close(); }} 2.2 一次性读入若干字节12345678910111213141516package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class OutputStreamTest { public static void main(String[] args) throws IOException { File file = new File(\"Settings\\\\input.txt\"); if(file.createNewFile()){ System.out.println(\"input.txt创建成功！\"); } OutputStream output = new FileOutputStream(\"Settings\\\\input.txt\"); output.write(\"world\".getBytes(StandardCharsets.UTF_8)); output.close(); }} 2.3 使用try(resourse)自动关闭（推荐）123456789101112131415161718192021222324package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class OutputStreamTest { public static void main(String[] args) throws IOException { File file = new File(\"Settings\\\\input.txt\"); if(file.createNewFile()){ System.out.println(\"input.txt创建成功！\"); } try(OutputStream output1 = new FileOutputStream(\"Settings\\\\input.txt\")){ output1.write(\"hello world!\".getBytes(StandardCharsets.UTF_8)); }// 编译器在此自动为我们写入finally并调用close() try(InputStream input = new FileInputStream(\"Settings\\\\input.txt\")){ int n; while((n = input.read()) != -1){ System.out.print((char) n); } } }} 3、阻塞 同样，只有等write方法执行完毕才能执行下一行！ 所以write方法也是阻塞的！ 123int n;n = output.write(); // 必须等待write()方法返回才能执行下一行代码int m = n; 4、OutputStream实现类 用FileOutputStream可以从文件获取输出流，这是OutputStream常用的一个实现类。此外，ByteArrayOutputStream可以在内存中模拟一个OutputStream ByteArrayOutputStream实际上是把一个byte[]数组在内存中变成一个OutputStream，虽然实际应用不多，但测试的时候，可以用它来构造一个OutputStream。 使用ByteArrayOutputStream模拟OutputStream 123456789101112131415package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class OutputStreamTest { public static void main(String[] args) throws IOException { byte[] data; try(ByteArrayOutputStream output1 = new ByteArrayOutputStream()){ output1.write(\"Hello world!\".getBytes(StandardCharsets.UTF_8)); data = output1.toByteArray(); } System.out.println(new String(data));//Hello world! }} 5、一个小例子 实现文件的复制！ 在命令行进行运行带有参数的运行，即将source.txt 复制到copy.txt； 当然要在源文件下，或者使用相对路径绝对路径都可以！ 前提是两个文件都已经存在了！ 1$ java CopyTest.java source.txt copy.txt main函数的args参数就是用来接收命令行参数的，直接将第一个参数给了输入流，第二个参数给了输出流，即可实现将输入流复制到输出流的copy文件里！ 123456789101112131415package com.learn.file;import java.io.*;public class CopyTest { public static void main(String[] args) throws IOException { try(InputStream source = new FileInputStream(args[0]); OutputStream copyfile = new FileOutputStream(args[1])){ int n; while((n = source.read()) != -1){ copyfile.write(n); } } }} 效果： 之前： 1234source.txt：I am a source file!copy.txt：（空） 之后： 1234source.txt：I am a source file!copy.txt：I am a source file! 五、Filter模式 InputStream，OutputStream都是以这种Filter模式来提供各种功能： 下面仅以InputStream举例！ 1、InputStream来源 FileInputStream：从文件读取数据，是最终数据源； ServletInputStream：从HTTP请求读取数据，是最终数据源； Socket.getInputStream()：从TCP连接读取数据，是最终数据源； … 2、引入FilterInputStream原因 如果要给FileInputStream添加各种功能： 1234567// 添加缓冲功能：BufferedFileInputStream extends FileInputStream// 添加计算签名功能：DigestFileInputStream extends FileInputStream// 添加加密解密功能：CipherFileInputStream extends FileInputStream// 以及其他类之间的相互组合.....等等 这还只是针对FileInputStream设计，如果针对另一种InputStream设计，很快会出现子类爆炸的情况。 因此，直接使用继承，为各种InputStream附加更多的功能，根本无法控制代码的复杂度，很快就会失控。 3、FilterInputStream简介 为了解决依赖继承会导致子类数量失控的问题，JDK首先将InputStream分为两大类： 无论我们包装多少次，得到的对象始终是InputStream，我们直接用InputStream来引用它！ 通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。它可以让我们通过少量的类来实现各种功能的组合！ FilterInputStream是其他各钟功能的父类！ 一类是直接提供数据的基础InputStream，例如： FileInputStream ByteArrayInputStream ServletInputStream … 一类是提供额外附加功能的InputStream，例如： BufferedInputStream DigestInputStream CipherInputStream … 123456InputStream file = new FileInputStream(\"test.gz\");// 使用BufferedInputStream包装InputStream,添加缓冲功能：InputStream buffered = new BufferedInputStream(file);// 使用GZIPInputStream包装InputStream,添加解压功能：InputStream gzip = new GZIPInputStream(buffered); 结构图像这样： OutputStream也一样！ 12345678910111213141516 ┌─────────────┐ │ InputStream │ └─────────────┘ ▲ ▲┌────────────────────┐ │ │ ┌─────────────────┐│ FileInputStream │─┤ └─│FilterInputStream│└────────────────────┘ │ └─────────────────┘┌────────────────────┐ │ ▲ ┌───────────────────┐│ByteArrayInputStream│─┤ ├─│BufferedInputStream│└────────────────────┘ │ │ └───────────────────┘┌────────────────────┐ │ │ ┌───────────────────┐│ ServletInputStream │─┘ ├─│ DataInputStream │└────────────────────┘ │ └───────────────────┘ │ ┌───────────────────┐ └─│CheckedInputStream │ └───────────────────┘ 4、编写FilterInputStream 下面编写一个自定义的FilterInputStream来实现需要实现的功能，同时还可以使得所有InputStream都可以使用该功能： CountInputStream实现了计数功能； 所有的功能都必须得继承自FilterInputStream！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.learn.file;import java.io.ByteArrayInputStream;import java.io.FilterInputStream;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;public class FilterWork { public static void main(String[] args) throws IOException{ byte[] data = \"hello world!\".getBytes(StandardCharsets.UTF_8); // 使用ByteArrayInputStream将byte数组封装为InputStream; try(CountInputStream inputStream = new CountInputStream(new ByteArrayInputStream(data))){ int n; while ((n = inputStream.read()) != -1){ System.out.print((char)n); // hello world! } System.out.println(\"\\nTotal read \" + inputStream.getBytesRead() + \" bytes!\"); // Total read 12 bytes! } }}class CountInputStream extends FilterInputStream{ private int count; // Idea自动生成的注释： /** * Creates a {@code FilterInputStream} * by assigning the argument {@code in} * to the field {@code this.in} so as * to remember it for later use. * * @param in the underlying input stream, or {@code null} if * this instance is to be created without an underlying stream. */ protected CountInputStream(InputStream in) { super(in); } public int getBytesRead() { return this.count; } public int read() throws IOException { int n = in.read(); if (n != -1) { this.count ++; } return n; } public int read(byte[] b, int off, int len) throws IOException { int n = in.read(b, off, len); this.count += n; return n; }} 六、操作Zip1、ZipInputStream ZipInputStream是一种FilterInputStream，它可以直接读取zip包的内容： 另一个JarInputStream是从ZipInputStream派生，它增加的主要功能是直接读取jar文件里面的MANIFEST.MF文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。 继承的结构关系： 1234567891011121314151617181920212223┌───────────────────┐│ InputStream │└───────────────────┘ ▲ │┌───────────────────┐│ FilterInputStream │└───────────────────┘ ▲ │┌───────────────────┐│InflaterInputStream│└───────────────────┘ ▲ │┌───────────────────┐│ ZipInputStream │└───────────────────┘ ▲ │┌───────────────────┐│ JarInputStream │└───────────────────┘ 2、读取Zip包 创建一个ZipInputStream，通常是传入一个FileInputStream作为数据源，然后，循环调用getNextEntry()，直到返回null，表示zip流结束。 一个ZipEntry表示一个压缩文件或目录，如果是压缩文件，我们就用read()方法不断读取，直到返回-1： 1234567891011121314151617181920212223242526package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.util.zip.ZipEntry;import java.util.zip.ZipInputStream;public class ZipTest { public static void main(String[] args) throws IOException { try (ZipInputStream zip = new ZipInputStream(new FileInputStream(\".\\\\zip.zip\"))) { ZipEntry entry = null; while ((entry = zip.getNextEntry()) != null) { System.out.println(\"文件或目录名：\" + entry.getName()); if (!entry.isDirectory()) { int n; System.out.print(\"内容：\"); while ((n = zip.read()) != -1) { System.out.print((char) n); } System.out.println(); } } } }} 结果如下： 12345文件或目录名：niub/文件或目录名：test.txt内容：I am a Test file!文件或目录名：zip.txt内容：hello world! 3、写入Zip包 ZipOutputStream是一种FilterOutputStream，它可以直接写入内容到zip包。我们要先创建一个ZipOutputStream，通常是包装一个FileOutputStream，然后，每写入一个文件前，先调用putNextEntry()，然后用write()写入byte[]数据，写入完毕后调用closeEntry()结束这个文件的打包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.learn.file;import java.io.*;import java.util.zip.ZipEntry;import java.util.zip.ZipInputStream;import java.util.zip.ZipOutputStream;public class ZipTest { public static void main(String[] args) throws IOException { try (ZipInputStream zip = new ZipInputStream(new FileInputStream(\".\\\\zip.zip\"))) { ZipEntry entry = null; while ((entry = zip.getNextEntry()) != null) { System.out.println(\"文件或目录名：\" + entry.getName()); if (!entry.isDirectory()) { int n; System.out.print(\"内容：\"); while ((n = zip.read()) != -1) { System.out.print((char) n); } System.out.println(); } } } File file1 = new File(\".\\\\Settings\"); try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(\".\\\\zip.zip\"))) { File[] files = file1.listFiles(); if(files != null){ for (File file : files) { // 在Zip中创建文件 zip.putNextEntry(new ZipEntry(file.getName())); // 将内容写入 zip.write(getFileDataAsBytes(file)); // 关闭外部文件 zip.closeEntry(); } } } } private static byte[] getFileDataAsBytes(File file) throws IOException{ byte[] data = new byte[1024]; try(InputStream file1 = new FileInputStream(file)){ int n; while((n = file1.read(data)) != -1){ System.out.println(\"read \" + n + \" byte\"); } } return data; }} 七、读取classpath资源 是一种与路径无关的读取文件的方式： 从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把default.properties文件放到classpath中，就不用关心它的实际存放路径。 在classpath中的资源文件，路径总是以／开头，我们先获取当前的Class对象，然后调用getResourceAsStream()就可以直接从classpath读取任意的资源文件！ 关于classpath目前还不太清楚，后续再进行学习！ Java存放.class的目录或jar包也可以包含任意其他类型的文件，例如： 配置文件，例如.properties； 图片文件，例如.jpg； 文本文件，例如.txt，.csv； …… 1234567891011121314151617package com.learn.file;import java.io.IOException;import java.io.InputStream;public class ClassPathTest { public static void main(String[] args) throws IOException { try (InputStream input = ClassPathTest.class.getResourceAsStream(\"/default.properties\")) { if (input != null) { int n; while((n = input.read()) != -1){ System.out.print((char) n); } } } }} 如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置： 123Properties props = new Properties();props.load(inputStreamFromClassPath(\"/default.properties\"));props.load(inputStreamFromFile(\"./conf.properties\")); 八、序列化 序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。 为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。 有序列化，就有反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。 一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口： Serializable接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。 这节有点云里雾里，后续再看！ 1、序列化 把一个Java对象变为byte[]数组，需要使用ObjectOutputStream。它负责把一个Java对象写入一个字节流。 ObjectOutputStream既可以写入基本类型，如int，boolean，也可以写入String（以UTF-8编码），还可以写入实现了Serializable接口的Object。 因为写入Object时需要大量的类型信息，所以写入的内容很大。 123456789101112131415161718192021package com.learn.file;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.util.Arrays;public class SerializableTest { public static void main(String[] args) throws IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); try (ObjectOutputStream output = new ObjectOutputStream(buffer)) { // 写入int: output.writeInt(12345); // 写入String: output.writeUTF(\"Hello\"); // 写入Object: output.writeObject(123.456); } System.out.println(Arrays.toString(buffer.toByteArray())); }} 2、反序列化 和ObjectOutputStream相反，ObjectInputStream负责从一个字节流读取Java对象 除了能读取基本类型和String类型外，调用readObject()可以直接返回一个Object对象。要把它变成一个特定类型，必须强制转型。 要特别注意反序列化的几个重要特点： 反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。 readObject()可能抛出的异常有： ClassNotFoundException：没有找到对应的Class； InvalidClassException：Class不匹配。 对于ClassNotFoundException，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，Person对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义Person类，所以无法反序列化。 对于InvalidClassException，这种情况常见于序列化的Person对象定义了一个int类型的age字段，但是反序列化时，Person类定义的age字段被改成了long类型，所以导致class不兼容。 123456789101112131415161718package com.learn.file;import java.io.*;import java.util.Arrays;public class SerializableTest { public static void main(String[] args) throws Exception { ByteArrayInputStream bufferin = new ByteArrayInputStream(buffer.toByteArray()); try (ObjectInputStream input = new ObjectInputStream(bufferin)) { int n = input.readInt(); String s = input.readUTF(); Double d = (Double) input.readObject(); System.out.println(n); System.out.println(s); System.out.println(d); } }} 为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的serialVersionUID静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变serialVersionUID的值，这样就能自动阻止不匹配的class版本： 123public class Person implements Serializable { private static final long serialVersionUID = 2709425275741743919L;} 3、安全性 因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 九、Reader Reader是Java的IO库提供的另一个输入流接口。和InputStream的区别是，InputStream是一个字节流，即以byte为单位读取，而Reader是一个字符流，即以char为单位读取： java.io.Reader是所有字符输入流的超类！ read()方法读取字符流的下一个字符，并返回字符表示的int，范围是0~65535。如果已读到末尾，返回-1。 1、Reader和InputStream对比 InputStream Reader 字节流，以byte为单位 字符流，以char为单位 读取字节（-1，0~255）：int read() 读取字符（-1，0~65535）：int read() 读到字节数组：int read(byte[] b) 读到字符数组：int read(char[] c) 2、FileReader FileReader是Reader的一个子类，它可以打开文件并获取`Reader： FileReader()可以接收一个编码参数！ 2.1 直接创建FileReader12345678910111213141516package com.learn.file;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class ReaderTest { public static void main(String[] args) throws IOException { Reader reader = new FileReader(\"Settings\\\\readme.txt\"); int n; while((n = reader.read()) != -1){ System.out.print((char) n); } reader.close(); }} 2.2 使用try(resourse)实现自动关闭资源1234567891011121314151617package com.learn.file;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class ReaderTest { public static void main(String[] args) throws IOException { try(Reader reader = new FileReader(\"Settings\\\\readme.txt\")){ int n; while((n = reader.read()) != -1){ System.out.print((char) n); } } }} 2.3 填充字符到char数组 read(char[] c)返回实际读入的字符个数，最大不超过char[]数组的长度。返回-1表示流结束。 123456789101112131415161718package com.learn.file;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class ReaderTest { public static void main(String[] args) throws IOException { try(Reader reader = new FileReader(\"Settings\\\\readme.txt\")){ int n; char[] buffer = new char[100]; while((n = reader.read(buffer)) != -1){ System.out.println(\"read \" + n + \"chars\"); } } }} 3、CharArrayReader CharArrayReader可以在内存中模拟一个Reader，它的作用实际上是把一个char[]数组变成一个Reader： 123456try (Reader reader = new CharArrayReader(\"Hello\".toCharArray())) { int n; while((n = reader.read()) != -1){System.out.print((char) n); }} 4、StringReader StringReader可以直接把String作为数据源，它和CharArrayReader几乎一样： 123456try (Reader reader = new StringReader(\"Hello\")) { int n; while((n = reader.read()) != -1){ System.out.print((char) n); }} 5、InputStreamReader 除了特殊的CharArrayReader和StringReader，普通的Reader实际上是基于InputStream构造的。 因为Reader需要从InputStream中读入字节流（byte），然后，根据编码设置，再转换为char就可以实现字符流。 InputStreamReader就是一个转换器，它可以把任何InputStream转换为Reader： 两个参数，一个InputStream，一个可选的编码方式参数！ 使用try (resource)结构时，当我们关闭Reader时，它会在内部自动调用InputStream的close()方法，所以，只需要关闭最外层的Reader对象即可 12345678910// 持有InputStream:InputStream input = new FileInputStream(\"src/readme.txt\");// 变换为Reader:Reader reader = new InputStreamReader(input, StandardCharsets.UTF_8);// 使用try(resourse)：try (Reader reader1 = new InputStreamReader(new FileInputStream(\"src/readme.txt\"),StandardCharsets.UTF_8)) { // TODO: System.out.println(reader1);} 十、Writer Reader是带编码转换器的InputStream，它把byte转换为char，而Writer就是带编码转换器的OutputStream，它把char转换为byte并输出： 1、Reader和InputStream对比 OutputStream Writer 字节流，以byte为单位 字符流，以char为单位 写入字节（0~255）：void write(int b) 写入字符（0~65535）：void write(int c) 写入字节数组：void write(byte[] b) 写入字符数组：void write(char[] c) 无对应方法 写入String：void write(String s) Writer是所有字符输出流的超类，它提供的方法主要有： 写入一个字符（0~65535）：void write(int c)； 写入字符数组的所有字符：void write(char[] c)； 写入String表示的所有字符：void write(String s)。 2、FileWriter 同样可以设置第三个参数，使其不进行覆盖写入： 123456789101112131415161718192021package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class WriterTest { public static void main(String[] args) throws IOException { try (Writer writer = new FileWriter(\"readme.txt\", StandardCharsets.UTF_8, true)) { writer.write('H'); // 写入单个字符 writer.write(\"Hello\".toCharArray()); // 写入char[] writer.write(\"Hello\"); // 写入String } try (Reader reader = new FileReader(\"readme.txt\")){ int n; while((n = reader.read()) != -1){ System.out.print((char) n); } } }} 3、CharArrayWriter CharArrayWriter可以在内存中创建一个Writer，它的作用实际上是构造一个缓冲区，可以写入char，最后得到写入的char[]数组： 12345678910111213141516package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class WriterTest { public static void main(String[] args) throws IOException { try (CharArrayWriter writer = new CharArrayWriter()) { writer.write(65); writer.write(66); writer.write(67); char[] data = writer.toCharArray(); System.out.print(data); // ABC } }} 4、StringWriter StringWriter也是一个基于内存的Writer，它和CharArrayWriter类似。实际上，StringWriter在内部维护了一个StringBuffer，并对外提供了Writer接口： 可以使用StringBuffer的所有方法，只是实现了一个writer接口： 1234567891011121314package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class WriterTest { public static void main(String[] args) throws IOException { try (StringWriter writer = new StringWriter()) { writer.write(\"hello world nxd\"); writer.append(\" last!\"); System.out.print(writer); } }} 5、OutputStreamWriter 除了CharArrayWriter和StringWriter外，普通的Writer实际上是基于OutputStream构造的，它接收char，然后在内部自动转换成一个或多个byte，并写入OutputStream。因此，OutputStreamWriter就是一个将任意的OutputStream转换为Writer的转换器： 12345try (Writer writer = new OutputStreamWriter(new FileOutputStream(\"readme.txt\"), StandardCharsets.UTF_8)) { // TODO: int n; writer.write(\"hello\");} 十一、PrintStream和PrintWriter1、PrintStream PrintStream和OutputStream相比，除了添加了一组print()/println()方法，可以打印各种数据类型，比较方便外，它还有一个额外的优点，就是不会抛出IOException，这样我们在编写代码的时候，就不必捕获IOException。 以及对应的一组println()方法，它会自动加上换行符。 我们经常使用的System.out.println()实际上就是使用PrintStream打印各种数据。其中，System.out是系统默认提供的PrintStream，表示标准输出. System.err是系统默认提供的标准错误输出。 PrintStream是一种FilterOutputStream，它在OutputStream的接口上，额外提供了一些写入各种数据类型的方法： 写入int：print(int) 写入boolean：print(boolean) 写入String：print(String) 写入Object：print(Object)，实际上相当于print(object.toString()) … 1234567891011package com.learn.file;public class PrintStreamTest { public static void main(String[] args) { System.out.print(12345); // 输出12345 System.out.print(new Object()); // 输出类似java.lang.Object@3c7a835a System.out.println(\"Hello\"); // 输出Hello并换行 System.err.println(\"hhh\"); }} 2、PrintWriter PrintStream最终输出的总是byte数据，而PrintWriter则是扩展了Writer接口，它的print()/println()方法最终输出的是char数据。两者的使用方法几乎是一模一样的： 12345678910111213141516package com.learn.file;import java.io.PrintWriter;import java.io.StringWriter;public class PrintWriterTest { public static void main(String[] args) { StringWriter buffer = new StringWriter(); try (PrintWriter pw = new PrintWriter(buffer)) { pw.println(\"Hello\"); pw.println(12345); pw.println(true); } System.out.println(buffer.toString()); }} 本章终于完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://niuxvdong.top/tags/IO/"},{"name":"File","slug":"File","permalink":"https://niuxvdong.top/tags/File/"}],"author":"Mr.Niu"},{"title":"Java教程系列之集合","slug":"Java教程系列之集合","date":"2020-04-07T08:23:56.000Z","updated":"2020-04-07T08:23:56.000Z","comments":true,"path":"posts/46100.html","link":"","permalink":"https://niuxvdong.top/posts/46100.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、Java集合介绍 在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合！ 数组就是一种集合： 123String[] ss = new String[10]; // 可以持有10个String对象ss[0] = \"Hello\"; // 可以放入String对象String first = ss[0]; // 可以获取String对象 1、数组的不足 数组初始化后大小不可变； 数组只能按索引顺序存取。 2、需要各种类型的集合 可变大小的顺序链表； 保证无重复元素的集合； … 3、Collection Collection，它是除Map外所有其他集合类的根接口，来自于java.util包！ 3.1 三种主要集合： List：一种有序列表的集合 Set：一种保证没有重复元素的集合 Map：一种通过键值（key-value）查找的映射表集合 3.2 Java集合的特点： 一是实现了接口和实现类相分离，例如，有序表的接口是List，具体的实现类有ArrayList，LinkedList等. 二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素. 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 只能放入String类型 3.3 集合访问（Iterator） Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。 Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。 3.4 不建议继续使用的集合由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用： Hashtable：一种线程安全的Map实现； Vector：一种线程安全的List实现； Stack：基于Vector实现的LIFO的栈。 还有一小部分接口是遗留接口，也不应该继续使用： Enumeration：已被Iterator取代。 二、使用List List是最基础的一种集合：它是一种有序链表。 1、数组的删除和添加 删除：删掉指定索引位置后将后面元素整体前移一位； 添加：将指定索引位置及之后元素后移一位，将新元素插入该位置； 可见：操作增删是很复杂的，需要人为介入去处理！ 2、ArrayList 把添加和删除的操作封装起来，让我们操作List类似于操作数组，却不用关心内部元素如何移动。 变成了自动操作！ 增删可以直接使用，已经封装为函数！ 数组已满时的操作： 先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组 3、List&lt;E&gt;接口主要的接口方法： 在末尾添加一个元素：void add(E e) 在指定索引添加一个元素：void add(int index, E e) 删除指定索引的元素：int remove(int index)：返回索引+1，从1开始计数！ 删除某个元素：int remove(Object e) 获取指定索引的元素：E get(int index) 获取链表大小（包含元素的个数）：int size() 4、ArrayList与LinkedList 都是List接口实现的实例类！ LinkedList相当于单链表，有前后的指针关系！ 通常情况下，我们总是优先使用ArrayList。 区别： ArrayList LinkedList 获取指定元素 速度很快 需要从头开始查找元素 添加元素到末尾 速度很快 速度很快 在指定位置添加/删除 需要移动元素 不需要移动元素 内存占用 少 较大 5、List的特点 元素可重复 允许添加null 123456789101112131415package com.learn.java;import java.util.ArrayList;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"hello\"); list.add(\"hello\"); list.add(null); System.out.println(list.size()); // 3 System.out.println(list.toString()); // [hello, hello, null] }} 6、创建List 通过List接口提供的of()方法，根据给定元素快速创建List： 但是List.of()方法不接受null值，如果传入null，会抛出NullPointerException异常。 123List&lt;String&gt; list1 = List.of(\"hello\", \"hello\", \"world\");// 无法传入null:List&lt;String&gt; list2 = List.of(null); 7、遍历List7.1 通过get方法遍历（不推荐） 缺点： 一是代码复杂； 二是因为get(int)方法只有ArrayList的实现是高效的，换成LinkedList后，索引越大，访问速度越慢。 12345678910111213141516package com.learn.java;import java.util.ArrayList;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"hello\"); list.add(\"hello\"); list.add(null); for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); } }} 7.2 通过Iterator遍历 使用迭代器Iterator来访问List。 Iterator本身也是一个对象，但它是由List的实例调用iterator()方法的时候创建的。 Iterator对象知道如何遍历一个List，并且不同的List类型，返回的Iterator对象实现也是不同的，但总是具有最高的访问效率。 两个方法： boolean hasNext()：判断是否有下一个元素 E next()：返回下一个元素 1234567891011121314151617package com.learn.java;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"hello\"); list.add(\"hello\"); list.add(null); for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ){ System.out.println(it.next()); } }} 7.3 通过for each遍历（推荐） 编译器内部其实会通过Iterator来实现遍历，达到最高效！ 和7.2的实现是一样的，但是更加简单使用，推荐使用！ 只要实现了Iterable接口的集合类都可以直接用for each循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把for each循环变成Iterator的调用，原因就在于Iterable接口定义了一个Iterator iterator()方法，强迫集合类必须返回一个Iterator实例。 12345678910111213141516package com.learn.java;import java.util.ArrayList;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"hello\"); list.add(\"hello\"); list.add(null); for (String s : list) { System.out.println(s); } }} 8、List转换为Array8.1 使用toArray()方法 调用toArray()方法直接返回一个Object[]数组： 这种方法会丢失类型信息，所以实际应用很少。 12List&lt;String&gt; list = List.of(\"apple\", \"pear\", \"banana\");Object[] array = list.toArray(); 8.2 使用toArray(T[])方法 给toArray(T[])传入一个类型相同的Array，List内部自动把元素复制到传入的Array中： 该方法的泛型参数&lt;T&gt;并不是List接口定义的泛型参数&lt;E&gt;！ 参数可传入实际类型及其父类： 12345678910111213141516171819package com.learn.java;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;Integer&gt; list = List.of(1, 3, 5); Number[] arr = list.toArray(new Number[3]); Object[] arr1 = list.toArray(new Object[3]); for (Number number : arr) { System.out.print(number + \" \"); } System.out.println(); for (Object o : arr1) { System.out.print(o + \" \"); } }} 如果传入的数组不够大，那么List内部会创建一个新的刚好够大的数组，填充后返回； 如果传入的数组比List元素还要多，那么填充完元素后，剩下的数组元素一律填充null。 8.3 传入恰好大小的数组12List&lt;Integer&gt; list = List.of(1, 3, 5);Integer[] array = list.toArray(new Integer[list.size()]); 8.4 使用函数式写法 更简洁的写法是通过List接口定义的T[] toArray(IntFunction generator)方法： 函数式写法后面会讲到： 1Integer[] array = list.toArray(Integer[]::new); 9、Array转换为List 直接借助List.of()方法： 12345Integer[] array = { 1, 2, 3 };List&lt;Integer&gt; list = List.of(array);// jdk11之前可以这样用：List&lt;Integer&gt; list = Arrays.asList(array); 使用List.of()方法返回的是一个只读的List，无法调用add和remove等方法！ 会抛出UnsupportedOperationException。 1234567// 正确：List&lt;Integer&gt; lis = new ArrayList&lt;&gt;();lis.add(3);// 抛出错误：List&lt;Integer&gt; list = List.of(1, 3, 5);list.add(5); 三、编写equals方法1、contains 和 indexOf方法 List还提供了boolean contains(Object o)方法来判断List是否包含某个指定元素. int indexOf(Object o)方法可以返回某个元素的索引，如果元素不存在，就返回-1。 12345678910111213package com.learn.java;import java.util.List;public class Equals { public static void main(String[] args) { List&lt;String&gt; list = List.of(\"A\", \"B\", \"C\"); System.out.println(list.contains(\"C\")); // true System.out.println(list.contains(\"X\")); // false System.out.println(list.indexOf(\"C\")); // 2 System.out.println(list.indexOf(\"X\")); // -1 }} 2、判断两个元素相等 传入不同的实例，仍然可以通过下面两个函数比较得到结果： 因为List内部并不是通过==判断两个元素是否相等，而是使用equals()方法判断两个元素是否相等： Java标准中的引用类型定义的类已经正确实现了equals方法！ 所以自定义的类需要手动覆写equals方法； 12System.out.println(list.contains(new String(\"C\"))); // trueSystem.out.println(list.indexOf(new String(\"C\"))); // 2 3、编写equals方法3.1 equals方法需要满足的条件 自反性（Reflexive）：对于非null的x来说，x.equals(x)必须返回true； 对称性（Symmetric）：对于非null的x和y来说，如果x.equals(y)为true，则y.equals(x)也必须为true； 传递性（Transitive）：对于非null的x、y和z来说，如果x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)也必须为true； 一致性（Consistent）：对于非null的x和y来说，只要x和y状态不变，则x.equals(y)总是一致地返回true或者false； 对null的比较：即x.equals(null)永远返回false。 3.2 equals方法编写步骤 先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等； 用instanceof判断传入的待比较的Object是不是当前类型，如果是，继续比较，否则，返回false； 对引用类型用Objects.equals()比较，对基本类型直接用==比较。 对于引用字段比较，我们使用equals()，对于基本类型字段的比较，我们使用==。 使用instanceof来判断两个对象类型是否一致！当然参数为当前对象子类时也可以进入判断！ 普通方法编写： 要判断null的特殊情况！ 123456789101112131415161718192021public class Person { public String name; public int age; public boolean equals(Object o) { if (o instanceof Person) { Person p = (Person) o; boolean nameEquals = false; // 都是null返回true if (this.name == null &amp;&amp; p.name == null) { nameEquals = true; } if (this.name != null) { nameEquals = this.name.equals(p.name); } return nameEquals &amp;&amp; this.age == p.age; } return false; } } 借助Objects.equals()方法判断 使用Objects.equals()比较两个引用类型是否相等的目的是省去了判断null的麻烦。两个引用类型都是null时它们也是相等的。 12345678910111213public class Person { public String name; public int age; public boolean equals(Object o) { if (o instanceof Person) { Person p = (Person) o; return Objects.equals(this.name, p.name) &amp;&amp; this.age == p.age; } return false; } } 4、什么时候需要编写equals方法如果不调用List的contains()、indexOf()这些方法，那么放入的元素就不需要实现equals()方法。 总而言之：不需要进行元素的比较就不需要编写！ 四、使用Map Map是一种键值（key-value）映射表的数据结构，作用就是能高效通过key快速查找value（元素）。 Map和List一样也是一个接口，最常用的实现类是HashMap。 1、常用方法 V put(K key, V value)：存储键值对，没有键时返回null，有键时返回旧的value，新的覆盖旧的！ V get(K key)：获取键对应的值！ boolean containsKey(K key)：查询键是否存在！ 123456789101112131415161718import java.util.HashMap;import java.util.Map;public class Main { public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"apple\", 123); map.put(\"pear\", 456); System.out.println(map.get(\"apple\")); // 123 map.put(\"apple\", 789); // 再次放入apple作为key，但value变为789 System.out.println(map.get(\"apple\")); // 789 // 当然：value可重复 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"apple\", 123); map.put(\"pear\", 123); // ok }} 2、Map遍历 Map存储的是key-value的映射关系，并且，它不保证顺序，即遍历的顺序是不确定的！ 三种遍历如下： 1234567891011121314151617181920212223242526package com.learn.java;import java.util.HashMap;import java.util.Map;public class MapTest { public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"niu\", 20); map.put(\"ge\", 30); map.put(\"hello\", 30); // 遍历key for(String key : map.keySet()){ System.out.println(key); } // 遍历value for(Integer value : map.values()){ System.out.println(value); } // 遍历key-value for(Map.Entry&lt;String, Integer&gt; entry : map.entrySet()){ System.out.println(entry.getKey() + \" \" + entry.getValue()); } }} 3、高效查找例子 List来存储所有信息，Map来存储经常需要查询的信息！提高查找效率！ 现在Map中找，找到直接返回，找不到再从List中找，找到将这组信息放入Map，并返回该信息！ Map永远存储最常用的信息，极大提高效率！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.learn.java;import java.util.HashMap;import java.util.List;import java.util.Map;public class MapWork { public static void main(String[] args) { List&lt;Student&gt; list = List.of( new Student(\"Bob\", 78), new Student(\"Alice\", 85), new Student(\"Brush\", 66), new Student(\"Newton\", 99)); var holder = new Students(list); System.out.println(holder.getScore(\"Bob\") == 78 ? \"测试成功!\" : \"测试失败!\"); System.out.println(holder.getScore(\"Alice\") == 85 ? \"测试成功!\" : \"测试失败!\"); System.out.println(holder.getScore(\"Tom\") == -1 ? \"测试成功!\" : \"测试失败!\"); }}class Students { List&lt;Student&gt; list; Map&lt;String, Integer&gt; cache; Students(List&lt;Student&gt; list) { this.list = list; cache = new HashMap&lt;&gt;(); } /** * 根据name查找score，找到返回score，未找到返回-1 */ Integer getScore(String name) { // 先在Map中查找: Integer score = this.cache.get(name); if (score == null) { // TODO: score = findInList(name); if(score != null){ cache.put(name, score); } } return score == null ? -1 : score; } Integer findInList(String name) { for (var ss : this.list) { if (ss.name.equals(name)) { return ss.score; } } return null; }}class Student { String name; int score; Student(String name, int score) { this.name = name; this.score = score; }} 五、编写hashCode和equals方法 当然是针对HashMap的，get方法查找的时候HashMap内部要进行比对，通过equals方法，编写方法同第三大节的编写equals方法，当自定义的类出现时，就需要去覆写equals方法。 在Map的内部，对key做比较是通过equals()实现的，这一点和List查找元素需要正确覆写equals()是一样的，即正确使用Map必须保证：作为key的对象必须正确覆写equals()方法。 Map内部是通过hashCode()方法来计算key对应的value的索引， 正确使用Map必须保证： 作为key的对象必须正确覆写equals()方法，相等的两个key实例调用equals()必须返回true； 作为key的对象还必须正确覆写hashCode()方法，且hashCode()方法要严格遵循以下规范： 如果两个对象相等，则两个对象的hashCode()必须相等； 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。 第一条规范是正确性，必须保证实现，否则HashMap不能正常工作。 而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的hashCode()，会造成Map内部存储冲突，使存取的效率下降。 1、equals方法覆写同第三节的编写equals方法！ 2、编写hashCode方法 当然还是针对自定义类的覆写，标准库的类，java内部已经实现！ 2.1 实现原理 此方法并没有处理参数为null的问题，要想写完整需要加上关于null的判断！ 在计算Person的hashCode()时，反复使用31*h，这样做的目的是为了尽量把不同的Person实例的hashCode()均匀分布到整个int范围。 1234567891011121314public class Person { String firstName; String lastName; int age; @Override int hashCode() { int h = 0; h = 31 * h + firstName.hashCode(); h = 31 * h + lastName.hashCode(); h = 31 * h + age; return h; }} 2.2 使用Objects.hash方法 直接借助Objects.hash()方法，自动实现null的处理； 123int hashCode() { return Objects.hash(firstName, lastName, age);} 2.3 编写原则 equals()用到的用于比较的每一个字段，都必须在hashCode()中用于计算； equals()中没有使用到的字段，绝不可放在hashCode()中计算。 另外注意，对于放入HashMap的value对象，没有任何要求。 2.4 完整示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.learn.java;import java.util.HashMap;import java.util.Map;import java.util.Objects;public class HashCode { public static void main(String[] args) { Map&lt;Persons, String&gt; map = new HashMap&lt;&gt;(); map.put(new Persons(\"hello1\", \"world1\", 20), \"first\"); map.put(new Persons(\"hello2\", \"world2\", 21), \"second\"); map.put(new Persons(\"hello3\", \"world3\", 22), \"three\"); String str = map.get(new Persons(\"hello2\", \"world2\", 21)); System.out.println(str); // second Persons key = new Persons(\"hello2\", \"world2\", 21); int index = key.hashCode() &amp; 0xf; System.out.println(index); // 4 }}class Persons { String firstName; String lastName; int age; Persons(String firstName, String lastName, int age){ this.firstName = firstName; this.lastName = lastName; this.age = age; } @Override public boolean equals(Object o){ if(o instanceof Persons){ Persons p = (Persons) o; return Objects.equals(this.firstName, p.firstName) &amp;&amp; Objects.equals(this.lastName, p.lastName) &amp;&amp; this.age == p.age; } return false; } /*@Override // 普通方法： public int hashCode() { int h = 0; h = 31 * h + firstName.hashCode(); h = 31 * h + lastName.hashCode(); h = 31 * h + age; return h; }*/ @Override public int hashCode(){ return Objects.hash(firstName, lastName, age); }} 3、hashCode延伸 HashMap内部使用了数组，通过计算key的hashCode()直接定位value所在的索引！ 3.1 HashMap的数组变化HashMap初始化时默认的数组大小只有16，索引为在0～15，超过范围，自动扩容为原来的二倍，即长度为16的数组扩展为长度32，相应地，需要重新确定hashCode()计算的索引位置。 扩容会导致重新分布已有的key-value，所以，频繁扩容对HashMap的性能影响很大，所以在创建时就指定容量！ 虽然指定容量是10000，但HashMap内部的数组长度总是2n，因此，实际数组长度被初始化为比10000大的16384（214）。 1234567Persons key = new Persons(\"hello2\", \"world2\", 21);// 调用hashCode方法与容量做按位与获取value下标：int index = key.hashCode() &amp; 0xf;System.out.println(index);// 在创建时指定容量：Map&lt;String, Integer&gt; maps = new HashMap&lt;&gt;(10000); 3.2 hashCode计算得到的索引相同 若计算出的数组索引相同，并不会发生覆盖现象，只要key不相同，它们映射的value就互不干扰！ 假设\"a\"和\"b\"这两个key最终计算出的索引都是5，那么，在HashMap的数组中，实际存储的不是一个Person实例，而是一个List，它包含两个Entry，一个是\"a\"的映射，一个是\"b\"的映射！ HashMap内部通过\"a\"找到的实际上是List&gt;，它还需要遍历这个List，并找到一个Entry，它的key字段是\"a\"，才能返回对应的Person实例！ 我们把不同的key具有相同的hashCode()的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用List存储hashCode()相同的key-value。显然，如果冲突的概率越大，这个List就越长，Map的get()方法效率就越低，这就是为什么要尽量满足条件二： 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。 12map.put(\"a\", new Person(\"Xiao Ming\"));map.put(\"b\", new Person(\"Xiao Hong\")); 六、使用EnumMap HashMap是一种通过对key计算hashCode()，通过空间换时间的方式，直接定位到value所在的内部数组的索引，因此，查找效率非常高。 如果作为key的对象是enum类型，那么，还可以使用Java集合库提供的一种EnumMap，它在内部以一个非常紧凑的数组存储value，并且根据enum类型的key直接定位到内部数组的索引，并不需要计算hashCode()，不但效率最高，而且没有额外的空间浪费。 使用EnumMap的时候，我们总是用Map接口来引用它，因此，实际上把HashMap和EnumMap互换，在客户端看来没有任何区别。 12345678910111213141516171819202122232425package com.learn.java;import java.time.DayOfWeek;import java.util.EnumMap;import java.util.Map;public class EnumMapTest { public static void main(String[] args) { // 参数作用：泛型擦除，方法内部从T拿不到class Map&lt;DayOfWeek, String&gt; map = new EnumMap&lt;&gt;(DayOfWeek.class); map.put(DayOfWeek.MONDAY, \"星期一\"); map.put(DayOfWeek.TUESDAY, \"星期二\"); map.put(DayOfWeek.WEDNESDAY, \"星期三\"); map.put(DayOfWeek.THURSDAY, \"星期四\"); map.put(DayOfWeek.FRIDAY, \"星期五\"); map.put(DayOfWeek.SATURDAY, \"星期六\"); map.put(DayOfWeek.SUNDAY, \"星期日\"); System.out.println(map); System.out.println(map.get(DayOfWeek.MONDAY)); /* {MONDAY=星期一, TUESDAY=星期二, WEDNESDAY=星期三, THURSDAY=星期四, FRIDAY=星期五, SATURDAY=星期六, SUNDAY=星期日} 星期一 */ }} 七、使用TreeMap HashMap是一种以空间换时间的映射表，它的实现原理决定了内部的Key是无序的，即遍历HashMap的Key时，其顺序是不可预测的（但每个Key都会遍历一次且仅遍历一次）。 还有一种Map，它在内部会对Key进行排序，这种Map就是SortedMap。 注意到SortedMap是接口，它的实现类是TreeMap。 1、Map的继承关系：1234567891011121314 ┌───┐ │Map│ └───┘ ▲ ┌────┴─────┐ │ │┌───────┐ ┌─────────┐│HashMap│ │SortedMap│└───────┘ └─────────┘ ▲ │ ┌─────────┐ │ TreeMap │ └─────────┘ 2、普通排序 使用TreeMap时，放入的Key必须实现Comparable接口。String、Integer这些类已经实现了Comparable接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。 123456789101112public class Main { public static void main(String[] args) { Map&lt;String, Integer&gt; map = new TreeMap&lt;&gt;(); map.put(\"orange\", 1); map.put(\"apple\", 2); map.put(\"pear\", 3); for (String key : map.keySet()) { System.out.println(key); } // apple, orange, pear }} 3、自定义类的排序 通过Comparable接口实现一个自定义排序算法： String类型通过compareTo()方法比较，int通过-比较！ 不需要覆写equals()和hashCode()，因为TreeMap不使用equals()和hashCode()。 在创建TreeMap时的参数中传入排序算法： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.learn.java;import java.util.Comparator;import java.util.Map;import java.util.TreeMap;public class TreeMapTest { public static void main(String[] args) { Map&lt;Person1, Integer&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Person1&gt;() { @Override public int compare(Person1 o1, Person1 o2) { return o1.name.compareTo(o2.name); } }); map.put(new Person1(\"Tom\"), 1); map.put(new Person1(\"Bob\"), 2); map.put(new Person1(\"Lily\"), 3); for(var key : map.keySet()){ System.out.println(key); } for(var entry : map.entrySet()){ System.out.println(entry.getKey() + \" \" + entry.getValue()); } System.out.println(map.get(new Person1(\"Lily\"))); // 3 }}class Person1{ public String name; Person1(String name){ this.name = name; } public String toString(){ return \"name: \" + name; }} 八、使用Properties 在编写应用程序的时候，经常需要读写配置文件！ 配置文件的特点是，它的Key-Value一般都是String-String类型的，因此我们完全可以用Map来表示它。 因为配置文件非常常用，所以Java集合库提供了一个Properties来表示一组“配置”。由于历史遗留原因，Properties内部本质上是一个Hashtable，但我们只需要用到Properties自身关于读写配置的接口。 1、读取配置文件 用Properties读取配置文件非常简单。Java默认配置文件以.properties为扩展名，每行以key=value表示，以#课开头的是注释。以下是一个典型的配置文件： 配置文件实例： 1234# setting.propertieslast_open_file=/data/hello.txtauto_save_interval=60 读取步骤： Properties读取配置文件，一共有三步： 创建Properties实例； 调用load()读取文件； 调用getProperty()获取配置。（如果key不存在，将返回null。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。） 也可以从classpath读取.properties文件，因为load(InputStream)方法接收一个InputStream实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流！ 1234567891011// 读取步骤：String f = \"setting.properties\";Properties props = new Properties();props.load(new java.io.FileInputStream(f));// 获取属性值：String filepath = props.getProperty(\"last_open_file\");String interval = props.getProperty(\"auto_save_interval\", \"120\");// 从classpath读取配置文件：Properties props = new Properties();props.load(getClass().getResourceAsStream(\"/common/setting.properties\")); 2、配置读取实例 从内存读取一个字节流： 123456789101112131415161718package com.learn.java;import java.io.ByteArrayInputStream;import java.util.Properties;public class PropertiesTest { public static void main(String[] args) throws Exception{ String settings = \"# test\" + \"\\n\" + \"course=Java\" + \"\\n\" + \"last_open_date=2019-08-07T12:35:01\"; ByteArrayInputStream input = new ByteArrayInputStream(settings.getBytes(\"UTF-8\")); Properties props = new Properties(); props.load(input); System.out.println(\"course: \" + props.getProperty(\"course\")); System.out.println(\"last_open_date: \" + props.getProperty(\"last_open_date\")); System.out.println(\"last_open_file: \" + props.getProperty(\"last_open_file\")); System.out.println(\"auto_save: \" + props.getProperty(\"auto_save\", \"60\")); }} 输出结果： 1234course: Javalast_open_date: 2019-08-07T12:35:01last_open_file: nullauto_save: 60 3、多配置文件 可以反复调用load()读取，后读取的key-value会覆盖已读取的key-value： 下面的代码演示了Properties的一个常用用法：可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。 123Properties props = new Properties();props.load(getClass().getResourceAsStream(\"/common/setting.properties\"));props.load(new FileInputStream(\"C:\\\\conf\\\\setting.properties\")); Properties设计的目的是存储String类型的key－value，但Properties实际上是从Hashtable派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了getProperty()和setProperty()方法外，还有从Hashtable继承下来的get()和put()方法，这些方法的参数签名是Object，我们在使用Properties的时候，不要去调用这些从Hashtable继承下来的方法。 4、写入配置文件 使用setProperty()方法修改Properties实例； 可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用store()方法！ 12345Properties props2 = new Properties();props2.setProperty(\"url\", \"https://niuxvdong.top/\");props2.setProperty(\"language\", \"Java\");//E:\\MyJavaProgram\\Settings 已写入我的E盘props2.store(new FileOutputStream(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\"), \"这是写入的properties注释\"); 结果如下： 第一行是“这是写入的properties注释”的Unicode编码！ 第二行是生成的时间： 后面是你设置的属性！ 1234#\\u8FD9\\u662F\\u5199\\u5165\\u7684properties\\u6CE8\\u91CA#Wed Apr 08 21:58:45 CST 2020url=https\\://niuxvdong.top/language=Java 5、编码 早期版本的Java规定.properties文件编码是ASCII编码（ISO8859-1），如果涉及到中文就必须用name=\\u4e2d\\u6587来表示，非常别扭。从JDK9开始，Java的.properties文件可以使用UTF-8编码了。 不过，需要注意的是，由于load(InputStream)默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法load(Reader)读取！ 就可以正常读取中文。InputStream和Reader的区别是一个是字节流，一个是字符流。字符流在内存中已经以char类型表示了，不涉及编码问题。 1234Properties props3 = new Properties();props3.load(new FileReader(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\", StandardCharsets.UTF_8));System.out.println(props3.getProperty(\"language\")); // JavaSystem.out.println(props3.getProperty(\"url\")); // https://niuxvdong.top/ 九、使用Set Map用于存储key-value的映射，对于充当key的对象，是不能重复的，并且，不但需要正确覆写equals()方法，还要正确覆写hashCode()方法。 如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用Set。 Set实际上相当于只存储key、不存储value的Map。我们经常用Set用于去除重复元素。 因为放入Set的元素和Map的key类似，都要正确实现equals()和hashCode()方法，否则该元素无法正确地放入Set。 1、常用方法 将元素添加进Set：boolean add(E e) 将元素从Set删除：boolean remove(Object e) 判断是否包含元素：boolean contains(Object e) 1234567891011121314151617package com.learn.java;import java.util.HashSet;import java.util.Set;public class SetTest { public static void main(String[] args) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); System.out.println(set.add(\"abc\")); // true System.out.println(set.add(\"xyz\")); // true System.out.println(set.add(\"xyz\")); // false，添加失败，因为元素已存在 System.out.println(set.contains(\"xyz\")); // true，元素存在 System.out.println(set.contains(\"XYZ\")); // false，元素不存在 System.out.println(set.remove(\"hello\")); // false，删除失败，因为元素不存在 System.out.println(set.size()); // 2，一共两个元素 }} 2、Set实现代码简化版 最常用的Set实现类是HashSet，实际上，HashSet仅仅是对HashMap的一个简单封装，它的核心代码如下： 123456789101112131415161718192021public class HashSet&lt;E&gt; implements Set&lt;E&gt; { // 持有一个HashMap: private HashMap&lt;E, Object&gt; map = new HashMap&lt;&gt;(); // 放入HashMap的value: private static final Object PRESENT = new Object(); public boolean add(E e) { // 放入成功会返回null，失败返回旧value return map.put(e, PRESENT) == null; } public boolean contains(Object o) { return map.containsKey(o); } public boolean remove(Object o) { // 删除成功返回value,失败返回null return map.remove(o) == PRESENT; }} 3、两种Set实现类 HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口； TreeSet是有序的，因为它实现了SortedSet接口。 继承关系如下： 1234567891011121314 ┌───┐ │Set│ └───┘ ▲ ┌────┴─────┐ │ │┌───────┐ ┌─────────┐│HashSet│ │SortedSet│└───────┘ └─────────┘ ▲ │ ┌─────────┐ │ TreeSet │ └─────────┘ 3.1 HashSet 是无序的，类似HashMap！ 自定义类同样需要实现equals() 和 hashCode()方法！ 3.2 TreeSet 实现了SortedSet接口！ 自定义类必须正确实现Comparable接口！ TreeSet不需要覆写equals()和hashCode()方法： 关于TreeSet不需要覆写两个方法！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.learn.java;import java.util.Comparator;import java.util.Set;import java.util.TreeSet;public class TreeSetTest { public static void main(String[] args) { Set&lt;Person2&gt; set = new TreeSet&lt;&gt;(new Comparator&lt;Person2&gt;() { @Override public int compare(Person2 o1, Person2 o2) { if(o1.age != o2.age) return o1.age - o2.age; else return o1.name.compareTo(o2.name); } }); set.add(new Person2(\"hello\", 25)); set.add(new Person2(\"world\", 25)); set.add(new Person2(\"abc\", 30)); set.add(new Person2(\"abc\", 30)); for (var p : set){ System.out.println(p.toString()); } }}class Person2{ public String name; public int age; Person2(String name, int age){ this.age = age; this.name = name; } @Override public String toString(){ return this.name + \" \" + this.age; } /* 不需要覆写： @Override public boolean equals(Object o){ if(o instanceof Person2){ Person2 p = (Person2) o; return Objects.equals(this.name, p.name) &amp;&amp; this.age == p.age; } return false; } @Override public int hashCode(){ return Objects.hash(name, age); }*/} 4、一个去重例子 在聊天软件中，发送方发送消息时，遇到网络超时后就会自动重发，因此，接收方可能会收到重复的消息，在显示给用户看的时候，需要首先去重，使用Set去重！ 注释中的两种方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.learn.java;import java.util.*;public class TreeSetTest02 { public static void main(String[] args){ List&lt;Message&gt; received = List.of( new Message(1, \"Hello!\"), new Message(2, \"发工资了吗？\"), new Message(2, \"发工资了吗？\"), new Message(3, \"去哪吃饭？\"), new Message(3, \"去哪吃饭？\"), new Message(4, \"Bye\") ); List&lt;Message&gt; displayMessages = process(received); for (Message message : displayMessages) { System.out.println(message.text); } } static List&lt;Message&gt; process(List&lt;Message&gt; received) { // TODO: 按sequence去除重复消息 // 方法一：通过覆写equals和hashCode方法，来使用Set去重 /*Set&lt;Message&gt; set = new HashSet&lt;&gt;(); List&lt;Message&gt; ls = new ArrayList&lt;&gt;(); for(var list : received) { if (set.add(list)) ls.add(list); } return ls;*/ // 方法二：使用TreeSet进行去重，不需要覆写那两个方法：当然必须实现一个Comparator方法 Set&lt;Message&gt; set = new TreeSet&lt;&gt;(new Comparator&lt;Message&gt;() { @Override public int compare(Message o1, Message o2) { // 这里随便，按照sequence从小到大排 return o1.sequence - o2.sequence; } }); // 将原List放入TreeSet自动实现去重 set.addAll(received); // 返回一个由Set构造的List return new ArrayList&lt;Message&gt;(set); }}class Message { public final int sequence; public final String text; public Message(int sequence, String text) { this.sequence = sequence; this.text = text; } /* 方法一的覆写： @Override public boolean equals(Object o){ if(o instanceof Message){ Message m = (Message) o; return Objects.equals(this.text, m.text) &amp;&amp; this.sequence == m.sequence; } return false; } @Override public int hashCode(){ return Objects.hash(sequence, text); }*/} 十、使用Queue 队列（Queue）是一种经常使用的集合。Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作： 把元素添加到队列末尾； 从队列头部取出元素。 1、常用方法 int size()：获取队列长度； boolean add(E)/boolean offer(E)：添加元素到队尾； E remove()/E poll()：获取队首元素并从队列中删除； E element()/E peek()：获取队首元素但并不从队列中删除。 关于上面方法的区别： THROW EXCEPTION 返回false或null 添加元素到队尾 add(E e) boolean offer(E e) 取队首元素并删除 E remove() E poll() 取队首元素但不删除 E element() E peek() add方法超过队列容量会抛出异常，offer方法超过队列容量会返回false； remove方法删除空队列会抛出异常，poll方法删除空队列会返回null; …. 123456789101112131415161718192021222324252627package com.learn.java;import java.util.LinkedList;import java.util.Queue;public class QueueTest { public static void main(String[] args) { Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); System.out.println(queue.peek()); // null //System.out.println(queue.element()); // throws NoSuchElementException System.out.println(queue.poll()); // null //System.out.println(queue.remove()); // throws NoSuchElementException queue.offer(\"hello\"); queue.offer(\"world\"); queue.add(\"add\"); System.out.println(queue.size()); // 3 // 获取队首并删除 System.out.println(queue.remove()); // hello System.out.println(queue.poll()); // world // 获取队首不删除 System.out.println(queue.element()); // add System.out.println(queue.peek()); // add }} 2、注意点 注意：不要把null添加到队列中，否则poll()方法返回null时，很难确定是取到了null元素还是队列为空。 LinkedList即实现了List接口，又实现了Queue接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用： 1234// 这是一个List:List&lt;String&gt; list = new LinkedList&lt;&gt;();// 这是一个Queue:Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); 十一、使用PriorityQueue 用来实现“VIP插队”的业务！ PriorityQueue和Queue的区别在于，它的出队顺序与元素的优先级有关，对PriorityQueue调用remove()或poll()方法，返回的总是优先级最高的元素。 1、标准类的优先队列 所谓不需要实现Comparable接口，因为Java已经实现了这些标准类了！ String当然是按照字母顺序来排列的！ 12345678910111213141516package com.learn.java;import java.util.PriorityQueue;public class PriorityQueueTest01 { public static void main(String[] args) { PriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;(); pq.offer(\"hello\"); pq.offer(\"world\"); pq.offer(\"ababa\"); for(var s : pq){ System.out.println(s); } }} 2、自定义类的优先队列 和TreeSet一样，实现一个Comparator对象即可！ 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.learn.java;import java.util.Comparator;import java.util.PriorityQueue;public class PriorityQueueTest02 { public static void main(String[] args) { PriorityQueue&lt;User&gt; pq = new PriorityQueue&lt;User&gt;(new Comparator&lt;User&gt;() { @Override public int compare(User o1, User o2) { if(o1.age == o2.age){ return o1.name .compareTo(o2.name); } return o1.age - o2.age; } }); pq.offer(new User(\"hello\", 25)); pq.offer(new User(\"world\", 10)); pq.offer(new User(\"abcde\", 25)); pq.offer(new User(\"cfgeg\", 30)); while (!pq.isEmpty()){ System.out.println(pq.poll()); } }}class User{ public String name; public int age; User(String name, int age) { this.name = name; this.age = age; } @Override public String toString(){ return name + \" \" + age; }} 也可以这样写 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.learn.java;import java.util.Comparator;import java.util.PriorityQueue;import java.util.Queue;public class PriorityQueueTest03 { public static void main(String[] args) { Queue&lt;Users&gt; pq = new PriorityQueue&lt;Users&gt;(new UsersComparator()); pq.offer(new Users(\"hello\", 25)); pq.offer(new Users(\"world\", 10)); pq.offer(new Users(\"abcde\", 25)); pq.offer(new Users(\"cfgeg\", 30)); while (!pq.isEmpty()){ System.out.println(pq.poll()); } }}class UsersComparator implements Comparator&lt;Users&gt; { public int compare(Users o1, Users o2) { if(o1.age == o2.age){ return o1.name .compareTo(o2.name); } return o1.age - o2.age; }}class Users{ public String name; public int age; public Users(String name, int age) { this.name = name; this.age = age; } @Override public String toString(){ return name + \" \" + age; }} 十二、使用Deque Deque是一个接口，它的实现类有ArrayDeque和LinkedList。 LinkedList真是一个全能选手，它即是List，又是Queue，还是Deque的接口！ 两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名Deque。 1、常用方法 queue Deque 添加元素到队尾 add(E e) / offer(E e) addLast(E e) / offerLast(E e) 取队首元素并删除 E remove() / E poll() E removeFirst() / E pollFirst() 取队首元素但不删除 E element() / E peek() E getFirst() / E peekFirst() 添加元素到队首 无 addFirst(E e) / offerFirst(E e) 取队尾元素并删除 无 E removeLast() / E pollLast() 取队尾元素但不删除 无 E getLast() / E peekLast() 1234567891011121314151617package com.learn.java;import java.util.Deque;import java.util.LinkedList;public class DequeTest01 { public static void main(String[] args) { Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); deque.offerLast(\"A\"); // A deque.offerLast(\"B\"); // B -&gt; A deque.offerFirst(\"C\"); // B -&gt; A -&gt; C System.out.println(deque.pollFirst()); // C, 剩下B -&gt; A System.out.println(deque.pollLast()); // B System.out.println(deque.pollFirst()); // A System.out.println(deque.pollFirst()); // null }} 2、一些建议 Deque接口实际上扩展自Queue！Queue提供的add()/offer()方法在Deque中也可以使用，但是，使用Deque，最好不要调用offer()，而是调用offerLast()： 123public interface Deque&lt;E&gt; extends Queue&lt;E&gt; { ...} 不要使用接口去实例化 尽量持有接口，而不是具体的实现类。 123456// 不推荐的写法:LinkedList&lt;String&gt; d1 = new LinkedList&lt;&gt;();d1.offerLast(\"z\");// 推荐的写法：Deque&lt;String&gt; d2 = new LinkedList&lt;&gt;();d2.offerLast(\"z\"); 十三、使用Stack 栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。 Stack只有入栈和出栈的操作： 把元素压栈：push(E)； 把栈顶的元素“弹出”：pop(E)； 取栈顶元素但不弹出：peek(E)。 在Java中，我们用Deque可以实现Stack的功能： 把元素压栈：push(E)/addFirst(E)； 把栈顶的元素“弹出”：pop(E)/removeFirst()； 取栈顶元素但不弹出：peek(E)/peekFirst()。 Java的集合类没有单独的Stack接口呢？因为有个遗留类名字就叫Stack，出于兼容性考虑，所以没办法创建Stack接口，只能用Deque接口来“模拟”一个Stack了。 当我们把Deque作为Stack使用时，注意只调用push()/pop()/peek()方法，不要调用addFirst()/removeFirst()/peekFirst()方法，这样代码更加清晰。 不要使用遗留类Stack。使用Deque来实现Stack即可！ 1、一个例子 使用Stack实现十进制转化为十六进制： 1234567891011121314151617181920212223242526272829303132package com.learn.java;import java.util.Deque;import java.util.LinkedList;public class StackTest { public static void main(String[] args) { String hex = toHex(12500); if (hex.equalsIgnoreCase(\"30D4\")) { System.out.println(\"测试通过\"); } else { System.out.println(\"测试失败\"); } } static String toHex(int n) { Deque&lt;String&gt; stack = new LinkedList&lt;&gt;(); String[] str = {\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"}; while(n != 0){ int t = n % 16; n /= 16; stack.push(str[t]); } StringBuilder s = new StringBuilder(); while(!stack.isEmpty()) { s.append(stack.pop()); } return s.toString(); }} 十四、使用Iterator1、for each遍历的实现 Java编译器并不知道如何遍历List。上述代码能够编译通过，只是因为编译器把for each循环通过Iterator改写为了普通的for循环： 12345678910List&lt;String&gt; list = List.of(\"Apple\", \"Orange\", \"Pear\");for (String s : list) { System.out.println(s);}// 编译器编译为如下：for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) { String s = it.next(); System.out.println(s);} 2、迭代器 我们把这种通过Iterator对象遍历集合的模式称为迭代器。 使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。 这样一来，调用方就必须知道集合的内部存储结构。并且，如果把ArrayList换成LinkedList，get(int)方法耗时会随着index的增加而增加。如果把ArrayList换成Set，上述代码就无法编译，因为Set内部没有索引。 用Iterator遍历就没有上述问题，因为Iterator对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的for each循环自动转换为Iterator遍历。 3、编写Iterator我们自己编写了一个集合类，想要使用for each循环，只需满足以下条件： 集合类实现Iterable接口，该接口要求返回一个Iterator对象； 用Iterator对象迭代集合内部数据。 这里的关键在于，集合类通过调用iterator()方法，返回一个Iterator对象，这个对象必须自己知道如何遍历该集合。 一个例子：实现List逆序的迭代器！ 稍有点复杂，要记得多看多练多查资料！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.learn.java;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class IteratorTest { public static void main(String[] args) { ReverseList&lt;String&gt; rlist = new ReverseList&lt;&gt;(); rlist.add(\"Apple\"); rlist.add(\"Orange\"); rlist.add(\"Pear\"); for (String s : rlist) { System.out.println(s); } }}class ReverseList&lt;T&gt; implements Iterable&lt;T&gt; { // 内部使用List存储 private List&lt;T&gt; list = new ArrayList&lt;&gt;(); public void add(T t) { list.add(t); } @Override // 覆写Iterator方法： public Iterator&lt;T&gt; iterator() { return new ReverseIterator(list.size()); } // 实现迭代器：内部类： class ReverseIterator implements Iterator&lt;T&gt; { int index; // 内部类构造方法： ReverseIterator(int index) { this.index = index; } @Override // 覆写hasNext public boolean hasNext() { return index &gt; 0; } @Override // 覆写next public T next() { index--; // 从index输出，即从后向前，访问外部类ReverseList的list的get方法来获取元素： return ReverseList.this.list.get(index); } }} 十五、使用Collections Collection，它是除Map外所有其他集合类的根接口，来自于java.util包！ Collections是JDK提供的工具类，同样位于java.util包中。它提供了一系列静态方法，能更方便地操作各种集合。 注意Collections结尾多了一个s，不是Collection！ 1、addAll方法 方法可以给一个Collection类型的集合添加若干元素。因为方法签名是Collection，所以我们可以传入List，Set等各种集合类型。 1public static boolean addAll(Collection&lt;? super T&gt; c, T... elements) { ... } 1234567891011121314151617package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; list2 = List.of(\"hello\", \"world\", \"hello\"); // 1. 分开写 /*Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.addAll(list2);*/ // 2.直接可以合并 Set&lt;String&gt; set1 = new HashSet&lt;&gt;(list2); for(var s : set1){ System.out.println(s); } }} 2、创建空集合 创建空List：List emptyList() 创建空Map：Map emptyMap() 创建空Set：Set emptySet() 要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。 其他类还可以用类.of()方法来创建空集合！ 12345678910111213package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; list = Collections.emptyList(); List&lt;String&gt; list1 = List.of(); list.add(\"hello\"); // throws UnsupportedOperationException list1.add(\"hello\"); // throws UnsupportedOperationException Map&lt;String, Integer&gt; map = Collections.emptyMap(); }} 3、创建单元素集合 创建一个元素的List：List singletonList(T o) 创建一个元素的Map：Map singletonMap(K key, V value) 创建一个元素的Set：Set singleton(T o) 要注意到返回的单元素集合也是不可变集合，无法向其中添加或删除元素。 也可以用各个集合接口提供的of(T...)方法创建单元素集合 使用of()方法创建的都是不变集合，无法进行增删！ 使用of()方法可以实现任意大小的不变集合，比Collections更加方便！ 12345678910List&lt;String&gt; list5 = List.of(\"apple\");List&lt;String&gt; list6 = Collections.singletonList(\"apple\");list5.add(\"hhh\"); // UnsupportedOperationExceptionList&lt;String&gt; list7 = List.of(); // empty list List&lt;String&gt; list8 = List.of(\"apple\"); // 1 elementList&lt;String&gt; list3 = List.of(\"apple\", \"pear\"); // 2 elementsList&lt;String&gt; list4 = List.of(\"apple\", \"pear\", \"orange\"); // 3 elementslist3.add(\"hello\"); // UnsupportedOperationException 4、排序 Collections可以对List进行排序。因为排序会直接修改List元素的位置，因此必须传入可变List： 只能对List排序！ 1234567891011121314151617package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; list01 = new ArrayList&lt;&gt;(); list01.add(\"apple\"); list01.add(\"pear\"); list01.add(\"orange\"); // 排序前: System.out.println(list01); // [apple, pear, orange] Collections.sort(list01); // 排序后: System.out.println(list01); // [apple, orange, pear] }} 5、洗牌算法 Collections提供了洗牌算法，即传入一个有序的List，可以随机打乱List内部元素的顺序，效果相当于让计算机洗牌： 只针对List！ 1234567891011121314151617package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;Integer&gt; list02 = new ArrayList&lt;&gt;(); for (int i=0; i&lt;10; i++) { list02.add(i); } // 洗牌前: System.out.println(list02); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Collections.shuffle(list02); // 洗牌后: System.out.println(list02); // [5, 7, 1, 4, 9, 2, 6, 0, 8, 3] }} 6、不可变集合Collections还提供了一组方法把可变集合封装成不可变集合： 封装成不可变List：List unmodifiableList(List list) 封装成不可变Set：Set unmodifiableSet(Set set) 封装成不可变Map：Map unmodifiableMap(Map m) 下面这种情况可以用of()方法代替，不过其他情况就不一定了，必须使用该方法了！ 123456789101112131415package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; mutable = new ArrayList&lt;&gt;(); mutable.add(\"apple\"); mutable.add(\"pear\"); // 变为不可变集合: List&lt;String&gt; immutable = Collections.unmodifiableList(mutable); List&lt;String&gt; immutable = List.of(\"apple\", \"pear\"); immutable.add(\"orange\"); // UnsupportedOperationException! }} 继续对原始的可变List进行增删是可以的，并且，会直接影响到封装后的“不可变”List： 原List可修改，会影响到封装后的List！所以需要将原List扔掉！ 123456789101112131415161718package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; mutable = new ArrayList&lt;&gt;(); mutable.add(\"apple\"); mutable.add(\"pear\"); // 变为不可变集合: List&lt;String&gt; immutable = Collections.unmodifiableList(mutable); List&lt;String&gt; immutable = List.of(\"apple\", \"pear\"); immutable.add(\"orange\"); // UnsupportedOperationException! System.out.println(immutable); //[apple, pear] mutable.add(\"orange\"); System.out.println(immutable); //[apple, pear, orange] }} 扔掉原List 操作：将原List置为null即可！ 12345678910111213141516package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; mutable = new ArrayList&lt;&gt;(); mutable.add(\"apple\"); mutable.add(\"pear\"); // 变为不可变集合: List&lt;String&gt; immutable = Collections.unmodifiableList(mutable); // 立刻扔掉mutable的引用: mutable = null; System.out.println(immutable); //[apple, pear] }} 7、线程安全集合Collections还提供了一组方法，可以把线程不安全的集合变为线程安全的集合： 变为线程安全的List：List synchronizedList(List list) 变为线程安全的Set：Set synchronizedSet(Set s) 变为线程安全的Map：Map synchronizedMap(Map m) 多线程的概念我们会在后面讲。因为从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。 集合这一章完结，敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"集合","slug":"集合","permalink":"https://niuxvdong.top/tags/%E9%9B%86%E5%90%88/"}],"author":"Mr.Niu"},{"title":"Java教程系列之泛型","slug":"Java教程系列之泛型","date":"2020-04-04T10:27:50.000Z","updated":"2020-04-04T10:27:50.000Z","comments":true,"path":"posts/16438.html","link":"","permalink":"https://niuxvdong.top/posts/16438.html","excerpt":"","text":"一、泛型是什么 泛型就是编写模板代码来适应任意类型； 泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查； 1、以ArrayList举例 例如将其模板化： T可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的ArrayList： 编译器会针对定义类型进行检查： 12345678910111213141516171819public class ArrayList&lt;T&gt; { private T[] array; private int size; public void add(T e) {...} public void remove(int index) {...} public T get(int index) {...}}// 创建可以存储String的ArrayList:ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;();// 创建可以存储Float的ArrayList:ArrayList&lt;Float&gt; floatList = new ArrayList&lt;Float&gt;();// 创建可以存储Person的ArrayList:ArrayList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();strList.add(\"hello\"); // OKString s = strList.get(0); // OKstrList.add(new Integer(123)); // compile error!Integer n = strList.get(0); // compile error! 2、向上转型 Java标准库中的ArrayList实现了List接口，它可以向上转型为List： 12345public class ArrayList&lt;T&gt; implements List&lt;T&gt; { ...}List&lt;String&gt; list = new ArrayList&lt;String&gt;(); 3、特别注意 不能把ArrayList&lt;Integer&gt;向上转型为ArrayList&lt;Number&gt;或List&lt;Number&gt;。 我们把一个ArrayList转型为ArrayList类型后，这个ArrayList就可以接受Float类型，因为Float是Number的子类。但是，ArrayList实际上和ArrayList是同一个对象，也就是ArrayList类型，它不可能接受Float类型， 所以在获取Integer的时候将产生ClassCastException。 实际上，编译器为了避免这种错误，根本就不允许把ArrayList转型为ArrayList。 但是java14似乎连转型的第六行赋值都会报错。。。 12345678910// 创建ArrayList&lt;Integer&gt;类型：ArrayList&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;();// 添加一个Integer：integerList.add(new Integer(123));// “向上转型”为ArrayList&lt;Number&gt;：ArrayList&lt;Number&gt; numberList = integerList;// 添加一个Float，因为Float也是Number：numberList.add(new Float(12.34));// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：Integer n = integerList.get(1); // ClassCastException! 二、使用泛型1、泛型接口接口定义： 12345678public interface Comparable&lt;T&gt; { /** * 返回-1: 当前实例比参数o小 * 返回0: 当前实例与参数o相等 * 返回1: 当前实例比参数o大 */ int compareTo(T o);} 具体用法： 对Person0数组按年龄升序排列，年龄相同，按照姓名字典序排序！ 如果使用了泛型Comparable&lt;Person0&gt;则类内部必须进行compareTo的覆写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.hello;import java.util.Arrays;public class TYPE { public static void main(String[] args) { Person0[] list = new Person0[]{ new Person0(\"B\", 2), new Person0(\"A\", 3), new Person0(\"G\", 0), new Person0(\"A\", 2), new Person0(\"L\", 4) }; Arrays.sort(list); System.out.println(Arrays.toString(list)); // String 类型的排序，本身已经实现了Comparable接口： String[] str = {\"hello\", \"world\", \"hhhh\", \"wor\", \"adv\"}; Arrays.sort(str); System.out.println(Arrays.toString(str)); }}// 使用泛型覆写compareTo方法进行比较：class Person0 implements Comparable&lt;Person0&gt; { public String name; public int age; Person0(String name, int age){ this.name = name; this.age = age; } // 重构toString方法： public String toString(){ return this.name + \"-\" + this.age; } // 覆写compareTo方法： @Override public int compareTo(Person0 o) { if(this.age != o.age) return this.age - o.age; else return this.name.compareTo(o.name); }} 结果如下： 12[G-0, A-2, B-2, A-3, L-4][adv, hello, hhhh, wor, world] 三、编写泛型1、编写泛型 像这样，将需要的写类型的地方全部替换为T，类名称后面加一个&lt;T&gt;即可： 1234567891011121314public class Pair&lt;T&gt; { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { return first; } public T getLast() { return last; }} 2、静态方法 普通的方法是通过类的实例来调用的，创建实例的过程调用了构造方法，也就是说对象已经知道这个时候类上面定义的的具体类型了； 而静态方法不需要对象实例来调用，是直接通过类名调用的，两者必须得区分开来写：并且在static后面再加一个&lt;K&gt;： 123456789101112131415public class Pair&lt;T&gt; { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { ... } public T getLast() { ... } // 静态泛型方法应该使用其他类型区分: public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) { return new Pair&lt;K&gt;(first, last); }} 3、多参数泛型 同样的操作方法： Java标准库的Map就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。 123456789101112public class Pair&lt;T, K&gt; { private T first; private K last; public Pair(T first, K last) { this.first = first; this.last = last; } public T getFirst() { ... } public K getLast() { ... }}Pair&lt;String, Integer&gt; p = new Pair&lt;&gt;(\"test\", 123); 四、擦拭法 Java语言的泛型实现方式是擦拭法（Type Erasure）。 擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。 Java使用擦拭法实现泛型，导致了： 编译器把类型&lt;T&gt;视为Object； 编译器根据&lt;T&gt;实现安全的强制转型。 1、擦拭法过程编译器看到的代码： 123Pair&lt;String&gt; p = new Pair&lt;&gt;(\"Hello\", \"world\");String first = p.getFirst();String last = p.getLast(); 虚拟机看到的代码： 123Pair p = new Pair(\"Hello\", \"world\");String first = (String) p.getFirst();String last = (String) p.getLast(); 2、擦拭法实现泛型的局限 &lt;T&gt;不能是基本类型（必须是引用类型，因为会被编译器处理为Object） 无法取得带泛型的Class（获取到的Class是类的Class） 无法使用instanceof判断类型关系（同上一点原因） 不能实例化T类型 12345678910111213141516// 第一点：int和Object矛盾Pair&lt;int&gt; p = new Pair&lt;&gt;(1, 2); // compile error!// 第二点：都是Pair.class...Pair&lt;String&gt; p1 = new Pair&lt;&gt;(\"Hello\", \"world\");Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(123, 456);Class c1 = p1.getClass();Class c2 = p2.getClass();System.out.println(c1==c2); // trueSystem.out.println(c1==Pair.class); // true// 第三点：同第二点:Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);// Compile error:if (p instanceof Pair&lt;String&gt;.class) {} 第四点：创建new Pair&lt;String&gt;()和创建new Pair&lt;Integer&gt;()就全部成了Object，显然编译器要阻止这种类型不对的代码。 要实例化T类型，我们必须借助额外的Class&lt;T&gt;参数： 上述代码借助Class&lt;T&gt;参数并通过反射来实例化T类型，使用的时候，也必须传入Class&lt;T&gt; 1234567891011121314151617181920212223242526272829// 第四点：无法实例化public class Pair&lt;T&gt; { private T first; private T last; public Pair() { // Compile error: first = new T(); last = new T(); }}// 借助Class实例化：package com.hello;public class ClassInstance { public static void main(String[] args) throws Exception { PairOne&lt;String&gt; p = new PairOne&lt;&gt;(String.class); }}class PairOne &lt;T&gt; { public T first; public T second; PairOne(Class&lt;T&gt; clazz) throws Exception { first = clazz.newInstance(); second = clazz.newInstance(); }} 3、无法覆写 定义的equals(T t)方法实际上会被擦拭成equals(Object t)，而这个方法是继承自Object的，编译器会阻止一个实际上会变成覆写的泛型方法定义。 12345678910class PairOne &lt;T&gt; { // 无法覆写Object的方法:编译报错 public boolean equals(T t){ return this == t; } // 改名即可： public boolean equal(T t){ return this == t; }} 4、泛型继承 无法获取Pair&lt;T&gt;的T类型，即给定一个变量Pair&lt;String&gt; p，无法从p中获取到String类型。 但是，在父类是泛型类型的情况下，编译器就必须把类型T（对PairOne来说，也就是String类型）保存到子类的class文件中，不然编译器就不知道PairOne只能存取String这种类型。 在继承了泛型类型的情况下，子类可以获取父类的泛型类型。 实现方法如下； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.hello;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;public class ClassInstance { public static void main(String[] args) throws Exception { PairOne&lt;String&gt; p = new PairOne&lt;&gt;(String.class); // 获取父类的T类型： Class&lt;PairTwo&gt; cls = PairTwo.class; Type t = cls.getGenericSuperclass(); if(t instanceof ParameterizedType){ ParameterizedType pt = (ParameterizedType) t; Type[] types = pt.getActualTypeArguments(); Type firstType = types[0]; Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType; System.out.println(typeClass); } }}class PairOne &lt;T&gt; { public T first; public T second; PairOne(T first, T second){ this.first = first; this.second = second; } PairOne(Class&lt;T&gt; clazz) throws Exception { first = clazz.newInstance(); second = clazz.newInstance(); } // 无法覆写Object的方法 /*public boolean equals(T t){ return this == t; }*/ // 改名即可： public boolean equal(T t){ return this == t; }}class PairTwo extends PairOne&lt;String&gt;{ PairTwo(String first, String second) { super(first, second); }} Java 类型的结构图： 12345678910 ┌────┐ │Type│ └────┘ ▲ │ ┌────────────┬────────┴─────────┬───────────────┐ │ │ │ │┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐│Class││ParameterizedType││GenericArrayType││WildcardType│└─────┘└─────────────────┘└────────────────┘└────────────┘ 五、extends通配符 PairThree&lt;Number&gt;不是PairThree&lt;Ingeter&gt;的子类。 因为PairThree&lt;Number&gt;不是PairThree&lt;Ingeter&gt;的子类，因此，add(PairThree&lt;Number&gt;)不接受参数类型PairThree&lt;Integer&gt;。 1、无继承关系无法传参1234567891011121314151617181920212223242526272829303132333435package com.hello;public class Extends { public static void main(String[] args) { PairThree&lt;Number&gt; p = new PairThree&lt;&gt;(23, 89); System.out.println(add(p)); PairThree&lt;Integer&gt; i = new PairThree&lt;&gt;(23, 89); System.out.println(add(i));// 编程错误 } static int add(PairThree&lt;Number&gt; p){ Number first = p.getA(); Number second = p.getB(); return first.intValue() + second.intValue(); }}class PairThree &lt;T&gt; { private T a; private T b; public PairThree(T a, T b){ this.a = a; this.b = b; } public T getA() { return a; } public T getB() { return b; }} 很明显这里没什么毛病，属于向上转型，因为Integer向上转型为Number! 但是问题在add方法的参数上，PairThree&lt;Number&gt;是不可能接受PairThree&lt;Integer&gt;的，毕竟没有继承关系。。。 12Number first = p.getA();Number last = p.getB(); 2、通过extends通配符传继承子类 Java中的通配符：? 只要是Number的子类就可以进行传参： 使用&lt;? extends Number&gt;的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number了。 12345static int add(PairThree&lt;? extends Number&gt; p){ Number first = p.getA(); Number second = p.getB(); return first.intValue() + second.intValue();} 下面的赋值是无法通过的！ 编译器只是知道传入的是Number或其子类，并不知道到底是谁，具体类型无法确定！无法完成赋值！ 1Integer x = p.getFirst(); 3、extends通配符处理set方法 如此效果，也就是你只能对其进行获取，不能进行修改，极大保证了数据安全性！ 1234567891011static int addOne(PairThree&lt;? extends Number&gt; p){ Number first = p.getA(); Number second = p.getB(); // 当前p类型为PairThree&lt;? extends Number&gt; 无法传入除null之外的其他类型 // 报错 //p.setA(new Integer(123)); //p.setB(new Integer(345)); p.setA(null);// ok, 但是后面会抛出NullPointerException p.getA().intValue(); // NullPointerException return p.getA().intValue()+ p.getB().intValue();} 4、extends通配符作用 当然和上一点的安全性脱不了关系： 方法使用了通配符参数，有什么用呢？ 优点： 允许调用get()方法获取Integer的引用； 不允许调用set(? extends Integer)方法并传入任何Integer的引用（null除外）。 即通过通配符参数实现了List类的只读效果，保证了安全！ 123456789101112131415public interface List&lt;T&gt; { int size(); // 获取个数 T get(int index); // 根据索引获取指定元素 void add(T t); // 添加一个新元素 void remove(T t); // 删除一个已有元素}int sumOfList(List&lt;? extends Integer&gt; list) { int sum = 0; for (int i=0; i&lt;list.size(); i++) { Integer n = list.get(i); sum = sum + n; } return sum;} 5、使用extends通配符限定T类型 则在定义时只能是Number及其子类！ 其他类型将无法通过编译： 1public class Pair&lt;T extends Number&gt; { ... } 六、super通配符 和extends相反，extends通配符可以接收当前类以及子类，super通配符可以接收当前类及其父类： 但是无法通过当前类或其他类来接收当前获取到的值，除了Object对象： 很好理解：当前类型p是Integer本身或其父类，编译器无法确定到底是和类型，无法用一个Integer来接收Number，当然Object是可以接收的，所有类型都可以向上转型为Object对象！ 1、只能写不能读使用&lt;? super Integer&gt;通配符表示： 允许调用set(? super Integer)方法传入Integer的引用； 不允许调用get()方法获得Integer的引用。 唯一例外是可以获取Object的引用：Object o = p.getFirst()。 换句话说，使用&lt;? super Integer&gt;通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.hello;public class Super { public static void main(String[] args) { PairFive&lt;Integer&gt; p1 = new PairFive&lt;&gt;(123, 567); PairFive&lt;Number&gt; p2 = new PairFive&lt;&gt;(34, 69); setName(p1, 100); setName(p2, 200); System.out.println(p1.getA()); // 100 System.out.println(p2.getA()); // 200 } static void setName(PairFive&lt;? super Integer&gt; p, Integer n){ // 唯一可接受get方法的是Object Object oc = p.getA(); // 这样无法接收： Number nc = p.getA(); Integer ic = p.getA(); p.setA(n); p.setB(n); }}class PairFive &lt;T&gt; { private T a; private T b; public PairFive(T a, T b){ this.a = a; this.b = b; } public void setA(T a) { this.a = a; } public void setB(T b) { this.b = b; } public T getA() { return a; } public T getB() { return b; }} 2、extends 与 super 区别作为方法参数，&lt;? super T&gt;类型和&lt;? extends T&gt;类型的区别在于： &lt;? extends T&gt;允许调用读方法T get()获取T的引用，但不允许调用写方法set(T)传入T的引用（传入null除外）； &lt;? super T&gt;允许调用写方法set(T)传入T的引用，但不允许调用读方法T get()获取T的引用（获取Object除外）。 一个是允许读不允许写，另一个是允许写不允许读。 一个很好的例子： 作用：将src的元素全部添加到dest中： 这个copy()方法的定义就完美地展示了extends和super的意图： copy()方法内部不会读取dest，因为不能调用dest.get()来获取T的引用； copy()方法内部也不会修改src，因为不能调用src.add(T)。 倘若意外修改了src，或者意外读取了dest，就会导致一个编译错误： 12345678910111213141516171819202122232425package com.hello;import java.util.List;public class CollectionsTest { public static void main(String[] args) { }}class CollectionsDemo { // 把src的每个元素复制到dest中: public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { // 下面的循环可以用这句话替代： // dest.addAll(src); for (int i=0; i&lt;src.size(); i++) { T t = src.get(i); dest.add(t); } // 无法实现： T t = dest.get(0); // compile error! src.add(t); // compile error! }} 当然，也无法反过来添加： 这些都是通过super和extends通配符，并由编译器强制检查来实现的。 1234567// copy List&lt;Integer&gt; to List&lt;Number&gt; ok:List&lt;Number&gt; numList = ...;List&lt;Integer&gt; intList = ...;CollectionDemo.copy(numList, intList);// ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;:CollectionDemo.copy(intList, numList); 3、PECS 原则 何时使用extends，何时使用super？ 为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。 如果需要返回T，它是生产者（Producer），要使用extends通配符；如果需要写入T，它是消费者（Consumer），要使用super通配符。 任然使用这个例子： 12345678public class Collections { public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { for (int i=0; i&lt;src.size(); i++) { T t = src.get(i); // src是producer dest.add(t); // dest是consumer } }} 4、无界定通配符 即只定义一个&lt;?&gt;： 因为&lt;?&gt;通配符既没有extends，也没有super，因此： 不允许调用set(T)方法并传入引用（null除外）； 不允许调用T get()方法并获取T引用（只能获取Object引用）。 换句话说，既不能读，也不能写，那只能做一些null判断： 123static boolean isNull(Pair&lt;?&gt; p){ return p.getFirst() == null || p.getSecond() == null;} 大多数情况下，可以引入泛型参数&lt;T&gt;消除&lt;?&gt;通配符：(一般这样使用) 123static &lt;T&gt; boolean isNull(Pair&lt;T&gt; p) { return p.getFirst() == null || p.getSecond() == null;} &lt;?&gt;通配符有一个独特的特点，就是：Pair&lt;?&gt;是所有Pair&lt;T&gt;的超类(即父类)： 5、super通配符不能用于class 无法这样写： extends可以！ 123class demo &lt;T super Number&gt; {} 七、泛型与反射1、Class&lt;T&gt;是泛型123456789// 编译警告：可运行Class cls = String.class;String str0 = (String)cls.newInstance();// 无问题：Class&lt;String&gt; cl = String.class;String str = cl.newInstance();Class&lt;? super String&gt; sup = String.class.getSuperclass(); 2、Constructor&lt;T&gt;是泛型1234Class&lt;Integer&gt; clazz = Integer.class;Constructor&lt;Integer&gt; cons = clazz.getConstructor(int.class);Integer i = cons.newInstance(123);System.out.println(i); // 123 3、泛型数组创建 不能用new操作符创建带泛型的数组： 必须通过强制转型实现带泛型的数组： 可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型： 123456Pair&lt;String&gt;[] ps = null; // okPair&lt;String&gt;[] ps1 = new Pair&lt;String&gt;[2]; // compile error!// 正确使用：@SuppressWarnings(\"unchecked\")Pair&lt;String&gt;[] ps2 = (Pair&lt;String&gt;[]) new Pair[2]; 可以通过Array.newInstance(Class, int)创建T[]数组，需要强制转型： 廖雪峰教程，有点没看懂，以后再看！。。。 4、谨慎使用泛型可变参数 如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。 直接调用asArray(T...)似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生ClassCastException，原因还是因为擦拭法，在pickTwo()方法内部，编译器无法检测K[]的正确类型，因此返回了Object[]。 如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用@SafeVarargs消除警告。 12345678910111213141516171819202122package com.learn.java;import java.util.Arrays;public class Main01 { public static void main(String[] args) { String[] arr = asArray(\"one\", \"two\", \"three\"); System.out.println(Arrays.toString(arr)); // ClassCastException: String[] firstTwo = pickTwo(\"one\", \"two\", \"three\"); System.out.println(Arrays.toString(firstTwo)); } static &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) { return asArray(k1, k2); } @SafeVarargs static &lt;T&gt; T[] asArray(T... objs) { return objs; }} 输出结果： 123[one, two, three]Exception in thread \"main\" java.lang.ClassCastException: class [Ljava.lang.Object; cannot be cast to class [Ljava.lang.String; ([Ljava.lang.Object; and [Ljava.lang.String; are in module java.base of loader 'bootstrap') at com.learn.java.Main01.main(Main01.java:10) 泛型章节终于结束，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"泛型","slug":"泛型","permalink":"https://niuxvdong.top/tags/%E6%B3%9B%E5%9E%8B/"}],"author":"Mr.Niu"},{"title":"Java教程系列之注解","slug":"Java教程系列之注解","date":"2020-04-02T09:50:48.000Z","updated":"2020-04-02T09:50:48.000Z","comments":true,"path":"posts/35258.html","link":"","permalink":"https://niuxvdong.top/posts/35258.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、什么是注解 注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释” 注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。 注解的作用 从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定： Java的注解可以分为三类： 由编译器使用的注解 由工具处理.class文件使用的注解 在程序运行期能够读取的注解 第一类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。 第二类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。 第三类加载后一直存在于JVM中，这也是最常用的注解 注解的参数： 所有基本类型； String； 枚举类型； 基本类型、String以及枚举的数组。 因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。 注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。 此外，大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。 如果只写注解，相当于全部使用默认值。 二、定义注解1、如何定义注解（Annotation） 用@interface定义注解 添加参数、默认值 用元注解配置注解 必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。 注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。 12345678910// 第三步：@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)// 第一步：public @interface Report { // 第二步： int type() default 0; String level() default \"info\"; String value() default \"\";} 2、元注解 有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。 target 使用@Target可以定义Annotation能够被应用于源码的哪些位置： 实际上@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法。 类或接口：ElementType.TYPE； 字段：ElementType.FIELD； 方法：ElementType.METHOD； 构造方法：ElementType.CONSTRUCTOR； 方法参数：ElementType.PARAMETER。 123456789// 一个参数：@Target(ElementType.METHOD)// 多个参数：@Target({ElementType.TYPE, ElementType.METHOD})public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\";} Retention 定义了Annotation的生命周期： 如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解 仅编译期：RetentionPolicy.SOURCE； 仅class文件：RetentionPolicy.CLASS； 运行期：RetentionPolicy.RUNTIME。 123456@Retention(RetentionPolicy.RUNTIME)public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\";} Repeatable 可以定义Annotation是否可重复。这个注解应用不是特别广泛。 123456789101112131415161718192021222324// 参数为重复类的Class@Repeatable(Hellos.class)//@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE, ElementType.METHOD})@interface Hello { int type() default 0; String level() default \"info\"; String value() default \"\";}@Target(ElementType.TYPE)@interface Hellos{ Hello[] value();}// 重复注解：@Hello(type = 1, level = \"debug\", value = \"test\")@Hello(type = 2, level = \"warning\", value = \"warn\")@Hello(type = 3, value = \"niu\")class Test{} Inherited 使用@Inherited定义子类是否可继承父类定义的Annotation。 @Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效 123456789101112131415161718@Inherited@Target(ElementType.TYPE)@interface Hello { int type() default 0; String level() default \"info\"; String value() default \"\";}@Hello(type = 1, level = \"debug\", value = \"test\")class Test{}class TestSon extends Test{} 三、处理注解根据@Retention的配置 如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。 只有RUNTIME类型的注解不但要使用，还经常需要编写。 因此，我们只讨论如何读取RUNTIME类型的注解。 注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。 1、使用反射读取注解Java提供的使用反射API读取Annotation的方法包括： 判断某个注解是否存在于Class、Field、Method或Constructor： Class.isAnnotationPresent(Class) Field.isAnnotationPresent(Class) Method.isAnnotationPresent(Class) Constructor.isAnnotationPresent(Class) 使用反射API读取Annotation： Class.getAnnotation(Class) Field.getAnnotation(Class) Method.getAnnotation(Class) Constructor.getAnnotation(Class) 先判断Annotation是否存在再读取注解及类的定义： 12345678910111213141516171819@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@interface Hello { int type() default 0; String level() default \"info\"; String value() default \"\";}@Target(ElementType.TYPE)@interface Hellos{ Hello[] value();}@Hello(type = 1, level = \"debug\", value = \"test\")class Test{} 1234567Class cls = Test.class;if(cls.isAnnotationPresent(Hello.class)){ Hello hello = (Hello) cls.getAnnotation(Hello.class); System.out.println(hello.level()); // debug System.out.println(hello.type()); // 1 System.out.println(hello.value()); // test} 直接读取Annotation，不存在返回null1234567Class cls1 = Test.class;Hello hello = (Hello) cls1.getAnnotation(Hello.class);if(hello != null){ System.out.println(hello.level()); // debug System.out.println(hello.type()); // 1 System.out.println(hello.value()); // test} 读取方法参数的注解 有点没看懂。。先搁这里！点击这里查看！ 2、注解的使用 注解好处：再需要检查的字段或方法前加上再写一个Check方法即可实现所有检查！ 提高了效率： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.hello;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Field;public class Annotation1 { public static void main(String[] args){ Person p1 = new Person(\"niuge\", \"xinzhou\"); Person p2 = new Person(\"niuge\", \"shanxixinzhou\"); for(Person p : new Person[]{p1, p2}){ try{ Check(p); System.out.println(\"String 参数无误！\"); }catch (IllegalAccessException e){ System.out.println(\"String 参数有误！\" + e.toString()); } } } static void Check(Person p) throws IllegalAccessException { // 获取Person实例p的每个字段field for(Field field : p.getClass().getFields()){ // 获取每个字段的注解 Range range = field.getAnnotation(Range.class); // 注解存在时 if(range != null){ // 获取当前字段的值 Object value = field.get(p); // 是String类型时： if(value instanceof String){ String s = (String) value; // 判断是否符合范围Range if(s.length() &lt; range.min() || s.length() &gt; range.max()){ throw new IllegalAccessException(\"String 有误！(Check函数抛出)\"); } } } } }}@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)@interface Range{ int min() default 0; int max() default 0x3f;}class Person{ @Range(min = 1, max = 20) public String name; @Range(max = 10) public String city; public Person(String name, String city){ this.name = name; this.city = city; }} 输出结果： 12String 参数无误！String 参数有误！java.lang.IllegalAccessException: String 有误！(Check函数抛出) 注解已经完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://niuxvdong.top/tags/%E6%B3%A8%E8%A7%A3/"}],"author":"Mr.Niu"},{"title":"Java教程系列之反射","slug":"Java教程系列之反射","date":"2020-04-01T10:05:20.000Z","updated":"2020-04-01T10:05:20.000Z","comments":true,"path":"posts/39487.html","link":"","permalink":"https://niuxvdong.top/posts/39487.html","excerpt":"","text":"一、什么是反射反射：Reflection 反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。 通过Class实例获取class信息的方法称为反射（Reflection）。 二、Class类 class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。 每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来！ 这里的Class类型是一个名叫Class的class。。。。 1、以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来 2、Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。 3、此处为JVM自动创建，是一个私有类！ 1Class cls = new Class(String); 一个Class实例包含了该class的所有完整信息！ 由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。 这种通过Class实例获取class信息的方法称为反射（Reflection）。 1、创建CLass 直接通过一个class的静态变量class获取： 通过该实例变量提供的getClass()方法获取： 通过静态方法Class.forName()获取，参数为完整类名： 因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。可以用==比较两个Class实例： 12345String s = \"\";Class cls = String.class;Class cls1 = s.getClass();Class cls2 = Class.forName(\"java.lang.String\");System.out.println(cls == cls1); 2、== 和 instanceof() instanceof可以判断子类及继承关系！ ==可以用来精确判断类的类型！ 通常情况下，我们应该用instanceof判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个class的时候，我们才使用==判断class实例。 1234567Integer n = new Integer(123);boolean b1 = n instanceof Integer; // true，因为n是Integer类型boolean b2 = n instanceof Number; // true，因为n是Number类型的子类boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.classboolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class 3、通过Class来获取相关信息12345678910111213141516171819202122232425package com.test;public class reflection { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException { printClassInfo(\"\".getClass()); printClassInfo(Runnable.class); printClassInfo(java.time.Month.class); printClassInfo(String[].class); printClassInfo(int.class); System.out.println(\"end\"); } static void printClassInfo(Class cls) { System.out.println(\"Class name: \" + cls.getName()); System.out.println(\"Simple name: \" + cls.getSimpleName()); if (cls.getPackage() != null) { System.out.println(\"Package name: \" + cls.getPackage().getName()); } System.out.println(\"is interface: \" + cls.isInterface()); System.out.println(\"is enum: \" + cls.isEnum()); System.out.println(\"is array: \" + cls.isArray()); System.out.println(\"is primitive: \" + cls.isPrimitive()); }} 输出结果： 数组（例如String[]）也是一种Class，而且不同于String.class，它的类名是[Ljava.lang.String 1234567891011121314151617181920212223242526272829303132333435Class name: java.lang.StringSimple name: StringPackage name: java.langis interface: falseis enum: falseis array: falseis primitive: falseClass name: java.lang.RunnableSimple name: RunnablePackage name: java.langis interface: trueis enum: falseis array: falseis primitive: falseClass name: java.time.MonthSimple name: MonthPackage name: java.timeis interface: falseis enum: trueis array: falseis primitive: false// 特殊：String 类型的数组Class name: [Ljava.lang.String;Simple name: String[]is interface: falseis enum: falseis array: trueis primitive: falseClass name: intSimple name: intis interface: falseis enum: falseis array: falseis primitive: trueend 4、动态加载 JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载： 当执行Main.java时，由于用到了Main，因此，JVM首先会把Main.class加载到内存。然而，并不会加载Person.class，除非程序执行到create()方法，JVM发现需要加载Person类时，才会首次加载Person.class。如果没有执行create()方法，那么Person.class根本就不会被加载。 1234567891011121314151617181920package com.test;public class reflectionTest { public static void main(String[] args) { if(args.length &gt; 0){ create(args[0]); } } static void create(String name){ Person1 p = new Person1(name); }}class Person1{ public String name; public Person1(String name){ this.name = name; }} 5、Log的动态加载 动态加载class的特性对于Java程序非常重要。利用JVM动态加载class的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下： 所以我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。 12345678910111213141516// Commons Logging优先使用Log4j:LogFactory factory = null;if (isClassPresent(\"org.apache.logging.log4j.Logger\")) { factory = createLog4j();} else { factory = createJdkLog();}boolean isClassPresent(String name) { try { Class.forName(name); return true; } catch (Exception e) { return false; }} 三、访问字段1、访问字段 Field getField(name)：根据字段名获取某个public的field（包括父类） Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类） Field[] getFields()：获取所有public的field（包括父类） Field[] getDeclaredFields()：获取当前类的所有field（不包括父类） 1234567891011121314151617181920public class Main { public static void main(String[] args) throws Exception { Class stdClass = Student.class; // 获取public字段\"score\": System.out.println(stdClass.getField(\"score\")); // 获取继承的public字段\"name\": System.out.println(stdClass.getField(\"name\")); // 获取private字段\"grade\": System.out.println(stdClass.getDeclaredField(\"grade\")); }}class Student extends Person { public int score; private int grade;}class Person { public String name;} 123public int Student.scorepublic java.lang.String Person.nameprivate int Student.grade 2、field对象方法一个Field对象包含了一个字段的所有信息： getName()：返回字段名称，例如，\"name\"； getType()：返回字段类型，也是一个Class实例，例如，String.class； getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。 String类的value字段如下定义： 123public final class String { private final byte[] value;} 获取所有信息： 12345678910111213141516171819package com.test;import java.lang.reflect.Field;import java.lang.reflect.Modifier;public class field { public static void main(String[] args) throws Exception { Field f = String.class.getDeclaredField(\"value\"); System.out.println(f.getName()); // \"value\" System.out.println(f.getType()); // class [B 表示byte[]类型 int m = f.getModifiers(); System.out.println(m); // 18 System.out.println(Modifier.isFinal(m)); // true System.out.println(Modifier.isPublic(m)); // false System.out.println(Modifier.isProtected(m)); // false System.out.println(Modifier.isPrivate(m)); // true System.out.println(Modifier.isStatic(m)); // false }} 3、获取字段值 先获取Class实例： 再获取Field实例： 然后，用Field.get(Object)获取指定实例的指定字段的值。 123456789101112131415161718192021package com.test;import java.lang.reflect.Field;public class getField { public static void main(String[] args) throws Exception { Object p = new Person3(\"Xiao Ming\"); Class c = p.getClass(); Field f = c.getDeclaredField(\"name\"); Object value = f.get(p); System.out.println(value); // \"Xiao Ming\" }}class Person3{ // public字段 public String name; public Person3(String name){ this.name = name; }} private字段main类是无法访问的： 直接访问会得到一个IllegalAccessException！ 解决方法： 在调用Object value = f.get(p);前，先写一句： 1f.setAccessible(true); 调用Field.setAccessible(true)的意思是，别管这个字段是不是public，一律允许访问。 如果使用反射可以获取private字段的值，那么类的封装还有什么意义？ 答案是正常情况下，我们总是通过p.name来访问Person的name字段，编译器会根据public、protected和private决定是否允许访问字段，这样就达到了数据封装的目的。 而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。 此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 修改如下： 123456789101112131415161718192021package com.test;import java.lang.reflect.Field;public class getField { public static void main(String[] args) throws Exception { Object p = new Person3(\"Xiao Ming\"); Class c = p.getClass(); Field f = c.getDeclaredField(\"name\"); f.setAccessible(true); Object value = f.get(p); System.out.println(value); // \"Xiao Ming\" }}class Person3{ private String name; public Person3(String name){ this.name = name; }} 4、设置字段值 设置字段值是通过Field.set(Object, Object)实现的，其中第一个Object参数是指定的实例，第二个Object参数是待修改的值： 修改非public字段，需要首先调用setAccessible(true)。 123456789101112131415161718192021222324252627package com.test;import java.lang.reflect.Field;public class getField { public static void main(String[] args) throws Exception { Person3 p = new Person3(\"Xiao Ming\"); System.out.println(p.getName()); Class c = p.getClass(); Field f = c.getDeclaredField(\"name\"); f.setAccessible(true); //Object value = f.get(p); f.set(p, \"Xiao Hong\"); System.out.println(p.getName()); // \"Xiao Hong\" }}class Person3{ private String name; public Person3(String name){ this.name = name; } public String getName() { return name; }} 四、调用方法1、调用方法我们已经能通过Class实例获取所有Field对象，同样的，可以通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method： Method getMethod(name, Class...)：获取某个public的Method（包括父类） Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类） Method[] getMethods()：获取所有public的Method（包括父类） Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类） 12345678910111213141516171819202122232425262728package com.test;public class method { public static void main(String[] args) throws Exception { Class stdClass = Students.class; // 获取public方法getScore，参数为String: System.out.println(stdClass.getMethod(\"getScore\", String.class)); // 获取继承的public方法getName，无参数: System.out.println(stdClass.getMethod(\"getName\")); // 获取private方法getGrade，参数为int: System.out.println(stdClass.getDeclaredMethod(\"getGrade\", int.class)); }}class Students extends Person4 { public int getScore(String type) { return 99; } private int getGrade(int year) { return 1; }}class Person4 { public String getName() { return \"Person\"; }} 输出结果： 123public int com.test.Students.getScore(java.lang.String)public java.lang.String com.test.Person4.getName()private int com.test.Students.getGrade(int) 2、method对象方法一个Method对象包含一个方法的所有信息： getName()：返回方法名称，例如：\"getScore\"； getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class； getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}； getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。 3、调用方法用反射来调用substring方法： 对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。 1234567891011121314151617package com.test;import java.lang.reflect.Method;public class getMethod { public static void main(String[] args) throws Exception{ // String对象: String s = \"Hello world\"; // 获取String substring(int)方法，参数为int: Method m = String.class.getMethod(\"substring\", int.class); System.out.println(m); // 在s对象上调用该方法并获取结果: String r = (String) m.invoke(s, 6); // 打印调用结果: System.out.println(r); }} 输出结果如下： 12public java.lang.String java.lang.String.substring(int)world 4、调用静态方法 如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null。 1234567891011121314package com.test;import java.lang.reflect.Method;public class Main { public static void main(String[] args) throws Exception { // 获取Integer.parseInt(String)方法，参数为String: Method m = Integer.class.getMethod(\"parseInt\", String.class); // 调用该静态方法并获取结果: Integer n = (Integer) m.invoke(null, \"12345\"); // 打印调用结果: System.out.println(n); // 12345 }} 5、调用非public方法 和Field类似，对于非public方法，我们虽然可以通过Class.getDeclaredMethod()获取该方法实例，但直接对其调用将得到一个IllegalAccessException。为了调用非public方法，我们通过Method.setAccessible(true)允许其调用： 此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 123456789101112131415161718192021package com.test;import java.lang.reflect.Method;public class Main { public static void main(String[] args) throws Exception { Person p = new Person(); Method m = p.getClass().getDeclaredMethod(\"setName\", String.class); // 关键点： m.setAccessible(true); m.invoke(p, \"Bob\"); System.out.println(p.name); }}class Person { String name; private void setName(String name) { this.name = name; }} 6、多态 我们来考察这样一种情况：一个Person类定义了hello()方法，并且它的子类Student也覆写了hello()方法，那么，从Person.class获取的Method，作用于Student实例时，调用的方法到底是哪个？ 123456789101112131415161718192021222324package com.test;import java.lang.reflect.Method;public class Main { public static void main(String[] args) throws Exception { // 获取Person的hello方法: Method h = Person.class.getMethod(\"hello\"); // 对Student实例调用hello方法: h.invoke(new Student()); //Student:hello }}class Person { public void hello() { System.out.println(\"Person:hello\"); }}class Student extends Person { public void hello() { System.out.println(\"Student:hello\"); }} 使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在） 123456Method m = Person.class.getMethod(\"hello\");m.invoke(new Student());// 相当于：Person p = new Student();p.hello(); 7、链式编程123456789// 普通方法：Method m1 = Integer.class.getMethod(\"parseInt\", String.class);Integer n = (Integer) m1.invoke(null, \"12345\");System.out.println(n);// 链式编程：Integer n = (Integer) Integer.class.getMethod(\"parseInt\", String.class).invoke(null, \"123456\");// 打印调用结果:System.out.println(n); 五、调用构造方法1、通过调用Class提供的newInstance()方法来创建构造方法实例 调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。 1Person p = Person.class.newInstance(); 2、通过调用Java的反射API提供了Constructor对象来创建构造方法实例通过Class实例获取Constructor的方法如下： getConstructor(Class...)：获取某个public的Constructor； getDeclaredConstructor(Class...)：获取某个Constructor； getConstructors()：获取所有public的Constructor； getDeclaredConstructors()：获取所有Constructor。 注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。 调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。 Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例： 12345678910111213141516import java.lang.reflect.Constructor;public class Main { public static void main(String[] args) throws Exception { // 获取构造方法Integer(int): Constructor cons1 = Integer.class.getConstructor(int.class); // 调用构造方法: Integer n1 = (Integer) cons1.newInstance(123); System.out.println(n1); // 123 // 获取构造方法Integer(String) Constructor cons2 = Integer.class.getConstructor(String.class); Integer n2 = (Integer) cons2.newInstance(\"456\"); System.out.println(n2); // 456 }} 六、获取继承关系1、获取父类Class 使用getSuperclass()方法： 12345678910public class Main { public static void main(String[] args) throws Exception { Class i = Integer.class; Class n = i.getSuperclass(); System.out.println(n); Class o = n.getSuperclass(); System.out.println(o); System.out.println(o.getSuperclass()); }} 输出结果： Integer的父类类型是Number，Number的父类是Object，Object的父类是null。 除Object外，其他任何非interface的Class都必定存在一个父类类型。 123class java.lang.Numberclass java.lang.Objectnull 2、获取接口Interface 使用getInterfaces()方法： 如果一个类没有实现任何interface，那么getInterfaces()返回空数组。 123456789public class Main { public static void main(String[] args) throws Exception { Class s = Integer.class; Class[] is = s.getInterfaces(); for (Class i : is) { System.out.println(i); } }} 输出结果： 可知Integer有以下三个接口： 123interface java.lang.Comparableinterface java.lang.constant.Constableinterface java.lang.constant.ConstantDesc 要特别注意：getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型： 12345678910public class Main { public static void main(String[] args) throws Exception { Class s = Integer.class.getSuperclass(); System.out.println(s); Class[] is = s.getInterfaces(); for (Class i : is) { System.out.println(i); } }} 输出结果如下： 可知Number的接口只有下面这一个： 12class java.lang.Numberinterface java.io.Serializable 接口使用getSuperclass()方法永远返回null： 3、Class的继承关系 判断普通实例使用instanceof ()方法： 判断Class实例使用isAssignableFrom()方法： 可以这样简单理解：括号内的是否继承自外面的！ 12345678// Integer i = ?Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer// Number n = ?Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number// Object o = ?Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object// Integer i = ?Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer 七、动态代理（Dynamic Proxy）1、class 和 interfaceclass和interface的区别： 可以实例化class（非abstract）； 不能实例化interface。 2、静态代理实现 定义接口 编写实现类 创建实例转型为接口并调用 123456789101112131415161718package com.test;public class DynamicProxy { public static void main(String[] args) { Hello hello = new HelloWorlds(); hello.morning(\"Bob\"); }}class HelloWorlds implements Hello { public void morning(String name) { System.out.println(\"Good morning, \" + name); }}interface Hello { void morning(String name);} 3、动态代理实现在运行期动态创建一个interface实例的方法如下： 定义一个InvocationHandler实例，它负责实现接口的方法调用； 通过Proxy.newProxyInstance() 创建interface实例，它需要3个参数： 使用的ClassLoader，通常就是接口类的ClassLoader； 需要实现的接口数组，至少需要传入一个接口进去； 用来处理接口方法调用的InvocationHandler实例。 将返回的Object强制转型为接口。 ClassLoader，它是类加载器，用来将.class字节码加载转换成class类对象的！ InvocationHandler相当于：第一个参数传入了创建的实例hello，第二个参数传入了Hello的抽象方法morning，第三个参数传入了抽象方法morning的参数BOb。 1234567891011121314151617181920212223242526272829package com.test;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class DynamicProxy { public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); if (method.getName().equals(\"morning\")) { System.out.println(\"Good morning, \" + args[0]); } return null; } }; Hello1 hello = (Hello1) Proxy.newProxyInstance( Hello1.class.getClassLoader(), // 传入ClassLoader new Class[] { Hello1.class }, // 传入要实现的接口 handler); // 传入处理调用方法的InvocationHandler hello.morning(\"Bob\"); }}interface Hello1 { void morning(String name);} 输出结果： 12public abstract void com.test.Hello1.morning(java.lang.String)Good morning, Bob 4、动态代理实际实现方法 动态代理实际上是JDK在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样： 其实就是JDK帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。 目前我还不太会调用。。。 123456789101112public class HelloDynamicProxy implements Hello { InvocationHandler handler; public HelloDynamicProxy(InvocationHandler handler) { this.handler = handler; } public void morning(String name) { handler.invoke( this, Hello.class.getMethod(\"morning\"), new Object[] { name }); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"反射","slug":"反射","permalink":"https://niuxvdong.top/tags/%E5%8F%8D%E5%B0%84/"}],"author":"Mr.Niu"},{"title":"Java教程系列之异常处理","slug":"Java教程系列之异常处理","date":"2020-03-30T11:55:07.000Z","updated":"2020-03-30T11:55:07.000Z","comments":true,"path":"posts/19314.html","link":"","permalink":"https://niuxvdong.top/posts/19314.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、Java的异常1、异常的来源1.1 来源 用户输入造成 随机出现的错误 网络突然断了，连接不到远程服务器； 内存耗尽，程序崩溃了； 用户点“打印”，但根本没有打印机； …… 1.2 处理错误的方法 方法一：约定返回错误码。 例如，处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码： 因为使用int类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。 一般不这样处理！ 1234567891011121314int code = processFile(\"C:\\\\test.txt\");if (code == 0) { // ok:} else { // error: switch (code) { case 1: // file not found: case 2: // no read permission: default: // unknown error: }} 方法二：在语言层面上提供一个异常处理机制。 Java内置了一套异常处理机制，总是使用异常来表示错误。 异常是一种class，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了！ 使用的是try...catch...语句： 123456789101112try { String s = processFile(“C:\\\\test.txt”); // ok:} catch (FileNotFoundException e) { // file not found:} catch (SecurityException e) { // no read permission:} catch (IOException e) { // io error:} catch (Exception e) { // other error:} 1.3 异常的继承关系1234567891011121314151617181920212223242526 ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Throwable │ └───────────┘ ▲ ┌─────────┴─────────┐ │ │ ┌───────────┐ ┌───────────┐ │ Error │ │ Exception │ └───────────┘ └───────────┘ ▲ ▲ ┌───────┘ ┌────┴──────────┐ │ │ │┌─────────────────┐ ┌─────────────────┐┌───────────┐│OutOfMemoryError │... │RuntimeException ││IOException│...└─────────────────┘ └─────────────────┘└───────────┘ ▲ ┌───────────┴─────────────┐ │ │ ┌─────────────────────┐ ┌─────────────────────────┐ │NullPointerException │ │IllegalArgumentException │... └─────────────────────┘ └─────────────────────────┘ Throwable是异常体系的根，它继承自Object。Throwable有两个体系：Error和Exception，Error表示严重的错误，程序对此一般无能为力： OutOfMemoryError：内存耗尽 NoClassDefFoundError：无法加载某个Class StackOverflowError：栈溢出 而Exception则是运行时的错误，它可以被捕获并处理！ 某些异常是应用程序逻辑处理的一部分，应该捕获并处理！ 还有一些异常是程序逻辑编写不对造成的，应该修复程序本身！ NumberFormatException：数值类型的格式错误 FileNotFoundException：未找到文件 SocketException：读取网络失败 NullPointerException：对某个null的对象调用方法或字段 IndexOutOfBoundsException：数组索引越界 Exception分为两大类： RuntimeException以及它的子类； 非RuntimeException（包括IOException、ReflectiveOperationException等等） 1.4 哪些异常需要处理Java规定： 必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。 不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。 2、捕获异常（catch） 捕获异常使用try...catch语句，把可能发生异常的代码放到try {...}中，然后使用catch捕获对应的Exception及其子类！ 2.1 方法内部使用try catch捕获 不去捕获错误会发生编译错误： 12345Main.java:15: 错误: 未报告的异常错误UnsupportedEncodingException; 必须对其进行捕获或声明以便抛出 return s.getBytes(\"GBK\"); ^1 个错误错误: 编译失败 1234567891011121314151617181920212223package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); } public static byte[] toGBK(String s) { try { // 用指定编码转换String为byte[]: return s.getBytes(\"GBK\"); } catch (UnsupportedEncodingException e) { // 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException: System.out.println(e);// 打印错误信息 e.printStackTrace(); return s.getBytes();// 尝试使用用默认编码 } }} 来看一下String.getBytes(String)方法的定义： 在方法定义的时候，使用throws Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。 123public byte[] getBytes(String charsetName) throws UnsupportedEncodingException { ...} 2.2 方法定义处使用throws 在方法定义处用throws表示toGBK()方法可能会抛出UnsupportedEncodingException，就可以让toGBK()方法通过编译器检查： 告诉编译器可能会抛出错误，编译器会跳过检查该方法，但是会在main方法里面抛出异常： 12345Main.java:8: 错误: 未报告的异常错误UnsupportedEncodingException; 必须对其进行捕获或声明以便抛出 byte[] bs = toGBK(\"中文\"); ^1 个错误错误: 编译失败 123456789101112131415package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); } public static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); }} 做出修改如下： 修改一：在main方法内捕获异常： 12345678910111213141516171819package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) { try { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); }catch (UnsupportedEncodingException e) { System.out.println(e); } } public static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); }} 修改二：将main方法定义为throws Exception main()方法声明了可能抛出Exception，也就声明了可能抛出所有的Exception，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。 123456789101112131415package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) throws Exception { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); } public static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); }} 2.3 使用printStackTrace()打印异常栈 没有弄明白这样写为什么不会执行catch内部的语句。。。 1234567891011121314151617181920package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) { try { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); }catch (UnsupportedEncodingException e) { System.out.println(e); e.printStackTrace(); } } public static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); }} 二、捕获异常1、多条catch语句 可以使用多个catch语句，每个catch分别捕获对应的Exception及其子类。JVM在捕获到异常后，会从上到下匹配catch语句，匹配到某个catch后，执行catch代码块，然后不再继续匹配。 多条catch语句只执行一个！ 由于从上到下匹配，所以catch语句要从子类开始写起，防止被一个父类直接截断！ 若将下方两个catch互换，则UnsupportedEncodingException根本无法执行，会被其父类IOException给截断！ 1234567891011public static void main(String[] args) { try { process1(); process2(); process3(); } catch (UnsupportedEncodingException e) { System.out.println(\"Bad encoding\"); } catch (IOException e) { System.out.println(\"IO error\"); }} 2、finally语句 无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？ 当然可以在每个catch语句都写一遍，显然这样很麻烦！ 所以引入一个finally语句，有无错误都会执行！ 可见，finally是用来保证一些代码必须执行的。 如果捕获异常跳转执行 catch 里面的语句块，return 先执行。finally 里面的代码总是最后执行。 注意finally的两个特点： finally语句不是必须的，可写可不写； finally总是最后执行。 执行流程： 如果没有发生异常，就正常执行try { ... }语句块，然后执行finally。如果发生了异常，就中断执行try { ... }语句块，然后跳转执行匹配的catch语句块，最后执行finally。 12345678910111213public static void main(String[] args) { try { process1(); process2(); process3(); } catch (UnsupportedEncodingException e) { System.out.println(\"Bad encoding\"); } catch (IOException e) { System.out.println(\"IO error\"); } finally { System.out.println(\"END\"); }} try...finally语句： 某些情况下，可以没有catch，只使用try ... finally结构！ 1234567void process(String file) throws IOException { try { ... } finally { System.out.println(\"END\"); }} 3、异常逻辑相同则合并 处理IOException和NumberFormatException的代码是相同的，所以我们可以把它两用|合并到一起： 1234567891011public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException | NumberFormatException e) { // IOException或NumberFormatException System.out.println(\"Bad input\"); } catch (Exception e) { System.out.println(\"Unknown error\"); }} 三、抛出异常 目的：是为了在代码执行发生错误的时候，停止，或者进行处理，以及抛出信息帮助程序员定位出现bug的位置！ 所以，需要在可能发生异常的地方，使用 throw 语句抛出异常！ 异常抛出之后，需要对异常进行捕获！ 1、异常的传播 当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try ... catch被捕获为止： 12345678910111213141516171819package com.test;public class codeTest { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { process2(); } static void process2() { Integer.parseInt(null); // 会抛出NumberFormatException }} 使用printStackTrace()方法打印方法的调用栈： printStackTrace()对于调试错误非常有用，下面信息表示：NumberFormatException是在java.lang.Integer.parseInt方法中被抛出的！ 12345678java.lang.NumberFormatException: null at java.base/java.lang.Integer.parseInt(Integer.java:614) at java.base/java.lang.Integer.parseInt(Integer.java:770) at com.test.codeTest.process2(codeTest.java:17) at com.test.codeTest.process1(codeTest.java:13) at com.test.codeTest.main(codeTest.java:6)Process finished with exit code 0 打印的是异常栈，是栈，所以从下往上看： main()调用process1()； process1()调用process2()； process2()调用Integer.parseInt(String)； Integer.parseInt(String)调用Integer.parseInt(String, int)。 2、抛出异常2.1 创建并抛出 创建某个Exception的实例； 用throw语句抛出。 通常会合并到一起来写： 12345678910111213void process2(String s) { if (s==null) { NullPointerException e = new NullPointerException(); throw e; }}// 合并写法：void process2(String s) { if (s==null) { throw new NullPointerException(); }} 2.2 异常转换 如果一个方法捕获了某个异常后，又在catch子句中抛出新的异常，就相当于把抛出的异常类型“转换”了： 后者覆盖前者： 当process2()抛出NullPointerException后，被process1()捕获，然后抛出IllegalArgumentException()。 123456789101112131415161718192021public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(); } } static void process2() { throw new NullPointerException(); }} 2.3 传入原始Exception来保留原始Exception 捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！ 12345678910111213141516171819202122public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { try { process2(); } catch (NullPointerException e) { // 关键点，传入原始Exception e throw new IllegalArgumentException(e); } } static void process2() { throw new NullPointerException(); }} 抛出信息的异常栈信息如下： 注意到Caused by: Xxx，说明捕获的IllegalArgumentException并不是造成问题的根源，根源在于NullPointerException，是在Main.process2()方法抛出的。 1234567java.lang.IllegalArgumentException: java.lang.NullPointerException at com.test.codeTest.process1(codeTest.java:16) at com.test.codeTest.main(codeTest.java:6)// 关键点：Caused by: java.lang.NullPointerException at com.test.codeTest.process2(codeTest.java:23) at com.test.codeTest.process1(codeTest.java:14) 3、finally语句是否执行 在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。 123456789101112public class Main { public static void main(String[] args) { try { Integer.parseInt(\"abc\"); } catch (Exception e) { System.out.println(\"catched\"); throw new RuntimeException(e); } finally { System.out.println(\"finally\"); } }} 1234catchedfinallyException in thread \"main\" java.lang.IllegalArgumentException at Main.main(Main.java:11) 4、异常屏蔽 在执行finally语句时抛出异常,catch语句的异常会被屏蔽！ finally抛出异常后，原来在catch中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception） Suppressed ：屏蔽 绝大多数情况下，在finally中不要抛出异常。因此，我们通常不需要关心Suppressed Exception。 12345678910111213public class Main { public static void main(String[] args) { try { Integer.parseInt(\"abc\"); } catch (Exception e) { System.out.println(\"catched\"); throw new RuntimeException(e); } finally { System.out.println(\"finally\"); throw new IllegalArgumentException(); } }} 抛出异常如下： 1234catchedfinallyException in thread \"main\" java.lang.IllegalArgumentException at Main.main(Main.java:11) 解决方法： 如果需要获知所有的异常，方法是先用origin变量保存原始异常，然后调用Throwable.addSuppressed()，把原始异常添加进来，最后在finally抛出： Suppressed ：屏蔽 1234567891011121314151617public class Main { public static void main(String[] args) throws Exception { Exception origin = null; try { System.out.println(Integer.parseInt(\"abc\")); } catch (Exception e) { origin = e; throw e; } finally { Exception e = new IllegalArgumentException(); if (origin != null) { e.addSuppressed(origin); } throw e; } }} 抛出异常信息如下： 1234567Exception in thread \"main\" java.lang.IllegalArgumentException at Main.main(Main.java:11) // 关键点：屏蔽异常信息：NumberFormatException Suppressed: java.lang.NumberFormatException: For input string: \"abc\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) 四、自定义异常1、Java标准库定义的 常用异常：1234567891011121314151617181920212223242526272829Exception│├─ RuntimeException│ ││ ├─ NullPointerException│ ││ ├─ IndexOutOfBoundsException│ ││ ├─ SecurityException│ ││ └─ IllegalArgumentException│ ││ └─ NumberFormatException│├─ IOException│ ││ ├─ UnsupportedCharsetException│ ││ ├─ FileNotFoundException│ ││ └─ SocketException│├─ ParseException│├─ GeneralSecurityException│├─ SQLException│└─ TimeoutException 2、自定义异常 在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。 一个常见的做法是自定义一个BaseException作为“根异常”，然后，派生出各种业务类型的异常。 BaseException需要从一个适合的Exception派生，通常建议从RuntimeException派生： BaseException构造方法实际上都是原样照抄RuntimeException。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。 12345678910111213141516171819202122232425public class BaseException extends RuntimeException { public BaseException() { super(); } public BaseException(String message, Throwable cause) { super(message, cause); } public BaseException(String message) { super(message); } public BaseException(Throwable cause) { super(cause); }}public class UserNotFoundException extends BaseException {}public class LoginFailedException extends BaseException {}... 五、NullPointerException 所有的RuntimeException异常中，最常见的就是NullPointerException了！ NullPointerException即空指针异常，俗称NPE。如果一个对象为null，调用其方法或访问其字段就会产生NullPointerException，这个异常通常是由JVM抛出的！ 1、处理NullPointerException NullPointerException是一种代码逻辑错误，遇到NullPointerException，遵循原则是早暴露，早修复，严禁使用catch来隐藏这种编码错误： 1.1 变量定义时尽量不使用null 使用空字符串\"\"而不是默认的null可避免很多NullPointerException，编写业务逻辑时，用空字符串\"\"表示未填写比null安全得多。 123public class Person { private String name = \"\";} 1.2 返回时尽量不返回null12345678910111213package com.test;public class codeTest { public static void main(String[] args) { String name = getName(); System.out.println(name.toString()); } public static String getName() { //return null; return \"\"; }} 1.3 必须返回null时使用Optional&lt;T&gt; 使用Optional.isPresent()来判断是不是null 使用Optional.of()返回T类型的值： 1234567891011121314151617181920package com.test;import java.util.Optional;public class codeTest { public static void main(String[] args) { Optional&lt;String&gt; name = getName(); if(name.isPresent()) { System.out.println(name); }else{ System.out.println(\"NULL\"); } } public static Optional&lt;String&gt; getName() { //return null; //return Optional.of(\"hhh\"); return Optional.empty(); }} 2、定位NullPointerException 这种增强的NullPointerException详细信息是Java 14新增的功能，但默认是关闭的，我们可以给JVM添加一个-XX:+ShowCodeDetailsInExceptionMessages参数启用它： 1java -XX:+ShowCodeDetailsInExceptionMessages Main.java 12345678910111213141516171819package com.test;public class codeTest { public static void main(String[] args) { Persons p = new Persons(); System.out.println(p.address.city.toLowerCase()); }}class Persons { String[] name = new String[2]; Address address = new Address();}class Address { String city; String street; String zipcode;} 定位信息如下：city是空的！ 12345java -XX:+ShowCodeDetailsInExceptionMessages Main.java// 信息如下：Exception in thread \"main\" java.lang.NullPointerException: Cannot invoke \"String.toLowerCase()\" because \"&lt;local1&gt;.address.city\" is null at com.test.codeTest.main(codeTest.java:6) 六、使用断言 实际开发中，很少使用断言。更好的方法是编写单元测试！ 断言条件预期为true，则正常执行。断言条件为false，抛出AssertionError。 后面可加参数来打印提示信息，更加便于调试！ Java断言的特点是：断言失败时会抛出AssertionError，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。 对可恢复的错误不能使用断言，而应该抛出异常； 1assert x &gt;= 0 : \"x must &gt;= 0\"; 1234567public class Main { public static void main(String[] args) { int x = -1; assert x &gt; 0; System.out.println(x); }} JVM默认关闭断言指令，即遇到assert语句就自动忽略了，不执行。 要执行assert语句，必须给Java虚拟机传递-enableassertions（可简写为-ea）参数启用断言。所以，上述程序必须在命令行下运行才有效果： 123$ java -ea Main.javaException in thread \"main\" java.lang.AssertionError at Main.main(Main.java:5) 七、使用JDK Loging 编写程序的过程中，发现程序运行结果与预期不符，使用System.out.println()打印变量信息！异常麻烦！ 所以使用Loging，日志就是Logging，它的目的是为了取代System.out.println()。 使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。 几点好处： 可以设置输出样式，避免自己每次都写\"ERROR: \" + var； 可以设置输出级别，禁止某些级别输出。例如，只输出错误日志； 可以被重定向到文件，这样可以在程序运行结束后查看日志； 可以按包名控制日志级别，只输出某些包打的日志； 可以…… 12345678910111213package com.test;import java.util.logging.Logger;public class codeTest { public static void main(String[] args) { Logger logger = Logger.getGlobal(); logger.info(\"start process...\"); logger.warning(\"memory is running out...\"); logger.fine(\"ignored.\"); logger.severe(\"process will be terminated...\"); }} 输出信息如下： 1234563月 31, 2020 6:12:33 下午 com.test.codeTest main信息: start process...3月 31, 2020 6:12:33 下午 com.test.codeTest main警告: memory is running out...3月 31, 2020 6:12:33 下午 com.test.codeTest main严重: process will be terminated... Logger日志的七个级别： 默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。 SEVERE WARNING INFO CONFIG FINE FINER FINEST Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行main()方法，就无法修改配置； 配置不太方便，需要在JVM启动时传递参数-Djava.util.logging.config.file=。 因此，Java标准库内置的Logging使用并不是非常广泛。 一个例子： 1234567891011121314151617181920package com.test;import com.sun.tools.javac.Main;import java.io.UnsupportedEncodingException;import java.util.logging.Logger;public class codeTest { public static void main(String[] args) { Logger logger = Logger.getLogger(Main.class.getName()); logger.info(\"Start process...\"); try { \"\".getBytes(\"invalidCharsetName\"); } catch (UnsupportedEncodingException e) { // TODO: 使用logger.severe()打印异常 logger.severe(e.toString()); } logger.info(\"Process end.\"); }} 日志如下： 123456783月 31, 2020 6:18:43 下午 com.test.codeTest main信息: Start process...3月 31, 2020 6:18:43 下午 com.test.codeTest main严重: java.io.UnsupportedEncodingException: invalidCharsetName3月 31, 2020 6:18:43 下午 com.test.codeTest main信息: Process end.Process finished with exit code 0 八、使用Commons Logging 和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。 Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。 Commons Logging是一个第三方提供的库，所以，必须先把它下载下来。下载后，解压，找到commons-logging-1.2.jar这个文件，再把Java源码Main.java放到一个目录下 1、idea 导入方式：1.打开 File -&gt; Project Structure 2.单击 Modules -&gt; Dependencies -&gt; “+” -&gt; “Jars or directories” 3.选择硬盘上的jar包 4.Apply -&gt; OK 然后将鼠标放到导入的包上，点击提示信息的add classspath….即可成功导入！ 12345678910111213package com.test;import com.sun.tools.javac.Main;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class codeTest { public static void main(String[] args) { Log log = LogFactory.getLog(Main.class); log.info(\"start...\"); log.warn(\"end.\"); }} 信息如下： 12343月 31, 2020 6:51:39 下午 com.sun.tools.javac.Main main信息: start...3月 31, 2020 6:51:39 下午 com.sun.tools.javac.Main main警告: end. 2、Commons Logging定义了6个日志级别： FATAL ERROR WARNING INFO DEBUG TRACE 默认级别是INFO。 3、静态方法中引用log定义静态类型变量：12345678/ 在静态方法中引用Log:public class Main { static final Log log = LogFactory.getLog(Main.class); static void foo() { log.info(\"foo\"); }} 4、实例方法中引用log定义实例类型变量： 注意到实例变量log的获取方式是LogFactory.getLog(getClass())，虽然也可以用LogFactory.getLog(Person.class)，但是前一种方式有个非常大的好处，就是子类可以直接使用该log实例： 由于Java类的动态特性，子类获取的log字段实际上相当于LogFactory.getLog(Student.class)，但却是从父类继承而来，并且无需改动代码： 12345678910111213141516// 在实例方法中引用Log:public class Person { protected final Log log = LogFactory.getLog(getClass()); void foo() { log.info(\"foo\"); }}// 在子类中使用父类实例化的log:public class Student extends Person { void bar() { log.info(\"bar\"); }} 5、可抛出异常： Commons Logging的日志方法，例如info()，除了标准的info(String)外，还提供了一个非常有用的重载方法：info(String, Throwable)，这使得记录异常更加简单： 本例子使用了： 实例方法引用log定义实例变量 使用LogFactory.getLog(getClass())来是子类直接继承log 使用log的两个参数，第二个参数来抛出异常： 12345678910111213141516171819202122232425262728293031package com.test;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class codeTest { public static void main(String[] args) { var s = new Persons(); s.foo(); var t = new Tests(); t.bar(); }}class Persons{ protected final Log log = LogFactory.getLog(getClass()); void foo(){ try { Integer n = Integer.parseInt(\"abs\"); }catch (NumberFormatException e){ log.error(\"foo\", e); } }}class Tests extends Persons{ void bar(){ log.info(\"bar\"); }} 结果如下： 12345678910113月 31, 2020 7:09:22 下午 com.test.Persons foo严重: foojava.lang.NumberFormatException: For input string: \"abs\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) at com.test.Persons.foo(codeTest.java:20) at com.test.codeTest.main(codeTest.java:9)3月 31, 2020 7:09:22 下午 com.test.Tests bar信息: bar 九、使用Log4j 前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。 Log4j是一种非常流行的日志框架，最新版本是2.x。 在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入classpath，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。 1、Log4j架构：Log4j是一个组件化设计的日志系统，它的架构大致如下： 12345678910111213log.info(\"User signed in.\"); │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ Console │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ File │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ └──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ Socket │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ 当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如： console：输出到屏幕； file：输出到文件； socket：通过网络输出到远程计算机； jdbc：输出到数据库 在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出ERROR级别的日志。 最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。 2、配置XML文件上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。 将下面保存到文件并命名为：log4j2.xml放到src目录下即可： 虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是INFO级别的日志，会自动输出到屏幕，而ERROR级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Configuration&gt; &lt;Properties&gt; &lt;!-- 定义日志格式 --&gt; &lt;Property name=\"log.pattern\"&gt;%d{MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36}%n%msg%n%n&lt;/Property&gt; &lt;!-- 定义文件名变量 --&gt; &lt;Property name=\"file.err.filename\"&gt;log/err.log&lt;/Property&gt; &lt;Property name=\"file.err.pattern\"&gt;log/err.%i.log.gz&lt;/Property&gt; &lt;/Properties&gt; &lt;!-- 定义Appender，即目的地 --&gt; &lt;Appenders&gt; &lt;!-- 定义输出到屏幕 --&gt; &lt;Console name=\"console\" target=\"SYSTEM_OUT\"&gt; &lt;!-- 日志格式引用上面定义的log.pattern --&gt; &lt;PatternLayout pattern=\"${log.pattern}\" /&gt; &lt;/Console&gt; &lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt; &lt;RollingFile name=\"err\" bufferedIO=\"true\" fileName=\"${file.err.filename}\" filePattern=\"${file.err.pattern}\"&gt; &lt;PatternLayout pattern=\"${log.pattern}\" /&gt; &lt;Policies&gt; &lt;!-- 根据文件大小自动切割日志 --&gt; &lt;SizeBasedTriggeringPolicy size=\"1 MB\" /&gt; &lt;/Policies&gt; &lt;!-- 保留最近10份 --&gt; &lt;DefaultRolloverStrategy max=\"10\" /&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=\"info\"&gt; &lt;!-- 对info级别的日志，输出到console --&gt; &lt;AppenderRef ref=\"console\" level=\"info\" /&gt; &lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt; &lt;AppenderRef ref=\"err\" level=\"error\" /&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是INFO级别的日志，会自动输出到屏幕，而ERROR级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。 3、下载并配置Log4j有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从这里下载Log4j，解压后，把以下3个jar包放到classpath中： log4j-api-2.x.jar log4j-core-2.x.jar log4j-jcl-2.x.jar 因为Commons Logging会自动发现并使用Log4j，所以，把上一节下载的commons-logging-1.2.jar也放到classpath中。 要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出，类似： 第八节第五点的输出信息变为如下： 123456789101103-31 19:35:03.119 [main] ERROR com.test.Personsfoojava.lang.NumberFormatException: For input string: \"abs\" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) ~[?:?] at java.lang.Integer.parseInt(Integer.java:652) ~[?:?] at java.lang.Integer.parseInt(Integer.java:770) ~[?:?] at com.test.Persons.foo(codeTest.java:20) [java-base/:?] at com.test.codeTest.main(codeTest.java:9) [java-base/:?]03-31 19:35:03.146 [main] INFO com.test.Testsbar 4、小结 通过Commons Logging实现日志，不需要修改代码即可使用Log4j； 使用Log4j只需要把log4j2.xml和相关jar放入classpath； 如果要更换Log4j，只需要移除log4j2.xml和相关jar； 只有扩展Log4j时，才需要引用Log4j的接口（例如，将日志加密写入数据库的功能，需要自己开发）。 十、使用SLF4J和Logback 前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。 有的童鞋可能还听说过SLF4J和Logback。这两个东东看上去也像日志，它们又是啥？ 其实SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。 为什么有了Commons Logging和Log4j，又会蹦出来SLF4J和Logback？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。 因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。 来看看SLF4J对Commons Logging的接口有何改进： SLF4J的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。 12345678910int score = 99;p.setScore(score);// Commons Logging 的拼接字符串：log.info(\"Set score \" + score + \" for Person \" + p.getName() + \" ok.\");// SLF4Jint score = 99;p.setScore(score);// 改进后的拼接字符串：logger.info(\"Set score {} for Person {} ok.\", score, p.getName()); 如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样！ 配置相关：使用SLF4J和Logback和前面讲到的使用Commons Logging加Log4j是类似的，先分别下载SLF4J和Logback，然后把以下jar包放到classpath下： slf4j-api-1.7.x.jar logback-classic-1.2.x.jar logback-core-1.2.x.jar 在src目录下新建一个logback.xml文件，写入下面内容： 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;charset&gt;utf-8&lt;/charset&gt; &lt;/encoder&gt; &lt;file&gt;log/output.log&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.FixedWindowRollingPolicy\"&gt; &lt;fileNamePattern&gt;log/output.log.%i&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;1MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt;&lt;/configuration&gt; 代码修改如下：123456789101112131415161718192021222324252627282930313233343536package com.test;import org.slf4j.LoggerFactory;import org.slf4j.Logger;public class codeTest { public static void main(String[] args) { var s = new Persons(); s.foo(); var t = new Tests(); t.bar(); }}class Persons{ //protected final Logger log = LoggerFactory.getLogger(getClass()); final Logger logger = LoggerFactory.getLogger(getClass()); void foo(){ try { Integer n = Integer.parseInt(\"abs\"); }catch (NumberFormatException e){ logger.error(\"foo\", e); } }}class Tests extends Persons{ String name = \"Mr.Niu\"; int age = 100; void bar(){ logger.info(\"bar\"); // 拼接字符串新方法： logger.info(\"name:{}, age:{}\",name, age); }} 输出信息如下： 12345678920:14:19.679 [main] ERROR com.test.Persons - foojava.lang.NumberFormatException: For input string: \"abs\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) at com.test.Persons.foo(codeTest.java:21) at com.test.codeTest.main(codeTest.java:9)20:14:19.693 [main] INFO com.test.Tests - bar20:14:19.697 [main] INFO com.test.Tests - name:Mr.Niu, age:100 小结 SLF4J和Logback可以取代Commons Logging和Log4j； 始终使用SLF4J的接口写入日志，使用Logback只需要配置，不需要修改代码。 异常处理已完结，敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://niuxvdong.top/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}],"author":"Mr.Niu"},{"title":"Java教程系列之Java核心类","slug":"Java教程系列之Java核心类","date":"2020-03-27T09:56:43.000Z","updated":"2020-03-27T09:56:43.000Z","comments":true,"path":"posts/22799.html","link":"","permalink":"https://niuxvdong.top/posts/22799.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、字符串和编码1、字符串（String） 在Java中，String是一个引用类型，它本身也是一个class。但是，Java编译器对String有特殊处理，即可以直接用\"...\"来表示一个字符串！ 实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的！ 因为String太常用了，所以Java提供了\"...\"这种字符串字面量表示方法。 Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。 12String s1 = \"hello!\";String s2 = new String(new char[] {'H', 'e', 'l', 'l', 'o', '!'}); 下面这个输出结果不一样，因为不可变性，所以其实就是指向变了！原来的字符串仍然在内存中！ 12345678public class Main { public static void main(String[] args) { String s = \"Hello\"; System.out.println(s); //Hello s = s.toUpperCase(); //HELLO System.out.println(s); }} 1.1 字符串比较（equal） 必须使用equals()方法而不能用==！ equal()方法比较的是实实在在指向的内容！ ==则比较的指向的对象或实例是否相同！ 一般情况下我们只需要比较内容，所以一定要射用equal方法！ 从表面上看，两个字符串用==和equals()比较都为true，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然s1和s2的引用就是相同的。 1234567891011121314public class Main { public static void main(String[] args) { String s1 = \"hello\"; String s2 = \"hello\"; System.out.println(s1 == s2);//true System.out.println(s1.equals(s2));//true // 上面纯属巧合！ String s3 = \"hello\"; String s4 = \"HELLO\".toLowerCase(); System.out.println(s3 == s4);//false System.out.println(s3.equals(s4));//true }} 要忽略大小写比较，使用equalsIgnoreCase()方法。 12345678910package com.test;public class codeTest { public static void main(String[] args) { String s = \"hello\"; String t = s.toUpperCase(); System.out.println(s.equals(t));//false System.out.println(s.equalsIgnoreCase(t));//true }} 1.2 字符串搜索 contains()：参数是CharSequence而不是String，因为CharSequence是String的父类。查找子串，返回bool型！ indexof()：返回查找第一次出现子串的下标位置！ lastIndexOf()：返回最后一次出现子串的下标位置！ startsWith()：返回是否以子串开头的bool型值！ endwith()：返回是否以子串结尾的bool型值！ substring()：截取子串！ substring(a)：返回下标a开始到最后！ substring(a, b)：返回下标a开始到b为止，左闭右开！ 1234567891011// 是否包含子串:\"Hello\".contains(\"ll\"); // true\"Hello\".indexOf(\"l\"); // 2\"Hello\".lastIndexOf(\"l\"); // 3\"Hello\".startsWith(\"He\"); // true\"Hello\".endsWith(\"lo\"); // true\"Hello\".substring(2); // \"llo\"\"Hello\".substring(2, 4); \"ll\" 1.3 取出首尾空白字符 trim()：移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n!并没有改变字符串的内容，而是返回了一个新字符串。 strip()：移除字符串首尾空白字符。它和trim()不同的是，类似中文的空格字符\\u3000也会被移除！ stripLeading()：移除首部！ stripTrailing()：移除尾部！ isEmpty()：潘福安字符串是否为空！ isBlank()：判断字符串是否为空白字符（空格）！ 1234567891011\" \\tHello\\r\\n \".trim(); // \"Hello\"\"\\u3000Hello\\u3000\".strip(); // \"Hello\"\" Hello \".stripLeading(); // \"Hello \"\" Hello \".stripTrailing(); // \" Hello\"\"\".isEmpty(); // true，因为字符串长度为0\" \".isEmpty(); // false，因为字符串长度不为0\" \\n\".isBlank(); // true，因为只包含空白字符\" Hello \".isBlank(); // false，因为包含非空白字符 1.4 子串替换（replace） 使用replace()方法： 123String s = \"hello\";s.replace('l', 'w'); // \"hewwo\"，所有字符'l'被替换为'w's.replace(\"ll\", \"~~\"); // \"he~~o\"，所有子串\"ll\"被替换为\"~~\" 使用正则表达式： 参考我之前在JavaScript教程的RegExp：点击这里! 当然语法不太相同，后面的java教程会讲到Re！ 12String s = \"A,,B;C ,D\";String tt = s.replaceAll(\"[,;\\\\s]+\", \",\"); // \"A,B,C,D\" 1.5 字符串分割 split()：参数为正则表达式！ 12String s = \"A,B,C,D\";String[] ss = s.split(\",\"); // {\"A\", \"B\", \"C\", \"D\"} 1.6 字符串拼接 join()：用指定的字符串连接字符串数组! 12String[] arr = {\"A\", \"B\", \"C\"};String s = String.join(\"***\", arr); // \"A***B***C\" 1.7 类型转换其他类型转换为字符串： valueof()：把任意基本类型或引用类型转换为字符串，这是一个重载方法，编译器会根据参数自动选择合适的方法！ 1234String.valueOf(123); // \"123\"String.valueOf(45.67); // \"45.67\"String.valueOf(true); // \"true\"String.valueOf(new Object()); // 输出java.lang.Object@636be97c 字符串转换为其他类型： Integer.parseInt()：int转换为String！ Boolean.parseBoolean()：boolean转换为String！ 12345int n1 = Integer.parseInt(\"123\"); // 123int n2 = Integer.parseInt(\"ff\", 16); // 按十六进制转换，255boolean b1 = Boolean.parseBoolean(\"true\"); // trueboolean b2 = Boolean.parseBoolean(\"FALSE\"); // false Integer的getInteger(String)方法，它不是将字符串转换为int，而是把该字符串对应的系统变量转换为Integer： 1System.out.println(\"java版本：\" + Integer.getInteger(\"java.version\"));// java版本：14 1.8 String与char[]互转 String转char[]：使用toCharArray()方法！ char[]转String：使用new String()方法！ 12char[] cs = \"Hello\".toCharArray(); // String -&gt; char[]String s = new String(cs); // char[] -&gt; String 通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份，所以，修改外部的char[]数组不会影响String实例内部的char[]数组，因为这是两个不同的数组。 new String()时：传入的是一个复制！ 123456789public class Main { public static void main(String[] args) { char[] cs = \"Hello\".toCharArray(); String s = new String(cs); System.out.println(s); cs[0] = 'X'; System.out.println(s); }} 当向类中传入引用时，外部改变会影响类的改变！ 由于Score内部直接引用了外部传入的int[]数组，这会造成外部代码对int[]数组的修改，影响到Score类的字段。如果外部代码不可信，这就会造成安全隐患。 可以使用数组的clone()方法， 123456789101112131415161718192021222324import java.util.Arrays;public class Main { public static void main(String[] args) { int[] scores = new int[] { 88, 77, 51, 66 }; Score s = new Score(scores); s.printScores();//[88, 77, 51, 66] scores[2] = 99; s.printScores();//[88, 77, 99, 66]修改后[88, 77, 51, 66] }}class Score { private int[] scores; public Score(int[] scores) { this.scores = scores; // 修改为使用克隆方法！ this.scores = scores.clone(); } public void printScores() { System.out.println(Arrays.toString(scores)); }} 2、字符编码 可参考廖雪峰的字符编码教程：点击这里！ 始终牢记：Java的String和char在内存中总是以Unicode编码表示。 2.1 ASCII编码 在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从0到127，最高位始终为0，称为ASCII编码。例如，字符'A'的编码是0x41，字符'1'的编码是0x31。 2.2 GB2312和GBK编码 如果要把汉字也纳入计算机编码，很显然一个字节是不够的。GB2312标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为1，以便和ASCII编码区分开。例如，汉字'中'的GB2312编码是0xd6d0。 1、收录不同：GB2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；GBK共收入21886个汉字和图形符号。 2、表示不同：GB2312对任意一个图形字符都采用两个字节表示，并对所收汉字进行了“分区”处理，每区含有94个汉字／符号，分别对应第一字节和第二字节。GBK采用双字节表示，总体编码范围为8140-FEFE之间，首字节在81-FE之间，尾字节在40-FE之间。 3、处理功能不同：对于人名、古汉语等方面出现的罕用字，GB2312不能处理，这导致了后来GBK 及GB18030 汉字字符集的出现。 GBK: 汉字国标扩展码,基本上采用了原来GB2312-80所有的汉字及码位，并涵盖了原Unicode中所有的汉字20902，总共收录了883个符号， 21003个汉字及提供了1894个造字码位。 Microsoft简体版中文Windows 95就是以GBK为内码，又由于GBK同时也涵盖了Unicode所有CJK汉字，所以也可以和Unicode做一一对应。 GB码，全称是GB2312-80《信息交换用汉字编码字符集 基本集》，1980年发布，是中文信息处理的国家标准，在大陆及海外使用简体中文的地区（如新加坡等）是强制使用的唯一中文编码。P-Windows3.2和苹果OS就是以GB2312为基本汉字编码， Windows 95/98则以GBK为基本汉字编码、但兼容支持GB2312。GB码共收录6763个简体汉字、682个符号，其中汉字部分：一级字3755，以拼音排序，二级字3008，以偏旁排序。该标准的制定和应用为规范、推动中文信息化进程起了很大作用。 GBK编码是中国大陆制订的、等同于UCS的新的中文编码扩展国家标准。GBK工作小组于1995年10月，同年12月完成GBK规范。该编码标准兼容GB2312，共收录汉字21003个、符号883个，并提供1894个造字码位，简、繁体字融于一库。 2.3 Unicode编码 为了统一全球所有语言的编码，全球统一码联盟发布了Unicode编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。 Unicode编码需要两个或者更多字节表示！ 2.4 UTF-8编码 因为英文字符的Unicode编码高字节总是00，包含大量英文的文本会浪费空间，所以，出现了UTF-8编码，它是一种变长编码，用来把固定长度的Unicode编码变成1～4字节的变长编码。通过UTF-8编码，英文字符'A'的UTF-8编码变为0x41，正好和ASCII码一致，而中文'中'的UTF-8编码为3字节0xe4b8ad。 UTF-8编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为UTF-8编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。 在Java中，char类型实际上就是两个字节的Unicode编码。如果我们要手动把字符串转换成其他编码，可以这样做： getBytes(\"UTF-8\")：这个编译通不过。。 使用getBytes(StandardCharsets.UTF_8)才可以！ 了解一下就好！ 转换编码后，就不再是char类型，而是byte类型表示的数组。 1234byte[] b1 = \"Hello\".getBytes(); // 按系统默认编码转换，不推荐byte[] b2 = \"Hello\".getBytes(\"UTF-8\"); // 按UTF-8编码转换byte[] b2 = \"Hello\".getBytes(\"GBK\"); // 按GBK编码转换byte[] b3 = \"Hello\".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换 将byte[]转换为String，可以这样做： 123byte[] b = ...String s1 = new String(b, \"GBK\"); // 按GBK转换String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换 3、String存储方式 早期JDK版本的String总是以char[]存储： 12345public final class String { private final char[] value; private final int offset; private final int count;} 较新的JDK版本的String则以byte[]存储： 如果String仅包含ASCII字符，则每个byte存储一个字符，否则，每两个byte存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的String通常仅包含ASCII字符： 对于使用者来说，String内部的优化不影响任何已有代码，因为它的public方法签名是不变的。 123public final class String { private final byte[] value; private final byte coder; // 0 = LATIN1, 1 = UTF16 二、StringBuilder 使用String拼接字符串时，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC(垃圾回收)效率。 为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象： 其他许多方法去编译器就可以看到！ 你可能还听说过StringBuffer，这是Java早期的一个StringBuilder的线程安全版本，它通过同步来保证多个线程操作StringBuffer也是安全的，但是同步会带来执行速度的下降。 StringBuilder和StringBuffer接口完全相同，现在完全没有必要使用StringBuffer。 也就是说StringBuffer已经是一个淘汰品了，不需要使用了！ 最大作用：高效拼接字符串！ 可以进行链式操作： 进行链式操作的关键是，定义的append()方法会返回this，这样，就可以不断调用自身的其他方法！ 参数capacity为初始容量，不够时，自动扩大为当前的二倍！ 也可以不写该参数！ 12345678910public class Main { public static void main(String[] args) { var sb = new StringBuilder(1024); sb.append(\"Mr \") .append(\"Bob\") .append(\"!\") .insert(0, \"Hello, \"); System.out.println(sb.toString()); }} 来设计一个支持链式操作的类！关键当然是可以返回this即可！ 12345678910111213141516171819202122232425262728public class Main { public static void main(String[] args) { Adder adder = new Adder(); adder.add(3) .add(5) .inc() .add(10); System.out.println(adder.value()); }}class Adder { private int sum = 0; public Adder add(int n) { sum += n; return this; } public Adder inc() { sum ++; return this; } public int value() { return sum; }} 对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作。 三、StringJoiner 最大作用：可以用分隔符拼接字符串，也可以指定开始和结束！ StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的！！ 123456789101112131415import java.util.StringJoiner;public class Main { public static void main(String[] args) { String[] names = {\"Bob\", \"Alice\", \"Grace\"}; // 按逗号分隔 var sj = new StringJoiner(\", \"); // 指定开头和结尾 var sj = new StringJoiner(\", \", \"Hello \", \"!\"); for (String name : names) { sj.add(name); } System.out.println(sj.toString()); }} 不需要开头结尾时，可以使用更方便的String.join() 12String[] names = {\"Bob\", \"Alice\", \"Grace\"};var s = String.join(\", \", names); 四、包装类型Java的两种数据类型： 基本类型：byte，short，int，long，boolean，float，double，char 引用类型：所有class和interface类型 引用类型可以赋值为null，表示空，但基本类型不能赋值为null： 12String s = null;int n = null; // compile error! 将基本类型转换为引用类型就是包装类型！ 1、int转Integer12345678Integer n = null;Integer n2 = new Integer(99);Integer n3 = 98;Integer n4 = Integer.valueOf(99);// 通过静态方法valueOf(String)创建Integer实例:Integer n5 = Integer.valueOf(\"100\");int n6 = n2.intValue();int n7 = n3; Java对应的基本类型的包装类型： 基本类型 对应的引用类型 boolean java.lang.Boolean byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double char java.lang.Character 2、Auto Boxing 由于可以自动互转，所以可以直接简化的写，编译器自动完成转换加上相应语句！ 这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。 注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。 装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException： 123456Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue()// 这样拆箱会报错的：Integer n = null;int i = n; 3、不变类（final class） 所有的包装类型都是不变类，如Integer的源码： 两个Integer比较大小，不能使用==, 一定要用equal()方法! ，==比较，较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);，为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。 1234567891011121314151617public final class Integer { private final int value;}// 比较：public class Main { public static void main(String[] args) { Integer x = 127; Integer y = 127; Integer m = 99999; Integer n = 99999; System.out.println(\"x == y: \" + (x==y)); // true System.out.println(\"m == n: \" + (m==n)); // false System.out.println(\"x.equals(y): \" + x.equals(y)); // true System.out.println(\"m.equals(n): \" + m.equals(n)); // true }} 因为Integer.valueOf()可能始终返回同一个Integer实例，因此，在我们自己创建Integer的时候，以下两种方法： 方法1：Integer n = new Integer(100); 方法2：Integer n = Integer.valueOf(100); 方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。 我们把能创建“新”对象的静态方法称为静态工厂方法。Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。 创建新对象时，优先选用静态工厂方法而不是new操作符。 如果我们考察Byte.valueOf()方法的源码，可以看到，标准库返回的Byte实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例！ 4、Integer的进制转换 使用Integer.parseInt()方法或者是toString()....等等！ 输出结果都是String类型！ 12345678910111213public class Main { public static void main(String[] args) { // 将字符串解析成一个整数： int x1 = Integer.parseInt(\"100\"); // 100 int x2 = Integer.parseInt(\"100\", 16); // 256,因为按16进制解析 System.out.println(Integer.toString(100)); // \"100\",表示为10进制 System.out.println(Integer.toString(100, 36)); // \"2s\",表示为36进制 System.out.println(Integer.toHexString(100)); // \"64\",表示为16进制 System.out.println(Integer.toOctalString(100)); // \"144\",表示为8进制 System.out.println(Integer.toBinaryString(100)); // \"1100100\",表示为2进制 }} 5、静态变量一些静态变量： 123456789// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:Boolean t = Boolean.TRUE;Boolean f = Boolean.FALSE;// int可表示的最大/最小值:int max = Integer.MAX_VALUE; // 2147483647int min = Integer.MIN_VALUE; // -2147483648// long类型占用的bit和byte数量:int sizeOfLong = Long.SIZE; // 64 (bits)int bytesOfLong = Long.BYTES; // 8 (bytes) 所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型： 12345678// 向上转型为Number:Number num = new Integer(999);// 获取byte, int, long, float, double:byte b = num.byteValue();int n = num.intValue();long ln = num.longValue();float f = num.floatValue();double d = num.doubleValue(); 5、无符号处理 在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。 因为byte的-1的二进制表示是11111111，以无符号整型转换后的int就是255。 类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。 12345678910111213public class Main { public static void main(String[] args) { byte x = -1; byte y = 1; short r = -1; int t = -1; System.out.println(Byte.toUnsignedInt(x)); // 255 System.out.println(Byte.toUnsignedInt(y)); // 127 System.out.println(Short.toUnsignedInt(r));//65535 System.out.println(Integer.toUnsignedLong(t));//4294967295 }} 无、JavaBean在Java中，有很多class的定义都符合这样的规范： 若干private实例字段； 通过public方法来读写实例字段。 1、JavaBean规范如果读写方法符合以下这种命名规范： 12345678910// 读方法:public Type getXyz()// 写方法:public void setXyz(Type value)// boolean特殊：读方法一般命名为isXyz()：// 读方法:public boolean isChild()// 写方法:public void setChild(boolean value) 那么这种class被称为JavaBean： 上面的字段是xyz，那么读写方法名分别以get和set开头，并且后接大写字母开头的字段名Xyz，因此两个读写方法名分别是getXyz()和setXyz() 我们通常把一组对应的读方法（getter）和写方法（setter）称为属性（property）。例如，name属性： 对应的读方法是String getName() 对应的写方法是setName(String) 只有getter的属性称为只读属性（read-only），例如，定义一个age只读属性： 对应的读方法是int getAge() 无对应的写方法setAge(int) 类似的，只有setter的属性称为只写属性（write-only）。 很明显，只读属性很常见，只写属性不常见。 getter和setter就实现了一种数据封装的方法！ 1234567891011121314public class Person { private String name; private int age; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public int getAge() { return this.age; } public void setAge(int age) { this.age = age; } public boolean isChild() { return age &lt;= 6; }} 2、JavaBean作用 JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。 通过IDE，可以快速生成getter和setter！ 3、枚举JavaBean属性 了解即可！ 使用Introspector.getBeanInfo()可以获取属性列表。 1234567891011121314151617181920212223242526272829303132333435363738package com.test;import java.beans.BeanInfo;import java.beans.IntrospectionException;import java.beans.Introspector;import java.beans.PropertyDescriptor;public class codeTest { public static void main(String[] args) throws IntrospectionException { BeanInfo info = Introspector.getBeanInfo(Person.class); for (PropertyDescriptor pd : info.getPropertyDescriptors()) { System.out.println(pd.getName()); System.out.println(\" \" + pd.getReadMethod()); System.out.println(\" \" + pd.getWriteMethod()); } }}class Persons { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 输出结果： 123456789101112age public int com.test.Person.getAge() public void com.test.Person.setAge(int)birth public int com.test.Person.getBirth() public void com.test.Person.setBirth(int)class public final native java.lang.Class java.lang.Object.getClass() nullname public java.lang.String com.test.Person.getName() public void com.test.Person.setName(java.lang.String) 六、枚举类（enum） 为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类！ 注意到定义枚举类是通过关键字enum实现的，我们只需依次列出枚举的常量名。 和int定义的常量相比，使用enum定义枚举有如下好处： 首先，enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误。 其次，不可能引用到非枚举的值，因为无法通过编译。 最后，不同类型的枚举不能互相比较或者赋值，因为类型不符！ 使用enum定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用equals()方法，如果使用==比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用equals()方法，但enum类型可以例外。 因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较： 12345678910111213141516171819public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day == Weekday.SAT || day == Weekday.SUN) { System.out.println(\"Work at home!\"); } else { System.out.println(\"Work at office!\"); } // 这样是编译不会通过的： int day = 1; if (day == Weekday.SUN) { // Compile error: bad operand types for binary operator '==' } }}enum Weekday { SUN, MON, TUE, WED, THU, FRI, SAT;} 1、enum类型通过enum定义的枚举类，和其他的class有什么区别？ 答案是没有任何区别。enum定义的类型就是class，只不过它有以下几个特点： 定义的enum类型总是继承自java.lang.Enum，且无法被继承； 只能定义出enum的实例，而无法通过new操作符创建enum的实例； 定义的每个实例都是引用类型的唯一实例； 可以将enum类型用于switch语句。 12345678910111213public enum Color { RED, GREEN, BLUE;}// 编译后大概长这样：public final class Color extends Enum { // 继承自Enum，标记为final class // 每个实例均为全局唯一: public static final Color RED = new Color(); public static final Color GREEN = new Color(); public static final Color BLUE = new Color(); // private构造方法，确保外部无法调用new操作符: private Color() {}} 编译后的enum类和普通class并没有任何区别。但是我们自己无法按定义普通class那样来定义enum，必须使用enum关键字，这是Java语法规定的。 因为enum是一个class，每个枚举的值都是class实例！ 2、常用方法 name()：返回常量名！ ordinal()：返回定义常量的顺序（从0开始）！ 12String s = Weekday.SUN.name(); // \"SUN\"int n = Weekday.MON.ordinal(); // 1 注意：当枚举类Weekday内部的顺序发生变化时，通过ordinal()方法获取到的值也会相应改变！ 想要不受影响，新增的变量值一定要放到最后！ 解决方法： 要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段： 默认情况下，对枚举常量调用toString()会返回和name()一样的字符串。但是，toString()可以被覆写，而name()则不行。我们可以给Weekday添加toString()方法： 覆写toString()的目的是在输出时更有可读性。 注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！ 默认调用day的toString()方法！ toString()覆写后则调用覆写后的方法！ 12345678910111213141516171819202122232425262728public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day.dayValue == 6 || day.dayValue == 0) { // 默认调用day的toString()方法： System.out.println(\"Today is \" + day + \". Work at home!\"); } else { System.out.println(\"Today is \" + day + \". Work at office!\"); } }}enum Weekday { MON(1, \"星期一\"), TUE(2, \"星期二\"), WED(3, \"星期三\"), THU(4, \"星期四\"), FRI(5, \"星期五\"), SAT(6, \"星期六\"), SUN(0, \"星期日\"); public final int dayValue; private final String chinese; private Weekday(int dayValue, String chinese) { this.dayValue = dayValue; this.chinese = chinese; } @Override public String toString() { return this.chinese; }} 3、使用switch语句12345678910111213141516171819202122public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; switch(day) { case MON: case TUE: case WED: case THU: case FRI: System.out.println(\"Today is \" + day + \". Work at office!\"); break; case SAT: case SUN: System.out.println(\"Today is \" + day + \". Work at home!\"); break; } }}enum Weekday { MON, TUE, WED, THU, FRI, SAT, SUN;} 七、记录类（record） 使用String、Integer等类型的时候，这些类型都是不变类，一个不变类具有以下特点： 定义class时使用final，无法派生子类； 每个字段使用final，保证创建实例后无法修改任何字段。 为了保证不变类的比较，还需要正确覆写equals()和hashCode()方法，这样才能在集合类中正常使用。 从Java 14开始，引入了新的Record类。我们定义Record类时，使用关键字record， 1、record类 除了用final修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写toString()、equals()和hashCode()方法。 换句话说，使用record关键字，可以一行写出一个不变类。 和enum类似，我们自己不能直接从Record派生，只能通过record关键字由编译器实现继承。 12345678910public class Main { public static void main(String[] args) { Point p = new Point(123, 456); System.out.println(p.x()); System.out.println(p.y()); System.out.println(p); }}public record Point(int x, int y) {} 编译时编译器自动完成所需要的代码以及需要覆写的代码： 12345678910111213141516171819202122232425262728public final class Point extends Record { private final int x; private final int y; public Point(int x, int y) { this.x = x; this.y = y; } public int x() { return this.x; } public int y() { return this.y; } public String toString() { return String.format(\"Point[x=%s, y=%s]\", x, y); } public boolean equals(Object o) { ... } public int hashCode() { ... }} 2、record的构造方法 编译器默认按照record声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？ 假设Point类的x、y不允许负数，我们就得给Point的构造方法加上检查逻辑： 123456789101112131415161718192021public record Point(int x, int y) { public Point { if (x &lt; 0 || y &lt; 0) { throw new IllegalArgumentException(); } }}// 编译后的代码长这样：public final class Point extends Record { public Point(int x, int y) { // 这是我们编写的Compact Constructor: if (x &lt; 0 || y &lt; 0) { throw new IllegalArgumentException(); } // 这是编译器继续生成的赋值代码: this.x = x; this.y = y; } ...} 3、可以编写静态方法1234567891011public record Point(int x, int y) { public static Point of() { return new Point(0, 0); } public static Point of(int x, int y) { return new Point(x, y); }}var z = Point.of();var p = Point.of(123, 456); 4、小结：从Java 14开始，提供新的record关键字，可以非常方便地定义Data Class： 使用record定义的是不变类； 可以编写Compact Constructor（构造方法）对参数进行验证； 可以定义静态方法。 八、BigInteger 超出long的范围时可以使用java.math.BigInteger，来模拟大整数！ BigInteger内部用一个int[]数组来模拟一个非常大的整数！ 做运算时，只能通过实例方法来进行！ 和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢！ 可以使用longVanlue()方法来将其转化为long类型，前提当然是没有超过long的范围！超过会把报错！ 1234567891011121314151617181920BigInteger bi = new BigInteger(\"1234567890\");System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000// 加法BigInteger i1 = new BigInteger(\"1234567890\");BigInteger i2 = new BigInteger(\"12345678901234567890\");BigInteger sum = i1.add(i2); // 12345678902469135780// 转换为longBigInteger i = new BigInteger(\"123456789000\");System.out.println(i.longValue()); // 123456789000System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range// + - * /BigInteger s1 = s.add(new BigInteger(\"328423\"));BigInteger s3 = s.subtract(new BigInteger(\"89789797\"));BigInteger s2 = s.multiply(new BigInteger(\"328423\"));BigInteger s4 = s.divide(new BigInteger(\"2379743489\"));// s的5次方BigInteger s5 = s.pow(5); BigInteger和Integer、Long一样，也是不可变类，并且也继承自Number类。因为Number定义了转换为基本类型的几个方法： 转换为byte：byteValue() 转换为short：shortValue() 转换为int：intValue() 转换为long：longValue() 转换为float：floatValue() 转换为double：doubleValue() 因此，通过上述方法，可以把BigInteger转换成基本类型。如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。 float没有floatValueExact()方法，超出范围会输出Infintity； 123456789101112131415import java.math.BigInteger;public class Main { public static void main(String[] args) { BigInteger n = new BigInteger(\"999999\").pow(99); float f = n.floatValue(); System.out.println(f);//Infinity int s = n.intValueExact(); System.out.println(s);//报错 int s = n.intValue(); System.out.println(s);//结果会丢失，不准确！ }} 九、BigDecimal 和BigInteger类似，BigDecimal可以表示一个任意大小且精度完全准确的浮点数。 BigDecimal也是从Number继承的，也是不可变对象。 当然也有和BigInteger一样的方法！ BigDecimal用于表示精确的小数，常用于财务计算； 12BigDecimal bd = new BigDecimal(\"123.4567\");System.out.println(bd.multiply(bd)); // 15241.55677489 scale()：可以计算小数位数！ stripTrailingZeros()：去掉小数末尾的0！ 若为整数，则返回整数末尾的0的个数，为负值！ 12345678910111213141516BigDecimal d1 = new BigDecimal(\"123.45\");BigDecimal d2 = new BigDecimal(\"123.4500\");BigDecimal d3 = new BigDecimal(\"1234500\");System.out.println(d1.scale()); // 2,两位小数System.out.println(d2.scale()); // 4System.out.println(d3.scale()); // 0BigDecimal d1 = new BigDecimal(\"123.4500\");BigDecimal d2 = d1.stripTrailingZeros();System.out.println(d1.scale()); // 4System.out.println(d2.scale()); // 2,因为去掉了00BigDecimal d3 = new BigDecimal(\"1234500\");BigDecimal d4 = d3.stripTrailingZeros();System.out.println(d3.scale()); // 0System.out.println(d4.scale()); // -2 setScale()：设置精度，小数位数。两种截断方法： RoundingMode.HALF_UP：四舍五入截断 RoundingMode.DOWN：直接截断 123456789101112import java.math.BigDecimal;import java.math.RoundingMode;public class Main { public static void main(String[] args) { BigDecimal d1 = new BigDecimal(\"123.456789\"); BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568 BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567 System.out.println(d2); System.out.println(d3); }} 对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断： 1234BigDecimal d1 = new BigDecimal(\"123.456\");BigDecimal d2 = new BigDecimal(\"23.456789\");BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽 divideAndRemainder()：返回除数和余数！ signum()：有余数返回1，余数为0返回0！ 调用divideAndRemainder()方法时，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个BigDecimal是否是整数倍数： 123456789101112BigDecimal n = new BigDecimal(\"12.345\");BigDecimal m = new BigDecimal(\"0.12\");BigDecimal[] dr = n.divideAndRemainder(m);System.out.println(dr[0]); // 102System.out.println(dr[1]); // 0.105BigDecimal n = new BigDecimal(\"12.75\");BigDecimal m = new BigDecimal(\"0.15\");BigDecimal[] dr = n.divideAndRemainder(m);if (dr[1].signum() == 0) { // n是m的整数倍} BigDecimal比较 equal()方法，不但要求两个BigDecimal的值相等，还要求它们的scale()相等！ 可以使用stripTrailingZeros()去掉末尾0再比较！ 也可以使用compareTo()方法：它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。 比较必须使用compareTo()方法！ 12345BigDecimal d1 = new BigDecimal(\"123.456\");BigDecimal d2 = new BigDecimal(\"123.45600\");System.out.println(d1.equals(d2)); // false,因为scale不同System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2System.out.println(d1.compareTo(d2)); // 0 十、其他常用类1、Math类 Java标准库还提供了一个StrictMath，它提供了和Math几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，StrictMath保证所有平台计算结果都是完全相同的，而Math会尽量针对平台优化计算速度，所以，绝大多数情况下，使用Math就足够了。 abs()：绝对值 max()：最大 min()：最小 sqrt()：开方 exp()：e的x次方 log()：以e为底对数 log10()：以10为底对数 sin()、cos()、tan()、asin()、acos()：三角函数 PI：pai(3.14….) E：e(2.718….) 1234567891011121314151617Math.abs(-100); // 100Math.max(100, 99); // 100Math.min(1.2, 2.3); // 1.2Math.pow(2, 10); // 2的10次方=1024Math.sqrt(2); // 1.414...Math.exp(2); // 7.389...Math.log(4); // 1.386...Math.log10(100); // 2Math.sin(3.14); // 0.00159...Math.cos(3.14); // -0.9999...Math.tan(3.14); // -0.0015...Math.asin(1.0); // 1.57079...Math.acos(1.0); // 0.0double pi = Math.PI; // 3.14159...double e = Math.E; // 2.7182818...Math.sin(Math.PI / 6); // sin(π/6) = 0.5 2、Random类 Random用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。 要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()： 123456Random r = new Random();r.nextInt(); // 2071575453,每次都不一样r.nextInt(10); // 5,生成一个[0,10)之间的intr.nextLong(); // 8811649292570369305,每次都不一样r.nextFloat(); // 0.54335...生成一个[0,1)之间的floatr.nextDouble(); // 0.3716...生成一个[0,1)之间的double 倘若在创建实例时给定一个种子，则随机生成的数都是一定的，不会改变，不给种子是按照当前的时间戳自动确定种子，由于每时每刻时间不同，所以生成的数不同： 12Random r = new Random(3);System.out.println(r.nextInt());//-1155099828 3、SecureRandom类 有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的！ SecureRandom无法指定种子，它使用RNG（random number generator）算法。JDK的SecureRandom实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器： SecureRandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。 在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用SecureRandom来产生安全的随机数。 需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！ 虽然有点没看懂！以后回来再看！ 12345678910111213141516171819202122package com.test;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.util.Arrays;public class codeTest { public static void main(String[] args) { SecureRandom s = new SecureRandom(); System.out.println(s.nextInt()); SecureRandom sr = null; try { sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器 } catch (NoSuchAlgorithmException e) { sr = new SecureRandom(); // 获取普通的安全随机数生成器 } byte[] buffer = new byte[16]; sr.nextBytes(buffer); // 用安全随机数填充buffer System.out.println(Arrays.toString(buffer)); }} 常用Java核心类终于完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"String","slug":"String","permalink":"https://niuxvdong.top/tags/String/"},{"name":"JavaBean","slug":"JavaBean","permalink":"https://niuxvdong.top/tags/JavaBean/"},{"name":"包装类型","slug":"包装类型","permalink":"https://niuxvdong.top/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"}],"author":"Mr.Niu"},{"title":"Java教程系列之面向对象编程","slug":"Java教程系列之面向对象编程","date":"2020-03-25T10:11:00.000Z","updated":"2020-03-25T10:11:00.000Z","comments":true,"path":"posts/40947.html","link":"","permalink":"https://niuxvdong.top/posts/40947.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、class 和 instance 就是常说的类和实例！ 1、定义class 一个class可以包含多个字段（field），字段用来描述一个类的特征。 上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。因此，通过class，把一组数据汇集到一个对象上，实现了数据封装。 public是用来修饰字段的，它表示这个字段可以被外部访问。 123456789101112package com.test;public class codeTest { public static void main(String[] args) { }}class Person { public String name; public int age;} 2、创建instance 定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。 new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例： 访问实例变量可以用变量.字段 ! 小贴士：new出来的东西都在堆区，其他在栈区！ 1234567891011121314package com.test;public class codeTest { public static void main(String[] args) { Person ming = new Person(); ming.name = \"Xiao Ming\"; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = \"Xiao Hong\"; hong.age = 15; }} 上面创建的两个实例分别指向两块内存，存放在堆中！ 二、普通方法 通过在类的内部定义方法可以实现数据的封装，由于private的特性可以保证外部无法访问到私有成员field！ 一般使用set和get函数来进行赋值和获取，而字段field是private的，可以保证不被外部所修改！保证数据的安全性！ 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) { Person ming = new Person(); ming.setName(\"Xiao Ming\"); // 设置name ming.setAge(12); // 设置age System.out.println(ming.getName() + \", \" + ming.getAge()); }}class Person { private String name; private int age; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public int getAge() { return this.age; } public void setAge(int age) { if (age &lt; 0 || age &gt; 100) { throw new IllegalArgumentException(\"invalid age value\"); } this.age = age; }} 1、定义方法 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。 1234修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值;} 2、private方法 和private字段一样，private方法不允许外部调用，那我们定义private方法有什么用？ 定义private方法的理由是内部方法是可以调用private方法的。例如： 12345678910111213141516171819202122232425public class Main { public static void main(String[] args) { Person ming = new Person(); ming.setBirth(2008); System.out.println(ming.getAge()); }}class Person { private String name; private int birth; public void setBirth(int birth) { this.birth = birth; } public int getAge() { return calcAge(2019); // 调用private方法 } // private方法: private int calcAge(int currentYear) { return currentYear - this.birth; }} 观察上述代码，calcAge()是一个private方法，外部代码无法调用，但是，内部方法getAge()可以调用它。 此外，我们还注意到，这个Person类只定义了birth字段，没有定义age字段，获取age时，通过方法getAge()返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心Person实例在内部到底有没有age字段。 3、this变量 在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。因此，通过this.field就可以访问当前实例的字段。 3.1 没有命名冲突，直接return1234567class Person { private String name; public String getName() { return name; // 相当于this.name }} 3.2 有冲突，使用this.field1234567class Person { private String name; public void setName(String name) { this.name = name; // 前面的this不可少，少了就变成局部变量name了 }} 4、方法参数 方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递，对应位置对应相等！ 4.1 不可变参数123456class Person { ... public void setNameAndAge(String name, int age) { ... }} 4.2 可变参数 可变参数用类型...定义，可变参数相当于数组类型： 1234567class Group { private String[] names; public void setNames(String... names) { this.names = names; }} 也可以直接接收数组 1234567class Group { private String[] names; public void setNames(String[] names) { this.names = names; }} 二者的区别： 第一种可以直接方便的传参，而第二种只能使用new来传参，相比之下，第一种更加方便！ 12345678910111213public class Main { public static void main(String[] args) { // 第一种： Group g = new Group(); g.setNames(\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"); // 传入3个String g.setNames(\"Xiao Ming\"); // 传入1个String g.setNames(); // 传入0个String // 第二种： Group g = new Group(); g.setNames(new String[] {\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"}); // 传入1个String[] }} 可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null。 5、参数绑定 基本类型参数的传递：是调用外部方法值的复制。双方各自的后续修改，互不影响。 引用类型参数的绑定：调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。 下面就是引用型参数例子，main中的修改会影响到类的field，因为指向的是同一块内存地址！ 12345678910111213141516171819202122public class Main { public static void main(String[] args) { Person p = new Person(); String[] fullname = new String[] { \"Homer\", \"Simpson\" }; p.setName(fullname); // 传入fullname数组 System.out.println(p.getName()); // \"Homer Simpson\" fullname[0] = \"Bart\"; // fullname数组的第一个元素修改为\"Bart\" System.out.println(p.getName()); // \"Homer Simpson\"还是\"Bart Simpson\"? }}class Person { private String[] name; public String getName() { return this.name[0] + \" \" + this.name[1]; } public void setName(String[] name) { this.name = name; }} 三、构造方法 在创建对象实例时就把内部字段进行初始化的操作！ 1、构造方法 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false： 默认任何class都有构造方法！ 编译器自动生成：它没有参数，也没有执行语句，类似这样： 1234class Person { public Person() { }} 如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法： 如下方：无法找到默认构造函数Person()！ 1234567891011121314151617181920212223public class Main { public static void main(String[] args) { Person p = new Person(); // 编译错误:找不到这个构造方法 }}class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; }} 当然可以将原来的默认方法与自定义的构造方法通过重载都写出来！ 2、构造方法重载 默认的构造方法依然可以使用！ 在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分 1234567891011121314151617class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this.name = name; this.age = 12; } public Person() { }} 3、构造方法自我调用 一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)： 1234567891011121314151617class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this(name, 18); // 调用另一个构造方法Person(String, int) } public Person() { this(\"Unnamed\"); // 调用另一个构造方法Person(String) }} 四、继承 继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让Student从Person继承时，Student就获得了Person的所有功能，我们只需要为Student编写新增的功能。 1、使用extends实现继承 在OOP的术语中，我们把Person称为超类（super class），父类（parent class），基类（base class），把Student称为子类（subclass），扩展类（extended class）。 123456789101112131415161718class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...}}class Student extends Person { // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() { … } public void setScore(int score) { … }} 注意到我们在定义Person的时候，没有写extends。在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类。 Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。 2、使用protected 子类无法访问父类的private的字段field，可以使用protected来修饰字段，使得该字段可以在一个继承树中被访问！ protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问 12345678910class Person { protected String name; protected int age;}class Student extends Person { public String hello() { return \"Hello, \" + name; // OK! }} 3、super super关键字表示父类（超类）。子类引用父类的字段时，可以用s uper.fieldName! 12345class Student extends Person { public String hello() { return \"Hello, \" + super.name; }} 使用super.name，或者this.name，或者name，效果都是一样的。编译器会自动定位到父类的name字段。 在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super(); 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。 小贴士：子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。 若父类是默认构造方法，则子类使用时会自动调用，不需要写；若是自定义构造方法，需要调用super并加上参数！ 123456789101112131415161718192021222324public class Main { public static void main(String[] args) { Student s = new Student(\"Xiao Ming\", 12, 89); }}class Person { protected String name; protected int age; public Person(String name, int age) { this.name = name; this.age = age; }}class Student extends Person { protected int score; public Student(String name, int age, int score) { super(name, age); // 自动调用父类的构造方法 this.score = score; }} 4、向上转型 把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。 Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！ 继承树是Student &gt; Person &gt; Object ，所以可以把Student类型转型为Person，或者更高层次的Object。 老子可以拓展到儿子级别扩大功能！！！。。 1234Student s = new Student();Person p = new Person();Person p = new Student(); // ??? 5、向下转型 和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting） 1234Person p1 = new Student(); // upcasting, okPerson p2 = new Person();Student s1 = (Student) p1; // okStudent s2 = (Student) p2; // runtime error! ClassCastException! Person类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。在向下转型的时候，把p1转型为Student会成功，因为p1确实指向Student实例，把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。 向下转型错误时候，Java虚拟机会报ClassCastException。 总而言之：就是少的可以拓展为多的，多的无法删减为少的（从左到右说）！ 使用instanceof instanceof实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false。 如果实里原来就是子类，则将其向下转型时是可以正确转型的！ 可以使用instaceof 来判断原来是不是子类，使得话则可以向下转型，这样就可以避免转型错误的发生！ 12345Person p = new Student();if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功} 从Java 14开始，判断instanceof后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码： 直接使用obj instanceof String s 即可在判断可以向下转型的条件下直接进行转型到变量 s！ 使用instanceof variable这种判断并转型为指定类型变量的语法时，必须打开编译器开关--source 14和--enable-preview。 这是java14的语法！ 1234567891011Object obj = \"hello\";if (obj instanceof String) { String s = (String) obj; System.out.println(s.toUpperCase());}Object obj = \"hello\";if (obj instanceof String s) { // 可以直接使用变量s: System.out.println(s.toUpperCase());} 五、多态1、覆写（Override） 在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。 Override和Overload不同的是，如果方法签名不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是Override。 就和重载一样，全部一样才是才叫覆写！ 123456789101112class Person { public void run() { System.out.println(\"Person.run\"); }}class Student extends Person { @Override public void run() { System.out.println(\"Student.run\"); }} 2、关于@Override 加上@Override可以让编译器来判断你是不是进行覆写时参数或类型写错了，若不同则会直接编译错误！ 倘若不加的话，是不会去检查的，编译器认为这是你新写的方法，编译通过！ 如下方：加上，编译错误，不加，编译通过！ 12345678910111213public class Main { public static void main(String[] args) { }}class Person { public void run() {}}public class Student extends Person { //@Override // Compile error! public void run(String s) {}} 3、多态（Polymorphic） 多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法 1234public void runTwice(Person p) { p.run(); p.run();} 它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。 所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？ 举个例子: 三种收税情况，覆写三种getTax函数，利用多态自动调用需要的覆写方法！ 观察totalTax()方法：利用多态，totalTax()方法只需要和Income打交道，它完全不需要知道Salary和StateCouncilSpecialAllowance的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从Income派生，然后正确覆写getTax()方法就可以。把新的类型传入totalTax()，不需要修改任何代码。 可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Main { public static void main(String[] args) { // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes = new Income[] { new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) }; System.out.println(totalTax(incomes)); } public static double totalTax(Income... incomes) { double total = 0; for (Income income: incomes) { total = total + income.getTax(); } return total; }}class Income { protected double income; public Income(double income) { this.income = income; } public double getTax() { return income * 0.1; // 税率10% }}class Salary extends Income { public Salary(double income) { super(income); } @Override public double getTax() { if (income &lt;= 5000) { return 0; } return (income - 5000) * 0.2; }}class StateCouncilSpecialAllowance extends Income { public StateCouncilSpecialAllowance(double income) { super(income); } @Override public double getTax() { return 0; }} 覆写object方法 因为所有的class最终都继承自Object，而Object定义了几个重要的方法： toString()：把instance输出为String； equals()：判断两个instance是否逻辑相等； hashCode()：计算一个instance的哈希值。 1234567891011121314151617181920212223242526class Person { ... // 显示更有意义的字符串: @Override public String toString() { return \"Person:name=\" + name; } // 比较是否相等: @Override public boolean equals(Object o) { // 当且仅当o为Person类型: if (o instanceof Person) { Person p = (Person) o; // 并且name字段相同时，返回true: return this.name.equals(p.name); } return false; } // 计算hash: @Override public int hashCode() { return this.name.hashCode(); }} 调用super 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。 1234567891011121314class Person { protected String name; public String hello() { return \"Hello, \" + name; }}Student extends Person { @Override public String hello() { // 调用父类的hello()方法: return super.hello() + \"!\"; }} 使用final 继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override： 12345678910111213class Person { protected String name; public final String hello() { return \"Hello, \" + name; }}Student extends Person { // compile error: 不允许覆写 @Override public String hello() { }} 如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承： 1234567final class Person { protected String name;}// compile error: 不允许继承自PersonStudent extends Person {} 对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改 可使用构造方法来进行给final字段赋值，赋值完毕，值将不可修改！ 1234567891011121314class Person { public final String name = \"Unamed\";}Person p = new Person();p.name = \"New Name\"; // compile error!// 定义构造函数赋值final字段class Person { public final String name; public Person(String name) { this.name = name; }} 4、一句话总结多态： JAVA变量在调用类方法时，以实际指向的实例类型为准，而不是声明类型 六、抽象类 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法： 把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person类也无法被实例化。编译器会告诉我们，无法编译Person类，因为它包含抽象方法。 必须把Person类本身也声明为abstract，才能正确编译它： 抽象方法不需要写大括号！ 123abstract class Person { public abstract void run();} 1、抽象类 如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。 因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。 使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类： 无法实例化的抽象类有什么用？ 因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。 例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法： 1234567891011121314151617public class Main { public static void main(String[] args) { Person p = new Student(); p.run(); }}abstract class Person { public abstract void run();}class Student extends Person { @Override public void run() { System.out.println(\"Student.run\"); }} 倘若不进行覆写run方法，则会直接编译错误！ 2、面向抽象编程 当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例： 这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型： 同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型： 这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。 12345678910Person s = new Student();Person t = new Teacher();// 不关心Person变量的具体子类型:s.run();t.run();// 同样不关心新的子类是如何实现run()方法的：Person e = new Employee();e.run(); 面向抽象编程的本质就是： 上层代码只定义规范（例如：abstract class Person）； 不需要子类就可以实现业务逻辑（正常编译）； 具体的业务逻辑由不同的子类实现，调用者并不关心。 七、接口 在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。 如果一个抽象类没有字段，所有方法全部都是抽象方法： 1234abstract class Person { public abstract void run(); public abstract String getName();} 1、接口（interface）就可以把该抽象类改写为接口：interface。 在Java中，使用interface可以声明一个接口： 所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。 Java的接口特指interface的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。 1234interface Person { void run(); String getName();} 2、implements 当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子： 1234567891011121314151617class Student implements Person { private String name; public Student(String name) { this.name = name; } @Override public void run() { System.out.println(this.name + \" run\"); } @Override public String getName() { return this.name; }} 我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，例如： 123class Student implements Person, Hello { // 实现了两个interface ...} 3、接口继承 一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如： 此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口。 12345678interface Hello { void hello();}interface Person extends Hello { void run(); String getName();} 4、抽象类与接口 合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度。 在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象! 5、default方法 在接口中，可以定义default方法。例如，把Person接口的run()方法改为default方法： 实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。 default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。 12345678910111213141516171819202122232425public class Main { public static void main(String[] args) { Person p = new Student(\"Xiao Ming\"); p.run(); }}interface Person { String getName(); default void run() { System.out.println(getName() + \" run\"); }}class Student implements Person { private String name; public Student(String name) { this.name = name; } public String getName() { return this.name; }} 6、一些接口的笔记为什么要有接口因为java中为了避免多重继承可能带来的继承关系混乱所以只允许单一继承，java为了 满足多重继承的需要，采用了规格的多重继承即接口,如果使用，即使没有继承关系的不同种类的对象也可以做共通的处理（我们可以在接口中定义一个方法，然后在两个没有继承关系的对象的不同父类中写一个相同方法签名和返回类型的方法） 接口和抽象类的区别 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实例是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。 类实现两个接口有同名方法时会发生的几种情况： 两个接口方法签名相同返回类型相同时 不会编译出错，可以直接override 两个接口方法签名相同返回类型不同，会编译出错。 两个接口方法名相同,在实现类里这两个同名方法签名符合overload条件的话可以同时实现不会报错，只要符合overload那方法返回类型就不重要了，一样不会报错。 类实现两个接口有同名default方法时会发生的几种情况 如果两个方法的方法签名相同方法返回类型相同那么需要在实现类override这个同名方法。 如果两个方法方法签名相同，返回类型不同会编译出错。 如果两个方法符合overload条件可以正常实现。 关于接口中的静态方法，静态变量静态变量： 可直接通过实现类或者实现类的实例直接访问到接口的静态变量,但如果多继承时这样调用会编译出错。 静态方法 无法通过实现类和它的实例访问到接口的静态方法 八、静态字段和静态方法1、静态字段 在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。 还有一种字段，是用static修饰的字段，称为静态字段：static field。 实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段 12345678910111213141516171819202122public class Main { public static void main(String[] args) { Person ming = new Person(\"Xiao Ming\", 12); Person hong = new Person(\"Xiao Hong\", 15); ming.number = 88; System.out.println(hong.number); hong.number = 99; System.out.println(ming.number); }}class Person { public String name; public int age; public static int number; public Person(String name, int age) { this.name = name; this.age = age; }} 如下图： 12345678910111213141516 ┌──────────────────┐ming ──&gt;│Person instance │ ├──────────────────┤ │name = \"Xiao Ming\"│ │age = 12 │ │number ───────────┼──┐ ┌─────────────┐ └──────────────────┘ │ │Person class │ │ ├─────────────┤ ├───&gt;│number = 99 │ ┌──────────────────┐ │ └─────────────┘hong ──&gt;│Person instance │ │ ├──────────────────┤ │ │name = \"Xiao Hong\"│ │ │age = 15 │ │ │number ───────────┼──┘ └──────────────────┘ 虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。 因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。 推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。对于上面的代码，更好的写法是： 12Person.number = 99;System.out.println(Person.number); 2、静态方法 有静态字段，就有静态方法。用static修饰的方法称为静态方法。 调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数! 因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。 通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。 通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。 1234567891011121314public class Main { public static void main(String[] args) { Person.setNumber(99); System.out.println(Person.number); }}class Person { public static int number; public static void setNumber(int value) { number = value; }} 3、接口静态字段 因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型。 实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉！ 编译器会自动把该字段变为public static final类型。 记得一个java文件只能有一个public类哦！ 1234567891011public interface Person { public static final int MALE = 1; public static final int FEMALE = 2;}// 改进写法！public interface Person { // 编译器会自动加上public statc final: int MALE = 1; int FEMALE = 2;} 九、包（package）1、package 在Java中，我们使用package来解决名字冲突。 Java定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是包名.类名。 包可以是多层结构，用.隔开。例如：java.util。 没有定义包名的class，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。 要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。 123456789101112package ming; // 申明包名mingpublic class Person { }// 第二个包package mr.jun; // 申明包名mr.junpublic class Arrays { } 我们还需要按照包结构把上面的Java文件组织起来。假设以package_sample作为根目录，src作为源码目录，那么所有文件结构就是： 123456789package_sample└─ src ├─ hong │ └─ Person.java │ ming │ └─ Person.java └─ mr └─ jun └─ Arrays.java 编译后的.class文件也需要按照包结构存放。如果使用IDE，把编译后的.class文件放到bin目录下，那么，编译的文件结构就是： 123456789package_sample└─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class 2、包作用域 位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。 123456789101112131415161718package hello;public class Person { // 包作用域: void hello() { System.out.println(\"Hello!\"); }}// 同包调用package hello;public class Main { public static void main(String[] args) { Person p = new Person(); p.hello(); // 可以调用，因为Main和Person在同一个包 }} 3、import 为了引用其他包的类可以使用import导入包名！ 导入也可以直接写完整路径，很明显，不这样做！ 1234567891011121314151617181920// Person.javapackage ming;public class Person { public void run() { mr.jun.Arrays arrays = new mr.jun.Arrays(); }}// Person.javapackage ming;// 导入完整类名:import mr.jun.Arrays;public class Person { public void run() { Arrays arrays = new Arrays(); }} 在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）： 我们一般不推荐这种写法，因为在导入了多个包后，很难看出Arrays类属于哪个包。 1234567891011// Person.javapackage ming;// 导入mr.jun包的所有class:import mr.jun.*;public class Person { public void run() { Arrays arrays = new Arrays(); }} 还有一种import static的语法，它可以导入可以导入一个类的静态字段和静态方法： import static很少使用。 1234567891011package main;// 导入System类的所有静态字段和静态方法:import static java.lang.System.*;public class Main { public static void main(String[] args) { // 相当于调用System.out.println(…) out.println(\"Hello, world!\"); }} 4、包命名为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如： org.apache org.apache.commons.log com.niuge.sample 子包就可以根据功能自行命名。 5、class查找顺序Java编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时： 如果是完整类名，就直接根据完整类名查找这个class； 如果是简单类名，按下面的顺序依次查找： 查找当前package是否存在这个class； 查找import的包是否包含这个class； 查找java.lang包是否包含这个class。 如果按照上面的规则还无法确定类名，则编译报错。 因此，编写class的时候，编译器会自动帮我们做两个import动作： 默认自动import当前package的其他class； 默认自动import java.lang.*。 注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。 如果有两个class名称相同，例如，mr.jun.Arrays和java.util.Arrays，那么只能import其中一个，另一个必须写完整类名。 十、作用域 在Java中，我们经常看到public、protected、private这些修饰符。在Java中，这些修饰符可以用来限定访问作用域。 1、public 定义为public的class、interface可以被其他任何类访问： 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限： 导入包，只可以访问public类型的class等等！ 2、private 定义为private的field、method无法被其他类访问： 实际上，确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面，因为public方法定义了类对外提供的功能，阅读代码的时候，应该先关注public方法： 12345678910package abc;public class Hello { public void hello() { this.hi(); } private void hi() { }} 嵌套类 Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限： 定义在一个class内部的class称为嵌套类（nested class），Java支持好几种嵌套类。 内部嵌套类必须使用static修饰！ 123456789101112131415161718public class Main { public static void main(String[] args) { Inner i = new Inner(); i.hi(); } // private方法: private static void hello() { System.out.println(\"private hello!\"); } // 静态内部类: static class Inner { public void hi() { Main.hello(); } }} 3、protected protected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类： 4、包作用域详见第九点的小2！ 5、局部变量 在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。 6、final请查看第五点的小3的final！ 7、tips 如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法。 把方法定义为package权限有助于测试，因为测试类和被测试类只要位于同一个package，测试代码就可以访问被测试类的package权限方法。 一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。 十一、classpath和jar 廖雪峰本节教程参考！点击这里！ 1、classpath classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。 因为Java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。 一般不需要设置，IDE编译时会自动引入当前bin目录的参数！。。。。 所以，classpath就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用;分隔，带空格的目录用\"\"括起来，可能长这样： 1C:\\work\\project1\\bin;C:\\shared;\"D:\\My Documents\\project1\\bin\" 在Linux系统上，用:分隔，可能长这样： 1/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin 现在我们假设classpath是.;C:\\work\\project1\\bin;C:\\shared，当JVM在加载abc.xyz.Hello这个类时，会依次查找： &lt;当前目录&gt;\\abc\\xyz\\Hello.class C:\\work\\project1\\bin\\abc\\xyz\\Hello.class C:\\shared\\abc\\xyz\\Hello.class 注意到.代表当前目录。如果JVM在某个路径下找到了对应的class文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。 classpath的设定方法有两种： 在系统环境变量中设置classpath环境变量，不推荐； 在启动JVM时设置classpath变量，推荐。 我们强烈不推荐在系统环境变量中设置classpath，那样会污染整个系统环境。在启动JVM时设置classpath才是推荐的做法。实际上就是给java命令传入-classpath或-cp参数： 1java -classpath .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello 或者使用-cp的简写： 1java -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello 没有设置系统环境变量，也没有传入-cp参数，那么JVM默认的classpath为.，即当前目录： 1java abc.xyz.Hello 上述命令告诉JVM只在当前目录搜索Hello.class。 在IDE中运行Java程序，IDE自动传入的-cp参数是当前工程的bin目录和引入的jar包。 通常，我们在自己编写的class中，会引用Java核心库的class，例如，String、ArrayList等。这些class应该上哪去找？ 有很多“如何设置classpath”的文章会告诉你把JVM自带的rt.jar放入classpath，但事实上，根本不需要告诉JVM如何去Java核心库查找class，JVM怎么可能笨到连自己的核心库在哪都不知道？ 不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！ 更好的做法是，不要设置classpath！默认的当前目录.对于绝大多数情况都够用了。 2、jar 如果有很多.class文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。 jar包就是用来干这个事的，它可以把package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。 jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的class，就可以把jar包放到classpath中： 就是用来打包class的文件！ 1java -cp ./hello.jar abc.xyz.Hello 这样JVM会自动在hello.jar文件里去搜索某个类。 那么问题来了：如何创建jar包？ 因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从.zip改为.jar，一个jar包就创建成功。 假设编译输出的目录结构是这样： 123456789package_sample└─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class 这里需要特别注意的是，jar包里的第一层目录，不能是bin，而应该是hong、ming、mr。 打包位置应该是bin目录进去之后，或者是IDEA的out目录进去之后！ jar包还可以包含一个特殊的/META-INF/MANIFEST.MF文件，MANIFEST.MF是纯文本，可以指定Main-Class和其它信息。JVM会自动读取这个MANIFEST.MF文件，如果存在Main-Class，我们就不必在命令行指定启动的类名，而是用更方便的命令： 1java -jar hello.jar jar包还可以包含其它jar包，这个时候，就需要在MANIFEST.MF文件里配置classpath了。 在大型项目中，不可能手动编写MANIFEST.MF文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如Maven，可以非常方便地创建jar包。 十二、模块 廖雪峰模块教程，点击这里！ 从Java 9开始，JDK又引入了模块（Module）。 我们知道，.class文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆.class文件，很不便于管理，所以，jar文件就是class文件的容器。 在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫rt.jar，一共有60多M。 如果是自己开发的程序，除了一个自己的app.jar以外，还需要一堆第三方的jar包 此节有点复杂以后回来再看！。。。 1、模块运行一个Java程序，一般来说，命令行写这样： 1java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main 注意：JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。 如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出ClassNotFoundException。 所以，jar只是用于存放class的容器，它并不关心class之间的依赖。 从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果a.jar必须依赖另一个b.jar才能运行，那我们应该给a.jar加点说明啥的，让程序在编译和运行的时候能自动定位到b.jar，这种自带“依赖关系”的class容器就是模块。 为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的rt.jar分拆成了几十个模块，这些模块以.jmod扩展名标识，可以在$JAVA_HOME/jmods目录下找到它们： java.base.jmod java.compiler.jmod java.datatransfer.jmod java.desktop.jmod … 这些.jmod文件每一个都是一个模块，模块名就是文件名。例如：模块java.base对应的文件就是java.base.jmod。模块之间的依赖关系已经被写入到模块内的module-info.class文件了。所有的模块都直接或间接地依赖java.base模块，只有java.base模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从Object直接或间接继承而来。 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。 2、编写模块那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以oop-module工程为例，它的目录结构如下： 12345678910oop-module├── bin├── build.sh└── src ├── com │ └── itranswarp │ └── sample │ ├── Greeting.java │ └── Main.java └── module-info.java 其中，bin目录存放编译后的class文件，src目录存放源码，按包名的目录结构存放，仅仅在src目录下多了一个module-info.java这个文件，这就是模块的描述文件。在这个模块中，它长这样： 1234module hello.world { requires java.base; // 可不写，任何模块都会自动引入java.base requires java.xml;} 其中，module是关键字，后面的hello.world是模块的名称，它的命名规范与包一致。花括号的requires xxx;表示这个模块需要引用的其他模块名。除了java.base可以被自动引入外，这里我们引入了一个java.xml的模块。 当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，Main.java代码如下： 1234567891011package com.itranswarp.sample;// 必须引入java.xml模块后才能使用其中的类:import javax.xml.XMLConstants;public class Main { public static void main(String[] args) { Greeting g = new Greeting(); System.out.println(g.hello(XMLConstants.XML_NS_PREFIX)); }} 如果把requires java.xml;从module-info.java中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。 下面，我们用JDK提供的命令行工具来编译并创建模块。 首先，我们把工作目录切换到oop-module，在当前目录下编译所有的.java文件，并存放到bin目录下，命令如下： 1$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java 如果编译成功，现在项目结构如下： 123456789101112131415oop-module├── bin│ ├── com│ │ └── itranswarp│ │ └── sample│ │ ├── Greeting.class│ │ └── Main.class│ └── module-info.class└── src ├── com │ └── itranswarp │ └── sample │ ├── Greeting.java │ └── Main.java └── module-info.java 注意到src目录下的module-info.java被编译到bin目录下的module-info.class。 下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入--main-class参数，让这个jar包能自己定位main方法所在的类： 1$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin . 现在我们就在当前目录下得到了hello.jar这个jar包，它和普通jar包并无区别，可以直接使用命令java -jar hello.jar来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的jmod命令把一个jar包转换成模块： 1$ jmod create --class-path hello.jar hello.jmod 于是，在当前目录下我们又得到了hello.jmod这个模块文件，这就是最后打包出来的传说中的模块！ 3、运行模块 要运行一个jar，我们使用java -jar xxx.jar命令。要运行一个模块，我们只需要指定模块名。试试： 1$ java --module-path hello.jmod --module hello.world 结果是一个错误： 12Error occurred during initialization of boot layerjava.lang.module.FindException: JMOD format not supported at execution time: hello.jmod 原因是.jmod不能被放入--module-path中。换成.jar就没问题了： 12$ java --module-path hello.jar --module hello.worldHello, xml! 那我们辛辛苦苦创建的hello.jmod有什么用？答案是我们可以用它来打包JRE。 4、打包JRE 前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的rt.jar拆成了几十个.jmod模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。 过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？ 现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了jlink命令来干这件事。命令如下： 1$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/ 我们在--module-path参数指定了我们自己的模块hello.jmod，然后，在--add-modules参数中指定了我们用到的3个模块java.base、java.xml和hello.world，用,分隔。最后，在--output参数指定输出目录。 现在，在当前目录下，我们可以找到jre目录，这是一个完整的并且带有我们自己hello.jmod模块的JRE。试试直接运行这个JRE： 12$ jre/bin/java --module hello.worldHello, xml! 要分发我们自己的Java应用程序，只需要把这个jre目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。 5、访问权限 前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。 确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。 举个例子：我们编写的模块hello.world用到了模块java.xml的一个类javax.xml.XMLConstants，我们之所以能直接使用这个类，是因为模块java.xml的module-info.java中声明了若干导出： 123456module java.xml { exports java.xml; exports javax.xml.catalog; exports javax.xml.datatype; ...} 只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的hello.world模块中的com.itranswarp.sample.Greeting类，我们必须将其导出： 123456module hello.world { exports com.itranswarp.sample; requires java.base; requires java.xml;} 因此，模块进一步隔离了代码的访问权限。 Java面向对象告一段落了，敬请期待后序内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://niuxvdong.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"author":"Mr.Niu"},{"title":"AcWing-41.包含min函数的栈","slug":"AcWing-41-包含min函数的栈","date":"2020-03-23T12:11:57.000Z","updated":"2020-03-23T12:11:57.000Z","comments":true,"path":"posts/50257.html","link":"","permalink":"https://niuxvdong.top/posts/50257.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：41. 包含min函数的栈 题目背景： 来源：剑指Offer,《算法竞赛进阶指南》, 美国 Hulu公式 面试题！ 两种做法：详细见下文！ 题目描述设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。 push(x)–将元素x插入栈中 pop()–移除栈顶元素 top()–得到栈顶元素 getMin()–得到栈中最小元素 样例12345678MinStack minStack = new MinStack();minStack.push(-1);minStack.push(3);minStack.push(-4);minStack.getMin(); --&gt; Returns -4.minStack.pop();minStack.top(); --&gt; Returns 3.minStack.getMin(); --&gt; Returns -1. 题目分析：题目要求：在普通栈的基础上实现一个可以实时获得最小值的 最小栈 ，而且使得复杂度达到O(1)的效果！ 解题思路：第一想法：暴力即可，其他操作都是O(1)的，只有获得最小值的操作不好弄，暴力的话直接扫描一遍，复杂度为O(N)，很明显不合题意！ 好了，正确解法开始！ 解法一：维护两个栈，一个为普通栈，一个为保存前i个数最小值的栈！ 最小栈的第i个位置永远保存前i个位置的最小值！ 最小栈的实现： push时：为空直接压入，不为空只需要判断当前栈顶与当前值得大小取一下min放入栈中即可！ pop时：直接删除即可！ top时：返回普通栈栈顶！ getMin时：直接返回栈顶即可！ 解法二：维护两个栈，一个为普通栈，一个为单调栈！ 单调栈就是：简而言之：就是具有单调性的栈！ 单调栈的实现： 当我们向栈中压入一个数时，如果该数 &lt;= 单调栈的栈顶元素，则将该数同时压入单调栈中； 否则，不压入，这是由于栈具有先进后出性质，所以在该数被弹出之前，栈中一直存在一个数比该数小，所以该数一定不会被当做最小数输出。 当我们从栈中弹出一个数时，如果该数等于单调栈的栈顶元素，则同时将单调栈的栈顶元素弹出。 单调栈由于其具有单调性，所以它的栈顶元素，就是当前栈中的最小数。 其实两种做法很类似的，但解法二用来单调栈的思想！ 可以参考一下的讲解或许会更加清楚！ yxc大神的题解，点击这里！ yxc大神的视频讲解，点击这里！ 题解：解法一：维护前i个数的最小值栈123456789101112131415161718192021222324252627282930313233343536class MinStack {public: /** initialize your data structure here. */ stack&lt;int&gt; stk, stk_min; MinStack() { } void push(int x) { stk.push(x); if(stk_min.size()) x = min(x, stk_min.top()); stk_min.push(x); } void pop() { stk.pop(); stk_min.pop(); } int top() { return stk.top(); } int getMin() { return stk_min.top(); }};/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 解法二：维护一个单调栈123456789101112131415161718192021222324252627282930313233343536class MinStack {public: /** initialize your data structure here. */ stack&lt;int&gt; stk, stk_min; MinStack() { } void push(int x) { stk.push(x); if(stk_min.empty() || x &lt;= stk_min.top()) stk_min.push(x); } void pop() { if(stk_min.top() == stk.top()) stk_min.pop(); stk.pop(); } int top() { return stk.top(); } int getMin() { return stk_min.top(); }};/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"栈","slug":"栈","permalink":"https://niuxvdong.top/tags/%E6%A0%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://niuxvdong.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"author":"Mr.Niu"},{"title":"AcWing-114.国王游戏","slug":"AcWing-114-国王游戏","date":"2020-03-18T13:12:46.000Z","updated":"2020-03-18T13:12:46.000Z","comments":true,"path":"posts/55540.html","link":"","permalink":"https://niuxvdong.top/posts/55540.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：114. 国王游戏 题目背景： 贪心 + 高精度 以前好像在牛客做过一次。。。 以前的题解链接：点击这里！ 可以再一次温习一下高精度写法以及本题的贪心思路！ 题目描述恰逢 H 国国庆,国王邀请 n 位大臣来玩一个有奖游戏。 首先,他让每个大臣在左、右手上面分别写下一个整数,国王自己也在左、右手上各写一个整数。 然后,让这 n 位大臣排成一排,国王站在队伍的最前面。 排好队后,所有的大臣都会获得国王奖赏的若干金币,每位大臣获得的金币数分别是: 排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数,然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏,所以他想请你帮他重新安排一下队伍的顺序,使得获得奖赏最多的大臣,所获奖赏尽可能的少。 注意,国王的位置始终在队伍的最前面。 输入格式第一行包含一个整数 n,表示大臣的人数。 第二行包含两个整数 a 和 b,之间用一个空格隔开,分别表示国王左手和右手上的整数。 接下来 n 行,每行包含两个整数 a 和 b,之间用一个空格隔开,分别表示每个大臣左手和右手上的整数。 输出格式输出只有一行,包含一个整数,表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 数据范围1≤n≤10000&lt;a,b&lt;10000 输入样例：1234531 12 37 44 6 输出样例：12 题目分析：题目要求：一个国王，n个大臣，排成一排，国王在最前边，发一些金币，大臣得到的金币数计算方法为，大臣前面的所有人的左手上的数字乘积除以自己右手的数下取整的到的数。 通过一定的排序，想要达到一个得到金币最多的大臣得到的金币尽可能少！ 最后输出这个大臣的金币数！ 解题思路：贪心思路：（猜想。。） 按照大臣的左右手乘积从小到大排序，然后找出最大值！ 证明过程： 由于是累乘，而且每个数最大为10000，则必须使用高精度来存储： 涉及到高精度乘法，除法，比较大小的操作。 这里不做介绍了，参考下面高精度模板： 我的傻瓜解释版高精度模板！ yxc官网高精度模板！ 相关题解如下： 以前做过一次的题解：点击这里！ yxc大神的题解及证明过程！ yxc视频讲解，点击这里！ 题解：这里涉及到的计算都是高精度乘除一个小的数！ 比较简单！ 可以使用pair来存储 a*b 和 a ，另一个没有存储的数可以直接由二者计算得到！同时也可以借助pair默认排序安装第一个参数排序。。 同时比较两个vector的大小可以借助vector的自动按照字典序比较，当然我们得从高位到低位进行字典序比较，所以需要将vector反转一下，变成下标为0存储最高位即可！ 反转方法：可以使用vector构造函数： 1vector&lt;int&gt;(a.rbegin(), a.rend()) 也可以使用： 1reverse(c.begin(), c.end()); 注意：后者会修改原vector！ 参考具体代码进行理解！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;const int N = 1010;int n;PII T[N];LL S[N], maxn;// 692// i=2、1、0vector&lt;int&gt; mul(vector&lt;int&gt; a, int b){ int t = 0; vector&lt;int&gt; c; for(int i = 0; i &lt; a.size(); i++) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while(t) c.push_back(t % 10), t /= 10; return c;}vector&lt;int&gt; div(vector&lt;int&gt; a, int b){ int t = 0; vector&lt;int&gt; c; bool is_0 = false; for(int i = a.size() - 1; i &gt;= 0; i--) { t = t * 10 + a[i]; int x = t / b; // x 不为0 或前导不是0 if(x || is_0) { is_0 = true; c.push_back(x); } t %= b; } reverse(c.begin(), c.end()); return c;}vector&lt;int&gt; max_vec(vector&lt;int&gt; a, vector&lt;int&gt; b){ if(a.size() &gt; b.size()) return a; if(a.size() &lt; b.size()) return b; if(vector&lt;int&gt;(a.rbegin(), a.rend()) &lt; vector&lt;int&gt;(b.rbegin(), b.rend())) return b; else return a; }void print(vector&lt;int&gt; res){ for(int i = res.size() - 1; i &gt;= 0; i --) cout &lt;&lt; res[i];}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt;= n; i++) { int l, r; cin &gt;&gt; l &gt;&gt; r; T[i] = {l * r, l}; } sort(T + 1, T + n + 1); vector&lt;int&gt; p(1, T[0].second); // 记录累乘 vector&lt;int&gt; res(1, 0); // 记录最大结果 for(int i = 1; i &lt;= n; i++) { res = max_vec(res, div(p, T[i].first/T[i].second)); p = mul(p, T[i].second); } print(res); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://niuxvdong.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"高精度","slug":"高精度","permalink":"https://niuxvdong.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}],"author":"Mr.Niu"},{"title":"蓝桥杯第十一届软件类校内模拟赛","slug":"蓝桥杯第十一届软件类校内模拟赛","date":"2020-03-17T10:53:00.000Z","updated":"2020-03-17T10:53:00.000Z","comments":true,"path":"posts/43446.html","link":"","permalink":"https://niuxvdong.top/posts/43446.html","excerpt":"","text":"非编程题就不看了，都是水题！5、递增三元组问题描述 在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。 给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。 输入格式 输入的第一行包含一个整数 n。 第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。 输出格式 输出一行包含一个整数，表示答案。 样例输入1251 2 5 3 5 样例输出12 样例说明 a[2] 和 a[4] 可能是三元组的中心。 评测用例规模与约定 对于 50% 的评测用例，2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。 对于所有评测用例，2 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。 题解一：暴力题解（或许超时）可以跨元素，并不是只能是挨着的三个！ 前面可以用最小值来找，后面直接循环一遍即可！ 我竟然没发现后面也可以存到数组去实现当前位置到最后元素的最大值！ 参考题解二！ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int a[N], n;int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int mina = a[1], res = 0; for(int j = 2; j &lt;= n - 1; j++) { bool flag1 = false, flag2 = false; mina = min(mina, a[j]); if(mina &lt; a[j]) flag1 = true; for(int k = j + 1; k &lt;= n; k++) if(a[j] &lt; a[k]) { flag2 = true; break; } if(flag1 &amp;&amp; flag2) res ++; } cout &lt;&lt; res &lt;&lt; endl; return 0;} 题解二：维护两个最大最小值数组先线性扫描维护两个数组！ 最小值数组，起点到当前位置的最小值； 最大值数组，终点到当前位置的最大值。 从前往后维护一个最小值数组 从后往前维护一个最大值数组 时间复杂度: O(N) 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N = 1010;int a[N], n, small[N], big[N];int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; small[1] = a[1], big[n] = a[n]; for (int i = 2; i &lt;= n; i++) if (a[i] &lt; small[i - 1]) small[i] = a[i]; else small[i] = small[i - 1]; for (int i = n - 1; i &gt;= 1; i--) if (a[i] &gt; big[i + 1]) big[i] = a[i]; else big[i] = big[i + 1]; int res = 0; for (int i = 2; i &lt;= n - 1; i++) if (small[i - 1] &lt; a[i] &amp;&amp; a[i] &lt; big[i + 1]) res++; cout &lt;&lt; res &lt;&lt; endl; return 0;} 6、数位递增逆序数问题描述 一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。 给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？ 输入格式 输入的第一行包含一个整数 n。 输出格式 输出一行包含一个整数，表示答案。 样例输入130 样例输出126 评测用例规模与约定 对于 40% 的评测用例，1 &lt;= n &lt;= 1000。 对于 80% 的评测用例，1 &lt;= n &lt;= 100000。 对于所有评测用例，1 &lt;= n &lt;= 1000000。 题解：直接扫描一遍即可判断时可以用两个指针指向一前一后，进行判断即可！ 具体看代码实现！ 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, sum;void solve(int x){ int next = 0x3f, pre; bool flag = true; while(x) { int pre = x % 10; x /= 10; if(pre &gt; next) { flag = false; break; } next = pre; } if(flag) sum ++;}int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) solve(i); cout &lt;&lt; sum &lt;&lt; endl; return 0;} 7、元音辅音问题描述 小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。 给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。 元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。 输入格式 输入一行，包含一个单词，单词中只包含小写英文字母。 输出格式 输出答案，或者为yes，或者为no。 样例输入1lanqiao 样例输出1yes 样例输入1world 样例输出1no 评测用例规模与约定 对于所有评测用例，单词中的字母个数不超过100。 题解：扫描一遍即可！保证是辅音、元音、辅音、元音的顺序即可，并且只出现这四段，顺序也一样，多一段都不行！ 直接while去循环直到元辅音出现变化结束即可！ 使用flag可以控制他进入的顺序。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, sum;string str;int fuyin, yuanyin, flag;int main(){ cin &gt;&gt; str; for(int i = 0; i &lt; str.size();) { if(!flag)//辅音 { flag = 1; bool flag1 = false; while(str[i] != 'a' &amp;&amp; str[i] != 'e' &amp;&amp; str[i] != 'i' &amp;&amp; str[i] != 'o' &amp;&amp; str[i] != 'u') { flag1 = true; i ++; } if(!flag1) { cout &lt;&lt; \"no\" &lt;&lt; endl; return 0; } fuyin ++; } else//元音 { flag = 0; bool flag2 = false; while(str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' || str[i] == 'u') { flag2 = true; i ++; } if(!flag2) { cout &lt;&lt; \"no\" &lt;&lt; endl; return 0; } yuanyin ++; } } if(fuyin == 2 &amp;&amp; yuanyin == 2) cout &lt;&lt; \"yes\" &lt;&lt; endl; else cout &lt;&lt; \"no\" &lt;&lt; endl; return 0;} 8、长草问题描述 小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。 小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。 这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。 请告诉小明，k 个月后空地上哪些地方有草。 输入格式 输入的第一行包含两个整数 n, m。 接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。 接下来包含一个整数 k。 输出格式 输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。 样例输入12345678910114 5.g..........g.......2 样例输出1234567gggg.gggg.ggggg.ggg. 评测用例规模与约定 对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。 对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。 对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= k &lt;= 1000。 题解一：直接循环k个月先将有草的地方存起来，再去循环k个月，每次循环都将起点置为上一次的终点，可以有效减少扫描次数，每个月都去扫描上一次新增加的地方！ 貌似不会超时！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;typedef pair&lt;int, int&gt; PII;int n, m, k, r;string str[N];PII T[N * N];int dx[4] = {-1, 1, 0, 0};int dy[4] = {0, 0, -1, 1};bool in(int x, int y){ return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;}int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; str[i]; for(int j = 0; j &lt; m; j++) if(str[i][j] == 'g') T[r++] = {i, j}; } cin &gt;&gt; k; int t = 0, s; while(k--) { s = t, t = r; for(int i = s; i &lt; t; i++) { for(int j = 0; j &lt; 4; j++) { int tx = T[i].first + dx[j], ty = T[i].second + dy[j]; if(in(tx, ty) &amp;&amp; str[tx][ty] != 'g') str[tx][ty] = 'g', T[r++] = {tx, ty}; } } } for(int i = 0; i &lt; n; i++) cout &lt;&lt; str[i] &lt;&lt; endl; return 0;} 题解二：使用BFS貌似和上面解法没区别，复杂度我认为也没什么区别。。。 第二层while循环循环上一次新增加的地方，即队列的大小，内循环结束一次，上一次队列存储的值就会清空一次，然后当前队列存储的就是本月新增的地方，外循环循环月份即可！ 可能会发生某个月份长草时，已经全部长满了，则直接退出即可，即外循环增加一个非空判断条件即可！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 使用BFS#include &lt;queue&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;typedef pair&lt;int, int&gt; PII;int n, m, k, r;string str[N];int dx[4] = {-1, 1, 0, 0};int dy[4] = {0, 0, -1, 1};bool in(int x, int y){ return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;}queue&lt;PII&gt; q;int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; str[i]; for(int j = 0; j &lt; m; j++) if(str[i][j] == 'g') q.push({i, j}); } cin &gt;&gt; k; while(!q.empty() &amp;&amp; k--) { int len = q.size(); while(len--) { PII now = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) { int tx = now.first + dx[i], ty = now.second + dy[i]; if(in(tx, ty) &amp;&amp; str[tx][ty] != 'g') { str[tx][ty] = 'g'; q.push({tx, ty}); } } } } for(int i = 0; i &lt; n; i++) cout &lt;&lt; str[i] &lt;&lt; endl; return 0;} 9、序列数问题描述 小明想知道，满足以下条件的正整数序列的数量： 1. 第一项为 n； 2. 第二项不超过 n； 3. 从第三项开始，每一项小于前两项的差的绝对值。 请计算，对于给定的 n，有多少种满足条件的序列。 输入格式 输入一行包含一个整数 n。 输出格式 输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。 样例输入14 样例输出17 样例说明 以下是满足条件的序列： 4 1 4 1 1 4 1 2 4 2 4 2 1 4 3 4 4 评测用例规模与约定 对于 20% 的评测用例，1 &lt;= n &lt;= 5； 对于 50% 的评测用例，1 &lt;= n &lt;= 10； 对于 80% 的评测用例，1 &lt;= n &lt;= 100； 对于所有评测用例，1 &lt;= n &lt;= 1000。 题解：DFS(暴力TLE)直接DFS最多只能算到20几的数字，但本题数据范围为1000。。。 可以暴力跑一遍所有数组，存储起来，打表输出O(1)即可。。。 正确做法或许是记忆化搜索，动态规划之类。。。 就这样吧，打表或许是最好的选择！ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;#define mod 10000using namespace std;int n, ans;void dfs(int pre, int next){ ans = (ans + 1) % mod; if(abs(pre - next) &lt;= 1) return; for (int i = 1; i &lt; abs(pre - next); i++) dfs(next, i);}int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) dfs(n, i); cout &lt;&lt; ans &lt;&lt; endl; return 0;} 10、选节目问题描述 小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。 这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。 小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。 小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。 输入格式 输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。 第二行包含 n 个整数，依次为每个节目的好看值。 输出格式 输出一行包含 m 个整数，为选出的节目的好看值。 样例输入1235 33 1 2 5 4 样例输出13 5 4 样例说明 选择了第1, 4, 5个节目。 评测用例规模与约定 对于 30% 的评测用例，1 &lt;= n &lt;= 20； 对于 60% 的评测用例，1 &lt;= n &lt;= 100； 对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。 题解：似乎不太对简单的觉得先按好看值从大到小排序，再按序号从小到大排序即可！ 似乎不是这么简单！ 听说用到了好多算法。。。 放过，再说吧！ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100000;struct Node{ int point, pos;};bool cmp(Node x, Node y){ return x.point &gt; y.point;}bool cmp1(Node x, Node y){ return x.pos &lt; y.pos;}int n, m;Node a[N];int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i].point, a[i].pos = i; sort(a, a + n, cmp); sort(a, a + m, cmp1); for(int i = 0; i &lt; m; i++) cout &lt;&lt; a[i].point &lt;&lt; \" \"; return 0;} 记录一下这垃圾的蓝桥杯校赛！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://niuxvdong.top/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://niuxvdong.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"author":"Mr.Niu"},{"title":"AcWing-112.雷达设备","slug":"AcWing-112-雷达设备","date":"2020-03-12T12:59:56.000Z","updated":"2020-03-12T12:59:56.000Z","comments":true,"path":"posts/27200.html","link":"","permalink":"https://niuxvdong.top/posts/27200.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：112. 雷达设备 题目背景： 同样是贪心问题！ 题目描述假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。 每个小岛都位于海洋一侧的某个点上。 雷达装置均位于海岸线上，且雷达的监测范围为d，当小岛与某雷达的距离不超过d时，该小岛可以被雷达覆盖。 我们使用笛卡尔坐标系，定义海岸线为x轴，海的一侧在x轴上方，陆地一侧在x轴下方。 现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。 输入格式第一行输入两个整数n和d，分别代表小岛数目和雷达检测范围。 接下来n行，每行输入两个整数，分别代表小岛的x，y轴坐标。 同一行数据之间用空格隔开。 输出格式输出一个整数，代表所需的最小雷达数目，若没有解决方案则所需数目输出“-1”。 数据范围1≤n≤1000 输入样例：12343 21 2-3 12 1 输出样例：12 题目分析：题目要求：简单来说，就是给一条数轴，在数轴上方有一些点（小岛），要在数轴上放置雷达，使得可以使每个点都被覆盖住！ 求达到目的的最小雷达数目！ 解题思路：雷达有一个半径值，当然处于半径内则可以覆盖！ 首先先考虑一个点（x，y）,要想使得数轴上的雷达可以探测到，必须处于半径范围内，左右可以拓展的距离最大就是以点（x，y）往出拉一条雷达的半径d，与数轴的交点就是可以拓展的最大距离，即只要在[a，b] 范围内就可以保证当前点处于雷达可探测范围！ 如下图： 若发现无交点，即当前点太高，即使雷达放在正下方都够不着，超过了雷达的范围，则直接返回-1即可！ 判断条件：y &gt; d 时！够不着！ 计算区间a，b值可以利用勾股定理即可！ 这样我们可以得到每一个点的雷达取值区间，现在问题就从二维变为了一维的区间问题！ 具体解法： 我们可以给每个区间按照右端点从小到大排序！ 扫描每一个区间，看这个区间内是否有雷达？ 若没有雷达，则在当前区间右端点放置一颗雷达 若有雷达，则跳过即可 具体解释一下： 排好序后，如果前面有一个雷达则去看一下雷达有没有在当前点的区间，要知道：只有在当前点的区间内才能够得着这个点！ 为了尽可能的使放一个雷达可以最好，最大的服务后面的的点的区间，可以将每个雷达放到该点区间的右端点即可！ 既可以保证当前点被覆盖，又可以保证距离下一个点最近，达到最优的效果！ 最后的最少的雷达数就是区间上可以放置的雷达数，即进去if条件的次数！ 证明可以看一下下方yxc大神的证明！ yxc视频讲解，点击这里！ 题解：下一个区间要想判断是否在雷达的左或右边，可以简单的用一个last指针来动态指向雷达的位置，若区间没有雷达，则将last置为当前区间的右端点，否则跳过即可！ 注意：因为勾股定理需要开方，所以区间使用double来存储！ 数轴是正无穷到负无穷级别的，所以将last初值赋为负无穷大！ 具体参考代码理解！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;const double INF = 1e10;struct Node{ double l, r;};bool cmp(Node a, Node b){ return a.r &lt; b.r;}int n, d;Node a[N];int main(){ cin &gt;&gt; n &gt;&gt; d; for(int i = 0, x, y; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; if(y &gt; d) { cout &lt;&lt; -1 &lt;&lt; endl; return 0; } double l = x - sqrt(d * d - y * y), r = x + sqrt(d * d - y * y); a[i] = {l, r}; } sort(a, a + n, cmp); int res = 0; double last = -INF; for(int i = 0; i &lt; n; i++) { if(a[i].l &gt; last) { res ++; last = a[i].r; } } cout &lt;&lt; res &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://niuxvdong.top/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"AcWing-111.畜栏预定","slug":"AcWing-111-畜栏预定","date":"2020-03-10T13:22:43.000Z","updated":"2020-03-10T13:22:43.000Z","comments":true,"path":"posts/23513.html","link":"","permalink":"https://niuxvdong.top/posts/23513.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：111. 畜栏预定 题目背景： 贪心证明略过。。。 本题我在出列排序后的第一头牛时出现了问题，粗心了。。。 题目描述有N头牛在畜栏中吃草。 每个畜栏在同一时间段只能提供给一头牛吃草，所以可能会需要多个畜栏。 给定N头牛和每头牛开始吃草的时间A以及结束吃草的时间B，每头牛在[A,B]这一时间段内都会一直吃草。 当两头牛的吃草区间存在交集时（包括端点），这两头牛不能被安排在同一个畜栏吃草。 求需要的最小畜栏数目和每头牛对应的畜栏方案。 输入格式第1行：输入一个整数N。 第2..N+1行：第i+1行输入第i头牛的开始吃草时间A以及结束吃草时间B，数之间用空格隔开。 输出格式第1行：输入一个整数，代表所需最小畜栏数。 第2..N+1行：第i+1行输入第i头牛被安排到的畜栏编号，编号是从1开始的 连续 整数，只要方案合法即可。 数据范围1≤N≤500001≤A,B≤1000000 输入样例：12345651 102 43 65 84 7 输出样例：123456412324 题目分析：题目要求：给出n头牛吃草的时间区间，问最少可以划分几个容器，使得每个容器牛吃草时间不会冲突，端点相同也算冲突！ 解题思路： 根据时间区间的起点排序 用小根堆维护当前容器最后一头牛吃草的结束时间 若当前牛的起始值比堆顶结束的值都大，则更新堆顶，否则，新建一个节点，存入堆！ 至于为什么这样做是对的，那就是数学问题了，我就不细说了，证明请看下方的视频讲解！ 先默认排好序后的第一头牛为第一个容器，后面的牛则从2开始循环！ 具体看题解下方的解释！ yxc大神参考题解：点击这里！ yxc视频讲解 题解：题解一：暴力超时TLE代码结构体的三个变量：时间区间的开始结束和标号！ S数组存储两个值，当前容器的右端点和容器的编号，第一个变量不需要，随便写个0！ 内部for循环来找有没有可以放到同一个容器的区间，若能放到一起，则更新容器的右端点！并记录牛的容器编号！ 若没有找到可以放到一起的，则新建容器，编号++，右端点为当前牛的右端点，记录牛的编号！ 时间复杂度：O(n2) TLE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Node{ int start, end, pos;};bool cmp(Node x, Node y){ return x.start &lt; y.start;}const int N = 50010;int n, id[N];Node T[N], S[N];int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; T[i].start &gt;&gt; T[i].end, T[i].pos = i; sort(T + 1, T + 1 + n, cmp); S[1] = {0, T[1].end, 1}; int k = 1, r = 1; id[T[1].pos] = 1; for(int i = 2; i &lt;= n; i++) { bool flag = false; for(int j = 1; j &lt;= k; j++) { if(T[i].start &gt; S[j].end) { S[j].end = T[i].end; id[T[i].pos] = S[j].pos; flag = true; break; } } if(!flag) { S[++k] = {0, T[i].end, ++r}; id[T[i].pos] = r; } } cout &lt;&lt; k &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; id[i] &lt;&lt; endl; return 0;} 题解二：使用堆优化的AC代码想要从已知的容器中找一个比当前牛起始端点还小的容器，则可以简化为找一个最小的即可！ 然后比较容器右端点最小的容器和当前牛的左端点比较即可！ 则变成了动态变化的容器求最小值，这不就是堆的性质吗！ 可以建立一个优先队列，即小根堆！ 每次取堆顶即可，取出来再和当前牛比较！ 同样：排好序的第一头牛初始编号为1，先放入堆，for循环从2开始！ 堆中存储两个值，第一个为右端点（动态）第二个值为容器编号！ 比堆顶还小则新建一个节点，节点编号++，压入堆中！ 否则：取出堆顶，更新右端点，压入堆中！ 最后容器个数就是堆的大小！ 时间复杂度：O(NlogN) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;struct Node{ int start, end, pos;};bool cmp(Node x, Node y){ return x.start &lt; y.start;}const int N = 50010;int n, id[N];Node T[N], S[N];priority_queue &lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; T[i].start &gt;&gt; T[i].end, T[i].pos = i; sort(T + 1, T + 1 + n, cmp); // first -&gt; end , second -&gt; pos heap.push({T[1].end, 1}); id[T[1].pos] = 1; for(int i = 2; i &lt;= n; i++) { if(T[i].start &lt;= heap.top().first) { int s = heap.size() + 1; PII t = {T[i].end, s}; id[T[i].pos] = s; heap.push(t); } else { auto t = heap.top(); heap.pop(); t.first = T[i].end; id[T[i].pos] = t.second; heap.push(t); } } cout &lt;&lt; heap.size() &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; id[i] &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://niuxvdong.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"堆","slug":"堆","permalink":"https://niuxvdong.top/tags/%E5%A0%86/"}],"author":"Mr.Niu"},{"title":"AcWing-110.防晒","slug":"AcWing-110-防晒","date":"2020-03-07T11:36:56.000Z","updated":"2020-03-07T11:36:56.000Z","comments":true,"path":"posts/10715.html","link":"","permalink":"https://niuxvdong.top/posts/10715.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：110. 防晒 题目背景： 贪心的证明就略过了，运用了大量数学知识，二分图。。。。 题目描述有C头奶牛进行日光浴，第i头奶牛需要minSPF[i]到maxSPF[i]单位强度之间的阳光。 每头奶牛在日光浴前必须涂防晒霜，防晒霜有L种，涂上第i种之后，身体接收到的阳光强度就会稳定为SPF[i]，第i种防晒霜有cover[i]瓶。 求最多可以满足多少头奶牛进行日光浴。 输入格式第一行输入整数C和L。 接下来的C行，按次序每行输入一头牛的minSPF和maxSPF值,即第i行输入minSPF[i]和maxSPF[i]。 再接下来的L行，按次序每行输入一种防晒霜的SPF和cover值,即第i行输入SPF[i]和cover[i]。 每行的数据之间用空格隔开。 输出格式输出一个整数，代表最多可以满足奶牛日光浴的奶牛数目。 数据范围1≤C,L≤25001≤minSPF≤maxSPF≤10001≤SPF≤1000 输入样例：1234563 23 102 51 56 24 1 输出样例：12 题目分析：题目要求：有一些奶牛，一些防晒霜，最大可能的使更多的牛涂了防晒霜后处于需求范围内！ 解题思路：将牛的区间按照左端点从大到小排序，如下图； 从上向下处理每一头牛，扫描当前区间的最大强度的防晒霜即可！ 简单解释： 第一头牛从右端点开始找起，找到的一定是在牛的区间范围内最少的，而左边的则可以满足多头牛！ 最终答案就是区间上使用了防晒霜的个数！ 用完一个就将防晒霜个数–，减到0从容器中删除！ 为了方便，使用map来存储防晒霜，由于防晒霜类型有重复，sp[spf] += cover;这里变为+=即可！ 找满足牛区间的最大值，可以使用upper_bound(x)函数 lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 找到大于右端点值时，直接–就找到了一个可能存在的防晒霜！ 若当前防晒霜在区间内，则当前牛可以满足条件，计数器++； 可参考下面题解： yxc大神参考题解：点击这里！ yxc视频讲解 题解：在这里map确实好用！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2510;struct Cow{ int first, second;};bool cmp(Cow x, Cow y){ if(x.first != y.first) return x.first &gt; y.first;}int n, m;Cow cows[N];map &lt;int, int&gt; sp;int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; cows[i].first &gt;&gt; cows[i].second; for(int i = 0; i &lt; m; i++) { int spf, cover; cin &gt;&gt; spf &gt;&gt; cover; sp[spf] += cover; } sort(cows, cows + n, cmp); int res = 0; sp[0] = sp[1001] = n; for(int i = 0; i &lt; n; i++) { // it是一个迭代器！ auto it = sp.upper_bound(cows[i].second); it --; if(it-&gt;first &gt;= cows[i].first) { res ++; it-&gt;second --; if(it-&gt;second == 0) sp.erase(it); } } cout &lt;&lt; res &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"排序","slug":"排序","permalink":"https://niuxvdong.top/tags/%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"https://niuxvdong.top/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"AcWing-109.天才ACM","slug":"AcWing-109-天才ACM","date":"2020-03-07T08:44:34.000Z","updated":"2020-03-07T08:44:34.000Z","comments":true,"path":"posts/45606.html","link":"","permalink":"https://niuxvdong.top/posts/45606.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：109. 天才ACM 题目背景： 又是一道好题，参考了许多题解，明白后，有因为粗心，debug了好久才AC了！ 题目描述给定一个整数 M，对于任意一个整数集合 S，定义“校验值”如下: 从集合 S 中取出 M 对数(即 2∗M 个数，不能重复使用集合中的数，如果 S 中的整数不够 M 对，则取到不能取为止)，使得“每对数的差的平方”之和最大，这个最大值就称为集合 S 的“校验值”。 现在给定一个长度为 N 的数列 A 以及一个整数 T。 我们要把 A 分成若干段，使得每一段的“校验值”都不超过 T。 求最少需要分成几段。 输入格式第一行输入整数 K，代表有 K 组测试数据。 对于每组测试数据，第一行包含三个整数 N,M,T 。 第二行包含 N 个整数，表示数列A1,A2…AN。 输出格式对于每组测试数据，输出其答案，每个答案占一行。 数据范围1≤K≤121≤N,M≤5000000≤T≤10180≤Ai≤220 输入样例：1234525 1 498 2 1 7 95 1 648 2 1 7 9 输出样例：1221 题目分析：题目要求：校验值：就是每对数的差的平方之和 将一个序列分成若干段，使得每一段的校验值都不超过T，求可分成的最小段数！ 每一段要取出M对数，即2 * M 个数，取到不能取为止！ 解题思路：贪心 + 归并(只用到合并) + 倍增 首先一段的校验值最大，很简单，直接排序后，取一个最大值和一个最小值，每次都去最大最小即可，这样贪心得到的校验值就是这一段的最大值！（当然不能重复取！） 如何可以使得段数尽可能的小了？ 那么一段要取多长？ 我们可以进行二分，每次都将二分得到的区间计算的到的校验值和T比较即可，然后动态的改变右端点！ 但是这样得到的区间要想计算校验值，得进行该序列的排序，用到sort，复杂度石灰超时的！ 这是可以用倍增来解决这个问题！ 要想使段数尽可能少，则要保证每一段在不超过T的情况下，尽可能的长！ 用 l 和 r 指向区间的左右端点，若区间不超过T，就进行倍增拓展长度（p），p 成倍增加，r 也要一直后移；若某次成倍增加是校验值超过T，则当前p就得成倍减少，直到p为0，此时就是说明找到了不超过T的最大长度！ 第一段开始，已排序序列b数组需要和那段倍增的长度进行拓展，需要进行排序，但是 b 数组已经有序，根本不需要去整段去排序，将倍增长度排序后，直接使用归并进行两个序列的合并，得到一个新数组即可！ 其后的每一段合并时，b数组都是排好序的，这样可以大大减少时间消耗！ b数组用来保存处理过的序列，c数组来保存每次倍增多出来的序列，temp数组来保存b和c合并后的序列！ 若当前序列不超过T，则将合并后的序列temp归还给b数组（表示处理过且当前是有序序列），返回true，右端点右移到倍增后的位置，p继续倍增！ 若当前序列超过了T，则直接返回false，此时b数组的存储没有被改变，然后p倍减！ 为什么会比二分更优化呢？ 因为每次的b数组都是有序的，不需要排序，省了很多时间！ 可以参考代码中的注释进行详细了解！ 也可以参考如下的一篇题解！ 参考题解：点击这里！ 题解：注意： 校验值可能会溢出，要使用long long！ 以防倍增后使右端点溢出，使用t = min(r + p, n - 1) 来进行约束！ 每一段找到右端点后，当前段在b数组就是有序的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 5e5 + 10;int K, n, m;LL a[N], b[N], c[N], temp[N], T;// 合并 l1~r1 和 l2~r2int merge(int l1, int r1, int l2, int r2){ int i = l1, j = l2, k = 0; while(i &lt;= r1 &amp;&amp; j &lt;= r2) { if(b[i] &lt;= c[j]) temp[k++] = b[i++]; else temp[k++] = c[j++]; } while(i &lt;= r1) temp[k++] = b[i++]; while(j &lt;= r2) temp[k++] = c[j++]; return k;}// 当前l ~ r1 是有序的 bool check(int l, int r1, int r2){ // 将 r1 + 1 ~ r2(倍增序列)存储起来 for(int i = r1 + 1; i &lt;= r2; i++) c[i] = a[i]; // 排序倍增序列 sort(c + r1 + 1, c + r2 + 1); // 合并倍增序列与已排好序的序列 int len = merge(l, r1, r1 + 1, r2); // 合并后的有序序列 计算校验值 LL cnt = 0, head = 0, tail = len - 1, sum = 0; while(cnt &lt; m &amp;&amp; head &lt; tail) { sum += (temp[head] - temp[tail]) * (temp[head] - temp[tail]); head ++, tail --, cnt ++; } if(sum &gt; T) return false; else { // 小于T 将临时temp存回到b数组，此时b数组是一个有序序列 int k = 0; for(int i = l; i &lt;= r2; i++) b[i] = temp[k++]; return true; }}int main(){ cin &gt;&gt; K; while(K--) { cin &gt;&gt; n &gt;&gt; m &gt;&gt; T; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; int l = 0, r = 0, p, nes = 0, t; // 若 r 到了最后就退出 while(r &lt; n - 1) { // b 在这里每次存储一段序列的头部！r 初始指向 l, p初始倍增为1 nes统计序列段数 b[l] = a[l], r = l, p = 1, nes++; // p 为0时，即找到了序列的最大长度 while(p) { // 倍增后的右端点 t = min(r + p, n - 1); // 若此时的合并后的序列的校验值 &lt;= T 则p倍增 合并完成的右端点r后移 否则：p倍减 if(check(l, r, t)) r = t, p &lt;&lt;= 1; else p &gt;&gt;= 1; // 保证r 不超过 n - 1 说明走到了序列末 是切割的最后一段 if(r == n - 1) break; } // 下一段开始的位置 l = r + 1; } cout &lt;&lt; nes &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://niuxvdong.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"归并排序","slug":"归并排序","permalink":"https://niuxvdong.top/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"倍增","slug":"倍增","permalink":"https://niuxvdong.top/tags/%E5%80%8D%E5%A2%9E/"}],"author":"Mr.Niu"},{"title":"AcWing-108.奇数码问题","slug":"AcWing-108-奇数码问题","date":"2020-03-06T08:12:44.000Z","updated":"2020-03-06T08:12:44.000Z","comments":true,"path":"posts/12934.html","link":"","permalink":"https://niuxvdong.top/posts/12934.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：108.奇数码问题 题目背景： 同样是归并排序求逆序对的问题！ 参考我关于这类问题的一篇题解：AcWing-788.逆序对的数量 奇偶性很神奇，对于一类问题，如果属于同种性质（奇偶性相同），那么它们就是完全相同（这个在某种意义上说）的，一些特殊的情况又例外！ 题目描述你一定玩过八数码游戏，它实际上是在一个3×3的网格中进行的,1个空格和1~8这8个数字恰好不重不漏地分布在这3×3的网格中。 例如： 1235 2 81 3 _4 6 7 在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。 例如在上例中，空格可与左、上、下面的数字交换，分别变成： 1235 2 8 5 2 _ 5 2 81 _ 3 1 3 8 1 3 74 6 7 4 6 7 4 6 _ 奇数码游戏是它的一个扩展，在一个n×n的网格中进行，其中n为奇数，1个空格和1~n2−1这n2−1个数恰好不重不漏地分布在n×n的网格中。 空格移动的规则与八数码游戏相同，实际上，八数码就是一个n=3的奇数码游戏。 现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。 输入格式多组数据，对于每组数据： 第1行输入一个整数n，n为奇数。 接下来n行每行n个整数，表示第一个局面。 再接下来n行每行n个整数，表示第二个局面。 局面中每个整数都是0~n2−1之一，其中用0代表空格，其余数值与奇数码游戏中的意义相同，保证这些整数的分布不重不漏。 输出格式对于每组数据，若两个局面可达，输出TAK，否则输出NIE。 数据范围1≤n&lt;500 输入样例：1234567891031 2 30 4 67 5 81 2 34 5 67 8 0100 输出样例：12TAKTAK 题目分析：题目要求：询问是不是可以将一个矩阵中的空位 _ 通过上下左右交换变成另一个矩阵！ 解题思路：先来一个结论： 奇数码游戏两个局面可达，当且仅当两个局面下网格中的数依次写成1行n*n-1个元素的序列后(不考虑空格)，逆序对个数的奇偶性相同！ 空格左右移动时，写成的序列显然不变; 空格向上(下)移动时，相当于某个数与它后(前)边的n-1个数交换了位置，因为n-1是偶数，所以逆序对数的变化也只能是偶数。 该结论的充分性证明较为复杂，我们将不在此大篇幅讨论这样一个 数学问题。 可以参考下面这位同学的简单证明！ 我之前的题解：归并求逆序对！点击这里！ 参考题解：点击这里！ 题解：同样：使用long long，以防溢出！ 判断同奇同偶性，可以直接相减的绝对值对2取余即可，若为0，则是同类，若不为0则是一奇一偶！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 510;int a[N * N], temp[N * N], n, k;LL sum, suma, sumb;void merge_sort(int l, int r){ if(l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(l, mid), merge_sort(mid + 1, r); int i = l, j = mid + 1, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else { temp[k++] = a[j++]; sum += mid - i + 1; } } while(i &lt;= mid) temp[k++] = a[i++]; while(j &lt;= r) temp[k++] = a[j++]; for(int i = l, j= 0; i &lt;= r; i++, j++) a[i] = temp[j];}int main(){ while(cin &gt;&gt; n) { sum = 0, k = 0; for(int i = 0, x; i &lt; n * n; i++) { cin &gt;&gt; x; if(x) a[k++] = x; } merge_sort(0, n * n - 1); suma = sum; sum = 0, k = 0; for(int i = 0, x; i &lt; n * n; i++) { cin &gt;&gt; x; if(x) a[k++] = x; } merge_sort(0, n * n - 1); sumb = sum; if(abs(suma - sumb) % 2) cout &lt;&lt; \"NIE\" &lt;&lt; endl; else cout &lt;&lt; \"TAK\" &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"归并排序","slug":"归并排序","permalink":"https://niuxvdong.top/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"逆序对","slug":"逆序对","permalink":"https://niuxvdong.top/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"奇偶性","slug":"奇偶性","permalink":"https://niuxvdong.top/tags/%E5%A5%87%E5%81%B6%E6%80%A7/"}],"author":"Mr.Niu"},{"title":"AcWing-107.超快速排序","slug":"AcWing-107-超快速排序","date":"2020-03-06T03:58:14.000Z","updated":"2020-03-06T03:58:14.000Z","comments":true,"path":"posts/8382.html","link":"","permalink":"https://niuxvdong.top/posts/8382.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：107. 超快速排序 题目背景： 又是归并排序求逆序对的问题！ 参考我关于这类问题的一篇题解：AcWing-788.逆序对的数量 题目描述在这个问题中，您必须分析特定的排序算法—-超快速排序。 该算法通过交换两个相邻的序列元素来处理n个不同整数的序列，直到序列按升序排序。 对于输入序列9 1 0 5 4，超快速排序生成输出0 1 4 5 9。 您的任务是确定超快速排序需要执行多少交换操作才能对给定的输入序列进行排序。 输入格式输入包括一些测试用例。 每个测试用例的第一行输入整数n，代表该用例中输入序列的长度。 接下来n行每行输入一个整数ai,代表用例中输入序列的具体数据，第i行的数据代表序列中第i个数。 当输入用例中包含的输入序列长度为0时，输入终止，该序列无需处理。 输出格式对于每个需要处理的输入序列，输出一个整数op，代表对给定输入序列进行排序所需的最小交换操作数，每个整数占一行。 数据范围0≤N&lt;5000000≤ai≤999999999 输入样例：123456789101159105431230 输出样例：1260 题目分析：题目要求：就是求逆序对的数目，遇到0结束输入！ 解题思路：同样是归并排序再求逆序对的数目： sum += mid - i + 1; 详细题解看类似的题目下面这篇我之前写的题解！ AcWing-788.逆序对的数量 题解：注意：以防越界，全部改为long long！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 500010;LL a[N], temp[N];LL n, sum;void merge_sort(int l, int r){ if(l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(l, mid), merge_sort(mid + 1, r); int i = l, j = mid + 1, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else { temp[k++] = a[j++]; sum += mid - i + 1; } } while(i &lt;= mid) temp[k++] = a[i++]; while(j &lt;= r) temp[k++] = a[j++]; for(int i = l, j= 0; i &lt;= r; i++, j++) a[i] = temp[j];}int main(){ while(cin &gt;&gt; n &amp;&amp; n) { sum = 0; for(int i = 0, x; i &lt; n; i++) cin &gt;&gt; a[i]; merge_sort(0, n - 1); cout &lt;&lt; sum &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"归并排序","slug":"归并排序","permalink":"https://niuxvdong.top/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"逆序对","slug":"逆序对","permalink":"https://niuxvdong.top/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"}],"author":"Mr.Niu"},{"title":"AcWing-106.动态中位数","slug":"AcWing-106-动态中位数","date":"2020-03-05T10:38:26.000Z","updated":"2020-03-05T10:38:26.000Z","comments":true,"path":"posts/3455.html","link":"","permalink":"https://niuxvdong.top/posts/3455.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：106. 动态中位数 题目背景： 让两个堆来构建一个有序序列，找到中位数，优先队列的优先就是用堆结构实现的！ 题目描述依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数。 输入格式第一行输入一个整数P，代表后面数据集的个数，接下来若干行输入各个数据集。 每个数据集的第一行首先输入一个代表数据集的编号的整数。 然后输入一个整数M，代表数据集中包含数据的个数，M一定为奇数，数据之间用空格隔开。 数据集的剩余行由数据集的数据构成，每行包含10个数据，最后一行数据量可能少于10个，数据之间用空格隔开。 输出格式对于每个数据集，第一行输出两个整数，分别代表数据集的编号以及输出中位数的个数（应为数据个数加一的二分之一），数据之间用空格隔开。 数据集的剩余行由输出的中位数构成，每行包含10个数据，最后一行数据量可能少于10个，数据之间用空格隔开。 输出中不应该存在空行。 数据范围1≤P≤10001≤M≤9999 输入样例：1234567893 1 9 1 2 3 4 5 6 7 8 9 2 9 9 8 7 6 5 4 3 2 1 3 23 23 41 13 22 -3 24 -31 -11 -8 -7 3 5 103 211 -311 -45 -67 -73 -81 -99 -33 24 56 输出样例：12345671 51 2 3 4 52 59 8 7 6 53 1223 23 22 22 13 3 5 5 3 -3 -7 -3 题目分析：题目要求：输入一串数，在输入奇数位时，输出当前序列的中位数！ 解题思路：本人的暴力做法： 每次输入一个数，就使用sort来拍一下序，为奇数位时，输出当前的中位数！ 看看时间复杂度：1e3 * 1e4 * NlogN 大概已经1e11 绝对TLE！ 更优的做法：使用对顶堆 时间复杂度：1e3 * 1e4 * logN 似乎是这样！不太会分析复杂度。。。 使用两个堆结构：大根堆和小根堆，且必须时刻满足这两个条件！ 大根堆：序列中从小到大排序为 1 ~ M / 2 个数存储到大根堆 小根堆：序列中从小到大排序为 M + 1~ M 个数存储到大根堆 始终保证大根堆元素小于小于等于小根堆，小根堆元素大于等于大根堆元素个数！ 输入一个数先进行存储，若比中位数小，存储到大根堆，比中位数大存储到小根堆！ 倘若不符合上面两个条件： 需要进行多的给少的，达到上面的限制条件即可！ 为什么要这样限制了？ 看一下这张图： 会发现每次插入结束后，只要保证右边大于等于左边，就可以轻而易举得到中位数，就是小根堆的堆顶！ 如果是偶数个数，则左右是相等个数，若为奇数，则右边一定会多一个！ 以这几个数举例：没有9时，则中位数为5？不对吧，没关系，题目要求在奇数个数时去找中位数，所以右边一定比左边多1，这时，也就是有9的时候，中位数就是5，没毛病！ 大根堆的堆顶为4，小根堆的堆顶为5 ! 具体实现请看下方代码！ 李煜东的视频讲解，大概在45分钟的时候！ 题解：题解一：本人的纯暴力做法！（TLE）123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int a[N], b[N];int p, q, n;int main(){ cin &gt;&gt; p; while(p --) { cin &gt;&gt; q &gt;&gt; n; int k = 0; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; sort(a + 1, a + 1 + i); if(i &amp; 1) b[k++] = a[i + 1 &gt;&gt; 1]; } cout &lt;&lt; q &lt;&lt; \" \" &lt;&lt; k &lt;&lt; endl; for(int i = 0; i &lt; k; i++) { if(i % 10 == 0 &amp;&amp; i) cout &lt;&lt; endl; cout &lt;&lt; b[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } return 0;} 题解二：使用对顶堆（大根堆和小根堆）（AC）注意：将第一个数直接插入小根堆，毕竟要保证右边大于等于左边！ 在清空堆的时候，由于没有clear函数，只能使用循环去删除达到空容器效果，或者直接赋值一个空容器，建议使用赋值方法！简单明了，vector可以直接使用clear函数清空！ 关于优先队列： 默认为大根堆，要使用小根堆得如代码这样写，很明显第三个参数为排序函数！ 12priority_queue &lt;int&gt; big, kong1; // 大根堆priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; small, kong2; // 小根堆 具体代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int p, q, n;vector &lt;int&gt; v, kongV;priority_queue &lt;int&gt; big, kong1; // 大根堆priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; small, kong2; // 小根堆int main(){ cin &gt;&gt; p; while(p --) { cin &gt;&gt; q &gt;&gt; n; int k = 0; big = kong1, small = kong2, v.clear(); for(int i = 1, x; i &lt;= n; i++) { cin &gt;&gt; x; if(small.empty()) { small.push(x); v.push_back(x); continue; } if(x &gt;= small.top()) small.push(x); else big.push(x); if(big.size() &gt; small.size()) { small.push(big.top()); big.pop(); } else if(small.size() - big.size() &gt; 1) { big.push(small.top()); small.pop(); } if(i &amp; 1) v.push_back(small.top()); } cout &lt;&lt; q &lt;&lt; \" \" &lt;&lt; v.size() &lt;&lt; endl; for(int i = 0; i &lt; v.size(); i++) { if(i % 10 == 0 &amp;&amp; i) cout &lt;&lt; endl; cout &lt;&lt; v[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"priority_queue","slug":"priority-queue","permalink":"https://niuxvdong.top/tags/priority-queue/"},{"name":"中位数","slug":"中位数","permalink":"https://niuxvdong.top/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"name":"堆","slug":"堆","permalink":"https://niuxvdong.top/tags/%E5%A0%86/"}],"author":"Mr.Niu"},{"title":"AcWing-122.糖果传递","slug":"AcWing-122-糖果传递","date":"2020-03-05T10:37:38.000Z","updated":"2020-03-05T10:37:38.000Z","comments":true,"path":"posts/58067.html","link":"","permalink":"https://niuxvdong.top/posts/58067.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：122. 糖果传递 题目背景： 又是一道环形的均分纸牌问题，这也是这类题的一个基础的经典的例题了！ 我先做的 七夕祭 这道题，一个二维的环形均分纸牌问题，比这个复杂一点。。 题目描述有n个小朋友坐成一圈，每人有a[i]个糖果。 每人只能给左右两人传递糖果。 每人每次传递一个糖果代价为1。 求使所有人获得均等糖果的最小代价。 输入格式第一行输入一个正整数n，表示小朋友的个数。 接下来n行，每行一个整数a[i]，表示第i个小朋友初始得到的糖果的颗数。 输出格式输出一个整数，表示最小代价。 数据范围1≤n≤1000000数据保证一定有解。 输入样例：1234541254 输出样例：14 题目分析：题目要求：n个人围成一圈，没人有一些糖果，问最少交换多少次会达到均等时的最小步数！ 传递一个糖果代价为1！ 解题思路：同样是环形均分纸牌问题，里面的公式推导就不再推了，请看我的上一篇题解： AcWing-105.七夕祭 接下来总结一下环形纸牌问题： 第一步：将原值减去平均值 第二步：求当前的前缀和 第三步：将前缀和排序 此时转化为了货仓问题 第四部：求中位数 第五步：求 abs(b[i] - mid) 的和 题解：小技巧：求前缀和时，输入从下标为1开始，方便后序求前缀和等等！ 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1e6 + 10;LL a[N], b[N];int main(){ int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], a[0] += a[i]; for(int i = 1; i &lt;= n; i++) b[i] = b[i - 1] + a[i] - a[0]/n; sort(b + 1, b + 1 + n); LL sum = 0, mid = b[n + 1 &gt;&gt; 1]; for(int i = 1; i &lt;= n; i++) sum += abs(b[i] - mid); cout &lt;&lt; sum &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"前缀和","slug":"前缀和","permalink":"https://niuxvdong.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"贪心","slug":"贪心","permalink":"https://niuxvdong.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"中位数","slug":"中位数","permalink":"https://niuxvdong.top/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"AcWing-105.七夕祭","slug":"AcWing-105-七夕祭","date":"2020-03-04T10:51:43.000Z","updated":"2020-03-04T10:51:43.000Z","comments":true,"path":"posts/47007.html","link":"","permalink":"https://niuxvdong.top/posts/47007.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：105. 七夕祭 此题为了理解折腾了一下午，写题解又写了一晚上！终于完整的记录了下来 题目背景： 本题运用了大量的数学公式化简，以及中位数性质等等，我会在题目分析当中进行详细介绍和解释！ 题目描述七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。 于是TYVJ今年举办了一次线下七夕祭。 Vani同学今年成功邀请到了cl同学陪他来共度七夕，于是他们决定去TYVJ七夕祭游玩。 TYVJ七夕祭和11区的夏祭的形式很像。 矩形的祭典会场由N排M列共计N×M个摊点组成。 虽然摊点种类繁多，不过cl只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。 Vani预先联系了七夕祭的负责人zhq，希望能够通过恰当地布置会场，使得各行中cl感兴趣的摊点数一样多，并且各列中cl感兴趣的摊点数也一样多。 不过zhq告诉Vani，摊点已经随意布置完毕了，如果想满足cl的要求，唯一的调整方式就是交换两个相邻的摊点。 两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。 由于zhq率领的TYVJ开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。 现在Vani想知道他的两个要求最多能满足多少个。 在此前提下，至少需要交换多少次摊点。 输入格式第一行包含三个整数N和M和T，T表示cl对多少个摊点感兴趣。 接下来T行，每行两个整数x, y，表示cl对处在第x行第y列的摊点感兴趣。 输出格式首先输出一个字符串。 如果能满足Vani的全部两个要求，输出both； 如果通过调整只能使得各行中cl感兴趣的摊点数一样多，输出row； 如果只能使各列中cl感兴趣的摊点数一样多，输出column； 如果均不能满足，输出impossible。 如果输出的字符串不是impossible， 接下来输出最小交换次数，与字符串之间用一个空格隔开。 数据范围1≤N,M≤1000000≤T≤min(N∗M,100000)1≤x≤N1≤y≤M 输入样例：123452 3 41 32 12 22 3 输出样例：1row 1 题目分析：题目要求：就是 n 行 m 列的构成的 n * m 个交叉点，输入 t 个点的坐标，询问是否能使得每行的点数相同，每列的点数相同，若能相同，输出最小交换步数！ 交换方法：上下左右交换，还有一个特殊的交换：每一行或每一列的第一个可以和每一行或每一列的最后一个交换，即可以看成环形的状态！ 解题思路：首先：想一个问题：什么情况才能让行或列所占点数相同？ 很明显，行或列点数和只有是行或列的倍数时才可以。这样才可以平分，对吧！ 答案前半部分很好判断，后半部分最小步数不太好判断！ 接着：在想一个问题，在做行与行间点的交换时，即上下交换，会发现，上下交换是不会影响列的数目变化，毕竟上下交换，一定在那一列，那一列总和不会变！ 同理：在做列与列的点的交换时，即左右交换，会发现，左右交换是不会影响行的数目变化，毕竟左右交换，一定在那一行，那一行总和不会变！ 所以本题可以分为两个部分，一个行，一个列，分别取处理！毕竟不会互相影响！ 这个题和均分纸牌问题类似： 读者可能已经想到了一个与此类似的经典问题“均分纸牌”。“均分.纸牌”问题是说，有M个人排成一行，他们手中分别有C[1]~C[M]张纸牌，在每一步操作中，可以让某个人把自己手中的一张纸牌交给他旁边的一个人，求至少需要多少步操作才能让每个人手中持有的纸牌数相等。 显然，“ 均分纸牌”问题当所有人手中持有的纸牌总数T能被M整除时有解。 我们这样想：假如可以均分，即最后牌数一样多时： 第一个人为了达到目标平均值 T/M ,要将多出来的 C[1] - T/M 给了第二个人，第二个人此时有 C[2] + C[1] - T/M张牌。 假如第一个人不够 T/M 张牌需要去第二个人处借 T/M - C[1]张牌，此时第二个人有C[2] + T/M - C[1]张牌。 终上：第一个人要想达到T/M张牌，必须去和下一个人借或给！结束之后第一个人变成了T/M张牌，发生的交换次数为|C[1] - T/M|次 第二个人当前的牌数为： C[2] + (C[1] - T/M) 为了达到T/M张牌，必须去和下一个人借或给！则要做 |C[2] + (C[1] - T/M) - T/M|次交换！ 化简一下可以得到：第i个人需要交换次数为 |C[i] + C[i - 1] +…C[1] - i * T/M| 次交换！ 最终交换次数就是将其求和即可！ 会发现每一项都有一个前缀和：令G[i] 为C[i] 的前缀和，即最终次数变成了： |G[i] - i* T/M| ：i 从 1到M求和即可！ 注意：不用考虑某个人变为负数啥的，因为最终他都会去想后面的人来补齐！这就是拆东墙补西墙，但是不一样的是，这个最终会都补好！ 继续：将每个人的初始牌数都减去T/M，得到相对于平均值的一些正负数，要想使得最终相等，那么每个人都得相对于平均值为0，即都是平均值才可以！ 假设：令 A[i] = C[i] - T/M 此时第一个人需要交换次数为|A[1]| 第二个人为|A[2] + A[1]| 第i个人为|A[i] + A[i - 1] … + A[1]| 令S[i] 为A[i] 的前缀和，则： 第i个人交换次数为：|S[i]| 所以最终次数变为了：|S[i]| ，i从1到M求和！ 到了这里，题目就简单多了！普通均分纸牌就结束了！ 回归本题：这道题就是在均分纸牌的条件上，多了一个首和尾可以交换！成为了环形均分纸牌： 首先给出一个结论： 最优解下，一定存在两个人没有进行交换 如下图： 图：2号标错了，标在紧挨3号的位置才对。。。懒得换了！ 假如发生了这样的交换，1号和2后都在给三号，我们要的是交换次数最少，最优！那么为什么不把2号到3号的直接砍断，让1号给三号多一点，给另一方少一点，这样不就可以减少交换次数吗？ 没毛病，这样就反证了刚刚的结论！ 现在我们只需要枚举在哪里有两个人没有发生交换即可！ 假设发生在k处！ 上面的那个求和公式则是在1号和M号之间断开了！即：|S[i]| ，i从1到M求和！ 发生在K处的话，前缀和S[i]会发生什么变化： 如图： 我们可以将1~M的长条进行多条拼接，即可得到在任意处砍断的完整长条，假设在K处砍断：前缀和发什么什么变化？ S[k + 1] ———–&gt; S[k + 1] +( S[M] - S[k]) （可以在左边再延长一条线看出来） S[k] —————&gt; 0 S[1] —————&gt; S[1] + (S[M] - S[k]) S[i] —————&gt; S[i] + (S[M] - S[k]) 然后又因为S[i] 是A[i] = C[i] - T/M 的前缀和，叨叨S[M]时，前面的都已经变为0了，即达到T/M了，最后一个人则自动达成最终的T/M，所以最后一项一定是0，不需要发生交换！ 所以原式子：|S[i]| ，i从1到M求和！ 有了砍断部分的加入则变成了|S[i] - S[M]| - S[k]| 因为S[M]为0，则最终变为：|S[i] - S[k]| 最终交换次数为：|S[i] - S[k]| i从1到M求和 现在就是要找到砍断的地方，使得，这个式子求和和值最小！ 看这个式子的几何意义：就是k到各个前缀和的距离，此时，没有什么点数，牌数，已经转变为了一个个前缀和，就像一个个条形的柱子，想统计学的柱形图一样，在中间找一个地方，使得到左右柱子的距离和最短！ 眼熟吗？ 这不就是刚刚做过的AcWing-104. 货仓选址 吗？ 砍断处 k 相当于货仓位置，s[i] 相当于各个商店位置！ 什么时候距离最小呢？ 参考货仓选址的中位数证明！ 所以只要将 砍断处选在 中位数的位置即可达到最优解！ 本题解完毕！ 可以看《算法竞赛进阶指南》的作者李煜东的讲解视频：大概在29分钟的时候！ 题解：注意：要用long long，数据很大！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;int n, m, t;int a[N], b[N], f[N];LL calc(int c[], int n){ // c[i]--&gt;A[i] = C[i] - T/M // f[i]--&gt;S[i] 为A[i]前缀和 for(int i = 1; i &lt;= n; i++) c[i] -= c[0]/n, f[i] = f[i - 1] + c[i]; sort(f + 1, f + 1 + n); LL mid = f[n + 1 &gt;&gt; 1]; LL res = 0; //求 |S[i] - S[k]| 的和 for(int i = 1; i &lt;= n; i++) res += abs(f[i] - mid); return res;}int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for(int i = 1, x, y; i &lt;= t; i++) { cin &gt;&gt; x &gt;&gt; y; a[x] ++, b[y] ++; } for(int i = 1; i &lt;= n; i++) a[0] += a[i]; for(int i = 1; i &lt;= m; i++) b[0] += b[i]; int row = a[0] % n, col = b[0] % m; if(!row &amp;&amp; !col) cout &lt;&lt; \"both \" &lt;&lt; calc(a, n) + calc(b, m) &lt;&lt; endl; else if(!row) cout &lt;&lt; \"row \" &lt;&lt; calc(a, n) &lt;&lt; endl; else if(!col) cout &lt;&lt; \"column \" &lt;&lt; calc(b, m) &lt;&lt; endl; else cout &lt;&lt; \"impossible\"; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"前缀和","slug":"前缀和","permalink":"https://niuxvdong.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"贪心","slug":"贪心","permalink":"https://niuxvdong.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"中位数","slug":"中位数","permalink":"https://niuxvdong.top/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"字符串-字典序问题","slug":"字符串-字典序问题","date":"2020-03-04T09:36:10.000Z","updated":"2020-03-04T09:36:10.000Z","comments":true,"path":"posts/65259.html","link":"","permalink":"https://niuxvdong.top/posts/65259.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目背景：题目描述在数据加密和数据压缩中常需要对特殊的字符串进行编码。给定的字母表A由26个小写英文字母组成A={a,b,…,z}。该字母表产生的升序字符串是指字符串中字母按照从左到右出现的次序与字母在字母表中出现的次序相同，且每个字符最多出现1次。例如，a,b,ab,bc,xyz等字符串都是升序字符串。现在对字母表A产生的所有长度不超过6的升序字符串按照字典序排列并编码如下。 1 2 … 26 27 28 … a b … z ab ac … 对于任意长度不超过6的升序字符串，迅速计算出它在上述字典中的编码。 算法设计：对于给定的长度不超过6的升序字符串，计算出它在上述字典中的编码。 输入格式第一行是一个正整数k，表示接下来共有k行。 接下来的k行中，每行给出一个字符串。 输出格式输出共有k行，每行对应于一个字符串的编码。 数据范围1≤n≤100000 输入样例：1232aab 输出样例：12127 题目分析：题目要求：输入一个字典序字符串，输出对应的编号，注意没有aa，abccd，后面的一定比前面的大！ 解题思路：先举一个例子：假如输入 cdfg ，要怎么计算了？ 先看长度为字符串长度的处理： c开头的一定排在a和b开头的后面，我们可以先算出a打头的长度为4的字符串有多少个，用C(26 - 1, 4 - 1) 表示从25个字符中组合3长度的组合种类！这句话是不是相当于C 325 了，即数学中的排列组合的组合，这样既可保证不重不漏，还可以保证字典序正确！ a完了，还有b开头的长度为4的字符串种类，即C(26 - 2, 4 - 1) ab完了，到了c，很明显，c不需要处理 往后移动，到了d的位置，c的下一个就是d，不需要处理 下一个f，会发现f一定在e开头的长度为2的字符串之后，所以需要继续统计,即C(26 - 5 , 4 - 3) 继续发现下一个是g，这也是最后一个，就简单了，不需要用到组合，g一定在a之后，最后直接累加一下a ~ g的编号即可！ 再看长度小于字符串长度的处理： 很明显：我们处理完毕了字符串本身长度的排序，还没有处理，在自身长度之下，长度为1 ~ len - 1 的长度，不过这就更加简单了！ 长度为1：C(26, 1) 长度为2：C(26, 2) 长度为len - 1：C(26, len - 1);","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"字典序","slug":"字典序","permalink":"https://niuxvdong.top/tags/%E5%AD%97%E5%85%B8%E5%BA%8F/"},{"name":"字符串","slug":"字符串","permalink":"https://niuxvdong.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"组合数","slug":"组合数","permalink":"https://niuxvdong.top/tags/%E7%BB%84%E5%90%88%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"AcWing-104.货仓选址","slug":"AcWing-104-货仓选址","date":"2020-03-03T04:19:38.000Z","updated":"2020-03-03T04:19:38.000Z","comments":true,"path":"posts/57916.html","link":"","permalink":"https://niuxvdong.top/posts/57916.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：104. 货仓选址 题目背景： 贪心，贪的我很服。。。 题目描述在一条数轴上有 N 家商店，它们的坐标分别为 A1~AN。 现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。 为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。 输入格式第一行输入整数N。 第二行N个整数A1~AN。 输出格式输出一个整数，表示距离之和的最小值。 数据范围1≤N≤100000 输入样例：1246 2 9 1 输出样例：112 题目分析：题目要求：有N个商店，要求放一个仓库使得到所有商店的距离和最小，输出最小值！ 解题思路：第一想法就是暴力扫描一遍，选出最小值即可！但是超时了，数据范围为1e5，平方就是1e10，肯定超时，详见题解一的代码： 正确思路： 先排序，使其变成一条链状的情况！ 把a[0] ~ a[N-1]排序，设货仓在X坐标处，X左侧的商店有P家，右侧的商店有Q家。若P &lt; Q，则每把仓库的选址向右移动1单位距离，距离之和就会变少Q - P.同理，若P &gt; Q，则仓库的选址向左移动会使距离之和变小。当P==Q时为最优解。 结合图片，红色的圈表示商店，蓝色的箭头表示仓库的所在地： 第一种情况：左边的商店数目小于右边时，往右移动，则左边的都要加一，右边的都要减一，而右边的多，所以最终距离和会变小！ 第二种情况：左边的商店数目大于右边时，往左移动，则左边的都要减一，右边的都要加一，而左边的多，所以最终距离和会变小！ 第三种情况：第一种情况左移，和第二种情况右移，会发现最终都是变大的！ 总结：仓库的位置一定不在靠左，也不在靠右，因为，如果在两边，都会有更优的地方，可以取到最小值！所以中间一定是最优的地方； 也就是上图的红色箭头处，五个仓库取中间即可！ 分一下奇偶数情况，都进行取中位数即可，即仓库从N个商店中找一个中间商店，若为偶数则随便即可！我们统一选择偶数时编号小的那个：即res = n- 1 &gt;&gt; 1 一篇好理解一点的题解：点击这里！ 题解：题解一：（TLE）超时代码时间复杂度：O(N2) 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int a[N], b[N], k;int main(){ int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); int res = 0x3f; for(int i = a[0]; i &lt; a[n - 1]; i++) { int sum = 0; for(int j = 0; j &lt; n; j++) { sum += abs(i - a[j]); } b[k++] = sum; } sort(b, b + k); cout &lt;&lt; b[0] &lt;&lt; endl; return 0;} 题解二：选取中位数为仓库处时间复杂度：O(N) 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int a[N];int main(){ int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); int int sum = 0; for(int i = 0; i &lt; n; i++) sum += abs(a[res] - a[i]); cout &lt;&lt; sum &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"排序","slug":"排序","permalink":"https://niuxvdong.top/tags/%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"https://niuxvdong.top/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"AcWing-102.最佳牛围栏","slug":"AcWing-102-最佳牛围栏","date":"2020-03-01T14:36:13.000Z","updated":"2020-03-01T14:36:13.000Z","comments":true,"path":"posts/35910.html","link":"","permalink":"https://niuxvdong.top/posts/35910.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：102. 最佳牛围栏 题目背景： 一道难题，前缀和，差分，双指针的叠加应用！ 题目描述农夫约翰的农场由 N 块田地组成，每块地里都有一定数量的牛,其数量不会少于1头，也不会超过2000头。 约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。 围起区域内至少需要包含 F 块地，其中 F 会在输入中给出。 在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。 输入格式第一行输入整数 N 和 F ，数据间用空格隔开。 接下来 N 行，每行输出一个整数，第i+1行输出的整数代表，第i片区域内包含的牛的数目。 输出格式输出一个整数，表示平均值的最大值乘以1000再 向下取整 之后得到的结果。 数据范围1≤N≤1000001≤F≤N 输入样例：123456789101110 66 4210385941 输出样例：16500 题目分析：题目要求：给了N块地，每块地有一些牛，现在想让你在1 ~ N 块地里，连续的选取大于 f 块地，使得得到的平均数最大！ 输出最大的平均值！ 解题思路：首先说一下我的思路：（TLE） 因为数据是10的五次方，我用的是O(N)的做法，那就是10的10次方了，远远大于C++一秒可以计算的次数了！ 我就是暴力找一遍！ 先计算前缀和，为了以后用的时候方便！然后用两重for循环去找，一个在区间左端点，一个在右端点，为了保证区间长度大于f，如解法一的两重for 循环的循环变量设置！每次取一个最大值即可，当然，它超时了！ 现在开始正确的O(NlogN)的做法： 二分思想： 那么我们判断是否存在一个平均值大于等于mid，如果最优解是x，那么mid &lt;= x的时候，必然可以找到一段，其平均值≥mid， 否则 一定找不到！ 就是说最终的答案那个平均值，一定在1 ~ 2000头牛之间，我们用二分，从mid开始，如果发现mid是可以合法的，那么一定有大于mid的平均值可以作为最后答案，也就是一定有一个从mid开始的一个长度&gt;=f的区间可以达到更大的平均值！所以区间开始一步步缩小，为了达到乘1000向下取值，精度就得达到1e-4左右，为了保险将精度压到1e-5！ 在平均值check时，可以将原值都减去传入的二分平均值mid，最后再进行前缀和！这时看一个区间平均值就可以直接看前缀和是不是大于0，大于0则平均值大于mid，反之，小于mid！ 如果可选区间有一个大于mid的区间，那么，最终答案一定大于mid，在主函数内部进行二分区间的缩小，往后移动即可！ 此处有一个即可，有一个，只要有就行，只要有就可以使得mid成立，即最终结果一定比mid大，区间要后移！有就行，那么当然要选择最小的，sum[j] - minv &gt;= 0 要想使这个式子成立，只要使得minv为可选区间最小即可，只要成立一种就行，用最小的岂不是更方便！ 接下来就是区间的变化，i,j始终保持f的距离！然后sum[j] - minv &gt;= 0 可以看到这个区间的长度一定是大于f的，可以画个图去理解！ 可以结合下面某位大神的题解： 我们要找的是 有没有一段不小于F的区间，使这段区间的平均数尽可能的大，如果我们找到了一段连续的区间且区间长度不小于F且平均数大于我们二分的平均数 ，那么大于这个数的区间也一定满足了， 我们直接返回true！ 因为我们要找一段区间的平均数，根据平均数的一个基本应用，显而易见，对于一段序列，每个数减去我们所算的平均数，如果大于0 那么他本身就大于平均数，如果小于0 那么它本身就小于平均数， 此时我们就能算出哪些数大于0 哪些数小于0 ，之后我们再使用前缀和，就能判断一个区间内的平均值是否大于或小于我们二分的平均数了！ 我们还可以继续优化，因为我们不仅需要找F大小区间内，我们还要找＞F大小区间内的，我们如果用二次for太费时间了，我们这里可以使用双指针的做法，我们设i=0,j=F ，每次使两个数++ ，因为i,j始终满足相距F的距离，所以我们用一个变量minv来存储i所遍历到的最小值，这样我们比较的距离一定是≥F的，并且如果我们用j位的前缀和数减去minv的话，就能得到我们的最优解，如果这个最优解＞= 0 那么就满足我们的指定条件，即可以得到平均值大于min的取值，返回true！ yxc大神的视频讲解：点击这里！ 一篇好理解一点的题解：点击这里！ 题解：解法一：本人的暴力超时做法！（TLE）时间复杂度：O(N2) 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N = 100010;int g[N], n, f;int main(){ cin &gt;&gt; n &gt;&gt; f; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; g[i]; g[i] += g[i - 1]; } double res = 0; for(int r = f; r &lt;= n; r++) { for(int l = 1; l &lt;= r - f + 1; l++) { double t = (g[r] - g[l - 1])/(r - l + 1.0); res = max(res, t); } } res *= 1000; printf(\"%.0lf\\n\", res); return 0;} 解法二：使用二分，前缀和，双指针的yxc大神的AC做法！好好看看代码，可以结合上面的题解与上面附出的大神的视频！ 注意：r 要取最大牛，输入时用来max函数，其实不取最大值，直接带入2000也可以，但取最大值更加精准！ 可能的最大值 ：题目最后这样写的！即要输出极大值，很明显r 最终一定比l大，所以最后要输出 r , 而不是 l ，输出 l 的话，其值一定会比 r 小！ 这里sum数组的变化是不需要处理的，数组每次其实都是重新复制去覆盖的，不用担心上一下会影响到下一次！ cow[i] - avg：可以看成整体，将每一位数都减去平均值！ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;const int N = 100010;int cow[N];double sum[N]; int n, f;bool check(double avg){ for(int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + cow[i] - avg; double minv = 0; for(int i = 0, j = f; j &lt;= n; i++, j++) { minv = min(minv, sum[i]); if(sum[j] - minv &gt;= 0) return true; } return false;}int main(){ cin &gt;&gt; n &gt;&gt; f; double l = 0, r = 0; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; cow[i], r = max(r, (double)cow[i]); while(r - l &gt; 1e-5) { double mid = (l + r) / 2; if(check(mid)) l = mid; else r = mid; } cout &lt;&lt; int(r * 1000) &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"前缀和","slug":"前缀和","permalink":"https://niuxvdong.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"二分","slug":"二分","permalink":"https://niuxvdong.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"双指针","slug":"双指针","permalink":"https://niuxvdong.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"AcWing-101.最高的牛","slug":"AcWing-101-最高的牛","date":"2020-03-01T08:44:34.000Z","updated":"2020-03-01T08:44:34.000Z","comments":true,"path":"posts/63414.html","link":"","permalink":"https://niuxvdong.top/posts/63414.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：101. 最高的牛 题目背景： 差分应用！ 题目描述有 N 头牛站成一行，被编队为1、2、3…N，每头牛的身高都为整数。 当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。 现在，我们只知道其中最高的牛是第 P 头，它的身高是 H ，剩余牛的身高未知。 但是，我们还知道这群牛之中存在着 M 对关系，每对关系都指明了某两头牛 A 和 B 可以相互看见。 求每头牛的身高的最大可能值是多少。 输入格式第一行输入整数N,P,H,M，数据用空格隔开。 接下来M行，每行输出两个整数 A 和 B ，代表牛 A 和牛 B 可以相互看见，数据用空格隔开。 输出格式一共输出 NN 行数据，每行输出一个整数。 第 ii 行输出的整数代表第 ii 头牛可能的最大身高。 数据范围1≤N≤100001≤H≤10000001≤A,B≤100000≤M≤10000 输入样例：1234569 3 5 51 35 34 33 79 8 输出样例：123456789545344555 注意： 此题中给出的关系对可能存在重复 题目分析：题目要求：n头牛，给出多组互相可以看见的牛，求所有牛的最大高度是多少？ 并且，如果两头牛可以互相看到，则两头牛中间的牛的高度一定小于两端的高度！ 解题思路：了解一个性质： 可不可能有两组可看到的牛发生重合，例如：（3, 8），（5, 11），很明显不可能，5要比8小，才能使得3和8看见；5还要比8大，才能使得5和11看见，很明显，已经矛盾了！ 所以所有的组数，都不会有覆盖，只可能是嵌套，所以假设原高度都是h，如果当前牛在区间内则必须得减一，才能保证互相看到，假如另一组数据正好包围当前数据，那么由于传递性，最外面要比中间的高，所以中间得减一，最内部还得减一！ 这是就可以用到差分序列了，如果假设原数组高度都是h，则差分序列： g[1] = h；剩下的都是0。即可！ 给区间-1操作： g[a + 1] --, g[b] ++; 可以画一下看看！ 最后为了得到牛的高度，即将差分序列再转回前缀和序列即可！ yxc大神的视频讲解：点击这里！ 题解：注意：a，b大小，逆序时交换一下，方便！ 注意：可能有重复数据，则判断一下，防止多减一操作！ 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;const int N = 10010;int g[N];bool visit[N][N];int main(){ int n, p, h, m; cin &gt;&gt; n &gt;&gt; p &gt;&gt; h &gt;&gt; m; g[1] = h; for(int i = 0, a, b; i &lt; m; i++) { cin &gt;&gt; a &gt;&gt; b; if(a &gt; b) swap(a, b); if(!visit[a][b]) { visit[a][b] = true; g[a + 1] --; g[b] ++; } } for(int i = 1; i &lt;= n; i++) { g[i] += g[i - 1]; cout &lt;&lt; g[i] &lt;&lt; endl; } return 0;} 更好一点的话：可以使用set集合来代替数组，毕竟set具有极快的查找速度！ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int N = 10010;int g[N];int main(){ int n, p, h, m; cin &gt;&gt; n &gt;&gt; p &gt;&gt; h &gt;&gt; m; g[1] = h; set&lt;pair&lt;int, int&gt;&gt; s; for(int i = 0, a, b; i &lt; m; i++) { cin &gt;&gt; a &gt;&gt; b; if(a &gt; b) swap(a, b); if(!s.count({a, b})) { s.insert({a, b}); g[a + 1] --; g[b] ++; } } for(int i = 1; i &lt;= n; i++) { g[i] += g[i - 1]; cout &lt;&lt; g[i] &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"差分序列","slug":"差分序列","permalink":"https://niuxvdong.top/tags/%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97/"}],"author":"Mr.Niu"},{"title":"AcWing-100.增减序列","slug":"AcWing-100-增减序列","date":"2020-03-01T06:24:16.000Z","updated":"2020-03-01T06:24:16.000Z","comments":true,"path":"posts/41483.html","link":"","permalink":"https://niuxvdong.top/posts/41483.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：100. 增减序列 题目背景： 前缀和和差分序列是互逆的！ 题目分析处详细解释！ 题目描述给定一个长度为 n 的数列 a1,a2,…,an，每次可以选择一个区间 [l,r]，使下标在这个区间内的数都加一或者都减一。 求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。 输入格式第一行输入正整数n。 接下来n行，每行输入一个整数，第i+1行的整数代表ai。 输出格式第一行输出最少操作次数。 第二行输出最终能得到多少种结果。 数据范围0&lt;n≤1050≤ai&lt;2147483648 输入样例：1234541122 输出样例：1212 题目分析：题目要求：在一个序列内任意选择区间，将区间内的数都进行加一或减一操作，使得最后的序列数字都一样，问对少步数和达到最少步数的方法总数！ 解题思路：先引入差分： a数组是普通序列，b数组是a数组的差分序列！ 差分序列定义：b[i] = a[i] - a[i-1], b[1] = a[1] 然后就是两个定理： b 序列是 a 序列的差分序列（定义就是这样定义的！） a 序列是 b 序列的前缀和序列（开始证明！） a[i] 可以写为 b[1] + b[i]：如下： 123456a[1],a[2],.…a[n]b[i] = a[i] - a[i-1], b[1] = a[1]a[i] = b[1] + b[2] +.…+ b[i] = a[1] + a[2] - a[1] + a[3] - a[2] +.…+ a[i] - a[i-1] = a[i] 证明成立！ 接下来开始看题！ 在一个(L，R)序列上加一个常数 C，相当于： 1b[L] += C b[R + 1] -= C; 这个可以稍微想一下：或者那笔画一下！ 假设序列从下标为1开始存储！ 再想一下：要想全部数变成同样的数，可以让b数组变成什么样？ 当然是让 b[1] ~ b[n] 都为0，也就是整个序列此时都是 a[1] ，即 n 个 a[1]！ 首先先将差分序列处理出来，我们可以想，既然是区间的端点出进行加一或减一，那么，让一个正数去–，一个负数去++是不是可以更快的达到为0的目的！ 所以可以将差分序列的正数和负数都累加一下计算出来！得到两个值！ 这样的话：选取一个区间就会使累积的正数（假如是40）和一个负数（假如是34）减一，这样直到其中一方为0，这样正负数匹配就结束了，可能剩下的多出来的一方（不为0的）就需要和b[0]或b[n + 1]来处理。 正负匹配需要最少为 34次，即min(34, 40) 多出来的最少需要 40 - 34 次，即abs(34 - 40) 或者直接这样想，一次就需要正负减1，全部处理完，自然就是最大的数了！就是40次，直接max(34, 40) 所以最少次数为：min(34, 40) + abs(34 - 40) = max(34, 40) 以及最后的方案数： min(34, 40)是死的，最后不一样的就是多出来的（不为0的）的数的方案，即 abs(40- 34) + 1！ yxc大神的视频讲解：点击这里！ 题解：讲解是下标从1开始，我是从0开始，都一样的！ 防止溢出，使用 long long！ 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;int n;int a[N], b[N];int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt; n; i++) b[i] = a[i] - a[i - 1]; // positive number, negative number LL pos = 0, neg = 0; for(int i = 0; i &lt; n; i++) if(b[i] &gt; 0) pos += b[i]; else neg -= b[i]; cout &lt;&lt; max(pos, neg) &lt;&lt; endl &lt;&lt; abs(pos - neg) + 1 &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"差分序列","slug":"差分序列","permalink":"https://niuxvdong.top/tags/%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97/"}],"author":"Mr.Niu"},{"title":"AcWing-99.激光炸弹","slug":"AcWing-99-激光炸弹","date":"2020-02-29T14:07:26.000Z","updated":"2020-02-29T14:07:26.000Z","comments":true,"path":"posts/26178.html","link":"","permalink":"https://niuxvdong.top/posts/26178.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：99. 激光炸弹 题目背景：题目描述地图上有 N 个目标，用整数Xi,Yi表示目标在地图上的位置，每个目标都有一个价值Wi。 注意：不同目标可能在同一位置。 现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有的目标。 激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和x，y轴平行。 若目标位于爆破正方形的边上，该目标不会被摧毁！ 求一颗炸弹最多能炸掉地图上总价值为多少的目标。 输入格式第一行输入正整数 N 和 R ,分别代表地图上的目标数目和正方形的边长，数据用空格隔开。 接下来N行，每行输入一组数据，每组数据包括三个整数Xi,Yi,Wi,分别代表目标的x坐标，y坐标和价值，数据用空格隔开。 输出格式输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。 数据范围0≤ R ≤1090&lt; N ≤100000≤ Xi,Yi ≤50000≤ Wi ≤1000 输入样例：1232 10 0 11 1 1 输出样例：11 题目分析：题目要求：就是在一个地图上放一个边长为 r 正方形，最后要输出这个正方形扣住的区域权值最大的值！ 注意：正方形的边上的不算！ 解题思路：首先引入一维前缀和： 作用：可以在O(1)的时间内求出某一段区间的和！ 举个例子： a[1]、a[2] ……… a[n] 引入s[i]前缀和： s[i] = s[0]……+s[i] 加入求a[7] ~ a[40] 那么就等于s[40] - s[6]！ 接着引入二维前缀和： 就是变成了一个坐标： 首先给出递归式：s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; 画个图：紫色的自己加上红色和绿色构成的矩形，再加上另一个红色和绿色构成的矩形，在减去多加的绿色部分！ 接下来开始预处理前缀和，在输入是让x和y都加了1，这样在预处理时，不会出现负数下标，免得处理边界问题！ 由于每个点不止一个目标：所以数组要进行累加：g[x][y] += w; 接下来开始划分边长为R的矩形，要保证边长足够，所以i和j 最小也得从R开始，此时的(i, j) 指向的是矩形的右下角，这样可以保证不越界！ 递推式：g[i][j] - g[i - r][j] - g[i][j - r] + g[i - r][j - r] 很好理解的：此时的(i , j)表示的行和列，即第i行第j列！ 如下图： 假如：r = 2,要计算 g[3][3]为右下角时，需要减去画那两道红线所构成的两个矩形，再加上多减掉的交叉部分，这样剩下的就是从青绿色右下角开始的四个蓝色的圈，这样看来，得到的结果就不是R 边长了，而是R- 1的边长，这样也就可以保证边上的不被计算！ 为什么不把右边和下边两条边也删掉了？ 我看了好久！才发现： 不能删，删掉上和左就够了！ 你可以在脑袋里想一下，将那个矩形在图上飘起来，会发现盖住的部分最多就是那四个蓝色的圈！而R - 1 就可以实现边上的不记录效果！ 好好理解一下，可能有点绕！ yxc大神视频讲解：点击这里！ 题解：123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;const int N = 5010;int g[N][N];int main(){ int s, r; cin &gt;&gt; s &gt;&gt; r; // 题目R的数据有点问题，怎么可能比坐标最大还打，所以约束一下 r = min(r, 5010); int n = 5010; for(int i = 0, x, y, w; i &lt; s; i++) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; x ++, y ++; g[x][y] += w; } // 预处理前缀和 for(int i = 1; i &lt; n; i++) for(int j = 1; j &lt; n; j++) g[i][j] += g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1]; // 找到（i，j）为矩形右下角 int res = 0; for(int i = r; i &lt; n; i++) for(int j = r; j &lt; n; j++) res = max(res, g[i][j] - g[i - r][j] - g[i][j - r] + g[i - r][j - r]); cout &lt;&lt; res &lt;&lt; endl; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"二维前缀和","slug":"二维前缀和","permalink":"https://niuxvdong.top/tags/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"}],"author":"Mr.Niu"},{"title":"AcWing-96.奇怪的汉诺塔","slug":"AcWing-96-奇怪的汉诺塔","date":"2020-02-29T09:44:12.000Z","updated":"2020-02-29T09:44:12.000Z","comments":true,"path":"posts/34850.html","link":"","permalink":"https://niuxvdong.top/posts/34850.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：96. 奇怪的汉诺塔 题目背景：题目描述汉诺塔问题，条件如下： 1、这里有A、B、C和D四座塔。 2、这里有n个圆盘，n的数量是恒定的。 3、每个圆盘的尺寸都不相同。 4、所有的圆盘在开始时都堆叠在塔A上，且圆盘尺寸从塔顶到塔底逐渐增大。 5、我们需要将所有的圆盘都从塔A转移到塔D上。 6、每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。 请你求出将所有圆盘从塔A移动到塔D，所需的最小移动次数是多少。 汉诺塔塔参考模型 输入格式没有输入 输出格式对于每一个整数n(1≤n≤121≤n≤12),输出一个满足条件的最小移动次数，每个结果占一行。 输入样例：1没有输入 输出样例：1参考输出格式 题目分析：题目要求：此题是三根柱子汉诺塔的变形，现在有四根棍子，需要输出n 为1 到12的最小移动次数即可！ 解题思路：先介绍一下三根棍子情况：不论有多少个碟子，都可看为这几步： 将前n - 1 个盘子移到第二个棍子 再将最底下的1个盘子移到第三个棍子 再将n - 1个盘子移到第三个棍子 所以得到递推式：d[n] = d[n - 1] + 1 + d[n - 1]; 初始值为d[1] = 1; 再看一下四根棍子的情况：不论多少个盘子，都可以看为这几步： 将前 i 个盘子移到第二个棍子 再将剩下的n - i 个盘子移到第三个棍子 再将 前 i 个盘子移到第四根棍子 所以得到递归式：f[n] = f[i] + d[n - i] + f[i]; 初始值为f[0] = 0； 前i 个盘子有 j种情况！每次取一个min函数即可！ 至于为什么是d[n - 1]，可以这样想，将前 i 个移走后，第二根柱子就死了，不能再用了，所以可以看做是三根棍子，第二步就变为了三根棍子的情况！ yxc大神的视频讲解：点击这里！ 题解：123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int d[20], f[20];int main(){ d[1] = 1; for(int i = 2; i &lt;= 12; i++) d[i] = d[i - 1] + 1 + d[i - 1]; memset(f, 0x3f, sizeof f); f[0] = 0; for(int i = 1; i &lt;= 12; i++) for(int j = 0; j &lt; i; j++) f[i] = min(f[i], f[j] + d[i - j] + f[j]); for(int i = 1; i &lt;= 12; i++) cout &lt;&lt; f[i] &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"Dp","slug":"Dp","permalink":"https://niuxvdong.top/tags/Dp/"},{"name":"递推","slug":"递推","permalink":"https://niuxvdong.top/tags/%E9%80%92%E6%8E%A8/"}],"author":"Mr.Niu"},{"title":"AcWing-95.费解的开关","slug":"AcWing-95-费解的开关","date":"2020-02-29T08:39:12.000Z","updated":"2020-02-29T08:39:12.000Z","comments":true,"path":"posts/18232.html","link":"","permalink":"https://niuxvdong.top/posts/18232.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：95.费解的开关 题目背景：题目描述你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态 123451011101101101111000011011 在改变了最左上角的灯的状态后将变成： 123450111111101101111000011011 再改变它正中间的灯后状态将变成： 123450111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。 输入格式第一行输入正整数n，代表数据中共有n个待解决的游戏初始状态。 以下若干行数据分为nn组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。 输出格式一共输出n行数据，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。 对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。 数据范围0&lt;n≤500 输入样例：1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 输出样例：12332-1 题目分析：题目要求：给定一个 5 x 5 的矩阵，想要全部变成1，求最少的步数，并且改变一个上下左右都换变化！ 解题思路：我们可以一层一层去想，先看第一层，如果第一层有 0， 我们需要在下一层的正下方的那个点作为中心改变状态即可，使上面的0变为1,；同样，第一层结束，要想使第二层也全变为1，做法一样，使有0 的正下方作为中心改变即可；最终只需要判断改变了前四行后，第五行有没有全部变为1即可，若没有变为1，则此种情况并不合法。 第一层的变化自然是有2的五次方，仍然想成二进制来表示，只需枚举这些所有情况即可，将可达到最终状态的最小值找出来即可！ 也就是说，如果只考虑第一层，他的开关方法有2的五次方，最终可以使最后一层全部变为1的就是一组解！ 注意：本题输入是没有空格的，我以为有空格，用int来存储的，结果出了问题，可以使用char数组来存储即可！ 为了方便的复制一份g数组，使用的cstring头文件的memcpy函数！ memcpy()函数： 第一个参数：备份数组 第二个参数：原数组 第三个参数：用sizeof计算的大小 在进行0,1取反时，直接和1异或即可！ char类型的 0 和 1 也可以：对应的ASCII码分别为48和49，二进制如下： 110000 110001 异或后结果没有问题！ yxc大神的视频讲解：点击这里！ 题解：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;char g[10][10];char backup[10][10];int dx[5] = {0, -1, 1, 0, 0}, dy[5] = {0, 0, 0, -1, 1};bool in(int x, int y){ return x &gt;= 0 &amp;&amp; x &lt; 5 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 5;}// 改变五个值void turn(int x, int y){ for(int i = 0; i &lt; 5; i++) { int a = x + dx[i], b = y + dy[i]; if(in(a, b)) g[a][b] ^= 1; }}int solve(){ int ans = 0x3f; //二进制的1来表示按那个灯 for(int i = 0; i &lt; 1 &lt;&lt; 5; i++) { int res = 0; // 扫描第一层按过的开关，并进行修改 for(int j = 0; j &lt; 5; j++) { if(i &gt;&gt; j &amp; 1) { res ++; turn(0, j); } } // 扫描前四层 for(int j = 0; j &lt; 4; j++) { for(int k = 0; k &lt; 5; k++) { if(g[j][k] == '0') { res ++; turn(j + 1, k); } } } // 扫描最后一层 bool flag = true; for(int j = 0; j &lt; 5; j++) if(g[4][j] == '0') { flag = false; break; } // 还原g数组的状态 memcpy(g, backup, sizeof g); if(flag) ans = min(ans, res); } if(ans &gt; 6) return -1; return ans;}int main(){ cin &gt;&gt; n; while(n --) { for(int i = 0; i &lt; 5; i++) cin &gt;&gt; g[i]; memcpy(backup, g, sizeof g); cout &lt;&lt; solve() &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"递推","slug":"递推","permalink":"https://niuxvdong.top/tags/%E9%80%92%E6%8E%A8/"},{"name":"位运算","slug":"位运算","permalink":"https://niuxvdong.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"author":"Mr.Niu"},{"title":"AcWing-94.递归实现排列型枚举","slug":"AcWing-94-递归实现排列型枚举","date":"2020-02-28T13:10:57.000Z","updated":"2020-02-28T13:10:57.000Z","comments":true,"path":"posts/45388.html","link":"","permalink":"https://niuxvdong.top/posts/45388.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：94. 递归实现排列型枚举 题目背景：题目描述把 1~n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。 输入格式一个整数n。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。 数据范围1≤n≤9 输入样例：13 输出样例：1234561 2 31 3 22 1 32 3 13 1 23 2 1 题目分析：题目要求：全排列，字典序小的在前！ 解题思路：具体看代码以及注释和介绍！ 题解：题解一：最普通的递归：不解释了！没什么说的，极易理解！ 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; using namespace std;int n;int a[10];bool visit[10];void dfs(int u){ if(u == n) { for(int i = 0; i &lt; n ; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = 1; i&lt;= n; i++) { if(!visit[i]) { a[u] = i; visit[i] = true; dfs(u + 1); visit[i] = false; } }}int main(){ cin &gt;&gt; n; dfs(0); return 0;} 题解二：yxc大神的使用vector的版本auto 是C++ 11 的新特性，要想编译通过，需要在编译器设置好！具体百度！ 和上面注释掉的for循环是一样的！ 用state存储二进制状态，u表示当前枚举到的数，退出条件：u == n 时！ dfs结束后记得还原vector的状态！ 12345678910111213141516171819202122232425262728293031323334#include &lt;vector&gt;#include &lt;iostream&gt; using namespace std;int n;vector&lt;int&gt; v;void dfs(int u, int state){ if(u == n) { //for(int i = 0; i &lt; v.size() ; i++) cout &lt;&lt; v[i] &lt;&lt; \" \"; for(auto x : v) cout &lt;&lt; x &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = 1; i&lt;= n; i++) { if(!(state &gt;&gt; i &amp; 1)) { v.push_back(i); dfs(u + 1, state | 1 &lt;&lt; i); v.pop_back(); } }}int main(){ cin &gt;&gt; n; dfs(0, 0); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"DFS","slug":"DFS","permalink":"https://niuxvdong.top/tags/DFS/"}],"author":"Mr.Niu"},{"title":"AcWing-93.递归实现组合型枚举","slug":"AcWing-93-递归实现组合型枚举","date":"2020-02-28T11:17:32.000Z","updated":"2020-02-28T11:17:32.000Z","comments":true,"path":"posts/53888.html","link":"","permalink":"https://niuxvdong.top/posts/53888.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：93. 递归实现组合型枚举 题目背景： 递归实现，看完本篇你大概将知道递归转化为非递归方法！ 题目描述从 1~n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。 输入格式两个整数 n,m ,在同一行用空格隔开。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。 数据范围n&gt;00≤m≤nn+(n−m)≤25 输入样例：15 3 输出样例：123456789101 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5 思考题：如果要求使用非递归方法，该怎么做呢？ 题目分析：题目要求：解题思路： 一篇好理解的题解，点击这里！ 题解：题解一：最普通的递归：不解释了！ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt; using namespace std;const int N = 30;int n, m;int a[N];bool visit[N];void dfs(int k, int t, int m){ if(k == m) { for(int i = 0; i &lt; k; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = t + 1; i &lt;= n; i++) { if(!visit[i]) { a[k] = i; visit[i] = true; dfs(k + 1, i, m); visit[i] = false; } }}int main(){ cin &gt;&gt; n &gt;&gt; m; dfs(0, 0, m); return 0;} 题解二：这是错误的。。题目要求最后要按字典序输出，如果用上次的二进制表示，结果没问题，但是顺序是乱的！没有规律的！ Go Out！ 123456789101112131415161718192021222324#include &lt;iostream&gt; using namespace std;int n, m;int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; 1 &lt;&lt; n; i++) { int k = 0; for(int j = 0; j &lt; n; j++) if(i &gt;&gt; j &amp; 1) k++; if(k == m) { for(int t = 0; t &lt; n; t++) if(i &gt;&gt; t &amp; 1) cout &lt;&lt; t + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; } } return 0;} 题解三：yxc大神的递归，以及递归转非递归：递归容易爆栈，有时候需要使用非递归！ 递归仍然和上一题一样，稍微修改一下，多一个计数器，如果sum + 后面可以取到的数的最大位数 n - u， 还达不到 要求的m为，直接return；后面为了输出按照字典序，要换一下dfs选与不选的顺序，至于为什么（自己大脑稍微模拟一下过程即可）。 接下来就是，转化为非递归的做法，将递归的过程分为三部分，如图上所标示的： pos 为0，为1，为2，三种状态！ 使用State结构体存储状态，多一个pos来标识当前处于的状态： 将初状态鸭压入栈中：stk.push({0, 0, 0, 0}); 进入while循环来判断三种状态： pos = 0，将递归的那一段写进去，改一下变量，将return改为continue，然后将当前状态改为1，压入栈中，将状态0的最后一句dfs也压入栈中。 pos = 1，将当前状态改为2，压入栈中，将状态1的那一句dfs也压入栈中。 pos = 2， 直接continue。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stack&gt;#include &lt;iostream&gt; using namespace std;struct State{ int pos, u, sum, state; };int n, m;void dfs(int u, int sum, int state){ // pos = 0 if(sum + n - u &lt; m) return; if(sum == m) { for(int i = 0; i &lt; n; i++) if(state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt;\" \"; cout &lt;&lt; endl; return; } dfs(u + 1, sum + 1, state | 1 &lt;&lt; u); // pos = 1 dfs(u + 1, sum, state); // pos = 2}int main(){ cin &gt;&gt; n &gt;&gt; m; //dfs(0, 0, 0); stack&lt;State&gt; stk; stk.push({0, 0, 0, 0}); while(stk.size()) { State t = stk.top(); stk.pop(); if(t.pos == 0) { if(t.sum + n - t.u &lt; m) continue; if(t.sum == m) { for(int i = 0; i &lt; n; i++) if(t.state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; continue; } t.pos = 1; stk.push(t); stk.push({0, t.u + 1, t.sum + 1, t.state | 1 &lt;&lt; t.u}); } else if(t.pos == 1) { t.pos = 2; stk.push(t); stk.push({0, t.u + 1, t.sum, t.state}); } else continue; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"栈","slug":"栈","permalink":"https://niuxvdong.top/tags/%E6%A0%88/"},{"name":"DFS","slug":"DFS","permalink":"https://niuxvdong.top/tags/DFS/"}],"author":"Mr.Niu"},{"title":"AcWing-92.递归实现指数型枚举","slug":"AcWing-92-递归实现指数型枚举","date":"2020-02-28T09:02:35.000Z","updated":"2020-02-28T09:02:35.000Z","comments":true,"path":"posts/14886.html","link":"","permalink":"https://niuxvdong.top/posts/14886.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：92. 递归实现指数型枚举 题目背景： 多种做法！ 题目描述从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。 输入格式输入一个整数n。 输出格式每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。 数据范围1≤n≤15 输入样例：13 输出样例：12345678322 311 31 21 2 3 题目分析：题目要求：输出任任意位的组合（从小到大），包括0位组合（即输出空行），不限制输出顺序！ 解题思路：详见下方四种解法： 一篇好理解的题解，点击这里！ 题解：注意：选择0位也是一种情况，千万别忘记！要输出一个空行！ 解法一：本人能想到的最粗糙的做法：1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt; using namespace std;const int N = 15;int n, b[N];bool flag[N];void dfs(int k, int cnt, int pos){ if(cnt &gt;= k) { for(int i = 0; i &lt; k; i++) cout &lt;&lt; b[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = pos + 1; i &lt;= n; i++) { if(!flag[i]) { b[cnt] = i; flag[i] = true; dfs(k, cnt + 1, i); flag[i] = false; } }}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt;= n; i++) dfs(i, 0, 0); return 0;} 解法二：使用二进制优化：和之前做过的类似：将每一位的选择变成0和1的二进制即可，和直接使用数组存储（解法一）不一样的点： 添加第 i 位时：state |= 1 &lt;&lt;(i - 1); 最后还要恢复原状态：state ^= 1 &lt;&lt; (i - 1); 用到了异或和按位或，不懂的去学习一下！ 为何数组不需要恢复状态，而二进制需要恢复状态？ 因为数组存储时时从下标为0开始存储，一次dfs结束后，会进入下一次for循环，此时，数组存储的下标仍然是cnt，没有变化，即进行了覆盖，不会影响； 然而：使用二进制就不一样了，二进制存储的是每一位的状态，没有下标的关系，如果不进行恢复状态，下一次for循环可不是数组的原位覆盖，而是在新的地方置为了1，这样state状态就会多一位被选择的数，造成错误答案！ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; using namespace std;const int N = 15;int n, b[N];bool flag[N];void dfs(int state, int k, int cnt, int pos){ if(cnt &gt;= k) { for(int i = 0; i &lt; n; i++) if(state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = pos + 1; i &lt;= n; i++) { if(!flag[i]) { state |= 1 &lt;&lt;(i - 1); flag[i] = true; dfs(state, k, cnt + 1, i); flag[i] = false; state ^= 1 &lt;&lt; (i - 1); } }}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt;= n; i++) dfs(0, i, 0, 0); return 0;} 解法三：状态压缩非递归类似于第二种解法：用state来存储二进制集合，当然共有 2 n种，然后第二层for循环直接去从第0位开始扫描即可，遇到1 就输出，遇到0就跳过即可！ 本人最喜欢这种做法，既好理解又简洁！推荐！！！ 1234567891011121314151617181920#include &lt;iostream&gt; using namespace std;const int N = 15;int n, state[N];bool flag[N];int main(){ cin &gt;&gt; n; for(int state = 0; state &lt; 1 &lt;&lt; n; state++) { for(int j = 0; j &lt; n; j++) if(state &gt;&gt; j &amp; 1) cout &lt;&lt; j + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; } return 0;} 解法四：状态压缩递归形式（来自yxc大神）也就是第三种解法的递归写法，仍然是每一位数都有两种选择，选与不选，所以，此处的dfs的两个参数，第一个代表当前扫描到了哪一位，state表示当前状态的二进制为情况！ 两种状态： dfs(u + 1, state); ：不选，state 没有进行改变！ dfs(u + 1, state | (1 &lt;&lt; u)); ：选择，state 已经将 u + 1加入到了state中！ 退出条件，扫描到最后一项时进行输出和判断！ 总而言之：就像是一个二叉搜索树，都有选与不选两种情况，答案则在最后的叶子节点上！ 1234567891011121314151617181920212223242526#include &lt;iostream&gt; using namespace std;const int N = 15;int n;void dfs(int u, int state){ if(u == n) { for(int i = 0; i &lt; n; i++) if(state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; return; } dfs(u + 1, state); dfs(u + 1, state | (1 &lt;&lt; u));} int main(){ cin &gt;&gt; n; dfs(0, 0); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"DFS","slug":"DFS","permalink":"https://niuxvdong.top/tags/DFS/"},{"name":"二进制","slug":"二进制","permalink":"https://niuxvdong.top/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://niuxvdong.top/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}],"author":"Mr.Niu"},{"title":"AcWing-91.最短Hamilton路径","slug":"AcWing-91-最短Hamilton路径","date":"2020-02-27T11:19:09.000Z","updated":"2020-02-27T11:19:09.000Z","comments":true,"path":"posts/30496.html","link":"","permalink":"https://niuxvdong.top/posts/30496.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：91. 最短Hamilton路径 题目背景： 这对我来说是一道难题，经过我一直理解，看题解，看yxc大神视频，反复多次，一点点的，终于明白了这个思想并且可以自己独立写出来！ 坚持！反复！终将成功！ 此题，时间限制为 3s ！ 题目描述给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。 输入格式第一行输入整数n。 接下来n行每行n个整数，其中第ii行第jj个整数表示点ii到jj的距离（记为a[i,j]）。 对于任意的x,y,z 数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]&gt;=a[x,z]。 输出格式输出一个整数，表示最短Hamilton路径的长度。 数据范围1 ≤ n ≤ 200 ≤ a[i,j] ≤ 10 7 输入样例：12345650 2 4 5 12 0 6 5 34 6 0 8 35 5 8 0 51 3 3 5 0 输出样例：118 题目分析：题目要求：给了n个点，以及n个点之间的权，要求出从起点到终点的最短路径，并且要不重不漏的走一遍！ 解题思路：当然最容易想到的就是直接暴力枚举，但是，n的范围为20，暴力的话会达到20的阶乘，这绝对超过了C++一秒计算可达到的次数，虽然题目是三秒，但是和常数相比，还是远远不够的！ 所以要用到状态压缩： 即所有点都有两种状态，选或不选，可以用0,1来表示（二进制），这样，所有的情况就是最大就是220 , 这远比阶乘要小。 举个例子：假如有8个点，选择 0,1,5,6 时，当前状态可以表示为：01100011。 状态转移方程为：dp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; j)][k] + weight[k][j]); i 不是一个数，它表示的是二进制，即2的n次方中的一种情况； j 表示的是，当前的终点； 首先：当前状态的终点为 j 为，要想计算当前值，需要拿当前值 和 刨去 第 j 位后的状态中找一个走过的点 k,即dp[i - (1 &lt;&lt; j)][k] 在加上要到j 的终点 weight[k][j]) ,就是一个完整的路径，然后将当前状态的所有情况（即k 的取值情况）与 已知dp[i][j] 取一个min即可！ 最终答案当然就是求：dp[(1 &lt;&lt; n) - 1][n - 1] 即 dp[111..共n个1..111] 表示n个点全部走过来，第二维的 n - 1则是说终点是 最后一个点！ 要想保住是从第0个点开始，就要保证二进制的第0位永远为1，即保证他是个奇数； j 的取值当然要保证在 当前 i 的状态内，即 i &gt;&gt; j &amp; 1 用这个来判断！ k 作为中间量，当然要保证当前状态 i 刨去 j 后 k 仍然在 i 的状态内，才能进行与第三者的连接！即 i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1 ！ 最终进行状态转移方程：dp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; j)][k] + weight[k][j]); 位运算不太清楚可以百度一下学习！ yxc大神的视频讲解，点击这里！ 一篇好理解的题解，点击这里！ 题解：加快速度的办法：使用二进制，并且转态压缩本就是用二级制来存储转态的，所以可以提高速度！ 注意：要将dp数组初始化为极大值！ 12345678910111213141516171819202122232425262728293031#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1 &lt;&lt; 20;int n, weight[21][21];int dp[N][21];int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) cin &gt;&gt; weight[i][j]; memset(dp, 0x3f, sizeof dp); dp[1][0] = 0; for(int i = 0; i &lt; 1 &lt;&lt; n; i++) if(i &amp; 1) for(int j = 0; j &lt; n; j++) if(i &gt;&gt; j &amp; 1) for(int k = 0; k &lt; n; k++) if(i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) dp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; j)][k] + weight[k][j]); cout &lt;&lt; dp[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"二进制","slug":"二进制","permalink":"https://niuxvdong.top/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"状压Dp","slug":"状压Dp","permalink":"https://niuxvdong.top/tags/%E7%8A%B6%E5%8E%8BDp/"},{"name":"最短路","slug":"最短路","permalink":"https://niuxvdong.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"author":"Mr.Niu"},{"title":"AcWing-90.64位整数乘法","slug":"AcWing-90-64位整数乘法","date":"2020-02-27T06:00:36.000Z","updated":"2020-02-27T06:00:36.000Z","comments":true,"path":"posts/39845.html","link":"","permalink":"https://niuxvdong.top/posts/39845.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：90. 64位整数乘法 题目背景：题目描述求 a 乘 b 对 p 取模的值。 输入格式第一行输入整数a，第二行输入整数b，第三行输入整数p。 输出格式输出一个整数，表示a*b mod p的值。 数据范围1≤a,b,p≤1018 输入样例：123345 输出样例：12 题目分析：题目要求：两个十八位数相乘，然后模十八位数！ 解题思路：直接算肯定会超出数据类型的最大范围，所以不能直接算！ 使用高精度乘法去算，显然可以，但是没必要，本题不需要最后结果，需要的是模p 的结果，所以可以借助快速幂思想： 参考这里：AcWing-89.a ^ b 类似的：十八位数乘法会溢出，那么加法肯定不会溢出，所以就是要将乘法转化为加法： a * b a + a + a + a + a + a + a … + a a * 1 = 1a a * 2 = 2a a * 4 = 4a a * 8 = 8a … 和之前一样同样是倍增思想！ 快速幂是一个平方，这个就是一直乘2即可！ yxc大神的视频讲解：点击这里！ 题解：注意：unsigned long long 的范围是C++最大的 unsigned int 0～4294967295 int -2147483648～2147483647 unsigned long 0～4294967295 long -2147483648～2147483647 long long的最大值：9223372036854775807（19位） long long的最小值：-9223372036854775808 unsigned long long的最大值：18446744073709551615 （20位） 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;typedef unsigned long long ULL;ULL a, b, p;ULL res;int main(){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; while(b) { if(b&amp;1) res = (res + a) % p; b &gt;&gt;= 1; a = a * 2 % p; } cout &lt;&lt; res &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"快速幂","slug":"快速幂","permalink":"https://niuxvdong.top/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}],"author":"Mr.Niu"},{"title":"AcWing-89.a ^ b","slug":"AcWing-89-a^b","date":"2020-02-27T04:34:36.000Z","updated":"2020-02-27T04:34:36.000Z","comments":true,"path":"posts/2286.html","link":"","permalink":"https://niuxvdong.top/posts/2286.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：89. a^b 题目背景：题目描述求 a 的 b 次方对 p 取模的值。 输入格式三个整数 a,b,在同一行用空格隔开。 输出格式输出一个整数，表示a^b mod p的值。 数据范围0≤a,b,p≤109 输入样例：13 2 7 输出样例：12 题目分析：题目要求：求a 的 b 次方 模 p 的值。 解题思路：直接循环求a 的 b 次幂，很明显会超时，C++ 一秒大概能运行10的7次方到10的8次方次之间，本题数据为10的9次方，肯定超时！ 所以需要用到快速幂来计算： 快速幂思想如图： 假如计算3 的 7 次方，7的二进制为111，如图，3的7次相当于3的1次，2次，4次，即3的2的0次+1次+2次，而3的2次是3的1次的平方，4次是2次的平方，所以这样看来，7次本来要算7回，这样只需要算三次即可，当然这里数据较小，加入是3的1000000次，只需要计算20次左右！可见提高了多少速度。 具体思想：对次数取最后一位，如果是奇数（即对应二进制为为1），就去累乘，如果是偶数（即二进制位为0），就跳过；当然每次都要存储好下一次需要计算的数据，即将当前值平方即可！ yxc大神的快速幂模板，点击这里！ yxc大神的视频讲解，点击这里！ 题解：注意点： 如果数据是这样：9 0 1 ，此时while进不去，最后会输出初始值1，但结果要对1取余，所以应该是0！所以要在开始时就对res 取余，次数取余不会影响到后面计算，只要p 比1大，此处相当于没有变化，只有1的时候会变化！或者也可以用if 来判断一下即可！ b&amp;1 ：就是判断是不是奇数，或者说对应的二进制为是不是1 1ll ：可以简单的将数据转化为long long类型，以防溢出！ b &gt;&gt; 1 ：即二进制为右移，相当于除2，转化为二进制为就是将最后一位扔掉！ 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int a, b, p;long long res = 1;int main(){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; res %= p; while(b) { if(b&amp;1) res = res * 1ll * a % p; a = a * 1ll * a % p; b &gt;&gt;= 1; } cout &lt;&lt; res &lt;&lt; endl; return 0;} 每天学习一点点！每天进步一点点！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"快速幂","slug":"快速幂","permalink":"https://niuxvdong.top/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}],"author":"Mr.Niu"},{"title":"AcWing-788.逆序对的数量","slug":"AcWing-788-逆序对的数量","date":"2020-02-26T13:19:28.000Z","updated":"2020-02-26T13:19:28.000Z","comments":true,"path":"posts/25834.html","link":"","permalink":"https://niuxvdong.top/posts/25834.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：788. 逆序对的数量 题目背景：题目描述给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。 逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。 输入格式第一行包含整数n，表示数列的长度。 第二行包含 n 个整数，表示整个数列。 输出格式输出一个整数，表示逆序对的个数。 数据范围1≤n≤100000 输入样例：1262 3 4 5 6 1 输出样例：15 题目分析：题目要求：题目要求求出逆序对的数目，所谓逆序对就是后面的数小于前面的数就是一组！ 解题思路：首先，应该想到逆序对不就是从小大大排序时，需要交换的两者吗？所以可以使用冒泡排序，在进行交换时就进行++记录。 但是：很明显冒泡排序复杂度太大，是O(N) 的，一定超时。 所以又想到归并排序，归并排序也有逆序对的交换，所以也可以进行记录。时间复杂度为O(NlogN)！ 归并排序模板！点击这里！ 稍微解释一下归并排序，先分后合的思想： 分：将原来的一条链一直从中间切开，直到切到当前只有一个元素，这时，它是有序的。 合：将当前两个有序序列排好序用中间变量存储起来，最后再将中间序列还给原序列。 直到序列全部有序！ 本题就是要在归并排序的过程中，产生逆序对的时候，进行记录： 其中res 就是用来记录的，res = mid - i + 1; 关于这里，要详细解释一下： 123456789while(i &lt;= mid &amp;&amp; j &lt;= r){ if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else { res += mid - i + 1; temp[k++] = a[j++]; }} 首先：相邻的这两个序列，对序列本身自己来说，它是内部有序的，假如左边的序列大于右边的序列，由于左右都是有序的，那么左边的序列从当前位置 i 到 mid 结束时，都是要大于右边当前值的，所以逆序对不是1，而是 res += mid - i + 1; ， 至于为什么要这样算，因为等到右边的较小值被存储了之后，左边当前值以后真的值就没有机会和右边的被存储值进行比较了！ 如图： 题解：注意：最好使用long long 或许数据很大！ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;const int N = 100050;int a[N], temp[N];long long n, res;void merge_sort(int a[], int l, int r){ if(l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(a, l, mid), merge_sort(a, mid + 1, r); int k = 0, i = l, j = mid + 1; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else { res += mid - i + 1; temp[k++] = a[j++]; } } while(i &lt;= mid) temp[k++] = a[i++]; while(j &lt;= r) temp[k++] = a[j++]; for(i = l, j = 0; i &lt;= r; i++, j++) a[i] = temp[j];}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; merge_sort(a, 0, n - 1); cout &lt;&lt; res &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"归并排序","slug":"归并排序","permalink":"https://niuxvdong.top/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"逆序对","slug":"逆序对","permalink":"https://niuxvdong.top/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"}],"author":"Mr.Niu"},{"title":"AcWing-1326.军训队列","slug":"AcWing-1326-军训队列","date":"2020-02-25T11:08:02.000Z","updated":"2020-02-25T11:08:02.000Z","comments":true,"path":"posts/13968.html","link":"","permalink":"https://niuxvdong.top/posts/13968.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：1326. 军训队列 题目背景：题目描述有 n 名学生参加军训，军训的一大重要内容就是走队列，而一个队列的不整齐程度是该队中最高的学生的身高与最矮的学生的身高差值的平方。 现在要将 n 名参加军训的学生分成 k 个队列，每个队列的人数可以是任意非负整数。 在安排队列时希望所有队列的不整齐度之和尽量小，请问不整齐度之和最小可以是多少？ 输入格式第一行两个整数 n,k，表示学生人数和队列数。 第二行 n 个整数，依次表示每名学生的身高。 输出格式一个整数表示答案。 数据范围对于10%的数据，k=1；对于另外10%的数据，k=2；对于另外10%的数据，k=3；对于另外10%的数据，k=4；对于另外10%的数据，1≤n,k≤5；对于另外10%的数据，1≤n,k≤10；对于另外20%的数据，1≤n,k≤100；对于另外5%的数据，n=k=500;对于所有的数据，1≤n,k≤500，0≤ 学生身高 ≤200 输入样例：123 2170 180 168 输出样例：14 题目分析：这对我来说是一道难题，用到了贪心和动态规划： 我也是第一次接触Dp。 我的理解动态规划就是从小集合算到大集合，找大的集合和小的集合的关系，即可实现后面用到的前面已经算出来的效果！ 尽我的能力写了一篇足够详细的题解： 题目要求：n 个人，分成 k 组，求 k 组的最大最小值差的平方的最小值，也就是在所有分法中找一个最优解！ 解题思路：贪心 + Dp 首先，分成 k 组，一定要让 k 组不空，因为如果分成k - 1组，和从k - 1组里拿出一个人给了第k 组，后者得到的结果一定不会比前者更坏，最优解一定不会变大，也就是说，全部分成k组得到的结果会更优，自己好好想想！ 用二维数组 f[i][j] 表示将前 i 个人分成 j 组！ 前提：当然是从小到大排好序了！ 探讨 f[i][j] 的情况： 将 i 个人 划分为 j 组，考虑一下最后一组的情况，也就是要保证最后一组之前要有j - 1组，每组至少一个人，所以 最后一组的起始点最小值也得是 j , 而总共i 个人，那么最后一组的起始值的范围是 j &lt;= k &lt;= i ，也就是f[i][j] 的划分集合共有i - j 种，而最优解一定为其中一种，如下图： 继续看图：最终f[i][j] 的值当然就是前面的 j - 1 组的结果加上最后一组的和了： 前面j - 1 组，相当于从 k - 1 个人中划分 j - 1组，即f[k - 1][j - 1] : 所以：最终结果： f[i][j] = min(f[i][j], f[k - 1][j - 1] + (a[i] - a[k]) * (a[i] - a[k])); 计算最小值，当然要将f数组初始化为较大值：0x3f 。 划分组数 j 要保证不大于人数 i，不大于划分数 m 。 边界：当然是f[1][1] , 要想的到该值，当然需要有 f[0][0] 。将0个人划分为 0 组，结果当然为0；处理好边界值：f[0][0] = 0; k 的取值范围正如上面所讲，j 到 i 。 最后输出f[n][m] 即可！ 官方题解视频： yxc大神官方讲解 题解：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m;int a[510];int f[510][510];int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; if(m &gt;= n) { cout &lt;&lt; 0 &lt;&lt; endl; return 0; } sort(a + 1, a + n + 1); memset(f, 0x3f, sizeof f); f[0][0] = 0; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= i &amp;&amp; j &lt;= m; j++) { for(int k = j; k &lt;= i; k++) { f[i][j] = min(f[i][j], f[k - 1][j - 1] + (a[i] - a[k]) * (a[i] - a[k])); } } } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} 历经千辛万苦，终于折腾完毕！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://niuxvdong.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"Dp","slug":"Dp","permalink":"https://niuxvdong.top/tags/Dp/"}],"author":"Mr.Niu"},{"title":"AcWing-1324.五子棋","slug":"AcWing-1324-五子棋","date":"2020-02-25T07:29:54.000Z","updated":"2020-02-25T07:29:54.000Z","comments":true,"path":"posts/44380.html","link":"","permalink":"https://niuxvdong.top/posts/44380.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：1324. 五子棋 题目背景：题目描述小 A 和小 B 在下五子棋。 五子棋是在一个由网格构成的棋盘内进行的。 网格有 15 行 15 列，共有 225 个交叉点。 小 A 先手执黑棋，小 B 后手执白棋。 两人轮流下棋，每次下棋都将一个自己的棋子放在棋盘上一个空白的交叉点上。 然而，由于小 A 和小 B 都不知道五子棋的胜利条件，所以即使有一方已经胜利了，他们仍然会继续下棋。 现在想请你帮忙分析一下，所下的棋局是在第几步结束的。 当然，也有可能他们最终仍然没有分出胜负，这时请判定他们平局。 五子棋的胜利条件是这样的：当同一行或同一列或同一斜线（即与网格线成 45° 角的直线）上连续的五个或五个以上交叉点放有同色棋子的时候，立即判定使用该颜色棋子的玩家获得胜利，游戏结束。 输入格式第一行输入一个正整数 n，表示双方总共下了多少步棋。 接下来 n 行，每行两个正整数。其中，第 i 行的两个数 x,y 表示第 i 步的棋子下在了第 x 条横线和第 y 条竖线的交叉点上。若 i 为奇数，则这个棋子是黑棋，否则是白棋。 输出格式若没有人获得胜利，你需要输出“Tie”（不含引号）。 否则，若小 A 获胜，输出 “A”（不含引号），若小 B 获胜，输出 “B”（不含引号）；并输出一个正整数 w 表示第 w 步下完后游戏应当结束，字母与整数间用一个空格隔开。 数据范围对于 20% 的数据，游戏结果是平局。对于 30% 的数据，游戏在最后一手结束。对于 100% 的数据，0≤n≤225，1≤x,y≤150≤n≤225，1≤x,y≤15。 输入样例：1234567891091 12 11 22 21 32 31 42 41 5 输出样例：1A 9 题目分析：题目要求：题目意思就是在一个15 x 15 的棋盘下棋，要你求出谁最后赢了，并且是在下第几课棋子时赢的！ 解题思路： 当然还是要下一步棋子，就判断一下是否有人胜利！ 方法就是要在下棋子的地方展开，如果下了这步棋子，胜利了，那么最后的结果必有这一个棋子，所以从这里展开！ 有四个方向可能五子连珠：横向，竖向，以及两个斜向！ 所以直接扫描四个方向即可！ 五子连珠条件：一个方向的正反向相加再加1大于等于5即可！ 题解：由于一个方向的正反完全可以由正或反乘以-1得到，所以只需记录八个方向的相连的四个方向即可。本人用dx 和 dy数组记录。 先后手判断奇偶数即可。 arr 为 0 表示空，为1表示先手，为2表示后手。 win 为 0 表示平局，1表示先手赢，2表示后手赢。 flag 标记是否五子连珠，step 表示胜利时的步数。 需注意越界条件和下一个棋子是否是本方棋色。 一个方向的正向就是+该变量，反向就是-该变量！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;iostream&gt; #include &lt;algorithm&gt;using namespace std;int n;int arr[20][20];// 1 先手 2 后手 int main(){ cin &gt;&gt; n; // 四个方向：下、右下、右、右上 int dx[4] = {1, 1, 0, -1}; int dy[4] = {0, 1, 1, 1}; int step, win = 0;//先手为1，后手为2 for(int i = 1; i &lt;= n; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; if(i % 2) arr[x][y] = 1; else arr[x][y] = 2; bool flag = false; // 判断四个方向 for(int j = 0; j &lt; 4; j++) { int a = 0, b = 0;//一个方向的正反 记录该方向可走的步数 // 正向 while(true) { int tx = x + (a + 1) * dx[j]; int ty = y + (a + 1) * dy[j]; if(tx &lt; 1 || tx &gt; 15 || ty &lt; 1 || ty &gt; 15) break;//越界 if(arr[x][y] != arr[tx][ty]) break;//棋子颜色不同 a++;//正方向++ } // 反向 while(true) { int tx = x - (b + 1) * dx[j]; int ty = y - (b + 1) * dy[j]; if(tx &lt; 1 || tx &gt; 15 || ty &lt; 1 || ty &gt; 15) break;//越界 if(arr[x][y] != arr[tx][ty]) break;//棋子颜色不同 b++;//反方向++ } if(a + b + 1 &gt;= 5) { flag = true; break; } } if(flag) { win = arr[x][y]; step = i; break; } } if(win == 0) cout &lt;&lt; \"Tie\" &lt;&lt; endl; else if(win == 1) printf(\"A %d\\n\", step); else printf(\"B %d\\n\", step); return 0;} 欢迎访问！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"模拟","slug":"模拟","permalink":"https://niuxvdong.top/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"人一生需要花多少钱","slug":"人一生需要花多少钱","date":"2020-02-24T03:25:05.000Z","updated":"2020-02-24T03:25:05.000Z","comments":true,"path":"posts/42468.html","link":"","permalink":"https://niuxvdong.top/posts/42468.html","excerpt":"","text":"一首歌曲送上 我们都是语言的巨人，行动的矮子！ 分享偶然看到的四张图： 看到图后，我想了很多，当然是乐观的想，本人并不是那种悲观的人！ 人一生花费的钱有这么多，现在不努力更待何时！ 每天努力一点点，不要管于你无关的事情！ 又想到了自己博客首页的座右铭： 你现在的努力，是为了以后有更多的选择！ 一则启示：俄罗斯方块告诉我们，合群跟随大众，随波逐流，我们就会消失，变得没有自我 。贪吃蛇告诉我们，不断的吸收负能量，不断的懒惰，害死我们的终究是自己 。愤怒的小鸟告诉我们，嘲笑我们的终究没有我们具有选择性，他们只有嘲笑的能力而我们具有打败别人的能力，变成猪的人类也只会嘲笑努力的人。 其实自律很简单：其实自律很简单，需要认清自己，再朝一个方向去行动。刚开始要给自己时间去适应，慢慢的慢慢的你就会习惯成自然。也不要刻意的强求自己定要做什么什么然后没做成而感到懊恼，在努力的过程中需要付出很多心血和汗水不要放弃、不要悲伤。终有一天你的目标会开花结果。不要每天看一些励志视频就为自己打一针鸡血，努力一下又开始堕落、迷茫。加油陌生人，一起朝着梦想努力[打call][打call][打call] 成为自己想成为的人：我一点也不聪明 我必须很努力的学才能达到和同龄人同样的成绩 优秀的人太多 很多人轻轻松松就能获得我努力了很久才能换来的成果 甚至我拼尽全力也得不来的成果 心里当然不是滋味 但我不羡慕 没有人的成功是空穴来风的 他们能做到轻而易举 那是因为他们已经默默付出了很多 而我只看到了表面 我要做的就是做好我自己 我慢慢来 一步一步来 总是可以的 因为我喜欢的 想干的事太多了 我想成为自己喜欢的人 一则视频送给努力的你们！ 最后送上四十句话：第一：我有我要赶去的远方，哪怕风雨兼程披星戴月。 第二：一棵树的树冠越是向往高处的太阳，它的跟越是得深入黑暗的地底。 第三：你不能要求一个没有风暴的海洋。那不是海，是泥塘。 第四：没有一个冬天不可跨越，也没有一个春天不会来临。 第五：先努力让自己发光，对的人才能迎着光而来。 第六：你那么憎恨的人，和他们斗了那么久。最终却要变得和他们一样。人世间没有任何理想值得以这样的沉沦作为代价。 第七：觉得为时已晚的时候恰恰是最早的时候。 第八：你走的每一步，都藏着未来的影子。 第九：要变优秀，堵住那悠悠众口。 第十：那一天，我也曾看到花团锦簇。那一夜，我也曾梦见百万雄兵。 第十一：你背单词时，阿拉斯加的鳕鱼正跃出水面；你算数学时，太平洋彼岸的海鸥振翅掠过城市上空；你晚自习时，极图中的夜空散漫了五彩斑斓。但是少年你别着急，在你为自己未来踏踏实实地努力时，那些你感觉从来不会看到的景色，那些你觉得终身不会遇到的人，正一步步向你走来。 第十二：我要和生活再死磕几年，要么我就毁灭，要么我就注定铸就辉煌。 第十三：在隆冬，我终于知道，在我身上有一个不可战胜的夏天。 第十四：他们试图把你埋了，但你要记得，你是种子。 第十五：要偷偷努力，希望自己也能成为别人的梦想。 第十六：一生中总会遇到这样的时候，你的内心已经兵荒马乱天翻地覆了，可是在别人看来你只是比平时沉默了一点，没人会觉得奇怪，这种战争，注定单枪匹马。 第十七：既然我找不到你，只好站在显眼的地方让你找到了。 第十八：这是个第一人称的世界，现在开始有我来论证这一切。 第十九：即使身在井隅，也仍然有仰望星空的权利。况且，我们生而闪耀，又何必活在别人的阴影里。 第二十：天行健，君子以自强不息。 第二十一：人世间有一种庸俗势力的大合唱。谁一旦对它屈服，就永远沉沦了。 第二十二：谁将声震人间，必长久深自缄默。谁将点燃闪电，必长久如云漂泊。 第二十三：所谓无底深渊，下去，也是前程万里。 第二十四：从来不是让你把一次考试当成人生的赌注，只是想让你在足够年轻的时候体会一次全力以赴。 第二十五：但凡不能杀死你的，最终都会使你更强大。 第二十六：生前何必久睡，死后自会长眠。 第二十七：你终究会成为你正在成为的人。 第二十八：我要悄悄拔尖，然后惊艳所有人。 第二十九：因为，我喜欢的东西很贵，想去的地方很远，喜欢的人很优秀。 第三十：不恨古人吾不见，恨古人不见吾狂尔。 等三十一：待到秋来九月八，我花开后百花杀。 第三十二：春来我不先张口，哪个虫儿干作声。 第三十三：大鹏一日同风起，扶摇直上九万里。 第三十四：想当年，金戈铁马，气吞万里如虎。 第三十五：仙路尽头谁为峰，一见无始道成空。 第三十六：海到无边天做岸，山登绝顶我为峰。 第三十七：窥尽阴阳理，易掌定乾坤。 第三十八：春风得意马蹄疾，一夜看尽长安花。 第三十九：他年若有凌云日，敢笑黄巢不丈夫。 第四十：俱往矣，数风流人物，还看今朝。 现在根本不晚，站起来奋斗吧！ 加油吧！骚年们！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"随笔","slug":"随笔","permalink":"https://niuxvdong.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"努力","slug":"努力","permalink":"https://niuxvdong.top/tags/%E5%8A%AA%E5%8A%9B/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之面向浏览器","slug":"JavaScript教程系列之面向浏览器","date":"2020-02-19T11:20:35.000Z","updated":"2020-02-19T11:20:35.000Z","comments":true,"path":"posts/57030.html","link":"","permalink":"https://niuxvdong.top/posts/57030.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、浏览器对象(BOM) BOM是一套操作浏览器的API（接口/方法/属性） 常见的BOM对象： window：代表整个浏览器窗口（window是BOM中的一个对象，并且是顶级的对象） Navigator ：代表浏览器当前的信息，通过Navigator我们可以获取用户当前使用的是什么浏览器 Location： 代表浏览器当前的地址信息，通过Location我们可以获取或者设置当前的地址信息 History：代表浏览器的历史信息，通过History我们可以实现上一步/刷新/下一步操作（出于对用户的隐私考虑，我们只能拿到当前的浏览记录，不能拿到所有的历史记录） Screen：代表用户的屏幕信息 1、window对象 window对象不但充当全局作用域，而且表示浏览器窗口。 还记得之前的什么alert，console啥的没，那都是全局对象window的属性或者成员！ window对象的成员加不加window都一样，不加默认就是window！ innerWidth 和 innerHeight 获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。(当然：包括滚动条) 简而言之就是网页部分的尺寸！ 当然他会随网页大小而改变： 123console.log('window inner size: ' + innerWidth + ' x ' + innerHeight);// 一样的效果：console.log('window inner size: ' + window.innerWidth + ' x ' + window.innerHeight); 效果如下： outerWidth 和 outerHeight 获取浏览器窗口的整个宽高。 计算的是浏览器，而不是网页。 也是随浏览器大小而改变的！ 12console.log('window outersize: ' + window.outerWidth+ ' x ' + window.outerHeight);// window outersize: 1536 x 864 2、navigator对象 navigator对象表示浏览器的信息，获取浏览器信息 常见属性： navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型；（不是你的电脑系统！） navigator.userAgent：浏览器设定的User-Agent字符串。 12345console.log('appName = ' + navigator.appName);console.log('appVersion = ' + navigator.appVersion);console.log('language = ' + navigator.language);console.log('platform = ' + navigator.platform);console.log('userAgent = ' + navigator.userAgent); 效果如下： 3、screen对象 screen对象用来获取屏幕的信息！ 常用属性： screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。 1234console.log('Screen size = ' + screen.width + ' x ' + screen.height);console.log('colorDepth = ' + screen.colorDepth );// Screen size = 1536 x 864// colorDepth = 24 4、location对象 location对象表示当前页面的URL信息！ 常用属性： 123456789101112http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOPlocation.href;//http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOPlocation.protocol; // 'http'location.host; // 'www.example.com'location.port; // '8080'location.pathname; // '/path/index.html'location.search; // '?a=1&amp;b=2'location.hash; // 'TOP'window.location.href; //获取当前地址栏的地址window.location.href = “http://www.baidu.com”; // 设置当前地址栏的地址 刷新和强制刷新（Ctrl + F5）: 123window.location.reload(); //刷新window.location.reload(true); //强制刷新window.location.assign('/'); // 设置一个新的URL地址 5、document对象 document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。 其独特之处是唯一一个既属于BOM又属于DOM的对象！ document.title：改变title标签的属性 1document.title = '努力学习JavaScript!'; getElementById()和getElementsByTagName() 通过id获取和通过标签获取！ 12var menu = document.getElementById('drink-menu');var drinks = document.getElementsByTagName('dt'); document.cookie document对象还有一个cookie属性，可以获取当前页面的Cookie。 1document.cookie; // 'v=123; remember=true; prefer=zh' 6、history对象 history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。 这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。 新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。 任何情况，你都不应该使用history这个对象了。 12345window.history.forword(); //上一步 window.history.back(); //下一步 window.history.go(0); //接收参数 0 表示刷新当前页面 window.history.go(2); //接收正整数 表示前进2个页面 window.history.go(-2); //接收负整数 表示后退2个页面 二、操作DOM DOM是一套操作标签的API（接口/方法/属性） 由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。 始终记住DOM是一个树形结构。 DOM的基本操作： 更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容； 遍历：遍历该DOM节点下的子节点，以便进行进一步操作； 添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点； 删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。 1、获取DOM节点 document.getElementById()：通过id获取 document.getElementsByTagName()：通过标签获取 document.getElementsByClassName()：通过class获取 注意：通过id获取是唯一的，通过标签和class获取的是一组DOM节点 1.1 可以通过先定位父节点再来定位子节点来进行唯一确定！123456789101112131415// 返回ID为'test'的节点：var test = document.getElementById('test');// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：var trs = document.getElementById('test-table').getElementsByTagName('tr');// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：var reds = document.getElementById('test-div').getElementsByClassName('red');// 获取节点test下的所有直属子节点:var cs = test.children;// 获取节点test下第一个、最后一个子节点：var first = test.firstElementChild;var last = test.lastElementChild; 1.2 通过 querySelector() 和 querySelectorAll() 获取12345// 通过querySelector获取ID为q1的节点：var q1 = document.querySelector('#q1');// 通过querySelectorAll获取q1节点内的符合条件的所有节点：var ps = q1.querySelectorAll('div.highlighted &gt; p'); 1.3 一道简单测试题：题目背景： 12345678910111213141516&lt;!-- HTML结构 --&gt;&lt;div id=\"test-div\"&gt; &lt;div class=\"c-red\"&gt; &lt;p id=\"test-p\"&gt;JavaScript&lt;/p&gt; &lt;p&gt;Java&lt;/p&gt; &lt;/div&gt; &lt;div class=\"c-red c-green\"&gt; &lt;p&gt;Python&lt;/p&gt; &lt;p&gt;Ruby&lt;/p&gt; &lt;p&gt;Swift&lt;/p&gt; &lt;/div&gt; &lt;div class=\"c-green\"&gt; &lt;p&gt;Scheme&lt;/p&gt; &lt;p&gt;Haskell&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 选择指定项： 1234567891011121314151617181920212223242526272829// 1、选择&lt;p&gt;JavaScript&lt;/p&gt;:var js = document.getElementById('test-p');// 2、选择&lt;p&gt;Python&lt;/p&gt;,&lt;p&gt;Ruby&lt;/p&gt;,&lt;p&gt;Swift&lt;/p&gt;:// 2.1 分开写：var arr = document.querySelector('div[class = \"c-red c-green\"]').querySelectorAll('p');// 2.2 合并写：var arr = document.querySelectorAll('div[class = \"c-red c-green\"] &gt; p');// 2.3 另一种写法：var arr = document.querySelectorAll('.c-red.c-green p');// 2.4 另一种：var arr = document.getElementsByClassName('c-red')[1].children;// 3、选择&lt;p&gt;Haskell&lt;/p&gt;:// 3.1 用数组序号获取元素：var haskell = document.querySelectorAll('div[class = \"c-green\"] &gt; p')[1];// 3.2 另一种写法：var haskell = document.querySelector('.c-green:not(.c-red)').lastElementChild;// 测试:if (!js || js.innerText !== 'JavaScript') { alert('选择JavaScript失败!');} else if (!arr || arr.length !== 3 || !arr[0] || !arr[1] || !arr[2] || arr[0].innerText !== 'Python' || arr[1].innerText !== 'Ruby' || arr[2].innerText !== 'Swift') { console.log('选择Python,Ruby,Swift失败!');} else if (!haskell || haskell.innerText !== 'Haskell') { console.log('选择Haskell失败!');} else { console.log('测试通过!');} 2、更新DOM节点 用来直接修改节点的文本！ 2.1 innerHTML属性 可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树： 通过innerHTML属性，原内容已经被覆盖！ 1、可以传入普通内容 2、也可以传入标签，标签会直接被解析为HTML内容！ 1234567891011&lt;p id=\"my-p\"&gt;...&lt;/p&gt;&lt;script&gt; // 获取&lt;p id=\"p-id\"&gt;...&lt;/p&gt; let p1 = document.getElementById('my-p'); // 设置文本为abc: p1.innerHTML = 'cde'; // &lt;p id=\"p-id\"&gt;ABC&lt;/p&gt; // 设置HTML: p1.innerHTML = 'ABC &lt;span style=\"color:red\"&gt;RED&lt;/span&gt; XYZ'; // &lt;p&gt;...&lt;/p&gt;的内部结构已修改&lt;/script&gt; 2.2 innerText属性 属性中无法传入html标签，若传入，则会直接被解析为文本显示！不是解析为HTML标签！ 12345678&lt;p id=\"my-p\"&gt;...&lt;/p&gt;&lt;script&gt; // 获取&lt;p id=\"p-id\"&gt;...&lt;/p&gt; var p = document.getElementById('my-p'); // 设置文本: p.innerText = '&lt;span&gt;hhhhh&lt;/span&gt;';&lt;/script&gt; 特殊点： 无法正常显示script标签： 12345678910&lt;p id=\"p-id\"&gt;hello&lt;/p&gt;&lt;script&gt; var p = document.getElementById('p-id'); // 设置文本:此句无法正常显示 p.innerText = '&lt;script&gt;alert(\"Hi\")&lt;/script&gt;'; // HTML被自动编码，无法设置一个&lt;script&gt;节点:&lt;/script&gt;// 正常显示方法：&lt;p id=\"p-id\"&gt;&amp;lt;script&amp;gt;alert(\"Hi\")&amp;lt;/script&amp;gt;&lt;/p&gt; 2.3 textContent属性 两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本 作用和 innerText 一样！ 123456789&lt;p id=\"my-p\"&gt;...&lt;/p&gt;&lt;script&gt; // 获取&lt;p id=\"p-id\"&gt;...&lt;/p&gt; var p = document.getElementById('my-p'); // 设置文本: p.textContent = '&lt;span&gt;hhhhh&lt;/span&gt;';&lt;/script&gt; 2.4 style属性 DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize： CSS 的属性带有- 的都变为驼峰命名法！ 123456// 获取&lt;p id=\"p-id\"&gt;...&lt;/p&gt;var p = document.getElementById('p-id');// 设置CSS:p.style.color = '#ff0000';p.style.fontSize = '20px';p.style.paddingTop = '2em'; 3、插入DOM节点 如果这个DOM节点是空的，例如，&lt;div&gt;&lt;/div&gt;，那么，直接使用innerHTML = 'child'就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。 如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点。 方法一：使用 appendChild 把一个子节点添加到父节点的最后一个子节点 首先会从原先的位置删除，再插入到新的位置。 123456789101112&lt;!-- HTML结构 --&gt;&lt;p id=\"js\"&gt;JavaScript&lt;/p&gt;&lt;div id=\"list\"&gt; &lt;p id=\"java\"&gt;Java&lt;/p&gt; &lt;p id=\"python\"&gt;Python&lt;/p&gt; &lt;p id=\"scheme\"&gt;Scheme&lt;/p&gt;&lt;/div&gt;// JavaScript代码var js = document.getElementById('js'), list = document.getElementById('list');list.appendChild(js); 最终结果： 1234567&lt;!-- HTML结构 --&gt;&lt;div id=\"list\"&gt; &lt;p id=\"java\"&gt;Java&lt;/p&gt; &lt;p id=\"python\"&gt;Python&lt;/p&gt; &lt;p id=\"scheme\"&gt;Scheme&lt;/p&gt; &lt;p id=\"js\"&gt;JavaScript&lt;/p&gt;&lt;/div&gt; 一个例子：打开谷歌控制台，将下面代码复制到任意个网页，观看网页CSS变化！ 1234var d = document.createElement('style');d.setAttribute('type', 'text/css');d.innerHTML = 'p { color: red }';document.getElementsByTagName('head')[0].appendChild(d); 如下，会发现多了一行CSS，而网页只要是p标签都会被修改颜色！ 方法二：使用 insertBefore 可将子节点插入到指定位置！ 可以使用parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前。 123456789101112131415&lt;!-- HTML结构 --&gt;&lt;div id=\"list\"&gt; &lt;p id=\"java\"&gt;Java&lt;/p&gt; &lt;p id=\"python\"&gt;Python&lt;/p&gt; &lt;p id=\"scheme\"&gt;Scheme&lt;/p&gt;&lt;/div&gt;var list = document.getElementById('list'), ref = document.getElementById('python'), haskell = document.createElement('p');haskell.id = 'haskell';haskell.innerText = 'Haskell';// 将新建的p标签（haskell）插入到ref的前面list.insertBefore(haskell, ref); 效果如下： 1234567&lt;!-- HTML结构 --&gt;&lt;div id=\"list\"&gt; &lt;p id=\"java\"&gt;Java&lt;/p&gt; &lt;p id=\"haskell\"&gt;Haskell&lt;/p&gt; &lt;p id=\"python\"&gt;Python&lt;/p&gt; &lt;p id=\"scheme\"&gt;Scheme&lt;/p&gt;&lt;/div&gt; 使用 children 属性来遍历 遍历一个父节点的所有子节点！ 123456var i, c, list = document.getElementById('list');for (i = 0; i &lt; list.children.length; i++) { c = list.children[i]; // 拿到第i个子节点} 4、删除DOM 要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉： 注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 1234567// 拿到待删除节点:var self = document.getElementById('to-be-removed');// 拿到父节点:var parent = self.parentElement;// 删除:var removed = parent.removeChild(self);removed === self; // true 当你遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。 12345678&lt;div id=\"parent\"&gt; &lt;p&gt;First&lt;/p&gt; &lt;p&gt;Second&lt;/p&gt;&lt;/div&gt;var parent = document.getElementById('parent');parent.removeChild(parent.children[0]);parent.removeChild(parent.children[1]); // &lt;-- 浏览器报错 三、操作表单表单类型主要有以下几种： 文本框，对应的&lt;input type=\"text\"&gt;，用于输入文本； 口令框，对应的&lt;input type=\"password\"&gt;，用于输入口令； 单选框，对应的&lt;input type=\"radio\"&gt;，用于选择一项； 复选框，对应的&lt;input type=\"checkbox\"&gt;，用于选择多项； 下拉框，对应的&lt;input type=\"select\"&gt;，用于选择一项； 隐藏文本，对应的&lt;input type=\"hidden\"&gt;，用户不可见，但表单提交时会把隐藏文本发送到服务器。 1、获取值 如果我们获得了一个&lt;input&gt;节点的引用，就可以直接调用value获得对应的用户输入值： 123// &lt;input type=\"text\" id=\"email\"&gt;var input = document.getElementById('email');input.value; // '用户输入的值' 这种方式可以应用于text、password、hidden以及select。 但是，对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断： 12345678// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"monday\" value=\"1\"&gt; Monday&lt;/label&gt;// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"tuesday\" value=\"2\"&gt; Tuesday&lt;/label&gt;var mon = document.getElementById('monday');var tue = document.getElementById('tuesday');mon.value; // '1'tue.value; // '2'mon.checked; // true或者falsetue.checked; // true或者false 2、设置值 设置值和获取值类似，对于text、password、hidden以及select，直接设置value就可以： 123// &lt;input type=\"text\" id=\"email\"&gt;var input = document.getElementById('email');input.value = 'test@example.com'; // 文本框的内容已更新 对于单选框和复选框，设置checked为true或false即可。 123456// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"monday\" value=\"1\"&gt; Monday&lt;/label&gt;// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"tuesday\" value=\"2\"&gt; Tuesday&lt;/label&gt;var mon = document.getElementById('monday');var tue = document.getElementById('tuesday');mon.checked = true; // true或者falsetue.checked = false; // true或者false 3、HTML5控件 HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用``标签： 具体效果自己试一下！ 123&lt;input type=\"date\" value=\"2015-07-01\"&gt;&lt;input type=\"datetime-local\" value=\"2015-07-01T02:03:04\"&gt;&lt;input type=\"color\" value=\"#ff0000\"&gt; 3、提交表单 JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。 通过绑定submit()方法实现： 这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击``时提交表单，或者用户在最后一个输入框按回车键！ 1234567891011121314&lt;!-- HTML --&gt;&lt;form id=\"test-form\"&gt; &lt;input type=\"text\" name=\"test\"&gt; &lt;button type=\"button\" onclick=\"doSubmitForm()\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function doSubmitForm() { var form = document.getElementById('test-form'); // 可以在此修改form的input... // 提交form: form.submit();}&lt;/script&gt; 通过form本身的onsubmit事件 注意要return true来告诉浏览器继续提交，如果return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。 在检查和修改时，要充分利用来传递数据。 1234567891011121314&lt;!-- HTML --&gt;&lt;form id=\"test-form\" onsubmit=\"return checkForm()\"&gt; &lt;input type=\"text\" name=\"test\"&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() { var form = document.getElementById('test-form'); // 可以在此修改form的input... // 继续下一步: return true;}&lt;/script&gt; 关于MD5 安全考虑，提交表单时不传输明文口令，而是口令的MD5 这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个*变成32个*（因为MD5有32个字符）。 12345678910111213141516&lt;!-- HTML --&gt;&lt;form id=\"login-form\" method=\"post\" onsubmit=\"return checkForm()\"&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;input type=\"password\" id=\"password\" name=\"password\"&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() { var pwd = document.getElementById('password'); // 把用户输入的明文变为MD5: pwd.value = toMD5(pwd.value); // 继续下一步: return true;}&lt;/script&gt; 利用&lt;input type=\"hidden\"&gt;实现： 可以实现不改变用户的输入！ 注意到id为md5-password的标记了`name=\"password\"`，而用户输入的`id`为`input-password`的没有name属性。没有name属性的``的数据不会被提交。 123456789101112131415161718&lt;!-- HTML --&gt;&lt;form id=\"login-form\" method=\"post\" onsubmit=\"return checkForm()\"&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;input type=\"password\" id=\"input-password\"&gt; &lt;input type=\"hidden\" id=\"md5-password\" name=\"password\"&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() { var input_pwd = document.getElementById('input-password'); var md5_pwd = document.getElementById('md5-password'); // 把用户输入的明文变为MD5: md5_pwd.value = toMD5(input_pwd.value); // 继续下一步: return true;}&lt;/script&gt; 4、一个例子利用JavaScript检查用户注册信息是否正确，在以下情况不满足时报错并阻止提交表单： 用户名必须是3-10位英文字母或数字； 口令必须是6-20位； 两次输入口令必须一致。 12345678910111213141516&lt;!-- HTML结构 --&gt;&lt;form id=\"test-register\" action=\"#\" target=\"_blank\" onsubmit=\"return checkRegisterForm()\"&gt; &lt;p id=\"test-error\" style=\"color:red\"&gt;&lt;/p&gt; &lt;p&gt; 用户名: &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;/p&gt; &lt;p&gt; 口令: &lt;input type=\"password\" id=\"password\" name=\"password\"&gt; &lt;/p&gt; &lt;p&gt; 重复口令: &lt;input type=\"password\" id=\"password-2\"&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt; &lt;button type=\"reset\"&gt;重置&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233&lt;script&gt; var checkRegisterForm = function () { let re1 = /^\\w{3,10}$/; re2 = /^.{6,20}$/; user = document.getElementById('username'); pwd = document.getElementById('password'); pwd2 = document.getElementById('password-2'); if ( re1.test(user.value) &amp;&amp; re2.test(pwd.value) &amp;&amp; pwd.value === pwd2.value ) { return true; } else { return false; } return false; } // 测试: ;(function () { window.testFormHandler = checkRegisterForm; var form = document.getElementById('test-register'); if (form.dispatchEvent) { var event = new Event('submit', { bubbles: true, cancelable: true }); form.dispatchEvent(event); } else { form.fireEvent('onsubmit'); } })();&lt;/script&gt; 四、操作文件 在HTML表单中，可以上传文件的唯一控件就是&lt;input type=\"file\"&gt;。 注意：当一个表单包含&lt;input type=\"file\"&gt;时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。 出于安全考虑，浏览器只允许用户点击&lt;input type=\"file\"&gt;来选择本地文件，用JavaScript对&lt;input type=\"file\"&gt;的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径： 通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件： 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022494381696#0 补充教程：https://www.w3school.com.cn/jsref/event_onchange.asp 目前一脸懵逼，以后再细看把！ 123456var f = document.getElementById('test-file-upload');var filename = f.value; // 'C:\\fakepath\\test.png'if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) { alert('Can only upload image file.'); return false;} File API 由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。 随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。 HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。 下面的例子演示了如何读取用户选取的图片文件，并在一个``中预览图像： 可以自己编一下看看效果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt; &lt;title&gt;文件api&lt;/title&gt; &lt;style&gt; #test-image-preview { width:500px; height:500px; border:1px solid #ff0000; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; &lt;div id=\"test-file-info\"&gt;&lt;/div&gt; &lt;div id=\"test-image-preview\"&gt;&lt;/div&gt; &lt;input id=\"test-image-file\" type=\"file\"&gt;&lt;/form&gt;&lt;script &gt; window.onload=function(){ var fileInput = document.getElementById('test-image-file'); var info = document.getElementById('test-file-info'); var preview = document.getElementById('test-image-preview'); fileInput.addEventListener('change',function(){ console.log('change...'); preview.style.backgroundImage=''; if (!fileInput.value){ info.innerHTML = '没有选择文件'; return ; } var file = fileInput.files[0]; info.innerHTML = '文件:' + file.name + '&lt;br&gt;'+'大小:'+file.size+'&lt;br&gt;'+'修改:'+file.lastModifiedDate; if(file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif'){ alert('不是有效的图片文件!'); return; } var reader = new FileReader(); reader.onload=function(e){ console.log('reader.onload'); var data = e.target.result;// 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage='url('+ data +')'; }; reader.readAsDataURL(file); }); };&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...，常用于设置图像。如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。 五、AJAX1、AJAX 的起源 AJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。 如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。 这就是Web的运作原理：一次HTTP请求对应一个页面。 如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。 最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。 用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 2、编写AJAX 通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest。注意，不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性，一是因为这个字符串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。 当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。 XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。 注意，千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。 最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象： 1234567891011121314151617181920212223242526272829303132function success(text) { var textarea = document.getElementById('test-response-text'); textarea.value = text;}function fail(code) { var textarea = document.getElementById('test-response-text'); textarea.value = 'Error code: ' + code;}var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象request.onreadystatechange = function () { // 状态发生变化时，函数被回调 if (request.readyState === 4) { // 成功完成 // 判断响应结果: if (request.status === 200) { // 成功，通过responseText拿到响应的文本: return success(request.responseText); } else { // 失败，根据响应码判断失败原因: return fail(request.status); } } else { // HTTP请求还在继续... }}// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); 对于低版本的IE，需要换一个ActiveXObject对象： 1234567891011121314151617181920212223242526272829303132function success(text) { var textarea = document.getElementById('test-ie-response-text'); textarea.value = text;}function fail(code) { var textarea = document.getElementById('test-ie-response-text'); textarea.value = 'Error code: ' + code;}var request = new ActiveXObject('Microsoft.XMLHTTP'); // 新建Microsoft.XMLHTTP对象request.onreadystatechange = function () { // 状态发生变化时，函数被回调 if (request.readyState === 4) { // 成功完成 // 判断响应结果: if (request.status === 200) { // 成功，通过responseText拿到响应的文本: return success(request.responseText); } else { // 失败，根据响应码判断失败原因: return fail(request.status); } } else { // HTTP请求还在继续... }}// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); 3、安全限制 有点看不懂了！ 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400#0 4、CORS 有点看不懂了！ 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400#0 六、Promise 有点看不懂了！ 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544 七、Canvas以后再看吧！ 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022423592576 目前告一段落了！以后有机会再进行 JavaScript 的学习！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://niuxvdong.top/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://niuxvdong.top/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://niuxvdong.top/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"https://niuxvdong.top/tags/DOM/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之面向对象编程","slug":"JavaScript教程系列之面向对象编程","date":"2020-02-17T14:17:37.000Z","updated":"2020-02-17T14:17:37.000Z","comments":true,"path":"posts/55519.html","link":"","permalink":"https://niuxvdong.top/posts/55519.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 有人这样说：这种高大上的东西都是造火箭才用得上的，平时干的都是拧螺丝的活当然用不上咯！ 但还是得知道并掌握。。。。！ class继承需要掌握，原型继承知道就好了…… 一、面向对象编程概述 JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。 1、通过__proto__ 来指向Student，并且继承Student的所有属性！ JavaScript它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。 12345678910111213141516var Student = { name: 'Robot', height: 1.2, run: function () { console.log(this.name + ' is running...'); }};var xiaoming = { name: '小明'};xiaoming.__proto__ = Student;xiaoming.name; // '小明'xiaoming.run(); // 小明 is running... 2、指向（原型）是可以改变的！ 在指向一个类后，可以直接修改他的指向（原型）！ 123456789101112var Bird = { fly: function () { console.log(this.name + ' is flying...'); }};var xiaoming = { name: '小明'};xiaoming.__proto__ = Bird;xiaoming.fly(); // 小明 is flying... 注意：不建议使用`__proto__`来改变指向 3、要使用Object.create()方法 该方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有 为了方便，可以创建一个函数来接收姓名参数，在函数内部做一下赋值的过程即可！ 12345678910111213141516171819202122// 原型对象:var Student = { name: 'Robot', height: 1.2, run: function () { console.log(this.name + ' is running...'); }};function createStudent(name) { // 基于Student原型创建一个新对象: var s = Object.create(Student); // 初始化新对象: s.name = name; return s;}//直接创建是没有属性“小明”的：let xiaoming = Object.create(Student);//通过新建函数，传入名字，即可：var xiaoming = createStudent('小明');xiaoming.run(); // 小明 is running...xiaoming.__proto__ === Student; // true 二、关于proto和prototype prototype是函数的一个属性（每个函数都有一个prototype属性），这个属性是一个指针，指向一个对象。它是显示修改对象的原型的属性。 __proto__是一个对象拥有的内置属性（请注意：prototype是函数的内置属性，__proto__是对象的内置属性），是JS内部使用寻找原型链的属性。 区别参考链接：https://www.cnblogs.com/yangjinjin/archive/2013/02/01/2889103.html 三、创建对象 为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写. 这样，一些语法检查工具如jslint将可以帮你检测到漏写的new。 本节参考：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022043494624 1、原型链 当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。 数组原型链 Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。 12var arr = [1, 2, 3];arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null 函数原型链 Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。 1234function foo() { return 0;}foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null 2、构造函数 用new来调用函数，返回一个对象！ 函数内部的this指向新创建的对象！并默认返回this!不需要写return了！ 必须写new，不写new，函数返回的是undefined！ 12345678910function Student(name) { this.name = name; this.hello = function () { alert('Hello, ' + this.name + '!'); }}var xiaoming = new Student('小明');xiaoming.name; // '小明'xiaoming.hello(); // Hello, 小明! 此时小明的原型链： 1xiaoming ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null 3、constructor 用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身： 123456xiaoming.constructor === Student.prototype.constructor; // trueStudent.prototype.constructor === Student; // trueObject.getPrototypeOf(xiaoming) === Student.prototype; // truexiaoming instanceof Student; // true 4、公用函数（共享方法） 如果我们通过new Student()创建了很多对象，这些对象的hello函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。 通过够着函数.prototype.函数名来创建公用函数，节省内存！ 1234567function Student(name) { this.name = name;}Student.prototype.hello = function () { alert('Hello, ' + this.name + '!');}; 5、解决忘写new的方法 我们还可以编写一个createStudent()函数，在内部封装所有的new操作。 || ：用或符号来实现默认值，毕竟是就近原则的！ 将new封装后，即可不用写new了，以防忘写！ 123456789101112function Student(props) { this.name = props.name || '匿名'; // 默认值为'匿名' this.grade = props.grade || 1; // 默认值为1}Student.prototype.hello = function () { alert('Hello, ' + this.name + '!');};function createStudent(props) { return new Student(props || {})} 不传参都行 也可以这样定义 这样传参传的是一个对象，是不需要顺序的！ 12345var xiaoming = createStudent({ name: '小明'});xiaoming.grade; // 1 四、原型继承 本节参考：https://www.liaoxuefeng.com/wiki/1022910821149312/1023021997355072 原型链： 1new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null 我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： F空函数起到一个桥接的作用！ 123456789101112131415161718192021222324252627282930313233343536373839// PrimaryStudent构造函数:function PrimaryStudent(props) { Student.call(this, props); this.grade = props.grade || 1;}// 空函数F:function F() {}// 把F的原型指向Student.prototype:F.prototype = Student.prototype;// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:PrimaryStudent.prototype = new F();// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:PrimaryStudent.prototype.constructor = PrimaryStudent;// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：PrimaryStudent.prototype.getGrade = function () { return this.grade;};// 创建xiaoming:var xiaoming = new PrimaryStudent({ name: '小明', grade: 2});xiaoming.name; // '小明'xiaoming.grade; // 2// 验证原型:xiaoming.__proto__ === PrimaryStudent.prototype; // truexiaoming.__proto__.__proto__ === Student.prototype; // true// 验证继承关系:xiaoming instanceof PrimaryStudent; // truexiaoming instanceof Student; // true 关于call()函数：https://www.runoob.com/w3cnote/js-call-apply-bind.html 是用来重定义 this 这个对象的! 五、class继承 在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。 有没有更简单的写法？有！ 新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。 用class来写，上面章节中的继承和对象编程就简单多了！ constructor很明显是够着函数！ 注意没有function关键字！ 1234567891011class Student { constructor(name) { this.name = name; } hello() { alert('Hello, ' + this.name + '!'); }}var xiaoming = new Student('小明');xiaoming.hello(); class继承 用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现： extends表示原型链对象来自Student！ 使用super()函数来调用父类的（即Student）的构造方法！ class继承和原型继承没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。 12345678910class PrimaryStudent extends Student { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert('I am at grade ' + this.grade); }} 本章节到此结束，敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://niuxvdong.top/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://niuxvdong.top/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"https://niuxvdong.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之标准对象","slug":"JavaScript教程系列之标准对象","date":"2020-02-17T07:31:19.000Z","updated":"2020-02-17T07:31:19.000Z","comments":true,"path":"posts/15769.html","link":"","permalink":"https://niuxvdong.top/posts/15769.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 在 JavaScript 的世界里，一切皆对象！ 一、包装对象1、用typeof来识别身份 number、string、boolean、function和undefined有别于其他类型。特别注意null的类型是object，Array的类型也是object，如果我们用typeof将无法区分出null、Array和通常意义上的object——{}。 123456789typeof 123; // 'number'typeof NaN; // 'number'typeof 'str'; // 'string'typeof true; // 'boolean'typeof undefined; // 'undefined'typeof Math.abs; // 'function'typeof null; // 'object'typeof []; // 'object'typeof {}; // 'object' 2、通过new来包装对象 number、boolean和string都有包装对象。没错，在JavaScript中，字符串也区分string类型和它的包装类型。包装对象用new创建： 经过new包装的元素类型已经变为了对象！ 注意：闲的蛋疼也不要使用包装对象！尤其是针对`string`类型！！！ 123var n = new Number(123); // 123,生成了新的包装类型var b = new Boolean(true); // true,生成了新的包装类型var s = new String('str'); // 'str',生成了新的包装类型 12345678typeof new Number(123); // 'object'new Number(123) === 123; // falsetypeof new Boolean(true); // 'object'new Boolean(true) === true; // falsetypeof new String('str'); // 'object'new String('str') === 'str'; // false 注意：创建包装对象后的与原始值不同！！！ 3、不使用new的结果 Number()、Boolean和String()被当做普通函数，把任何类型的数据转换为number、boolean和string类型（注意不是其包装类型）： 1234567891011var n = Number('123'); // 123，相当于parseInt()或parseFloat()typeof n; // 'number'var b = Boolean('true'); // truetypeof b; // 'boolean'var b2 = Boolean('false'); // true! 'false'字符串转换结果为true！因为它是非空字符串！var b3 = Boolean(''); // falsevar s = String(123.45); // '123.45'typeof s; // 'string' 4、简单总结 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === 'undefined'； toString()方法 除了null 和 undefined ,其他对象都有此方法！ 用来将一个对象转换为字符串类型！ 注意，数字调用toString方法时，会报错，因为程序会认为.不是调用方法而是看成了小数； 所以要使用两个点，或者加一个括号，将他变成整体！ 1234123.toString(); // SyntaxError123..toString(); // '123', 注意是两个点！(123).toString(); // '123' 二、Data对象1、获取对象 通过new Data()来构建一个时间对象 可以获得，年月日，星期，时分秒，毫秒，以及时间戳！ 注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。 1234567891011var now = new Date();now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)now.getFullYear(); // 2015, 年份now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月now.getDate(); // 24, 表示24号now.getDay(); // 3, 表示星期三now.getHours(); // 19, 24小时制now.getMinutes(); // 49, 分钟now.getSeconds(); // 22, 秒now.getMilliseconds(); // 875, 毫秒数now.getTime(); // 1435146562875, 以number形式表示的时间戳 2、创建对象创建指定日期的Data对象:12var d = new Date(2015, 5, 19, 20, 15, 30, 123);d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST) 注意：JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。！ 注意：JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 通过解析ISO 8601格式的字符串 返回值为时间戳！ 使用Date.parse()时传入的字符串使用实际月份01 ~ 12，转换为Date对象后getMonth()获取的月份值为0 ~ 11。 要获取具体内容，得通过传入时间戳创建对象，再调用函数获得具体信息！ 123456var d = Date.parse('2015-06-24T19:49:22.875+08:00');d; // 1435146562875var d = new Date(1435146562875);d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)d.getMonth(); // 5 时间戳 时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。 我们只需要传递时间戳，或者把时间戳从数据库里读出来，再让JavaScript自动转换为当地时间就可以了。 获取当前时间戳： 两种方法： Data的now方法 Data的getTime方法 12console.log(Date.now()); console.log(new Date().getTime()); 时区 Date对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间： 只要我们传递的是一个number类型的时间戳，我们就不用关心时区转换。任何浏览器都可以把一个时间戳正确转换为本地时间。 123var d = new Date(1435146562875);d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时 三、RegExp对象 就是正则表达式！ 1、基础匹配 \\d ：一个数字 \\w ：一个数字或一个字母（大小写） \\s ：一个空格 . ：一个任意字符 \\. ：一个小数点 * ：任意个（包括0个） + ：至少一个 ？ ：0个或1个 {n} ：n个 {n, m} ：n 到 m 个 \\- ：一个- \\\\ ：一个\\ 12js. //可以表示js! js1 jsp\\d{3}\\s+\\d{3,8} //即三个数字一个空格然后是三到八个数字eg:010-12345 2、做到更精确的匹配，用方括号表示范围： [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串 [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就JavaScript允许的变量名 [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符） A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 你可能注意到了，js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了。 3、创建正则表达式通过/正则表达式/ 创建通过new RegExp('正则表达式')创建 注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个\\\\实际上是一个\\。 12345var re1 = /ABC\\-001/;var re2 = new RegExp('ABC\\\\-001');re1; // /ABC\\-001/re2; // /ABC\\-001/ 4、正则表达式匹配 使用re.test(待测字符串) 1234var re = /^\\d{3}\\-\\d{3,8}$/;re.test('010-12345'); // truere.test('010-1234x'); // falsere.test('010 12345'); // false 5、切分字符串 使用字符串.split(正则表达式) 来切割： 第一个：按一个空格分隔 第二个：按一个或多个空格分隔 第三个：按按空格和逗号大于等于一个的任意组合分隔 第四个：按空格和逗号和分号的大于等于一个的任意组合分隔 1234'a b c'.split(' '); // ['a', 'b', '', '', 'c']'a b c'.split(/\\s+/); // ['a', 'b', 'c']'a,b, c d'.split(/[\\s\\,]+/); // ['a', 'b', 'c', 'd']'a,b;; c d'.split(/[\\s\\,\\;]+/); // ['a', 'b', 'c', 'd'] 6、字符串分组 将需要分组的部分用()括起来即可 使用：正则表达式.exec(待测字符串) 进行分组 结果返回一个Array，[原字符串， 分组1， 分组2，....] 若无法匹配字符串，则返回null 123var re = /^(\\d{3})-(\\d{3,8})$/;re.exec('010-12345'); // ['010-12345', '010', '12345']re.exec('010 12345'); // null 看一个凶残的例子： 12var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;re.exec('19:05:30'); // ['19:05:30', '19', '05', '30'] | 表示或者，首先看冒号前的，从前往后表示00-09、10-19、20-29…最后一个是1-9，因为有时候01不写01，而写1，所以加一个[0-9]更合适。后面类似。。。 7、贪婪匹配 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： 12var re = /^(\\d+)(0*)$/;re.exec('102300'); // ['102300', '102300', ''] 由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配： ? ：即先满足后方的条件，再考虑前方！ 12var re = /^(\\d+?)(0*)$/;re.exec('102300'); // ['102300', '1023', '00'] 8、全局搜索 JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配： 即在正则表达式的最后加一个g 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引： 全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。 拓展：正则表达式还可以指定i标志，表示忽略大小写；m标志，表示执行多行匹配。 123var r1 = /test/g;// 等价于:var r2 = new RegExp('test', 'g'); 如下： 1234567891011121314151617var s = 'JavaScript, VBScript, JScript and ECMAScript';var re=/[a-zA-Z]+Script/g;// 使用全局匹配:re.exec(s); // ['JavaScript']re.lastIndex; // 10re.exec(s); // ['VBScript']re.lastIndex; // 20re.exec(s); // ['JScript']re.lastIndex; // 29re.exec(s); // ['ECMAScript']re.lastIndex; // 44re.exec(s); // null，直到结束仍没有匹配到 9、小栗子实现验证邮箱的正则表达式： 邮箱组成： 数字字母、下划线、小数点、- ,并且不以-开头 @符号 域名前缀：字母数字以及·-的任意组合，且不能以-开头 . 域名后缀： 1、只有一组字符：eg ：.com, .cn 2、有两组：eg: edu.cn、.com.cn eg：9zdfsk7sdf-hsdf7sdf88dsf.sdfhi.sjiodf99sdf@bbsdkf-88sdf-sgd.com.cn 例子有点夸张，哈哈哈哈哈！ 123let re = /^\\w+\\.?\\w+@\\w+\\.\\w+$/;let re = /^[0-9a-zA-Z]+\\.?[0-9a-zA-Z]+\\@[0-9a-zA-Z]+\\.[0-9a-zA-Z]+$/;let re = /^[a-zA-Z0-9]+([._-]?[a-zA-Z0-9]+)*@([a-zA-Z0-9]+[_-]?[a-zA-Z0-9]+)([_-][a-zA-Z0-9]+)*\\.[a-zA-Z]{2,3}(\\.[a-zA-Z]{2})?$/; 四、JSON对象 JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。 1、JSON的故事 在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。 终于，在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。 2、JSON的数据类型 number：和JavaScript的number完全一致； boolean：就是JavaScript的true或false； string：就是JavaScript的string； null：就是JavaScript的null； array：就是JavaScript的Array表示方式——[]； object：就是JavaScript的{ ... }表示方式。 JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。 为了统一解析，JSON的字符串规定必须用双引号\"\"，Object的键也必须用双引号\"\"。 由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。 3、JSON序列化 通过JSON的stringfy()方法来进行序列化： 123456789101112var xiaoming = { name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\\\"W3C\\\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp']};var s = JSON.stringify(xiaoming);console.log(s);//{\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]} 为了好看一点：按照缩进输出： 12345678910111213141516JSON.stringify(xiaoming, null, ' ');//结果：{ \"name\": \"小明\", \"age\": 14, \"gender\": true, \"height\": 1.65, \"grade\": null, \"middle-school\": \"\\\"W3C\\\" Middle School\", \"skills\": [ \"JavaScript\", \"Java\", \"Python\", \"Lisp\" ]} 123456789101112131415161718192021222324252627282930313233343536JSON.stringify(xiaoming, ['name', 'skills'], ' ');//结果：只输出name和skills的结果：{ \"name\": \"小明\", \"skills\": [ \"JavaScript\", \"Java\", \"Python\", \"Lisp\" ]}function convert(key, value) { if (typeof value === 'string') { return value.toUpperCase(); } return value;}JSON.stringify(xiaoming, convert, ' ');//结果：将值为String类型的都大写输出：{ \"name\": \"小明\", \"age\": 14, \"gender\": true, \"height\": 1.65, \"grade\": null, \"middle-school\": \"\\\"W3C\\\" MIDDLE SCHOOL\", \"skills\": [ \"JAVASCRIPT\", \"JAVA\", \"PYTHON\", \"LISP\" ]} 更精确控制： 可以在对象内部定义一个toJSON()的方法： 1234567891011121314151617var xiaoming = { name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\\\"W3C\\\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp'], toJSON: function () { return { // 只输出name和age，并且改变了key： 'Name': this.name, 'Age': this.age }; }};JSON.stringify(xiaoming); // '{\"Name\":\"小明\",\"Age\":14}' 4、反序列化 将JSON格式化后的字符串变为JavaScript对象 格式：JSON.parse(格式化的字符串)； 1234JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]JSON.parse('{\"name\":\"小明\",\"age\":14}'); // Object {name: '小明', age: 14}JSON.parse('true'); // trueJSON.parse('123.45'); // 123.45 parse()还可以跟一个函数来控制： 如果属性是name，则在对应的值上加同学两个字： 1234567var obj = JSON.parse('{\"name\":\"小明\",\"age\":14}', function (key, value) { if (key === 'name') { return value + '同学'; } return value;});console.log(JSON.stringify(obj)); // {\"name\": \"小明同学\", \"age\": 14} 本节到此结束，欢迎阅读，敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://niuxvdong.top/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://niuxvdong.top/tags/JavaScript/"},{"name":"Data","slug":"Data","permalink":"https://niuxvdong.top/tags/Data/"},{"name":"RegExp","slug":"RegExp","permalink":"https://niuxvdong.top/tags/RegExp/"},{"name":"JSON","slug":"JSON","permalink":"https://niuxvdong.top/tags/JSON/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之函数","slug":"JavaScript教程系列之函数","date":"2020-02-11T08:29:20.000Z","updated":"2020-02-11T08:29:20.000Z","comments":true,"path":"posts/52313.html","link":"","permalink":"https://niuxvdong.top/posts/52313.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、函数的定义与调用定义1234567function abs(x) { if (x &gt;= 0) return x; else return -x;}abs(-9);// 9 JavaScript用function来指出这是一个函数 JavaScript不写return语句自动返回undefined 调用 调用时参数可以有多个，即使定义时参数为1个 12abs(10, 'blablabla'); // 返回10abs(-9, 'haha', 'hehe', null); // 返回9 传入参数比定义还少也可以，返回NaN 此时参数 x 将收到undefined，为了避免参数收到undefined，可以进行一下判断： 这样，若没有参数，或参数传错即可输出一条提示语句。 typedef 来返回值得类型，可以用括号将参数括起来，也可以直接以空格隔开。 throw 语句：语句允许您创建自定义错误。从技术上讲能够抛出异常（抛出错误）。异常可以是 JavaScript 字符串、数字、布尔或对象： 123456789abs(); // 返回NaN x 收到参数为undefinedfunction abs(x) { if (typeof x !== 'number') throw 'Not a number'; if (x &gt;= 0) return x; else return -x;} arguments JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array： 可以接收传入的所有参数 123456789function foo(x) { console.log('x = ' + x); // 10 for (var i=0; i&lt;arguments.length; i++) { console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30 }}foo(10, 20, 30); 关键字在可以用来解决没有参数，但却传参无法接收参数的问题 1234567891011function abs() { if (arguments.length === 0) return 0; var x = arguments[0]; return x &gt;= 0 ? x : -x;}abs(); // 0abs(10); // 10abs(-9); // 9 解决可选参数问题 此函数可以用来解决可选参数与函数内部实际参数的对应关系，以免造成混乱 调用时是将a给了a，c给了b，所以为了保证对应，用if来判断，并作出修改 123456789101112// foo(a[, b], c)// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：function foo(a, b, c) { if (arguments.length === 2) { // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 } // ...} rest参数 rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。 123456789101112131415161718function foo(a, b, ...rest) { console.log('a = ' + a); console.log('b = ' + b); console.log(rest);}foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] return 语句注意：与C++不同，JavaScript引擎有一个在行末自动添加分号的机制，所以要保证你的句子不要写错。 12345678910111213141516171819function foo1() { return //这就是错的 { name: 'foo' };}function foo2() { return { name: 'foo' };}function foo3() { return { name: 'foo' };}foo3(); // { name: 'foo' } 如上：1是错的，2、3是对的。 二、变量作用域1、变量作用域同其他语言一样，从内到外2、变量提升变量提升介绍 只针对var声明的变量，let没有这些奇怪的用法 1234567891011121314151617function foo(){ var x = 'Hello, ' + y; console.log(x); var y = 'Bob';}foo();//Hello, undefined//上面的写法相当于下面的写法function foo(){ var y; // 提升变量y的申明，此时y为undefined var x = 'Hello, ' + y; console.log(x); y = 'Bob';} 不会报错，原因是变量y在稍后申明了。但是console.log显示Hello, undefined，说明变量y的值为undefined。 这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。 So 用到的变量最好提前声明。。。以防 不必要麻烦。。。 var 声明变量一次声明所有需要的变量。。 1234567function foo() { var x = 1, // x初始化为1 y = x + 1, // y初始化为2 z, i; // z和i为undefined} 全局作用域 不在任何函数内定义的变量就具有全局作用域。 实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性. 1234567891011121314var course = 'Learn JavaScript';alert(course); // 'Learn JavaScript'alert(window.course); // 'Learn JavaScript'function foo() { alert('foo');}foo(); // 直接调用foo()window.foo(); // 通过window.foo()调用alert(\"hhhhh\");window.alert('调用window.alert()'); 名字空间 全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中 著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。 其实就是用一个自定义的对象绑定了。。。 123456789101112// 唯一的全局变量MYAPP:var MYAPP = {};// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () { return 'foo';}; 局部作用域var无法实现for循环的局部范围 12345678function foo() { for (var i=0; i&lt;100; i++) { // } i += 100; // 仍然可以引用变量i} letlet没有这个问题 12345678910function foo() { var sum = 0; for (let i=0; i&lt;100; i++) { sum += i; } // SyntaxError: i += 1;} 所以定义变量建议全部使用let，而不使用var; const 用来定义常量，定义的常量不会被修改值 123const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14 3、解构赋值具体使用 使用解构赋值，直接对多个变量同时赋值 数组结构多个变量要使用[]来解构 数组若是嵌套，要保证对应层次相同 可以省略不想解构的值，逗号隔开即可 对对象解构要使用{} 对象的嵌套也要保证解构的层次对应清楚，属性后面根冒号再写大括号，eg：,address: {city, zip}, 找不到的属性会报错undefined 12345678910111213141516171819202122232425262728293031let [x, y, z] = ['hello', 'JavaScript', 'ES6'];console.log(x,y,z);//hello JavaScript ES6let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素let person ={ name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'};let {name, age, passport} = person;let person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: { city: 'Beijing', street: 'No.1 Road', zipcode: '100001' }};let {name, address: {city, zip}} = person;let {name, single=true} = person; 声明过的变量要想赋值，不能直接使用，要使用圆括号括起来 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来： 1234567// 声明变量:let x, y;// 解构赋值:{x, y} = { name: '小明', x: 100, y: 200};// 语法错误: Uncaught SyntaxError: Unexpected token =//正确写法:({x, y} = { name: '小明', x: 100, y: 200}); 如果想给对象中的属性换个名字，解构的时候可以在变量名后面加一个冒号，加上想要改的别名即可。。 1234567891011121314let person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'};// 把passport属性赋值给变量id:let {name, passport:id} = person;name; // '小明'id; // 'G-12345678'// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined 添加默认值，直接用等号赋值即可， 可以解决找不到属性，返回undefined的错误 1234567891011let person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678'};// 如果person对象没有single属性，默认赋值为true:let {name, single=true} = person;name; // '小明'single; // true 用处 用来交换两个值！ 12let x=1, y=2;[x, y] = [y, x] 快速获取当前页面域名和路径 1var {hostname:domain, pathname:path} = location; 创建Date对象 123456789101112131415161718function buildDate({year, month, day, hour=0, minute=0, second=0}){ return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);}let t = buildDate({ year: 2020, month: 2, day: 12, hour: 20, minute: 15 });console.log(t);//Wed Feb 12 2020 20:15:00 GMT+0800 (中国标准时间)//或者这样进行解构var time = {};time.year = 2018;time.month = 1;time.day = 1;time.hour = 23;time.minute = 45;time.second = 18;console.log(buildDate(time)); 三、对象内的函数1、定义及使用 调用时加上括号是调用函数 不加括号是调用函数内容，直接打印函数体 合着来写：1234567891011var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; }};console.log(xiaoming.age); // function xiaoming.age()console.log(xiaoming.age()); // 今年调用是25,明年调用就变成26了 浏览器返回的结果： 123456ƒ (){ var y = new Date().getFullYear(); return y - this.birth;}30 分开来写：1234567891011121314function getAge() { var y = new Date().getFullYear(); return y - this.birth;}var xiaoming = { name: '小明', birth: 1990, age: getAge};console.log(xiaoming.age()); // 25, 正常结果console.log(getAge()); // NaN 直接调用函数，由于this的指向就变成了全局对象windows，而windows并没有birth这个属性，所以最后会返回一个NaN; 错误写法12var fn = xiaoming.age; // 先拿到xiaoming的age函数fn(); // NaN 这种写法也是错的，必须直接用对象加点加属性来调用 1xiaoming.age(); 重构函数 第一种，this指向是windows，结果为NaN 第二种：this指向that,that指向xiaoming，结果正确 1234567891011121314151617181920212223242526272829303132333435//第一种，this指向是windowsvar xiaoming = { name: '小明', birth: 1990, age: function () { function getAgeFromBirth() { var y = new Date().getFullYear(); return y - this.birth; } return getAgeFromBirth(); }};xiaoming.age(); // NaN//第二种：this指向that,that指向xiaomingvar xiaoming = { name: '小明', birth: 1990, age: function () { var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() { var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this } return getAgeFromBirth(); }};xiaoming.age(); // 25 2、this 在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。 而直接在函数内部使用this，则指向的是windows全局对象 apply()方法 用来改变this 指向 它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 123456789101112131415function getAge() { var y = new Date().getFullYear(); return y - this.birth;}var xiaoming = { name: '小明', birth: 1990, age: getAge};xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 call()方法 apply()把参数打包成Array再传入； call()把参数按顺序传入。 对于一般函数，通常把this绑定为 null 即可 12Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5 3、装饰器 通过apply()方法我们可以动态改变函数作用 可以实现在原函数不变的情况下增加功能的效果 先保留原函数 再改变原函数，最后通过apply()方法传入this指向和参数，return回去原函数的作用 达到增加功能的效果 arguments即当前函数接收到的所有参数，再次传给保留的旧函数，进行作用 而apply最大的作用就是可以将改造函数传入的一堆参数再原封不动的传给旧函数！！！12345678910111213var count = 0;var oldParseInt = parseInt; // 保存原函数window.parseInt = function () { count += 1; return oldParseInt.apply(null, arguments); // 调用原函数};// 测试:parseInt('10');parseInt('20');parseInt('30');console.log('count = ' + count); // 3 四、高阶函数 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 简单的例子： 123456function add(x, y, f){ return f(x) + f(y);}let x = add(-5, 8, Math.abs);console.log(x);//13 1、map()函数 此方法是专门针对数组的 由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果 map参数为函数名 1234567891011function pow(x){ return x * x;}var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]console.log(results);var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] 2、reduce()函数 Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上 这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： 1[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) 就是一个迭代过程！ 利用reduce求乘积12345function product(arr){ return arr.reduce((x,y)=&gt;x*y);}console.log(product([1,5,2,7,9]));//630 利用reduce 将数字数组转化为整数12345let arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) { return x * 10 + y;}); // 13579 将字符串变为数字1234567891011121314151617181920212223function stringToint(s) { let ss = []; for(let i = 0; i &lt; s.length; i++) ss.push(s[i]); let arr = ss.map(x =&gt; x -= '0'); let res = arr.reduce((x,y) =&gt; x * 10 + y); return res; //或者合并一下操作，这样也可以： return ss.map((x) =&gt; x -= '0').reduce((x, y) =&gt; (x*10+y)); //用split函数来得到一个副本为单个字符的数组 return s.split('').map(x =&gt; x * 1).reduce((x, y) =&gt; x * 10 + y) //或者直接使用下面的语句： return s* 1; //使用自带的parseInt函数 r = ss.map(function(x){ return parseInt(x)});}stringToint('43859843');//43859843 注意： return s* 1 ：隐式类型转换 ，会将操作数转换成数字类型，如运算符-, *, /,% 首字母大写，其他小写 输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']。 12345678910111213141516171819202122232425262728293031323334353637function normalize(arr) { let arrs = []; arrs = arr.map(function(x){ let s = x[0].toUpperCase(); for(let i = 1; i &lt; x.length; i++) s += x[i].toLowerCase(); return s; }); return arrs; //或者这样 return arr.map((x) =&gt; { let a = ''; for (let v of x) { if (!a) a += v.toUpperCase(); else a += v.toLowerCase(); } return a; })； //或者使用split函数分割再使用reduce进行拼接 return arr.map(function(s){ var c=s.toLowerCase().split(''); c[0]=c[0].toUpperCase(); return c.reduce((x,y)=&gt;x+y); });} //或者这样，比较精巧，使用字符串的substr函数 return arr.map(function(arr){ return arr[0].toUpperCase()+arr.substr(1).toLowerCase(); }); //或者这样，使用数组的slice函数 return arr.map(s =&gt; s[0].toUpperCase() + s.slice(1).toLowerCase());console.log(normalize(['adam', 'LISA', 'barT'])); 3、filter()函数 filter同样是作用于数组Array的函数！ filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。 简而言之：就是一个按条件过滤函数； 返回新数组！ 过滤掉偶数： 12345let arr = [1, 2, 4, 5, 6, 9, 10, 15];let r = arr.filter(function (x){ return x % 2 !== 0;});r; // [1, 5, 9, 15] 过滤掉空字符串： 字符串的trim函数用来删除字符串的头尾空格。 12345var arr = ['A', '', 'B', null, undefined, 'C', ' '];var r = arr.filter(function (s) { return s &amp;&amp; s.trim();});r; // ['A', 'B', 'C'] filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身： 1234567var arr = ['A', 'B', 'C'];var r = arr.filter(function (element, index, self) { console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // ['A', 'B', 'C'] return true;}); 过滤掉相同的元素 过滤掉数组找到的当前元素下标和当前元素的真正下标不相等的 indexOf函数总是返回数组中找到的第一个匹配的下标，所以后面有相同字符串不同下标的时候就会自动过滤。 123456789var r, arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry']; r = arr.filter(function (element, index, self) { return self.indexOf(element) === index;});console.log(r); 4、sort()函数 通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1 sort函数会直接修改当前Array，注意！ sort 返回修改后的数组！ 12345678// 看上去正常的结果:['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];// apple排在了最后:['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft\", 'apple']// 无法理解的结果:[10, 20, 1, 2].sort(); // [1, 10, 2, 20] 第一个正常 第二个不正常，都是按照ASKII码排序的 第三个不正常，虽然是数字，但Array的sort()方法默认把所有元素先转换为String再排序 作为高阶函数sort自然可以穿函数参数： 与其他语言不同，比较函数得写全，不能只写一个if 返回的1可以理解为需要交换 返回-1表示不需要交换 返回0表示。。。 数字比价 12345678910111213arr.sort(function (x, y) { if (x &lt; y) return -1; if (x &gt; y) return 1; return 0;});console.log(arr); // [1, 2, 10, 20]arr.sort(function (x, y) { if (x &lt; y) return 1; if (x &gt; y) return -1; return 0;});console.log(arr); // [20,10,2,1] 字符串比较 既有大写又有小写，则统一一下进行比较 123456789101112var arr = ['Google', 'apple', 'Microsoft'];arr.sort(function (s1, s2) { x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) { return -1; } if (x1 &gt; x2) { return 1; } return 0;}); // ['apple', 'Google', 'Microsoft'] 5、every()函数 every()方法可以判断数组的所有元素是否满足测试条件。 返回值为 true 或 false 12345678var arr = ['Apple', 'pear', 'orange'];console.log(arr.every(function (s) { return s.length &gt; 0;})); // true, 因为每个元素都满足s.length&gt;0console.log(arr.every(function (s) { return s.toLowerCase() === s;})); // false, 因为不是每个元素都全部是小写 6、find()函数 find()方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined： 返回元素 123456789var arr = ['Apple', 'pear', 'orange'];console.log(arr.find(function (s) { return s.toLowerCase() === s;})); // 'pear', 因为pear全部是小写console.log(arr.find(function (s) { return s.toUpperCase() === s;})); // undefined, 因为没有全部是大写的元素 7、findIndex()函数 findIndex()和find()类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，如果没有找到，返回-1： 返回索引 12345678var arr = ['Apple', 'pear', 'orange'];console.log(arr.findIndex(function (s) { return s.toLowerCase() === s;})); // 1, 因为'pear'的索引是1console.log(arr.findIndex(function (s) { return s.toUpperCase() === s;})); // -1 8、forEach forEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。forEach()常用于遍历数组，因此，传入的函数不需要返回值： 12var arr = ['Apple', 'pear', 'orange'];arr.forEach(console.log); // 依次打印每个元素 五、闭包1、函数作为返回值12345678function sum(arr) { return arr.reduce(function (x, y) { return x + y; });}sum([1, 2, 3, 4, 5]); // 15 2、延迟执行函数 对上一个进行包装，写成一个函数套函数即可实现 f1()和f2()的调用结果互不影响，返回的都是一个新的独立的函数！ 1234567891011121314151617function lazy_sum(arr) { var sum = function () { return arr.reduce(function (x, y) { return x + y; }); } return sum;}var f = lazy_sum([1, 2, 3, 4, 5]); // f接收sum用来求和的函数f(); // 15 调用f指向的sum函数var f1 = lazy_sum([1, 2, 3, 4, 5]);var f2 = lazy_sum([1, 2, 3, 4, 5]);f1 === f2; // false 3、闭包 闭包参考，加深理解： JavaScript之闭包 在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。 在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。 函数内部的函数不进行函数的函数调用是不会执行的！ 简而言之：就是为了让外部的人访问不到内部的东西，外部的人看不到内部存在的闭包 最简单的闭包：123456789101112function makeFunc() { var name = \"Mozilla\"; function displayName() { alert(name); } return displayName;}var myFunc = makeFunc();myFunc(); 在一些编程语言中，函数中的局部变量仅在函数的执行期间可用。 一旦 makeFunc() 执行完毕，我们会认为 name 变量将不能被访问。然而，因为代码运行得没问题，所以很显然在 JavaScript 中并不是这样的。 JavaScript这样的原因是：JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成，这个环境包括了这个闭包创建时所能访问的所有局部变量。在上面的例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用，而 displayName 实例仍可访问其词法作用域中的变量，即可以访问到 name 。由此，当 myFunc 被调用时，name 仍可被访问，其值 Mozilla 就被传递到alert中。 函数生产工厂12345678910111213function makeAdder(x) { return function(y) { return x + y; };}var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7 实现参数和5加的函数console.log(add10(2)); // 12 实现参数和10加的函数 闭包问题来源 本例子引用廖雪峰JavaScript之闭包 12345678910111213141516function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push(function () { return i * i; }); } return arr;}var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2]; 在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是： 123f1(); // 16f2(); // 16f3(); // 16 问题解析： 首先我们弄懂上面代码的运行流程： 首先var results = count();之后，函数count已经被调用了，所以一次执行函数内的各段代码：var arr = [];，for (var i=1; i&lt;=3; i++)，这个for循环尤其值得注意。 因为此时循环体执行了push方法，将一个个函数function () { return i * i;}添加到数组内，但是这个函数并没有被调用，还只是一个变量，所以for循环依次执行，直到i = 4。因为闭包，内部函数function () { return i * i;}引用的i就是外部变量，for循环中的i = 4。所以，之后数组arr内的函数的i都是4。 调用函数count后，变量results已经是数组arr了。数组里面元素依次是function f1() { return i * i;} function f2() { return i * i;} function f3() { return i * i;}。但是三个函数都没有被调用，直到var f1 = results[0];，此时function f1() { return i * i;}开始执行，如上段所写，此时的i = 4，所以，返回值就是16了。后面两个调用也是类似情况。 简而言之：就是因为函数内部的函数不会直接执行，会等到调用了外部函数之后，在调用 到内部的函数时，才会执行，也就是说，var results = count();这里还没有调用到内部的函数，直到var f1 = results[0];被调用时，才会调用到内部的函数！ 然而：在count()函数被调用时，i的值就已经变为了4，所以在result()调用时，i 其实是4,； 同理：后面的所有i 就都变为了4！ 解决办法 为了实现我们理想的结果，1，4，9；可以这样做： 注意这里用了一个“创建一个匿名函数并立刻执行”的语法： 123456789101112131415161718192021222324252627282930313233343536373839404142function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push((function (n) { return function () { return n * n; } })(i)); } return arr;}var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9//或者这样：function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push((function (n) { return n * n; })(i)); } return arr;}var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];console.log(f1); // 1console.log(results[1]);//4 “创建一个匿名函数并立刻执行” 最后小括号内引用的参数是用来保存值的，也是为了传递到函数的 x 参数使用的，同时做到了即刻执行的效果！ 注意：函数要用小括号括起来： 123(function (x) { return x * x;})(3); // 9 4、对象作为返回值 此时return 后面跟的是一个大括号，即是一个对象： 12345678910111213141516171819function create_counter(initial) { var x = initial || 0; return { inc: function () { x += 1; return x; } }}var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2c1.inc(); // 3var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12c2.inc(); // 13 解析： 在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。 函数内部的x += 1;实际上他已经改变了函数内部的x，也就是对当前函数来说的局部变量x,由于闭包的出现，导致c2这个函数不会终止，即第一次的调用对后续是有累积效应的！ 而c1和c2则是完全独立的！ 六、箭头函数最简单的例子：二者一样： 一条语句123456x =&gt; x * xfunction (x){ return x * x;} 箭头函数相当于匿名函数(即没有函数名！)，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ ... }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ ... }和return： 多条语句1234x =&gt; { if (x &gt; 0) return x * x; else return - x * x;} 多个参数： 需要用小括号括起来：无参数也需要括起来； 1234567891011121314// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; { var i, sum = x + y; for (i=0; i&lt;rest.length; i++) { sum += rest[i]; } return sum;} 返回对象 本来要用大括号，但是对象也是大括号，所以用小括号来括住了！ 1x =&gt; ({ foo: x }) this 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 箭头函数this的指向永远是作用域内的那个指向！ 而不是普通函数的指向；要想实现真正指向，如以前教程，可以var that = this; 如下：普通函数this指向windows会undefined 12345678910var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = function () { return new Date().getFullYear() - this.birth; // this指向window或undefined }; return fn(); }}; 改用箭头函数后：this始终指向obj对象！ 123456789var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); }};obj.getAge(); // 25 使用了箭头函数后，无法通过参数来改变this指向 this指向还是obj，而不是此时的year！ 由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略： 123456789var obj = { birth: 1990, getAge: function (year) { var b = this.birth; // 1990 var fn = (y) =&gt; y - this.birth; // this.birth仍是1990 return fn.call({birth:2000}, year); }};obj.getAge(2015); // 25 七、generator 一个generator看上去像一个函数，但可以返回多次。 可以实现多次return的作用 1、普通的 实现斐波那契数列的算法 只有返回一个数组才能得到最终结果 1234567891011121314151617function fib(max) { var t, a = 0, b = 1, arr = [0, 1]; while (arr.length &lt; max) { [a, b] = [b, a + b]; arr.push(b); } return arr;}// 测试:fib(5); // [0, 1, 1, 2, 3]fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 2、使用generator generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。 直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。 调用方法一：调用generator对象的next()方法： next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}， 然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。 当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。 12345678910111213141516171819202122function* fib(max) { var t, a = 0, b = 1, n = 0; while (n &lt; max) { yield a; [a, b] = [b, a + b]; n ++; } return;}var f = fib(5);// fib {[[GeneratorStatus]]: \"suspended\", [[GeneratorReceiver]]: Window}f.next(); // {value: 0, done: false}f.next(); // {value: 1, done: false}f.next(); // {value: 1, done: false}f.next(); // {value: 2, done: false}f.next(); // {value: 3, done: false}f.next(); // {value: undefined, done: true} 调用方法二：使用for of语句 此调用不需要我们来判断done,for of 可以自动判断！ 12345678910111213141516171819function* fib(max) { var t, a = 0, b = 1, n = 0; while (n &lt; max) { yield a; [a, b] = [b, a + b]; n ++; } return;}for (var x of fib(10)){ console.log(x); // 依次输出0, 1, 1, 2, 3, ...} 3、一个小栗子 实现打印下一个id: 12345678910111213function* next_id() { var x=0; while(true) { yield ++x; }}// 测试:let x g = next_id();for (x = 1; x &lt; 100; x ++) console.log(g.next().value);//[1,2,3....99] 函数这节有点难度，也是看了好久，需要经常看！经过艰难险阻，终于完结了！敬请期待下一节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://niuxvdong.top/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://niuxvdong.top/tags/JavaScript/"},{"name":"函数","slug":"函数","permalink":"https://niuxvdong.top/tags/%E5%87%BD%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"Java教程系列之快速入门","slug":"Java教程系列之快速入门","date":"2020-02-09T11:50:45.000Z","updated":"2020-02-09T11:50:45.000Z","comments":true,"path":"posts/12025.html","link":"","permalink":"https://niuxvdong.top/posts/12025.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 为什么Java应用最广泛？从互联网到企业平台，Java是应用最广泛的编程语言，原因在于： Java是基于JVM虚拟机的跨平台语言，一次编写，到处运行； Java程序易于编写，而且有内置垃圾收集，不必考虑内存管理； Java虚拟机拥有工业级的稳定性和高度优化的性能，且经过了长时期的考验； Java拥有最广泛的开源社区支持，各种高质量组件随时可用。 Java语言常年霸占着三大市场： 互联网和企业应用，这是Java EE的长期优势和市场地位； 大数据平台，主要有Hadoop、Spark、Flink等，他们都是Java或Scala（一种运行于JVM的编程语言）开发的； Android移动平台。 这意味着Java拥有最广泛的就业市场。 一、Java 的诞生Java的出现 Java最早是由SUN公司（已被Oracle收购）的詹姆斯·高斯林（高司令，人称Java之父）在上个世纪90年代初开发的一种编程语言，最初被命名为Oak，目标是针对小型家电设备的嵌入式应用，结果市场没啥反响。谁料到互联网的崛起，让Oak重新焕发了生机，于是SUN公司改造了Oak，在1995年以Java的名称正式发布，原因是Oak已经被人注册了，因此SUN注册了Java这个商标。随着互联网的高速发展，Java逐渐成为最重要的网络编程语言。 Java语言类型 Java介于编译型语言和解释型语言之间。 编译型语言如C、C++，代码是直接编译成机器码执行，但是不同的平台（x86、ARM等）CPU的指令集不同，因此，需要编译出每一种平台的对应机器码。 解释型语言如Python、Ruby没有这个问题，可以由解释器直接加载源码然后运行，代价是运行效率太低。 而Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。当然，这是针对Java开发者而言。对于虚拟机，需要为每个平台分别开发。为了保证不同平台、不同公司开发的虚拟机都能正确执行Java字节码，SUN公司制定了一系列的Java虚拟机规范。从实践的角度看，JVM的兼容性做得非常好，低版本的Java字节码完全可以正常运行在高版本的JVM上。 Java三个版本 Java SE：Standard Edition Java EE：Enterprise Edition Java ME：Micro Edition Java SE就是标准版，包含标准的JVM和标准库 而Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。 Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。 Java学习路线 首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用； 如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的； 如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发； 如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。 无论怎么选择，Java SE的核心技术是基础 Java版本 1995年发布，目前已经到了 Java13 名次解释JDK 和 JRE JDK：Java Development Kit JRE：Java Runtime Environment JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。 JSR 和JCP JSR规范：Java Specification Request JCP组织：Java Community Process RI 和 TCK 比如有人提议要搞一个基于Java开发的消息服务器，这个提议很好啊，但是光有提议还不行，得贴出真正能跑的代码，这就是RI。如果有其他人也想开发这样一个消息服务器，如何保证这些消息服务器对开发者来说接口、功能都是相同的？所以还得提供TCK。 通常来说，RI只是一个“能跑”的正确的代码，它不追求速度，所以，如果真正要选择一个Java的消息服务器，一般是没人用RI的，大家都会选择一个有竞争力的商用或开源产品。 RI：Reference Implementation 参考实现 TCK：Technology Compatibility Kit 兼容性测试套件 二、JDK的安装环境变量配置 都在系统变量里设置： 1、新建JAVA_HOME变量，变量值为安装JDK的路径 2、新建CLASSPATH变量，变量值为.;%JAVA_HOME%\\lib。 3、新增CLASSPATH变量，变量值为%JAVA_HOME%\\bin。 找到PATH点击编辑-&gt;新建 测试win + R键打开cmd: 输入java -version，若显示如下，则说明配置正确，否则需要检查路径问题，重新配置。 三、Java编程规范1234567public class Hello { public static void main(String[] args) { System.out.println(\"Hello, world!\"); }} 大小写敏感 Java规定，某个类定义的public static void main(String[] args)是Java程序的固定入口方法，因此，Java程序总是从main方法开始执行。 当我们把代码保存为文件时，文件名必须是Hello.java，而且文件名也要注意大小写，因为要和我们定义的类名Hello完全保持一致。 注意：文件名，必须和类名一致。 运行程序 Java源码本质上是一个文本文件，我们需要先用javac把Hello.java编译成字节码文件Hello.class，然后，用java命令执行这个字节码文件： 因此，可执行文件javac是编译器，而可执行文件java就是虚拟机。 或者直接使用java hello.java 一次性完成两个过程 1234$ javac hello.java //生成hello.class$ java hello$ java hello.java 第一种，javac 后跟文件名.java , java后跟 类名，无后缀。 第二种，直接java 后跟文件名.java 需要注意的是，在实际项目中，单个不依赖第三方库的Java源码是非常罕见的，所以，绝大多数情况下，我们无法直接运行一个Java源码文件，原因是它需要依赖其他的库。 1.Java保存的文件名必须与类名一致； 2.如果文件中只有一个类，文件名必须与类名一致； 3.一个Java文件中只能有一个public类； 4.如果文件中不止一个类，文件名必须与public类名一致； 5.如果文件中不止一个类，而且没有public类，文件名可与任一类名一致。 四、java 程序基础1、类 Java是面向对象的语言，一个程序的基本单位就是class，class是关键字 类名要求： 类名必须以英文字母开头，后接字母，数字和下划线的组合 习惯以大写字母开头 注意： Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。 在class内部，可以定义若干方法（method） 句子以分号结束 2、注释 // ：单行注释 /* */：多行注释 /** */：如果有多行，每行通常以星号开头，可以用来自动创建文档的注释 123456789101112/** * 可以用来自动创建文档的注释 * * @auther Mr.Niu */public class Hello { public static void main(String[] args) { System.out.println(\"Hello, world!\"); }} 3、数据类型 计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从00000000~11111111，换算成十进制是0~255，换算成十六进制是00~ff。 整数类型： byte 一个字节 short 两个字节 int 四个字节 long 八个字节 浮点数类型： float 四个字节 double 八个字节 字符类型： char 两个字节 布尔类型： boolean 两个字节 So…….范围如下： byte：-128 ~ 127 short: -32768 ~ 32767 int: -2147483648 ~ 2147483647 long: -9223372036854775808 ~ 9223372036854775807 注意：long型数据结尾需要加L，否则会报错。不加L默认为int型。 123456789101112public class Main{ public static void main(String[] args) { int i = 2147483647; int i2 = -2147483648; int i3 = 2_000_000_000; // 加下划线更容易识别 int i4 = 0xff0000; // 十六进制表示的16711680 int i5 = 0b1000000000; // 二进制表示的512 long l = 9000000000000000000L; // long型的结尾需要加L }} 注意：float型数据末尾必须加f，否则会报错，不加f默认为double类型。 12345float f1 = 3.14f;float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38double d = 1.79e308;double d2 = -1.79e308;double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324 浮点数可表示的范围非常大，float类型可最大表示3.4x1038，而double类型可最大表示1.79x10308。 注意：boolean类型只有flase 和 true两个值 12345boolean b1 = true;boolean b2 = false;boolean isGreater = 5 &gt; 3; // 计算结果为trueint age = 12;boolean isAdult = age &gt;= 18; // 计算结果为false 注意：char类型既可以表示ASCII码也可以表示Unicode字符 单引号表示字符，双引号表示字符串 12345678910public class Main{ public static void main(String[] args) { char a = 'A'; char zh = '中'; System.out.println(a); System.out.println(zh); }} 4、常量 定义变量的时候，如果加上final修饰符，这个变量就变成了常量： 1234final double PI = 3.14; // PI是一个常量double r = 5.0;double area = PI * r * r;PI = 300; // compile error! 5、var关键字 编译器会根据赋值语句自动推断出变量类型，省时，省力 123StringBuilder sb = new StringBuilder();var sb = new StringBuilder(); 6、数据运算除0编译可以通过，但运行会报错可以使用+=等等可以使用++、-- 运算符移位运算 带符号位移动： 左移 &lt;&lt; ：相当于乘2 右移 &gt;&gt; ：相当于除2 不带符号位移动： 右移 &gt;&gt;&gt; ：相当于除2 12345int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &lt;&lt; 1; // 00000000 00000000 00000000 00001110 = 14int b = n &lt;&lt; 2; // 00000000 00000000 00000000 00011100 = 28int c = n &gt;&gt; 1; // 00000000 00000000 00000000 00000011 = 3int d = n &gt;&gt; 2; // 00000000 00000000 00000000 00000001 = 1 注意：对一个负数进行右移，最高位的1不动，结果仍然是一个负数： 12345int n = -536870912;int a = n &gt;&gt; 1; // 11110000 00000000 00000000 00000000 = -268435456int b = n &gt;&gt; 2; // 10111000 00000000 00000000 00000000 = -134217728int c = n &gt;&gt; 28; // 11111111 11111111 11111111 11111110 = -2int d = n &gt;&gt; 29; // 11111111 11111111 11111111 11111111 = -1 注意：使用不带符号右移，负数右移，会将最高位符号位也右移，变为正数 12345int n = -536870912;int a = n &gt;&gt;&gt; 1; // 01110000 00000000 00000000 00000000 = 1879048192int b = n &gt;&gt;&gt; 2; // 00111000 00000000 00000000 00000000 = 939524096int c = n &gt;&gt;&gt; 29; // 00000000 00000000 00000000 00000111 = 7int d = n &gt;&gt;&gt; 31; // 00000000 00000000 00000000 00000001 = 1 注意：对byte和short类型进行移位时，会首先转换为int再进行位移。 7、位运算 位运算是按位进行与、或、非和异或的运算。 &amp;：按位与 | ：按位或 ~ ：按位非 ^ ： 按位异或 :不同为1，相同为0 8、运算符优先级从高到低： () ! ~ ++ -- * / % + - &lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | += -= *= /= 9、类型提升和强转类型转换略，太简单了！ 10、浮点数 由于计算机二进制表示，判断浮点数相等仍得通过阀值和绝对值函数来实现。 12345678// 比较x和y是否相等，先计算其差的绝对值:double r = Math.abs(x - y);// 再判断绝对值是否足够小:if (r &lt; 0.00001) { // 可以认为相等} else { // 不相等} 11、溢出 NaN表示Not a Number Infinity表示无穷大 -Infinity表示负无穷大 123double d1 = 0.0 / 0; // NaNdouble d2 = 1.0 / 0; // Infinitydouble d3 = -1.0 / 0; // -Infinity 12、boolean运算 比较运算符：&gt;，&gt;=，&lt;，&lt;=，==，!= 与运算 &amp;&amp; 或运算 || 非运算 ! 123456boolean isGreater = 5 &gt; 3; // trueint age = 12;boolean isZero = age == 0; // falseboolean isNonZero = !isZero; // trueboolean isAdult = age &gt;= 18; // falseboolean isTeenager = age &gt;6 &amp;&amp; age &lt;18; // true 注意：若boolean运算可以判断最终结果为真或假，则不会进行后续无意义计算，即便后面有除0运算 1boolean result = true || (5 / 0 &gt; 0); // true 13、三目运算符？： …不介绍了。 14、字符和字符串char char类型既可以表示ASCII码也可以表示Unicode字符 用转义字符\\u+Unicode编码来表示一个字符： 123// 注意是十六进制:char c3 = '\\u0041'; // 'A'，因为十六进制0041 = 十进制65char c4 = '\\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013 String 用双引号表示 用\\表示转义 字符串连接 用+号连接 12345678910public class Main{ public static void main(String[] args) { String s1 = \"Hello\"; String s2 = \"world\"; String s = s1 + \" \" + s2 + \"!\"; System.out.println(s); }} 多行字符串 笨办法： 123String s = \"first line \\n\" + \"second line \\n\" + \"end\"; 新办法： 12345678910111213141516String s = \"\"\" SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC \"\"\"String s = \"\"\" SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC\"\"\";String s = \"\"\" SELECT * FROMusersWHERE id &gt; 100ORDER BY name DESC\"\"\"; 注意：上面表示五行还有一个换行符\\n 注意：下面表示四行，没有换行符 注意：最终格式总是以最靠左边的为基准。 第三种可以避免空格问题出现。。 若要使用cmd： 1$ javac --source 13 --enable-preview Main.java String的不可变特性12345678910public class Main { public static void main(String[] args) { String s = \"hello\"; System.out.println(s); // 显示 hello s = \"world\"; System.out.println(s); // 显示 world }} 原来的字符串\"hello\"还在，只是我们无法通过变量s访问它而已。因此，字符串的不可变是指字符串内容不可变。 相当于指针指向换了， 空值null1234String s1 = null; // s1是nullString s2; // 没有赋初值值，s2也是nullString s3 = s1; // s3也是nullString s4 = \"\"; // s4指向空字符串，不是null 15、数组类型数组定义 定义一个数组类型的变量，使用数组类型“类型[]”，例如，int[]。和单个基本类型变量不同，数组变量初始化必须使用new int[5]表示创建一个可容纳5个int元素的数组 Java的数组有几个特点： 数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false； 数组一旦创建后，大小就不可改变。 可以使用.length来获取数组长度 第一种12345678public class Main { public static void main(String[] args) { int[] ns = new int[5]; System.out.println(ns.length); // 5 }} 第二种可以用{}来初始化，自动推算数组大小： 123456789public class Main { public static void main(String[] args) { // 5位同学的成绩: int[] ns = new int[] { 68, 79, 91, 85, 62 }; System.out.println(ns.length); // 编译器自动推算数组大小为5 }} 第三种：简略版1int[] ns = { 68, 79, 91, 85, 62 }; 数组大小不可变如下： 123456789101112public class Main { public static void main(String[] args) { // 5位同学的成绩: int[] ns; ns = new int[] { 68, 79, 91, 85, 62 }; System.out.println(ns.length); // 5 ns = new int[] { 1, 2, 3 }; System.out.println(ns.length); // 3 }} 看似大小变了，实际是数组指向变了，由原来指向五个数据的地方，指向了三个数据地方，而原来五个数组没有指向他的，所以无法访问了。 原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。 String类型数组，一样，改变一个值，值并没有消失，只是指向改变了，原来的值无法通过下标为1的数组来访问。 12345678910public class Main{ public static void main(String[] args) { String[] names = {\"ABC\", \"XYZ\", \"zoo\"}; String s = names[1]; names[1] = \"cat\"; System.out.println(s); // XYZ }} 五、流程控制1、输出System.out.println() println是print line的缩写，表示输出并换行 System.out.print() print：不换行 1234567891011public class Main { public static void main(String[] args) { System.out.print(\"A,\"); System.out.print(\"B,\"); System.out.print(\"C.\"); System.out.println();//可以用来换行 System.out.println(\"END\"); }} System.out.printf() 格式化输出，和C语言printf类似 可以%08.3f来控制小数与宽度与补位数 占位符： %d 格式化输出整数 %x 格式化输出十六进制整数 %f 格式化输出浮点数 %e 格式化输出科学计数法表示的浮点数 %s 格式化字符串 注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身 12345678910public class Main{ public static void main(String[] args) { int n = 12345000; System.out.printf(\"n=%d, hex=%08x\\n\", n, n); double d = 239.3839; System.out.printf(\"%09.2f\", d);//000239.38 }} 2、输入 首先，我们通过import语句导入java.util.Scanner，import是导入某个类的语句，必须放到Java源代码的开头 然后，创建Scanner对象并传入System.in。System.out代表标准输出流，而System.in代表标准输入流。直接使用System.in读取用户输入虽然是可以的，但需要更复杂的代码，而通过Scanner就可以简化后续的代码。 有了Scanner对象后，要读取用户输入的字符串，使用scanner.nextLine()，要读取用户输入的整数，使用scanner.nextInt()。Scanner会自动转换数据类型，因此不必手动转换。 1234567891011121314import java.util.Scanner;public class Main{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.out.print(\"Input your name: \"); // 打印提示 String name = scanner.nextLine(); // 读取一行输入并获取字符串 System.out.print(\"Input your age: \"); // 打印提示 int age = scanner.nextInt(); // 读取一行输入并获取整数 System.out.printf(\"Hi, %s, you are %d\\n\", name, age); // 格式化输出 }} 3、if语句判断引用类型相等 在Java中，判断值类型的变量是否相等，可以使用==运算符。 但是，判断引用类型的变量是否相等，==表示“引用是否相等”，或者说，是否指向同一个对象。 例如，下面的两个String类型，它们的内容是相同的，但是，分别指向不同的对象，用==判断，结果为false： 1234567891011121314public class Main { public static void main(String[] args) { String s1 = \"hello\"; String s2 = \"HELLO\".toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1 == s2) System.out.println(\"s1 == s2\"); else System.out.println(\"s1 != s2\"); }} 要判断引用类型的变量内容是否相等，必须使用equals()方法： 1234567891011121314public class Main { public static void main(String[] args) { String s1 = \"hello\"; String s2 = \"HELLO\".toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1.equals(s2)) System.out.println(\"s1 equals s2\"); else System.out.println(\"s1 not equals s2\"); }} 注意： 执行语句s1.equals(s2)时，如果变量s1为null，会报NullPointerException： 4、switch语句 switch case break default 与C++一样，不介绍 switch表达式 使用switch时，如果遗漏了break，就会造成严重的逻辑错误，而且不易在源代码中发现错误。 从Java 12开始，switch语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要break语句： 注意新语法使用-&gt;，如果有多条语句，需要用{}括起来。不要写break语句，因为新语法只会执行匹配的语句，没有穿透效应。 123456789101112131415161718public class Main{ public static void main(String[] args) { String fruit = \"apple\"; switch (fruit) { case \"apple\" -&gt; System.out.println(\"Selected apple\"); case \"pear\" -&gt; System.out.println(\"Selected pear\"); case \"mango\" -&gt; { System.out.println(\"Selected mango\"); System.out.println(\"Good choice!\"); } default -&gt; System.out.println(\"No fruit selected\"); } }} 1234567891011121314public class Main { public static void main(String[] args) { String fruit = \"apple\"; int opt = switch (fruit) { case \"apple\" -&gt; 1; case \"pear\", \"mango\" -&gt; 2; default -&gt; 0; }; // 注意赋值语句要以;结束 System.out.println(\"opt = \" + opt); }} 5、yield 大多数时候，在switch表达式内部，我们会返回简单的值。 但是，如果需要复杂的语句，我们也可以写很多语句，放到{...}里，然后，用yield返回一个值作为switch语句的返回值： 123456789101112131415161718public class Main{ public static void main(String[] args) { String fruit = \"orange\"; int opt = switch (fruit) { case \"apple\" -&gt; 1; case \"pear\", \"mango\" -&gt; 2; default -&gt; { int code = fruit.hashCode(); yield code; // switch语句返回值 } }; System.out.println(\"opt = \" + opt); }} 运行结果： 注: Main.java 使用预览语言功能。注: 有关详细信息，请使用 -Xlint:preview 重新编译。opt = -1008851410 6、while和do while略。。。与C++一样。。。 7、for循环略。。。与C++一样。。。 for each 和for循环相比，for each循环的变量n不再是计数器，而是直接对应到数组的每个元素。for each循环的写法也更简洁。但是，for each循环无法指定遍历顺序，也无法获取数组的索引。 除了数组外，for each循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的List、Map等。 1234567891011public class Main{ public static void main(String[] args) { int[] ns = { 1, 4, 9, 16, 25 }; for (int n : ns) { System.out.println(n); } }} 8、break 和 continue略。。。与C++一样。。。 六、 数组操作1、for each 遍历参考第五个的for each 2、直接打印数组名 得到的是在JVM中的地址。。。 3、Arrays.toString() 需引入java.util.Arrays库，可以用来遍历数组 12345678910import java.util.Arrays;public class Main { public static void main(String[] args) { int[] ns = { 1, 1, 2, 3, 5, 8 }; System.out.println(Arrays.toString(ns));//[1, 1, 2, 3, 5, 8] }} 4、Arrays.sort() 排序 对int排序，数组内存存储顺序已经改变 对String类型排序，数组内存存储顺序没有改变，只是指向的改变 1234567891011import java.util.Arrays;public class Main { public static void main(String[] args) { int[] ns = { 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 }; Arrays.sort(ns); System.out.println(Arrays.toString(ns)); }} 5、多维数组多维数组定义：1234567891011121314public class Main { public static void main(String[] args) { int[][] arr = new int[100][100]; int[][] ns = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }; System.out.println(ns.length); // 3 }} 多维数组遍历 普通遍历 使用for each遍历 12345678910111213141516171819202122public class Main { public static void main(String[] args) { int[][] arr = new int[100][100]; int[][] ns = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }; for (int[] t : ns) { for (int n : t) { System.out.print(n); System.out.print(\", \"); } System.out.println(); }} 6、命令行参数 命令行参数类型是String[]数组； 命令行参数由JVM接收用户输入并传给main方法； 我们可以利用接收到的命令行参数，根据不同的参数执行不同的代码。例如，实现一个-version参数，打印程序版本号 123456789101112131415161718public class Main { public static void main(String[] args) { for (String arg : args) { System.out.println(arg); } for (String arg : args) { if (\"-version\".equals(arg)) { System.out.println(\"v 1.0\"); break; } } }} 123$ javac Main.java$ java Main -version # 传一个参数v 1.0 快速入门结束，敬请期待后续内容，to be continued. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"入门","slug":"入门","permalink":"https://niuxvdong.top/tags/%E5%85%A5%E9%97%A8/"},{"name":"基础","slug":"基础","permalink":"https://niuxvdong.top/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"https://niuxvdong.top/tags/Java/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之基础语法入门","slug":"JavaScript教程系列之基础语法入门","date":"2020-02-09T05:53:06.000Z","updated":"2020-02-09T05:53:06.000Z","comments":true,"path":"posts/41103.html","link":"","permalink":"https://niuxvdong.top/posts/41103.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。 新兴的Node.js把JavaScript引入到了服务器端，JavaScript已经变成了全能型选手。 JavaScript确实很容易上手，但其精髓却不为大多数开发人员所熟知。编写高质量的JavaScript代码更是难上加难。 教程参考：JavaScript全栈教程 一、JavaScript的诞生 在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。 由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在两周之内设计出了JavaScript语言。你没看错，这哥们只用了10天时间。 为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。 二、JavaScript引入 JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到head中 第一种 123&lt;script&gt; alert('hello world!');&lt;/script&gt; 第二种 1&lt;script src=\"/static/js/abc.js\"&gt;&lt;/script&gt; 第三种 默认的type就是JavaScript，所以不必显式地把type指定为JavaScript。 123&lt;script type=\"text/javascript\"&gt; ...&lt;/script&gt; 三、基本语法句子以分号结束'Hello, world'; 也是完整语句注释 //：单行注释 /**/：多行注释 四、数据类型Number类型 123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 字符串类型 使用单引号或双引号引起来的内容 同样，要输出无法输出的字符，仍然可以使用\\来转义 字符串转义：123'I\\'m \\\"OK\\\"!'; //I'm \"OK\"!'\\x41'; // 完全等同于 'A'---\\x表示ASCII编码字符'\\u4e2d\\u6587'; // 完全等同于 '中文' ----\\u表示一个Unicode字符 多行字符串： 由于多行字符串用\\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 “``”表示： 反引号位于数字1的左边 123`这是一个多行字符串`; 模板字符串： 将多个字符串连接起来 使用 + 号 123var name = '小明';var age = 20;var message = '你好, ' + name + ', 你今年' + age + '岁了!'; 使用${变量}来表示，得用反引号引起来 1234var name = '小明';var age = 20;var message = `你好, ${name}, 你今年${age}岁了!`;alert(message); 显示结果都是： 你好, 小明, 你今年20岁了! str.length12var s = 'Hello, world!';s.length; // 13 索引操作略。 对索引赋值，无返回结果，不影响原值，并且字符串类型无法进行修改，是不可变类型 123var s = 'Test';s[0] = 'X';alert(s); // s仍然为'Test' toUpperCase()函数 小写变大写 12var s = 'Hello';s.toUpperCase(); // 返回'HELLO' toLowerCase()函数 大写边小写 123var s = 'Hello';var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lowerlower; // 'hello' indexOf()函数 返回字串出现位置，没有找到返回-1 123var s = 'hello, world';s.indexOf('world'); // 返回7s.indexOf('World'); // 没有找到指定的子串，返回-1 substring()函数 返回索引区间字串 123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' split()函数 split() 方法用于把一个字符串分割成字符串数组。 如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。 split() 方法不改变原始字符串。 *string*.split(*separator*,*limit*) 第一个参数：分隔符；第二个参数：限制返回字符数组的最大长度，不指定则不限制； 1234567891011var str=\"How are you doing today?\";var n=str.split(\" \");//[\"How\", \"are\", \"you\", \"doing\", \"today?\"]var nn = str.split();console.log(nn);//[\"How are you doing today?\"]var nnn = str.split(\"\");console.log(nnn);//[\"H\", \"o\", \"w\", \" \", \"a\", \"r\", \"e\", \" \", \"y\", \"o\", \"u\", \" \", \"d\", \"o\", \"i\", \"n\", \"g\", \" \", \"t\", \"o\", \"d\", \"a\", \"y\", \"?\"]var nnnn = str.split(\" \", 3);console.log(nnnn);//[\"How\", \"are\", \"you\"] 布尔类型 true 和 false 12false == 0; // truefalse === 0; // false 注意： ==：它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果 ===：它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 所以： 尽量不要使用 ==来进行比较，要使用===来比较！ 特例1：NaN 与自己比较也会返回false1NaN === NaN; // false 判断方法：使用isNaN()函数比较 1isNaN(NaN); // true 特例2：浮点数比较 浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值.（二级制无法表示0.1 。。。。。。） 11 / 3 === (1 - 2 / 3); // false 解决方法：使用Math.abs()函数 1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true null 和 undefined JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义. 数组 数组可以包括任意数据类型 中括号创建数组1[1, 2, 3.14, 'Hello', null, true]; 使用Array()函数创建数组：1new Array(1, 2, 3); // 创建了数组[1, 2, 3] 建议直接使用[]来创建数组 与其他语言一样，可以只用下标访问，超出下标范围返回undeifined 1234var arr = [1, 2, 3.14, 'Hello', null, true];arr[0]; // 返回索引为0的元素，即1arr[5]; // 返回索引为5的元素，即truearr[6]; // 索引超出了范围，返回undefined for循环遍历12var arr2 = [1,2,3,'', \"jdsoa\", null];for(var n in arr) console.log(arr[n]); s.length注意点：直接给Array的length赋一个新的值会导致Array大小的变化： 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] 可通过索引修改值 切记不可超出下标范围 indexOf()函数 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置：没有找到返回-1 12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 slice()函数 slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： 注意到slice()的起止参数包括开始索引，不包括结束索引。 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： 1234567var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G'] push()和pop()函数 push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] unshift()和shift()函数 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： 123456789var arr = [1, 2];arr.unshift('A', 'B'); // 返回Array新的长度: 4arr; // ['A', 'B', 1, 2]arr.shift(); // 'A'arr; // ['B', 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // [] sort()函数 sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序： 可自定义参数实现自定义排序 123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] reverse()函数 reverse()把整个Array的元素给掉个个，也就是反转： 123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] splice()函数 splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： 12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] concat()函数 concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： 1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] 实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里： 12var arr = ['A', 'B', 'C'];arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] join()函数 join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 多维数组 如果数组的某个元素又是一个Array，则可以形成多维数组 1var arr = [[1, 2, 3], [400, 500, 600], '-']; 对象 JavaScript的对象是一组由键-值组成的无序集合 JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。 JavaScript对象的键都是字符串类型，值可以是任意数据类型。person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为'Bob'，zipcode属性为null。 属性名若包括特殊字符，需用引号引起来。eg：middle-school 123456789var person = { name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, 'middle-school': 'No.1 Middle School', zipcode: null}; 对象访问方法： 12person.name; // 'Bob'person.zipcode; // null 注意：属性若有-等特殊字符，需要用引号引起来使用，并且访问时只能使用[]来访问，不能通过.访问。否则显示xxxx is not defined for循环遍历对象：用 in 来遍历，变量访问的是属性，通过[]来访问值。 若用.访问的属性不存在会自动创建一个，使用deletek可以进行删除，删除后再次访问会显示undefined。 用 in来判断属性名是否是对象的属性，但是无法判断由于继承得到的属性 使用hasOwnProperty()函数来判断解决继承问题得到的属性 12345678910111213141516171819202122232425var xiaoming = { name : \"小明\", age : 24, height : 9999, score : null, ps : undefined, str : '', hr : NaN, 'n-x' : 89, }; console.log(xiaoming.n-x);//报错，x is not defined console.log(xiaoming['n-x']); console.log(xiaoming['name']); for(var i in xiaoming) console.log(i + ':' + xiaoming[i]); xiaoming.zdf = '增加'; console.log(xiaoming.zdf); delete xiaoming.zdf; console.log(xiaoming.zdf); //undefined console.log('name' in xiaoming); //true console.log('toString' in xiaoming); //true console.log(xiaoming.hasOwnProperty('toString')); //false 变量 变量名是大小写英文、数字、$和_的组合，且不能用数字开头 申明一个变量用var语句 12345var a; // 申明了变量a，此时a的值为undefinedvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 = '007'; // s_007是一个字符串var Answer = true; // Answer是一个布尔值truevar t = null; // t的值是null 在JavaScript中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值， JavaScript是动态语言，弱类型语言 12var a = 123; // a的值是整数123a = 'ABC'; // a变为字符串 console.log()函数 可以在控制台打印需要的东西 无、条件判断 和C++一模一样，不做介绍 六、循环break和continue 和C++一模一样，不做介绍 for循环普通循环for in 循环 可以遍历对象，得到对象的属性名 要过滤掉对象继承的属性，用hasOwnProperty()来实现： 123456789101112var o = { name: 'Jack', age: 20, city: 'Beijing'};for (var key in o) { if (o.hasOwnProperty(key)) { console.log(key); // 'name', 'age', 'city' }} 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引： 请注意，for ... in对Array的循环得到的是String而不是Number。 12345var a = ['A', 'B', 'C'];for (var i in a) { console.log(i); // '0', '1', '2' console.log(a[i]); // 'A', 'B', 'C'} while循环和do while循环 和C++一模一样，不做介绍 七、Map Map是一组键值对的结构，具有极快的查找速度。 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 set()添加，get()查找，delete()删除，has()查询 set是一组key,value,后三个参数都为key 1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined set()添加时，后添加的会覆盖前面添加的。 1234var m = new Map();m.set('Adam', 67);m.set('Adam', 88);m.get('Adam'); // 88 for of 遍历Map对象1for(var j of m) console.log(j[0]+':'+j[1]); 八、Set Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 Set创建12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素自动过滤12var s = new Set([1, 2, 3, 3, '3']);s; // Set {1, 2, 3, \"3\"} add()添加，delete()删除 参数都是key 123456789s.add(4);s; // Set {1, 2, 3, 4}s.add(4);s; // 仍然是 Set {1, 2, 3, 4}var s = new Set([1, 2, 3]);s; // Set {1, 2, 3}s.delete(3);s; // Set {1, 2} for of 遍历Set对象1for(var j of s) console.log(j); 九、iterable 遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for ... of循环来遍历。 for in ：遍历属性名 for of：遍历值 123456789101112131415161718192021222324var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) { // 遍历Array console.log(x);}for (var x of s) { // 遍历Set console.log(x);}for (var x of m) { // 遍历Map console.log(x[0] + '=' + x[1]);}//for in 会将所以属性名都遍历var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x in a) { console.log(x); // '0', '1', '2', 'name'}//for of 只遍历该遍历的var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x of a) { console.log(x); // 'A', 'B', 'C'} 使用forEach()函数 它接收一个函数，每次迭代就自动回调该函数 结构： 参数可以有多个，可以只有一个。 参数1：对应值 参数2：对应键 参数3：对应类型 123456789101112a.forEach(function(参数1,参数2,参数3){ 语句块})；var a = [3,4,5,6,7];var sum = 0;// 第一种a.forEach(function(item){sum += item;});// 第二种a.forEach(item =&gt; sum += item);console.log(sum); 遍历Array123456789101112var a = ['A', 'B', 'C'];//访问值和键a.forEach(function (element, index, array){ console.log(element + ', index = ' + index);});//只访问值a.forEach(function (element) { console.log(element);}); 遍历Set12345var s = new Set(['A', 'B', 'C']);s.forEach(function (element, set) { console.log(element);}); 遍历Map12345var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map){ console.log(value);}); JavaScript教程系列一完美结束，敬请期待后续教程！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://niuxvdong.top/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://niuxvdong.top/tags/JavaScript/"},{"name":"入门","slug":"入门","permalink":"https://niuxvdong.top/tags/%E5%85%A5%E9%97%A8/"}],"author":"Mr.Niu"},{"title":"自学Git记录及用法总结","slug":"自学Git记录及用法总结","date":"2020-02-06T13:02:25.000Z","updated":"2020-02-06T13:02:25.000Z","comments":true,"path":"posts/50207.html","link":"","permalink":"https://niuxvdong.top/posts/50207.html","excerpt":"","text":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 本文资料参考： 廖雪峰Git教程 菜鸟Git教程 相关文章推荐： Git五分钟教程 Github简明教程 Git命令文档参考： Git官方文档参考 菜鸟Git文档PDF 国外友人制作Git文档 首先来首歌曲来放松一下吧！ 一、 Git的诞生 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 二、 Git与 Svn 的区别 1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。 2、Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。 3、Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。 4、Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。 5、Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 三、Git的安装及配置直接去Git官网下载对应的安装程序，安装即可. 安装完成配置一下全局用户名和邮箱！ 12$ git config --global user.name \"xxxx\"$ git config --global user.email \"xxxx\" 查看用户名： 12$ git config user.name$ git config user.email 效果如下： 查看配置信息： 1$ git config --list 效果如下： 清空Git Bash的代码记录：输入reset回车即可 1$ reset 四、工作区，暂存区，版本库的区别 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下图来解释三者的关系： 图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。 图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 五、Git 创建版本库git init 命令首先本地新建一个文件夹名为test，然后cd 进去，打开Git Bash，输入初始化命令： 1$ git init 然后你会发现test文件夹多了一个.git目录： 这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了 但是你会发现你看不到，因为它为了防止被人改动，自动隐藏了，可以使用如下命令查看： 1$ ls -ah 效果如下： 会发现路径后面多了一个master，是说当前库是被git托管的，并且是在master的默认分支上。 接下来在本地目录新建一个README.md文档，用文本编辑器打开写上“我的Git自学记录！” 然后用Git命令将其提交到暂存区，再提交到版本库： 12$ git add README.md$ git commit -m \"增加README文件\" 效果如下： git add 与 git commit 命令 git add 命令：将文件从工作区提交到暂存区 后面可以跟文件名，或者多个文件名以空格分隔 也可以跟 .来表示所有文件 git commit 命令：将文件从暂存区提交到版本库 -m 参数：后面写本次提交的备注 -a 参数： 可以跳过备注，但会进入编辑备注模式，按shift键+ZZ可以退出。 git status 命令 用来查看状态：可以让我们时刻掌握仓库当前的状态，即工作区有没有提交到暂存区，暂存区有没有提交到版本库 接下来修改文件内容，增加一行“修改文件test1”。 如下： 然后再git bash 中使用 git status命令查看状态： 如下： 会提示”change not staged for commit”也就是改变还没有提交到版本库 会提示”modifiled : README.md”即，提示这个文件被修改了 会提示”git add &lt;file&gt;“，即使用此命令可以将当前改变提交到暂存区 会提示git restore &lt;file&gt;，即使用此命令可以将当前改变撤销，即本地文件会恢复到修改之前。 接下来使用git add .将文件提交到暂存区，在使用git status 来查看状态： 会发现红字变为了绿字，即当前修改已经提交成功到了暂存区。 会提示git restore --staged &lt;file&gt;来撤销暂存区修改，即暂存区还是原来的样子，而本地文件还是修改后的状态 想要恢复文件未被修改之前，参考上面提到的撤销命令git restore &lt;file&gt; 接下来使用git commit来将修改提交到版本库，然后使用git status查看状态： 会发现git status 的返回状态为”working tree clean”，即工作区很干净。 ls 命令 可以查看当前目录下的文件 -a ：查看隐藏目录 cd到.git目录可以看到HEAD(版本库)和index(暂存区)文件： cd 命令 cd d: ：即切换到d 盘 cd &lt;目录&gt;：即进入那个目录 cd ..：即退到上一目录 touch 命令 创建文件命令，后跟文件名。 mkdir命令 创建目录命令，后跟目录名 pwd 命令 用于显示当前路径 cat 命令 查看文件内容，后跟文件名 vim 或vi 命令 编辑文件命令，后跟文件名 进入编辑状态后： 按 i进入编辑模式 按 Esc键结束编辑 按shift + Z + Z 键退出编辑状态 若没有要打开的文件，则会自动新建一个文件，只有在新建文件中输入了东西，按下shift +Z + Z才能保存，若没有进行修改，文件也不会创建成功，所以也可以用此命令来代替touch命令，效果一样。 git diff命令 git diff：查看工作区和暂存区差异， git diff -cached：查看暂存区和版本库差异， git diff HEAD/master：查看工作区和版本库差异， 若没有差异，则不会有返回信息。 git rm 命令 rm file：删除工作区文件 git rm file：删除暂存区和工作区文件 git rm –cached file：只删除暂存区，保留工作区 git rm -r *：递归删除该目录下所有文件 只在工作区的文件，通过rm删除，无法恢复 提交到暂存区的文件，在工作区进行rm删除后，可以通过git checkout – file来撤销删除。新版命令：git restore file 提交到版本库的文件，在工作区进行rm删除后，也可以通过 git checkout – file 来撤销删除。新版命令：git restore file 提交到版本库的文件，通过git rm 进行删除后，其实已经将删除提交到了暂存区，所以应该用git reset HEAD file将版本库给了暂存区，再用git checkout – file将暂存区拉回工作区，即恢复原状。新版命令：git restore –staged file 再使用：git restore file. 若想彻底删除版本库文件，先git rm ，再commit 即可，若想恢复就得晋城版本回退操作，后序再讲。 提交到暂存区或版本库，用rm删除后恢复操作： 提交到版本库文件，用git rm删除恢复操作： 彻底删除版本库文件： 新版命令变化新版： 12$ git restore --staged file$ git restore file. 旧版： 12$ git reset HEAD file$ git checkout -- file 六、版本回退 版本回退即时空穿梭，只要提交到了版本库，你可以穿梭到任意一次版本库的提交记录。 git log 命令 git log命令显示从最近到最远的提交日志，会显示提交id,作者，邮箱，日期，以及提交备注。 可以使用git log --oneline来显示简略版的历史 可以使用 git log --pretty=oneline来显示在一行 只显示commit id ,以及提交备注 可以使用git log --graph查看拓扑图具体自己操作查看！ 可以使用 git log --reverse --oneline逆向显示记录可以使用git log --author=niuxvdong --oneline -5来指定作者名字更多log 参数命令前往官网查看https://git-scm.com/docs/git-log git用HEAD表示当前版本git reset 命令 回退命令！ git reset --hard HEAD^ 回退上一个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 此时再使用git log会发现未来的记录没了，只能查看当前记录。 So… 往上翻找到commitId再使用git reset --hard HEAD commitIdgit reflog 记录你的命令 可以找到commitId，然后git reset –hard HEAD commitId即可回到未来 七、远程仓库（远程库）创建密钥：1$ ssh-keygen -t rsa -C \"youremail@example.com\" 密钥相当于个人电脑的指纹，托管平台通过密钥来识别身份。 在C盘用户目录下的.ssh文件夹下的id_rsa和id_rsa.pub两个文件，一个私钥，一个公钥。 链接远程库： 将公钥复制到代码托管平台的SSH管理页面，名称随便填即可。 创建仓库： 名字起的像样点，相当于你的项目名。 如图所示，安照提示走： $ git remote add origin git@github.com:niuxvdong/test.git &lt;figure class=\"highlight plain\">&lt;table>&lt;tbody>&lt;tr>&lt;td class=\"gutter\">&lt;pre>&lt;span class=\"line\">1&lt;/span>&lt;br>&lt;span class=\"line\">2&lt;/span>&lt;br>&lt;span class=\"line\">3&lt;/span>&lt;br>&lt;/pre>&lt;/td>&lt;td class=\"code\">&lt;pre>&lt;span class=\"line\">&lt;/span>&lt;br>&lt;span class=\"line\">- ```bash&lt;/span>&lt;br>&lt;span class=\"line\"> $ git push -u origin master&lt;/span>&lt;br>&lt;/pre>&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table>&lt;/figure> 以后即可直接git push 了，不需要那么多参数。 删除远程库 以便于连接另一个托管平台 1$ git remote rm origin 同时连接多个托管平台 因为远程库名字都叫origin，所以只需先删除已绑定的远程库，然后进行关联时候，将名字更改即可！ 1234$ git remote rm origin$ git remote add github git@github.com:niuxvdong/test.git$ git remote add gitee git@gitee.com:niuxvdong/test.git$ git remote -v so 现在的仓库名字不叫 origin 了，一个叫 github ，一个叫 gitee。用到origin的命令时，就要对应仓库名字进行修改了。 push 命令修改如下： 12$ git push github master$ git push gitee master 克隆仓库： git clone + ssh链接 git clone + ssh链接 + 路径 git remote命令12$ git remote $ git remote -v 远程库名称和详细信息 有push信息说明你有推送权限： 推送分支1$ git push origin master 推送其他分支即将master改为其他分支名 多人协作参考教程：https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320 git rabase参考教程：https://www.liaoxuefeng.com/wiki/896043488029600/1216289527823648 八、分支管理查看分支1$ git branch 创建分支1$ git branch &lt;name&gt; 切换分支1$ git switch &lt;name&gt; 或 git checkout &lt;name&gt; 创建并切换1$ git switch -c &lt;name&gt; 或 git checkout -b &lt;name&gt; 合并分支1$ git merge &lt;name&gt; 默认合并方式为Fast forward模式 此种合并方法看不到合并历史，对于开发来说不太好 尽量使用 –no-ff 参数来合并使用普通合并 此方法可以看到合并历史记录，便于开发和操作 可以追加上-m参数1$ git merge --no-ff -m \"merge with --no-ff\" 删除分支1$ git branch -d &lt;name&gt; 强制删除分支： 1$ git branch -D &lt;name&gt; 合并冲突解决创建dev分支1$ git branch dev 在master分支将文件修改后，add并且commit123$ vi new.c$ git add .$ git commit -m \"add hhhhhhhhhh\" 切换到dev分支1$ git switch dev 在dev分支将文件修改后，add 并 commit123$ vi new.c$ git add .$ git commit -m \"add ssssssssss\" 切换到master分支1$ git branch dev 合并dev分支1$ git merge dev 出现冲突 vi 编辑冲突文件1$ vi new.c add 并commit12$ git add .git commit -m \"merge confilt\" 删除dev分支1$ git branch -d dev 九、存储现场git stash 命令 用来存储当前工作状态，一遍先去处理遇到的问题或其他bug 12$ git stashSaved working directory and index state WIP on dev: f52c633 add merge git stash list12$ git stash liststash@{0}: WIP on dev: f52c633 add merge 恢复现场一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick命令，把bug提交的修改“复制”到当前分支，避免重复劳动。十、标签管理 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 创建标签1$ git tag v1.0 查看标签1$ git tag 通过commitId打标签 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了 12$ git log --oneline$ git tag v1.1 f52c633 查看具体标签信息 标签不是按时间顺序列出，而是按字母排序的。可以用git show查看标签信息： 12$ git tag$ git show v1.1 创建带有说明的标签 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m \"version 0.1 released\" 1094adb 注意： 标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 删除本地标签 当前本地标签未推送到远程库 1$ git tag -d v0.1 推送标签推送指定标签1$ git push origin v1.0 一次性推送全部尚未推送到远程的本地标签1$ git push origin --tags 删除已推送到远程库的标签先删除本地标签1$ git tag -d v0.9 再删除远程库1$ git push origin :refs/tags/v0.9 另一种删除方式1$ git push origin :&lt;branch&gt;/&lt;tag&gt; 注意冒号 : 必不可少, 后面跟远程库的分支名/标签名 十一、自定义忽略特殊文件参考文档：https://www.liaoxuefeng.com/wiki/896043488029600/900004590234208 给命令配置简短的别名参考文档： https://www.liaoxuefeng.com/wiki/896043488029600/898732837407424 完美结束，历时好久终于写完，感谢观看！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Git","slug":"Git","permalink":"https://niuxvdong.top/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://niuxvdong.top/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://niuxvdong.top/tags/Github/"}],"author":"Mr.Niu"},{"title":"hexo-theme-matery主题配置详解","slug":"hexo-theme-matery主题配置详解","date":"2020-02-05T04:24:09.000Z","updated":"2020-02-05T04:24:09.000Z","comments":true,"path":"posts/57378.html","link":"","permalink":"https://niuxvdong.top/posts/57378.html","excerpt":"","text":"hexo-theme-matery 这是一个采用 Material Design 和响应式设计的 Hexo 博客主题。 特性 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 首页轮播文章及每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。 支持 DaoVoice、Tidio 在线聊天功能。 贡献者感谢下面列出的贡献者，没有他们，hexo-theme-matery 不会这么完美。 @HarborZeng @shw2018 @L1cardo @Five-great 下载当你看到这里的时候，应该已经有一个自己的 Hexo 博客了。如果还没有的话，不妨使用 Hexo 和 Markdown 来写博客和文章。 点击 这里 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。 当然你也可以在你的 themes 文件夹下使用 Git clone 命令来下载: 1git clone https://github.com/blinkfox/hexo-theme-matery.git 配置切换主题修改 Hexo 根目录下的 _config.yml 的 theme 的值：theme: hexo-theme-matery _config.yml 文件的其它修改建议: 请修改 _config.yml 的 url 的值为你的网站主 URL（如：http://xxx.github.io）。 建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。 如果你是中文用户，则建议修改 language 的值为 zh-CN。 新建分类 categories 页categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"categories\" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： 123456---title: categoriesdate: 2018-09-30 17:25:30type: \"categories\"layout: \"categories\"--- 新建标签 tags 页tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"tags\" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： 123456---title: tagsdate: 2018-09-30 18:23:38type: \"tags\"layout: \"tags\"--- 新建关于我 about 页about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"about\" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： 123456---title: aboutdate: 2018-09-30 17:25:30type: \"about\"layout: \"about\"--- 新建留言板 contact 页（可选的）contact 页是用来展示留言板信息的页面，如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"contact\" 编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容： 123456---title: contactdate: 2018-09-30 17:25:30type: \"contact\"layout: \"contact\"--- 注：本留言板功能依赖于第三方评论系统，请激活你的评论系统才有效果。并且在主题的 _config.yml 文件中，第 19 至 21 行的“菜单”配置，取消关于留言板的注释即可。 新建友情连接 friends 页（可选的）friends 页是用来展示友情连接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"friends\" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： 123456---title: friendsdate: 2018-12-12 21:25:30type: \"friends\"layout: \"friends\"--- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： 12345678910111213141516171819[{ \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\", \"name\": \"码酱\", \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\", \"url\": \"http://luokangyuan.com/\", \"title\": \"前去学习\"}, { \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\", \"name\": \"闪烁之狐\", \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\", \"url\": \"https://blinkfox.github.io/\", \"title\": \"前去学习\"}, { \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\", \"name\": \"ja_rome\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://me.csdn.net/jlh912008548\", \"title\": \"前去学习\"}] 菜单导航配置配置基本菜单导航的名称、路径url和图标icon.1.菜单导航名称可以是中文也可以是英文(如：Index或主页)2.图标icon 可以在Font Awesome 中查找 12345678910111213141516171819menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book 二级菜单配置方法如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作1.在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children)2.在children下创建二级菜单的 名称name,路径url和图标icon.3.注意每个二级菜单模块前要加 -.4.注意缩进格式 12345678910111213141516171819202122232425262728293031323334menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后就可以在文章中对应位置看到你用emoji语法写的表情了。 代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下： 1npm i -S hexo-prism-plugin 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下： 12345678highlight: enable: falseprism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: 搜索本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： 1npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123search: path: search.xml field: post 中文链接转拼音（建议安装）如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。 安装命令如下： 1npm i hexo-permalink-pinyin --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123permalink_pinyin: enable: true separator: '-' # default: '-' 注：除了此插件外，hexo-abbrlink 插件也可以生成非中文的链接。 文章字数统计插件（建议安装）如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。 安装命令如下： 1npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可： 1234567postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数. 添加emoji表情支持（可选的）本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下： 1npm install hexo-filter-github-emojis --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 添加 RSS 订阅支持（可选的）本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下： 1npm install hexo-generator-feed --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456789feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。 添加 DaoVoice 在线聊天功能（可选的）前往 DaoVoice 官网注册并且获取 app_id，并将 app_id 填入主题的 _config.yml 文件中。 添加 Tidio 在线聊天功能（可选的）前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 修改页脚页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。 修改社交链接在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： 12345&lt;% if (theme.socialLink.github) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.github %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-github\"&gt;&lt;/i&gt; &lt;/a&gt;&lt;% } %&gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0。 修改打赏的二维码图片在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 配置音乐播放器（可选的）要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。 首先，在你的博客 source 目录下的 _data 目录（没有的话就新建一个）中新建 musics.json 文件，文件内容如下所示： 12345678910111213141516[{ \"name\": \"五月雨变奏电音\", \"artist\": \"AnimeVibe\", \"url\": \"http://xxx.com/music1.mp3\", \"cover\": \"http://xxx.com/music-cover1.png\"}, { \"name\": \"Take me hand\", \"artist\": \"DAISHI DANCE,Cecile Corbel\", \"url\": \"/medias/music/music2.mp3\", \"cover\": \"/medias/music/cover2.png\"}, { \"name\": \"Shape of You\", \"artist\": \"J.Fla\", \"url\": \"http://xxx.com/music3.mp3\", \"cover\": \"http://xxx.com/music-cover3.png\"}] 注：以上 JSON 中的属性：name、artist、url、cover 分别表示音乐的名称、作者、音乐文件地址、音乐封面。 然后，在主题的 _config.yml 配置文件中激活配置即可： 1234567891011121314# 是否在首页显示音乐.music: enable: true showTitle: false title: 听听音乐 fixed: false # 是否开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'list' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: false # 列表默认折叠 listMaxHeight: # 列表最大高度 文章 Front-matter 介绍Front-matter 选项详解Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。 最简示例1234---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00--- 最全示例1234567891011121314151617---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags: - Typora - Markdown--- 效果截图 自定制修改在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分： 菜单 我的梦想 首页的音乐播放器和视频播放器配置 是否显示推荐文章名称和按钮配置 favicon 和 Logo 个人信息 TOC 目录 文章打赏信息 复制文章内容时追加版权信息 MathJax 文章字数统计、阅读时长 点击页面的’爱心’效果 我的项目 我的技能 我的相册 Gitalk、Gitment、Valine 和 disqus 评论配置 不蒜子统计和谷歌分析（Google Analytics） 默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图 我认为个人博客应该都有自己的风格和特色。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方： 修改主题颜色在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： 123456789101112/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}@-webkit-keyframes rainbow { /* 动态切换背景颜色. */}@keyframes rainbow { /* 动态切换背景颜色. */} 修改 banner 图和文章特色图你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 &lt;script&gt;&lt;/script&gt; 代码中： 1$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); 在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。 版本记录 v1.2.2 新增了自定义文章 keywords 的功能； 新增静态彩带点击切换的功能和配置； 将文章字数统计、彩带和站点运行时间等功能默认设置为 false； 修改了文章的 description 的 meta 属性优先读取文章的 summary 属性； 修改了文章标题的 HTML 标签，从 div 改成了 h1 标题； 修改了页脚年份显示不正确的问题； 去掉了站点运行时间中多余的 setTimeout 代码； v1.2.1 新增了 TOC 的展开目录层级设置和滚动条功能，防止目录较多的时候目录溢出； 修改了首页的展示方式为以前的模式； 修复首页按钮没有边框的问题； 修复了音乐及吸底模式、视频、推荐文章等不激活时仍然生成首页卡片的问题； 修复 wordCount 插件未安装的问题，修改了部分配置； 修复音乐的 JSON 配置中有单引号的情况页面不显示的音乐的问题 修复标签云在Hexo4.0下链接失效的问题； v1.2.0 新增了 DaoVoice、Tidio 的在线聊天功能； 新增了两级菜单的功能； 新增了打字效果的副标题； 新增了网页内容预加载的功能； 新增了首页 banner 是否每日切换的配置功能； 新增了显示 ICP 备案信息的功能，默认未开启； 新增了百度分析的配置； 新增了代码块的语言显示、一键复制、显示行号等功能； 新增了首页轮播图和推荐文章可自定义配置的功能； 新增了文章页面显示更新日期； 新增了转载规则的图标； 修改了分享的布局和显示方式； 升级更新了部分依赖库的版本； 其他细节修改和优化； v1.1.0 新增了 emoji 的支持； 新增了站点运行时间统计及配置； 新增了留言板的功能,默认未开启； 新增了 Twitter、Facebook、知乎的社交链接； 更新了 Valine 的版本为最新版； 其他小细节的修改； v1.0.4 新增了能为每篇文章都自定义转载规则的功能； 修复上一页、下一页的自定义 summary 不显示的问题； 修复了友情链接显示错位的问题，改为了瀑布流的布局方式； 其他小细节 bug 的修改； v1.0.3 新增了TOC展开、收缩的按钮和相关配置，默认显示此按钮； v1.0.2 升级了 Materialize 框架版本为1.0.0，重构和修改了升级过程中的部分文件或问题； 新增了首页封面的全屏轮播特效，可以将更重要的文章设置到首页轮播中； 修复首页第一个按钮是中文的问题 修复了 iPhone 上点击搜索输入获取焦点的问题； 修复了 iPhone 上输入框获取焦点后页面放大的问题； 修复一些文章或 UI 显示问题； v1.0.1 调整 css、js 的文件请求路径在主题的_config.yml中配置，便于你更快捷的配置自己的 CDN； 新增代码是否折行为可配置，默认为折行； 默认激活 TOC 功能，并新增为某篇文章关闭 TOC 的 Front-matter 配置选项； 修复文章滚动时，高亮的目录选项不准确的问题； IOS下移除搜索框自动获得焦点属性，防止自动获得焦点后导致视图上移； v1.0.0 新增了所有基础功能； document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo主题","slug":"Hexo主题","permalink":"https://niuxvdong.top/categories/Hexo%E4%B8%BB%E9%A2%98/"}],"tags":[{"name":"matery","slug":"matery","permalink":"https://niuxvdong.top/tags/matery/"}],"author":"Mr.Niu"},{"title":"Hexo中引入音乐和视频","slug":"Hexo中引入音乐和视频","date":"2020-02-03T13:06:43.000Z","updated":"2020-02-03T13:06:43.000Z","comments":true,"path":"posts/14163.html","link":"","permalink":"https://niuxvdong.top/posts/14163.html","excerpt":"","text":"1、通过网易云网站引入外链HTML代码: 如图所示，复制当中的HTML代码即可。效果如下: 2、通过B站来引入外链HTML代码: 如图所示，复制当中的HTML代码即可。效果如下: 3、通过Hexo的插件来引用音乐: hexo-tag-aplayer： 点击这里！ hexo-tag-dplayer： 点击这里！ 通过npm来安装两个插件： 1234$ npm install hexo-tag-aplayer --save$ npm install hexo-tag-dplayer --save 第一种：meting后面根歌单id。例如 :https://music.163.com/playlist?id=523845661&amp;userid=46562117 ，这个歌 单的id就是523845661，公司名可以是tencent、netease或是其他公司。 最新版的 hexo-tag-aplayer 已经支持了MetingJS的使用，可以直接解析网络平台的歌曲，在站点配置文件_config.yml中将aplayer的meting属性开启。 123aplayer: meting: true 参考文章：点击这里！ 有关细节及参数，点击这里！ 1{% meting \"523845661\" \"netease\" \"playlist\" \"theme:#FF4081\" \"mode:circulation\" \"mutex:true\" \"listmaxheight:340px\" \"preload:auto\" %} 第二种：写上名字，歌手，链接地址即可。 参考文章：点击这里！ 1{% aplayer \"她的睫毛\" \"周杰伦\" \"https://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3\" \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\" \"autoplay=false\" %} var ap = new APlayer({ element: document.getElementById(\"aplayer-bBDTXmkL\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"她的睫毛\", author: \"周杰伦\", url: \"https://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3\", pic: \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 通过meting 和 aplayer 的引用，无法同时使用，都在的时候，只能加载meting!4、通过Hexo的插件来引用视频:效果如下: 12{% dplayer \"url=http://home.ustc.edu.cn/~mmmwhy/GEM.mp4\" \"pic=http://home.ustc.edu.cn/~mmmwhy/GEM.jpg\" \"loop=yes\" \"theme=#FADFA3\" \"autoplay=false\" \"token=tokendemo\" %} (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"http://home.ustc.edu.cn/~mmmwhy/GEM.mp4\",\"pic\":\"http://home.ustc.edu.cn/~mmmwhy/GEM.jpg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://niuxvdong.top/categories/Hexo/"}],"tags":[{"name":"aplayer","slug":"aplayer","permalink":"https://niuxvdong.top/tags/aplayer/"},{"name":"dplayer","slug":"dplayer","permalink":"https://niuxvdong.top/tags/dplayer/"}],"author":"Mr.Niu"},{"title":"用法总结之Markdown","slug":"用法总结之Markdown","date":"2020-02-03T11:36:46.000Z","updated":"2020-02-03T11:36:46.000Z","comments":true,"path":"posts/25708.html","link":"","permalink":"https://niuxvdong.top/posts/25708.html","excerpt":"","text":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。Markdown 编写的文档后缀为 .md, .markdown。 首先来首歌曲来放松一下吧！ 技术支持：Markdown教程|菜鸟教程 注意：Markdown可以使用Html语法及标签 一、编写 Markdown 好用软件1、Typora 优点：可视化很强，写了后回车即可见到真实效果。 2、VS Code 最强大的编辑器，只要安装了对应的插件，即可实现所有的编辑即代码运行调试！ 二、Markdown 语法1、标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 显示效果： 2、段落 Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 12这是段落！ 下一段落... 显示效果： 这是段落！ 下一段落… 3、字体3.1 粗体1**粗体** 显示效果： 粗体 3.2 斜体1*斜体* 显示效果： 斜体 3.3 粗斜体1___粗斜___ 显示效果： 粗斜体 4、分割线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。下面每种写法都可以建立分隔线： 1234567********------------- 显示效果： 5、列表5.1 有序列表 有序列表使用数字并加上 . 号来表示 1231. 第一项2. 第二项3. 第三项 显示效果： 第一项 第二项 第三项 5、2 无序列表 无序列表用 * + -来表示 123456789- 第一项- 第二项- 第三项+ 第一项+ 第二项+ 第三项* 第一项* 第二项* 第三项 显示效果： 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 5.3 列表嵌套1234561. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 显示效果： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 6、区块 Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号. 6.1 普通区块123&gt; 普通区块&gt; hello&gt; 床前明月光 显示效果： 普通区块hello床前明月光 6.2 列表中使用区块1234- 第一层 &gt; 我是Mr.Niu- 第二层 &gt; 你好，世界！ 显示效果： 第一层 我是Mr.Niu 第二层 你好，世界！ 6.3 区块中使用列表123&gt; 第一层 - 我是Mr.Niu - 你好世界！ 显示效果： 第一层 我是Mr.Niu 你好世界！ 6.4 区块嵌套123&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套 显示效果： 最外层 第一层嵌套 第二层嵌套 7、代码7.1 段落内代码1这是`printf()`函数 显示效果： 这是printf()函数！ 7.2 代码块 用 ``` 包裹一段代码，并指定一种语言（也可以不指定）： 1234567891011```c++#include &lt;iostream&gt;using namesapce std;int main(){ cout &lt;&lt; \"hello world!\" &lt;&lt; endl; return 0;}``` 显示效果： 123456789#include &lt;iostream&gt;using namesapce std;int main(){ cout &lt;&lt; \"hello world!\" &lt;&lt; endl; return 0;} 8、链接8.1 普通用法1234567[链接名称](链接地址)[Mr.Niu's Blog](https://niuxvdong.top)或者&lt;https://niuxvdong.top&gt; 显示效果： Mr.Niu’s Blog https://niuxvdong.top 8.2 高级用法：1234567链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 [Baidu][1]这个链接用 niu 作为网址变量 [Blog][niu]然后在文档的结尾为变量赋值（网址） [1]: https://www.baidu.com [niu]: https://niuxvdong.top 显示效果： 链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 Baidu这个链接用 niu 作为网址变量 Blog然后在文档的结尾为变量赋值（网址）： 9、图片 格式如下： 123![alt 属性文本](图片地址)![alt 属性文本](图片地址 \"可选标题\") 1![](https://cdn.jsdelivr.net/gh/niuxvdong/images/img/e%20(2).jpg) 显示效果： 10、表格 Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 格式如下： 1234| 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 显示效果： 表头 表头 单元格 单元格 单元格 单元格 对齐方式： 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 1234|左对齐|右对齐|居中对齐||:----- | -----:|:------:||单元格|单元格|单元格||单元格|单元格|单元格| 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 11、高级技巧（使用HTML）11.1 使用html标签实现键盘按键图标1使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 显示效果： 使用 Ctrl+Alt+Del 重启电脑 11.2 用 \\ 来实现转义 Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： 12**文本加粗** \\*\\* 正常显示星号 \\*\\* 显示效果： 文本加粗** 正常显示星号 ** 可实现的转义字符如下： 123456789101112\\ 反斜线` 反引号* 星号_ 下划线{} 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号 11.3 更多高级用法参考菜鸟教程1234567```mermaidgraph LRA[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 12345678```mermaidgraph LRA[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://niuxvdong.top/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://niuxvdong.top/tags/Markdown/"}],"author":"Mr.Niu"},{"title":"Hello World","slug":"hello-world","date":"2020-01-31T04:21:55.000Z","updated":"2020-01-31T04:21:55.000Z","comments":true,"path":"posts/16107.html","link":"","permalink":"https://niuxvdong.top/posts/16107.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://niuxvdong.top/categories/Hexo/"}],"tags":[{"name":"Doc","slug":"Doc","permalink":"https://niuxvdong.top/tags/Doc/"}]}],"categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://niuxvdong.top/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"数据库","slug":"数据库","permalink":"https://niuxvdong.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JS实战","slug":"JS实战","permalink":"https://niuxvdong.top/categories/JS%E5%AE%9E%E6%88%98/"},{"name":"Java教程","slug":"Java教程","permalink":"https://niuxvdong.top/categories/Java%E6%95%99%E7%A8%8B/"},{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/categories/AcWing/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://niuxvdong.top/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"随笔","slug":"随笔","permalink":"https://niuxvdong.top/categories/%E9%9A%8F%E7%AC%94/"},{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://niuxvdong.top/categories/JavaScript%E6%95%99%E7%A8%8B/"},{"name":"Git","slug":"Git","permalink":"https://niuxvdong.top/categories/Git/"},{"name":"Hexo主题","slug":"Hexo主题","permalink":"https://niuxvdong.top/categories/Hexo%E4%B8%BB%E9%A2%98/"},{"name":"Hexo","slug":"Hexo","permalink":"https://niuxvdong.top/categories/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://niuxvdong.top/categories/Markdown/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://niuxvdong.top/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"链表","slug":"链表","permalink":"https://niuxvdong.top/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://niuxvdong.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"哈希表","slug":"哈希表","permalink":"https://niuxvdong.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"修改","slug":"修改","permalink":"https://niuxvdong.top/tags/%E4%BF%AE%E6%94%B9/"},{"name":"INSERT","slug":"INSERT","permalink":"https://niuxvdong.top/tags/INSERT/"},{"name":"UPDATE","slug":"UPDATE","permalink":"https://niuxvdong.top/tags/UPDATE/"},{"name":"DELETE","slug":"DELETE","permalink":"https://niuxvdong.top/tags/DELETE/"},{"name":"油猴脚本","slug":"油猴脚本","permalink":"https://niuxvdong.top/tags/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"},{"name":"知乎","slug":"知乎","permalink":"https://niuxvdong.top/tags/%E7%9F%A5%E4%B9%8E/"},{"name":"SELECT","slug":"SELECT","permalink":"https://niuxvdong.top/tags/SELECT/"},{"name":"查询","slug":"查询","permalink":"https://niuxvdong.top/tags/%E6%9F%A5%E8%AF%A2/"},{"name":"SQL","slug":"SQL","permalink":"https://niuxvdong.top/tags/SQL/"},{"name":"MySQL","slug":"MySQL","permalink":"https://niuxvdong.top/tags/MySQL/"},{"name":"加密","slug":"加密","permalink":"https://niuxvdong.top/tags/%E5%8A%A0%E5%AF%86/"},{"name":"安全","slug":"安全","permalink":"https://niuxvdong.top/tags/%E5%AE%89%E5%85%A8/"},{"name":"Regex","slug":"Regex","permalink":"https://niuxvdong.top/tags/Regex/"},{"name":"JUnit","slug":"JUnit","permalink":"https://niuxvdong.top/tags/JUnit/"},{"name":"Date","slug":"Date","permalink":"https://niuxvdong.top/tags/Date/"},{"name":"Time","slug":"Time","permalink":"https://niuxvdong.top/tags/Time/"},{"name":"IO","slug":"IO","permalink":"https://niuxvdong.top/tags/IO/"},{"name":"File","slug":"File","permalink":"https://niuxvdong.top/tags/File/"},{"name":"集合","slug":"集合","permalink":"https://niuxvdong.top/tags/%E9%9B%86%E5%90%88/"},{"name":"泛型","slug":"泛型","permalink":"https://niuxvdong.top/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"注解","slug":"注解","permalink":"https://niuxvdong.top/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"反射","slug":"反射","permalink":"https://niuxvdong.top/tags/%E5%8F%8D%E5%B0%84/"},{"name":"异常处理","slug":"异常处理","permalink":"https://niuxvdong.top/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"String","slug":"String","permalink":"https://niuxvdong.top/tags/String/"},{"name":"JavaBean","slug":"JavaBean","permalink":"https://niuxvdong.top/tags/JavaBean/"},{"name":"包装类型","slug":"包装类型","permalink":"https://niuxvdong.top/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"},{"name":"面向对象","slug":"面向对象","permalink":"https://niuxvdong.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"AcWing","slug":"AcWing","permalink":"https://niuxvdong.top/tags/AcWing/"},{"name":"栈","slug":"栈","permalink":"https://niuxvdong.top/tags/%E6%A0%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://niuxvdong.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"贪心","slug":"贪心","permalink":"https://niuxvdong.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"高精度","slug":"高精度","permalink":"https://niuxvdong.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://niuxvdong.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"堆","slug":"堆","permalink":"https://niuxvdong.top/tags/%E5%A0%86/"},{"name":"排序","slug":"排序","permalink":"https://niuxvdong.top/tags/%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"https://niuxvdong.top/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"倍增","slug":"倍增","permalink":"https://niuxvdong.top/tags/%E5%80%8D%E5%A2%9E/"},{"name":"逆序对","slug":"逆序对","permalink":"https://niuxvdong.top/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"奇偶性","slug":"奇偶性","permalink":"https://niuxvdong.top/tags/%E5%A5%87%E5%81%B6%E6%80%A7/"},{"name":"priority_queue","slug":"priority-queue","permalink":"https://niuxvdong.top/tags/priority-queue/"},{"name":"中位数","slug":"中位数","permalink":"https://niuxvdong.top/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"name":"前缀和","slug":"前缀和","permalink":"https://niuxvdong.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"字典序","slug":"字典序","permalink":"https://niuxvdong.top/tags/%E5%AD%97%E5%85%B8%E5%BA%8F/"},{"name":"字符串","slug":"字符串","permalink":"https://niuxvdong.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"组合数","slug":"组合数","permalink":"https://niuxvdong.top/tags/%E7%BB%84%E5%90%88%E6%95%B0/"},{"name":"二分","slug":"二分","permalink":"https://niuxvdong.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"双指针","slug":"双指针","permalink":"https://niuxvdong.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"差分序列","slug":"差分序列","permalink":"https://niuxvdong.top/tags/%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97/"},{"name":"二维前缀和","slug":"二维前缀和","permalink":"https://niuxvdong.top/tags/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"Dp","slug":"Dp","permalink":"https://niuxvdong.top/tags/Dp/"},{"name":"递推","slug":"递推","permalink":"https://niuxvdong.top/tags/%E9%80%92%E6%8E%A8/"},{"name":"位运算","slug":"位运算","permalink":"https://niuxvdong.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"DFS","slug":"DFS","permalink":"https://niuxvdong.top/tags/DFS/"},{"name":"二进制","slug":"二进制","permalink":"https://niuxvdong.top/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://niuxvdong.top/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"状压Dp","slug":"状压Dp","permalink":"https://niuxvdong.top/tags/%E7%8A%B6%E5%8E%8BDp/"},{"name":"最短路","slug":"最短路","permalink":"https://niuxvdong.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"快速幂","slug":"快速幂","permalink":"https://niuxvdong.top/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"努力","slug":"努力","permalink":"https://niuxvdong.top/tags/%E5%8A%AA%E5%8A%9B/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://niuxvdong.top/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://niuxvdong.top/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"https://niuxvdong.top/tags/DOM/"},{"name":"Data","slug":"Data","permalink":"https://niuxvdong.top/tags/Data/"},{"name":"RegExp","slug":"RegExp","permalink":"https://niuxvdong.top/tags/RegExp/"},{"name":"JSON","slug":"JSON","permalink":"https://niuxvdong.top/tags/JSON/"},{"name":"函数","slug":"函数","permalink":"https://niuxvdong.top/tags/%E5%87%BD%E6%95%B0/"},{"name":"入门","slug":"入门","permalink":"https://niuxvdong.top/tags/%E5%85%A5%E9%97%A8/"},{"name":"基础","slug":"基础","permalink":"https://niuxvdong.top/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"https://niuxvdong.top/tags/Java/"},{"name":"Git","slug":"Git","permalink":"https://niuxvdong.top/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://niuxvdong.top/tags/Github/"},{"name":"matery","slug":"matery","permalink":"https://niuxvdong.top/tags/matery/"},{"name":"aplayer","slug":"aplayer","permalink":"https://niuxvdong.top/tags/aplayer/"},{"name":"dplayer","slug":"dplayer","permalink":"https://niuxvdong.top/tags/dplayer/"},{"name":"Markdown","slug":"Markdown","permalink":"https://niuxvdong.top/tags/Markdown/"},{"name":"Doc","slug":"Doc","permalink":"https://niuxvdong.top/tags/Doc/"}]}