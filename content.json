{"meta":{"title":"小牛博客","subtitle":"每天进步一点点!","description":"一个大学生的博客，记录学习，记录成长，分享生活！","author":"ITNXD","url":"https://www.itnxd.cn","root":"/"},"pages":[{"title":"404","date":"2020-02-05T05:33:10.000Z","updated":"2020-05-09T02:54:08.714Z","comments":true,"path":"404.html","permalink":"https://www.itnxd.cn/404.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"books","date":"2020-02-05T03:09:36.000Z","updated":"2020-05-09T02:54:08.765Z","comments":true,"path":"books/index.html","permalink":"https://www.itnxd.cn/books/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2020-02-02T04:27:52.000Z","updated":"2020-05-09T02:54:08.764Z","comments":true,"path":"about/index.html","permalink":"https://www.itnxd.cn/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-02-02T04:26:28.000Z","updated":"2020-05-09T02:54:08.766Z","comments":true,"path":"categories/index.html","permalink":"https://www.itnxd.cn/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2020-02-02T04:29:49.000Z","updated":"2020-05-09T02:54:08.769Z","comments":true,"path":"friends/index.html","permalink":"https://www.itnxd.cn/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-02-02T04:31:45.000Z","updated":"2020-05-09T02:54:08.768Z","comments":true,"path":"contact/index.html","permalink":"https://www.itnxd.cn/contact/index.html","excerpt":"","text":"有什么想说的，可以在下面留言哦，欢迎大家来讨论！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"galleries","date":"2020-02-05T03:27:33.000Z","updated":"2020-05-09T02:54:08.769Z","comments":true,"path":"galleries/index.html","permalink":"https://www.itnxd.cn/galleries/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"友情链接","date":"2020-05-18T14:17:49.000Z","updated":"2020-05-18T12:35:28.370Z","comments":true,"path":"link/index.html","permalink":"https://www.itnxd.cn/link/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"musics","date":"2020-02-05T03:08:51.000Z","updated":"2020-05-09T02:54:08.771Z","comments":true,"path":"musics/index.html","permalink":"https://www.itnxd.cn/musics/index.html","excerpt":"","text":"我的歌单 欢迎下方留言自己喜欢的歌单链接！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"movies","date":"2020-02-05T03:09:13.000Z","updated":"2020-05-09T02:54:08.770Z","comments":true,"path":"movies/index.html","permalink":"https://www.itnxd.cn/movies/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2021-09-04T15:41:53.625Z","updated":"2021-09-04T15:41:53.624Z","comments":true,"path":"self/atom-one-light-1.css","permalink":"https://www.itnxd.cn/self/atom-one-light-1.css","excerpt":"","text":"/* Atom One Light by Daniel Gamage Original One Light Syntax theme from https://github.com/atom/one-light-syntax base: #fafafa mono-1: #383a42 mono-2: #686b77 mono-3: #a0a1a7 hue-1: #0184bb hue-2: #4078f2 hue-3: #a626a4 hue-4: #50a14f hue-5: #e45649 hue-5-2: #c91243 hue-6: #986801 hue-6-2: #c18401 */ #article-container .highlight-tools { color: #f47466; background: #FFFFE0; } #article-container figure.highlight .gutter pre { color: #696969; background: #FFFFE0; } /* 背景和前景 */ #article-container pre, #article-container figure.highlight { color: #383a42; background: #FFFFF0; } .comment, .quote { font-style: italic; } .doctag, .keyword, .formula { color: #a626a4; } .section, .name, .selector-tag, .deletion, .subst { color: #e45649; } .literal { color: #0184bb; } .string, .regexp, .addition, .attribute, .meta .string { color: #50a14f; } .attr, .params, .variable, .template-variable, .type, .selector-class, .selector-attr, .selector-pseudo, .number { color: #986801; } .symbol, .bullet, .link, .meta, .selector-id, .title { color: #4078f2; } .built_in, .title.class_, .class .title { color: #c18401 !important; } .emphasis { font-style: italic; } .strong { font-weight: bold; } .link { text-decoration: underline; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2021-09-04T15:50:22.397Z","updated":"2021-09-04T15:50:22.397Z","comments":true,"path":"self/atom-one-light.css","permalink":"https://www.itnxd.cn/self/atom-one-light.css","excerpt":"","text":"/* Atom One Light by Daniel Gamage Original One Light Syntax theme from https://github.com/atom/one-light-syntax base: #fafafa mono-1: #383a42 mono-2: #686b77 mono-3: #a0a1a7 hue-1: #0184bb hue-2: #4078f2 hue-3: #a626a4 hue-4: #50a14f hue-5: #e45649 hue-5-2: #c91243 hue-6: #986801 hue-6-2: #c18401 */ #article-container .highlight-tools { color: #f47466; background: #F5F5F5; } #article-container figure.highlight .gutter pre { color: #696969; background: #fafafa; } #article-container figure.highlight .hljs { color: #383a42; background: #fafafa; } .hljs-comment, .hljs-quote { color: #a0a1a7; font-style: italic; } .hljs-doctag, .hljs-keyword, .hljs-formula { color: #a626a4; } .hljs-section, .hljs-name, .hljs-selector-tag, .hljs-deletion, .hljs-subst { color: #e45649; } .hljs-literal { color: #0184bb; } .hljs-string, .hljs-regexp, .hljs-addition, .hljs-attribute, .hljs-meta .hljs-string { color: #50a14f; } .hljs-attr, .hljs-variable, .hljs-template-variable, .hljs-type, .hljs-selector-class, .hljs-selector-attr, .hljs-selector-pseudo, .hljs-number { color: #986801; } .hljs-symbol, .hljs-bullet, .hljs-link, .hljs-meta, .hljs-selector-id, .hljs-title { color: #4078f2; } .hljs-built_in, .hljs-title.class_, .hljs-class .hljs-title { color: #c18401; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; } .hljs-link { text-decoration: underline; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-02-05T09:18:22.000Z","updated":"2020-05-09T02:54:08.773Z","comments":true,"path":"tags/index.html","permalink":"https://www.itnxd.cn/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"反向代理、负载均衡服务器Nginx入门到精通","slug":"反向代理、负载均衡服务器Nginx入门到精通","date":"2021-09-14T02:16:39.000Z","updated":"2021-09-20T16:18:54.922Z","comments":true,"path":"posts/16211.html","link":"","permalink":"https://www.itnxd.cn/posts/16211.html","excerpt":"","text":"¶一、Nginx简介 ¶1、背景介绍 Nginx（“engine x”）一个具有高性能的【HTTP】和【反向代理】的【WEB服务器】，同时也是一个【POP3/SMTP/IMAP代理服务器】，是由伊戈尔·赛索耶夫(俄罗斯人)使用C语言编写的，Nginx的第一个版本是2004年10月4号发布的0.1.0版本。另外值得一提的是伊戈尔·赛索耶夫将Nginx的源码进行了开源，这也为Nginx的发展提供了良好的保障。 ¶2、名词解释 ¶WEB服务器 WEB服务器也叫网页服务器，英文名叫Web Server，主要功能是为用户提供网上信息浏览服务。 ¶HTTP HTTP是超文本传输协议的缩写，是用于从WEB服务器传输超文本到本地浏览器的传输协议，也是互联网上应用最为广泛的一种网络协议。HTTP是一个客户端和服务器端请求和应答的标准，客户端是终端用户，服务端是网站，通过使用Web浏览器、网络爬虫或者其他工具，客户端发起一个到服务器上指定端口的HTTP请求。 ¶POP3/SMTP/IMAP POP3(Post Offic Protocol 3)邮局协议的第三个版本， SMTP(Simple Mail Transfer Protocol)简单邮件传输协议， IMAP(Internet Mail Access Protocol)交互式邮件存取协议， 通过上述名词的解释，我们可以了解到Nginx也可以作为电子邮件代理服务器。 ¶反向代理 正向代理 反向代理 ¶3、常见服务器对比 ¶IIS ​ 全称(Internet Information Services)即互联网信息服务，是由微软公司提供的基于windows系统的互联网基本服务。windows作为服务器在稳定性与其他一些性能上都不如类UNIX操作系统，因此在需要高性能Web服务器的场合下，IIS可能就会被\"冷落\". ¶Tomcat ​ Tomcat是一个运行Servlet和JSP的Web应用软件，Tomcat技术先进、性能稳定而且开放源代码，因此深受Java爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器。但是Tomcat天生是一个重量级的Web服务器，对静态文件和高并发的处理比较弱。 ¶Apache ​ Apache的发展时期很长，同时也有过一段辉煌的业绩。从上图可以看出大概在2014年以前都是市场份额第一的服务器。Apache有很多优点，如稳定、开源、跨平台等。但是它出现的时间太久了，在它兴起的年代，互联网的产业规模远远不如今天，所以它被设计成一个重量级的、不支持高并发的Web服务器。在Apache服务器上，如果有数以万计的并发HTTP请求同时访问，就会导致服务器上消耗大量能存，操作系统内核对成百上千的Apache进程做进程间切换也会消耗大量的CUP资源，并导致HTTP请求的平均响应速度降低，这些都决定了Apache不可能成为高性能的Web服务器。这也促使了Lighttpd和Nginx的出现。 ¶Lighttpd ​ Lighttpd是德国的一个开源的Web服务器软件，它和Nginx一样，都是轻量级、高性能的Web服务器，欧美的业界开发者比较钟爱Lighttpd,而国内的公司更多的青睐Nginx，同时网上Nginx的资源要更丰富些。 ¶其他的服务器 Google Servers，Weblogic, Webshpere(IBM)… 经过各个服务器的对比，种种迹象都表明，Nginx将以性能为王。这也是我们为什么选择Nginx的理由。 ¶4、Nginx的优点 ¶速度更快、并发更高 单次请求或者高并发请求的环境下，Nginx都会比其他Web服务器响应的速度更快。一方面在正常情况下，单次请求会得到更快的响应，另一方面，在高峰期(如有数以万计的并发请求)，Nginx比其他Web服务器更快的响应请求。Nginx之所以有这么高的并发处理能力和这么好的性能原因在于Nginx采用了多进程和I/O多路复用(epoll)的底层实现。 ¶配置简单，扩展性强 Nginx的设计极具扩展性，它本身就是由很多模块组成，这些模块的使用可以通过配置文件的配置来添加。这些模块有官方提供的也有第三方提供的模块，如果需要完全可以开发服务自己业务特性的定制模块。 ¶高可靠性 Nginx采用的是多进程模式运行，其中有一个master主进程和N多个worker进程，worker进程的数量我们可以手动设置，每个worker进程之间都是相互独立提供服务，并且master主进程可以在某一个worker进程出错时，快速去\"拉起\"新的worker进程提供服务。 ¶热部署 现在互联网项目都要求以7*24小时进行服务的提供，针对于这一要求，Nginx也提供了热部署功能，即可以在Nginx不停止的情况下，对Nginx进行文件升级、更新配置和更换日志文件等功能。 ¶成本低、BSD许可证 BSD是一个开源的许可证，世界上的开源许可证有很多，现在比较流行的有六种分别是GPL、BSD、MIT、Mozilla、Apache、LGPL。这六种的区别是什么，我们可以通过下面一张图来解释下： Nginx本身是开源的，我们不仅可以免费的将Nginx应用在商业领域，而且还可以在项目中直接修改Nginx的源码来定制自己的特殊要求。这些点也都是Nginx为什么能吸引无数开发者继续为Nginx来贡献自己的智慧和青春。OpenRestry [Nginx+Lua] Tengine[淘宝] ¶5、Nginx的功能特性及常用功能 Nginx提供的基本功能服务从大体上归纳为\"基本HTTP服务\"、“高级HTTP服务”和\"邮件服务\"等三大类。 ¶基本HTTP服务 Nginx可以提供基本HTTP服务，可以作为HTTP代理服务器和反向代理服务器，支持通过缓存加速访问，可以完成简单的负载均衡和容错，支持包过滤功能，支持SSL等。 处理静态文件、处理索引文件以及支持自动索引； 提供反向代理服务器，并可以使用缓存加上反向代理，同时完成负载均衡和容错； 提供对FastCGI、memcached等服务的缓存机制，，同时完成负载均衡和容错； 使用Nginx的模块化特性提供过滤器功能。Nginx基本过滤器包括gzip压缩、ranges支持、chunked响应、XSLT、SSI以及图像缩放等。其中针对包含多个SSI的页面，经由FastCGI或反向代理，SSI过滤器可以并行处理。 支持HTTP下的安全套接层安全协议SSL. 支持基于加权和依赖的优先权的HTTP/2 ¶高级HTTP服务 支持基于名字和IP的虚拟主机设置 支持HTTP/1.0中的KEEP-Alive模式和管线(PipeLined)模型连接 自定义访问日志格式、带缓存的日志写操作以及快速日志轮转。 提供3xx~5xx错误代码重定向功能 支持重写（Rewrite)模块扩展 支持重新加载配置以及在线升级时无需中断正在处理的请求 支持网络监控 支持FLV和MP4流媒体传输 ¶邮件服务 Nginx提供邮件代理服务也是其基本开发需求之一，主要包含以下特性： 支持IMPA/POP3代理服务功能 支持内部SMTP代理服务功能 ¶Nginx常用的功能模块 12345678910静态资源部署Rewrite地址重写 正则表达式反向代理负载均衡 轮询、加权轮询、ip_hash、url_hash、fairWeb缓存环境部署 高可用的环境用户认证模块... ¶Nginx的核心组成 1234nginx二进制可执行文件nginx.conf配置文件error.log错误的日志记录access.log访问日志记录 ¶二、Nginx环境准备 ¶1、Nginx版本介绍 Nginx的官方网站为: https://nginx.org，Nginx的官方下载网站为 https://nginx.org/en/download.html ¶2、获取Nginx源码 http://nginx.org/download/ 打开上述网站，就可以查看到Nginx的所有版本，选中自己需要的版本进行下载。 ¶3、准备服务器系统 确认centos的内核： 准备一个内核为2.6及以上版本的操作系统，因为linux2.6及以上内核才支持epoll,而Nginx需要解决高并发压力问题是需要用到epoll，所以我们需要有这样的版本要求。 我们可以使用uname -a命令来查询linux的内核版本。 确认停用selinux： selinux(security-enhanced linux),美国安全局对于强制访问控制的实现，在linux2.6内核以后的版本中，selinux已经成功内核中的一部分。可以说selinux是linux史上最杰出的新安全子系统之一。虽然有了selinux，我们的系统会更安全，但是对于我们的学习Nginx的历程中，会多很多设置，所以这块建议大家将selinux进行关闭。 sestatus查看状态： 如果查看不是disabled状态，我们可以通过修改配置文件来进行设置,修改SELINUX=disabled，然后重启下系统即可生效。 1vim /etc/selinux/config ¶4、Nginx安装方式即依赖介绍 Nginx的安装方式有两种分别是: 1234通过Nginx源码 通过Nginx源码简单安装 (1) 通过Nginx源码复杂安装 (3)通过yum安装 (2) 如果通过Nginx源码安装需要提前安装以下依赖： GCC编译器： Nginx是使用C语言编写的程序，因此想要运行Nginx就需要安装一个编译工具。GCC就是一个开源的编译器集合，用于处理各种各样的语言，其中就包含了C语言。 使用命令yum install -y gcc来安装 安装成功后，可以通过gcc --version来查看gcc是否安装成功 PCRE： Nginx在编译过程中需要使用到PCRE库（perl Compatible Regular Expressoin 兼容正则表达式库)，因为在Nginx的Rewrite模块和http核心模块都会使用到PCRE正则表达式语法。 可以使用命令yum install -y pcre pcre-devel来进行安装 安装成功后，可以通过rpm -qa pcre pcre-devel来查看是否安装成功 zlib： zlib库提供了开发人员的压缩算法，在Nginx的各个模块中需要使用gzip压缩，所以我们也需要提前安装其库及源代码zlib和zlib-devel 可以使用命令yum install -y zlib zlib-devel来进行安装 安装成功后，可以通过rpm -qa zlib zlib-devel来查看是否安装成功 OpenSSL： OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包进行安全通信，并且避免被窃听。 SSL：Secure Sockets Layer安全套接协议的缩写，可以在Internet上提供秘密性传输，其目标是保证两个应用间通信的保密性和可靠性。在Nginx中，如果服务器需要提供安全网页时就需要用到OpenSSL库，所以我们需要对OpenSSL的库文件及它的开发安装包进行一个安装。 可以使用命令yum install -y openssl openssl-devel来进行安装 安装成功后，可以通过rpm -qa openssl openssl-devel来查看是否安装成功 上述命令，一个个来的话比较麻烦，我们也可以通过一条命令来进行安装： yum install -y gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel进行全部安装。 ¶5、Nginx的源码简单安装 1、进入官网查找需要下载版本的链接地址，然后使用wget命令进行下载 1wget http://nginx.org/download/nginx-1.16.1.tar.gz 2、建议大家将下载的资源进行包管理 1mkdir -p nginx/coremv nginx-1.16.1.tar.gz nginx/core 3、解压缩 1tar -xzf nginx-1.16.1.tar.gz 4、进入资源文件中，发现configure 1./configure 5、编译 1make &amp;&amp; make install ¶6、yum安装 使用源码进行简单安装，我们会发现安装的过程比较繁琐，需要提前准备GCC编译器、PCRE兼容正则表达式库、zlib压缩库、OpenSSL安全通信的软件库包，然后才能进行Nginx的安装。官方文档yum安装介绍：https://nginx.org/en/linux_packages.html#RHEL-CentOS 1、安装yum-utils 1sudo yum install -y yum-utils 2、添加yum源文件 1vim /etc/yum.repos.d/nginx.repo 123456789101112131415[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true 3、查看是否配置成功 1yum list | grep nginx 4、使用yum进行安装 1yun install -y nginx 5、查看nginx的安装位置 1whereis nginx ¶7、源码简单安装和yum安装的差异 这里先介绍一个命令: ./nginx -V, 通过该命令可以查看到所安装Nginx的版本及相关配置信息。 简单安装： yum安装： ¶8、Nginx的源码复杂安装 这种方式和简单的安装配置不同的地方在第一步，通过./configure来对编译参数进行设置，需要我们手动来指定。那么都有哪些参数可以进行设置，接下来我们进行一个详细的说明。 ·/configure --help可以获得一些配置项参数： PATH：是和路径相关的配置信息 with：是启动模块，默认是关闭的 without：是关闭模块，默认是开启的 一些简单的路径配置已经通过这些配置来完成一个简单的编译： –prefix=PATH 1指向Nginx的安装目录，默认值为/usr/local/nginx –sbin-path=PATH 1指向(执行)程序文件(nginx)的路径,默认值为&lt;prefix&gt;/sbin/nginx –modules-path=PATH 1指向Nginx动态模块安装目录，默认值为&lt;prefix&gt;/modules –conf-path=PATH 1指向配置文件(nginx.conf)的路径,默认值为&lt;prefix&gt;/conf/nginx.conf –error-log-path=PATH 1指向错误日志文件的路径,默认值为&lt;prefix&gt;/logs/error.log –http-log-path=PATH 1指向访问日志文件的路径,默认值为&lt;prefix&gt;/logs/access.log –pid-path=PATH 1指向Nginx启动后进行ID的文件路径，默认值为&lt;prefix&gt;/logs/nginx.pid –lock-path=PATH 1指向Nginx锁文件的存放路径,默认值为&lt;prefix&gt;/logs/nginx.lock 要想使用可以通过如下命令： 这里的值就是源码简单安装的默认值！ 1./configure --prefix=/usr/local/nginx \\--sbin-path=/usr/local/nginx/sbin/nginx \\--modules-path=/usr/local/nginx/modules \\--conf-path=/usr/local/nginx/conf/nginx.conf \\--error-log-path=/usr/local/nginx/logs/error.log \\--http-log-path=/usr/local/nginx/logs/access.log \\--pid-path=/usr/local/nginx/logs/nginx.pid \\--lock-path=/usr/local/nginx/logs/nginx.lock 在使用上述命令之前，需要将之前服务器已经安装的nginx进行卸载，卸载的步骤分为三步骤： 步骤一：需要将nginx的进程关闭 1./nginx -s stop 步骤二：将安装的nginx进行删除 1rm -rf /usr/local/nginx 步骤三：将安装包之前编译的环境清除掉 1make clean ¶9、解压Nginx目录介绍 执行tar -zxvf nginx-1.16.1.tar.gz对下载的资源进行解压缩，进入压缩后的目录，可以看到如下结构： 内容解释： auto：存放的是编译相关的脚本 CHANGES：版本变更记录 CHANGES.ru：俄罗斯文的版本变更记录 conf：默认的配置文件 configure：nginx软件的自动脚本程序,是一个比较重要的文件，作用如下： 检测环境及根据环境检测结果生成C代码（会在当前目录下多一个objs文件夹） 生成编译代码需要的Makefile文件（会在当前目录下多一个Makefile文件） contrib：存放的是几个特殊的脚本文件，其中README中对脚本有着详细的说明 html：存放的是Nginx自带的两个html页面，访问Nginx的首页和错误页面 LICENSE：许可证的相关描述文件 man：nginx的man手册 README：Nginx的阅读指南 src：Nginx的源代码 ¶10、Nginx目录结构分析 在使用Nginx之前，我们先对安装好的Nginx目录文件进行一个分析，在这块给大家介绍一个工具tree，通过tree我们可以很方面的去查看centos系统上的文件目录结构，当然，如果想使用tree工具，就得先通过yum install -y tree来进行安装，安装成功后，可以通过执行tree /usr/local/nginx(tree后面跟的是Nginx的安装目录)，获取的结果如下： conf：nginx所有配置文件目录 CGI(Common Gateway Interface)通用网关【接口】，主要解决的问题是从客户端发送一个请求和数据，服务端获取到请求和数据后可以调用调用CGI【程序】处理及相应结果给客户端的一种标准规范。 fastcgi.conf：fastcgi相关配置文件 fastcgi.conf.default：fastcgi.conf的备份文件 fastcgi_params：fastcgi的参数文件 fastcgi_params.default：fastcgi的参数备份文件 scgi_params：scgi的参数文件 scgi_params.default：scgi的参数备份文件 uwsgi_params：uwsgi的参数文件 uwsgi_params.default：uwsgi的参数备份文件 mime.types：记录的是HTTP协议中的Content-Type的值和文件后缀名的对应关系 mime.types.default：mime.types的备份文件 nginx.conf：这个是Nginx的核心配置文件，这个文件非常重要，也是我们即将要学习的重点 nginx.conf.default：nginx.conf的备份文件 koi-utf、koi-win、win-utf：这三个文件都是与编码转换映射相关的配置文件，用来将一种编码转换成另一种编码 html：存放nginx自带的两个静态的html页面 50x.html：访问失败后的失败页面 index.html：成功访问的默认首页 logs：记录入门的文件，当nginx服务器启动后，这里面会有 access.log error.log 和 nginx.pid 三个文件出现。 sbin：是存放执行程序文件nginx。nginx是用来控制Nginx的启动和停止等相关的命令。 ¶11、Nginx服务器启停命令 Nginx安装完成后，接下来我们要学习的是如何启动、重启和停止Nginx的服务。 对于Nginx的启停在linux系统中也有很多种方式： Nginx服务的信号控制 Nginx的命令行控制 ¶Nginx服务的信号控制 前面在提到Nginx的高性能，其实也和它的架构模式有关。Nginx默认采用的是多进程的方式来工作的，当将Nginx启动后，我们通过ps -ef | grep nginx命令可以查看到如下内容： 从上图中可以看到,Nginx后台进程中包含一个master进程和多个worker进程。 master进程主要用来管理worker进程，包含接收外界的信息，并将接收到的信号发送给各个worker进程，监控worker进程的状态，当worker进程出现异常退出后，会自动重新启动新的worker进程。 而worker进程则是专门用来处理用户请求的，各个worker进程之间是平等的并且相互独立，处理请求的机会也是一样的。nginx的进程模型，我们可以通过下图来说明下： 我们现在作为管理员，只需要通过给master进程发送信号就可以来控制Nginx，这个时候我们需要有两个前提条件，一个是要操作的master进程，一个是信号。 1、要想操作Nginx的master进程，就需要获取到master进程的进程号ID。获取方式简单介绍两个， 方式一：通过ps -ef | grep nginx； 方式二：在讲解nginx的./configure的配置参数的时候，有一个参数是--pid-path=PATH默认是/usr/local/nginx/logs/nginx.pid,所以可以通过查看该文件来获取nginx的master进程ID. 2、信号 信号 作用 TERM/INT 立即关闭整个服务 QUIT \"优雅\"地关闭整个服务（等待worker处理完毕任务后再关闭） HUP 重读配置文件并使用服务对新配置项生效 USR1 重新打开日志文件，可以用来进行日志切割 USR2 平滑升级到最新版的nginx WINCH 所有子进程不在接收处理新连接，相当于给work进程发送QUIT指令 调用命令为kill -signal PID signal：即为信号；PID即为获取到的master线程ID 发送TERM/INT信号给master进程，会将Nginx服务立即关闭： 1kill -TERM PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`kill -INT PID / kill -INT `cat /usr/local/nginx/logs/nginx.pid` 发送QUIT信号给master进程，master进程会控制所有的work进程不再接收新的请求，等所有请求处理完后，在把进程都关闭掉： 1kill -QUIT PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid` 发送HUP信号给master进程，master进程会把控制旧的work进程不再接收新的请求，等处理完请求后将旧的work进程关闭掉，然后根据nginx的配置文件重新启动新的work进程： 1kill -HUP PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid` 发送USR1信号给master进程，告诉Nginx重新开启日志文件 1kill -USR1 PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid` 发送USR2信号给master进程，告诉master进程要平滑升级，这个时候，会重新开启对应的master进程和work进程，整个系统中将会有两个master进程，并且新的master进程的PID会被记录在/usr/local/nginx/logs/nginx.pid而之前的旧的master进程PID会被记录在/usr/local/nginx/logs/nginx.pid.oldbin文件中，接着再次发送QUIT信号给旧的master进程，让其处理完请求后再进行关闭 123kill -USR2 PID / kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`kill -QUIT PID / kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin` 发送WINCH信号给master进程,让master进程控制不让所有的work进程在接收新的请求了，请求处理完后关闭work进程。注意master进程不会被关闭掉 1kill -WINCH PID /kill -WINCH`cat /usr/local/nginx/logs/nginx.pid` ¶Nginx的命令行控制 此方式是通过Nginx安装目录下的sbin下的可执行文件nginx来进行Nginx状态的控制，我们可以通过nginx -h来查看都有哪些参数可以用： -?和-h：显示帮助信息 -v：打印版本号信息并退出 -V：打印版本号信息和配置信息并退出 -t：测试nginx的配置文件语法是否正确并退出 -T：测试nginx的配置文件语法是否正确并列出用到的配置文件信息然后退出 -q：在配置测试期间禁止显示非错误消息 -s：signal信号，后面可以添加 stop：快速关闭，类似于TERM/INT信号的作用 quit：优雅的关闭，类似于QUIT信号的作用 reopen：重新打开日志文件类似于USR1信号的作用 reload：类似于HUP信号的作用 -p：prefix，指定Nginx的prefix路径，(默认为: /usr/local/nginx/) -c：filename,指定Nginx的配置文件路径,(默认为: /usr/local/nginx/conf/nginx.conf) -g：用来补充Nginx配置文件，向Nginx服务指定启动时应用全局的配置 ¶12、Nginx服务器版本升级和新增模块 如果想对Nginx的版本进行更新，或者要应用一些新的模块，最简单的做法就是停止当前的Nginx服务，然后开启新的Nginx服务。但是这样会导致在一段时间内，用户是无法访问服务器。为了解决这个问题，我们就需要用到Nginx服务器提供的平滑升级功能。这个也是Nginx的一大特点，使用这种方式，就可以使Nginx在7*24小时不间断的提供服务了。接下来我们分析下需求： 1需求：Nginx的版本最开始使用的是Nginx-1.14.2,由于服务升级，需要将Nginx的版本升级到Nginx-1.16.1,要求Nginx不能中断提供服务。 为了应对上述的需求，提供两种解决方案: 使用Nginx服务信号完成Nginx的升级 使用Nginx安装目录的make命令完成升级 环境准备： 1、先准备两个版本的Nginx分别是 1.14.2和1.16.1 2、使用Nginx源码安装的方式将1.14.2版本安装成功并正确访问 1进入安装目录./configuremake &amp;&amp; make install 3、将Nginx1.16.1进行参数配置和编译，不需要进行安装。 1进入安装目录./configuremake ¶使用Nginx服务信号进行升级 1、将1.14.2版本的sbin目录下的nginx进行备份 1cd /usr/local/nginx/sbinmv nginx nginxold 2、将Nginx1.16.1安装目录编译后的objs目录下的nginx文件，拷贝到原来/usr/local/nginx/sbin目录下 1cd ~/nginx/core/nginx-1.16.1/objscp nginx /usr/local/nginx/sbin 3、发送信号USR2给Nginx的1.14.2版本对应的master进程 1kill -USR2 `more /usr/local/logs/nginx.pid.oldbin` 4、发送信号QUIT给Nginx的1.14.2版本对应的master进程 1kill -QUIT `more /usr/local/logs/nginx.pid.oldbin` ¶使用Nginx安装目录的make命令完成升级 1、将1.14.2版本的sbin目录下的nginx进行备份 1cd /usr/local/nginx/sbinmv nginx nginxold 2、将Nginx1.16.1安装目录编译后的objs目录下的nginx文件，拷贝到原来/usr/local/nginx/sbin目录下 1cd ~/nginx/core/nginx-1.16.1/objscp nginx /usr/local/nginx/sbin 3、进入到安装目录，执行make upgrade 会发现其实底层使用的也是信号控制的！ 4、查看是否更新成功 1./nginx -v ¶三、Nginx核心配置文件结构 Nginx的核心配置文件默认位置：/usr/local/nginx/conf/nginx.conf ¶1、配置文件介绍 读取Nginx自带的Nginx配置文件，我们将其中的注释部分删除掉后，就剩下下面内容： 1234567891011121314151617181920212223242526worker_processes 1;events { worker_connections 1024;}http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } }} 简单小结下： nginx.conf配置文件中默认有三大块：全局块、events块、http块 http块中可以配置多个server块，每个server块又可以配置多个location块。 ¶2、全局块 ¶user指令 user用于配置运行Nginx服务器的worker进程的用户和用户组。 语法 user user [group] 默认值 nobody 位置 全局块 该属性也可以在编译的时候指定，语法如下./configure --user=user --group=group,如果两个地方都进行了设置，最终生效的是配置文件中的配置。 该指令的使用步骤: 1、设置一个用户信息\"www\" 1user www; 此时使用命令./nginx -t检查会发现报错，原因是本机目前还没有www用户！ 2、Linux创建一个用户 1useradd www 3、创建/root/html/index.html页面，添加如下内容 4、修改nginx.conf 1234location / { root /root/html; index index.html index.htm;} 5、测试启动访问 1页面会报403拒绝访问的错误，因为当前用户没有访问/root/html目录的权限 6、将文件创建到 /home/www/html/index.html,修改配置 1234location / { root /home/www/html; index index.html index.htm;} 7、再次测试正常启动访问 综上所述，使用user指令可以指定启动运行工作进程的用户及用户组，这样对于系统的权限访问控制的更加精细，也更加安全。 ¶work process指令 master_process：用来指定是否开启工作进程。（修改该值需要重启nginx） 语法 master_process on|off; 默认值 master_process on; 位置 全局块 worker_processes：用于配置Nginx生成工作进程的数量，这个是Nginx服务器实现并发处理服务的关键所在。理论上来说workder process的值越大，可以支持的并发处理量也越多，但事实上这个值的设定是需要受到来自服务器自身的限制，建议将该值和服务器CPU的内核数保存一致。 语法 worker_processes num/auto; 默认值 1 位置 全局块 如果将worker_processes设置成2，则会看到如下内容: ¶其他指令 1、daemon：设定Nginx是否以守护进程的方式启动。 守护式进程是linux后台执行的一种服务进程，特点是独立于控制终端，不会随着终端关闭而停止。（也需要重启生效） 语法 daemon on|off; 默认值 daemon on; 位置 全局块 2、pid：用来配置Nginx当前master进程的进程号ID存储的文件路径。 语法 pid file; 默认值 默认为:/usr/local/nginx/logs/nginx.pid 位置 全局块 该属性可以通过./configure --pid-path=PATH来指定 3、error_log：用来配置Nginx的错误日志存放路径 语法 error_log file [日志级别]; 默认值 error_log logs/error.log error; 位置 全局块、http、server、location 该属性可以通过./configure --error-log-path=PATH来指定 其中日志级别的值有：debug|info|notice|warn|error|crit|alert|emerg，翻译过来为试|信息|通知|警告|错误|临界|警报|紧急，这块建议大家设置的时候不要设置成info以下的等级，因为会带来大量的磁盘I/O消耗，影响Nginx的性能。 4、include：用来引入其他配置文件，使Nginx的配置更加灵活 语法 include file; 默认值 无 位置 any ¶3、events块 1、accept_mutex：用来设置Nginx网络连接序列化 语法 accept_mutex on|off; 默认值 accept_mutex on; 位置 events 这个配置主要可以用来解决常说的**\"惊群\"问题。大致意思是在某一个时刻，客户端发来一个请求连接，Nginx后台是以多进程的工作模式，也就是说有多个worker进程会被同时唤醒，但是最终只会有一个进程可以获取到连接**，如果每次唤醒的进程数目太多，就会影响Nginx的整体性能。如果将上述值设置为on(开启状态)，将会对多个Nginx进程接收连接进行序列号，一个个来唤醒接收，就防止了多个进程对连接的争抢。（高并发时关闭更好！） 2、multi_accept：用来设置是否允许同时接收多个网络连接 语法 multi_accept on|off; 默认值 multi_accept off; 位置 events 如果multi_accept被禁止了，nginx一个工作进程只能同时接受一个新的连接。否则，一个工作进程可以同时接受所有的新连接 3、worker_connections：用来配置单个worker进程最大的连接数 语法 worker_connections number; 默认值 worker_commections 512; 位置 events 这里的连接数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数。另外，number值不能大于操作系统支持打开的最大文件句柄数量。 4、use：用来设置Nginx服务器选择哪种事件驱动来处理网络消息。 语法 use method; 默认值 根据操作系统定 位置 events 注意：此处所选择事件处理模型是Nginx优化部分的一个重要内容，method的可选值有select/poll/epoll/kqueue等，之前在准备centos环境的时候，我们强调过要使用linux内核在2.6以上，就是为了能使用epoll函数来优化Nginx。 另外这些值的选择，我们也可以在编译的时候使用 --with-select_module、--without-select_module、 --with-poll_module、 --without-poll_module 来设置是否需要将对应的事件驱动模块编译到Nginx的内核。 events指令配置实例： 打开Nginx的配置文件 nginx.conf,添加如下配置 123456events{ accept_mutex on; multi_accept on; worker_commections 1024; use epoll;} 启动测试 12./nginx -t./nginx -s reload ¶4、http块 MIME-Type： 我们都知道浏览器中可以显示的内容有HTML、XML、GIF等种类繁多的文件、媒体等资源，浏览器为了区分这些资源，就需要使用MIME Type。所以说MIME Type是网络资源的媒体类型。Nginx作为web服务器，也需要能够识别前端请求的资源类型。 在Nginx的配置文件中，默认有两行配置： 12include mime.types;default_type application/octet-stream;（表示是二进制流，浏览器会下载该文件） default_type：用来配置Nginx响应前端请求默认的MIME类型。 语法 default_type mime-type; 默认值 default_type text/plain； 位置 http、server、location 在default_type之前还有一句include mime.types,include之前我们已经介绍过，相当于把mime.types文件中MIMT类型与相关类型文件的文件后缀名的对应关系加入到当前的配置文件中。 举例来说明： 有些时候请求某些接口的时候需要返回指定的文本字符串或者json字符串，如果逻辑非常简单或者干脆是固定的字符串，那么可以使用nginx快速实现，这样就不用编写程序响应请求了，可以减少服务器资源占用并且响应性能非常快。 例子： 12345678910location /get_text { #这里也可以设置成text/plain # 二者区别：plain不会解析html标签，html会解析html标签 default_type text/html; return 200 \"&lt;h1&gt;this is nginx's text!&lt;/h1&gt;\";}location /get_json{ default_type application/json; return 200 '{\"name\":\"TOM\",\"age\":18}';} ¶5、自定义服务日志 Nginx中日志的类型分access.log、error.log。 access.log：用来记录用户所有的访问请求。 error.log：记录nginx本身运行时的错误信息，不会记录用户的访问请求。 Nginx服务器支持对服务日志的格式、大小、输出等进行设置，需要使用到两个指令，分别是access_log和log_format指令。 1、access_log：用来设置用户访问日志的相关属性。 语法 access_log path[format[buffer=size]] 默认值 access_log logs/access.log combined; 位置 http, server, location 2、log_format：用来指定日志的输出格式。 语法 log_format name [escape=default|json|none] string…; 默认值 log_format combined “…”; 位置 http ¶6、其他配置指令 1、sendfile：用来设置Nginx服务器是否使用sendfile()传输文件，该属性可以大大提高Nginx处理静态资源的性能 语法 sendfile on|off； 默认值 sendfile off; 位置 http、server、location 2、keepalive_timeout：用来设置长连接的超时时间。 为什么要使用keepalive？ 12我们都知道HTTP是一种无状态协议，客户端向服务端发送一个TCP请求，服务端响应完毕后断开连接。如何客户端向服务端发送多个请求，每个请求都需要重新创建一次连接，效率相对来说比较多，使用keepalive模式，可以告诉服务器端在处理完一个请求后保持这个TCP连接的打开状态，若接收到来自这个客户端的其他请求，服务端就会利用这个未被关闭的连接，而不需要重新创建一个新连接，提升效率，但是这个连接也不能一直保持，这样的话，连接如果过多，也会是服务端的性能下降，这个时候就需要我们进行设置其的超时时间。 语法 keepalive_timeout time; 默认值 keepalive_timeout 75s; 位置 http、server、location 3、keepalive_requests：用来设置一个keep-alive连接使用的次数。 语法 keepalive_requests number; 默认值 keepalive_requests 100; 位置 http、server、location ¶7、server块和location块 server块和location块，非常重要，后面介绍！ 12345678910111213server { listen 80; server_name localhost; location / { root html; index index.html index.htm; } error_page 500 502 503 504 404 /50x.html; location = /50x.html { root html; } } ¶四、Nginx服务器基础配置实例 ¶1、目标需求 需求： 1234567891011121314（1）有如下访问： http://192.168.200.133:8081/server1/location1 访问的是：index_sr1_location1.html http://192.168.200.133:8081/server1/location2 访问的是：index_sr1_location2.html http://192.168.200.133:8082/server2/location1 访问的是：index_sr2_location1.html http://192.168.200.133:8082/server2/location2 访问的是：index_sr2_location2.html（2）如果访问的资源不存在， 返回自定义的404页面（3）将/server1和/server2的配置使用不同的配置文件分割 将文件放到/home/www/conf.d目录下，然后使用include进行合并（4）为/server1和/server2各自创建一个访问日志文件 准备相关文件，目录如下： ¶2、配置内容 123456789101112131415161718192021222324252627282930313233343536373839404142##全局块 begin###配置允许运行Nginx工作进程的用户和用户组user www;#配置运行Nginx进程生成的worker进程数worker_processes 2;#配置Nginx服务器运行对错误日志存放的路径error_log logs/error.log;#配置Nginx服务器允许时记录Nginx的master进程的PID文件路径和名称pid logs/nginx.pid;#配置Nginx服务是否以守护进程方法启动#daemon on;##全局块 end####events块 begin##events{ #设置Nginx网络连接序列化 accept_mutex on; #设置Nginx的worker进程是否可以同时接收多个请求 multi_accept on; #设置Nginx的worker进程最大的连接数 worker_connections 1024; #设置Nginx使用的事件驱动模型 use epoll;}##events块 end####http块 start##http{ #定义MIME-Type include mime.types; default_type application/octet-stream; #配置允许使用sendfile方式运输 sendfile on; #配置连接超时时间 keepalive_timeout 65; #配置请求处理日志格式 log_format server1 '===&gt;server1 access log'; log_format server2 '===&gt;server2 access log'; ##server块 开始## include /home/www/conf.d/*.conf; ##server块 结束##}##http块 end## server1.conf 123456789101112131415161718192021222324server{ #配置监听端口和主机名称 listen 8081; server_name localhost; #配置请求处理日志存放路径 access_log /home/www/myweb/server1/logs/access.log server1; #配置错误页面 error_page 404 /404.html; #配置处理/server1/location1请求的location location /server1/location1{ root /home/www/myweb; index index_sr1_location1.html; } #配置处理/server1/location2请求的location location /server1/location2{ root /home/www/myweb; index index_sr1_location2.html; } #配置错误页面转向 location = /404.html { root /home/www/myweb; index 404.html; }} server2.conf 123456789101112131415161718192021222324server{ #配置监听端口和主机名称 listen 8082; server_name localhost; #配置请求处理日志存放路径 access_log /home/www/myweb/server2/logs/access.log server2; #配置错误页面,对404.html做了定向配置 error_page 404 /404.html; #配置处理/server1/location1请求的location location /server2/location1{ root /home/www/myweb; index index_sr2_location1.html; } #配置处理/server2/location2请求的location location /server2/location2{ root /home/www/myweb; index index_sr2_location2.html; } #配置错误页面转向 location = /404.html { root /home/www/myweb; index 404.html; } } ¶五、Nginx服务操作的问题 经过前面的操作，我们会发现，如果想要启动、关闭或重新加载nginx配置文件，都需要先进入到nginx的安装目录的sbin目录，然后使用nginx的二级制可执行文件来操作，相对来说操作比较繁琐，这块该如何优化？另外如果我们想把Nginx设置成随着服务器启动就自动完成启动操作。 ¶1、Nginx配置成系统服务 把Nginx应用服务设置成为系统服务，方便对Nginx服务的启动和停止等相关操作。 在/usr/lib/systemd/system目录下添加nginx.service，内容如下: 1vim /usr/lib/systemd/system/nginx.service 12345678910111213141516[Unit]Description=nginx web serviceDocumentation=http://nginx.org/en/docs/After=network.target[Service]Type=forkingPIDFile=/usr/local/nginx/logs/nginx.pidExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.confExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s stopPrivateTmp=true[Install]WantedBy=default.target 添加完成后如果权限有问题需要进行权限设置： 1chmod 755 /usr/lib/systemd/system/nginx.service 使用系统命令来操作Nginx服务： 123456启动: systemctl start nginx停止: systemctl stop nginx重启: systemctl restart nginx重新加载配置文件: systemctl reload nginx查看nginx状态: systemctl status nginx开机启动: systemctl enable nginx ¶2、Nginx命令配置到系统环境 Nginx安装目录下的二级制可执行文件nginx的很多命令，要想使用这些命令前提是需要进入sbin目录下才能使用，我们可以将该二进制可执行文件加入到系统的环境变量，这样的话在任何目录都可以使用nginx对应的相关命令。 1、修改/etc/profile文件 1vim /etc/profile在最后一行添加export PATH=/usr/local/nginx/sbin:$PATH 2、使之立即生效 1source /etc/profile 3、执行nginx命令 1nginx -V ¶六、Nginx静态资源部署 ¶1、Nginx静态资源概述 上网去搜索访问资源对于我们来说并不陌生，通过浏览器发送一个HTTP请求实现从客户端发送请求到服务器端获取所需要内容后并把内容回显展示在页面的一个过程。这个时候，我们所请求的内容就分为两种类型，一类是静态资源、一类是动态资源。 静态资源即指在服务器端真实存在并且能直接拿来展示的一些文件，比如常见的html页面、css文件、js文件、图 片、视频等资源； 动态资源即指在服务器端真实存在但是要想获取需要经过一定的业务逻辑处理，根据不同的条件展示在页面不同这 一部分内容，比如说报表数据展示、根据当前登录用户展示相关具体数据等资源； Nginx处理静态资源的内容，我们需要考虑下面这几个问题： 12345（1）静态资源的配置指令（2）静态资源的配置优化（3）静态资源的压缩配置指令（4）静态资源的缓存处理（5）静态资源的访问控制，包括跨域问题和防盗链问题 ¶2、Nginx静态资源的配置指令 ¶listen指令 listen：用来配置监听端口。 语法 listen address[:port] [default_server]…;listen port [default_server]…; 默认值 listen *:80 | *:8000 位置 server listen设置几种方式： 1234listen 127.0.0.1:8000; # listen localhost:8000 监听指定的IP和端口listen 127.0.0.1; # 监听指定IP的所有端口listen 8000; # 监听指定端口上的连接listen *:8000; # 监听指定端口上的连接 default_server：是标识符，用来将此虚拟主机设置成默认主机。所谓的默认主机指的是如果没有匹配到对应的address:port，则会默认执行的。如果不指定默认使用的是第一个server。 一个问题，server_name设置的是127.0.0.1，但是我们访问的是192内网地址，为何还能访问的到？ 因为default_server的默认值就是找第一个server的配置进行访问，即访问了server_name的配置！我们可以在listen后面添加default_server来指定默认server，即可以不按照第一个默认server去找！按照我们指定的顺序去访问！ 1234567891011121314server{ listen 8080; server_name 127.0.0.1; location /{ root html; index index.html; }}server{ listen 8080 default_server; server_name localhost; default_type text/plain; return 444 'This is a error request';} ¶server_name指令 server_name：用来设置虚拟主机服务名称。127.0.0.1 、 localhost 、域名。 语法 server_name name …;name可以提供多个中间用空格分隔 默认值 server_name “”; 位置 server 配置方式一：精确匹配 12345server { listen 80; server_name www.itcast.cn www.itheima.cn; ...} 配置方式二：使用通配符配置 server_name中支持通配符\"*\", 但需要注意的是通配符不能出现在域名的中间，只能出现在首段或尾段，如： 1234567server { listen 80; server_name *.itcast.cn www.itheima.*; # www.itcast.cn abc.itcast.cn www.itheima.cn www.itheima.com # server_name www.*.cn www.itheima.c* 会报错！ ...} 配置三：使用正则表达式配置 server_name中可以使用正则表达式，并且使用~作为正则表达式字符串的开始标记。 配置如下： 1234567# 注意 ~后面不能加空格，括号可以取值server{ listen 80; server_name ~^www\\.(\\w+)\\.com$; default_type text/plain; return 200 $1 $2 ..;} 匹配执行顺序 由于server_name指令支持通配符和正则表达式，因此在包含多个虚拟主机的配置文件中，可能会出现一个名称被多个虚拟主机的server_name匹配成功，当遇到这种情况，当前的请求交给谁来处理呢？ 12345678910111213141516171819202122232425262728293031323334server{ listen 80; server_name ~^www\\.\\w+\\.com$; default_type text/plain; return 200 'regex_success';}server{ listen 80; server_name www.itheima.*; default_type text/plain; return 200 'wildcard_after_success';}server{ listen 80; server_name *.itheima.com; default_type text/plain; return 200 'wildcard_before_success';}server{ listen 80; server_name www.itheima.com; default_type text/plain; return 200 'exact_success';}server{ listen 80 default_server; server_name _; default_type text/plain; return 444 'default_server not found server';} 结论： 1234567891011exact_successwildcard_before_successwildcard_after_successregex_successdefault_server not found serverNo1:准确匹配server_nameNo2:通配符在开始时匹配server_name成功No3:通配符在结束时匹配server_name成功No4:正则表达式匹配server_name成功No5:被默认的default_server处理，如果没有指定默认找第一个server ¶location指令 location：用来设置请求的URI 语法 location [ = | ~ | ~* | ^~ |@ ] uri{…} 默认值 — 位置 server,location uri变量是待匹配的请求字符串，可以不包含正则表达式，也可以包含正则表达式，那么nginx服务器在搜索匹配location的时候，是先使用不包含正则表达式进行匹配，找到一个匹配度最高的一个，然后在通过包含正则表达式的进行匹配，如果能匹配到直接访问，匹配不到，就使用刚才匹配度最高的那个location来处理请求。 不带符号，要求必须以指定模式开始： 12345678910111213server { listen 80; server_name 127.0.0.1; location /abc{ default_type text/plain; return 200 \"access success\"; }}以下访问都是正确的http://192.168.200.133/abchttp://192.168.200.133/abc?p1=TOMhttp://192.168.200.133/abc/http://192.168.200.133/abcdef = : 用于不包含正则表达式的uri前，必须与指定的模式精确匹配 1234567891011121314server { listen 80; server_name 127.0.0.1; location =/abc{ default_type text/plain; return 200 \"access success\"; }}可以匹配到http://192.168.200.133/abchttp://192.168.200.133/abc?p1=TOM匹配不到http://192.168.200.133/abc/http://192.168.200.133/abcdef ~ ： 用于表示当前uri中包含了正则表达式，并且区分大小写 ~*: 用于表示当前uri中包含了正则表达式，并且不区分大小写 12345678910111213141516server { listen 80; server_name 127.0.0.1; location ~^/abc\\w${ default_type text/plain; return 200 \"access success\"; }}server { listen 80; server_name 127.0.0.1; location ~*^/abc\\w${ default_type text/plain; return 200 \"access success\"; }} ^~: 用于不包含正则表达式的uri前，功能和不加符号的一致，唯一不同的是，如果模式匹配，那么就停止搜索其他模式了。 12345678server { listen 80; server_name 127.0.0.1; location ^~/abc{ default_type text/plain; return 200 \"access success\"; }} ¶root / alias指令 root：设置请求的根目录 语法 root path; 默认值 root html; 位置 http、server、location path为Nginx服务器接收到请求以后查找资源的根目录路径。 alias：用来更改location的URI 语法 alias path; 默认值 — 位置 location path为修改后的根路径。 以上两个指令都可以来指定访问资源的路径，那么这两者之间的区别是什么? 在/usr/local/nginx/html目录下创建一个 images目录,并在目录下放入一张图片mv.png图片 12345678910location /images { root /usr/local/nginx/html;}# /usr/local/nginx/html/images/mv.png# root改为alias 无法访问location /images { alias /usr/local/nginx/html;}# /usr/local/nginx/html/images 总结： root的处理结果是：root路径+location路径。 alias的处理结果是：使用alias路径替换location路径。 alias是一个目录别名的定义，root则是最上层目录的含义。 如果location路径是以/结尾，则alias也必须是以/结尾，root没有要求。（可以在error.log中查看日志得到访问的路径！） 解决： 1234# 改为location /images { alias /usr/local/nginx/html/images;} ¶index指令 index：设置网站的默认首页。 index后面可以跟多个设置，如果访问的时候没有指定具体访问的资源，则会依次进行查找，找到第一个为止。 语法 index file …; 默认值 index index.html; 位置 http、server、location 举例说明： 12345location / { root /usr/local/nginx/html; index index.html index.htm;}# 访问该location的时候，可以通过 http://ip:port/，地址后面如果不添加任何内容，则默认依次访问index.html和index.htm，找到第一个来进行返回 ¶error_page指令 error_page：设置网站的错误页面。当出现对应的响应code后，如何来处理。 语法 error_page code … [=[response]] uri; 默认值 — 位置 http、server、location… 1、可以指定具体跳转的地址 123server { error_page 404 http://www.itcast.cn;} 2、可以指定重定向地址 1234567server{ error_page 404 /50x.html; error_page 500 502 503 504 /50x.html; location =/50x.html{ root html; }} 3、使用location的@符合完成错误信息展示 1234567server{ error_page 404 @jump_to_error; location @jump_to_error { default_type text/plain; return 404 'Not Found Page...'; }} 4、可选项=[response]的作用是用来将相应代码更改为另外一个 1234567# 这样的话，当返回404找不到对应的资源的时候，在浏览器上可以看到，最终返回的状态码是200，这块需要注意下，编写error_page后面的内容，404后面需要加空格，200前面不能加空格server{ error_page 404 =200 /50x.html; location =/50x.html{ root html; }} ¶3、静态资源优化配置语法 ¶sendﬁle 用来开启高效的文件传输模式。 语法 sendﬁle on |oﬀ; 默认值 sendﬁle oﬀ; 位置 http、server、location… 请求静态资源的过程： 使用了sendfile后少了进程切换和两次copy！http底层使用tcp，tcp使用socket传输！ ¶tcp_nopush 该指令必须在sendfile打开的状态下才会生效，主要是用来提升网络包的传输’效率’。 语法 tcp_nopush on|off; 默认值 tcp_nopush oﬀ; 位置 http、server、location ¶tcp_nodelay 该指令必须在keep-alive连接开启的情况下才生效，来提高网络包传输的’实时性’。 语法 tcp_nodelay on|off; 默认值 tcp_nodelay on; 位置 http、server、location tcp_nopush和tcp_nodelay区别： ¶总结 经过刚才的分析，“tcp_nopush\"和”tcp_nodelay“看起来是\"互斥的”，那么为什么要将这两个值都打开？ 这个大家需要知道的是在linux2.5.9以后的版本中两者是可以兼容的，三个指令都开启的好处是： sendfile可以开启高效的文件传输模式 tcp_nopush开启可以确保在发送到客户端之前数据包已经充分“填满”， 这大大减少了网络开销，并加快了文件发送的速度。 然后，当它到达最后一个可能因为没有“填满”而暂停的数据包时，Nginx会忽略tcp_nopush参数， 然后，tcp_nodelay强制套接字发送数据。 由此可知，TCP_NOPUSH可以与TCP_NODELAY一起设置，它比单独配置TCP_NODELAY具有更强的性能。所以我们可以使用如下配置来优化Nginx静态资源的处理 123sendfile on;tcp_nopush on;tcp_nodelay on; ¶4、Nginx静态资源压缩实战 在Nginx的配置文件中可以通过配置gzip来对静态资源进行压缩，相关的指令可以配置在http块、server块和location块。 相关指令依赖如下模块进行解析： 123ngx_http_gzip_module模块ngx_http_gzip_static_module模块ngx_http_gunzip_module模块 ¶Gzip模块配置指令 接下来的指令都来自ngx_http_gzip_module模块，该模块会在nginx安装的时候内置到nginx的安装环境中，也就是说我们可以直接使用这些指令。 1、gzip指令：该指令用于开启或者关闭gzip功能 语法 gzip on|off; 默认值 gzip off; 位置 http、server、location… 注意只有该指令为打开状态，下面的指令才有效果 123http{ gzip on;} 2、gzip_types指令：该指令可以根据响应页的MIME类型选择性地开启Gzip压缩功能 语法 gzip_types mime-type …; 默认值 gzip_types text/html; 位置 http、server、location 所选择的值可以从mime.types文件中进行查找，也可以使用\"*\"代表所有。(不建议使用*浪费服务器资源，例如视频和图片) 123http{ gzip_types application/javascript;} 3、gzip_comp_level指令：该指令用于设置Gzip压缩程度，级别从1-9,1表示要是程度最低，要是效率最高，9刚好相反，压缩程度最高，但是效率最低最费时间。 建议设置为6！ 级别更高，压缩效率慢，压缩的也不会更加厉害！ 语法 gzip_comp_level level; 默认值 gzip_comp_level 1; 位置 http、server、location 123http{ gzip_comp_level 6;} 4、gzip_vary指令：该指令用于设置使用Gzip进行压缩发送是否携带“Vary:Accept-Encoding”头域的响应头部。主要是告诉接收方，所发送的数据经过了Gzip压缩处理 语法 gzip_vary on|off; 默认值 gzip_vary off; 位置 http、server、location 5、gzip_buffers指令：该指令用于处理请求压缩的缓冲区数量和大小。 语法 gzip_buffers number size; 默认值 gzip_buffers 32 4k|16 8k; 位置 http、server、location number：指定Nginx服务器向系统申请缓存空间个数，size指的是每个缓存空间的大小。主要实现的是申请number个每个大小为size的内存空间。这个值的设定一般会和服务器的操作系统有关，所以建议此项不设置，使用默认值即可。 1gzip_buffers 4 16K; #缓存空间大小 6、gzip_disable指令：针对不同种类客户端发起的请求，可以选择性地开启和关闭Gzip功能。 语法 gzip_disable regex …; 默认值 — 位置 http、server、location regex：根据客户端的浏览器标志(user-agent)来设置，支持使用正则表达式。指定的浏览器标志不使用Gzip。该指令一般是用来排除一些明显不支持Gzip的浏览器。 12# 例如IE浏览器gzip_disable \"MSIE [1-6]\\.\"; 7、gzip_http_version指令：针对不同的HTTP协议版本，可以选择性地开启和关闭Gzip功能。 语法 gzip_http_version 1.0|1.1; 默认值 gzip_http_version 1.1; 位置 http、server、location 该指令是指定使用Gzip的HTTP最低版本，该指令一般采用默认值即可。 8、gzip_min_length指令：该指令针对传输数据的大小，可以选择性地开启和关闭Gzip功能 Gzip压缩功能对大数据的压缩效果明显，但是如果要压缩的数据比较小的化，可能出现越压缩数据量越大的情况，因此我们需要根据响应内容的大小来决定是否使用Gzip功能，响应页面的大小可以通过头信息中的Content-Length来获取。但是如何使用了Chunk编码动态压缩，该指令将被忽略。建议设置为1K或以上。 语法 gzip_min_length length; 默认值 gzip_min_length 20; 位置 http、server、location 12nignx计量大小的单位：bytes[字节] / kb[千字节] / M[兆]例如: 1024 / 10k|K / 10m|M 9、gzip_proxied指令：该指令设置是否对服务端返回的结果进行Gzip压缩。 语法 gzip_proxied off|expired|no-cache|no-store|private|no_last_modified|no_etag|auth|any; 默认值 gzip_proxied off; 位置 http、server、location off：关闭Nginx服务器对后台服务器返回结果的Gzip压缩 expired：启用压缩，如果header头中包含 “Expires” 头信息 no-cache：启用压缩，如果header头中包含 “Cache-Control:no-cache” 头信息 no-store：启用压缩，如果header头中包含 “Cache-Control:no-store” 头信息 private：启用压缩，如果header头中包含 “Cache-Control:private” 头信息 no_last_modified：启用压缩,如果header头中不包含 “Last-Modified” 头信息 no_etag：启用压缩 ,如果header头中不包含 “ETag” 头信息 auth：启用压缩 , 如果header头中包含 “Authorization” 头信息 any：无条件启用压缩 ¶Gzip压缩功能的实例配置 123456789gzip on; #开启gzip功能gzip_types *; #压缩源文件类型,根据具体的访问资源类型设定gzip_comp_level 6; #gzip压缩级别gzip_min_length 1024; #进行压缩响应页面的最小长度,content-lengthgzip_buffers 4 16K; #缓存空间大小gzip_http_version 1.1; #指定压缩响应所需要的最低HTTP请求版本gzip_vary on; #往头信息中添加压缩标识gzip_disable \"MSIE [1-6]\\.\"; #对IE6以下的版本都不进行压缩gzip_proxied off； #nginx作为反向代理压缩服务端返回数据的条件 我们可以将这些内容抽取到一个配置文件中，然后通过include指令把配置文件再次加载到nginx.conf配置文件中： nginx_gzip.conf 123456789gzip on;gzip_types *;gzip_comp_level 6;gzip_min_length 1024;gzip_buffers 4 16K;gzip_http_version 1.1;gzip_vary on;gzip_disable \"MSIE [1-6]\\.\";gzip_proxied off; nginx.conf 1include nginx_gzip.conf ¶Gzip和sendfile共存问题 前面在讲解sendfile的时候，提到过，开启sendfile以后，在读取磁盘上的静态资源文件的时候，可以减少拷贝的次数，可以不经过用户进程将静态文件通过网络设备发送出去，但是Gzip要想对资源压缩，是需要经过用户进程进行操作的。所以如何解决两个设置的共存问题。 可以使用ngx_http_gzip_static_module模块的gzip_static指令来解决。（默认没有这个模块） ¶添加模块到Nginx的实现步骤 1、查询当前Nginx的配置参数（主要用于记录以前配置过的默认信息） 1nginx -V 2、将nginx安装目录下sbin目录中的nginx二进制文件进行更名 12cd /usr/local/nginx/sbinmv nginx nginxold 3、进入Nginx的安装目录 1cd /opt/nginx-1.16.1 4、执行make clean清空之前编译的内容 1make clean 5、使用configure来配置参数 1./configure --with-http_gzip_static_module 6、使用make命令进行编译 1make 7、将objs目录下的nginx二进制执行文件移动到nginx安装目录下的sbin目录中 1mv objs/nginx /usr/local/nginx/sbin 8、执行更新命令（在nginx解压目录下执行） 1make upgrade ¶gzip_static指令 注意：需要关了gzip开关，无需在应用程序中压缩，gzip off; gzip_static: 检查与访问资源同名的.gz文件时，response中以gzip相关的header返回.gz文件的内容。先进行服务器上的压缩为.gz文件，再进行资源传输。 语法 gzip_static on | off | always; 默认值 gzip_static off; 位置 http、server、location ¶gzip_static测试使用 1、直接访问http://192.168.200.133/jquery.js 2、使用gzip命令进行压缩 1cd /usr/local/nginx/htmlgzip jquery.js 3、再次访问http://192.168.200.133/jquery.js 多了Content-Encoding：gzip 和 Vary：Accept-Encoding ¶5、静态资源的缓存处理 ¶什么是缓存 缓存（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用DRAM技术，而使用昂贵但较快速的SRAM技术。缓存的设置是所有现代计算机系统发挥高性能的重要因素之一。 ¶什么是web缓存 Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。 比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页 ¶web缓存的种类 客户端缓存：浏览器缓存 服务端缓存：Nginx / Redis / Memcached等 ¶浏览器缓存 是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览. 是成本最低的一种缓存实现减少网络带宽消耗降低服务器压力减少网络延迟，加快页面打开速度！ ¶浏览器缓存的执行流程 HTTP协议中和页面缓存相关的字段： header 说明 Expires 缓存过期的日期和时间 Cache-Control 设置和缓存相关的配置信息 Last-Modified 请求资源最后修改时间 ETag 请求变量的实体标签的当前值，比如文件的MD5值 缓存执行流程示意图： 执行过程如下： 用户首次通过浏览器发送请求到服务端获取数据，客户端是没有对应的缓存，所以需要发送request请求来获取数据； 服务端接收到请求后，获取服务端的数据及服务端缓存的允许后，返回200的成功状态码并且在响应头上附上对应资源以及缓存信息； 当用户再次访问相同资源的时候，客户端会在浏览器的缓存目录中查找是否存在响应的缓存文件 如果没有找到对应的缓存文件，则走第二步 如果有缓存文件，接下来对缓存文件是否过期进行判断，过期的判断标准是(Expires), 如果没有过期，则直接从本地缓存中返回数据进行展示（强缓存） 如果Expires过期，接下来需要判断缓存文件是否发生过变化 判断的标准有两个，一个是ETag(Entity Tag),一个是Last-Modified 判断结果是未发生变化，则服务端返回304，直接从缓存文件中获取数据（弱缓存） 如果判断是发生了变化，重新从服务端获取数据，并根据缓存协商(服务端所设置的是否需要进行缓存数据的设置)来进行数据缓存。 弱缓存请求头图示： 记得去掉浏览器disabled cache的勾。 注意：直接刷新页面和F5会导致强缓存失效。一定要在开一个页面，提前打开浏览器控制台的网络选项卡查看！ 强缓存图示： ¶浏览器缓存相关指令 ¶expires指令 该指令用来控制页面缓存的作用。可以通过该指令控制HTTP应答中的“Expires\"和”Cache-Control\"。（单位默认秒） 语法 expires [modified] timeexpires epoch|max|off; 默认值 expires off; 位置 http、server、location time：可以整数也可以是负数，指定过期时间。如果是负数，Cache-Control则为no-cache；如果为整数或0，则Cache-Control的值为max-age=time； max-age为新的http1.1使用的，和expires类似。expires会由于服务器和本地时间不一致而不使用缓存！ epoch：指定Expires的值为’1 January,1970,00:00:01 GMT’(1970-01-01 00:00:00)，Cache-Control的值no-cache max：指定Expires的值为’31 December2037 23:59:59GMT’ (2037-12-31 23:59:59) ，Cache-Control的值为10年 off：默认不缓存。 给静态资源设置缓存： 123location ~ .*\\.(html|js|css|png|jpg) { expires 1000;} 分别为没有设置、设置为max，1000，负数 响应头示意图： ¶add_header指令 add_header指令是用来添加指定的响应头和响应值。 语法 add_header name value [always]; 默认值 — 位置 http、server、location… Cache-Control作为响应头信息，可以设置如下值： 缓存响应指令： 123456789Cache-control: must-revalidateCache-control: no-cacheCache-control: no-storeCache-control: no-transformCache-control: publicCache-control: privateCache-control: proxy-revalidateCache-Control: max-age=&lt;seconds&gt;Cache-control: s-maxage=&lt;seconds&gt; 指令 说明 must-revalidate 可缓存但必须再向源服务器进行确认 no-cache 缓存前必须确认其有效性 no-store 不缓存请求或响应的任何内容 no-transform 代理不可更改媒体类型 public 可向任意方提供响应的缓存 private 仅向特定用户返回响应 proxy-revalidate 要求中间缓存服务器对缓存的响应有效性再进行确认 max-age=&lt;秒&gt; 响应最大Age值 s-maxage=&lt;秒&gt; 公共缓存服务器响应的最大Age值 ¶6、Nginx的跨域问题解决 ¶同源策略 浏览器的同源策略：是一种约定，是浏览器最核心也是最基本的安全功能，如果浏览器少了同源策略，则浏览器的正常功能可能都会受到影响。 同源: 协议、域名(IP)、端口相同即为同源 1234567891011121314151617181920212223http://192.168.200.131/user/1https://192.168.200.131/user/1不http://192.168.200.131/user/1http://192.168.200.132/user/1不http://192.168.200.131/user/1http://192.168.200.131:8080/user/1不http://www.nginx.com/user/1http://www.nginx.org/user/1不http://192.168.200.131/user/1http://192.168.200.131:8080/user/1不http://www.nginx.org:80/user/1http://www.nginx.org/user/1满足 ¶跨域问题 简单描述下：有两台服务器分别为A,B，如果从服务器A的页面发送异步请求到服务器B获取数据，如果服务器A和服务器B不满足同源策略，则就会出现跨域问题。 ¶跨域问题演示 1、nginx的html目录下新建一个a.html 1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;跨域问题演示&lt;/title&gt; &lt;script src=\"jquery.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(\"#btn\").click(function(){ $.get('http://192.168.200.133:8080/getUser',function(data){ alert(JSON.stringify(data)); }); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"button\" value=\"获取数据\" id=\"btn\"/&gt; &lt;/body&gt;&lt;/html&gt; 2、在nginx.conf配置如下内容 12345678910111213141516server{ listen 8080; server_name localhost; location /getUser{ default_type application/json; return 200 '{\"id\":1,\"name\":\"TOM\",\"age\":18}'; }}server{ listen 80; server_name localhost; location /{ root html; index index.html; }} 3、通过浏览器访问测试 ¶解决方案 使用add_header指令，该指令可以用来添加一些头信息： 语法 add_header name value… 默认值 — 位置 http、server、location 此处用来解决跨域问题，需要添加两个头信息：Access-Control-Allow-Origin,Access-Control-Allow-Methods Access-Control-Allow-Origin: 直译过来是允许跨域访问的源地址信息，可以配置多个(多个用逗号分隔)，也可以使用*代表所有源 Access-Control-Allow-Methods：直译过来是允许跨域访问的请求方式，值可以为 GET POST PUT DELETE…,可以全部设置，也可以根据需要设置，多个用逗号分隔 具体配置方式： 123456location /getUser{ add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE; default_type application/json; return 200 '{\"id\":1,\"name\":\"TOM\",\"age\":18}';} ¶7、静态资源防盗链 ¶什么是资源盗链 资源盗链指的是此内容不在自己服务器上，而是通过技术手段，绕过别人的限制将别人的内容放到自己页面上最终展示给用户。以此来盗取大网站的空间和流量。简而言之就是用别人的东西成就自己的网站。 效果演示： 123京东：https://img14.360buyimg.com/n7/jfs/t1/101062/37/2153/254169/5dcbd410E6d10ba22/4ddbd212be225fcd.jpg百度：https://pics7.baidu.com/feed/cf1b9d16fdfaaf516f7e2011a7cda1e8f11f7a1a.jpeg?token=551979a23a0995e5e5279b8fa1a48b34&amp;s=BD385394D2E963072FD48543030030BB 我们自己准备一个html页面，在页面上img标签引入这两个图片查看效果： ¶Nginx防盗链原理 了解防盗链的原理之前，我们得先学习一个HTTP的头信息Referer，当浏览器向web服务器发送请求的时候，一般都会带上Referer，来告诉浏览器该网页是从哪个页面链接过来的。 后台服务器可以根据获取到的这个Referer信息来判断是否为自己信任的网站地址，如果是则放行继续访问，如果不是则可以返回403(服务端拒绝访问)的状态信息。 Nginx防盗链的具体实现: valid_referers：nginx会通就过查看referer自动和valid_referers后面的内容进行匹配，如果匹配到了就将$invalid_referer变量置0，如果没有匹配到，则将$invalid_referer变量置为1，匹配的过程中不区分大小写。 语法 valid_referers none|blocked|server_names|string… 默认值 — 位置 server、location none：如果Header中的Referer为空，允许访问 blocked：在Header中的Referer不为空，但是该值被防火墙或代理进行伪装过，如不带\"http://\" 、\"https://\"等协议头的资源允许访问。 server_names：指定具体的域名或者IP string：可以支持正则表达式和*的字符串。如果是正则表达式，需要以~开头表示，例如 注意： if后面必须有空格 12345678location ~*\\.(png|jpg|gif){ valid_referers none blocked www.baidu.com 192.168.200.222 *.example.com example.* www.example.org ~\\.google\\.; if ($invalid_referer){ return 403; } root /usr/local/nginx/html;} ¶针对目录进行防盗链 12345678location /images { valid_referers none blocked www.baidu.com 192.168.200.222 *.example.com example.* www.example.org ~\\.google\\.; if ($invalid_referer){ return 403; } root /usr/local/nginx/html;} 这样我们可以对一个目录下的所有资源进行了防盗操作。 遇到的问题：Referer的限制比较粗，比如随意加一个Referer，上面的方式是无法进行限制的。那么这个问题改如何解决？ 此处我们需要用到Nginx的第三方模块ngx_http_accesskey_module，后面模块篇内容介绍！ ¶七、Rewrite功能配置 Rewrite是Nginx服务器提供的一个重要基本功能，是Web服务器产品中几乎必备的功能。主要的作用是用来实现URL的重写。 注意：Nginx服务器的Rewrite功能的实现依赖于PCRE的支持，因此在编译安装Nginx服务器之前，需要安装PCRE库。 Nginx使用的是ngx_http_rewrite_module模块来解析和处理Rewrite功能的相关配置。（内置，无需安装） ¶1、地址重写与地址转发 地址重写浏览器地址会发生变化而地址转发则不变 一次地址重写会产生两次请求而一次地址转发只会产生一次请求 地址重写到的页面必须是一个完整的路径而地址转发则不需要 地址重写因为是两次请求所以request范围内属性不能传递给新页面而地址转发因为是一次请求所以可以传递值 地址转发速度快于地址重写 ¶2、Rewrite的相关指令 ¶set指令 该指令用来设置一个新的变量。 语法 set $variable value; 默认值 — 位置 server、location、if variable：变量的名称，该变量名称要用\"$\"作为变量的第一个字符，且不能与Nginx服务器预设的全局变量同名。 value：变量的值，可以是字符串、其他变量或者变量的组合等。 ¶Rewrite常用全局变量 不一定是nginx的全局变量！ 变量 说明 $args 变量中存放了请求URL中的请求指令。比如 http://192.168.200.133:8080?arg1=value1&amp;args2=value2 中的\"arg1=value1&amp;arg2=value2\"，功能和$query_string一样 $http_user_agent 变量存储的是用户访问服务的代理信息(如果通过浏览器访问，记录的是浏览器的相关版本信息) $host 变量存储的是访问服务器的server_name值 $document_uri 变量存储的是当前访问地址的URI。比如 http://192.168.200.133/server?id=10&amp;name=zhangsan 中的\"/server\"，功能和$uri一样 $document_root 变量存储的是当前请求对应location的root值，如果未设置，默认指向Nginx自带html目录所在位置 $content_length 变量存储的是请求头中的Content-Length的值 $content_type 变量存储的是请求头中的Content-Type的值 $http_cookie 变量存储的是客户端的cookie信息，可以通过add_header Set-Cookie 'cookieName=cookieValue’来添加cookie数据 $limit_rate 变量中存储的是Nginx服务器对网络连接速率的限制，也就是Nginx配置中对limit_rate指令设置的值，默认是0，不限制。 $remote_addr 变量中存储的是客户端的IP地址 $remote_port 变量中存储了客户端与服务端建立连接的端口号 $remote_user 变量中存储了客户端的用户名，需要有认证模块才能获取 $scheme 变量中存储了访问协议 $server_addr 变量中存储了服务端的地址 $server_name 变量中存储了客户端请求到达的服务器的名称 $server_port 变量中存储了客户端请求到达服务器的端口号 $server_protocol 变量中存储了客户端请求协议的版本，比如\"HTTP/1.1\" $request_body_file 变量中存储了发给后端服务器的本地文件资源的名称 $request_method 变量中存储了客户端的请求方式，比如\"GET\",\"POST\"等 $request_filename 变量中存储了当前请求的资源文件的路径名 $request_uri 变量中存储了当前请求的URI，并且携带请求参数，比如 http://192.168.200.133/server?id=10&amp;name=zhangsan 中的\"/server?id=10&amp;name=zhangsan\" ¶if指令 该指令用来支持条件判断，并根据条件判断结果选择不同的Nginx配置。 语法 if (condition){…} 默认值 — 位置 server、location condition为判定条件，可以支持以下写法： 1、变量名。如果变量名对应的值为空字符串或\"0\"，if都判断为false,其他条件为true。 123if ($param){ } 2、使用\"=“和”!=\"比较变量和字符串是否相等，满足条件为true，不满足为false 123if ($request_method = POST){ return 405;} 注意： 此处和Java不太一样的地方是字符串不需要添加引号。 浏览器无法直接发送post请求，可以编写form表单提交发送。也可以直接使用curl -X post 请求地址来发送！ 3、使用正则表达式对变量进行匹配，匹配成功返回true，否则返回false。 ~代表匹配正则表达式过程中区分大小写 ~*代表匹配正则表达式过程中不区分大小写 !~和!~刚好和上面取相反值，如果匹配上返回false,匹配不上返回true 123if ($http_user_agent ~ MSIE){ #$http_user_agent的值中是否包含MSIE字符串，如果包含返回true} 注意： 正则表达式字符串一般不需要加引号，但是如果字符串中包含\"}“或者是”;\"等字符时，就需要把引号加上。 4、判断请求的文件是否存在使用\"-f\"和\"!-f\", -f：如果请求的文件存在返回true，不存在返回false。 !f：如果请求文件不存在，但该文件所在目录存在返回true,文件和目录都不存在返回false,如果文件存在返回false 123456if (-f $request_filename){ #判断请求的文件是否存在}if (!-f $request_filename){ #判断请求的文件是否不存在} 5、判断请求的目录是否存在使用\"-d\"和\"!-d\", 6、判断请求的目录或者文件是否存在使用\"-e\"和\"!-e\" 7、判断请求的文件是否可执行使用\"-x\"和\"!-x\" ¶break指令 该指令用于中断当前相同作用域中的其他Nginx配置。与该指令处于同一作用域的Nginx配置中，位于它前面的指令配置生效，位于后面的指令配置无效。 语法 break; 默认值 — 位置 server、location、if 例子: 1234567891011location /testbreak { default_type text/plain; set $username TOM; if ($args){ set $username JERRY; break ; set $username ROSE; } add_header username $username; return 200 $username;} 解释：有了参数后走if，但是直接报错404，因为break会终止此次匹配，直接跳转到location的路径去重定向访问，导致跳转到/usr/local/nginx/html/testbreak目录，该目录下没有默认的index.html，因此报错404。 当我们创建了该目录和默认html文件后，如下： 301表示永久重定向，重定向到?1，状态码为200，响应头多了一个username为JERRY，即break后面的不会执行（同一作用域内）。 ¶return指令 该指令用于完成对请求的处理，直接向客户端返回响应状态代码。在return后的所有Nginx配置都是无效的。 语法 return code [text];return code URL;return URL; 默认值 — 位置 server、location、if code：为返回给客户端的HTTP状态代理。可以返回的状态代码为0~999的任意HTTP状态代理 text：为返回给客户端的响应体内容，支持变量的使用 URL：为返回给客户端的URL地址。重定向，地址栏改变，状态码为302，临时重定向！ 123return 302 https://www.baidu.com/;return https://www.baidu.com/;# 二者效果一样！ ¶rewrite指令 该指令通过正则表达式的使用来改变URI。可以同时存在一个或者多个指令，按照顺序依次对URL进行匹配和处理。 URI：统一资源标识符 URL：统一资源定位符 语法 rewrite regex replacement [flag]; 默认值 — 位置 server、location、if regex：用来匹配URI的正则表达式 replacement：匹配成功后，用于替换URI中被截取内容的字符串。如果该字符串是以\"http://\"或者\"https://\"开头的，则不会继续向下对URI进行其他处理，而是直接返回重写后的URI给客户端。 flag：用来设置rewrite对URI的处理行为，可选值有如下： last：终止继续在本location块中处理接收到的URI，并将此处重写的URl作为一个新的URI，使用各location块进行处理。该标志将重写后的URI重写在server块中执行，为重写后的URI提供了转入到其他location块的机会。 break：将此处重写的URI作为一个新的URl,在本块中继续进行处理。该标志将重写后的地址在当前的location块中执行，不会将新的URI转向其他的location块。 redirect：将重写后的URI返回给客户端，状态码为302，指明是临时重定向URI,主要用在replacement变量不是以\"http:/“或者\"https:/”\"开头的情况。 permanent：将重写后的URI返回给客户端，状态码为301，指明是永久重定向URl,主要用在replacement变量不是以\"http:/\"“或者\"https:/八”\"开头的情况。 1234567891011121314151617181920212223location /rewrite { rewrite ^/rewrite/url\\w*$ https://www.baidu.com; rewrite ^/rewrite/(test)\\w*$ /$1; rewrite ^/rewrite/(demo)\\w*$ /$1; # break rewrite ^/rewrite/(test)\\w*$ /$1 break; # 默认会去/usr/lcoal/nginx/html/test/index.html中去找。可以查看error.log看到！ # redirect 临时重定向 rewrite ^/rewrite/(test)\\w*$ /$1 redirect; # permanent 永久重定向 rewrite ^/rewrite/(test)\\w*$ /$1 permanent;}location /test { default_type text/plain; return 200 test_success;}location /demo { default_type text/plain; return 200 demo_success;} 补充：301 302和搜索引擎seo优化有关！ ¶rewrite_log指令 该指令配置是否开启URL重写日志的输出功能。 语法 rewrite_log on|off; 默认值 rewrite_log off; 位置 http、server、location、if 开启后，URL重写的相关日志将以notice级别输出到error_log指令配置的日志文件汇总。 12345678location /rewrite { error_log logs/error.log notice; rewrite_log on; rewrite ^/rewrite/url\\w*$ https://www.baidu.com; rewrite ^/rewrite/(test)\\w*$ /$1; rewrite ^/rewrite/(demo)\\w*$ /$1;} ¶3、Rewrite的案例 ¶域名跳转 准备三个域名： 1vim /etc/hosts 123127.0.0.1 www.itcast.cn127.0.0.1 www.itheima.cn127.0.0.1 www.itheima.com 通过Nginx实现访问www.itcast.cn 12345678server { listen 80; server_name www.itcast.cn; location /{ default_type text/html; return 200 '&lt;h1&gt;welcome to itcast&lt;/h1&gt;'; }} 通过Rewrite完成将 www.ithema.com 和 www.itheima.cn 的请求跳转到 www.itcast.com 12345server { listen 80; server_name www.itheima.com www.itheima.cn; rewrite ^/ http://www.itcast.cn;} 问题描述：如何在域名跳转的过程中携带请求的URI？ 修改配置信息： 12345server { listen 80; server_name www.itheima.com www.itheima.cn; rewrite ^(.*) http://www.itcast.cn$1；} ¶域名镜像 镜像网站指定是将一个完全相同的网站分别放置到几台服务器上，并分别使用独立的URL进行访问。其中一台服务器上的网站叫主站，其他的为镜像网站。镜像网站和主站没有太大的区别，可以把镜像网站理解为主站的一个备份节点。可以通过镜像网站提供网站在不同地区的响应速度。镜像网站可以平衡网站的流量负载、可以解决网络宽带限制、封锁等。 为其中某一个子目录下的资源做镜像，我们可以在location块中配置rewrite功能： 123456789101112server { listen 80; server_name www.itheima.cn www.itheima.com; location /user { rewrite ^/user(.*)$ http://www.itcast.cn$1; } location /emp{ default_type text/html; return 200 '&lt;h1&gt;emp_success&lt;/h1&gt;'; }} ¶独立域名 一个完整的项目包含多个模块，比如购物网站有商品搜索模块、商品详情模块和购物车模块等，那么我们如何为每一个模块设置独立的域名。 需求： 123http://search.itcast.com:81 #访问商品搜索模块http://item.itcast.com:82 #访问商品详情模块http://cart.itcast.com:83 #访问商品购物车模块 123456789101112131415server{ listen 81; server_name search.itcast.com; rewrite ^(.*) http://www.itcast.cn/search$1;}server{ listen 82; server_name item.itcast.com; rewrite ^(.*) http://www.itcast.cn/item$1;}server{ listen 83; server_name cart.itcast.com; rewrite ^(.*) http://www.itcast.cn/cart$1;} ¶目录自动添加\"/\" 问题描述 通过一个例子来演示下问题: 123456789server { listen 8082; server_name localhost; location /heima { root html; index index.html; }} 通过 http://192.168.200.133:8082/heima 和通过 http://192.168.200.133:8082/heima/ 访问的区别？ 如果不加斜杠，Nginx服务器内部会自动做一个301的重定向，重定向的地址会有一个指令叫server_name_in_redirect on|off;来决定重定向的地址： 123456如果该指令为on 重定向的地址为: http://server_name:8082/目录名/; http://localhost:8082/heima/如果该指令为off 重定向的地址为: http://原URL中的域名:8082/目录名/; http://192.168.200.133:8082/heima/ 所以就拿刚才的地址来说，http://192.168.200.133:8082/heima 如果不加斜杠，那么按照上述规则，如果指令server_name_in_redirect为on，则301重定向地址变为 http://localhost:8082/heima/ , 如果为off，则301重定向地址变为 http://192.168.200.133:8082/heima/。后面这个是正常的，前面地址就有问题。 注意server_name_in_redirect指令在Nginx的0.8.48版本之前默认都是on，之后改成了off, 所以现在我们这个版本不需要考虑这个问题，但是如果是0.8.48以前的版本并且server_name_in_redirect设置为on，我们如何通过rewrite来解决这个问题？ 旧版本解决方案： 我们可以使用rewrite功能为末尾没有斜杠的URL自动添加一个斜杠。 1234567891011server { listen 80; server_name localhost; server_name_in_redirect on; location /heima { if (-d $request_filename){ # 匹配/xxx不匹配/xxx/，匹配成功修改为/xxx/。[^/]匹配处理/的其它字符 rewrite ^/(.*)([^/])$ http://$host/$1$2/ permanent; } }} ¶合并目录 搜索引擎优化(SEO)是一种利用搜索引擎的搜索规则来提高目的网站在有关搜索引擎内排名的方式。我们在创建自己的站点时，可以通过很多中方式来有效的提供搜索引擎优化的程度。其中有一项就包含URL的目录层级一般不要超过三层，否则的话不利于搜索引擎的搜索也给客户端的输入带来了负担，但是将所有的文件放在一个目录下又会导致文件资源管理混乱并且访问文件的速度也会随着文件增多而慢下来，这两个问题是相互矛盾的，那么使用rewrite如何解决上述问题? 举例： 网站中有一个资源文件的访问路径时 /server/11/22/33/44/20.html, 也就是说20.html存在于第5级目录下，如果想要访问该资源文件，客户端的URL地址就要写成 http://192.168.200.133/server/11/22/33/44/20.html 但是这个是非常不利于SEO搜索引擎优化的，同时客户端也不好记，使用rewrite我们可以进行如下配置： 12345678910server { listen 8083; server_name localhost; location /server{ # 解释：匹配/server-11-22-33-44-20.html后重写为/server/11/22/33/44/20.html，由于是last，重新发起请求匹配/server/11/22/33/44/20.html。 # 再次进入本location匹配，并不满足rewrite规则，直接去服务器对应层级目录去找20.html文件，找到了直接显示，若没有会报错404！ #若这里为break，则不会再次发起请求匹配location而是会直接继续执行下方代码，由于下方没有代码，则默认找对应层级目录的20.html。 rewrite ^/server-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)\\.html$ /server/$1/$2/$3/$4/$5.html last; }} 客户端只需要输入http://www.web.name/server-11-22-33-44-20.html就可以访问到20.html页面了。 ¶防盗链 防盗链之前我们已经介绍过了相关的知识，在rewrite中的防盗链和之前的原理其实都是一样的，只不过通过rewrite可以将防盗链的功能进行完善下，当出现防盗链的情况，我们可以使用rewrite将请求转发到自定义的一张图片和页面，给用户比较好的提示信息。 123456789location /images { root html; valid_referers none blocked www.baidu.com; if ($invalid_referer){ #return 403; rewrite ^/ /images/forbidden.png break; }} ¶八、Nginx反向代理 ¶1、Nginx正向代理 正向代理代理的对象是客户端，反向代理代理的是服务端，这是两者之间最大的区别。 Nginx即可以实现正向代理，也可以实现反向代理。 需求： 客服端为192.168.200.1，代理为192.168.200.146，服务端为192.168.133 1、服务端的设置 123456789101112http { log_format main 'client send request=&gt;clientIp=$remote_addr serverIp=&gt;$host'; server{ listen 80; server_name localhost; access_log logs/access.log main; location { root html; index index.html index.htm; } }} 2、使用客户端访问服务端，打开日志查看结果 3、代理服务器设置 1234567891011server { listen 82; # dns地址，可配可不配 resolver 8.8.8.8; location /{ # proxy_pass http://$host$request_uri; } } 4、查看代理服务器的IP(192.168.200.146)和Nginx配置监听的端口(82) 5、在客户端配置代理服务器 6、设置完成后，再次通过浏览器访问服务端 通过对比，上下两次的日志记录，会发现虽然我们是客户端访问服务端，但是使用了代理，那么服务端能看到的只是代理发送过去的请求，这样的话，就使用Nginx实现了正向代理的设置。 但是Nginx正向代理，在实际的应用中不是特别多！ ¶2、Nginx反向代理 Nginx反向代理模块的指令是由ngx_http_proxy_module模块进行解析，默认已经内置！ ¶proxy_pass 该指令用来设置被代理服务器地址，可以是主机名称、IP地址加端口号形式。 语法 proxy_pass URL; 默认值 — 位置 location URL：为要设置的被代理服务器地址，包含传输协议(http,https://)、主机名称或IP地址加端口号、URI等要素。 大家在编写proxy_pass的时候，后面的值要不要加\"/\"? 接下来通过例子来说明刚才我们提到的问题： 12345678910111213141516171819202122server { listen 80; server_name localhost; location /{ #proxy_pass http://192.168.200.146; proxy_pass http://192.168.200.146/; }}# 当客户端访问 http://localhost/index.html,效果是一样的server{ listen 80; server_name localhost; location /server{ #proxy_pass http://192.168.200.146; proxy_pass http://192.168.200.146/; }}# 当客户端访问 http://localhost/server/index.html# 这个时候，第一个proxy_pass就变成了http://localhost/server/index.html# 第二个proxy_pass就变成了http://localhost/index.html效果就不一样了。 ¶proxy_set_header 该指令可以更改Nginx服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给代理的服务器 语法 proxy_set_header field value; 默认值 proxy_set_header Host $proxy_host;proxy_set_header Connection close; 位置 http、server、location 需要注意的是，如果想要看到结果，必须在被代理的服务器上来获取添加的头信息。 被代理服务器： [192.168.200.146] 1234567server { listen 8080; server_name localhost; default_type text/plain; # $http_请求头属性名 return 200 $http_username;} 代理服务器: [192.168.200.133] 123456789server { listen 8080; server_name localhost; location /server { proxy_pass http://192.168.200.146:8080/; proxy_set_header username TOM; } } ¶proxy_redirect 该指令是用来重置头信息中的\"Location\"和\"Refresh\"的值。 语法 proxy_redirect redirect replacement;proxy_redirect default;proxy_redirect off; 默认值 proxy_redirect default; 位置 http、server、location redirect：目标,Location的值 replacement：要替换的值 proxy_redirect default：带有默认规则的替换，将location块的uri变量作为replacement，将proxy_pass变量作为redirect进行替换 proxy_redirect off：关闭proxy_redirect的功能 为什么要用该指令? 服务端[192.168.200.146] 12345678server { listen 8081; server_name localhost; if (!-f $request_filename){ return 302 http://192.168.200.146; }} 代理服务端[192.168.200.133] 123456789101112131415server { listen 80; server_name localhost; location / { root html; index index.html; }}server { listen 8081; server_name localhost; location / { proxy_pass http://192.168.200.146:8081/; }} 问题发现： 访问 http://192.168.200.133:8081/abc.html 会先进入133的代理，再进入服务端146的if条件，302状态，地址栏变为146的ip！头信息的Location值也变为146服务端ip！ 这时候服务端ip地址已经暴露！ 解决： 123456789# 133代理服务器修改如下即可！server { listen 8081; server_name localhost; location / { proxy_pass http://192.168.200.146:8081/; proxy_redirect http://192.168.200.146 http://192.168.200.133; }} 又有问题：是跳转到了133代理服务器，但是获取的页面是133的默认80端口的值！即133的默认nginx欢迎页面！而不是想要得到的146服务端的nginx欢迎页面！ 133代理服务器80端口修改一下即可： 123456789101112131415server { listen 80; server_name localhost; location / { # 再次通过location拦截跳到真实146服务端即可！ proxy_pass http://192.168.200.146/; }}server { listen 8081; server_name localhost; location / { proxy_pass http://192.168.200.146:8081/; }} ¶3、Nginx反向代理实战 服务器1,2,3存在两种情况： 三台服务器的内容不一样。反向代理！ 三台服务器的内容是一样。负载均衡！ 配置： 123456789101112131415161718192021222324252627282930313233343536#代理服务器server { listen 8082; server_name localhost; location /server1 { proxy_pass http://192.168.200.146:9001/; } location /server2 { proxy_pass http://192.168.200.146:9002/; } location /server3 { proxy_pass http://192.168.200.146:9003/; }}#服务端server1server { listen 9001; server_name localhost; default_type text/html; return 200 '&lt;h1&gt;192.168.200.146:9001&lt;/h1&gt;'}#server2server { listen 9002; server_name localhost; default_type text/html; return 200 '&lt;h1&gt;192.168.200.146:9002&lt;/h1&gt;'}#server3server { listen 9003; server_name localhost; default_type text/html; return 200 '&lt;h1&gt;192.168.200.146:9003&lt;/h1&gt;'} ¶4、Nginx的安全控制 关于web服务器的安全是比较大的一个话题，里面所涉及的内容很多，Nginx反向代理是如何来提升web服务器的安全呢？ 安全隔离！ 什么是安全隔离? 通过代理分开了客户端到应用程序服务器端的连接，实现了安全措施。在反向代理之前设置防火墙，仅留一个入口供代理服务器访问。 ¶5、如何使用SSL对流量进行加密 就是将我们常用的http请求转变成https请求，那么这两个之间的区别简单的来说两个都是HTTP协议，只不过https是身披SSL外壳的http！ HTTPS是一种通过计算机网络进行安全通信的传输协议。它经由HTTP进行通信，利用SSL/TLS建立全通信，加密数据包，确保数据的安全性。 SSL(Secure Sockets Layer)安全套接层 TLS(Transport Layer Security)传输层安全 上述这两个是为网络通信提供安全及数据完整性的一种安全协议，TLS和SSL在传输层和应用层对网络连接进行加密。 总结来说为什么要使用https？ http协议是明文传输数据，存在安全问题，而https是加密传输，相当于http+ssl，并且可以防止流量劫持。 Nginx要想使用SSL，需要满足一个条件即需要添加一个模块--with-http_ssl_module,而该模块在编译的过程中又需要OpenSSL的支持，这个我们之前已经准备好了。 ¶nginx添加SSL的支持 1、完成 --with-http_ssl_module模块的增量添加 12345678910111213》拷贝nginx之前的配置信息 ./nginx -V 备份一份configure的参数信息！》将原有/usr/local/nginx/sbin/nginx进行备份》在nginx的安装源码进行配置指定对应模块 ./configure --with-http_ssl_module》通过make模板进行编译》将objs下面的nginx移动到/usr/local/nginx/sbin下》在源码目录下执行 make upgrade 进行升级，这个可以实现不停机添加新模块的功能root@VM-8-2-centos nginx-1.21.3]# nginx -Vnginx version: nginx/1.21.3built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) built with OpenSSL 1.0.2k-fips 26 Jan 2017TLS SNI support enabledconfigure arguments: --with-http_gzip_static_module --with-http_ssl_module ¶Nginx的SSL相关指令 ssl：该指令用来在指定的服务器开启HTTPS,可以使用 listen 443 ssl,后面这种方式更通用些。 语法 ssl on | off; 默认值 ssl off; 位置 http、server 123server{ listen 443 ssl;} ssl_certificate：为当前这个虚拟主机指定一个带有PEM格式证书的证书。 语法 ssl_certificate file; 默认值 — 位置 http、server ssl_certificate_key：该指令用来指定PEM secret key文件的路径 语法 ssl_ceritificate_key file; 默认值 — 位置 http、server ssl_session_cache：该指令用来配置用于SSL会话的缓存 语法 ssl_sesion_cache off|none|[builtin[:size]] [shared:name:size] 默认值 ssl_session_cache none; 位置 http、server off：禁用会话缓存，客户端不得重复使用会话 none：禁止使用会话缓存，客户端可以重复使用，但是并没有在缓存中存储会话参数 builtin：内置OpenSSL缓存，仅在一个工作进程中使用。 shared：所有工作进程之间共享缓存，缓存的相关信息用name和size来指定 ssl_session_timeout：开启SSL会话功能后，设置客户端能够反复使用储存在缓存中的会话参数时间。 语法 ssl_session_timeout time; 默认值 ssl_session_timeout 5m;（m：分钟） 位置 http、server ssl_ciphers：指出允许的密码，密码指定为OpenSSL支持的格式 语法 ssl_ciphers ciphers; 默认值 ssl_ciphers HIGH:!aNULL:!MD5; 位置 http、server 可以使用openssl ciphers查看openssl支持的格式。 ssl_prefer_server_ciphers：该指令指定是否服务器密码优先客户端密码 语法 ssl_perfer_server_ciphers on|off; 默认值 ssl_perfer_server_ciphers off; 位置 http、server ¶生成证书 方式一：使用阿里云/腾讯云等第三方服务进行购买或使用freessl申请！（有机构验证） 方式二：使用openssl生成证书。（无机构验证） 1、先要确认当前系统是否有安装openssl 1openssl version 2、安装下面的命令进行生成 1234567mkdir /root/certcd /root/certopenssl genrsa -des3 -out server.key 1024openssl req -new -key server.key -out server.csrcp server.key server.key.orgopenssl rsa -in server.key.org -out server.keyopenssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt ¶开启SSL实例 123456789101112131415161718192021server { listen 443 ssl; # 域名配置 server_name localhost; # 修改证书位置即可 ssl_certificate /root/cert/server.cert; ssl_certificate_key /root/cert/server.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # 具体配置 location / { root html; index index.html index.htm; }} 强制重定向到https： 1234567891011121314server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { #root html; #index index.html index.htm; rewrite ^(.*)$ https://$host$1 permanent; }} ¶6、反向代理系统调优 反向代理Buffer和Cache！ Buffer翻译过来是\"缓冲\"，Cache翻译过来是\"缓存\"。 总结下： 相同点：两种方式都是用来提供IO吞吐效率，都是用来提升Nginx代理的性能。 不同点： 缓冲主要用来解决不同设备之间数据传递速度不一致导致的性能低的问题，缓冲中的数据一旦此次操作完成后，就可以删除。 缓存主要是备份，将被代理服务器的数据缓存一份到代理服务器，这样的话，客户端再次获取相同数据的时候，就只需要从代理服务器上获取，效率较高，缓存中的数据可以重复使用，只有满足特定条件才会删除. Proxy Buffer相关指令： proxy_buffering：该指令用来开启或者关闭代理服务器的缓冲区 语法 proxy_buffering on|off; 默认值 proxy_buffering on; 位置 http、server、location proxy_buffers：该指令用来指定单个连接从代理服务器读取响应的缓存区的个数和大小 语法 proxy_buffers number size; 默认值 proxy_buffers 8 4k | 8K;(与系统平台有关) 位置 http、server、location number：缓冲区的个数 size：每个缓冲区的大小，缓冲区的总大小就是number*size proxy_buffer_size：该指令用来设置从被代理服务器获取的第一部分响应数据的大小。保持与proxy_buffers中的size一致即可，当然也可以更小。 语法 proxy_buffer_size size; 默认值 proxy_buffer_size 4k | 8k;(与系统平台有关) 位置 http、server、location proxy_busy_buffers_size：该指令用来限制同时处于BUSY状态的缓冲总大小。 语法 proxy_busy_buffers_size size; 默认值 proxy_busy_buffers_size 8k|16K; 位置 http、server、location proxy_temp_path：当缓冲区存满后，仍未被Nginx服务器完全接受，响应数据就会被临时存放在磁盘文件上，该指令设置文件路径 语法 proxy_temp_path path; 默认值 proxy_temp_path proxy_temp; 位置 http、server、location **注意：**path最多设置三层。 proxy_temp_file_write_size：该指令用来设置磁盘上缓冲文件的大小。 语法 proxy_temp_file_write_size size; 默认值 proxy_temp_file_write_size 8K|16K; 位置 http、server、location 通用网站的配置： 1234proxy_buffering on;proxy_buffer_size 4 32k;proxy_busy_buffers_size 64k;proxy_temp_file_write_size 64k; 根据项目的具体内容进行相应的调节。 ¶九、Nginx负载均衡 ¶1、负载均衡概述 早期的网站流量和业务功能都比较简单，单台服务器足以满足基本的需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也跟着越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器进行性能的水平扩展及避免单点故障出现。那么如何将不同用户的请求流量分发到不同的服务器上呢？ ¶2、负载均衡的原理及处理流程 系统的扩展可以分为纵向扩展和横向扩展。 纵向扩展是从单机的角度出发，通过增加系统的硬件处理能力来提升服务器的处理能力 横向扩展是通过添加机器来满足大型网站服务的处理能力。 这里面涉及到两个重要的角色分别是\"应用集群\"和\"负载均衡器\"： 应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理并返回响应的数据。 负载均衡器：将用户访问的请求根据对应的负载均衡算法，分发到集群中的一台服务器进行处理。 ¶3、负载均衡的作用 解决服务器的高并发压力，提高应用程序的处理性能。 提供故障转移，实现高可用。 通过添加或减少服务器数量，增强网站的可扩展性。 在负载均衡器上进行过滤，可以提高系统的安全性。 ¶3、负载均衡常用的处理方式 ¶方式一：用户手动选择 这种方式比较原始，只要实现的方式就是在网站主页上面提供不同线路、不同服务器链接方式，让用户来选择自己访问的具体服务器，来实现负载均衡。 ¶方式二：DNS轮询方式 大多域名注册商都支持对同一个主机名添加多条A记录，这就是DNS轮询，DNS服务器将解析请求按照A记录的顺序，随机分配到不同的IP上，这样就能完成简单的负载均衡。DNS轮询的成本非常低，在一些不重要的服务器，被经常使用。 可以在云服务器控制台添加多条A记录解析！ 简单验证： 1ping 域名 清空本地的dns缓存再次测试ping： 1ipconfig/flushdns 我们发现使用DNS来实现轮询，不需要投入过多的成本，虽然DNS轮询成本低廉，但是DNS负载均衡存在明显的缺点： 可靠性低 假设一个域名DNS轮询多台服务器，如果其中的一台服务器发生故障，那么所有的访问该服务器的请求将不会有所回应，即使你将该服务器的IP从DNS中去掉，但是由于各大宽带接入商将众多的DNS存放在缓存中，以节省访问时间，导致DNS不会实时更新。所以DNS轮流上一定程度上解决了负载均衡问题，但是却存在可靠性不高的缺点。 负载均衡不均衡 DNS负载均衡采用的是简单的轮询负载算法，不能区分服务器的差异，不能反映服务器的当前运行状态，不能做到为性能好的服务器多分配请求，另外本地计算机也会缓存已经解析的域名到IP地址的映射，这也会导致使用该DNS服务器的用户在一定时间内访问的是同一台Web服务器，从而引发Web服务器减的负载不均衡。 负载不均衡则会导致某几台服务器负荷很低，而另外几台服务器负荷确很高，处理请求的速度慢，配置高的服务器分配到的请求少，而配置低的服务器分配到的请求多。 ¶方式三：四/七层负载均衡 介绍四/七层负载均衡之前，我们先了解一个概念，OSI(open system interconnection), 叫开放式系统互联模型，这个是由国际标准化组织ISO指定的一个不基于具体机型、操作系统或公司的网络体系结构。该模型将网络通信的工作分为七层。 简单介绍，属于计网知识： 应用层：为应用程序提供网络服务。 表示层：对数据进行格式化、编码、加密、压缩等操作。 会话层：建立、维护、管理会话连接。 传输层：建立、维护、管理端到端的连接，常见的有TCP/UDP。 网络层：IP寻址和路由选择 数据链路层：控制网络层与物理层之间的通信。 物理层：比特流传输。 七层和四层指的是从下往上看的第七和第四层！ 所谓四层负载均衡指的是OSI七层模型中的传输层，主要是基于IP+PORT的负载均衡： 123实现四层负载均衡的方式：硬件：F5 BIG-IP、Radware等软件：LVS、Nginx、Hayproxy等 所谓的七层负载均衡指的是在应用层，主要是基于虚拟的URL或主机IP的负载均衡： 12实现七层负载均衡的方式：软件：Nginx、Hayproxy等 四层和七层负载均衡的区别： 四层负载均衡数据包是在底层就进行了分发，而七层负载均衡数据包则在最顶端进行分发，所以四层负载均衡的效率比七层负载均衡的要高。 四层负载均衡不识别域名，而七层负载均衡识别域名。 了解： 除了四层和七层负载以为其实还有二层、三层负载均衡，二层是在数据链路层基于mac地址来实现负载均衡，三层是在网络层一般采用虚拟IP地址的方式实现负载均衡。 实际环境采用的模式：四层负载(LVS)+七层负载(Nginx) ¶4、Nginx七层负载均衡 Nginx要实现七层负载均衡需要用到proxy_pass代理模块配置。Nginx默认安装支持这个模块，我们不需要再做任何处理。Nginx的负载均衡是在Nginx的反向代理基础上把用户的请求根据指定的算法分发到一组 upstream虚拟服务池。 ¶负载均衡指令 upstream指令： 该指令是用来定义一组服务器，它们可以是监听不同端口的服务器，并且也可以是同时监听TCP和Unix socket的服务器。服务器可以指定不同的权重，默认为1。 语法 upstream name {…} 默认值 — 位置 http server指令： 该指令用来指定后端服务器的名称和一些参数，可以使用域名、IP、端口或者unix socket 语法 server name [paramerters] 默认值 — 位置 upstream ¶七层负载均衡的实现流程 服务端设置： 123456789101112131415161718192021222324server { listen 9001; server_name localhost; default_type text/html; location /{ return 200 '&lt;h1&gt;192.168.200.146:9001&lt;/h1&gt;'; }}server { listen 9002; server_name localhost; default_type text/html; location /{ return 200 '&lt;h1&gt;192.168.200.146:9002&lt;/h1&gt;'; }}server { listen 9003; server_name localhost; default_type text/html; location /{ return 200 '&lt;h1&gt;192.168.200.146:9003&lt;/h1&gt;'; }} 负载均衡器设置： 123456789101112upstream backend{ server 192.168.200.146:9091; server 192.168.200.146:9092; server 192.168.200.146:9093;}server { listen 8083; server_name localhost; location /{ proxy_pass http://backend; }} ¶负载均衡状态 状态 概述 down 当前的server暂时不参与负载均衡 backup 预留的备份服务器 max_fails 允许请求失败的次数 fail_timeout 经过max_fails失败后, 服务暂停时间 max_conns 限制最大的接收连接数 down：将该服务器标记为永久不可用，那么该代理服务器将不参与负载均衡。 该状态一般会对需要停机维护的服务器进行设置。 注意：谷歌浏览器在这种情况下不会进行轮询，其他浏览器没问题！可以通过cmd中的curl 地址进行测试！ 123456789101112upstream backend{ server 192.168.200.146:9001 down; server 192.168.200.146:9002 server 192.168.200.146:9003;}server { listen 8083; server_name localhost; location /{ proxy_pass http://backend; }} backup：将该服务器标记为备份服务器，当主服务器不可用时，将用来传递请求。 此时需要将9003端口的访问禁止掉来模拟下唯一能对外提供访问的服务宕机以后，backup的备份服务器就要开始对外提供服务，此时为了测试验证，我们需要使用防火墙firewalld来进行拦截。 123456789101112upstream backend{ server 192.168.200.146:9001 down; server 192.168.200.146:9002 backup; server 192.168.200.146:9003;}server { listen 8083; server_name localhost; location /{ proxy_pass http://backend; }} max_conns=number：用来设置代理服务器同时活动链接的最大数量，默认为0，表示不限制，使用该配置可以根据后端服务器处理请求的并发量来进行设置，防止后端服务器被压垮。 max_fails=number：设置允许请求代理服务器失败的次数，默认为1。 fail_timeout=time：设置经过max_fails失败后，服务暂停的时间，默认是10秒。 123456789101112upstream backend{ server 192.168.200.133:9001 down; server 192.168.200.133:9002 backup; server 192.168.200.133:9003 max_fails=3 fail_timeout=15;}server { listen 8083; server_name localhost; location /{ proxy_pass http://backend; }} ¶负载均衡策略 Nginx的upstream支持如下六种方式的分配算法，分别是： 算法名称 说明 轮询 默认方式 weight 权重方式 ip_hash 依据ip分配方式 least_conn 依据最少连接方式 url_hash 依据URL分配方式 fair 依据响应时间方式 ¶轮询 是upstream模块负载均衡默认的策略。每个请求会按时间顺序逐个分配到不同的后端服务器。轮询不需要额外的配置。 123456789101112upstream backend{ server 192.168.200.146:9001 weight=1; server 192.168.200.146:9002; server 192.168.200.146:9003;}server { listen 8083; server_name localhost; location /{ proxy_pass http://backend; }} ¶weight加权轮询 weight=number：用来设置服务器的权重，默认为1，权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的，所有此策略比较适合服务器的硬件配置差别比较大的情况。 123456789101112upstream backend{ server 192.168.200.146:9001 weight=10; server 192.168.200.146:9002 weight=5; server 192.168.200.146:9003 weight=3;}server { listen 8083; server_name localhost; location /{ proxy_pass http://backend; }} ¶ip_hash 当对后端的多台动态应用服务器做负载均衡时，ip_hash指令能够将某个客户端IP的请求通过哈希算法定位到同一台后端服务器上。这样，当来自某一个IP的用户在后端Web服务器A上登录后，在访问该站点的其他URL，能保证其访问的还是后端web服务器A。 语法 ip_hash; 默认值 — 位置 upstream 12345678910111213upstream backend{ ip_hash; server 192.168.200.146:9001; server 192.168.200.146:9002; server 192.168.200.146:9003;}server { listen 8083; server_name localhost; location /{ proxy_pass http://backend; }} 需要额外多说一点的是使用ip_hash指令无法保证后端服务器的负载均衡，可能导致有些后端服务器接收到的请求多，有些后端服务器接收的请求少，而且设置后端服务器权重等方法将不起作用。 ¶least_conn 最少连接，把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least_conn这种方式就可以达到更好的负载均衡效果。 12345678910111213upstream backend{ least_conn; server 192.168.200.146:9001; server 192.168.200.146:9002; server 192.168.200.146:9003;}server { listen 8083; server_name localhost; location /{ proxy_pass http://backend; }} 此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况。 ¶url_hash 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，要配合缓存命中来使用。同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费。而使用url_hash，可以使得同一个url（也就是同一个资源请求）会到达同一台服务器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取。 12345678910111213upstream backend{ hash &amp;request_uri; server 192.168.200.146:9001; server 192.168.200.146:9002; server 192.168.200.146:9003;}server { listen 8083; server_name localhost; location /{ proxy_pass http://backend; }} 访问如下地址： 123http://192.168.200.133:8083/ahttp://192.168.200.133:8083/bhttp://192.168.200.133:8083/c ¶fair fair采用的不是内置负载均衡使用的轮换的均衡算法，而是可以根据页面大小、加载时间长短智能的进行负载均衡。那么如何使用第三方模块的fair负载均衡策略。 fair属于第三方模块实现的负载均衡。需要添加nginx-upstream-fair,如何添加对应的模块: 1、下载nginx-upstream-fair模块 12下载地址为: https://github.com/gnosek/nginx-upstream-fair 2、将下载的文件上传到服务器并进行解压缩 1unzip nginx-upstream-fair-master.zip 3、重命名资源 1mv nginx-upstream-fair-master fair 4、使用./configure命令将资源添加到Nginx模块中 1./configure --add-module=/root/fair 5、编译 1make 编译可能会出现如下错误，ngx_http_upstream_srv_conf_t结构中缺少default_port 解决方案： 在Nginx的源码中 src/http/ngx_http_upstream.h,找到ngx_http_upstream_srv_conf_s，在模块中添加添加default_port属性 1in_port_t default_port 然后再进行make. 6、更新Nginx ​ 12345678# 6.1 将sbin目录下的nginx进行备份mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginxold# 6.2 将安装目录下的objs中的nginx拷贝到sbin目录cd objscp nginx /usr/local/nginx/sbin# 6.3 更新Nginxcd ../make upgrade ​ 7、编译测试使用Nginx 12345678910111213upstream backend{ fair; server 192.168.200.146:9001; server 192.168.200.146:9002; server 192.168.200.146:9003;}server { listen 8083; server_name localhost; location /{ proxy_pass http://backend; }} ¶负载均衡案例 案例一：对所有请求实现一般轮询规则的负载均衡 123456789101112upstream backend{ server 192.168.200.146:9001; server 192.168.200.146:9002; server 192.168.200.146:9003;}server { listen 8083; server_name localhost; location /{ proxy_pass http://backend; }} 案例二：对所有请求实现加权轮询规则的负载均衡 123456789101112upstream backend{ server 192.168.200.146:9001 weight=7; server 192.168.200.146:9002 weight=5; server 192.168.200.146:9003 weight=3;}server { listen 8083; server_name localhost; location /{ proxy_pass http://backend; }} 案例三：对特定资源实现负载均衡 123456789101112131415161718upstream videobackend{ server 192.168.200.146:9001; server 192.168.200.146:9002;}upstream filebackend{ server 192.168.200.146:9003; server 192.168.200.146:9004;}server { listen 8084; server_name localhost; location /video/ { proxy_pass http://videobackend; } location /file/ { proxy_pass http://filebackend; }} 案例四：对不同域名实现负载均衡 12345678910111213141516171819202122upstream itcastbackend{ server 192.168.200.146:9001; server 192.168.200.146:9002;}upstream itheimabackend{ server 192.168.200.146:9003; server 192.168.200.146:9004;}server { listen 8085; server_name www.itcast.cn; location / { proxy_pass http://itcastbackend; }}server { listen 8086; server_name www.itheima.cn; location / { proxy_pass http://itheimabackend; }} 案例五：实现带有URL重写的负载均衡 123456789101112131415upstream backend{ server 192.168.200.146:9001; server 192.168.200.146:9002; server 192.168.200.146:9003;}server { listen 80; server_name localhost; location /file/ { rewrite ^(/file/.*) /server/$1 last; } location / { proxy_pass http://backend; }} ¶5、Nginx四层负载均衡 Nginx在1.9之后，增加了一个stream模块，用来实现四层协议的转发、代理、负载均衡等。stream模块的用法跟http的用法类似，允许我们配置一组TCP或者UDP等协议的监听，然后通过proxy_pass来转发我们的请求，通过upstream添加多个后端服务，实现负载均衡。 四层协议负载均衡的实现，一般都会用到LVS、HAProxy、F5等，要么很贵要么配置很麻烦，而Nginx的配置相对来说更简单，更能快速完成工作。 ¶添加stream模块的支持 Nginx默认是没有编译这个模块的，需要使用到stream模块，那么需要在编译的时候加上--with-stream。 完成添加--with-stream的实现步骤: 123456》将原有/usr/local/nginx/sbin/nginx进行备份》拷贝nginx之前的配置信息》在nginx的安装源码进行配置指定对应模块 ./configure --with-stream》通过make模板进行编译》将objs下面的nginx移动到/usr/local/nginx/sbin下》在源码目录下执行 make upgrade进行升级，这个可以实现不停机添加新模块的功能 ¶负载均衡的指令 stream指令：该指令提供在其中指定流服务器指令的配置文件上下文。和http指令同级。 语法 stream { … } 默认值 — 位置 main upstream指令：该指令和http的upstream指令是类似的。 ¶四层负载均衡的案例 需求分析： 实现步骤： 准备Redis服务器：在一条服务器上准备三个Redis，端口分别是6379,6378 1234567891011121314151617# 将安装包进行解压缩tar -zxf redis-4.0.14.tar.gzcd redis-4.0.14# 使用make和install进行编译和安装make PREFIX=/usr/local/redis/redis01 install# 拷贝redis配置文件`redis.conf`到/usr/local/redis/redis01/bin目录中cp redis.conf /usr/local/redis/redis01/bin# 修改redis.conf配置文件port 6379 #redis的端口daemonize yes #后台启动redis# 将redis01复制一份为redis02cd /usr/local/rediscp -r redis01 redis02# 将redis02文件文件夹中的redis.conf进行修改port 6378 #redis的端口daemonize yes #后台启动redis# 分别启动，即可获取两个Redis.并查看ps -ef | grep redis 准备Tomcat服务器： 123tar -zxf apache-tomcat-8.5.56.tar.gzcd apache-tomcat-8.5.56/bin./startup nginx.conf配置： 123456789101112131415161718stream { upstream redisbackend { server 192.168.200.146:6379; server 192.168.200.146:6378; } upstream tomcatbackend { server 192.168.200.146:8080; } server { listen 81; # 没有server_name这个指令 proxy_pass redisbackend; } server { listen 82; proxy_pass tomcatbackend; }} 访问测试： 问题： http和stream中都访问同一端口，会进入哪个进行处理? 四层负载均衡在七层负载均衡前面，因此会进入stream访问！ ¶十、Nginx缓存集成 ¶1、缓存的概念 缓存就是数据交换的缓冲区(称作:Cache),当用户要获取数据的时候，会先从缓存中去查询获取数据，如果缓存中有就会直接返回给用户，如果缓存中没有，则会发请求从服务器重新查询数据，将数据返回给用户的同时将数据放入缓存，下次用户就会直接从缓存中获取数据。 缓存流程图示： 缓存的优点： 减少数据传输，节省网络流量，加快响应速度，提升用户体验； 减轻服务器压力； 提供服务端的高可用性； 缓存的缺点： 数据的不一致 增加成本 ¶2、Nginx的web缓存服务 Nginx是从0.7.48版开始提供缓存功能。Nginx是基于Proxy Store来实现的，其原理是把URL及相关组合当做Key, 在使用MD5算法对Key进行哈希，得到硬盘上对应的哈希目录路径，从而将缓存内容保存在该目录中。它可以支持任意URL连接，同时也支持404/301/302这样的非200状态码。Nginx即可以支持对指定URL或者状态码设置过期时间，也可以使用purge命令来手动清除指定URL的缓存。 Nginx中的步骤图示： ¶3、Nginx缓存相关指令 Nginx的web缓存服务主要是使用ngx_http_proxy_module模块相关指令集来完成，接下来我们把常用的指令来进行介绍下。 ¶proxy_cache_path 该指定用于设置缓存文件的存放路径 语法 proxy_cache_path path [levels=number] keys_zone=zone_name:zone_size [inactive=time][max_size=size]; 默认值 — 位置 http path：缓存路径地址 1/usr/local/proxy_cache levels: 指定该缓存空间对应的目录，最多可以设置3层，每层取值为1|2 123456levels=1:2 #缓存空间有两层目录，第一次是1个字母，第二次是2个字母#举例说明:itheima[key] #通过MD5加密以后的值为 43c8233266edce38c2c9af0694e2107dlevels=1:2 #最终的存储路径为/usr/local/proxy_cache/d/07levels=2:1:2 #最终的存储路径为/usr/local/proxy_cache/7d/0/21levels=2:2:2 #最终的存储路径为/usr/local/proxy_cache/7d/10/e2 keys_zone：用来为这个缓存区设置名称和指定大小 1keys_zone=itcast:200m #缓存区的名称是itcast,大小为200M,1M大概能存储8000个keys inactive：指定缓存的数据多次时间未被访问就将被删除 1inactive=1d #缓存数据在1天内没有被访问就会被删除 max_size：设置最大缓存空间，如果缓存空间存满，默认会覆盖缓存时间最长的资源，如: 1max_size=20g 配置实例： 123http{ proxy_cache_path /usr/local/proxy_cache keys_zone=itcast:200m levels=1:2:1 inactive=1d max_size=20g;} ¶proxy_cache 该指令用来开启或关闭代理缓存，如果是开启则自定使用哪个缓存区来进行缓存。 语法 proxy_cache zone_name|off; 默认值 proxy_cache off; 位置 http、server、location zone_name：指定使用缓存区的名称 ¶proxy_cache_key 该指令用来设置web缓存的key值，Nginx会根据key值MD5哈希存缓存。 语法 proxy_cache_key key; 默认值 proxy_cache_key $scheme$proxy_host$request_uri; 位置 http、server、location ¶proxy_cache_valid 该指令用来对不同返回状态码的URL设置不同的缓存时间 语法 proxy_cache_valid [code …] time; 默认值 — 位置 http、server、location 1234#为200和302的响应URL设置10分钟缓存，为404的响应URL设置1分钟缓存proxy_cache_valid 200 302 10m;proxy_cache_valid 404 1m;proxy_cache_valid any 1m; #对所有响应状态码的URL都设置1分钟缓存 ¶proxy_cache_min_uses 该指令用来设置资源被访问多少次后被缓存 语法 proxy_cache_min_uses number; 默认值 proxy_cache_min_uses 1; 位置 http、server、location ¶proxy_cache_methods 该指令用户设置缓存哪些HTTP方法 语法 proxy_cache_methods GET|HEAD|POST; 默认值 proxy_cache_methods GET HEAD; 位置 http、server、location 默认缓存HTTP的GET和HEAD方法，不缓存POST方法。 ¶4、Nginx缓存设置案例 需求分析： 应用服务器的环境准备： 在192.168.200.146服务器上的tomcat的webapps下面添加一个js目录，并在js目录中添加一个jquery.js文件 启动tomcat 访问测试 1http://192.168.200.146:8080/js/jquery.js Nginx的环境准备： 1、完成Nginx反向代理配置： 123456789101112http{ upstream backend{ server 192.168.200.146:8080; } server { listen 8080; server_name localhost; location / { proxy_pass http://backend/js/; } }} 2、添加缓存配置： 123456789101112131415161718192021http{ proxy_cache_path /usr/local/proxy_cache levels=2:1 keys_zone=itcast:200m inactive=1d max_size=20g; upstream backend{ server 192.168.200.146:8080; } server { listen 8080; server_name localhost; location / { proxy_cache itcast; # 默认应该为变值，这里测试使用了固定字串。默认为$scheme$proxy_host$request_uri; proxy_cache_key itheima; proxy_cache_min_uses 5; proxy_cache_valid 200 5d; proxy_cache_valid 404 30s; proxy_cache_valid any 1m; add_header nginx-cache \"$upstream_cache_status\"; proxy_pass http://backend/js/; } }} add_header nginx-cache “$upstream_cache_status”; 第一次为MISS表示没有命中nginx缓存，再次访问变为HIT表示命中缓存！ ¶5、Nginx缓存的清除 ¶方式一：删除对应的缓存目录 1rm -rf /usr/local/proxy_cache/...... ¶方式二：使用第三方扩展模块（推荐） 使用ngx_cache_purge模块，默认没有，需要安装！ 12345678910111213141516171819# 下载ngx_cache_purge模块对应的资源包，并上传到服务器上ngx_cache_purge-2.3.tar.gzwget http://labs.frickle.com/files/ngx_cache_purge-2.3.tar.gz# 对资源文件进行解压缩tar -zxf ngx_cache_purge-2.3.tar.gz# 修改文件夹名称，方便后期配置mv ngx_cache_purge-2.3 purge# 查询Nginx的配置参数nginx -V# 进入Nginx的安装目录，使用./configure进行参数配置./configure --add-module=/root/nginx/module/purge# 使用make进行编译make# 将nginx安装目录的nginx二级制可执行文件备份mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginxold# 将编译后的objs中的nginx拷贝到nginx的sbin目录下cp objs/nginx /usr/local/nginx/sbin# 使用make进行升级make upgrade 在nginx配置文件中进行如下配置： 123456server{ location ~/purge(/.*) { # 缓存名称 缓存key proxy_cache_purge itcast itheima; }} 直接访问/purge/文件…即可自动删除！ proxy_cache_purge：若是key动态的，则也应该与缓存设置中的key一致，即 $scheme$proxy_host$request_uri 会发现并不能正常删除，可以在nginx.conf中添加log_format指定日志文件格式： 12345678910111213141516171819202122232425262728log_format main $scheme$proxy_host$request_uri;server { listen 8080; server_name localhost; location / { # 指定使用的日志格式和位置 access_log logs/access.log main; proxy_cache itcast; # 默认应该为变值，这里测试使用了固定字串。默认为$scheme$proxy_host$request_uri; proxy_cache_key itheima; proxy_cache_min_uses 5; proxy_cache_valid 200 5d; proxy_cache_valid 404 30s; proxy_cache_valid any 1m; add_header nginx-cache \"$upstream_cache_status\"; proxy_pass http://backend/js/; }}server{ location ~/purge(/.*) { access_log logs/access.log main; # 缓存名称 缓存key proxy_cache_purge itcast itheima; }} 日志打印如下：两次访问路径不一致，因此不会删除！真实场景应该写为一致！ ¶6、Nginx设置资源不缓存 前面咱们已经完成了Nginx作为web缓存服务器的使用。但是我们得思考一个问题就是不是所有的数据都适合进行缓存。比如说对于一些经常发生变化的数据。如果进行缓存的话，就很容易出现用户访问到的数据不是服务器真实的数据。所以对于这些资源我们在缓存的过程中就需要进行过滤，不进行缓存。 Nginx也提供了这块的功能设置，需要使用到如下两个指令 1、proxy_no_cache 该指令是用来定义不将数据进行缓存的条件。 语法 proxy_no_cache string …; 默认值 — 位置 http、server、location 配置实例 1proxy_no_cache $cookie_nocache $arg_nocache $arg_comment; 2、proxy_cache_bypass 该指令是用来设置不从缓存中获取数据的条件。 语法 proxy_cache_bypass string …; 默认值 — 位置 http、server、location 配置实例 1proxy_cache_bypass $cookie_nocache $arg_nocache $arg_comment; 解释： 上述两个指令都有一个指定的条件，这个条件可以是多个，并且多个条件中至少有一个不为空且不等于\"0\",则条件满足成立。上面给的配置实例是从官方网站获取的，里面使用到了三个变量，分别是$cookie_nocache、$arg_nocache、$arg_comment $cookie_nocache：指的是当前请求的cookie中键的名称为nocache对应的值 $arg_nocache和$arg_comment：指的是当前请求的参数中属性名为nocache和comment对应的属性值 案例演示如下: 1234567891011log_format params $cookie_nocache | $arg_nocache | $arg_comment；server{ listen 8081; server_name localhost; location /{ access_log logs/access_params.log params; add_header Set-Cookie 'nocache=999'; root html; index index.html; }} 访问：https://ip:8081?nocache=888&amp;comment=777 日志文件就会出现999 888 777获取到的值! ¶案例实现 设置不缓存资源的配置方案 1234567891011121314server{ listen 8080; server_name localhost; location / { # 请求文件地址和正则匹配 if ($request_uri ~ /.*\\.js$){ # 设置其他变量也可，只需将该变量加到 proxy_no_cache 值中即可！ set $nocache 1; } add_header nginx-cache \"$upstream_cache_status\"; proxy_no_cache $nocache $cookie_nocache $arg_nocache $arg_comment; proxy_cache_bypass $nocache $cookie_nocache $arg_nocache $arg_comment; }} 若使用proxy_cache_bypass，将proxy_no_cache注释，访问会发现 nginx-cache值已经变为了BYPASS表示配置生效！ 官方推荐两个配置都开启，保证数据最新！ ¶十一、Nginx服务器端集群搭建 ¶1、Nginx实现动静分离 什么是动静分离? 动：后台应用程序的业务处理 静：网站的静态资源(html,javaScript,css,images等文件) 分离：将两者进行分开部署访问，提供用户进行访问。举例说明就是以后所有和静态资源相关的内容都交给Nginx来部署访问，非静态内容则交个类似于Tomcat的服务器来部署访问。 为什么要动静分离? 前面我们介绍过Nginx在处理静态资源的时候，效率是非常高的，而且Nginx的并发访问量也是名列前茅，而Tomcat则相对比较弱一些，所以把静态资源交给Nginx后，可以减轻Tomcat服务器的访问压力并提高静态资源的访问速度。 动静分离以后，降低了动态资源和静态资源的耦合度。如动态资源宕机了也不影响静态资源的展示。 如何实现动静分离? 实现动静分离的方式很多，比如静态资源可以部署到CDN、Nginx等服务器上，动态资源可以部署到Tomcat,weblogic或者websphere上。我们使用Nginx+Tomcat来实现动静分离。 需求分析： 动静分离实现步骤： 1、将demo.war包部署到tomcat中，把之前部署的内容删除掉 2、在Nginx所在服务器创建如下目录，并将对应的静态资源放入指定的位置 index.html： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $.get('http://192.168.200.133/demo/getAddress',function(data){ $(\"#msg\").html(data); }); }); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"images/logo.png\"/&gt; &lt;h1&gt;Nginx如何将请求转发到后端服务器&lt;/h1&gt; &lt;h3 id=\"msg\"&gt;&lt;/h3&gt; &lt;img src=\"images/mv.png\"/&gt;&lt;/body&gt;&lt;/html&gt; 3、配置Nginx的静态资源与动态资源的访问 12345678910111213141516171819202122upstream webservice{ server 192.168.200.146:8080;}server { listen 80; server_name localhost; #动态资源 location /demo { proxy_pass http://webservice; } #静态资源 location ~/.*\\.(png|jpg|gif|js){ root html/web; gzip on; } location / { root html/web; index index.html index.htm; }} 4、启动测试，访问 http://192.168.200.133/ 小结： 假如某个时间点，由于某个原因导致Tomcat后的服务器宕机了，我们再次访问Nginx，用户还是能看到页面，只是缺失了访问端口的展示，这就是前后端耦合度降低的效果，并且整个请求只和后的服务器交互了一次，js和images都直接从Nginx返回，提供了效率，降低了后的服务器的压力。 ¶2、Nginx实现Tomcat集群搭建 一台服务器容易宕机，那就多搭建几台Tomcat服务器，这样的话就提升了后的服务器的可用性。这也就是我们常说的集群，搭建Tomcat的集群需要用到了Nginx的反向代理和负载均衡的知识，具体如何来实现?我们先来分析下原理： 环境准备： 1、准备3台tomcat，使用端口进行区分[实际环境应该是三台服务器]，修改server.xml，将端口修改分别修改为8080,8180,8280。将shutdown端口也修改了不要一样！ 2、启动tomcat并访问测试 123http://192.168.200.146:8080/demo/getAddresshttp://192.168.200.146:8180/demo/getAddresshttp://192.168.200.146:8280/demo/getAddress 3、在Nginx对应的配置文件中添加如下内容 12345upstream webservice{ server 192.168.200.146:8080; server 192.168.200.146:8180; server 192.168.200.146:8280;} ¶3、Nginx高可用解决方案 需要两台以上的Nginx服务器对外提供服务，这样的话就可以解决其中一台宕机了，另外一台还能对外提供服务，但是如果是两台Nginx服务器的话，会有两个IP地址，用户该访问哪台服务器，用户怎么知道哪台是好的，哪台是宕机了的? 这就要用到 Keepalived 了！ ¶Keepalived 使用Keepalived来解决，Keepalived 软件由 C 编写的，最初是专为 LVS 负载均衡软件设计的，Keepalived 软件主要是通过 VRRP 协议实现高可用功能。 ¶VRRP介绍 VRRP（Virtual Route Redundancy Protocol）协议：翻译过来为虚拟路由冗余协议。VRRP协议将两台或多台路由器设备虚拟成一个设备，对外提供虚拟路由器IP,而在路由器组内部，如果实际拥有这个对外IP的路由器如果工作正常的话就是MASTER, MASTER实现针对虚拟路由器IP的各种网络功能。其他设备不拥有该虚拟IP，状态为BACKUP,处了接收MASTER的VRRP状态通告信息以外，不执行对外的网络功能。当主机失效时，BACKUP将接管原先MASTER的网络功能。 从上面的介绍信息获取到的内容就是VRRP是一种协议，那这个协议是用来干什么的？ 选择协议：VRRP可以把一个虚拟路由器的责任动态分配到局域网上的 VRRP 路由器中的一台。其中的虚拟路由即Virtual路由是由VRRP路由群组创建的一个不真实存在的路由，这个虚拟路由也是有对应的IP地址。而且VRRP路由1和VRRP路由2之间会有竞争选择，通过选择会产生一个Master路由和一个Backup路由。 路由容错协议：Master路由和Backup路由之间会有一个心跳检测，Master会定时告知Backup自己的状态，如果在指定的时间内，Backup没有接收到这个通知内容，Backup就会替代Master成为新的Master。Master路由有一个特权就是虚拟路由和后端服务器都是通过Master进行数据传递交互的，而备份节点则会直接丢弃这些请求和数据，不做处理，只是去监听Master的状态 用了Keepalived后，解决方案如下： ¶环境搭建 环境准备： VIP IP 主机名 主/从 192.168.200.133 keepalived1 Master 192.168.200.222 192.168.200.122 keepalived2 Backup keepalived的安装： 12345678910# 步骤1:从官方网站下载keepalived,官网地址https://keepalived.org/# 步骤2:将下载的资源上传到服务器 keepalived-2.0.20.tar.gz# 步骤3:创建keepalived目录，方便管理资源mkdir keepalived# 步骤4:将压缩文件进行解压缩，解压缩到指定的目录tar -zxf keepalived-2.0.20.tar.gz -C keepalived/# 步骤5:对keepalived进行配置，编译和安装cd keepalived/keepalived-2.0.20./configure --sysconf=/etc --prefix=/usr/localmake &amp;&amp; make install /etc/keepalived/keepalived.conf：keepalived的系统配置文件 /usr/local/sbin/keepalived：是系统配置脚本，用来启动和关闭keepalived ¶Keepalived配置文件介绍 这里面会分三部，第一部分是global全局配置、第二部分是vrrp相关配置、第三部分是LVS相关配置。 我们主要是使用keepalived实现高可用部署，没有用到LVS，所以我们重点关注的是前两部分！ 配置介绍： 12345678910111213141516171819202122232425#global全局部分：global_defs { #通知邮件，当keepalived发送切换时需要发email给具体的邮箱地址 notification_email { tom@itcast.cn jerry@itcast.cn } #设置发件人的邮箱信息 notification_email_from zhaomin@itcast.cn #指定smpt服务地址 smtp_server 192.168.200.1 #指定smpt服务连接超时时间 smtp_connect_timeout 30 #运行keepalived服务器的一个标识，可以用作发送邮件的主题信息 router_id LVS_DEVEL #默认是不跳过检查。检查收到的VRRP通告中的所有地址可能会比较耗时，设置此命令的意思是，如果通告与接收的上一个通告来自相同的master路由器，则不执行检查(跳过检查) vrrp_skip_check_adv_addr #严格遵守VRRP协议。 vrrp_strict #在一个接口发送的两个免费ARP之间的延迟。可以精确到毫秒级。默认是0 vrrp_garp_interval 0 #在一个网卡上每组na消息之间的延迟时间，默认为0 vrrp_gna_interval 0} VRRP实例配置： 123456789101112131415161718192021# VRRP部分，该部分可以包含以下四个子模块# 1. vrrp_script# 2. vrrp_sync_group# 3. garp_group# 4. vrrp_instance# 我们会用到第一个和第四个# 设置keepalived实例的相关信息，VI_1为VRRP实例名称vrrp_instance VI_1 { state MASTER #有两个值可选MASTER主 BACKUP备 interface ens33 #vrrp实例绑定的接口，用于发送VRRP包[当前服务器使用的网卡名称] virtual_router_id 51#指定VRRP实例ID，范围是0-255 priority 100 #指定优先级，优先级高的将成为MASTER advert_int 1 #指定发送VRRP通告的间隔，单位是秒 authentication { #vrrp之间通信的认证信息 auth_type PASS #指定认证方式。PASS简单密码认证(推荐) auth_pass 1111 #指定认证使用的密码，最多8位 } virtual_ipaddress { #虚拟IP地址设置虚拟IP地址，供用户访问使用，可设置多个，一行一个 192.168.200.222 }} 完整配置服务器1： 1234567891011121314151617181920212223242526272829global_defs { notification_email { tom@itcast.cn jerry@itcast.cn } notification_email_from zhaomin@itcast.cn smtp_server 192.168.200.1 smtp_connect_timeout 30 router_id keepalived1 vrrp_skip_check_adv_addr vrrp_strict vrrp_garp_interval 0 vrrp_gna_interval 0}vrrp_instance VI_1 { state MASTER interface ens33 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.200.222 }} 完整配置服务器2： 1234567891011121314151617181920212223242526272829global_defs { notification_email { tom@itcast.cn jerry@itcast.cn } notification_email_from zhaomin@itcast.cn smtp_server 192.168.200.1 smtp_connect_timeout 30 router_id keepalived2 vrrp_skip_check_adv_addr vrrp_strict vrrp_garp_interval 0 vrrp_gna_interval 0}vrrp_instance VI_1 { state BACKUP interface ens33 virtual_router_id 51 priority 90 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.200.222 }} ¶访问测试 1、启动keepalived之前，先使用命令 ip a, 查看192.168.200.133和192.168.200.122这两台服务器的IP情况。 2、分别启动两台服务器的keepalived 12cd /usr/local/sbin./keepalived 再次通过 ip a查看ip： 3、当把192.168.200.133服务器上的keepalived关闭后，再次查看ip 总结： 我们会发现，虚拟IP(VIP)会在MASTER节点上，当MASTER节点上的keepalived出问题以后，因为BACKUP无法收到MASTER发出的VRRP状态通过信息，就会直接升为MASTER。VIP也会\"漂移\"到新的MASTER。 我们把192.168.200.133服务器的keepalived再次启动下，由于它的优先级高于服务器192.168.200.122的，所有它会再次成为MASTER，VIP也会\"漂移\"过去，然后我们再次通过浏览器访问：http://192.168.200.222/ 我们会发现要想让vip进行切换，就必须要把服务器上的keepalived进行关闭 ¶keepalived之vrrp_script keepalived只能做到对网络故障和keepalived本身的监控，即当出现网络故障或者keepalived本身出现问题时，进行切换。 但是这些还不够，我们还需要监控keepalived所在服务器上的其他业务，比如Nginx,如果Nginx出现异常了，仅仅keepalived保持正常，是无法完成系统的正常工作的，因此需要根据业务进程的运行状态决定是否需要进行主备切换，这个时候，我们可以通过编写脚本对业务进程进行检测监控。 实现步骤： 在keepalived配置文件中添加对应的配置： 123456vrrp_script 脚本名称{ script \"脚本位置\" interval 3 #执行时间间隔 weight -20 #动态调整vrrp_instance的优先级} 编写脚本 ck_nginx.sh： 123456789#!/bin/bashnum=`ps -C nginx --no-header | wc -l`if [ $num -eq 0 ];then /usr/local/nginx/sbin/nginx sleep 2 if [ `ps -C nginx --no-header | wc -l` -eq 0 ]; then killall keepalived fifi ps命令：用于显示当前进程 (process) 的状态 -C(command)：指定命令的所有进程 –no-header：排除标题 为脚本文件设置权限： 1chmod 755 ck_nginx.sh 将脚本添加到配置文件： 12345678910111213141516171819202122vrrp_script ck_nginx { script \"/etc/keepalived/ck_nginx.sh\" #执行脚本的位置 interval 2 #执行脚本的周期，秒为单位 weight -20 #权重的计算方式，表示当前Master挂了后，将自身权重降低20，降到小于Backup的优先级即可，这样可以保证当前nginx正常后，不会自动再切换回当前服务器}vrrp_instance VI_1 { state MASTER interface ens33 virtual_router_id 10 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.200.111 } track_script { ck_nginx }} 如果效果没有出来，可以使用 tail -f /var/log/messages查看日志信息，找对应的错误信息。 问题思考？ 通常如果master服务死掉后backup会变成master，但是当master服务又好了的时候 master此时会抢占VIP，这样就会发生两次切换对业务繁忙的网站来说是不好的。可以设置vrrp_script中的weight来动态调整当前nginx的优先级！ ¶十二、Nginx制作下载站点 首先我们先要清楚什么是下载站点? 我们先来看一个网站http://nginx.org/download/这个我们刚开始学习Nginx的时候给大家看过这样的网站，该网站主要就是用来提供用户来下载相关资源的网站，就叫做下载网站。 如何制作一个下载站点？ nginx使用的是模块ngx_http_autoindex_module来实现的，该模块处理以斜杠(“/”)结尾的请求，并生成目录列表。 nginx编译的时候会自动加载该模块，但是该模块默认是关闭的，我们需要使用下来指令来完成对应的配置。 1、autoindex：启用或禁用目录列表输出 语法 autoindex on|off; 默认值 autoindex off; 位置 http、server、location 2、autoindex_exact_size：对应HTLM格式，指定是否在目录列表展示文件的详细大小 默认为on，显示出文件的确切大小，单位是bytes。 改为off后，显示出文件的大概大小，单位是kB或者MB或者GB 语法 autoindex_exact_size on|off; 默认值 autoindex_exact_size on; 位置 http、server、location 3、autoindex_format：设置目录列表的格式 语法 autoindex_format html|xml|json|jsonp; 默认值 autoindex_format html; 位置 http、server、location 注意： 该指令在1.7.9及以后版本中出现 XML/JSON格式一般不用这两种方式！ 4、autoindex_localtime：对应HTML格式，是否在目录列表上显示时间。 默认为off，显示的文件时间为GMT时间。 改为on后，显示的文件时间为文件的服务器时间 语法 autoindex_localtime on | off; 默认值 autoindex_localtime off; 位置 http、server、location 配置方式如下: 1234567location /download{ root /usr/local; autoindex on; autoindex_exact_size on; autoindex_format html; autoindex_localtime on;} ¶十三、Nginx的用户认证模块 对应系统资源的访问，我们往往需要限制谁能访问，谁不能访问。这块就是我们通常所说的认证部分，认证需要做的就是根据用户输入的用户名和密码来判定用户是否为合法用户，如果是则放行访问，如果不是则拒绝访问。 Nginx对应用户认证这块是通过 ngx_http_auth_basic_module 模块来实现的，它允许通过使用\"HTTP基本身份验证\"协议验证用户名和密码来限制对资源的访问。默认情况下nginx是已经安装了该模块，如果不需要则使用 --without-http_auth_basic_module。 1、auth_basic：使用“ HTTP基本认证”协议启用用户名和密码的验证 语法 auth_basic string|off; 默认值 auth_basic off; 位置 http,server,location,limit_except 开启后，服务端会返回401，指定的字符串会返回到客户端，给用户以提示信息，但是不同的浏览器对内容的展示不一致。 2、auth_basic_user_file：指定用户名和密码所在文件 语法 auth_basic_user_file file; 默认值 — 位置 http,server,location,limit_except 指定文件路径，该文件中的用户名和密码的设置，密码需要进行加密。可以采用工具自动生成 nginx.conf 添加如下内容： 123456789location /download{ root /usr/local; autoindex on; autoindex_exact_size on; autoindex_format html; autoindex_localtime on; auth_basic 'please input your auth'; auth_basic_user_file htpasswd; # 文件路径/usr/local/nginx/conf/htpasswd} 我们需要使用htpasswd工具生成用户名和密码： 1yum install -y httpd-tools 1234htpasswd -c /usr/local/nginx/conf/htpasswd username #创建一个新文件记录用户名和密码htpasswd -b /usr/local/nginx/conf/htpasswd username password #在指定文件新增一个用户名和密码htpasswd -D /usr/local/nginx/conf/htpasswd username #从指定文件删除一个用户信息htpasswd -v /usr/local/nginx/conf/htpasswd username #验证用户名和密码是否正确 效果如下： 小结： 上述方式虽然能实现用户名和密码的验证，但是大家也看到了，所有的用户名和密码信息都记录在文件里面，如果用户量过大的话，这种方式就显得有点麻烦了，这时候我们就得通过后台业务代码来进行用户权限的校验了。 ¶十四、Nginx的扩展模块 Nginx是可扩展的，可用于处理各种使用场景。本节中，我们将探讨使用Lua扩展Nginx的功能。 ¶1、Lua ¶概念 Lua是一种轻量、小巧的脚本语言，用标准C语言编写并以源代码形式开发。设计的目的是为了嵌入到其他应用程序中，从而为应用程序提供灵活的扩展和定制功能。 ¶特性 跟其他语言进行比较，Lua有其自身的特点： 轻量级：Lua用标准C语言编写并以源代码形式开发，编译后仅仅一百余千字节，可以很方便的嵌入到其他程序中。 可扩展：Lua提供非常丰富易于使用的扩展接口和机制，由宿主语言(通常是C或C++)提供功能，Lua可以使用它们，就像内置的功能一样。 支持面向过程编程和函数式编程 ¶应用场景 Lua在不同的系统中得到大量应用，场景的应用场景如下: 游戏开发、独立应用脚本、web应用脚本、扩展和数据库插件、系统安全上。 ¶Lua的安装 在linux上安装Lua非常简单，只需要下载源码包并在终端解压、编译即可使用。 Lua的官网地址为:https://www.lua.org 123456wget https://www.lua.org/ftp/lua-5.4.1.tar.gzcd lua-5.4.1make linux testmake install# 验证是否安装成功lua -v ¶Lua的语法 Lua和C/C++语法非常相似，整体上比较清晰，简洁。条件语句、循环语句、函数调用都与C/C++基本一致。如果对C/C++不太熟悉的同学来说，也没关系，因为天下语言是一家，基本上理解起来都不会太困难。我们一点点来讲。 ¶第一个Lua程序 Lua交互式编程模式：可以通过命令lua -i 或lua来启用 Lua脚本式编程模式：是将代码保存到一个以lua为扩展名的文件中并执行的方式 脚本式方式一： 我们需要一个文件名为 hello.lua,在文件中添加要执行的代码，然后通过命令 lua hello.lua来执行，会在控制台输出对应的结果。 hello.lua 1print(\"Hello World!!\") 脚本式方式二： 将hello.lua做如下修改 12#!/usr/local/bin/luaprint(\"Hello World!!!\") 第一行用来指定Lua解释器所在位置为 /usr/local/bin/lua，加上#号标记解释器会忽略它。一般情况下#!就是用来指定用哪个程序来运行本文件。但是hello.lua并不是一个可执行文件，需要通过chmod来设置可执行权限，最简单的方式为： 1234chmod 755 hello.lua# 执行即可./hello.lua 可以使用dofile函数指明lua脚本路径在交互式命令行中运行： 1dofile(\"lua_demo/hello.lua\") 注意：在Lua语言中，连续语句之间的分隔符并不是必须的，也就是说后面不需要加分号，当然加上也不会报错 在Lua语言中，表达式之间的换行也起不到任何作用。如以下四个写法，其实都是等效的 12345678910--写法一a=1b=a+2--写法二a=1;b=a+2;--写法三a=1; b=a+2;--写法四a=1 b=a+2 不建议使用第四种方式，可读性太差。 ¶Lua的注释 关于Lua的注释要分两种，第一种是单行注释，第二种是多行注释。 单行注释的语法为： 1--注释内容 多行注释的语法为: 1234--[[ 注释内容 注释内容--]] 如果想取消多行注释，只需要在第一个–之前在加一个-即可 1234---[[ 注释内容 注释内容--]] ¶标识符 换句话说标识符就是我们的变量名，Lua定义变量名以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字（0到9）。这块建议大家最好不要使用下划线加大写字母的标识符，因为Lua的保留字也是这样定义的，容易发生冲突。注意Lua是区分大小写字母的。 ¶关键字 下列是Lua的关键字，大家在定义常量、变量或其他用户自定义标识符都要避免使用以下这些关键字： and break do else elseif end false for function if in local nil not or repeat return then true until while goto 一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。这个也是上面我们不建议这么定义标识符的原因。 ¶运算符 Lua中支持的运算符有算术运算符、关系运算符、逻辑运算符、其他运算符。 算术运算符： 1234567+ 加法- 减法* 乘法/ 除法% 取余^ 乘幂- 负号 关系运算符： 123456== 等于~= 不等于&gt; 大于&lt; 小于&gt;= 大于等于&lt;= 小于等于 逻辑运算符： 123and 逻辑与or 逻辑或not 逻辑非 其他运算符： 12.. -- 连接两个字符串# -- 一元运算符，返回字符串或表的长度 例如: 12&gt; \"HELLO \"..\"WORLD\" --&gt;HELLO WORLD&gt; #\"HELLO\" --&gt;5 ¶全局变量&amp;局部变量 在Lua语言中，全局变量无须声明即可使用。在默认情况下，变量总是认为是全局的，如果未提前赋值，默认为nil 要想声明一个局部变量，需要使用local来声明 ¶Lua数据类型 Lua有8个数据类型： 12345678nil(空，无效值)boolean(布尔，true/false)number(数值)string(字符串)function(函数)table（表）thread(线程)userdata（用户数据） 可以使用type函数测试给定变量或者的类型： 123456789print(type(nil)) --&gt;nilprint(type(true)) --&gt; booleanprint(type(1.1*1.1)) --&gt; numberprint(type(\"Hello world\")) --&gt; stringprint(type(io.stdin)) --&gt;userdataprint(type(print)) --&gt; functionprint(type(type)) --&gt;functionprint(type{}) --&gt;tableprint(type(type(X))) --&gt; string nil：nil是一种只有一个nil值的类型，它的作用可以用来与其他所有值进行区分，也可以当想要移除一个变量时，只需要将该变量名赋值为nil,垃圾回收就会会释放该变量所占用的内存。 boolean：具有两个值，true和false。boolean类型一般被用来做条件判断的真与假。在Lua语言中，只会将false和nil视为假，其他的都视为真，特别是在条件检测中0和空字符串都会认为是真，这个和我们熟悉的大多数语言不太一样。 number：在Lua5.3版本开始，Lua语言为数值格式提供了两种选择：integer(整型)和float(双精度浮点型)[和其他语言不太一样，float不代表单精度类型。 数值常量的表示方式： 1234&gt;4 --&gt;4&gt;0.4 --&gt;0.4&gt;4.75e-3 --&gt;0.00475&gt;4.75e3 --&gt;4750 不管是整型还是双精度浮点型，使用type()函数来取其类型，都会返回的是number： 12&gt;type(3) --&gt;number&gt;type(3.3) --&gt;number 所以它们之间是可以相互转换的，同时，具有相同算术值的整型值和浮点型值在Lua语言中是相等的。 string：Lua语言中的字符串即可以表示单个字符，也可以表示一整本书籍。在Lua语言中，操作100K或者1M个字母组成的字符串的程序很常见。可以使用单引号或双引号来声明字符串。 如果声明的字符串比较长或者有多行，则可以使用如下方式进行声明 12345678910html = [[&lt;html&gt;&lt;head&gt;&lt;title&gt;Lua-string&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"http://www.lua.org\"&gt;Lua&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;]] table：是Lua语言中最主要和强大的数据结构。使用表， Lua 语言可以以一种简单、统一且高效的方式表示数组、集合、记录和其他很多数据结构。 Lua语言中的表本质上是一种辅助数组。这种数组比Java中的数组更加灵活，可以使用数值做索引，也可以使用字符串或其他任意类型的值作索引(除nil外)。 创建表的最简单方式： 1&gt; a = {} 创建数组： 1&gt;arr = {\"TOM\",\"JERRY\",\"ROSE\"} 要想获取数组中的值，我们可以通过如下内容来获取: 1234print(arr[0]) nilprint(arr[1]) TOMprint(arr[2]) JERRYprint(arr[3]) ROSE 从上面的结果可以看出来，数组的下标默认是从1开始的。所以上述创建数组，也可以通过如下方式来创建。 1234&gt;arr = {}&gt;arr[1] = \"TOM\"&gt;arr[2] = \"JERRY\"&gt;arr[3] = \"ROSE\" 上面我们说过了，表的索引既可以是数字，也可以是字符串等其他的内容，所以我们也可以将索引更改为字符串来创建 1234&gt;arr = {}&gt;arr[\"X\"] = 10&gt;arr[\"Y\"] = 20&gt;arr[\"Z\"] = 30 当然，如果想要获取这些数组中的值，可以使用下面的方式 12345678-- 方式一&gt;print(arr[\"X\"])&gt;print(arr[\"Y\"])&gt;print(arr[\"Z\"])-- 方式二&gt;print(arr.X)&gt;print(arr.Y)&gt;print(arr.Z) 当前table的灵活不进于此，还有更灵活的声明方式 1&gt;arr = {\"TOM\",X=10,\"JERRY\",Y=20,\"ROSE\",Z=30} 如何获取上面的值? 12345TOM : arr[1]10 : arr[\"X\"] | arr.XJERRY: arr[2]20 : arr[\"Y\"] | arr.YROESE: arr[3] function：在 Lua语言中，函数（ Function ）是对语句和表达式进行抽象的主要方式。 定义函数的语法为： 123function functionName(params)end 函数被调用的时候，传入的参数个数与定义函数时使用的参数个数不一致的时候，Lua 语言会通过 抛弃多余参数和将不足的参数设为 nil 的方式来调整参数的个数： 12345678function f(a,b) print(a,b)endf() --&gt; nil nilf(2) --&gt; 2 nilf(2,6) --&gt; 2 6f(2.6.8) --&gt; 2 6 (8被丢弃) 可变长参数函数： 12345678function add(...) a,b,c=... print(a) print(b) print(c)endadd(1,2,3) --&gt; 1 2 3 函数返回值可以有多个，这点和Java不太一样： 12345function f(a,b) return a,bendx,y=f(11,22) --&gt; x=11,y=22 thread：翻译过来是线程的意思，在Lua中，thread用来表示执行的独立线路，用来执行协同程序。 userdata：是一种用户自定义数据，用于表示一种由应用程序或C/C++语言库所创建的类型。 ¶Lua控制结构 Lua 语言提供了一组精简且常用的控制结构，包括用于条件执行的证 以及用于循环的 while、 repeat 和 for。 所有的控制结构语法上都有一个显式的终结符： end 用于终结 if、 for 及 while 结构， until 用于终结 repeat 结构。 ¶if then elseif else 12345678910111213141516171819function testif(a) if a&gt;0 then print(\"a是正数\") else print(\"a是负数\") endendfunction show(age) if age&lt;=18 then return \"青少年\" elseif age&gt;18 and age&lt;=45 then return \"青年\" elseif age&gt;45 and age&lt;=60 then return \"中年人\" elseif age&gt;60 then return \"老年人\" endend ¶while循环 语法： 123while 条件 do 循环体end 1234567function testWhile() local i = 1 while i&lt;=10 do print(i) i=i+1 endend ¶repeat循环 语法： 123repeat 循环体 until 条件 1234567function testRepeat() local i = 10 repeat print(i) i=i-1 until i &lt; 1end ¶for循环 数值型for循环： 语法： 123for param=exp1,exp2,exp3 do 循环体end param的值从exp1变化到exp2之前的每次循环会执行 循环体，并在每次循环结束后将步长(step)exp3增加到param上。exp3可选，如果不设置默认为1。 123for i = 1,100,10 do print(i)end 泛型for循环： 泛型for循环通过一个迭代器函数来遍历所有值，类似于java中的foreach语句。 语法： 123for i,v in ipairs(x) do 循环体end i是数组索引值，v是对应索引的数组元素值，ipairs是Lua提供的一个迭代器函数，用来迭代数组，x是要遍历的数组。 例如: 1234arr = {\"TOME\",\"JERRY\",\"ROWS\",\"LUCY\"}for i,v in ipairs(arr) do print(i,v)end 但是如果将arr的值进行修改为 1arr = {\"TOME\",\"JERRY\",\"ROWS\",x=\"JACK\",\"LUCY\"} 其中的x为JACK就无法遍历出来，缺失了数据，如果解决呢? 我们可以将迭代器函数变成pairs： 123for i,v in pairs(arr) do print(i,v)end 上述实例就输出的结果为： 123451 TOM2 JERRY3 ROWS4 LUCYx JACK ¶2、ngx_lua模块概念 淘宝开发的ngx_lua模块通过将lua解释器集成进Nginx，可以采用lua脚本实现业务逻辑，由于lua的紧凑、快速以及内建协程，所以在保证高并发服务能力的同时极大地降低了业务逻辑实现成本。 ¶3、ngx_lua模块环境准备 ¶方式一：lua-nginx-module 一般不使用这种方式，比较繁杂，推荐使用下方的方式二！ ¶方式二：OpenRestry（推荐） ¶概述 前面我们提到过，OpenResty是由淘宝工程师开发的，所以其官方网站 http://openresty.org/ 我们读起来是非常的方便。OpenResty是一个基于Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。所以本身OpenResty内部就已经集成了Nginx和Lua，所以我们使用起来会更加方便。 openresty已经内置了nginx，因此先将之前的nginx关掉！ ¶安装 1234567891011121314(1) 下载OpenResty：https://openresty.org/download/openresty-1.15.8.2.tar.gz(2)使用wget下载: wget https://openresty.org/download/openresty-1.15.8.2.tar.gz(3)解压缩: tar -zxf openresty-1.15.8.2.tar.gz(4)进入OpenResty目录: cd openresty-1.15.8.2(5) 执行命令:./configure(6) 执行命令:make &amp;&amp; make install(7)进入OpenResty的目录，找到nginx：cd /usr/local/openresty/nginx/(8)在conf目录下的nginx.conf添加如下内容location /lua{ default_type 'text/html'; content_by_lua 'ngx.say(\"&lt;h1&gt;HELLO,OpenRestry&lt;/h1&gt;\")';}(9)在sbin目录下启动nginx(10)通过浏览器访问测试 ¶4、ngx_lua的使用 使用Lua编写Nginx脚本的基本构建块是指令。指令用于指定何时运行用户Lua代码以及如何使用结果。下图显示了执行指令的顺序。 先来解释下*的作用： 123*：无 ， 即 xxx_by_lua ,指令后面跟的是 lua指令*:_file，即 xxx_by_lua_file 指令后面跟的是 lua文件*:_block,即 xxx_by_lua_block 在0.9.17版后替换init_by_lua_file init_by_lua*：该指令在每次Nginx重新加载配置时执行，可以用来完成一些耗时模块的加载，或者初始化一些全局配置。 init_worker_by_lua*：该指令用于启动一些定时任务，如心跳检查、定时拉取服务器配置等。 set_by_lua*：该指令只要用来做变量赋值，这个指令一次只能返回一个值，并将结果赋值给Nginx中指定的变量。 rewrite_by_lua*：该指令用于执行内部URL重写或者外部重定向，典型的如伪静态化URL重写，本阶段在rewrite处理阶段的最后默认执行。 access_by_lua*：该指令用于访问控制。例如，如果只允许内网IP访问。 content_by_lua*：该指令是应用最多的指令，大部分任务是在这个阶段完成的，其他的过程往往为这个阶段准备数据，正式处理基本都在本阶段。 header_filter_by_lua*：该指令用于设置应答消息的头部信息。 body_filter_by_lua*：该指令是对响应数据进行过滤，如截断、替换。 log_by_lua*：该指令用于在log请求处理阶段，用Lua代码处理日志，但并不替换原有log处理。 balancer_by_lua*：该指令主要的作用是用来实现上游服务器的负载均衡器算法* ssl_certificate_by_*：该指令作用在Nginx和下游服务开始一个SSL握手操作时将允许本配置项的Lua代码。 需求： 123http://192.168.200.133?name=张三&amp;gender=1Nginx接收到请求后，根据gender传入的值，如果gender传入的是1，则在页面上展示张三先生,如果gender传入的是0，则在页面上展示张三女士,如果未传或者传入的不是1和2则在页面上展示张三。 实现代码： 123456789101112131415161718192021location /getByGender { default_type 'text/html'; set_by_lua $name \" local uri_args = ngx.req.get_uri_args() gender = uri_args['gender'] name = uri_args['name'] if gender=='1' then return name..'先生' elseif gender=='0' then return name..'女士' else return name end \"; header_filter_by_lua \" ngx.header.aaa='bbb' \"; # 解决中文乱码 charset utf-8; return 200 $name;} ¶5、ngx_lua操作Redis Redis在系统中经常作为数据缓存、内存数据库使用，在大型系统中扮演着非常重要的作用。 在Nginx核心系统中，Redis是常备组件。 Nginx支持3种方法访问Redis, 分别是HttpRedis模块、HttpRedis2Module、lua-resty-redis库。这三种方式中HttpRedis模块提供的指令少，功能单一，适合做简单缓存，HttpRedis2Module模块比HttpRedis模块操作更灵活，功能更强大。而Lua-resty-redis库是OpenResty提供的一个操作Redis的接口库，可根据自己的业务情况做一些逻辑处理，适合做复杂的业务逻辑。我们主要以Lua-resty-redis来学习。 ¶lua-resty-redis环境准备 步骤一：准备一个Redis环境 1连接地址host= 192.168.200.111port=6379 步骤二：准备对应的API 123456789101112131415lua-resty-redis提供了访问Redis的详细API，包括创建对接、连接、操作、数据处理等。这些API基本上与Redis的操作一一对应。（1）redis = require \"resty.redis\"（2）new 语法: redis,err = redis:new(),创建一个Redis对象。（3）connect 语法:ok,err=redis:connect(host,port[,options_table]),设置连接Redis的连接信息。 ok:连接成功返回 1，连接失败返回nil err:返回对应的错误信息（4）set_timeout 语法: redis:set_timeout(time) ，设置请求操作Redis的超时时间。（5）close 语法: ok,err = redis:close(),关闭当前连接，成功返回1，失败返回nil和错误信息（6）redis命令对应的方法 在lua-resty-redis中，所有的Redis命令都有自己的方法，方法名字和命令名字相同，只是全部为小写。 步骤三：效果实现 123456789101112131415161718192021location / { default_type \"text/html\"; content_by_lua_block{ local redis = require \"resty.redis\" -- 引入Redis local redisObj = redis:new() --创建Redis对象 redisObj:set_timeout(1000) --设置超时数据为1s local ok,err = redisObj:connect(\"192.168.200.1\",6379) --设置redis连接信息 if not ok then --判断是否连接成功 ngx.say(\"failed to connection redis\",err) return end ok,err = redisObj:set(\"username\",\"TOM\")--存入数据 if not ok then --判断是否存入成功 ngx.say(\"failed to set username\",err) return end local res,err = redisObj:get(\"username\") --从redis中获取数据 ngx.say(res) --将数据写会消息体中 redisObj:close() }} 步骤四：运行测试效果 ¶6、ngx_lua操作Mysql MySQL是一个使用广泛的关系型数据库。在ngx_lua中，MySQL有两种访问模式, 分别是 使用ngx_lua模块和lua-resty-mysql模块：这两个模块是安装OpenResty时默认安装的。 使用drizzle_nginx_module(HttpDrizzleModule)模块：需要单独安装，这个库现不在OpenResty中。 ¶lua-resty-mysql lua-resty-mysql是OpenResty开发的模块，使用灵活、功能强大，适合复杂的业务场景，同时支持存储过程的访问。 ¶使用lua-resty-mysql实现数据库的查询 步骤一：准备MYSQL 1234host: 192.168.200.111port: 3306username:rootpassword:123456 创建一个数据库表及表中的数据。 12345678910111213141516create database nginx_db;use nginx_db;create table users( id int primary key auto_increment, username varchar(30), birthday date, salary double);insert into users(id,username,birthday,salary) values(null,\"TOM\",\"1988-11-11\",10000.0);insert into users(id,username,birthday,salary) values(null,\"JERRY\",\"1989-11-11\",20000.0);insert into users(id,username,birthday,salary) values(null,\"ROWS\",\"1990-11-11\",30000.0);insert into users(id,username,birthday,salary) values(null,\"LUCY\",\"1991-11-11\",40000.0);insert into users(id,username,birthday,salary) values(null,\"JACK\",\"1992-11-11\",50000.0); 步骤二：API学习 12345678910111213141516171819202122232425262728293031323334353637383940414243444546（1）引入\"resty.mysql\"模块 local mysql = require \"resty.mysql\"（2）new 创建一个MySQL连接对象，遇到错误时，db为nil，err为错误描述信息 语法: db,err = mysql:new()（3）connect 尝试连接到一个MySQL服务器 语法:ok,err=db:connect(options),options是一个参数的Lua表结构，里面包含数据库连接的相关信息 host:服务器主机名或IP地址 port:服务器监听端口，默认为3306 user:登录的用户名 password:登录密码 database:使用的数据库名（4）set_timeout 设置子请求的超时时间(ms)，包括connect方法 语法:db:set_timeout(time)（5）close 关闭当前MySQL连接并返回状态。如果成功，则返回1；如果出现任何错误，则将返回nil和错误描述。 语法:db:close()（6）send_query 异步向远程MySQL发送一个查询。如果成功则返回成功发送的字节数；如果错误，则返回nil和错误描述 语法:bytes,err=db:send_query(sql)（7）read_result 从MySQL服务器返回结果中读取一行数据。res返回一个描述OK包或结果集包的Lua表,语法: res, err, errcode, sqlstate = db:read_result() res, err, errcode, sqlstate = db:read_result(rows) :rows指定返回结果集的最大值，默认为4 如果是查询，则返回一个容纳多行的数组。每行是一个数据列的key-value对，如 { {id=1,username=\"TOM\",birthday=\"1988-11-11\",salary=10000.0}, {id=2,username=\"JERRY\",birthday=\"1989-11-11\",salary=20000.0} } 如果是增删改，则返回类上如下数据 { insert_id = 0, server_status=2, warning_count=1, affected_rows=2, message=nil } 返回值: res:操作的结果集 err:错误信息 errcode:MySQL的错误码，比如1064 sqlstate:返回由5个字符组成的标准SQL错误码，比如42000 步骤三：效果实现 12345678910111213141516171819location /{ content_by_lua_block{ local mysql = require \"resty.mysql\" local db = mysql:new() local ok,err = db:connect{ host=\"192.168.200.111\", port=3306, user=\"root\", password=\"123456\", database=\"nginx_db\" } db:set_timeout(1000) db:send_query(\"select * from users where id =1\") local res,err,errcode,sqlstate = db:read_result() ngx.say(res[1].id..\",\"..res[1].username..\",\"..res[1].birthday..\",\"..res[1].salary) db:close() }} ¶使用lua-cjson处理查询结果 通过上述的案例学习，read_result()得到的结果res都是table类型，要想在页面上展示，就必须知道table的具体数据结构才能进行遍历获取。处理起来比较麻烦，接下来我们介绍一种简单方式cjson，使用它就可以将table类型的数据转换成json字符串，把json字符串展示在页面上即可。具体如何使用? 步骤一：引入cjson 1local cjson = require \"cjson\" 步骤二：调用cjson的encode方法进行类型转换 1cjson.encode(res) 步骤三:使用 12345678910111213141516171819202122232425262728location /{ content_by_lua_block{ local mysql = require \"resty.mysql\" local cjson = require \"cjson\" local db = mysql:new() local ok,err = db:connect{ host=\"192.168.200.111\", port=3306, user=\"root\", password=\"123456\", database=\"nginx_db\" } db:set_timeout(1000) --db:send_query(\"select * from users where id = 2\") db:send_query(\"select * from users\") local res,err,errcode,sqlstate = db:read_result() ngx.say(cjson.encode(res)) for i,v in ipairs(res) do ngx.say(v.id..\",\"..v.username..\",\"..v.birthday..\",\"..v.salary) end db:close() }} ¶lua-resty-mysql实现数据库的增删改 优化send_query和read_result ！ 本方法是send_query和read_result组合的快捷方法。 语法： 1res, err, errcode, sqlstate = db:query(sql[,rows]) 有了该API，上面的代码我们就可以进行对应的优化，如下： 12345678910111213141516171819202122232425location /{ content_by_lua_block{ local mysql = require \"resty.mysql\" local db = mysql:new() local ok,err = db:connect{ host=\"192.168.200.1\", port=3306, user=\"root\", password=\"123456\", database=\"nginx_db\", max_packet_size=1024, compact_arrays=false } db:set_timeout(1000) local res,err,errcode,sqlstate = db:query(\"select * from users\") --local res,err,errcode,sqlstate = db:query(\"insert into users(id,username,birthday,salary) values(null,'zhangsan','2020-11-11',32222.0)\") --local res,err,errcode,sqlstate = db:query(\"update users set username='lisi' where id = 6\") --local res,err,errcode,sqlstate = db:query(\"delete from users where id = 6\") db:close() }} ¶综合小案例 使用ngx_lua模块完成Redis缓存预热。 分析: 1、先得有一张表(users) 2、浏览器输入如下地址 1http://191.168.200.133?username=TOM 3、从表中查询出符合条件的记录，此时获取的结果为table类型 4、使用cjson将table数据转换成json字符串 5、将查询的结果数据存入Redis中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657init_by_lua_block{ redis = require \"resty.redis\" mysql = require \"resty.mysql\" cjson = require \"cjson\"}location /{ default_type \"text/html\"; content_by_lua_block{ --获取请求的参数username local param = ngx.req.get_uri_args()[\"username\"] --建立mysql数据库的连接 local db = mysql:new() local ok,err = db:connect{ host=\"192.168.200.111\", port=3306, user=\"root\", password=\"123456\", database=\"nginx_db\" } if not ok then ngx.say(\"failed connect to mysql:\",err) return end --设置连接超时时间 db:set_timeout(1000) --查询数据 local sql = \"\"; if not param then sql=\"select * from users\" else sql=\"select * from users where username=\"..\"'\"..param..\"'\" end local res,err,errcode,sqlstate=db:query(sql) if not res then ngx.say(\"failed to query from mysql:\",err) return end --连接redis local rd = redis:new() ok,err = rd:connect(\"192.168.200.111\",6379) if not ok then ngx.say(\"failed to connect to redis:\",err) return end rd:set_timeout(1000) --循环遍历数据 for i,v in ipairs(res) do rd:set(\"user_\"..v.username,cjson.encode(v)) end ngx.say(\"success\") rd:close() db:close() } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"中间件","slug":"中间件","permalink":"https://www.itnxd.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.itnxd.cn/tags/Nginx/"},{"name":"Lua","slug":"Lua","permalink":"https://www.itnxd.cn/tags/Lua/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://www.itnxd.cn/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"反向代理","slug":"反向代理","permalink":"https://www.itnxd.cn/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"}],"author":"ITNXD"},{"title":"MySQL数据库索引、索引失效、B树、B+树、聚簇索引、非聚簇索引","slug":"MySQL数据库索引、索引失效、B树、B-树","date":"2021-09-13T08:28:30.000Z","updated":"2021-09-13T13:57:37.370Z","comments":true,"path":"posts/6406.html","link":"","permalink":"https://www.itnxd.cn/posts/6406.html","excerpt":"","text":"¶一、索引数据结构介绍 tips：旧金山大学官网有可视化数据结构供我们使用！ 都以插入1-10这10个数字为例！ ¶1、哈希索引 可视化哈希索引，https://www.cs.usfca.edu/~galles/visualization/ClosedHash.html 可以发现查找可以直接找到，因为是计算了哈希值，可以直接找到！效率非常高！ 但是，为什么MySQL没有使用这种数据结构了？ 哈希值是无序的，不能进行范围查找 不能进行排序 哈希冲突，比对，可能发生全表扫描 ¶2、平衡二叉树 可视化平衡二叉树，https://www.cs.usfca.edu/~galles/visualization/AVLtree.html 查找10的过程： 也仅仅比了四次！ 缺点： 随着数据量的增大，树的高度也会增加，查找速度会越来越慢 还有一个致命缺点，若查找大于5的范围，他将会先找到5再进行回旋查找大于5的数，若大于5的数非常多，将会导致非常的慢 ¶3、B树 可视化B树，https://www.cs.usfca.edu/~galles/visualization/BTree.html 优点：由于一个节点存储的大于一个值，因此树高会变矮，变矮就表示查询次数会少很多！ 缺点： 同样存在回旋查找的问题，查找大于5仍然会进行回旋查找浪费时间！ ¶4、B+树 可视化B+树，https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html 与B树不同，他的非叶子节点只存储key，不存储value。叶子节点存储key和value！ 这里的value指的是内存地址！ 注意：这里的1和10兼具叶子节点和非叶子节点特点，成为了二者共用， 且叶子节点都以链表形式相连！且有序！ 优点：解决了上面的回旋查找的问题！ ¶二、索引失效分析 联合索引B+树结构！ ¶1、联合索引 从上图来看，会发现该数据结构的特点： 联合索引是按照顺序一个个排序的，即a有序，在a有序的情况下b有序 ¶2、索引失效分析 最佳左前缀原因：因为它是索引顺序一个个排序的，若前面某个索引列没有使用到，那么对于B+数的叶子节点来说，叶子节点就完全是无序的，因此索引就完全失效了，只能进行全表扫描！ 范围之后全失效：例如找a&gt;1的数据，会发现a&gt;1的数据中b是无序的，因此索引失效，只能进行全表扫描。因为只有a相同的情况下b才是有序的！否则无序！ like的%号左边、两边索引失效：和最佳左前缀法则一样，也是从左到右进行排序的，放左边和两边会导致之前的无法先排序之前的，导致后面的数据全部无序，只能进行全表扫描！ 注意：这里的无序不仅仅指B+树的叶子节点无序，非叶子节点同样是无序的！ ¶三、MyIsam和InnoDB常见区别 ¶事务方面 InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一。 ¶外键方面 InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败。 ¶索引层面 InnoDB 是聚集（聚簇）索引，MyISAM 是非聚集（非聚簇）索引。 MyISAM支持 FULLTEXT类型的全文索引， InnoDB不支持FULLTEXT类型的全文索引，但是InnoDB可以使用sphinx插件支持全文索引，并且效果更好。 ¶锁粒度方面 InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。 一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。 这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一。 ¶硬盘存储结构 MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。 .frm文件存储表的定义。 数据文件的扩 展名为.MYD (MYData)。 索引文件的扩 展名是.MYI (MYIndex)。 Innodb存储引擎存储数据库数据，一共有两个文件(没有专门保存数据的文件)： Frm文件：表的定义文件。 Ibd文件：数据和索引存储文件。数据以主键进行聚集存储，把真正的数据保存在叶子节点中。 ¶四、聚簇索引和非聚簇索引 ¶聚簇索引（InnoDB） 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据。 表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。 InnoDB中，在聚簇索引之上创建的索引称之为辅助索引，像复合索引、前缀索引、唯一索引等等。 聚簇索引默认是主键 如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。 如果没有这样的索引，InnoDB 会在内部生成一个名为 GEN_CLUST_INDEX 的隐式的聚簇索引。 ¶非聚簇索引（MyISAM） 将数据与索引分开存储，表数据存储顺序与索引顺序无关。 ¶图解两大索引 非聚簇索引存储结构： MyISAM的 B+树 的叶子节点上，记录的是真实数据的存储地址。 比如通过主键id查询，MyISAM查询流程如下： 根据id值在B+树上找到相应的叶子节点 取出叶子节点上的数据存储地址 根据数据存储地址，去找到相应的真实数据 聚簇索引存储结构： InnoDB的 B+树 的叶子节点上，记录的是真实行数据。 比如通过主键id查询，InnoDB查询流程如下： 聚簇索引（主键索引）： 根据id值在B+树上找到相应的叶子节点 取出叶子节点上的行数据，返回即可 辅助索引（聚簇索引以外的）： 在相应索引的B+树上找到相应的叶子节点 取出叶子节点上的数据，该数据是主键id 拿到主键id后，去主键索引的B+树上找到相应的叶子节点 取出叶子节点上的行数据，返回 ¶思考？ 为什么少用select *，为什么尽量使用覆盖索引？ 对innodb的聚簇索引来说，如果查的是id，where条件是索引，那么可以查找一次B+树即可找到（辅助索引树）！ 如果查找的是age字段，这个不是索引，那么我们得通过辅助索引树和主索引树才能找到！ 这就是为什么尽量走覆盖索引和少用select *的原因所在！ 当然真实场景不可能都走覆盖索引！ ¶总结 通过主键id查询的时候，InnoDB比MyIsam快一些，因为InnoDB只需要一次B+树查找就能取出数据。MyIsam通过B+树查找到地址后，还需要根据地址去查询真正的数据。 但是InnoDB普通索引查询会比MyIsam慢些，因为InnoDB要进行2次B+树的查找。 在数据重构的时候，MyIsam记录的是数据地址，那么重构数据的时候地址就要重新生成一遍，这也是有问题的。 InnoDB重构数据的时候就不会这样，因为他记录的是主键id，地址会变化，主键id是不会变的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"索引","slug":"数据库/索引","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/"}],"tags":[{"name":"B树","slug":"B树","permalink":"https://www.itnxd.cn/tags/B%E6%A0%91/"},{"name":"B+树","slug":"B-树","permalink":"https://www.itnxd.cn/tags/B-%E6%A0%91/"},{"name":"索引","slug":"索引","permalink":"https://www.itnxd.cn/tags/%E7%B4%A2%E5%BC%95/"}],"author":"ITNXD"},{"title":"MySQL数据库高级-MySQL数据库优化","slug":"MySQL数据库高级-MySQL数据库优化","date":"2021-09-07T00:26:52.000Z","updated":"2021-09-13T09:25:42.948Z","comments":true,"path":"posts/37817.html","link":"","permalink":"https://www.itnxd.cn/posts/37817.html","excerpt":"","text":"基于centos7及mysql-5.7.35，5.7.35为目前最新5.x版本！ ¶一、Linux安装MySQL及相关配置 ¶1、安装 安装步骤参考我之前的博客，Linux安装MySQL5.7！ 关于Linux下的三种安装包介绍： rpm package：是某个特定的包，比如server,client,shared lib等。（可以单独安装 ） rpm bundle：是该版本所有包的集合。（一般是把服务器端要用的都安装上，其他的不带，尤其是开发包 ） Compressed TAR Archive：是源码，必须用源码方式安装。（这个是源码，需要自己编译的，也有编译好，但不是安装包的） 下载地址： 1wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.35-1.el7.x86_64.rpm-bundle.tar 查看MySQL用户和组信息： /etc/passwd 文件：记录用户的各种信息。每行含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell /etc/group 文件：组(group)的配置文件，记录 Linux 包含的组的信息。每行含义：组名:口令:组标识号:组内用户列表 ¶2、配置文件修改 5.7版本MySQL配置文件默认位置为/etc/my.cnf！ 注意：已经创建的数据库的设定不会发生变化，参数修改只对新建的数据库有效。 修改已创建库、表字符集： 123456mysql&gt; alter database mydb character set 'utf8';mysql&gt; alter table mytbl convert to character set 'utf8';# 查看数据库的字符集mysql&gt; show create database 库名# 创建数据库，顺便执行字符集为utf-8create database 库名 character set utf8 修改已经乱码数据： 无论是修改 mysql 配置文件或是修改库、表字符集，都无法改变已经变成乱码的数据。 只能删除数据重新插入或更新数据才可以完全解决 设置默认编码为utf8：修改配置文件字符集使得永久生效 修改配置文件后需要重启MySQL，systemctl restart mysqld.service vim /etc/my.cnf 12345678910111213141516171819202122232425262728293031[mysqld]## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid# 新增如下内容character-set-server=utf8[client]default-character-set=utf8[mysql]default-character-set=utf8 使用show variables like ‘%char%‘查看编码格式： ¶3、默认配置文件路径 配置文件：/etc/my.cnf 日志文件：/var/log/mysqld.log 服务启动脚本：/usr/lib/systemd/system/mysqld.service socket文件：/var/run/mysqld/mysqld.pid 库文件：/var/lib/mysql ¶二、Mysql 逻辑架构简介 ¶1、整体架构图 和其它数据库相比，MySQL 有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，**插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。**这种架构可以根据业务的需求和实际需要选择合适的存储引擎。 ¶1.1、连接层 最上层是一些客户端和连接服务，包含本地 sock 通信和大多数基于客户端/服务端工具实现的类似于 tcp/ip 的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于 SSL 的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 ¶1.2、服务层 服务层组件 功能 Management Serveices &amp; Utilities 系统管理和控制工具 SQL Interface SQL 接口。接受用户的 SQL 命令，并且返回用户需要查询的结果。比如 select from 就是调用 SQL Interface Parser 解析器。 SQL 命令传递到解析器的时候会被解析器验证和解析。 Optimizer 查询优化器。 SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有where 条件时，优化器来决定先投影还是先过滤。 Cache 和 Buffer 查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存，权限缓存等 ¶1.3、引擎层 存储引擎层，存储引擎真正的负责了 MySQL 中数据的存储和提取，服务器通过 API 与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。 ¶1.4、存储层 数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互！ ¶2、两大常用引擎 即MyISAM 和 InnoDB！ ¶2.1、查看MySQL使用引擎 1234# 查看所有的数据库引擎show engines# 查看默认的数据库引擎show variables like '%storage_engine%' ¶2.2、二者对比 对比项 MyISAM InnoDB 事务 不支持 支持 外键 不支持 支持 行表锁 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作 缓存 只缓存索引，不缓存真实数据 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 关注点 读性能 并发写、事务、资源 表空间 小 大 默认安装 Y Y 默认使用 N Y 自带系统表使用 Y N ¶2.3、拓展了解 Percona为MySQL数据库服务器进行了改进，在功能和性能上较MySQL有着很显著的提升。该版本提升了在高负载情况下的InnoDB的性能、为DBA提供一些非常有用的性能诊断工具;另外有更多的参数和命令来控制服务器行为。 该公司新建了一款存储引擎叫xtradb完全可以替代innodb,并且在性能和并发上做得更好， 阿里巴巴大部分mysql数据库其实使用的percona的原型加以修改。AliSql+AliRedis ¶三、索引优化分析 ¶1、SQL性能下降的原因 查询语句写的烂（各种子查询，没建索引） 索引失效（单值，多值索引） 关联太多的Join（设计缺陷或不得已需求） 服务器调优及各个参数设置（缓冲，线程数） ¶2、SQL执行加载顺序 人写： 机读： MySQL执行顺序鱼刺图： ¶3、七种Join 注意：MySQL不支持全外连接，需要使用union进行合并去重得到，最后两种情况如下图： ¶4、什么是索引 Index在数组中叫下标，在Git中叫暂存区，在数据库中叫索引！ MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。 可以得到索引的本质：索引是数据结构。可以简单理解为排好序的快速查找数据结构。 排序：order by 查找：where条件 索引的目的：在于提高查找效率，可以类比字典！ 为了加快查找，可以维护一个图中右边所示的二叉查找树，类似指针指向真实的物理地址！ 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上 我们平常所说的索引，如果没有特别指明，都是指B树(多叉搜索树，并不一定是二叉的)结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树公引，统称索引。当然，除了B+树这种类型的索引之外，还有哈希索引等。 关于无效数据的删除： 并不会真的删除，底层只是做了update操作，只会将该数据的一个标志为置为非激活状态即可！ 留下来的该数据对于其他部门等数据分析还会有用 需要重建索引，以防查询到的数据因为索引没有及时更新造成数据不准确发生 ¶5、索引优缺点 优点： 提高数据检索的效率，降低数据库的IO成本。 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。 缺点： 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询。 ¶6、MySQL索引分类 ¶6.0、基本语法 123456789101112131415161718# 使用Create单独创建索引CREATE [UNIQUE] INDEX 索引名 ON 表名(列名[(长度)]);# 使用Alter单独创建索引ALTER 表名 ADD [UNIQUE] INDEX 索引名 ON 表名(列名[(长度)]);# 删除索引DROP INDEX 索引名 ON 表名;# 查看某表全部索引SHOW INDEX FROM 表名;# ALTER添加主键(主键也是一种索引，意味着该索引值必须唯一，且不能为null)ALTER 表名 ADD PRIMARY KEY(列名);# ALTER添加唯一索引(该索引值必须唯一，允许有NULL)ALTER 表名 ADD UNIQUE 索引名(列名);# ALTER添加普通单值索引(该索引值不一定唯一)ALTER 表名 ADD 索引名(列名);# ALTER添加全文索引(用于全文索引)ALTER 表名 ADD FULLTEXT 索引名(列名); ¶6.1、主键索引 是什么？ 设定为主键后数据库会自动建立索引，innodb为聚簇索引！ 例子？ 123456789101112# 和表一起创建：CREATE TABLE customer ( id INT(10) UNSIGNED AUTO_INCREMENT, customer_no VARCHAR(200), customer_name VARCHAR(200), PRIMARY KEY(id), # 主键索引);# 单独建：ALTER TABLE customer ADD PRIMARY KEY customer(customer_no);# 删除建主键索引：ALTER TABLE customer drop PRIMARY KEY ;# 修改建主键索引：必须先删除掉(drop)原索引，再新建(add)索引 ¶6.2、单值索引 是什么？ 即一个索引只包含单个列，一个表可以有多个单列索引！ 建议：一张表建的索引最多不要超过五个！ 例子？ 123456789# 和表一起创建：CREATE TABLE customer ( id INT(10) UNSIGNED AUTO_INCREMENT, customer_no VARCHAR(200), customer_name VARCHAR(200), KEY (customer_name) # 单值索引);# 单独建：CREATE INDEX idx_customer_name ON customer(customer_name); 查看表的索引： show index from table; ¶6.3、复合索引 是什么？ 即一个索引包含多个列！ 语法？ 123456789# 和表一起创建：CREATE TABLE customer ( id INT(10) UNSIGNED AUTO_INCREMENT, customer_no VARCHAR(200), customer_name VARCHAR(200), KEY (customer_no,customer_name) # 符合索引);# 单独建：CREATE INDEX idx_no_name ON customer(customer_no,customer_name); ¶6.4、唯一索引 是什么？ 索引列的值必须唯一，但允许有空值！ 例子？ 123456789# 和表一起创建：CREATE TABLE customer ( id INT(10) UNSIGNED AUTO_INCREMENT, customer_no VARCHAR(200), customer_name VARCHAR(200), UNIQUE (customer_no) # 唯一索引);# 单独建：CREATE UNIQUE INDEX idx_customer_name ON customer(customer_no); ¶7、MySQL索引结构 MySQL 使用的是 Btree 索引！ ¶7.1、Btree结构 结构如下图所示： 一颗 b 树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示）： 如磁盘块 1 包含数据项 17 和 35，包含指针 P1、P2、P3，P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。 真实的数据存在于叶子节点。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如 17、35 并不真实存在于数据表中。 ¶7.2、B+Tree结构 结构如下图所示： B+树和B树（B-树）区别： B树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。 在 B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而 B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。 从这个角度看 B- 树的性能好像要比 B+树好，而在实际应用中却是 B+树的性能要好些。因为 B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比 B-树多，树高比 B-树小，这样带来的好处是减少磁盘访问次数。尽管 B+树找到一个记录所需的比较次数要比 B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中B+树的性能可能还会好些，而且 B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用 B+树的缘故。 为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？ B+树的磁盘读写代价更低：B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。 B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 ¶7.3、聚簇索引和非聚簇索引 聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。术语‘聚簇’表示数据行和相邻的键值聚簇的存储在一起。如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。 聚簇索引的好处： 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不不用从多个数据块中提取数据，所以节省了大量的 io 操作。 聚簇索引的限制： 对于 mysql 数据库目前只有 innodb 数据引擎支持聚簇索引，而 Myisam 并不支持聚簇索引。由于数据物理存储排序方式只能有一种，所以每个 Mysql 的表只能有一个聚簇索引。一般情况下就是该表的主键。为了充分利用聚簇索引的聚簇的特性，所以 innodb 表的主键列尽量选用有序的顺序 id，而不建议用无序的 id，比如 uuid 这种。 ¶8、适合建索引的情况 主键自动建立唯一索引 频繁作为查询条件的字段应该创建索引 查询中与其它表关联的字段外键关系建立索引 单键/组合索引的选择问题，组合索引性价比更高（高并发更合适） 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度 查询中统计或者分组字段（分组前提必排序） ¶9、不适合建索引的情况 表记录太少（300w条记录数据库性能将会下降） 经常增删改的表或者字段 Where 条件里用不到的字段不创建索引 过滤性不好的不适合建索引 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。 ¶四、Explain性能分析 ¶1、MySQ常见瓶颈 CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候 IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候 服务器硬件的性能瓶颈：top, free, iostat和vmstat来查看系统的性能状态 ¶2、概述 使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈。 表的读取顺序 数据读取操作的操作类型哪些索引可以使用 哪些索引被实际使用 表之间的引用 每张表有多少行被优化器查询 用法： Explain+SQL 语句。 Explain 执行后返回的信息： ¶3、id select 查询的序列号,包含一组数字，表示查询中执行 select 子句或操作表的顺序。 id 相同，执行顺序由上至下 id 不同，id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行 有相同也有不同：id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行 衍生 = DERIVED derived2中的2是id=2的那个2，表示s3是由t3衍生出来的表，因此执行顺序为t3、s3、t2。 关注点：id 号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好。 ¶4、select_type select_type 代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。 关于subquery和dependent subquery区别： 都是 where 后面的条件，subquery 是单个值，dependent subquery 是一组值。 UNCACHEABLE SUBQUREY： 当使用了@@来引用系统变量的时候，不会使用缓存。 ¶5、table 表示这个数据是基于哪张表的。 ¶6、type type 是查询的访问类型。是较为重要的一个指标。 结果值从最好到最坏依次是： system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 一般来说，得保证查询至少达到 range 级别，最好能达到 ref。 system： 表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也可以忽略不计。 const： 表示通过索引一次就找到了,const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。 简单理解：单表（只索引一次），找到一条记录。 eq_ref： 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。 简单理解：多表（只索引一次），前一个表的唯一索引只能在后表中唯一匹配一条记录。 ref： 非唯一性索引扫描，返回匹配某个单独值的所有行.本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。 简单理解：非唯一索引，一条可能匹配多条记录。 range： 只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的 where 语句中出现了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。 index： 出现index是sql使用了索引但是没通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组。 Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而ALL是从硬盘中读的)。 all： Full Table Scan，将遍历全表以找到匹配的行。 **简单理解：**不建索引，不使用索引就是ALL。 ¶7、possible_keys 显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。（为MySQL估计值） ¶8、key 实际使用的索引。如果为NULL，则没有使用索引。（真实值） 查询中若使用了覆盖索引，则该索引仅出现在key列表中： 即符合索引用到的列和查询查的列完美匹配时，将不会进行全盘扫描，直接扫描符合索引即可！ ¶9、key_len 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 key_len 字段能够帮你检查是否充分的利用上了索引。ken_len 越长，说明索引使用的越充分。 key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。 如何计算？ 先看索引上字段的类型+长度比如 int=4 ; varchar(20) =20 ; char(20) =20 如果是 varchar 或者 char 这种字符串字段，视字符集要乘不同的值，比如 utf-8 要乘 3,GBK 要乘 2， varchar 这种动态字符串要加 2 个字节 允许为空的字段要加 1 个字节 第一组：key_len=age 的字节长度+name 的字节长度=4+1 + ( 20*3+2)=5+62=67 第二组：key_len=age 的字节长度=4+1=5 ¶10、ref 显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。 如果是使用的常数等值查询，这里会显示const。如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func。 下图解释：由key_len可知t1表的idx_col1_col2被充分使用，col1匹配t2表的col1，col2匹配了一个常量，即 ‘ac’ 其实就是where右边对应的条件，只是限定了左边必须是有索引的列！ ¶11、rows rows 列显示 MySQL 认为它执行查询时必须检查的行数。越少越好！ ¶12、extra 包含不适合在其他列中显示但十分重要的额外信息！ 前三个比较重要，其他了解即可！ Using filesort： 九死一生，需要尽快解决！ 说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”。 简单来说：MySQL内部认为该语句使用索引排序不如直接内部进行文件排序要好！ 原因：如下图，上面情况用到了col1和col3没有用到col2，出现断层，内部将会使用文件排序，多了一层，性能会下降，下面的全部用到了，性能会更好！ 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度！ Using temporary： 也需要尽快解决！ 使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。 自建了表索引index_a_b_c测试排序时使用到a，a b, a b c, 三种情况不会出现 filesort，所以建的组合索引index_a_b_c相当于建了三个索引a; a b; a b c。 Using index： 提高效率！ Using index 代表表示相应的 select 操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！ 如果同时出现 using where，表明索引被用来执行索引键值的查找; 如果没有同时出现 using where，表明索引只是用来读取数据而非利用索引执行查找。 利用索引进行了排序或分组。 覆盖索引补充： 就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件,换句话说查询列要被所建的索引覆盖。 注意： 如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select * 因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。 Using join buffer： 使用了连接缓存。表明配中的buffer需要调大一点！ impossible where： where 子句的值总是 false，不能用来获取任何元组。 **select tables optimized away：**了解 在没有 GROUPBY 子句的情况下，基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。 在 innodb 中不会显示，在 Myisam 中会显示！ distinct： 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作！ ¶13、一个例子 执行顺序分析如下： ¶五、索引优化 ¶1、索引分析 ¶1.1、单表 建表SQL： 1234567891011121314151617CREATE TABLE IF NOT EXISTS `article`(`id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,`author_id` INT (10) UNSIGNED NOT NULL,`category_id` INT(10) UNSIGNED NOT NULL , `views` INT(10) UNSIGNED NOT NULL , `comments` INT(10) UNSIGNED NOT NULL,`title` VARBINARY(255) NOT NULL,`content` TEXT NOT NULL);INSERT INTO `article`(`author_id`,`category_id` ,`views` ,`comments` ,`title` ,`content` )VALUES(1,1,1,1,'1','1'),(2,2,2,2,'2','2'),(3,3,3,3,'3','3'); SELECT * FROM ARTICLE;EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1; 案例： 查询category_id为1且comments大于1的情况下, views最多的 article_id。 简单实现： 12345678mysql&gt; EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1;+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+| 1 | SIMPLE | article | NULL | ALL | NULL | NULL | NULL | NULL | 3 | 33.33 | Using where; Using filesort |+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------------------+1 row in set, 1 warning (0.00 sec) 结论：很显然,type是ALL,即最坏的情况。Extra里还出现了Using filesort,也是最坏的情况。优化是必须的。 开始优化： 12345678910111213141516mysql&gt; show index from article\\G*************************** 1. row *************************** Table: article Non_unique: 0 Key_name: PRIMARY Seq_in_index: 1 Column_name: id Collation: A Cardinality: 3 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment: Index_comment: 1 row in set (0.00 sec) 优化：建立索引、删除索引 1234567891011121314151617181920212223create index idx_article_ccv on article(category_id,comments,views);# 索引结构mysql&gt; show index from article;+---------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+---------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| article | 0 | PRIMARY | 1 | id | A | 3 | NULL | NULL | | BTREE | | || article | 1 | idx_article_ccv | 1 | category_id | A | 3 | NULL | NULL | | BTREE | | || article | 1 | idx_article_ccv | 2 | comments | A | 3 | NULL | NULL | | BTREE | | || article | 1 | idx_article_ccv | 3 | views | A | 3 | NULL | NULL | | BTREE | | |+---------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+4 rows in set (0.00 sec)# 性能分析mysql&gt; EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1;+----+-------------+---------+------------+-------+-----------------+-----------------+---------+------+------+----------+---------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+---------+------------+-------+-----------------+-----------------+---------+------+------+----------+---------------------------------------+| 1 | SIMPLE | article | NULL | range | idx_article_ccv | idx_article_ccv | 8 | NULL | 1 | 100.00 | Using index condition; Using filesort |+----+-------------+---------+------------+-------+-----------------+-----------------+---------+------+------+----------+---------------------------------------+1 row in set, 1 warning (0.00 sec) 结果：type变为了range，且使用上了index，但extra里仍然有filesort ？ 索引为三者复合索引ccv，但是在范围 comments &gt; 1后就有范围了，导致后面的索引用不上，发生了断层，结果导致内部进行了文件排序！ type变成了range，这是可以忍受的。但是extra里使用Using filesort仍是无法接受的。但是我们已经建立了索引，为啥没用呢? 这是因为按照BTree 索引的工作原理，先排序category_id, 如果遇到相同的category_id则再排序comments, 如果遇到相同的comments 则再排序views。 当comments字段在联合索引里处于中间位置时，因comments &gt;1条件是一个范围值(所谓range), MySQL无法利用索引再对后面的views部分进行检索,即range类型查询字段后面的索引无效。 说明索引建的不合适，删掉重建！ 既然范围range类型查询字段后面索引失效，那我们可以直接跳过范围字段！ 1234567891011121314151617mysql&gt; drop index idx_article_ccv on article;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0# 重建索引mysql&gt; create index idx_article_cv on article(category_id,views);Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1;+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+| 1 | SIMPLE | article | NULL | ref | idx_article_cv | idx_article_cv | 4 | const | 1 | 33.33 | Using where |+----+-------------+---------+------------+------+----------------+----------------+---------+-------+------+----------+-------------+1 row in set, 1 warning (0.00 sec) 结果：可以看到, type变为了ref, Extra中的Using filesort也消失了, 结果非常理想。 ¶1.2、两表 建表SQL： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849CREATE TABLE IF NOT EXISTS `class`(`id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,`card` INT (10) UNSIGNED NOT NULL);CREATE TABLE IF NOT EXISTS `book`(`bookid` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,`card` INT (10) UNSIGNED NOT NULL);INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20))); INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20))); 性能分析： 123456789mysql&gt; EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+| 1 | SIMPLE | class | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | NULL || 1 | SIMPLE | book | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | Using where; Using join buffer (Block Nested Loop) |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+2 rows in set, 1 warning (0.00 sec) 结果：type 为 all 优化：添加索引 左连接将索引添加到右表上，type会扫一个ALL！ 123456789101112mysql&gt; create index idx_card on book(card);Query OK, 0 rows affected (0.10 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;+----+-------------+-------+------------+------+---------------+----------+---------+-----------------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+----------+---------+-----------------+------+----------+-------------+| 1 | SIMPLE | class | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | NULL || 1 | SIMPLE | book | NULL | ref | idx_card | idx_card | 4 | db02.class.card | 1 | 100.00 | Using index |+----+-------------+-------+------------+------+---------------+----------+---------+-----------------+------+----------+-------------+2 rows in set, 1 warning (0.01 sec) 左连接将索引添加到右表上，type会扫一个ALL！ 12345678910111213141516mysql&gt; drop index idx_card on book;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; create index idx_card on class(card);Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; EXPLAIN SELECT * FROM class LEFT JOIN book ON class.card = book.card;+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+----------------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+----------------------------------------------------+| 1 | SIMPLE | class | NULL | index | NULL | idx_card | 4 | NULL | 20 | 100.00 | Using index || 1 | SIMPLE | book | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | Using where; Using join buffer (Block Nested Loop) |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+----------------------------------------------------+2 rows in set, 1 warning (0.00 sec) 结论： 可以看到第二行的type变为了index, rows也变成了原来的20。 这是由左连接特性决定的。 LEFT JOIN 条件用于确定如何从右表搜索行, 左边一定都有，所以右边是我们的关键点,一定需要建立索引。 RIGHT JOIN 条件用于确定如何从左表搜索行, 右边一定都有, 所以左边是我们的关键点,一定需要建立索引。 ¶1.3、三表 建表SQL： 12345678910111213141516171819202122232425CREATE TABLE IF NOT EXISTS `phone`(`phoneid` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,`card` INT (10) UNSIGNED NOT NULL)ENGINE = INNODB;INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20))); 性能分析： 123456789mysql&gt; explain SELECT * FROM class LEFT JOIN book ON class.card=book.card inner JOIN phone ON book.card = phone.card;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+| 1 | SIMPLE | class | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | NULL || 1 | SIMPLE | book | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 10.00 | Using where; Using join buffer (Block Nested Loop) || 1 | SIMPLE | phone | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 10.00 | Using where; Using join buffer (Block Nested Loop) |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+3 rows in set, 1 warning (0.00 sec) 结果：type都为ALL，全表扫描 优化：添加索引 1234567891011121314151617mysql&gt; create index idx_book on book(card);Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; create index idx_phone on phone(card);Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; explain SELECT * FROM class LEFT JOIN book ON class.card=book.card inner JOIN phone ON book.card = phone.card;+----+-------------+-------+------------+------+---------------+-----------+---------+-----------------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+-----------+---------+-----------------+------+----------+-------------+| 1 | SIMPLE | class | NULL | ALL | NULL | NULL | NULL | NULL | 20 | 100.00 | Using where || 1 | SIMPLE | book | NULL | ref | idx_book | idx_book | 4 | db02.class.card | 1 | 100.00 | Using index || 1 | SIMPLE | phone | NULL | ref | idx_phone | idx_phone | 4 | db02.class.card | 1 | 100.00 | Using index |+----+-------------+-------+------------+------+---------------+-----------+---------+-----------------+------+----------+-------------+3 rows in set, 1 warning (0.00 sec) 结论： 后⒉行的 type 都是ref且总rows优化很好,效果不错。因此索引最好设置在需要经常查询的字段中。 ¶1.4、JOIN优化总结 尽可能减少Join语句中的NestedLoop（嵌套）的循环总次数;“永远用小结果集驱动大的结果集”。（小表驱动大表） 优先优化NestedLoop的内层循环 保证Join语句中被驱动表上Join条件字段已经被索引 当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝惜JoinBuffer的设置 ¶2、索引失效避免 建表SQL： 12345678910111213141516# 建表CREATE TABLE staffs(id INT PRIMARY KEY AUTO_INCREMENT,`name` VARCHAR(24)NOT NULL DEFAULT'' COMMENT'姓名',`age` INT NOT NULL DEFAULT 0 COMMENT'年龄',`pos` VARCHAR(20) NOT NULL DEFAULT'' COMMENT'职位',`add_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT'入职时间')CHARSET utf8 COMMENT'员工记录表';# 插入值insert into staffs(NAME,age,pos,add_time) values('z3',22,'manager',NOW());insert into staffs(NAME,age,pos,add_time) values('July',23,'dev',NOW());insert into staffs(NAME,age,pos,add_time) values('2000',23,'dev',NOW());# 建索引create index idx_staffs_nameAgePos on staffs(name,age,pos); ¶2.1、全值匹配我最爱 性能分析： 123EXPLAIN SELECT * FROM staffs WHERE NAME = 'July';EXPLAIN SELECT * FROM staffs WHERE NAME = 'July' AND age = 25;EXPLAIN SELECT * FROM staffs WHERE NAME = 'July' AND age = 25 AND pos = 'dev'; type都是ref，ref都是const，精度逐渐增加！ 性能分析： 12explain SELECT * FROM staffs WHERE age = 23 AND pos = 'dev';explain SELECT * FROM staffs WHERE pos = 'dev'; type都变为了ALL！ 结论：符合索引顺序和用到的个数顺序一致，为最优，全值匹配我最爱！ ¶2.2、最佳左前缀法则 如果索引了多例，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。 带头大哥不能死！ 性能分析： 1explain SELECT * FROM staffs WHERE NAME = 'July' AND pos = 'dev'; 很明显，使用到了索引，但是ref只有一个const，即中间出现了断层，索引部分失效！ 带头大哥不能死！中间兄弟不能断！ ¶2.3、索引列上少计算 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描！ 性能分析： 1234explain SELECT * FROM staffs WHERE NAME = 'July';# 函数引入explain SELECT * FROM staffs WHERE left(name,4); 索引列增加函数后，type变为了ALL，性能下降！ ¶2.4、范围之后全失效 存储引擎不能使用索引中范围条件右边的列！ 性能分析： 1explain SELECT * FROM staffs WHERE name = 'July' AND age &gt; 25 AND pos = 'dev'; type变为了range，右边的pos将会失效！ ¶2.5、覆盖索引不写星 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select*操作！ 性能分析： 12345explain SELECT * FROM staffs WHERE name = 'July' AND age = 25 AND pos = 'dev';explain SELECT name,age,pos FROM staffs WHERE name = 'July' AND age = 25 AND pos = 'dev';explain SELECT name,age,pos FROM staffs WHERE name = 'July' AND age &gt; 25 AND pos = 'dev';explain SELECT name FROM staffs WHERE name = 'July' AND age = 25; 很明显多了一个using index，即使用了覆盖索引，比*更好！ ¶2.6、不等空值还有or mysql在使用不等于（!=或者&lt;&gt;）的时候无法使用索引会导致全表扫描 is null,is not null 也无法使用索引 少用or,用它连接时会索引失效 性能优化： 1234explain SELECT * FROM staffs WHERE name != 'July' ;explain SELECT * FROM staffs WHERE name is null;explain SELECT * FROM staffs WHERE name is not null;explain SELECT * FROM staffs WHERE name = 'July' or name = 'z3'; ¶2.7、Like百分写最右 like以通配符开头（‘$abc…’）mysql索引失效会变成全表扫描操作！ 性能优化： 123explain SELECT * FROM staffs WHERE name like '%July%';explain SELECT * FROM staffs WHERE name like '%July';explain SELECT * FROM staffs WHERE name like 'July%'; like百分号加右边type会变为range，且使用上索引！ 问题：解决like’%字符串%'索引不被使用的方法？？ 可以使用主键索引 使用覆盖索引，查询字段必须是建立覆盖索引字段 当覆盖索引指向的字段是varchar(380)及380以上的字段时，覆盖索引会失效！ ¶2.8、VAR引号不可丢 字符串不加单引号索引失效！ 性能分析： 12explain SELECT * FROM staffs WHERE name = '2000';explain SELECT * FROM staffs WHERE name = 2000; 发生了隐式类型转换，会导致索引失效！ ¶3、一些案例 索引为c1，c2，c3，c4四个字段的复合索引！ 对于全部是常量索引（const），顺序无影响，因为逻辑架构中MySQL底层优化器会进行优化顺序！但建议还是按照查询顺序去写，让优化器少做一些操作！ 对于如下两种情况，第一种会用到三个索引，范围之后全失效，c4会用不到；但第二种会用到四个索引，因为MySQL底层优化器会对顺序进行调整优化，优化为和建索引顺序一致，因此会用到四个！ 这种情况显示用到了两个索引，但其实用到了三个索引，第三个索引c3没有用于查找而是用于了排序！ 与上一个相似，会发现和c4没啥关系，因为c3用于了排序，走不到c4！ 用到了两个索引，中间兄弟c3已断，还要使用c4排序，将会导致使用文件排序！ 第一个用到了一个索引，c2,c3用于排序，无文件排序 第二个用到了一个索引，由于order by的顺序不会被MySQL优化顺序，因此会发生断层，MySQL底层使用文件排序！ 第一个用到了两个索引，无filesort，原因是c2 = a2，其实就是常量const，对常量排序毫无意义，因此最后的排序相当于order by c3，并没有断层出现 第二个用到了一个索引，产生了filesort，原因是order by顺序出现了断层 都是只用了一个索引，由于断层会导致第二种情况会发生文件排序和临时表问题！ 总结： 定值为常量、范围后失效还是排序，一般order by是给个范围 group by 基本上都需要进行排序，顺序不当会有临时表产生（分组之前必排序） ¶4、一般性建议 对于单键索引，尽量选择针对当前query过滤性更好的索引 在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。 在选择组合索引的时候，尽量选择可以能包含当前query中的where子句中更多字段的索引 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的 ¶5、索引优化口诀 全值匹配我最爱，最左前缀要遵守 带头大哥不能死，中间兄弟不能断 索引列上少计算，范围之后全失效 Like百分写最右，覆盖索引不写星 不等空值还有or，索引失效要少用 哇擦引号不可丢，SQL高级也不难！ 注：哇擦表示varchar！ ¶六、查询截取分析 一般步骤如下： order by和group by的查询优化 慢查询的开启并捕获 explain+慢SQL分析 show profile查询SQL在Mysql服务器里面的执行细节和生命周期情况 SQL数据库服务器的参数调优。 ¶1、查询优化 ¶1.1、小表驱动大表 其实就是sql的机读顺序问题。in的时候先执行扩号里的查询，所以括号里的表要小；exists的时候先执行外查询，所以括号外的表要小。 EXISTS (subquey)只返回TRUE或FALSE，因此子查询中的SELECT * 也可以是SELECT 1 或select X，官方说法是实际执行时会忽略SELECT清单，因此没有区别 EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担忧效率问题，可进行实际检验以确定是否有效率问题。 EXISTS子查询往往也可以用条件表达式、其他子查询或者JOIN来替代，何种最优需要具体问题具体分析 ¶1.2、order by优化 建表SQL： 123456789101112create table tblA(age int,birth timestamp not null); insert into tblA(age,birth) values(22,now());insert into tblA(age,birth)values(23,now());insert into tblA(age,birth)values(24,now());create index idx_A_ageBirth ON tblA(age,birth); select * from tblA; 性能分析： 12345EXPLAIN SELECT * FROM tblA WHERE age &gt; 20 ORDER BY age;EXPLAIN SELECT * FROM tblA WHERE age &gt; 20 ORDER BY age,birth;EXPLAIN SELECT * FROM tblA WHERE age &gt; 20 ORDER BY birth;EXPLAIN SELECT * FROM tblA WHERE age &gt; 20 ORDER BY birth,age; 后两种出现了filesort文件排序！没有使用到age来排序或者排序字段顺序和索引顺序不一致导致！ 其他情况： 最后一种情况一个升序一个降序也会导致使用filesort文件索引！ 总结： ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序 MySQL支持二种方式的排序，FileSort和Index, Index效率高。 ORDER BY满足两情况，会使用Index方式排序 ORDER BY语句使用索引最左前列 使用where子句与Order By子句条件列组合满足索引最左前列 尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀 如果不在索引列上，filesort有两种算法： 双路排序：MySQL4.1之前是使用双路排序，字面意思是两次扫描磁盘，最终得到数据。读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据传输。从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。 取一批数据，要对磁盘进行两次扫描，众所周知，I\\O是很耗时的，所以在mysql4.1之后，出现了第二张改进的算法，就是单路排序。 单路排序：从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据，并且把随机IO变成顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。 结论及引申出的问题： 由于单路是后出来的，总体而言好过双路 但是用单路有问题 在sort_buffer中，单路比双路要多占用很多空间，因为单路是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取 sort_buffer容量大小，再排……从而多次I/O。本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。 提高Order By的速度： Order by 时 select * 是一个大忌，只Query需要的字段，这点非常重要。在这里的影响是: 当Query的字段大小总和小于 max_length_for_sort_data 而且排序字段不是 TEXTIBLOB 类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。 两种算法的数据都有可能超出 sort_buffer 的容量，超出之后，会创建tmp文件进行合并排序，导致多次IO，但是用单路排序算法的风险会更大一些, 所以要提高 sort_buffer_size。 尝试提高sort_buffer_size不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的。 尝试提高max_length_for_sort_data提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率. 为排序使用索引： MySql两种排序方式∶文件排序或扫描有序索引排序 MySql能为排序与查询使用相同的索引 一个案例： 简单解释一下第八个，b是范围，但是排序使用到了bc，对于bc来说，因为a为常量在，因此范围b不会影响！ ¶1.3、group by优化 和order by类似，适用于order by的都适用于group by，但也有一些新的！ group by实质是先排序后进行分组，遵照索引建的最佳左前缀 当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置 where高于having, 能写在where限定的条件就不要去having限定了。 ¶2、慢查询日志 ¶2.1、是什么 MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。 具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。 由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。 ¶2.2、怎么用 默认情况下，MySQL 数据库没有开启慢查询日志，需要我们手动来设置这个参数。 当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。 慢查询日志支持将日志记录写入文件。 开启设置： 永久生效修改配置文件： 如永久生效需要修改配置文件 my.cnf 中[mysqld]下配置！ 关于慢查询的参数slow_query_log_file，它指定慢查询日志文件的存放路径，系统默认会给一个缺省的文件host_name-slow.log (如果没有指定参数slow_query_log_file的话) 12345[mysqld]slow_query_log=1slow_query_log_file=/var/lib/mysql/xxxxx-slow.loglong_query_time=3log_output=FILE 那么开启慢查询日志后，什么样的SQL参会记录到慢查询里面？ 由参数 long_query_time控制，大于该值才会记录！ 若使用set命令设置后查询发现没有生效，可以断开连接，重新连接即可！ 模拟线程睡眠达到设置的阈值： 1select sleep(4); 使用命令show global status like '%Slow_queries%‘;查询慢SQL条数！ ¶2.3、日志分析工具 mysqldumpslow 查看mysqldumpslow的帮助信息： 1mysqldumpslow --help 参数介绍： 常用命令： 12345678# 得到返回记录集最多的 10 个 SQLmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log# 得到访问次数最多的 10 个 SQLmysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log# 得到按照时间排序的前 10 条里面含有左连接的查询语句mysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/atguigu-slow.log# 另外建议在使用这些命令时结合 | 和 more 使用 ，否则有可能出现爆屏情况mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more ¶3、批量数据脚本 ¶3.1、建表SQL 123456789101112131415161718create table dept(id int unsigned primary key auto_increment,deptno mediumint unsigned not null default 0,dname varchar(20) not null default \"\",loc varchar(13) not null default \"\")engine=innodb default charset=GBK;CREATE TABLE emp(id int unsigned primary key auto_increment,empno mediumint unsigned not null default 0,ename varchar(20) not null default \"\",job varchar(9) not null default \"\",mgr mediumint unsigned not null default 0,hiredate date not null,sal decimal(7,2) not null,comm decimal(7,2) not null,deptno mediumint unsigned not null default 0)ENGINE=INNODB DEFAULT CHARSET=GBK; ¶3.2、设置参数 在执行创建函数之前，首先请保证 log_bin_trust_function_creators 参数为 1，即 on 开启状态。否则会报错： 查询：show variables like 'log_bin_trust_function_creators'; 设置：set global log_bin_trust_function_creators=1; 当然，如上设置只存在于当前操作，想要永久生效，需要写入到配置文件中：在[mysqld]中加上 log_bin_trust_function_creators=1 ¶3.3、编写随机函数 要求：随机产生字符串和部门编号！ 删除函数：drop function 函数名; 123456789101112131415161718192021//函数delimiter $$create function ran_string(n int) returns varchar(255)begindeclare chars_str varchar(100) default 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';declare return_str varchar(255) default '';declare i int default 0;while i &lt; n doset return_str = concat(return_str,substring(chars_str,floor(1+rand()*52),1));set i=i+1;end while;return return_str;end $$//函数delimiter $$create function rand_num() returns int(5)begindeclare i int default 0;set i=floor(100+rand()*10);return i;end $$ ¶3.4、创建存储过程 往两张表中插入随机数据！ 删除存储过程：drop procedure rand_string; 1234567891011121314151617181920212223242526//存储过程delimiter $$ create procedure insert_emp(in start int(10),in max_num int(10))begindeclare i int default 0;set autocommit = 0;repeatset i = i+1;insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values((start+i),ran_string(6),'salesman',0001,curdate(),2000,400,rand_num());until i=max_numend repeat;commit;end $$//存储过程delimiter $$ create procedure insert_dept(in start int(10),in max_num int(10))begindeclare i int default 0;set autocommit = 0;repeatset i = i+1;insert into dept(deptno,dname,loc) values((start+i),ran_string(10),ran_string(8));until i=max_numend repeat;commit;end $$ ¶3.5、调用存储过程 调用存储过程执行批量插入！ 1234567891011delimiter ;call insert_dept(100, 10);# 添加50w条数据试试！delimiter ;call insert_emp(100001, 500000);# Query OK, 0 rows affected (1 min 6.83 sec)# 查询测试select * from emp;# 500000 rows in set (1.29 sec) ¶4、show profiles ¶4.1、是什么 是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。 默认情况下，参数处于关闭状态，并保存最近15次的运行结果 ¶4.2、分析步骤 查看是否开启： 123456789mysql&gt; show variables like '%profiling%';+------------------------+-------+| Variable_name | Value |+------------------------+-------+| have_profiling | YES || profiling | OFF || profiling_history_size | 15 |+------------------------+-------+3 rows in set (0.00 sec) 开启功能，默认是关闭： 12mysql&gt; set profiling=1;Query OK, 0 rows affected, 1 warning (0.00 sec) 运行SQL： 123456789select * from t_emp;select * from t_emp e inner join t_dept d where e.id = d.id;# 如下两句会报错，如果在 SELECT 中的列，没有在 GROUP BY 中出现，那么这个 SQL 是不合法的，因为列不在 GROUP BY 从句中# 需要开启sql_mode语法规则校验的一些设置 ONLY_FULL_GROUP_BYselect * from emp group by id%10 limit 150000;# order by 5是按照第五列字段排序select * from emp group by id%20 order by 5;.... sql_mode补充： sql_mode 定义了对 Mysql 中 sql 语句语法的校验规则！ sql_mode 是个很容易被忽视的变量，默认值是空值，在这种设置下是可以允许一些非法操作的，比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式，所以开发、测试环境的数据库也必须要设置，这样在开发测试阶段就可以发现问题。 1234mysql&gt; select @@sql_mode\\G*************************** 1. row ***************************@@sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION1 row in set (0.00 sec) 查看当前的 sql_mode: select @@sql_mode; 临时修改 sql_mode: set @@sql_mode=’’; 永久修改，需要在配置文件 my.cnf 中修改：[mysqld] 下添加 sql_mode='' 然后重启 mysql 即可 查看结果： 123456789101112131415161718192021mysql&gt; show profiles;+----------+------------+-----------------------------------------------------------------+| Query_ID | Duration | Query |+----------+------------+-----------------------------------------------------------------+| 3 | 0.00016450 | select * from tbl_emp e inner join tbl_dept d where e.id = d.id || 4 | 0.00442350 | show databases || 5 | 0.00285875 | SELECT DATABASE() || 6 | 0.00025075 | show tables || 7 | 0.00019325 | select * from t_emp || 8 | 0.00025050 | select * from t_emp e inner join t_dept d where e.id = d.id || 9 | 0.00019025 | select * from book || 10 | 0.00016150 | select * from emp group by id%10 limit 150000 || 11 | 0.00014275 | select * from emp group by id%20 order by 5 || 12 | 0.00012525 | select @@sql_mode || 13 | 0.00011350 | select @@sql_mode || 14 | 0.00542925 | set sql_mode = '' || 15 | 0.00012400 | select @@sql_mode || 16 | 1.23153325 | select * from emp group by id%10 limit 150000 || 17 | 1.17108425 | select * from emp group by id%20 order by 5 |+----------+------------+-----------------------------------------------------------------+15 rows in set, 1 warning (0.00 sec) 诊断SQL，show profile cpu,block io for query query_id; 1234567891011121314151617181920212223242526mysql&gt; show profile cpu,block io for query 16;+----------------------+----------+----------+------------+--------------+---------------+| Status | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |+----------------------+----------+----------+------------+--------------+---------------+| starting | 0.000081 | 0.000000 | 0.000076 | 0 | 0 || checking permissions | 0.000006 | 0.000000 | 0.000006 | 0 | 0 || Opening tables | 0.000016 | 0.000000 | 0.000016 | 0 | 0 || init | 0.000023 | 0.000000 | 0.000023 | 0 | 0 || System lock | 0.000005 | 0.000000 | 0.000006 | 0 | 0 || optimizing | 0.000003 | 0.000000 | 0.000002 | 0 | 0 || statistics | 0.000027 | 0.000000 | 0.000027 | 0 | 0 || preparing | 0.000011 | 0.000000 | 0.000011 | 0 | 0 || Creating tmp table | 0.003520 | 0.000000 | 0.000576 | 6568 | 0 || Sorting result | 0.000009 | 0.000000 | 0.000006 | 0 | 0 || executing | 0.000002 | 0.000000 | 0.000002 | 0 | 0 || Sending data | 1.227710 | 0.819174 | 0.142815 | 7032 | 0 || Creating sort index | 0.000069 | 0.000057 | 0.000003 | 0 | 0 || end | 0.000004 | 0.000003 | 0.000000 | 0 | 0 || query end | 0.000007 | 0.000006 | 0.000001 | 0 | 0 || removing tmp table | 0.000005 | 0.000004 | 0.000000 | 0 | 0 || query end | 0.000003 | 0.000003 | 0.000000 | 0 | 0 || closing tables | 0.000005 | 0.000005 | 0.000000 | 0 | 0 || freeing items | 0.000016 | 0.000016 | 0.000001 | 0 | 0 || cleaning up | 0.000013 | 0.000012 | 0.000001 | 0 | 0 |+----------------------+----------+----------+------------+--------------+---------------+20 rows in set, 1 warning (0.00 sec) 可以查看的选项： ¶4.3、结论分析 入下几种情况必须要优化！ converting HEAP to MyISAM：查询结果太大，内存都不够用了往磁盘上搬了。 Creating tmp table：创建临时表，拷贝数据到临时表，用完再删除。 Copying to tmp table on disk：把内存中临时表复制到磁盘，危险！！！ locked 下面的例子，就发生了创建临时表问题： 1234567891011121314151617181920212223242526mysql&gt; show profile cpu,block io for query 16;+----------------------+----------+----------+------------+--------------+---------------+| Status | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |+----------------------+----------+----------+------------+--------------+---------------+| starting | 0.000081 | 0.000000 | 0.000076 | 0 | 0 || checking permissions | 0.000006 | 0.000000 | 0.000006 | 0 | 0 || Opening tables | 0.000016 | 0.000000 | 0.000016 | 0 | 0 || init | 0.000023 | 0.000000 | 0.000023 | 0 | 0 || System lock | 0.000005 | 0.000000 | 0.000006 | 0 | 0 || optimizing | 0.000003 | 0.000000 | 0.000002 | 0 | 0 || statistics | 0.000027 | 0.000000 | 0.000027 | 0 | 0 || preparing | 0.000011 | 0.000000 | 0.000011 | 0 | 0 || Creating tmp table | 0.003520 | 0.000000 | 0.000576 | 6568 | 0 || Sorting result | 0.000009 | 0.000000 | 0.000006 | 0 | 0 || executing | 0.000002 | 0.000000 | 0.000002 | 0 | 0 || Sending data | 1.227710 | 0.819174 | 0.142815 | 7032 | 0 || Creating sort index | 0.000069 | 0.000057 | 0.000003 | 0 | 0 || end | 0.000004 | 0.000003 | 0.000000 | 0 | 0 || query end | 0.000007 | 0.000006 | 0.000001 | 0 | 0 || removing tmp table | 0.000005 | 0.000004 | 0.000000 | 0 | 0 || query end | 0.000003 | 0.000003 | 0.000000 | 0 | 0 || closing tables | 0.000005 | 0.000005 | 0.000000 | 0 | 0 || freeing items | 0.000016 | 0.000016 | 0.000001 | 0 | 0 || cleaning up | 0.000013 | 0.000012 | 0.000001 | 0 | 0 |+----------------------+----------+----------+------------+--------------+---------------+20 rows in set, 1 warning (0.00 sec) ¶5、全局查询日志 永远不要在生产环境开启这个功能！ 配置开启： 配置文件中永久开启： 12345# 在mysql的my.cnf中，设置如下:#开启general_log=1# 记录日志文件的路径eral_log _file=/path/logfile #输出格式log_output=FILE 临时开启： 1234set global general_log=1;set global log_output='TABLE';# 此后，你所编写的sql语句，将会记录到mysql库里的general_log表，可以用下面的命令查看：select * from mysql.general_log; ¶七、MySQL锁机制 ¶1、锁的定义 锁是计算机协调多个进程或线程并发访问某一资源的机制！ 在数据库中，除传统的计算资源（如CPU、RAM、IO等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。 ¶2、锁的分类 从数据操作的类型（读、写）分： 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响 写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。 从对数据操作的颗粒度 表锁 行锁 ¶3、表锁（偏读） ¶3.1、特点 偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发最低！ ¶3.2、案例分析 建表SQL： 以MyISAM引擎为例！ 12345678910create table mylock (id int not null primary key auto_increment,name varchar(20) default '') engine myisam;insert into mylock(name) values('a');insert into mylock(name) values('b');insert into mylock(name) values('c');insert into mylock(name) values('d');insert into mylock(name) values('e'); 常用命令： 123456789101112131415161718192021222324# 查看表上加过的锁:show open tables;# 手动增加表锁：lock table表名字read(write), 表名字2 read(write), 其它;# 释放全部表锁:unlock tables;# 分析表锁定：# 可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定:show status like 'table%';mysql&gt; show status like 'table%';+----------------------------+-------+| Variable_name | Value |+----------------------------+-------+| Table_locks_immediate | 110 || Table_locks_waited | 0 || Table_open_cache_hits | 11 || Table_open_cache_misses | 13 || Table_open_cache_overflows | 0 |+----------------------------+-------+5 rows in set (0.01 sec) Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1 Table_locks_waited：出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加1，此值高则说明存在着较，严重的表级锁争用情况 此外，Myisam的读写锁调度是写优先，这也是myisam不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。 读锁共享： unlock后才会结束阻塞！ 结果： 当前session可以查询该表记录，但不能查询其他没有加锁表记录，不能对该表进行写操作！ 其他session可以查询该表记录，也可查询其他表记录，如果对该表进行写操作会发生阻塞，直到原来表释放锁解除，写操作完成！ 写锁排他： unlock后才会结束阻塞！ 结果： 当前session可以进行读写操作，但是不能查询其他没加锁表记录 其他session可以对其他表进行读写，但不能对该表进行读写操作 总结： MyISAM在执行查询语句(SELECT）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。 简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞。 ¶4、行锁（偏写） ¶4.1、特点 偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION），二是采用了行级锁 ¶4.2、案例分析 为了使得行锁生效，得保证条件中的列为建了索引的列！ 建表SQL： 123456789101112131415161718192021CREATE TABLE test_innodb_lock (a INT(11),b VARCHAR(16))ENGINE=INNODB;# 插入数据INSERT INTO test_innodb_lock VALUES(1,'b2');INSERT INTO test_innodb_lock VALUES(3,'3');INSERT INTO test_innodb_lock VALUES(4, '4000');INSERT INTO test_innodb_lock VALUES(5,'5000');INSERT INTO test_innodb_lock VALUES(6, '6000');INSERT INTO test_innodb_lock VALUES(7,'7000');INSERT INTO test_innodb_lock VALUES(8, '8000');INSERT INTO test_innodb_lock VALUES(9,'9000');INSERT INTO test_innodb_lock VALUES(1,'b1');# 创建索引CREATE INDEX test_innodb_a_ind ON test_innodb_lock(a);CREATE INDEX test_innodb_lock_b_ind ON test_innodb_lock(b);------------------------------------------------------------# 关闭自动提交，不进行自动提交，相当于默认加了行锁！SET autocommit=0;------------------------------------------------------------ 行锁同一行阻塞，不同行无影响： commit后阻塞才会结束！ 索引失效行锁升级为表锁： 本来锁的是同一行，现在不同行也锁了，成为了表锁！ 原因就是b为varchar类型，前面讲到过这个类型必须加单引号，不加就会造成索引失效，索引失效就会导致行锁失效，成为表锁！ 这就是最危险的，还是不知情情况下发生的，会导致其他操作长时间阻塞等待，直到当前commit才可！ 拓展：一旦对表进行全表扫描（索引失效），innodb的行锁就会自动变为表锁，保护表的记录，直到写操作完成并提交！ 间隙锁： 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁，对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。 会造成的问题： 因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定。 而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。 但是间隙锁会完全解决幻读问题！ 本来没有a=2的行，但是在左边修改后，右边插入a=2的数据竟然可以发生阻塞！ 面试中常考如何锁定一行： for update等于加了锁，直到当前会话提交后才会释放锁！ 1select * from test_innodb_lock where a=8 for update; 查看系统变量分析行锁： 1234567891011mysql&gt; show status like 'innodb_row_lock%';+-------------------------------+--------+| Variable_name | Value |+-------------------------------+--------+| Innodb_row_lock_current_waits | 0 || Innodb_row_lock_time | 204071 || Innodb_row_lock_time_avg | 51017 || Innodb_row_lock_time_max | 51029 || Innodb_row_lock_waits | 4 |+-------------------------------+--------+5 rows in set (0.01 sec) 对各个状态量的说明如下: Innodb_row_lock_current_waits：当前正在等待锁定的数量（等待总次数） Innodb_row_lock_time：从系统启动到现在锁定总时间长度（等待总时长） Innodb_row_lock_time_avg：每次等待所花平均时间（等待平均时长） Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间;Innodb_row_lock_waits:系统启动后到现在总共等待的次数 尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析（show profiles;）系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。 优化建议： 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 合理设计索引，尽量缩小锁的范围 尽可能较少检索条件，避免间隙锁 尽量控制事务大小，减少锁定资源量和时间长度 尽可能低级别事务隔离 ¶5、页锁（了解） 开销和加锁时间界于表锁和行锁之间：会出现死锁！ 锁定粒度界于表锁和行锁之间，并发度一般！ ¶八、主从复制 ¶1、复制的基本原理 类似redis的主从复制！ slave会从master读取binlog来进行数据同步： master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志时间，binary log events slave将master的binary log ebents拷贝到它的中继日志（relay log） slave重做中继日志中的时间，将改变应用到自己的数据库中。MySQL复制是异步的且串行化的 ¶2、复制的基本原则 ​ 每个slave只有一个master 每个slave只能有一个唯一的服务器ID 每个master可以有多个salve ¶3、一主一从配置 window为主机，linux为从机！ 由于我使用云服务器且本地windows的MySQL版本不一致，因此，配置过程仅用于记录！ mysql 版本一致且后台以服务运行 主从都配置在[mysqld]结点下，都是小写 1、主机配置项： my.ini文件： 1234567891011主服务器唯一 IDserver-id=1启用二进制日志log-bin=自己本地的路径/data/mysqlbinlog-bin=D:/devSoft/MySQLServer5.5/data/mysqlbin设置不要复制的数据库binlog-ignore-db=mysql设置需要复制的数据库binlog-do-db=需要复制的主数据库名字设置 logbin 格式binlog_format=STATEMENT（默认） 2、从机修改my.cnf配置文件： 从服务器唯一ID（必须） 启用二进制文件（可选） 12345#从机服务 idserver-id = 2#注意 my.cnf 中有 server-id = 1#设置中继日志relay-log=mysql-relay 3、因修改过配置文件，请主机+从机都启动后台mysql服务！ 4、主机从机都关闭防火墙 windows手动关闭 关闭虚拟机linux防火墙systemctl stop firewalld.service 5、在Windows主机上简历账户并授权slave 记录下File（日志文件）和Position（位置，从哪开始复制）的值，下一步使用！ 执行完此步骤后不要再操作主服务器 MYSQL，防止主服务器状态值变化！ 若报错，可运行stop slave停止原来的从机复制，注意查看状态后状态值将会发生变化，记得用新的值grant！ 1234GRANT REPLICATION SLAVE ON *.* TO 'zhangsan'@'从机器数据库IP‘ IDENTIFIED BY '123456';flush privileges;# 查询master的状态show master status； 6、在 Linux 从机上配置需要复制的主机 12#查询 master 的状态CHANGE MASTER TO MASTER_HOST='主机 IP',MASTER_USER='创建用户名',MASTER_PASSWORD='创建的密码', MASTER_LOG_FILE='File 名字',MASTER_LOG_POS=Position 数字; 7、启动从服务器复制功能 12start slave;show slave status\\G 下面两个参数都是 Yes，则说明主从配置成功！ 12Slave_IO_Running: YesSlave_SQL_Running: Yes 8、主机新建库、新建表、insert 记录，从机复制 9、如何停止从服务复制功能 1stop slave; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"关系型数据库","slug":"数据库/关系型数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.itnxd.cn/tags/MySQL/"},{"name":"索引优化","slug":"索引优化","permalink":"https://www.itnxd.cn/tags/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"},{"name":"性能分析","slug":"性能分析","permalink":"https://www.itnxd.cn/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"}],"author":"ITNXD"},{"title":"Redis从入门到入土及几大面试常问问题","slug":"Redis从入门到入土及几大面试常问问题","date":"2021-08-30T07:12:17.000Z","updated":"2021-09-13T07:53:00.158Z","comments":true,"path":"posts/64689.html","link":"","permalink":"https://www.itnxd.cn/posts/64689.html","excerpt":"","text":"¶一、NoSQL数据库简介 ¶1、引入 随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。 解决CPU及内存压力？ — 增加多台服务器，复制进行分散！ 解决IO压力？ — 增加缓存数据库！ ¶2、NoSQL概述 NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。 NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。 不遵循SQL标准。 不支持ACID。（并不是不支持事务） 远超于SQL的性能。 ¶3、NoSQL使用场景 适用场景： 对数据高并发的读写 海量数据的读写 对数据高可扩展性的 不适用场景 需要事务支持 基于sql的结构化查询存储，处理复杂的关系，需要即席查询。 （用不着sql****的和用了sql也不行的情况，请考虑用NoSql） ¶二、Redis安装及其启动 ¶1、Redis概述 Redis是一个开源的key-value存储系统。 和Memcached类似，它支持存储的value类型相对更多，包括string、list、set、zset(sorted set --有序集合)和hash。 这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。 在此基础上，Redis支持各种不同方式的排序。 与memcached一样，为了保证效率，数据都是缓存在内存中。 区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。 并且在此基础上实现了master-slave**(主从)同步**。 ¶2、应用场景 配合关系型数据库做高速缓存： 高频次，热门访问的数据，降低数据库IO 分布式架构，做session共享 多样的数据结构存储持久化数据（如下图）： ¶3、Redis安装 访问Redis官网进行下载！ Redis只能在Linux下使用，没有Windows版本！ 123456789101112131415# 压缩文件位置cd /opt# 下载Redis压缩包 地址直接去官网下载处右键复制链接地址即可！wget https://download.redis.io/releases/redis-6.2.5.tar.gz# 解压tar -zxvf redis-6.2.5.tar.gz# Redis安装需要使用草C语言环境，先安装gccyum install gcc# 测试gcc版本gcc -v# 进入Redis解压目录进行编译及安装cd redis-6.2.5make &amp;&amp; make install 可执行文件位置：/usr/local/bin redis-benchmark：性能测试工具，可以在自己本机运行，看看自己本子性能如何 redis-check-aof：修复有问题的AOF文件 redis-check-dump：修复有问题的dump.rdb文件 redis-sentinel：Redis集群使用 redis-server：Redis服务器启动命令 redis-cli：客户端，操作入口 ¶4、Redis启动 默认端口6379，建议进行修改！ ¶4.1、前台启动 前台启动，命令行窗口关闭，则Redis服务停止！ 1redis-server ¶4.2、后台启动（推荐） 12345678910111213141516171819# 备份redis配置文件cd /opt/redis-6.2.5cp redis.conf /etc/redis.conf# 修改配置信息vim /etc/redis.conf# 将 daemonize no改成yes --&gt;打开后台启动开关# 后台启动redis-server /etc/redis.conf# 查看redis进程ps -ef | grep redis# 前台访问redis-cli# 指定端口访问redis-cli -p port# 测试 输入ping返回pongping ¶5、Redis关闭 在redis-cli中直接使用命令shutdown关闭，后台服务redis-server将终止。 或直接输入linux命令redis-cli -p port shutdown进行关闭 或者直接查看进程号通过linux命令kill -9关闭。（不建议，可能丢失数据等等） 退出客户端直接输入exit即可！ ¶6、Redis实现原理 原理：Redis是单线程+多路IO复用技术，memcached是多线程+锁！ 单线程 + 多路IO复用技术简单图示： ¶三、五大常用数据类型 在官网可以获得常用数据类型的各种命令！ ¶1、Redis中的key 操作key常用命令： keys *：查看当前库所有key (匹配：keys *1) exists key：判断某个key是否存在 type key：查看你的key是什么类型 del key：删除指定的key数据 unlink key：根据value选择非阻塞删除（仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。） expire key x：x秒钟：为给定的key设置过期时间 ttl key：查看还有多少秒过期，-1表示永不过期，-2表示已过期 操作库常用命令： select &lt;dbid&gt;：命令切换数据库（默认16个数据库，类似数组下标从0开始，初始默认使用0号库） dbsize：查看当前数据库的key的数量 flushdb：清空当前库 flushall：通杀全部库 ¶2、字符串String String类型是二进制安全的。意味着Redis的String可以包含任何数据。比如jpg图片或者序列化的对象。 String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M。 ¶2.1、常用命令 set key value [EX seconds | PX milliseconds | KEEPTTL][NX |XX] NX：当数据库中key不存在时，可以将key-value添加数据库 XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥 EX：key的超时秒数 PX：key的超时毫秒数，与EX互斥 get &lt;key&gt;：查询对应键值 append &lt;key&gt;&lt;value&gt;：将给定的&lt;value&gt;追加到原值的末尾并返回总长度 strlen &lt;key&gt;：获得值的长度 setnx &lt;key&gt;&lt;value&gt;：只有在 key 不存在时 设置 key 的值 incr &lt;key&gt;：将 key 中储存的数字值增1，只能对数字值操作，如果为空，新增值为1 decr &lt;key&gt;：将 key 中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1 incrby / decrby &lt;key&gt;&lt;步长&gt;：将 key 中储存的数字值增减。自定义步长。 mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; ..... ：同时设置一个或多个 key-value对 mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt; .....：同时获取一个或多个 value msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; ..... ：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。原子性，有一个失败则都失败。 getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;：（闭区间）获得值的范围，类似java中的substring。 setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;：用 &lt;value&gt; 覆写&lt;key&gt;所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。 （从起始位置覆盖，原字符串剩下的没有被覆盖的追加到后面） setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;：设置键值的同时，设置过期时间，单位秒。 getset &lt;key&gt;&lt;value&gt;：以新换旧，设置了新值同时获得旧值。 补充：所谓原子操作是指不会被线程调度机制打断的操作： 这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。 （1）在单线程中， 能够在单条指令中完成的操作都可以认为是\"原子操作\"，因为中断只能发生于指令之间。 （2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。 Redis单命令的原子性主要得益于Redis的单线程。 ¶2.2、数据结构 String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。 当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。 ¶3、列表List 单键多值。Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。 ¶3.1、常用命令 lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; .... ：从左边/右边插入一个或多个值。 lpop/rpop &lt;key&gt;：从左边/右边吐出一个值。值在键在，值光键亡。(每次删一个，删完则键值对就没了) rpoplpush &lt;key1&gt;&lt;key2&gt;：从&lt;key1&gt;列表右边吐出一个值，插到&lt;key2&gt;列表左边。 lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;：按照索引下标获得元素(从左到右) lrange mylist 0 -1：0左边第一个，-1右边第一个，（0-1表示获取所有） lindex &lt;key&gt;&lt;index&gt;：按照索引下标获得元素(从左到右) llen &lt;key&gt;：获得列表长度 linsert &lt;key&gt; before &lt;value&gt;&lt;newvalue&gt;：在&lt;value&gt;的前面插入&lt;newvalue&gt;插入值 lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;：从左边删除n个value(从左到右) lset&lt;key&gt;&lt;index&gt;&lt;value&gt;：将列表key下标为index的值替换成value ¶3.2、数据结构 List的数据结构为快速链表quickList。 首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。 因为普通的链表需要的附加指针空间太大，会比较浪费空间。 Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。 ¶4、集合Set Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。 ¶4.1、常用命令 sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... ：将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略 smembers &lt;key&gt;：取出该集合的所有值。 sismember &lt;key&gt;&lt;value&gt;：判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有1，没有0 scard&lt;key&gt;返回该集合的元素个数。 srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .... ：删除集合中的某个元素。 spop &lt;key&gt;：随机从该集合中吐出一个值。 srandmember &lt;key&gt;&lt;n&gt;：随机从该集合中取出n个值。不会从集合中删除 。 smove &lt;source&gt;&lt;destination&gt;value：把集合中一个值从一个集合移动到另一个集合 sinter &lt;key1&gt;&lt;key2&gt;：返回两个集合的交集元素。 sunion &lt;key1&gt;&lt;key2&gt;：返回两个集合的并集元素。 sdiff &lt;key1&gt;&lt;key2&gt;：返回两个集合的差集元素(key1中的，不包含key2中的) ¶4.2、数据结构 Set数据结构是dict字典，字典是用哈希表实现的。 Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。 ¶5、哈希Hash Redis hash 是一个键值对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 类似Java里面的Map&lt;String,Object&gt;。 ¶5.1、常用命令 hset &lt;key&gt;&lt;field&gt;&lt;value&gt;：给&lt;key&gt;集合中的 &lt;field&gt;键赋值&lt;value&gt;（可以批量插入，类似hmset，可以插入和修改） hget &lt;key1&gt;&lt;field&gt;从&lt;key1&gt;：集合&lt;field&gt;取出 value hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;... ：批量设置hash的值 hexists&lt;key1&gt;&lt;field&gt;：查看哈希表 key 中，给定域 field 是否存在。 hkeys &lt;key&gt;：列出该hash集合的所有field hvals &lt;key&gt;：列出该hash集合的所有value hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;：为哈希表 key 中的域 field 的值加上增量 1 -1 hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;：将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 . ¶5.2、数据结构 Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。 ¶6、有序集合Zset Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。 不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。 因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。 访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。 ¶6.1、常用命令 zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…：将一个或多个 member 元素及其 score 值加入到有序集 key 当中。 zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]：返回有序集 key 中，下标在&lt;start&gt;&lt;stop&gt;之间的元素。带WITHSCORES，可以让分数一起和值返回到结果集。 zrangebyscore key min max [withscores] [limit offset count]：返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 zrevrangebyscore key max min [withscores] [limit offset count] ：同上，改为从大到小排列。 zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;：为元素的score加上增量 zrem &lt;key&gt;&lt;value&gt;：删除该集合下，指定值的元素 zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;：统计该集合，分数区间内的元素个数 zrank &lt;key&gt;&lt;value&gt;：返回该值在集合中的排名，从0开始。 ¶6.2、数据结构 SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。 zset底层使用了两个数据结构： hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。 跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。 ¶四、Redis配置文件介绍 配置文件位置：opt下的解压目录或者我们使用的备份文件位置，/etc/redis.conf 配置文件修改后，都需要重启Redis进程！ ¶1、Units单位 配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit。 大小写不敏感！ ¶2、INCLUDES包含 类似jsp中的include，多实例的情况可以把公用的配置文件提取出来 ¶3、网络相关配置 bind + ip：表示谁可以访问Redis服务器，默认情况bind=127.0.0.1只能接受本机的访问请求，不写的情况下，无限制接受任何ip地址的访问 生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉 protected-mode：保护模式，如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应 port：端口，默认6379，建议修改，防止攻击。修改端口启动需要使用-p参数指定端口 tcp-backlog：backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。 注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果 timeout：一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。 tcp-keepalive：对访问客户端的一种心跳检测，每个n秒检测一次。单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 ¶4、GENERAL通用 daemonize：是否为后台进程，设置为yes。守护进程，后台启动 pidfile：进程id文件，存放pid文件的位置，每个实例会产生一个不同的pid文件 loglevel：指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice。四个级别根据使用阶段来选择，生产环境选择notice 或者warning logfile：日志文件名称 databases 16：设定库的数量 默认16，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id ¶5、SECURITY安全 requirepass：密码设置，在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。永久设置，需要再配置文件中进行设置。 命令行设置密码： ¶6、CLIENTS限制 maxclients：设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。 maxmemory：设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。 建议必须设置，否则，将内存占满，造成服务器宕机 如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。 但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。 maxmemory-policy：移除规则 volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用） allkeys-lru：在所有集合key中，使用LRU算法移除key volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键 allkeys-random：在所有集合key中，移除随机的key volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key noeviction：不进行移除。针对写操作，只是返回错误信息 maxmemory-samples：设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。 ¶五、Redis的发布和订阅 ¶1、Redis的发布和订阅 Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 订阅及发送消息如下图： ¶2、命令行实现 发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息。 1234567891011121314151617181920# 打开一个客户端订阅channel1频道，返回值为动态监控频道的消息127.0.0.1:6666&gt; SUBSCRIBE channel1Reading messages... (press Ctrl-C to quit)1) \"subscribe\"2) \"channel1\"3) (integer) 1# 打开另一个客户端，给channel1发布消息hello（返回值为订阅者数量）127.0.0.1:6666&gt; publish channel1 hello# 此时该客户端将收到消息127.0.0.1:6666&gt; SUBSCRIBE channel1Reading messages... (press Ctrl-C to quit)1) \"subscribe\"2) \"channel1\"3) (integer) 11) \"subscribe\"2) \"channel1\"3) \"hello\" ¶六、Redis6新增数据类型 ¶1、Bitmaps ¶1.1、概述 Redis提供了Bitmaps这个“数据类型”可以实现对位的操作： Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value）， 但是它可以对字符串的位进行操作。 Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。 ¶1.2、常用命令 setbit&lt;key&gt;&lt;offset&gt;&lt;value&gt;：设置Bitmaps中某个偏移量的值（0或1），offset偏移量从0开始 例子：很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。 独立用户是否访问过网站可以使用Bitmaps统计。在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。 getbit&lt;key&gt;&lt;offset&gt;：获取Bitmaps中某个偏移量的值 bitcount&lt;key&gt;[start end]：统计字符串从start字节到end字节比特值为1的数量。 注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。 bitop and(or/not/xor) &lt;destkey&gt; [key…]：复合操作， 它可以做多个Bitmaps的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存在destkey中。 ¶1.3、Bitmaps与set对比 Bitmaps适合大量数据且活跃占比大的情况，可以节省空间（会将每个数据都进行位存储） Set适合大量数据且活跃占比较低的情况，可以节省空间（只存储活跃数据） ¶2、HyperLogLog ¶2.1、概述 我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。 但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。 解决基数问题有很多种方案： （1）数据存储在MySQL表中，使用distinct count计算不重复个数 （2）使用Redis提供的hash、set、bitmaps等数据结构来处理 以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。 Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 ¶2.2、常用命令 pfadd &lt;key&gt;&lt; element&gt; [element ...]：添加指定元素到 HyperLogLog 中，将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数（即不同元素个数）发生变化，则返回1，否则返回0。 pfcount&lt;key&gt; [key ...]：计算HLL的近似基数（不同元素个数，交集） pfmerge&lt;destkey&gt;&lt;sourcekey&gt; [sourcekey ...]：将一个或多个HLL合并后的结果存储在另一个HLL中，并集 ¶3、Geospatial ¶3.1、概述 Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。 ¶3.2、常用命令 geoadd&lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;&lt;member&gt; [longitude latitude member...]：添加地理位置（经度，纬度，名称） 两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。 有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。 当坐标位置超出指定范围时，该命令将会返回一个错误。已经添加的数据，是无法再次往里面添加的。 geopos &lt;key&gt;&lt;member&gt; [member...]：获得指定地区的坐标值 geodist&lt;key&gt;&lt;member1&gt;&lt;member2&gt; [m|km|ft|mi ]：获取两个位置之间的直线距离 m 表示单位为米，（默认值）。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 georadius&lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;radius m|km|ft|mi：以给定的经纬度为中心，找出某一半径内的元素 ¶七、Jedis操作Redis ¶1、导包 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt; ¶2、Redis配置 云服务器厂商防火墙放行端口 Linux服务器内防火墙放行端口 redis.conf中注释掉 bind 127.0.0.1，然后关闭保护模式 protected-mode no ¶3、Jedis连接测试 123456public static void main(String[] args) { Jedis jedis = new Jedis(\"82.156.11.189\", 6379); // 测试，返回pong System.out.println(jedis.ping()); jedis.close();} ¶4、测试相关数据类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * String测试！ */@Testpublic void testString() { Jedis jedis = new Jedis(\"82.156.11.189\", 6379); // 添加单个key jedis.set(\"name\", \"lucy\"); // 获取单个value String name = jedis.get(\"name\"); System.out.println(name); System.out.println(jedis.ttl(\"name\")); System.out.println(jedis.exists(\"name\")); // 添加多个key jedis.mset(\"k1\", \"v1\", \"k2\", \"v2\", \"k3\", \"v3\"); // 获取多个value List&lt;String&gt; values = jedis.mget(\"k1\", \"k2\", \"k3\"); System.out.println(values); Set&lt;String&gt; keys = jedis.keys(\"*\"); for (String key : keys) { System.out.println(key); } jedis.close();}/** * List测试！ */@Testpublic void testList(){ Jedis jedis = new Jedis(\"82.156.11.189\", 6379); jedis.lpush(\"k1\", \"a\", \"b\", \"c\"); List&lt;String&gt; k1 = jedis.lrange(\"k1\", 0, -1); System.out.println(k1); jedis.close();}/** * 测试Set! */@Testpublic void testSet(){ Jedis jedis = new Jedis(\"82.156.11.189\", 6379); jedis.sadd(\"k2\", \"a\", \"b\", \"c\", \"a\"); Set&lt;String&gt; k2 = jedis.smembers(\"k2\"); System.out.println(k2); jedis.close();}/** * 测试Hash！ */@Testpublic void testHash(){ Jedis jedis = new Jedis(\"82.156.11.189\", 6379); jedis.hset(\"users\", \"age\", \"20\"); String age = jedis.hget(\"users\", \"age\"); System.out.println(age); jedis.close();}/** * 测试Zset！ */@Testpublic void testZset(){ Jedis jedis = new Jedis(\"82.156.11.189\", 6379); jedis.zadd(\"china\", 100d, \"shanghai\"); jedis.zadd(\"china\", 200d, \"beijing\"); jedis.zadd(\"china\", 300d, \"taiyuan\"); Set&lt;String&gt; china = jedis.zrange(\"china\", 0, -1); System.out.println(china); jedis.close();} ¶5、手机验证码实例 功能要求： 1、输入手机号，点击发送后随机生成6位数字码，2分钟有效 2、输入验证码，点击验证，返回成功或失败 3、每个手机号每天只能输入3次 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.itnxd.jedis;import redis.clients.jedis.Jedis;import java.util.Random;/** * @author ITNXD * @create 2021-09-01 15:53 */public class PhoneCode { /** * 模拟验证码发送！ * @param args */ public static void main(String[] args) { // 发送验证码 verifyCode(\"18888888888\"); // 校验验证码 getRedisCode(\"18888888888\", \"425741\"); } /** * 1. 生成六位数字验证码 */ public static String getCode(){ Random random = new Random(); return String.format(\"%06d\", random.nextInt(1000000)); } /** * 2. 处理每个手机号每天只能发送三次验证码，验证码过期时间120s */ public static void verifyCode(String phone){ Jedis jedis = new Jedis(\"82.156.11.189\", 6379); // 手机发送次数key规则 String countKey = \"verifyCode\" + phone + \":count\"; // 验证码key规则 String codeKey = \"verifyCode\" + phone + \":code\"; // 每个手机号每天只能发送三次 String count = jedis.get(countKey); if(count == null) { // 表示第一次发送，redis中添加过期时间为24小时的key jedis.setex(countKey, 24 * 60 * 60, \"1\"); }else if(Integer.parseInt(count) &lt;= 2){ // 发送次数加一 jedis.incr(countKey); }else if(Integer.parseInt(count) &gt; 2){ // 三次机会已用完 System.out.println(\"今天发送次数已经超过三次了！\"); jedis.close(); return; } // 发送的验证码放到redis中！ String vcode = getCode(); jedis.setex(codeKey, 120, vcode); jedis.close(); } /** * 3. 验证码校验 */ public static void getRedisCode(String phone, String code){ Jedis jedis = new Jedis(\"82.156.11.189\", 6379); // 从redis中获取随机生成的验证码 String codeKey = \"verifyCode\" + phone + \":code\"; String redisCode = jedis.get(codeKey); // 校验 if(code.equals(redisCode)){ System.out.println(\"成功\"); }else{ System.out.println(\"失败\"); } jedis.close(); }} ¶八、Redis的事务操作 ¶1、Redis中的事务 Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 Redis事务的主要作用就是串联多个命令防止别的命令插队。 ¶2、五大关键字 Multi命令：输入的命令都会依次进入命令队列中，但不会执行。 Exec命令：Redis会将之前的命令队列中的命令依次执行。 Discard命令：组队的过程中可以通过该命令来放弃组队。 watch key1 [key2]：在执行multi之前，先执行该命令，可以监视一个(或多个) key ，如果在事务执行之前这些key被其他命令所改动，那么事务将被打断。 unwhatch key1 [key2]：取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。 ¶3、事务的错误处理 组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。 如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。 ¶4、Redis事务的三大特性 单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 没有隔离级别的概念：队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行 不保证原子性：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 ¶5、Redis中的悲观锁和乐观锁 悲观锁(Pessimistic Lock)：（Redis不可直接用）顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 乐观锁(Optimistic Lock)：（Redis可以直接用）顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。 乐观锁简单图示： ¶6、事务-秒杀案例 库存减1，秒杀成功者加1！ ¶6.1、并发模拟 在Linux中安装httpd-tools来模拟大量请求和并发操作！ 1234yum install httpd-tools# 报错的话使用：yum --disableexcludes=all install httpd 测试： vim postfile 模拟表单提交参数，以&amp;符号结尾，存放当前目录。内容：prodid=0101&amp; 使用ab命令模拟测试： -n：总请求数 -c：并发请求数 -k：使用 HTTP KeepAlive 功能，可不加 -p：指定请求文件postfile位置 -T：如果为POST/PUT请求需要指定提交的数据类型为application/x-www-form-urlencoded 最后为请求地址 1ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded http://192.168.2.115:8081/Seckill/doseckill ¶6.2、事务问题解决 第一版：简单版 Servlet程序： 12345678910111213141516public class SecKillServlet extends HttpServlet { private static final long serialVersionUID = 1L; public SecKillServlet() { super(); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String userid = new Random().nextInt(50000) +\"\" ; String prodid =request.getParameter(\"prodid\"); boolean isSuccess=SecKill_redis.doSecKill(userid,prodid); response.getWriter().print(isSuccess); }} 核心秒杀函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//秒杀过程public static boolean doSecKill(String uid,String prodid) throws IOException { //1 uid和prodid非空判断 if(uid == null || prodid == null) { return false; } //2 连接redis Jedis jedis = new Jedis(\"82.156.11.189\",6379); //3 拼接key // 3.1 库存key(string) String kcKey = \"sk:\"+prodid+\":qt\"; // 3.2 秒杀成功用户key(set) String userKey = \"sk:\"+prodid+\":user\"; //4 获取库存，如果库存null，秒杀还没有开始 String kc = jedis.get(kcKey); if(kc == null) { System.out.println(\"秒杀还没有开始，请等待\"); jedis.close(); return false; } // 5 判断用户是否重复秒杀操作 if(jedis.sismember(userKey, uid)) { System.out.println(\"已经秒杀成功了，不能重复秒杀\"); jedis.close(); return false; } //6 判断如果商品数量，库存数量小于1，秒杀结束 if(Integer.parseInt(kc)&lt;=0) { System.out.println(\"秒杀已经结束了\"); jedis.close(); return false; } //7 秒杀过程 //7.1 库存-1 jedis.decr(kcKey); //7.2 把秒杀成功用户添加清单里面 jedis.sadd(userKey,uid); System.out.println(\"秒杀成功了..\"); jedis.close(); return true;} 第二版：加事务-乐观锁(解决超卖)，但出现遗留库存和连接超时 添加乐观锁解决超卖问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//秒杀过程public static boolean doSecKill(String uid,String prodid) throws IOException { //1 uid和prodid非空判断 if(uid == null || prodid == null) { return false; } //2 连接redis Jedis jedis = new Jedis(\"82.156.11.189\",6666); //3 拼接key // 3.1 库存key(string) String kcKey = \"sk:\"+prodid+\":qt\"; // 3.2 秒杀成功用户key(set) String userKey = \"sk:\"+prodid+\":user\"; //监视库存 jedis.watch(kcKey); //4 获取库存，如果库存null，秒杀还没有开始 String kc = jedis.get(kcKey); if(kc == null) { System.out.println(\"秒杀还没有开始，请等待\"); jedis.close(); return false; } // 5 判断用户是否重复秒杀操作 if(jedis.sismember(userKey, uid)) { System.out.println(\"已经秒杀成功了，不能重复秒杀\"); jedis.close(); return false; } //6 判断如果商品数量，库存数量小于1，秒杀结束 if(Integer.parseInt(kc)&lt;=0) { System.out.println(\"秒杀已经结束了\"); jedis.close(); return false; } //7 秒杀过程 //使用事务 Transaction multi = jedis.multi(); //组队操作 multi.decr(kcKey); multi.sadd(userKey,uid); //执行 List&lt;Object&gt; results = multi.exec(); if(results == null || results.size()==0) { System.out.println(\"秒杀失败了....\"); jedis.close(); return false; } System.out.println(\"秒杀成功了..\"); jedis.close(); return true;} 第三版：连接池解决超时问题 节省每次连接redis服务带来的消耗，把连接好的实例反复利用。通过参数管理连接的行为。 链接池参数： MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。 maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例； MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException； testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的； JedisPoolUtil.java： 12345678910111213141516171819202122232425262728293031323334353637package com.itnxd.redis_seckill_demo;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;public class JedisPoolUtil { private static volatile JedisPool jedisPool = null; private JedisPoolUtil() { } public static JedisPool getJedisPoolInstance() { if (null == jedisPool) { synchronized (JedisPoolUtil.class) { if (null == jedisPool) { JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(200); poolConfig.setMaxIdle(32); poolConfig.setMaxWaitMillis(100*1000); poolConfig.setBlockWhenExhausted(true); poolConfig.setTestOnBorrow(true); // ping PONG jedisPool = new JedisPool(poolConfig, \"192.168.44.168\", 6379, 60000 ); } } } return jedisPool; } public static void release(JedisPool jedisPool, Jedis jedis) { if (null != jedis) { jedisPool.returnResource(jedis); } }} Servlet程序修改： 123456789101112131415161718public class SecKillServlet extends HttpServlet { private static final long serialVersionUID = 1L; public SecKillServlet() { super(); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String userid = new Random().nextInt(50000) +\"\" ; String prodid =request.getParameter(\"prodid\"); boolean isSuccess=SecKill_redis.doSecKill(userid,prodid);// boolean isSuccess= SecKill_redisByScript.doSecKill(userid,prodid); response.getWriter().print(isSuccess); }} 使用连接池的核心函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static void main(String[] args) { Jedis jedis =new Jedis(\"82.156.11.189\",6666); System.out.println(jedis.ping()); jedis.close();}//秒杀过程public static boolean doSecKill(String uid,String prodid) throws IOException { //1 uid和prodid非空判断 if(uid == null || prodid == null) { return false; } //2 连接redis //通过连接池得到jedis对象 JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance(); Jedis jedis = jedisPoolInstance.getResource(); //3 拼接key // 3.1 库存key(string) String kcKey = \"sk:\"+prodid+\":qt\"; // 3.2 秒杀成功用户key(set) String userKey = \"sk:\"+prodid+\":user\"; //监视库存 jedis.watch(kcKey); //4 获取库存，如果库存null，秒杀还没有开始 String kc = jedis.get(kcKey); if(kc == null) { System.out.println(\"秒杀还没有开始，请等待\"); jedis.close(); return false; } // 5 判断用户是否重复秒杀操作 if(jedis.sismember(userKey, uid)) { System.out.println(\"已经秒杀成功了，不能重复秒杀\"); jedis.close(); return false; } //6 判断如果商品数量，库存数量小于1，秒杀结束 if(Integer.parseInt(kc)&lt;=0) { System.out.println(\"秒杀已经结束了\"); jedis.close(); return false; } //7 秒杀过程 //使用事务 Transaction multi = jedis.multi(); //组队操作 multi.decr(kcKey); multi.sadd(userKey,uid); //执行 List&lt;Object&gt; results = multi.exec(); if(results == null || results.size()==0) { System.out.println(\"秒杀失败了....\"); jedis.close(); return false; } System.out.println(\"秒杀成功了..\"); jedis.close(); return true;} 第四版：解决库存遗留问题，LUA脚本 解决库存遗留问题(乐观锁有一个购买成功版本号发生改变，则后续比较版本号不一致将会导致库存有剩余却不能继续进行下去)。 Lua 是一个小巧的脚本语言，Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。 很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。 将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。 LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。 但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。 利用lua脚本淘汰用户，解决超卖问题。 redis 2.6版本以后，通过lua脚本解决争抢问题，实际上是redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题。 lua脚本： 12345678910111213141516local userid=KEYS[1]; local prodid=KEYS[2];local qtkey=\"sk:\"..prodid..\":qt\";local usersKey=\"sk:\"..prodid.\":usr'; local userExists=redis.call(\"sismember\",usersKey,userid);if tonumber(userExists)==1 then return 2;endlocal num= redis.call(\"get\" ,qtkey);if tonumber(num)&lt;=0 then return 0; else redis.call(\"decr\",qtkey); redis.call(\"sadd\",usersKey,userid);endreturn 1; 将普通核心函数Seckill_redis类改为带有lua脚本的SecKill_redisByScript类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.itnxd.redis_seckill_demo;import java.io.IOException;import java.util.HashSet;import java.util.Set;import org.slf4j.LoggerFactory;import redis.clients.jedis.HostAndPort;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;public class SecKill_redisByScript { private static final org.slf4j.Logger logger = LoggerFactory.getLogger(SecKill_redisByScript.class) ; public static void main(String[] args) { JedisPool jedispool = JedisPoolUtil.getJedisPoolInstance(); Jedis jedis=jedispool.getResource(); System.out.println(jedis.ping()); Set&lt;HostAndPort&gt; set=new HashSet&lt;HostAndPort&gt;(); doSecKill(\"201\",\"sk:0101\"); } static String secKillScript =\"local userid=KEYS[1];\\r\\n\" + \"local prodid=KEYS[2];\\r\\n\" + \"local qtkey='sk:'..prodid..\\\":qt\\\";\\r\\n\" + \"local usersKey='sk:'..prodid..\\\":usr\\\";\\r\\n\" + \"local userExists=redis.call(\\\"sismember\\\",usersKey,userid);\\r\\n\" + \"if tonumber(userExists)==1 then \\r\\n\" + \" return 2;\\r\\n\" + \"end\\r\\n\" + \"local num= redis.call(\\\"get\\\" ,qtkey);\\r\\n\" + \"if tonumber(num)&lt;=0 then \\r\\n\" + \" return 0;\\r\\n\" + \"else \\r\\n\" + \" redis.call(\\\"decr\\\",qtkey);\\r\\n\" + \" redis.call(\\\"sadd\\\",usersKey,userid);\\r\\n\" + \"end\\r\\n\" + \"return 1\" ; static String secKillScript2 = \"local userExists=redis.call(\\\"sismember\\\",\\\"{sk}:0101:usr\\\",userid);\\r\\n\" + \" return 1\"; public static boolean doSecKill(String uid,String prodid) throws IOException { JedisPool jedispool = JedisPoolUtil.getJedisPoolInstance(); Jedis jedis=jedispool.getResource(); //String sha1= .secKillScript; String sha1= jedis.scriptLoad(secKillScript); Object result= jedis.evalsha(sha1, 2, uid,prodid); String reString=String.valueOf(result); if (\"0\".equals( reString ) ) { System.err.println(\"已抢空！！\"); }else if(\"1\".equals( reString ) ) { System.out.println(\"抢购成功！！！！\"); }else if(\"2\".equals( reString ) ) { System.err.println(\"该用户已抢过！！\"); }else{ System.err.println(\"抢购异常！！\"); } jedis.close(); return true; }} ¶九、Redis持久化之RDB 所谓持久化：是指在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。 ¶1、RDB持久化流程 Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程 在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术” 一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。 ¶2、RDB配置 在redis.conf中进行一些配置！ 修改后需要重启Redis！ 直接kill redis进程不会进行持久化操作，建议redis-cli中进行shutdown操作！ dbfilename：默认为dump.rdb dir：rdb文件保存位置，默认为./当前目录（启动redis-cli的目录） save [seconds] [changes]：表示在多少秒内至少有多少个数据发生改变时进行持久化操作，save时只管保存，其它不管，全部阻塞。手动保存。不建议。也可以直接在redis-cli中直接运行！ RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件， 默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。 禁用，不设置save指令，或者给save传入空字符串 动态停止RDB：redis-cli config set save \"\" save后给空值，表示禁用保存策略 bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。直接在redis-cli中直接运行。 lastsave：获取最后一次成功执行快照的时间。 flushall命令：也会产生dump.rdb文件，但里面是空的，无意义 stop-writes-on-bgsave-erro：当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes. rdbcompression：压缩文件，对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes. rdbchecksum：检查完整性，在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。推荐yes. ¶3、RDB备份与恢复 先通过config get dir查询rdb文件的目录 将*.rdb的文件拷贝到别的地方 cp dump.rdb dump.rdb.bak rdb的恢复 关闭Redis，redis-cli-&gt;shutdown 先把备份的文件拷贝到工作目录下 cp dump.rdb.bak dump.rdb 启动Redis, 备份数据会直接加载 ¶4、优缺点 优点： 适合大规模的数据恢复 对数据完整性和一致性要求不高更适合使用 节省磁盘空间 恢复速度快 缺点： Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑 虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。 在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。 ¶十、Redis持久化之AOF 以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 ¶1、AOF持久化流程 客户端的请求写命令会被append追加到AOF缓冲区内； AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中； AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量； Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的； Rewrite重写： 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof。 重写原理： AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。 no-appendfsync-on-rewrite： yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能） no, 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低） 触发机制： Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。 重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。 auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发） auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。 重写流程： bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。 主进程fork出子进程执行重写操作，保证主进程不会阻塞。 子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。 子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。主进程把aof_rewrite_buf中的数据写入到新的AOF文件。 使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。 ¶2、AOF配置 在redis.conf配置AOF开启！ appendonly：默认没有开启，改为yes开启 appendfilename：AOF文件名，默认为 appendonly.aof AOF文件的保存路径，同RDB的路径一致。 appendfsync：同步频率 always：始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好 everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。 no：redis不主动进行同步，把同步时机交给操作系统。 注意：AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失） ¶3、AOF备份与恢复 AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。 正常恢复： 修改默认的appendonly no，改为yes （重启redis生效） 将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir) 恢复：重启redis重新加载 异常恢复： 修改默认的appendonly no，改为yes 如遇到AOF文件损坏，通过/usr/local/bin/redis-check-aof--fix appendonly.aof进行恢复 备份被写坏的AOF文件 恢复：重启redis重新加载 ¶4、优缺点 优点： 备份机制更稳健，丢失数据概率更低。 可读的日志文本，通过操作AOF稳健，可以处理误操作。 缺点： 比起RDB占用更多的磁盘空间。 恢复备份速度要慢。 每次读写都同步的话，有一定的性能压力。 存在个别Bug，造成恢复不能。 ¶5、两种持久化使用建议 官方推荐两个都启用。 如果对数据不敏感，可以选单独用RDB。 不建议单独用 AOF，因为可能会出现Bug。 如果只是做纯内存缓存，可以都不用。 性能建议： 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。 如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。 代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。 只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。 默认超过原大小100%大小时重写可以改到适当的数值。 ¶十一、Redis的主从复制 主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主。 读写分离，性能扩展 容灾快速恢复 ¶1、主从复制配置 以一主两从为例！ 拷贝三份redis.conf文件，分别重命名为redis+port.conf 文件内容如下： 使用include引入公共配置文件 指定pidfile文件名 指定端口 指定rdb文件名 开启daemonize后台自启 Log文件名字（可选） 关掉aof，Appendonly1/ slave-priority：设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100 启动三台Redis，redis-server redis6370.conf，其他两台类似 可使用ps -ef | grep reids查看进程 进入cli后执行info replication查看主从关系 三个配置文件内容如下，修改相应的端口即可！ 1234include /myredis/redis.confpidfile /var/run/redis_6379.pidport 6379dbfilename dump6379.rdb 主从配置： 在两台从机上执行slaveof 127.0.0.1 6379指定他们的主机为6379端口的Redis. 可使用info replication查看主从关系 主机可以进行写操作，从机不可以，只可以进行读操作 ¶2、三种情况 ¶2.1、一主二仆 主机挂掉重启即可，会恢复正常 从机挂掉需要使用命令slaveof 127.0.0.1 6379重新建立主从关系，只有从机还是只能读不能写 ¶2.2、薪火相传 上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。 用 slaveof &lt;ip&gt;&lt;port&gt;中途变更转向，会清除之前的数据，重新建立拷贝最新的 风险是一旦某个slave宕机，后面的slave都没法备份，主机挂了，从机还是从机，无法写数据了 ¶2.3、反客为主 当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。 用 slaveof no one 将从机变为主机。（手动模式） ¶3、哨兵模式 反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库！ 调整为一主二仆模式，6379带着6380、6381 自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错 配置哨兵配置文件，填写内容sentinel monitor mymaster 127.0.0.1 6379 1 其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。 可以以多搞几个哨兵，当哨兵都认为主机死了，再进行主从转换！ 启动哨兵：cd /usr/local/bin下，执行redis-sentinel /myredis/sentinel.conf（哨兵默认端口26379，前台启动） 当主机挂掉，从机会根据优先级slave-priority选择一个从机作为主机（前台大概10秒左右可以看到哨兵窗口日志，切换了新的主机） 原主机重启后会变为从机。 ¶4、故障恢复 哨兵模式就是用来做故障恢复的！ 优先级在redis.conf中默认：slave-priority 100（新版为replica-priority），值越小优先级越高 偏移量是指获得原主机数据最全的 每个redis实例启动后都会随机生成一个40位的runid ¶5、主从复制代码实现 123456789101112131415161718192021private static JedisSentinelPool jedisSentinelPool=null;public static Jedis getJedisFromSentinel(){ if(jedisSentinelPool==null){ Set&lt;String&gt; sentinelSet=new HashSet&lt;&gt;(); sentinelSet.add(\"192.168.11.103:26379\"); JedisPoolConfig jedisPoolConfig =new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(10); //最大可用连接数 jedisPoolConfig.setMaxIdle(5); //最大闲置连接数 jedisPoolConfig.setMinIdle(5); //最小闲置连接数 jedisPoolConfig.setBlockWhenExhausted(true); //连接耗尽是否等待 jedisPoolConfig.setMaxWaitMillis(2000); //等待时间 jedisPoolConfig.setTestOnBorrow(true); //取连接的时候进行一下测试 ping pong jedisSentinelPool=new JedisSentinelPool(\"mymaster\",sentinelSet,jedisPoolConfig); return jedisSentinelPool.getResource(); }else{ return jedisSentinelPool.getResource(); }} ¶6、复制原理 一次完全同步，多次增量同步！ Slave启动成功连接到master后会发送一个sync命令 Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步 但是只要是重新连接master,一次完全同步（全量复制)将被自动执行 当然，一主多从的复制操作会导致大量的延时： 由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。 ¶十二、Redis的集群管理 ¶1、集群的引入 问题？ 容量不够，redis如何进行扩容？ 并发写操作， redis如何分摊？ 另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。 之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。 代理主机：三组主从，加代理服务器的主从，一共需要八台服务器！ 无中心化集群：只需要六台服务器 什么是集群？ Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。 Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。 ¶2、集群的配置 以三组主从为例！ 一个集群至少要有三个主节点。 每个主节点至少一台从节点，即集群至少需要六台服务器！ 选项 --cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。 分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。 将持久化文件rdb,aof文件都删除掉。 在主从配置文件里增加如下： cluster-enabled yes：打开集群模式 cluster-config-file nodes-6379.conf：设定节点配置文件名 cluster-node-timeout 15000：设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。 再复制五份文件，将带有端口的全部修改，可使用vim全局替换命令:%s/6379/6380 启动六台redis-server 将六个节点合成一个集群，组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。 cd /opt/redis-6.2.5/src，执行redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391 前三台为主机，后三台为从机 注意：使用云服务器需要开启各个端口，https://www.jianshu.com/p/250f5da36b49/ 此处不要用127.0.0.1， 请用真实IP地址 --cluster-replicas 1， 采用最简单的方式配置集群，一台主机，一台从机，正好三组。(1表示从机数量) 在主从基础上添加如下配置： 1234567891011121314151617include /myredis/redis.confpidfile \"/var/run/redis6379.pid\"port 6379dbfilename \"dump6379.rdb\"# 增加配置cluster-enabled yescluster-config-file \"nodes-6379.conf\"cluster-node-timeout 15000# Generated by CONFIG REWRITEdaemonize yesprotected-mode nosave 3600 1save 300 100save 60 10000user default on nopass ~* &amp;* +@alldir \"/myredis\" 示例图： ¶3、集群操作 **注意：**普通方式登录，可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。 采用集群策略连接，设置数据会自动切换到相应的写主机。 cluster nodes 命令查看集群信息，可看到主从关系！ 什么是slots？ 一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。 集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中： 节点 A 负责处理 0 号至 5460 号插槽。 节点 B 负责处理 5461 号至 10922 号插槽。 节点 C 负责处理 10923 号至 16383 号插槽。 在集群中录入值： 在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。 redis-cli客户端提供了 –c 参数实现自动重定向。 如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。 不在一个slot下的键值，是不能使用mget,mset等多键操作。 可以通过{}来定义组的概念（组名作为关键字计算哈希值），从而使key中{}内相同内容的键值对放到一个slot中去。 查询集群中的值： cluster keysinslot &lt;key&gt;：计算key对应的插槽值 cluster countkeysinslot &lt;slot&gt;：计算插槽值里有多少个key (只能看到自己主机插槽范围内内的数据) cluster getkeysinslot &lt;slot&gt; &lt;count&gt;：获取该插槽的n个key ¶4、故障恢复 主节点下线，附属的从节点变为主节点，当原主节点再次上线，他将作为现在主节点的从节点！（类似哨兵模式） 如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续? cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉 cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。 ¶5、集群代码实现 即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。 无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。 12345678910111213public class JedisClusterTest { public static void main(String[] args) { Set&lt;HostAndPort&gt;set =new HashSet&lt;HostAndPort&gt;(); set.add(new HostAndPort(\"192.168.31.211\",6379)); JedisCluster jedisCluster=new JedisCluster(set); // 或者 HostAndPort hostAndPort = new HostAndPort(“ip”, “port”); JedisCluster jedisCluster=new JedisCluster(hostAndPort); jedisCluster.set(\"k1\", \"v1\"); System.out.println(jedisCluster.get(\"k1\")); jedisCluster.close(); }} ¶6、集群优缺点 优点： 实现扩容 分摊压力 无中心配置相对简单 缺点： 多键操作是不被支持的 。 多键的Redis事务是不被支持的。lua脚本不被支持。 由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。 ¶十三、Redis的四大应用问题及解决 ¶1、缓存穿透 ¶1.1、问题描述 key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据库，从而可能压垮数据库。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。 ¶1.2、问题解决 一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。 **对空值缓存：**如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟 **设置可访问的名单（白名单）：**使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。 采用布隆过滤器：布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。 **进行实时监控：**当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务 ¶2、缓存击穿 ¶2.1、问题描述 key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。（一个key过期） ¶2.2、问题解决 key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。 **预先设置热门数据：**在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长 **实时调整：**现场监控哪些数据热门，实时调整key的过期时长 使用锁： 就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。 先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key 当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key； 当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。 ¶3、缓存雪崩 ¶3.1、问题描述 key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。（很多key过期） ¶3.2、问题解决 缓存失效时的雪崩效应对底层系统的冲击非常可怕！ **构建多级缓存架构：**nginx缓存 + redis缓存 +其他缓存（ehcache等） **使用锁或队列：**用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况 **设置过期标志更新缓存：**记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。 **将缓存失效时间分散开：**比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 ¶4、分布式锁 ¶4.1、问题描述 随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！ 分布式锁主流的实现方案： 基于数据库实现分布式锁 基于缓存（Redis等） 基于Zookeeper redis性能最高，zookeeper可靠性最高！ ¶4.2、使用redis实现分布式锁 Redis命令： set key value NX|XX PX|EX .. EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。 PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。 NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。 XX ：只在键已经存在时，才对键进行设置操作。 分布式锁实现及其几大优化： 使用setnx设置锁，del释放锁 优化之设置锁的过期时间，自动释放锁，为了防止上锁后出现问题无法设置锁过期时间，建议使用set lock nx ex ... 优化之UUID防误删，删除前判断本次UUID是否发生改变，以防释放其他人的锁 优化之LUA脚本保证删除的原子性，以防由于不具备原子性，比较了UUID正要删除时，出现问题，将会再次出现释放其他人的锁 不设置UUID可能误释放其他人： 删除操作不是原子性也会误释放其人人： ¶4.3、代码实现 使用了UUID和设置了锁过期时间的代码： 1234567891011121314151617181920212223242526272829303132@GetMapping(\"testLock\")public void testLock(){ String uuid = UUID.randomUUID().toString(); //1获取锁，setnx Boolean lock = redisTemplate.opsForValue().setIfAbsent(\"lock\", uuid,3, TimeUnit.SECONDS); //2获取锁成功、查询num的值 if(lock){ Object value = redisTemplate.opsForValue().get(\"num\"); //2.1判断num为空return if(StringUtils.isEmpty(value)){ return; } //2.2有值就转成成int int num = Integer.parseInt(value+\"\"); //2.3把redis的num加1 redisTemplate.opsForValue().set(\"num\", ++num); //2.4释放锁，del //判断比较uuid值是否一样 String lockUuid = (String)redisTemplate.opsForValue().get(\"lock\"); if(lockUuid.equals(uuid)) { redisTemplate.delete(\"lock\"); } }else{ //3获取锁失败、每隔0.1秒再获取 try { Thread.sleep(100); testLock(); } catch (InterruptedException e) { e.printStackTrace(); } }} 在上面基础上，使用了LUA脚本保证了原子性的最终版本： 锁过期同样释放不了锁，并不影响！ 注意： 真正落地不采用此方案，过期时间无法合理设置，集群不支持LUA脚本，常规考虑使用redssion和zookeeper解决，通常使用前者，后者还需要引入，成本过高！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 测试redis的分布式锁！@GetMapping(\"testLockLua\")public void testLockLua() { //1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中 String uuid = UUID.randomUUID().toString(); //2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！ String skuId = \"25\"; // 访问skuId 为25号的商品 100008348542 String locKey = \"lock:\" + skuId; // 锁住的是每个商品的数据 // 3 获取锁 Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid, 3, TimeUnit.SECONDS); // 第一种： lock 与过期时间中间不写任何的代码。 // redisTemplate.expire(\"lock\",10, TimeUnit.SECONDS);//设置过期时间 // 如果true if (lock) { // 执行的业务逻辑开始 // 获取缓存中的num 数据 Object value = redisTemplate.opsForValue().get(\"num\"); // 如果是空直接返回 if (StringUtils.isEmpty(value)) { return; } // 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！ int num = Integer.parseInt(value + \"\"); // 使num 每次+1 放入缓存 redisTemplate.opsForValue().set(\"num\", String.valueOf(++num)); /*使用lua脚本来锁*/ // 定义lua 脚本 String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\"; // 使用redis执行lua执行 DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(); redisScript.setScriptText(script); // 设置一下返回值类型 为Long // 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型， // 那么返回字符串与0 会有发生错误。 redisScript.setResultType(Long.class); // 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。 redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid); } else { // 其他线程等待 try { // 睡眠 Thread.sleep(1000); // 睡醒了之后，调用方法。 testLockLua(); } catch (InterruptedException e) { e.printStackTrace(); } }} LUA脚本介绍： ¶4.4、分布式锁四条件 为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件： 互斥性。在任意时刻，只有一个客户端能持有锁。 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。 加锁和解锁必须具有原子性。 ¶十四、Redis6新功能 ¶1、ACL ¶1.1、概述 Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。 在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ： 接入权限:用户名和密码 可以执行的命令 可以操作的 KEY ¶1.2、常用命令 acl list：命令展现用户权限列表 acl cat：命令查看添加权限指令类别 加参数类型名可以查看类型下具体命令，eg：acl cat string acl whoami：命令查看当前用户 auth 用户 密码 ：切换用户，验证权限。切换回默认default用户：auth default \"\" ¶1.3、ACL规则 使用acl setuser命令创建和编辑用户ACL！ acl setuser user 不指定任何规则。如果用户不存在，这将使用just created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。 acl setuser user2 on &gt;password ~cached:* +get：设置有用户名、密码、ACL权限、并启用的用户 下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。 ¶2、IO多线程 ¶2.1、概述 Redis6终于支撑多线程了，告别单线程了吗？ IO多线程其实指客户端交互部分的网络IO交互处理模块多线程，而非执行命令多线程。Redis6执行命令依然是单线程。 ¶2.2、实现原理 Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。**Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。**之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。 多线程IO默认也是不开启的，需要再配置文件中配置： io-threads-do-reads yes io-threads 4 ¶3、工具支持Cluster 之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。 ¶4、其他新功能 RESP3新的 Redis 通信协议：优化服务端与客户端之间通信 Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。 Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。 Modules API：Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"非关系型数据库","slug":"数据库/非关系型数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.itnxd.cn/tags/Redis/"},{"name":"RDB","slug":"RDB","permalink":"https://www.itnxd.cn/tags/RDB/"},{"name":"AOF","slug":"AOF","permalink":"https://www.itnxd.cn/tags/AOF/"},{"name":"集群","slug":"集群","permalink":"https://www.itnxd.cn/tags/%E9%9B%86%E7%BE%A4/"}],"author":"ITNXD"},{"title":"Shell编程学习总结","slug":"Shell编程学习总结","date":"2021-05-10T03:10:00.000Z","updated":"2021-05-10T05:52:34.160Z","comments":true,"path":"posts/6952.html","link":"","permalink":"https://www.itnxd.cn/posts/6952.html","excerpt":"","text":"¶一、概述 Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序！ ¶1、第一个Shell脚本 脚本以#!/bin/bash 开头：指明使用的是Bash Shell 脚本需要有可执行权限 vim hello.sh： 12#!/bin/bashecho \"hello,world~\" ¶2、Shell脚本执行 方式一：赋予脚本x可执行权限chmod u+x xx.sh，然后直接./xxx.sh执行 方式二：直接使用命令：sh xx.sh执行 ¶二、Shell变量 ¶1、概述 Linux Shell 中的变量分为，系统变量和用户自定义变量。 系统变量：$HOME、$PWD、$SHELL、$USER 等等，比如： echo $HOME 显示当前 shell 中所有变量：set ¶2、shell 变量的定义 定义变量及撤销变量： 定义变量：变量名=值 撤销变量：unset 变量 声明静态变量：readonly 变量。注意：不能 unset 将命令的返回值赋给变量： 12A=`date` #反引号，运行里面的命令，并把结果返回给变量 AA=$(date) #等价于反引号 定义变量的规则： 变量名称可以由字母、数字和下划线组成，但是不能以数字开头 等号两侧不能有空格 变量名称一般习惯为大写， 这是一个规范，我们遵守即可 注释： 12345# 单行注释# 多行注释:&lt;&lt;!我是注释! 几个例子： 12345678910111213141516171819202122232425262728#!/bin/bash# 案例 1：定义变量 AA=100echo $Aecho A=$Aecho \"A=$A\"# 案例 2：撤销变量 Aunset Aecho A=$A# 案例 3：声明静态的变量 B=2，不能 unsetreadonly B=2echo \"B=$B\"# unset B# 将指令返回的结果赋给变量 使用``或$()C=`date`echo $CD=$(date)echo $D# 使用环境变量TOMCAT_HOMEecho \"tomcat_home=$TOMCAT_HOME\"# 多行注释:&lt;&lt;!我是注释!echo \"test commont!\" ¶3、设置环境变量 这个环境变量的作用域是全局的，谁都可以调用！ 环境变量配置文件地址：/etc/profile export 变量名=变量值：将 shell 变量输出为环境变量/全局变量 source 配置文件：让修改后的配置信息立即生效 echo $变量名：查询环境变量的值 例子： 12# 定义一个环境变量 /etc/profile文件export TOMCAT_HOME=/opt/tomcat ¶4、位置参数变量 当我们执行一个 shell 脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量！ $n：n 为数字，$0 代表命令本身，$1-$9 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10} $*：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体 $@：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待 $#：这个变量代表命令行中所有参数的个数 sh内容： 12345#!/bin/bashecho \"0=$0 1=$1 2=$2\"echo \"所有的参数=$*\"echo \"$@\"echo \"参数的个数=$#\" 运行结果： 12345[root@itnxd100 shell]# ./myshell.sh 1 2 3 40=./myshell.sh 1=1 2=2所有的参数=1 2 3 41 2 3 4参数的个数=4 ¶5、预定义变量 shell 设计者事先已经定义好的变量，可以直接在 shell 脚本中使用！ $$：当前进程的进程号（PID） $!：后台运行的最后一个进程的进程号（PID） $?：最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一个命令正确执行；如果这个变量的值为非 0，则证明上一个命令执行不正确了。 sh文件： 1234567#!/bin/bashecho \"当前执行的进程的pid=$$\"# 以后台的方式运行一个脚本，并获取他的进程号# 控制台执行preVal.sh会卡在下方的命令，不在一个shell中，会死循环/home/shell/myshell.sh &amp;echo \"最后一个后台方式运行的进程pid=$!\"echo \"执行的结果是=$?\" ¶三、运算符 \"$((运算式))\"或\"$[运算式]\"或者 expr m + n，expression 表达式 注意 expr 运算符间要有空格, 如果希望将 expr 的结果赋给某个变量，使用反引号 expr \\*,/, % ：乘（需要斜杠转义），除，取余 例子： 123456789101112131415#!/bin/bash#案例 1：计算（2+3）X4 的值RES1=$(((2+3)*4))echo \"res1=$RES1\"#使用[] 推荐RES2=$[(2+3)*4]echo \"res2=$RES2\"#使用expr 运算符之间要有空格,不加空格就成为了整体，类似于字符串TEMP=`expr 2 + 3`RES4=`expr $TEMP \\* 4` #乘法需要转义 echo “temp=$TEMP”echo \"res4=$RES4\"#案例 2：请求出命令行的两个参数[整数]的和 20 50SUM=$[$1+$2]echo \"sum=$SUM\" ¶四、条件&amp;流程 ¶1、条件判断 语法： [ condition ]（注意 condition 前后要有空格，非空返回 true，可使用$?验证） 123[ hspEdu ] #返回 true[ ] #返回 false[ condition ] &amp;&amp; echo OK || echo notok #条件满足，执行后面的语句 运算符： = 字符串比较 两个整数的比较 -lt 小于 -le 小于等于 little equal -eq 等于 -gt 大于 -ge 大于等于 -ne 不等于 按照文件权限进行判断 -r 有读的权限 -w 有写的权限 -x 有执行的权限 按照文件类型进行判断 -f 文件存在并且是一个常规的文件 -e 文件存在 -d 文件存在并是一个目录 例子： 1234567891011121314151617181920if [ \"ok\" = \"ok\" ]then echo \"equal\"fiif [ 23 -ge 22 ]then echo \"大于\"fiif [ -f /home/shell/aaa.txt ]then echo \"存在\"fi# []表示空值为假时，同样需要两个空格if [ itnxd ]then echo \"为假\"fi ¶2、流程控制 ¶2.1、if 语法： 123456789101112if [ 条件判断式 ]then代码fi或者 , 多分支if [ 条件判断式 ]then代码elif [条件判断式]then代码fi 注意：[ 条件判断式 ]，中括号和条件判断式之间必须有空格 例子： 123456789#!/bin/bash# 如果输入的参数，大于等于 60，则输出 \"及格了\"，如果小于 60,则输出 \"不及格\"if [ $1 -ge 60 ]then echo \"及格了\"elif [ $1 -lt 60]then echo \"不及格\"fi ¶2.2、case 语法： 123456789101112case $变量名 in\"值 1\"）如果变量的值等于值 1，则执行程序 1;;\"值 2\"）如果变量的值等于值 2，则执行程序 2;;…省略其他分支…*)如果变量的值都不是以上的值，则执行此程序;;esac 例子： 12345678910111213#!/bin/bash# 当命令行参数是 1 时，输出 \"周一\", 是 2 时，就输出\"周二\"， 其它情况输出 \"other\"case $1 in\"1\")echo \"周一\";;\"2\")echo \"周二\";;*)echo \"other...\";;esac ¶2.3、for 语法： 12345678910for 变量 in 值 1 值 2 值 3…do程序/代码done# 或for (( 初始值;循环控制条件;变量变化 ))do程序/代码done 例子： 12345678910111213141516171819202122232425#!/bin/bash# 例子一# $*将输入的参数当做一个整体，以下只执行一次for i in \"$*\"do echo \"num is $i\"doneecho \"===============================\"# $@获取输入参数，分别对待，执行多次for i in \"$@\"do echo \"num is $i\"done# 例子二SUM=0for (( i=1; i &lt;= $1; i++ ))do SUM=$[$SUM+$i]doneecho \"总和sum=$SUM\" ¶2.4、while 语法： 12345while [ 条件判断式 ]do程序 /代码done注意：while 和 [有空格，条件判断式和 [也有空格 例子： 1234567891011#!/bin/bashSUM=0i=0while [ $i -le $1 ]do SUM=$[$SUM+$i] i=$[$i+1]doneecho \"sum=$SUM\" ¶五、read读取输入 可以处理控制台输入！ 语法： read(选项)(参数) 选项： -p：指定读取值时的提示符； -t：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了 参数：变量，指定读取值的变量名 例子： 1234567#!/bin/bashread -p \"请输入一个数NUM1=\" NUM1echo \"输入的NUM1=$NUM1\"read -t 10 -p \"请输入一个数NUM2=\" NUM2echo \"输入的NUM2=$NUM2\" ¶六、函数 ¶1、系统函数 basename [pathname] [suffix]：返回完整路径最后 / 的部分，常用于获取文件名 suffix 为后缀：如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉 dirname 文件绝对路径：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分），常用于获取路径 例子： 12345[root@itnxd100 shell]# basename /home/aaa/test.txtest.tx[root@itnxd100 shell]# dirname /home/aaa/test.txt/home/aaa[root@itnxd100 shell]# ¶2、自定义函数 语法： 123456[ function ] funname[()]{Action;[return int;]}调用直接写函数名：funname [值] 例子： 123456789101112#!/bin/bashfunction getSum(){ SUM=$[$n1+$n2] echo \"和是=$SUM\"}read -p \"请输入一个数n1=\" n1read -p \"请输入一个数n2=\" n2getSum $n1 $n2 ¶七、案例 一个数据库备份案例： 每天凌晨 2:30 备份 数据库 itnxd 到 /data/backup/db 备份开始和备份结束能够给出相应的提示信息 备份后的文件要求以备份时间为文件名，并打包成 .tar.gz 的形式，比如：2021-03-12_230201.tar.gz 在备份的同时，检查是否有 10 天前备份的数据库文件，如果有就将其删除。 /usr/sbin/mysql_db.backup.sh代码： 12345678910111213141516171819202122232425262728293031323334#!/bin/bash# 备份目录BACKUP=/data/backup/db# 当前时间DATETIME=$(date +%Y-%m-%d_%H%M%S)echo $DATETIME# 数据库地址HOST=localhost# 数据库用户名DB_USER=root# 数据库密码DB_PW=xxxxx# 要备份的数据库名DATABASE=itnxd# 创建备份目录，如果不存在就创建[ ! -d \"${BACKUP}/${DATETIME}\" ] &amp;&amp; mkdir -p \"${BACKUP}/${DATETIME}\"# 备份数据库mysqldump -u${DB_USER} -p${DB_PW} --host=${HOST} -q -R --databases ${DATABASE} | gzip &gt; ${BACKUP}/${DATETIME}/$DATETIME.sql.gz# 将文件处理称成tar.gzcd ${BACKUP}tar -zcvf $DATETIME.tar.gz ${DATETIME}# 删除对应的备份目录rm -rf ${BACKUP}/${DATETIME}# 删除十天前的备份文件find ${BACKUP} -atime +10 -name \"*.tar.gz\" -exec rm -rf {} \\;echo \"备份数据库${DATABASE}成功！\" 使用crond添加定时任务： 1234[root@VM-8-2-centos db]# crontab -l*/5 * * * * flock -xn /tmp/stargate.lock -c '/usr/local/qcloud/stargate/admin/start.sh &gt; /dev/null 2&gt;&amp;1 &amp;'30 2 * * * /usr/sbin/mysql_db_backup.sh document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Shell","slug":"Shell","permalink":"https://www.itnxd.cn/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://www.itnxd.cn/tags/Shell/"}],"author":"ITNXD"},{"title":"Linux使用及JavaEE环境搭建","slug":"Linux使用及JavaEE环境搭建","date":"2021-05-07T01:35:41.000Z","updated":"2021-09-04T13:02:11.121Z","comments":true,"path":"posts/58036.html","link":"","permalink":"https://www.itnxd.cn/posts/58036.html","excerpt":"","text":"以Centos7.6为主讲解，后面会有Ubuntu不同之处的单独讲解！ ¶一、Linux目录结构 linux 的文件系统是采用层级式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。 记住一句经典的话：在 Linux 世界里，一切皆文件! /bin [常用] (/usr/bin 、 /usr/local/bin)：是 Binary 的缩写, 这个目录存放着最经常使用的命令 /sbin (/usr/sbin 、 /usr/local/sbin)：s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。 /home [常用]：存放普通用户的，在 Linux 中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名 /root [常用]：该目录为系统管理员，也称作超级权限者的用户主目录 /lib：系统开机所需要最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件 /etc [常用]：所有的系统管理所需要的配置文件和子目录, 比如安装 mysql 数据库 my.conf /usr [常用]：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与 windows 下的 program files 目录。 /boot [常用]：存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件 /proc [不能动]：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息 /srv [不能动]：service 缩写，该目录存放一些服务启动之后需要提取的数据 /sys [不能动]：这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs /tmp：这个目录是用来存放一些临时文件的 /dev：类似于 windows 的设备管理器，把所有的硬件用文件的形式存储 /media [常用]：linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下 /mnt [常用]：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了 /opt：这是给主机额外安装软件所存放的目录。如安装 ORACLE 数据库就可放到该目录下。默认为空 /usr/local [常用]：这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序 /var [常用]：这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件 /selinux [security-enhanced linux]：SELinux 是一种安全子系统,它能控制程序只能访问特定文件, 有三种工作模式，可以自行设置. ¶二、Vi和Vim编辑器 Linux 系统会内置 Vi 文本编辑器！ Vim 具有程序编辑的能力，可以看做是 Vi 的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补全、编译及错误跳转等功能！ ¶1、三种模式 一般模式：默认模式，可使用上下左右键，可使用复制粘贴，删除整行，删除字符快捷键进行操作！ yy：拷贝当前行，拷贝当前行向下的 5 行 5yy p：粘贴 dd：删除当前行，删除当前行向下的 5 行 5dd G：最末行 gg：最首行 u：撤销插入模式的操作 Shift+g：跳转到指定行，输入行号，再输入 Shift+g 插入模式：按下 i, I, o, O, a, A, r, R 等任何一个字母之后才会进入编辑模式, 一般来说按 i 即可！ 命令行模式：输入 esc 再输入:在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的！ wq：保存退出 q：退出（打开但并未编辑时可用） q!：强制退出，不保存（打开进行了编辑时可用） /关键字：回车查找 , 输入 n 就是查找下一个 :set nu 和 :set nonu：设置和取消行号 ¶2、三种模式转换图 ¶三、开关机&amp;重启&amp;登录&amp;注销 ¶1、关机 &amp; 重启 不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中！ 目前的 shutdown/reboot/halt 等命令均已经在关机前进行了 sync！但建议手动运行一次！ shutdown –h now 立该关机 shudown -h 1 “hello, 1 分钟后会关机了” shutdown –r now 立刻重启！ halt 关机 reboot 重启 sync 把内存的数据同步到磁盘 ¶2、用户登录注销 登录时尽量少用 root 帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用 su - 用户名 命令来切换成系统管理员身份！ 在提示符下输入 logout 即可注销用户！ logout 注销指令在图形运行级别无效，在运行级别 3 下有效！ ¶四、用户管理 ¶1、添加用户 该用户家目录默认位于/home/xxx useradd 用户名：创建用户 useradd -d 目录 用户名：指定家目录 useradd –g 用户组 用户名：指定组 为添加用户设置密码：passwd 用户名 ¶2、删除用户 userdel 用户名：删除用户，但保留家目录 userdel -r 用户名：删除用户，且不保留家目录 ¶3、查询用户 返回用户id，组id，组名（默认组名为用户名） id 用户名 12[root@VM-8-2-centos ~]# id itnxduid=1001(itnxd) gid=1001(itnxd) groups=1001(itnxd) ¶4、切换用户 从权限高的用户切换到权限低的用户，不需要输入密码，反之需要！ 当需要返回到原来用户时，使用 exit/logout 指令！ su - 用户名 ¶5、查看当前登录用户 whoami 或 who am i ¶6、用户组 系统可以对有共性/权限的多个用户进行统一的管理！ groupadd 组名：创建组 groupdel 组名：删除组 useradd –g 用户组 用户名：为创建用户指定组 usermod –g 用户组 用户名：为指定用户修改组 usermod –d 目录 用户名：为指定用户修改家目录 ¶7、用户和组相关配置文件 /etc/passwd 文件：记录用户的各种信息。 每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell /etc/shadow 文件：口令的配置文件。 每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 /etc/group 文件：组(group)的配置文件，记录 Linux 包含的组的信息 每行含义：组名:口令:组标识号:组内用户列表 ¶五、实用指令 ¶1、运行级别 常用运行级别是 3 和 5 ，也可以指定默认运行级别！ 通过 init 命令来切换不同的运行级别。例如：init 0：关机。 0 ：关机 1 ：单用户【找回丢失密码】 2：多用户状态没有网络服务 3：多用户状态有网络服务 4：系统未使用保留给用户 5：图形界面 6：系统重启 centos7 之后的区别： 在 centos7 以前，在/etc/inittab 文件中！ 在 centos7 之后，简化为如下： 123456multi-user.target: analogous to runlevel 3graphical.target: analogous to runlevel 5# To view current default target, run:systemctl get-default# To set a default target, run:systemctl set-default TARGET.target ¶2、帮助指令 man 命令：获得帮助信息 help 命令：获得 shell 内置命令的帮助信息 ¶3、文件目录指令 pwd：获取当前目录绝对路径 ls [选项] [目录]：查看指定目录下详细信息（默认为当前目录） -a ：显示当前目录所有的文件和目录，包括隐藏的 -l ：以列表的方式显示信息 -h：显示文件大小 cd cd ~ 或 cd：回到家目录 cd ..：回到上一层 mkdir [选项] 目录：创建目录 -p ：创建多级目录 rmdir [选项] 空目录：只能删除空目录 rm [选项] 目录或文件：删除目录或文件 -r：递归 -f：强制删除不提示 touch 文件名称：创建文件 cp [选项] source dest：拷贝文件到指定目录 -r ：递归 \\cp [选项] source dest：强制覆盖不提示 mv oldNameFile newNameFile：重命名 mv /temp/movefile /targetFolder：剪切 cat [选项] 文件名：查看文件内容 -n：显示行号 more 文件：是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容，一些交互指令： 空白键：翻页 Enter：下一行 q：退出more Ctrl + F：向下滚一屏 Ctrl + B：返回上一屏 =：显示当前行行号 :f：输出文件名和行号 less 文件：用来分屏查看文件内容，与 more 类似，但比 more 更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。 空白键：下翻一页 pageDown，pageUp：向下或向上翻一页 /字串：向下查找字串，n：向下，N：向上 ?字串：向上查找字串，n：向上，N：向下 q：退出less echo [选项] [输出内容]：输出内容到控制台 可以用来输出环境变量，$PATH $HOSTNAME 等 也可以用来输出字符串 head [选项] 文件：查看文件头 10 行内容（默认） -n x：查看文件头 x 行内容 tail [选项] 文件：查看文件尾 10 行内容（默认） -n x：查看文件尾 x 行内容 -f：实时追踪该文档的所有更新，Ctrl + z 退出！ 指令 &gt; 文件：输出重定向 指令 &gt;&gt; 文件：追加 ln -s [原文件或目录] [软链接名]：创建软连接，类似快捷键，删除软链接后面不需要加斜杠 history：查看已经执行过历史命令,也可以执行历史指令，默认显示所有，后面添加数字指定显示最近条数！ ¶4、时间日期类 cal [选项]：查看当前日历（默认本月）可加年份，显示整年 date：显示当前时间 date +%Y：显示当前年份 date +%m：显示当前月份 date +%d：显示当前是哪一天 date \"+%Y-%m-%d %H:%M:%S\"：显示年月日时分秒 date -s “年-月-日 时:分:秒”：设置日期时间 ¶5、搜索查找类 find [搜索范围] [选项]：从指定目录向下递归遍历查找 -name：指定文件名 -user：指定拥有者 -size：指定文件大小，+n 大于 -n 小于 n 等于, 单位有 k,M,G。eg：find / -size +200M locate 文件：可以快速定位文件路径。locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给定的文件。locate 指令无需遍历整个文件系统，查询速度较快 由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。 which 指令：查询某个指令在哪个目录下，eg：which ls grep [选项] 查找内容 源文件： -n：显示匹配行及行号 -i：忽略字母大小写 可直接使用：eg：grep -n “yes” /home/hello.txt 也可结合**管道符|**使用：eg：cat /home/hello.txt | grep “yes” 管道符|：前面得到的结果交给后面进一步处理！ ¶6、压缩解压类 gzip 文件：压缩，只能压缩文件 gunzip 文件.gz：解压 源文件不保留，可操作多个文件，空格隔开！ zip [选项] XXX.zip 压缩文件或目录：压缩，可以压缩文件和目录 -r：递归压缩 unzip [选项] XXX.zip：解压 -d：指定解压目录 源文件保留，可操作多个文件或目录，空格隔开 tar [选项] XXX.tar.gz 打包的内容：压缩文件或目录 -c：产生.tar文件 -v：显示详细信息 -f：指定压缩后文件名 -z：打包同时压缩 -x：解压.tar文件 一般：压缩为-zcvf，解压为-zxvf 几个案例： 1234567案例 1: 压缩多个文件，将 /home/pig.txt 和 /home/cat.txt 压缩成 pc.tar.gztar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt案例 2: 将/home 的文件夹 压缩成 myhome.tar.gztar -zcvf myhome.tar.gz /home/案例 3: 将 pc.tar.gz 解压到当前目录tar -zxvf pc.tar.gz案例4: 将myhome.tar.gz 解压到 /opt/tmp2目录下 (1) mkdir /opt/tmp2 (2) tar -zxvf /home/myhome.tar.gz -C /opt/tmp2 ¶六、组管理&amp;权限管理 在 linux 中的每个用户必须属于一个组，不能独立于组外！ 有所有者、所在组、其它组的概念！ ¶1、所有者 查看：ls -alh 修改：chown [选项] 用户名 文件名 -R：递归生效 ¶2、所在组 创建组：groupadd 组名 查看组：ls -alh 修改组：chgrp [选项] 组名 文件名 -R：递归生效 ¶3、其他组 除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组！ ¶4、改变用户所在组 usermod –g 新组名 用户名：改变用户所在组 usermod –d 目录名 用户名： 改变该用户登陆的初始目录。特别说明：用户需要有进入到新目录的权限 ¶5、权限 12ls -l 中显示的内容如下：-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc ¶5.1、权限的基本介绍 第 0 位确定文件类型(d, - , l , c , b) l 链接，软链接 d 目录 - 普通文件 c 字符设备文件，鼠标，键盘 b 块设备，比如硬盘 第 1-3 位确定所有者权限（User） 第 4-6 位确定所属组权限（Group） 第 7-9 位确定其他用户权限（Other） ¶5.2、rwx权限详讲 作用到文件： r：代表可读(read): 可以读取,查看 w：代表可写(write): 可以修改。但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限 x：代表可执行(execute):可以被执行 作用到目录： r：代表可读(read): 可以读取，ls 查看目录内容 w：代表可写(write): 可以修改, 对目录内创建+删除+重命名目录 x：代表可执行(execute):可以进入该目录 可用数字表示：r=4,w=2,x=1 因此 rwx=4+2+1=7 , 数字可以进行组合！ ¶5.3、修改权限 chmod： 方式一：+、-、= 变更权限（u:所有者 g:所有组 o:其他人 a:所有人(u、g、o 的总和)） 方式二：通过数字变更权限，r=4 w=2 x=1 几个例子： 1234chmod u=rwx,g=rx,o=x 文件/目录名chmod o+w 文件/目录名chmod a-x 文件/目录名chmod 751 文件/目录名 chown： chown newowner 文件/目录：改变所有者 chown newowner:newgroup 文件/目录：改变所有者和所在组 -R 如果是目录 则使其下所有子文件或目录递归生效 chgrp： chgrp newgroup 文件/目录：改变所在组 -R 如果是目录 则使其下所有子文件或目录递归生效 ¶七、定时任务调度 ¶1、cron任务调度 使用 crontab 指令进行定时任务的设置！ crontab [选项]： -e：编辑定时任务 -l：查询定时任务 -r：删除当前用户所有定时任务 五个*含义： 特殊符号： crond 相关指令： conrtab –r：终止任务调度 crontab –l：列出当前所有任务调度 service crond restart：重启任务调度 ¶2、at任务调度 at 命令是一次性定时计划任务，at 的守护进程 atd 会以后台模式运行，检查作业队列来运行。 默认情况下，atd 守护进程每 60 秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。 在使用 at 命令的时候，一定要保证 atd 进程的启动 , 可以使用相关指令来查看ps -ef | grep atd！ at [选项] [时间]：Ctrl + D 结束 at 命令的输入， 输出两次 atq：查看系统中没有执行的工作任务 atrm 编号：删除已设置任务 at 命令选项： at 指定时间的方法： 接受在当天的 hh:mm（小时:分钟）式的时间指定。假如该时间已过去，那么就放在第二天执行。 例如：04:00 使用 midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午 4 点）等比较模糊的词语来指定时间。 采用 12 小时计时制，即在时间后面加上 AM（上午）或 PM（下午）来说明是上午还是下午。 例如：12pm 指定命令执行的具体日期，指定格式为 month day（月 日）或 mm/dd/yy（月/日/年）或 dd.mm.yy（日.月.年），指定的日期必须跟在指定时间的后面。 例如：04:00 2021-03-1 使用相对计时法。指定格式为：now + count time-units ，now 就是当前时间，time-units 是时间单位，这里能够是 minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count 是时间的数量，几天，几小时。 例如：now + 5 minutes 直接使用 today（今天）、tomorrow（明天）来指定完成命令的时间。 举例： 1234[root@VM-8-2-centos ~]# at 5pm + 2daysat&gt; ls -alh &gt; /var/ls.log at&gt; &lt;EOT&gt;job 1 at Tue May 11 17:00:00 2021 ¶八、分区&amp;挂载 ¶1、分区 Linux 采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。 Linux 硬盘介绍： Linux 硬盘分 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘 对于 IDE 硬盘，驱动器标识符为“hdx~”,其中“hd”表明分区所在设备的类型，这里是指 IDE 硬盘了。“x”为盘号（a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘）,“~”代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。例，hda3 表示为第一个 IDE 硬盘上的第三个主分区或扩展分区,hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区。 对于 SCSI 硬盘则标识为“sdx~”，SCSI 硬盘是用“sd”来表示分区所在设备的类型的，其余则和 IDE 硬盘的表示方法一样 查看所有设备挂载情况：lsblk/lsblk -f 123456789101112131415161718192021[root@itnxd100 ~]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 20G 0 disk ├─sda1 8:1 0 1G 0 part /boot├─sda2 8:2 0 2G 0 part [SWAP]└─sda3 8:3 0 17G 0 part /sdb 8:16 0 20G 0 disk ├─sdb1 8:17 0 500M 0 part └─sdb2 8:18 0 19.5G 0 part sr0 11:0 1 1024M 0 rom [root@itnxd100 ~]# lsblk -fNAME FSTYPE LABEL UUID MOUNTPOINTsda ├─sda1 ext4 a94968fa-d434-4907-a724-f32d4168262f /boot├─sda2 swap 39420955-4d5f-4a55-b923-023ce46e3d33 [SWAP]└─sda3 ext4 d3673e81-472b-49fe-a4ea-0fa00fc5ca05 /sdb ├─sdb1 ext4 18da3c5d-3712-4197-a559-21934d2444ca └─sdb2 ext4 a1a5af2e-9111-4a82-b399-w sr0 ¶2、挂载 以VM虚拟机增加一块硬盘熟悉磁盘分区、挂载、卸载！ 虚拟机添加硬盘： 【虚拟机】菜单中，选择【设置】，然后设备列表里添加硬盘，然后一路【下一步】，中间只有选择磁盘大小的地方需要修改，至到完成。然后重启系统（才能识别） 第一块硬盘为sda，第二块硬盘为sdb，依次类推… 分区： fdisk /dev/sdb：将新添加的硬盘sdb进行分区 开始分区后输入 n，新增分区，然后选择 p ，分区类型为主分区。两次回车默认剩余全部空间。最后输入 w写入分区并退出，若不保存退出输入 q。 m 显示命令列表 p 显示磁盘分区 同 fdisk –l n 新增分区 d 删除分区 w 写入并退出 格式化： mkfs -t ext4 /dev/sdb1，ext4 是分区类型 **挂载：**将一个分区与一个目录联系起来 mount 设备名称 挂载目录：挂载，eg：mount /dev/sdb1 /newdisk umount 设备名称 或者 挂载目录：卸载，eg：umount /dev/sdb1 或者 umount /newdisk 注意：用命令行挂载,重启后会失效 设置可以自动挂载： 永久挂载：通过修改 /etc/fstab 实现挂载。添加一行映射如下： 添加完成后 执行 mount –a 即刻生效 ¶3、磁盘情况查询 df -h：查询系统整体磁盘使用情况 du [选项] [目录]：查询指定目录的磁盘占用情况，默认为当前目录 -s 指定目录占用大小汇总 -h 带计量单位 -a 含文件 –max-depth=1 子目录深度 -c 列出明细的同时，增加汇总值 ¶4、其他实用指令 wc -l：统计目录或文件数量，常用在管道|后面 tree [目录]：树状显示目录，需要yum install tree安装 几个例子： 123456781) 统计/opt 文件夹下文件的个数ls -l /opt | grep \"^-\" | wc -l2) 统计/opt 文件夹下目录的个数ls -l /opt | grep \"^d\" | wc -l3) 统计/opt 文件夹下文件的个数，包括子文件夹里的ls -lR /opt | grep \"^-\" | wc -l4) 统计/opt 文件夹下目录的个数，包括子文件夹里的ls -lR /opt | grep \"^d\" | wc ¶九、网络配置 ¶1、NAT网络配置原理图示 ¶2、配置固定 IP 地址 DHCP模式自动获取可能产生冲突，且工作中一定是一个固定地址！ 查看虚拟网络编辑器和修改子网 IP 地址192.168.x.0 修改网关IP地址192.168.x.2 查看 windows 环境的中 VMnet8 网络配置(ipconfig 指令)，为192.168.x.1 直接修改配置文件来指定 IP，指定IP为192.168.x.y，x与上面相同，y自己设定！ 123456789101112131415161718192021vim /etc/sysconfig/network-scripts/ifcfg-ens33ifcfg-ens33 文件说明DEVICE=eth0 #接口名（设备,网卡）HWADDR=00:0C:2x:6x:0x:xx #MAC 地址TYPE=Ethernet #网络类型（通常是 Ethemet）UUID=926a57ba-92c6-4231-bacb-f27e5e6a9f44 #随机 id# 修改下面两行，增加最后三行！#系统启动的时候网络接口是否有效（yes/no）ONBOOT=yes# IP 的配置方法[none|static|bootp|dhcp]（引导时不使用协议|静态分配 IP|BOOTP 协议|DHCP 协议）BOOTPROTO=static#IP 地址IPADDR=192.168.200.130#网关GATEWAY=192.168.200.2#域名解析器DNS1=192.168.200.2 重启网络服务或者重启系统生效，service network restart 、reboot 可使用ifconfig查看 IP 地址 Windows和Linux互ping检查连通性！ ¶3、主机名与Hosts映射 主机名： 查看主机名：hostname 修改主机名：vim /etc/hostname 指定，修改后，重启生效 Hosts映射： windows hosts 位置：C:\\Windows\\System32\\drivers\\etc\\hosts，eg：: 192.168.200.130 centos linux hosts 位置：/etc/hosts，eg：: 192.168.200.1 windows ¶十、进程管理 在 LINUX 中，每个执行的程序都称为一个进程。每一个进程都分配一个 ID 号(pid,进程号)。 每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。 一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束 ¶1、ps指令 ps：命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数。一般为ps -aux -a：显示当前终端的所有进程信息 -u：以用户的格式显示进程信息 -x：显示后台进程运行的参数 -e：显示所有进程 -f：全格式 ps –aux | grep xxx：使用管道符查看某个进程是否在服务 ps -ef：是以全格式显示当前所有的进程，可以查看进程的父进程PPID。 PPID：父进程 ID C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高 STIME：进程启动的时间 TTY：完整的终端名称 TIME：CPU 时间 CMD：启动进程所用的命令和参数 ps指令详解： System V 展示风格 USER：用户名称 PID：进程号 %CPU：进程占用 CPU 的百分比 %MEM：进程占用物理内存的百分比 VSZ：进程占用的虚拟内存大小（单位：KB） RSS：进程占用的物理内存大小（单位：KB） TTY：终端名称缩写 STAT：进程状态，其中 S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R- 正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等 STARTED：进程的启动时间 TIME：CPU 时间，即进程使用 CPU 的总时间 COMMAND：启动进程所用的命令和参数，如果过长会被截断显示 ¶2、kill指令 kill [选项] 进程号：通过进程号杀死/终止进程 -9：表示强迫进程立即停止 killall 进程名称：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用 ¶3、pstree指令 pstree [选项]：查看进程树！ -p :显示进程的 PID -u :显示进程的所属用户 ¶4、服务service管理 服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysqld , sshd防火墙等)，因此我们又称为守护进程！ 在 CentOS7.0 后 很多服务不再使用 service ,而是 systemct！ service 服务名 [start | stop | restart | reload | status] service 指令管理的服务在 /etc/init.d 查看：ls -l /etc/init.d setup：setup -&gt; 系统服务 就可以看到全部 tab键切换选择区域 空格键设置是否自启 回车键确认 chkconfig：给服务的各个运行级别设置自 启动/关闭，chkconfig 指令管理的服务在 /etc/init.d 查看。注意: Centos7.0 后，很多服务使用 systemctl 管理。（不重要） chkconfig --list [| grep xxx]：查看服务 chkconfig 服务名 --list chkconfig --level 5 服务名 on/off chkconfig 重新设置服务后自启动或关闭，需要重启机器 reboot 生效 systemctl [start | stop | restart | status] 服务名 systemctl 指令管理的服务在 /usr/lib/systemd/system 查看 systemctl list-unit-files [ | grep 服务名]：查看服务开机启动状态, grep 可以进行过滤 systemctl enable 服务名：设置服务开机启动 systemctl disable 服务名：关闭服务开机启动 systemctl is-enabled 服务名：查询某个服务是否是自启动的 ¶5、防火墙 可以在windows中使用telnet命令测试某端口是否通畅！ 打开端口: firewall-cmd --permanent --add-port=端口号/协议 关闭端口: firewall-cmd --permanent --remove-port=端口号/协议 重新载入,才能生效 : firewall-cmd --reload 查询端口是否开放: firewall-cmd --query-port=端口/协议 netstat -anp：显示详细端口及协议！ ¶6、动态监控进程 top 与 ps 命令很相似。它们都用来显示正在执行的进程。top 与 ps 最大的不同之处在于 top 在执行一段时间可以更新正在运行的的进程！ top [选项]： -d：指定秒数，默认3秒 -i：指定不显示闲置和僵尸进程 -p：指定进程id单独监控某个进程 top交互命令： P：按CPU使用率排序，默认 M：按内存使用率排序 N：按PID排序 u：输入用户名，监控特定用户 k：输入进程PID，杀掉特定进程 q：退出top ¶7、网络状态监控 可以用来查看防火墙端口及协议，也可查看详细的网络端口配置！ netstat [选项] -an：按一定顺序排列输出 -p：显示哪个进程在调用 eg：netstat -anp | grep sshd，查看sshd服务 ¶十一、RPM &amp; YUM ¶1、RPM RPM是 RedHat Package Manager（RedHat 软件包管理工具）的缩写！ 就是一个rpm后缀的安装包，可以使用rpm相关命令来安装和卸载！ rpm –qa | grep xx：查看是否安装xx rpm -qi 软件包名：查询软件包信息 rpm -ql 软件包名：查询软件包中的文件 rpm -qf 文件全路径名：查询文件所属的软件包 rpm -e 包名：卸载包 rpm -e --nodeps 包名：强制卸载，即使有依赖关系 rpm -ivh 包名：安装，一般将.rpm安装包移动到/opt目录下！ i=install：安装 v=verbo：提示 h=hash：进度条 rpm 包名基本格式： 123456一个 rpm 包名：firefox-60.2.2-1.el7.centos.x86_64名称:firefox版本号：60.2.2-1适用操作系统: el7.centos.x86_64表示 centos7.x 的 64 位系统如果是 i686、i386 表示 32 位系统，noarch 表示通用 ¶2、YUM Yum 是一个 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。 yum list | grep xx：查询xx软件 yum install xxx：下载安装xx ¶十二、Linux配置JavaEE环境 ¶1、安装JDK mkdir /opt/jdk 通过 xftp 上传到 /opt/jdk 下 cd /opt/jdk 解压 tar -zxvf jdk-8u261-linux-x64.tar.gz mkdir /usr/local/java mv /opt/jdk/jdk1.8.0_261 /usr/local/java 配置环境变量的配置文件 vim /etc/profile export JAVA_HOME=/usr/local/java/jdk1.8.0_261 export PATH=$JAVA_HOME/bin:$PATH source /etc/profile [让新的环境变量生效] 测试：java -version ¶2、安装Tomcat 以Tomcat8.5.65为例！ 上传安装文件，并解压缩到/opt/tomcat 进入解压目录/bin , 启动 tomcat ./startup.sh 开放端口 8080 firewall-cmd --permanent --add-port=8080/tcp：开放8080 firewall-cmd --reload：重载配置生效 firewall-cmd --query-port=8080/tcp：检测是否开放成功 测试：ip地址:8080 ¶3、安装Mysql 新建文件夹/opt/mysql，并cd进去 运行wget http://dev.mysql.com/get/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar，下载mysql安装包 运行tar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar 运行rpm -qa | grep mari，查询mariadb相关安装包（centos7.6自带的类mysql数据库是mariadb，会跟mysql冲突，要先删除。） 运行rpm -e --nodeps mariadb-libs，卸载 然后开始真正安装mysql，依次运行以下几条 1234rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpmrpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm 运行systemctl start mysqld.service，启动mysql 然后开始设置root用户密码，Mysql自动给root用户设置随机密码，运行grep \"password\" /var/log/mysqld.log可看到当前密码 运行mysql -u root -p，用root用户登录，提示输入密码可用上述的 设置root密码，对于个人开发环境，如果要设比较简单的密码（生产环境服务器要设复杂密码），可以运行set global validate_password_policy=0; 提示密码设置策略（validate_password_policy默认值1） 0：只要求长度 (默认8位) 1：要求数字、大小写、特殊字符组合 2：要求数字、大小写、特殊字符组合、字典文件组合 set password for 'root'@'localhost' =password('xxx'); 运行flush privileges;使密码设置生效 使第三方软件SQLyog可以连接： 登录数据库 GRANT ALL PRIVILEGES ON *.* TO root@\"%\" IDENTIFIED BY \"root用户的密码\"; 添加远程登陆功能 set names utf8; 设置数据库编码为UTF-8 输入quit指令退出数据库，输入 service mysqld restart; 重启mysql服务 开放3306端口： 123firewall-cmd --permanent --add-port=3306/tcp 开放端口firewall-cmd --reload 重载配置firewall-cmd --query-port=3306/tcp 查询是否开放成功 ¶十三、Linux日志管理 日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。 日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹！ 可以这样理解 日志是用来记录重大事件的工具！ ¶1、系统常用日志 /var/log/ 目录就是系统日志文件的保存位置 ¶2、日志管理服务rsyslogd CentOS7.6 日志服务是 rsyslogd ， CentOS6.x 日志服务是 syslogd 。rsyslogd 功能更强大。rsyslogd 的使用、日志文件的格式，和 syslogd 服务兼容的。 查询 Linux 中的 rsyslogd 服务是否启动ps aux | grep \"rsyslog\" | grep -v \"grep\" 查询 rsyslogd 服务的自启动状态 systemctl list-unit-files | grep rsyslog 配置文件：/etc/rsyslog.conf 编辑文件时的格式为：*.* 存放日志文件 其中第一个*代表日志类型 第二个*代表日志级别 日志类型： 1234567891011auth ##pam 产生的日志authpriv ##ssh、ftp 等登录信息的验证信息corn ##时间任务相关kern ##内核lpr ##打印mail ##邮件mark(syslog)-rsyslog ##服务内部的信息，时间标识news ##新闻组user ##用户程序产生的相关信息uucp ##unix to nuix copy 主机之间相关的通信local 1-7 ##自定义的日志设备 日志级别： 12345678910debug ##有调试信息的，日志通信最多info ##一般信息日志，最常用notice ##最具有重要性的普通条件的信息warning ##警告级别err ##错误级别，阻止某个功能或者模块不能正常工作的信息crit ##严重级别，阻止整个系统或者整个软件不能正常工作的信息alert ##需要立刻修改的信息emerg ##内核崩溃等重要信息none ##什么都不记录注意：从上到下，级别从低到高，记录信息越来越少 由日志服务 rsyslogd 记录的日志文件，日志文件的格式包含以下 4 列： 事件产生的时间 产生事件的服务器的主机名 产生事件的服务名或程序名 事件的具体信息 一个例子： 在/etc/rsyslog.conf 中添加一个日志文件/var/log/itnxd.log,当有事件发送时(比如 sshd 服务相关事件)，该文件会接收到信息并保存! 12# 增加自定义日志*.* /var/log/itnxd.log ¶3、日志轮替 日志轮替就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除！ centos7 使用 logrotate 进行日志轮替管理，要想改变日志轮替文件名字，通过 /etc/logrotate.conf 配置文件中“dateext”参数 如果配置文件中有“dateext”参数，那么日志会用日期来作为日志文件的后缀，例如 “secure-20201010”。这样日志文件名不会重叠，也就不需要日志文件的改名， 只需要指定保存日志个数，删除多余的日志文件即可。 如果配置文件中没有“dateext”参数，日志文件就需要进行改名了。当第一次进行日志轮替时，当前的“secure”日志会自动改为“secure.1”，然后新建“secure”日志， 用来保存新的日志。当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”， 当前的“secure”日志会自动改名为“secure.1”，然后也会新建“secure”日志，用来保存新的日志，以此类推。 ¶4、logrotate 配置文件 /etc/logrotate.conf文件： 12345678910111213141516171819202122232425262728/etc/logrotate.conf 为 logrotate 的全局配置文件# rotate log files weekly, 每周对日志文件进行一次轮替weekly# keep 4 weeks worth of backlogs, 共保存 4 份日志文件，当建立新的日志文件时，旧的将会被删除rotate 4# create new (empty) log files after rotating old ones, 创建新的空的日志文件，在日志轮替后create# use date as a suffix of the rotated file, 使用日期作为日志轮替文件的后缀dateext# uncomment this if you want your log files compressed, 日志文件是否压缩。如果取消注释，则日志会在转储的同时进行压缩#compress#RPM packages drop log rotation information into this directoryinclude /etc/logrotate.d# 包含 /etc/logrotate.d/ 目录中所有的子配置文件。也就 是说会把这个目录中所有子配置文件读取进来，#下面是单独设置，优先级更高。# no packages own wtmp and btmp -- we'll rotate them here/var/log/wtmp { monthly # 每月对日志文件进行一次轮替 create 0664 root utmp # 建立的新日志文件，权限是 0664 ，所有者是 root ，所属组是 utmp 组 minsize 1M # 日志文件最小轮替大小是 1MB 。也就是日志一定要超过 1MB 才会轮替，否则就算时间达到一个月，也不进行日志转储 rotate 1 # 仅保留一个日志备份。也就是只有 wtmp 和 wtmp.1 日志保留而已}/var/log/btmp { missingok # 如果日志不存在，则忽略该日志的警告信息 monthly create 0600 root utmp rotate 1} 参数说明： daily：日志的轮替周期是每天 weekly：日志的轮替周期是每周 monthly：日志的轮替周期是每月 rotate 数字：保留的日志文件的个数。0 指没有备份 compress：日志轮替时，旧的日志进行压缩 create mode owner group：建立新日志，同时指定新日志的权限与所有者和所属组。 mail address：当日志轮替时，输出内容通过邮件发送到指定的邮件地址。 missingok：如果日志不存在，则忽略该日志的警告信息 notifempty：如果日志为空文件，则不进行日志轮替 minsize 大小：日志轮替的最小值。也就是日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替 size 大小：日志只有大于指定大小才进行日志轮替，而不是按照时间轮替。 dateext：使用日期作为日志轮替文件的后缀。 sharedscripts：在此关键字之后的脚本只执行一次。 prerotate/endscript：在日志轮替之前执行脚本命令。 postrotate/endscript：在日志轮替之后执行脚本命令。 ¶5、把自己的日志加入日志轮替 第一种方法是直接在/etc/logrotate.conf 配置文件中写入该日志的轮替策略 第二种方法是在/etc/logrotate.d/目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被“include”到主配置文件中，所以也可以把日志加入轮替。 推荐使用第二种方法，因为系统中需要轮替的日志非常多，如果全都直接写 入/etc/logrotate.conf 配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。 /etc/logrotate.d文件的下面的日志轮替策略： 1234[root@itnxd100 ~]# ls /etc/logrotate.dbootlog firewalld itnxd.log numad samba wpa_supplicantchrony glusterfs libvirtd ppp sssd yumcups iscsiuiolog libvirtd.qemu psacct syslog 日志轮替机制原理： 日志轮替之所以可以在指定的时间备份日志，是依赖系统定时任务。在 /etc/cron.daily/目录，就会发现这个目录中是有 logrotate 文件(可执行)，logrotate 通过这个文件依赖定时任务执行的。 12345[root@itnxd100 ~]# ls -l /etc/cron.daily/总用量 12-rwx------. 1 root root 219 4月 1 2020 logrotate-rwxr-xr-x. 1 root root 618 10月 30 2018 man-db.cron-rwx------. 1 root root 208 4月 11 2018 mlocate ¶6、查看内存日志 注意: journalctl 查看的是内存日志, 重启清空 123456789journalctl 可以查看内存日志, 这里我们看看常用的指令journalctl ##查看全部journalctl -n 3 ##查看最新 3 条journalctl --since 19:00 --until 19:10:10 #查看起始时间到结束时间的日志可加日期journalctl -p err ##报错日志journalctl -o verbose ##日志详细内容journalctl _PID=1245 _COMM=sshd ##查看包含这些参数的日志（在详细日志查看）或者 journalctl | grep sshd ¶十四、内核升级 内核地址：https://www.kernel.org/ 步骤： 1234uname -a // 查看当前的内核版本yum info kernel -q //检测内核版本，显示可以升级的内核yum update kernel //升级内核yum list kernel -q //查看已经安装的内核 ¶十五、备份 &amp; 恢复 ¶1、备份 方式一：把需要的文件(或者分区)用 TAR 打包就行，下次需要恢复的时候，再解压开覆盖即可 方式二：使用 dump 和 restore 命令（推荐） 使用 dump 完成备份： dump 支持分卷和增量备份（所谓增量备份是指备份上次备份后 修改/增加过的文件，也称差异备份） 注意：在备份分区时，是可以支持增量备份的，如果备份文件或者目录，不再支持增量备份, 即只能使用 0 级别备份！ 下载并安装： 123yum -y install dumpyum -y install restore 命令：dump [ -cu] [-123456789] [ -f &lt;备份后文件名&gt;] [-T &lt;日期&gt;] [ 目录或文件系统] -c ： 创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头。 -0123456789： 备份的层级。0 为最完整备份，会备份所有文件。若指定 0 以上的层级，则备份至上一次备份以来修改或新增的文件, 到 9 后，可以再次轮替. -f &lt;备份后文件名&gt;： 指定备份后文件名 -j : 调用 bzlib 库压缩备份文件，也就是将备份后的文件压缩成 bz2 格式，让文件更小 -T &lt;日期&gt;： 指定开始备份的时间与日期 -u ： 备份完毕后，在/etc/dumpdares 中记录备份的文件系统，层级，日期与时间等。 -t ： 指定文件名，若该文件已存在备份文件中，则列出名称 -W ：显示需要备份的文件及其最后一次备份的层级，时间 ，日期。 -w ：与-W 类似，但仅显示需要备份的文件。 几个例子： 12345将/boot 分区所有内容备份到/opt/boot.bak0.bz2 文件中，备份层级为“0”dump -0uj -f /opt/boot.bak0.bz2 /boot在/boot 目录下增加新文件，备份层级为“1”(只备份上次使用层次“0”备份后发生过改变的数据), 注意比较看看这次生成的备份文件 boot1.bak 有多大dump -1uj -f /opt/boot.bak1.bz2 /boot注意: 通过 dump 命令在配合 crontab 可以实现无人值守备份 其他命令： cat /etc/dumpdates：查看备份时间文件 dump -W：显示需要备份的文件及其最后一次备份的层级，时间 ，日期 ¶2、恢复 restore 命令用来恢复已备份的文件，可以从 dump 生成的备份文件中恢复原文件！ restore [模式选项] [选项]：四个模式， 不能混用，在一次命令中， 只能指定一种 -C ：使用对比模式，将备份的文件与已存在的文件相互对比。 -i：使用交互模式，在进行还原操作时，restors 指令将依序询问用户 -r：进行还原模式 -t : 查看模式，看备份文件有哪些文件 选项：-f &lt;备份设备&gt;：从指定的文件中读取备份数据，进行还原操作 几个例子： 1234567891011121314151617restore 命令比较模式，比较备份文件和原文件的区别测试mv /boot/hello.java /boot/hello100.javarestore -C -f boot.bak1.bz2 //注意和 最新的文件比较mv /boot/hello100.java /boot/hello.javarestore -C -f boot.bak1.bz2restore 命令查看模式，看备份文件有哪些数据/文件测试restore -t -f boot.bak0.bz2restore 命令还原模式, 注意细节： 如果你有增量备份，需要把增量备份文件也进行恢复， 有几个增量备份文件，就要恢复几个，按顺序来恢复即可。测试mkdir /opt/boottmpcd /opt/boottmprestore -r -f /opt/boot.bak0.bz2 //恢复到第 1 次完全备份状态restore -r -f /opt/boot.bak1.bz2 //恢复到第 2 次增量备份状态 ¶十六、Ubuntu介绍 ¶1、Ubuntu 的 root 用户 安装 ubuntu 成功后，都是普通用户权限，并没有最高 root 权限，如果需要使用 root 权限的时候，通常都会在命令前面加上 sudo 。有的时候感觉很麻烦。 我们一般使用 su 命令来直接切换到 root 用户的，但是如果没有给 root 设置初始密码，就会抛出 su : Authentication failure 这样的问题。所以，我们只要给 root 用户设置一个初始密码就好了! 给 root 用户设置密码并使用： 输入 sudo passwd 命令，设定 root 用户密码。 设定 root 密码成功后，输入 su 命令，并输入刚才设定的 root 密码，就可以切换成 root 了。提示符$代表一般用户，提示符#代表 root 用户。 以后就可以使用 root 用户了 输入 exit 命令，退出 root 并返回一般用户 ¶2、Ununtu的APT包管理器 apt 是 Advanced Packaging Tool 的简称，是一款安装包管理工具。在 Ubuntu 下，我们可以使用 apt 命令进行软件包的安装、删除、清理等，类似于 Windows 中的软件管理工具！ APT操作相关命令： sudo apt-get update更新源 sudo apt-get install package安装包 sudo apt-get remove package删除包 sudo apt-cache show package获取包的相关信息，如说明、大小、版本等 sudo apt-cache search package 搜索软件包 sudo apt-get install package --reinstall 重新安装包 sudo apt-get -f install 修复安装 sudo apt-get remove package --purge 删除包，包括配置文件等 sudo apt-get build-dep package 安装相关的编译环境 sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统 sudo apt-cache depends package 了解使用该包依赖那些包 sudo apt-cache rdepends package 查看该包被哪些包依赖 sudo apt-get source package下载该包的源代码 ¶3、设置APT为中国镜像源 sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup：先备份一下 echo '' &gt; source.list：清空该配置文件 版本号（或者官方一点的说：系统代号），所以我们先了解下新版本的系统代号：lsb_release -c，我的是focal 将下方内容的focal修改为你对应的版本号即可！ 1234567891011deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse sudo apt-get update：更新源地址，使配置生效 ¶4、安装sshd服务 Ubuntu默认没有sshd服务，我们来安装一下！ netstat查看一下：（默认也没有该命令，使用apt install net-tools安装） sudo apt-get install openssh-server：安装 service sshd restart：重启 ssh 用户名@IP：远程登录其他服务器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.itnxd.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.itnxd.cn/tags/Linux/"}],"author":"ITNXD"},{"title":"常用Git命令及IDEA整合Git、GitHub","slug":"常用Git命令及IDEA整合Git、GitHub","date":"2021-05-01T02:03:15.000Z","updated":"2021-05-01T09:10:06.715Z","comments":true,"path":"posts/23616.html","link":"","permalink":"https://www.itnxd.cn/posts/23616.html","excerpt":"","text":"好久前学习的Git内容记录，点击这里！ 本篇只记录最常用的命令及整合IDEA的步骤！ ¶一、常用命令 命令名称 作用 git config --global user.name 用户名 设置用户签名 git config --global user.email 邮箱 设置用户签名 git init git init 初始化本地库 git status 查看本地库状态 git add 文件名 添加到暂存区 git commit -m “日志信息” 文件名 提交到本地库 git reflog 查看版本信息 git log 查看版本详细信息 git reset --hard 版本号（前七位即可） 版本穿梭 git branch 分支名 创建分支 git branch -v （*代表当前所在的分区） 查看分支 git checkout 分支名 切换分支 git merge 分支名 把指定的分支合并到当前分支上 ¶1、设置用户签名 设置完成可以在家目录下的.gitconfig中看到：cat ~/.gitconfig 签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。Git 首次安装必须设置一下用户签名，否则无法提交代码。 注意：这里设置用户签名和将来登录 GitHub 的账号没有任何关系。 ¶2、合并冲突 当两个分支都发生了改变，合并时由于无法知道保留谁，舍弃谁，会冲突，这时需要手动合并冲突！ 冲突产生的表现：后面状态为 MERGING，例如：(master|MERGING) 1234$ git merge hot-fixAuto-merging hello.txtCONFLICT (content): Merge conflict in hello.txtAutomatic merge failed; fix conflicts and then commit the result. 查看会发现，已经将两个分支的不同之处标记了出来：特殊符号：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 当前分支的代码 ======= 合并过来的代码 &gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix 因此我们vim进入编辑，将要保留的内容留下，舍弃的内容舍弃后保存即可！ 在git add, git commit之后，后面的MERGING消失！ 注意：此时使用 git commit 命令时不能带文件名 12345678910111213141516171819202122$ cat hello.txthello git! hello atguigu! 2222222222222hello git! hello atguigu! 3333333333333hello git! hello atguigu!hello git! hello atguigu!hello git! hello atguigu!hello git! hello atguigu!hello git! hello atguigu!hello git! hello atguigu!hello git! hello atguigu!hello git! hello atguigu!hello git! hello atguigu!hello git! hello atguigu!hello git! hello atguigu!hello git! hello atguigu!&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADhello git! hello atguigu! master testhello git! hello atguigu!=======hello git! hello atguigu!hello git! hello atguigu! hot-fix test&gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix ¶二、远程库常用命令 命令名称 作用 git remote -v 查看当前所有远程地址别名（后面括号的fetch表示有pull权限，push表示有push权限！） git remote add 别名 远程地址 起别名 git push 别名 分支 推送本地分支上的内容到远程仓库 git clone 远程地址 将远程仓库的内容克隆到本地（1、拉取代码。2、初始化本地仓库。3、创建别名origin） git pull 远程库地址别名 远程分支名 将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并 ssh-keygen -t rsa -C 邮箱 生成ssh密钥，配置免密登录以及支持ssh协议传输！ ¶1、邀人进行团队协作 路径：github 仓库Settings -&gt; Manage access -&gt; Invite a collaborator ，输入邮箱找到该伙伴后将生成的链接通过社交软件发送给伙伴，他同意后就拥有了操作本库的权限！ ¶2、跨团队协作 就是常见的fork和PR操作！ github的聊天室无需刷新，动态展示所有聊天信息！ ¶三、IDEA整合Git ¶1、配置.ignore文件 用来配置git的忽略文件，即无需使用git跟踪的内容！ 与项目的实际功能无关，不参与服务器上部署运行。把它们忽略掉能够屏蔽 IDE 工具间的差异。 文件名建议设置为git.ignore即可！ 建议放到用户家目录下，方便在git配置中引用！ git.ignore文件内容如下即可： 123456789101112131415161718192021222324252627282930# Compiled class file*.class# Log file*.log# BlueJ files*.ctxt# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*.classpath.project.settingstarget.idea*.iml 在.gitconfig 文件中引用忽略配置文件： 注意：这里要使用“正斜线（/）”，不要使用“反斜线（\\）” 1234567891011121314[user] name = niuxvdong email = 158903258@qq.com emali = 158903258@qq.com[color] ui = true[core] autocrlf = true excludesfile = C:/Users/15890/git.ignore[gui]# [http \"https://github.com\"]# proxy = socks5://127.0.0.1:1080# [https \"https://github.com\"]# proxy = socks5://127.0.0.1:1080 ¶2、配置Git位置 路径：File | Settings | Version Control | Git 手动选择git.exe的位置，或者直接自动选择即可！ ¶3、初始化本地库 初始化完成就可以在Module或项目根目录上直接右键有了Git选项卡！并且上方工具栏下面点的快捷栏目也有了Git的两大命令，push和commit 注意：若使用方法一没有右键没有出现Git选项卡，重启一下Idea即可！ 方法一：直接点击下方工具栏的terminal，进入对应的Module目录或直接在项目根目录，执行命令git init即可！ 方法二：点击最上方的工具栏 Git（最新版Idea，旧版本为vcs），找到Create Git Repository...点击即可！ ¶4、添加&amp;提交 方法一：右键的Git选项卡找 方法二：最上方工具栏Git或下方的快捷栏目都有！ 文件颜色： 红色：表示未被git跟踪 绿色：表示已被跟踪，但未提交本地库 正常原色：表示已提交本地库 ¶5、切换版本 打开下方工具栏的Git栏目，点击log选项卡，即可看到全部的详细版本信息，直接右键需要回退的版本Checkout Revision即可回退到对应版本！ ¶6、新建及切换分支 鼠标移到对应分支，选择Checkout即可快速切换分支！ 方法一：右键Git选项卡找 方法二：最上方工具栏的Git找 方法三：右下角的带有分支图标的位置 ¶7、合并分支 在主分支下，选择对应分支后，点击Merge into Current即可！ 若出现合并冲突，由于Idea太过智能，会出现比对功能，帮助你合并冲突！会有三个界面： 左边：主分支代码 右边：待合并分支代码 中间：没有发生冲突的代码 会有常见的合并箭头，简单的点击即可将冲突问题解决！冲突合并完成会自动提交本地库！ ¶四、IDEA整合GitHub ¶1、配置Github信息 在路径：File | Settings | Version Control | GitHub里点击加号添加GitHub账户即可！ 若使用了SSH免密，建议勾选Clone git repositories using ssh ¶2、本地库推到GitHub上 选择最上方工具栏的Git选项，选择Github，选择Share Project on GitHub，弹出的框内填写远程库名（一般与项目同名）和别名以及描述信息即可！ Idea会帮你自动创建远程库并进行推送的！ ¶3、推送 &amp; 拉取 推送弹出的界面可以自定义其他别名！ 方法一：右键Git选项卡里找 方法二：最上面工具栏Git选项卡或下方一点的快捷操作中找 ¶4、克隆远程库 选择最上方工具栏的Git选项卡的clone，在弹出的界面选择克隆方式及远程库信息等等即可！ ¶五、IDEA整合码云Gitee 操作同上，若File | Settings | Version Control | Gitee没有Gitee选项，需要在插件商店安装后重启即可！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Git","slug":"Git","permalink":"https://www.itnxd.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.itnxd.cn/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://www.itnxd.cn/tags/GitHub/"}],"author":"ITNXD"},{"title":"每日一题之LeetCode 783.二叉搜索树节点最小距离","slug":"每日一题之LeetCode-783-二叉搜索树节点最小距离","date":"2021-04-13T09:20:25.000Z","updated":"2021-04-13T10:52:32.585Z","comments":true,"path":"posts/16877.html","link":"","permalink":"https://www.itnxd.cn/posts/16877.html","excerpt":"","text":"¶一、题解 题目大意： 求一个二叉搜索树任意两个节点数的差值的最小值！ 思路： 我们知道，二叉搜索树的中序遍历就是一个单调序列！ 因此我们可以在中序遍历的同时保存上一个节点的值，然后每次比较相邻两个数的差值即可！ 处理相邻的一定是最优的，非相邻节点的差值一定比相邻节点的差值要大！ 具体： 只要不是第一个遍历的节点，我们就可保存的上一个节点做一个差值，然后取一个最值即可 要注意，保存上一个节点的一定要在取过最值之后再保存！ 时间复杂度： O(n) 空间复杂度： O(h) ¶二、AC代码 参考代码： 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int last, res; bool first; void dfs(TreeNode* root){ if(!root) return; dfs(root-&gt;left); if(!first) res = min(res, root-&gt;val - last); last = root-&gt;val, first = false; dfs(root-&gt;right); } int minDiffInBST(TreeNode* root) { res = INT_MAX, first = true; dfs(root); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"中序遍历","slug":"中序遍历","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"树的遍历","slug":"树的遍历","permalink":"https://www.itnxd.cn/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"}],"author":"ITNXD"},{"title":"每日一题之AcWing 1453.移掉K位数字","slug":"每日一题之AcWing-1453-移掉K位数字","date":"2021-04-12T09:19:39.000Z","updated":"2021-04-13T10:52:32.561Z","comments":true,"path":"posts/59024.html","link":"","permalink":"https://www.itnxd.cn/posts/59024.html","excerpt":"","text":"题目链接：AcWing 1453. 移掉K位数字 ¶一、题解 题目大意： 给定一个很长的字符串表示的非负整数，去掉 k 位数，使得结果表示的数最小！ 思路： 对于一个单调递增的序列，我们发现，若出现后一个数比序列尾的数要小，即发生了逆序，那么我们应该尽可能删掉该序列的末尾比出现的数大的数，这样可以使得结果尽可能的小！ 删完后，将当前数加入序列！ 当然可以删除的前提是还有次数可以删！ 最后处理完毕，若还有删除次数，则此时的单调递增序列，可以直接删掉后面对应个数的数即可！ 注意： 为了防止全部删完，我们提前在最前方插入一个0，最终我们将前导0去掉即可！ 时间复杂度： O(n) 空间复杂度： O(n) ¶二、AC代码 参考代码： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main(){ string s; int k; cin &gt;&gt; s &gt;&gt; k; string res = \"0\"; for(auto c : s){ while(k &amp;&amp; res.back() &gt; c) res.pop_back(), k --; res += c; } while(k --) res.pop_back(); k = 0; while(k + 1 &lt; res.size() &amp;&amp; res[k] == '0') k ++; cout &lt;&lt; res.substr(k); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"}],"author":"ITNXD"},{"title":"每日一题之LeetCode 179.最大数","slug":"每日一题之LeetCode-179-最大数","date":"2021-04-11T09:19:06.000Z","updated":"2021-04-13T10:52:32.580Z","comments":true,"path":"posts/10647.html","link":"","permalink":"https://www.itnxd.cn/posts/10647.html","excerpt":"","text":"题目链接：LeetCode 179. 最大数 ¶一、题解 题目大意： 给定一组非负整数，我们可以任意组合，使其得到的结果最大！ 思路： 这个题目，我的想法是分析每个数的最高位以及每一位的大小情况，包括0的特殊处理，后来发现这样处理似乎非常复杂！ 正确做法： 我们可以把每个数看为一个整体，通过交换相邻两个数的位置，即可得到是否需要交换！ 类似排序！ 因此这样处理就很简单了，只需要定义一个排序函数处理相邻两个数的大小情况，排完序，自然就是一个最大值的情况了！ 对于前导0的处理？ 能出现前导0的情况一定是给定的数中只有0。 若不只有0，则0和其他数交换的过程中，会发现，0这个数一定会和其他数进行交换放到后方，因为其他数放到前方一定比放到后方要大！因此不可能出现前导0的情况！ 因此如果最终结果第一位为0，则该序列都是0，直接返回即可！ 时间复杂度： O(nlogn) 空间复杂度： O(n) ¶二、AC代码 参考代码： 12345678910111213class Solution {public: string largestNumber(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end(), cmp); string res; for(auto s : nums) res += to_string(s); if(res[0] == '0') return \"0\"; return res; } static bool cmp(int a, int b){ return to_string(a) + to_string(b) &gt; to_string(b) + to_string(a); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"}],"author":"ITNXD"},{"title":"每日一题之AcWing 62.丑数","slug":"每日一题之AcWing-62-丑数","date":"2021-04-10T09:17:13.000Z","updated":"2021-04-13T10:52:32.574Z","comments":true,"path":"posts/12479.html","link":"","permalink":"https://www.itnxd.cn/posts/12479.html","excerpt":"","text":"题目链接：AcWing 62. 丑数 ¶一、题解 题目大意： 只包含2，3，5质因子的数，称之为丑数，求第 n 个丑数的值！ 思路： 假设有一个序列是丑数序列，我们将其中2的倍数，3的倍数，5的倍数抽取出来得到三个序列！ 那么原序列的取值一定是1和这三个序列的并集！ 因此丑数序列的每一个取值一定可以由这三个序列得到！ 我们使用三个指针分别指向三个序列的开始，那么下一项的取值一定是三个序列中最小的一个，取完值后对应指针后移即可！ 那三个序列的取值一定可以由已知的丑数序列通过乘2，乘3，乘5得到！ 不好理解的地方在于三个指针的移动？ 三个指针都处在已得到序列之前的某个位置，只有该位置的数乘以对应的2，3，5才可以且该结果在三个结果中最小，该指针才会后移！ 三个指针是否会越界？ 自然不会，由于丑数序列下标每次必增加1，而三个序列的指针却不一定增加1，因此一定不会越界！ 注意： 由于三个序列可能会有重复，即可能同时是几个数的倍数！因此我们遇到相同时，指针一定要同时后移！ 时间复杂度： O(n) 空间复杂度： O(n) ¶二、AC代码 参考代码： 123456789101112131415class Solution {public: int getUglyNumber(int n) { vector&lt;int&gt; q(1, 1); int i = 0, j = 0, k = 0; while(-- n){ int t = min(q[i] * 2, min(q[j] * 3, q[k] * 5)); q.push_back(t); if(t == q[i] * 2) i ++; if(t == q[j] * 3) j ++; if(t == q[k] * 5) k ++; } return q.back(); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"多路归并","slug":"多路归并","permalink":"https://www.itnxd.cn/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/"}],"author":"ITNXD"},{"title":"持久化层数据库框架-MyBatis使用总结","slug":"持久化层数据库框架-MyBatis使用总结","date":"2021-04-09T07:18:18.000Z","updated":"2021-04-10T07:27:41.569Z","comments":true,"path":"posts/33442.html","link":"","permalink":"https://www.itnxd.cn/posts/33442.html","excerpt":"","text":"¶一、MyBatis简介 MyBatis，和数据库进行交互的持久化层框架（SQL映射框架） 官方文档也很详细：点击这里！ MyBatis特点： MyBatis将重要的步骤抽取出来可以人工定制，其他步骤自动化 重要步骤都是写在配置文件中(好维护) 完全解决数据库的优化问题 MyBatis底层就是对原生JDBC的一个简单封装 既将java编码与sq|抽取了出来,还不会失去自动化功能;半自动的持久化层框架 实现原理图示： 复杂场景可以实现手动！半自动 ¶二、MyBatis搭建 ¶1、数据库建表和对应JavaBean（略） ¶2、pom.xml导包 导入MyBatis、数据库驱动、以及log4j依赖！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itnxd.mybatis&lt;/groupId&gt; &lt;artifactId&gt;3_MyBatis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;14&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;14&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--MyBatis--&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt; &lt;/dependency&gt; &lt;!--loj4j日志，可以显示sql语句！--&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!--Junit--&gt; &lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.8.0-M1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ¶3、创建log4j配置文件 在maven工程的resources目录下新建log4j.xml文件（名字固定），这样可以在运行程序时显示更详细的信息，会有发送的sql语句提示信息！ 在mybatis配置文件中加入&lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt;即可！ 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"&gt;&lt;log4j:configuration xmlns:log4j=\"http://jakarta.apache.org/log4j/\"&gt; &lt;appender name=\"STDOUT\" class=\"org.apache.log4j.ConsoleAppender\"&gt; &lt;param name=\"Encoding\" value=\"UTF-8\" /&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \\n\" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=\"java.sql\"&gt; &lt;level value=\"debug\" /&gt; &lt;/logger&gt; &lt;logger name=\"org.apache.ibatis\"&gt; &lt;level value=\"info\" /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=\"debug\" /&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; ¶4、创建mybatis配置文件 在maven工程的resources目录下新建mybatis-config.xml配置文件（名字任意）！ 注意： dtd: 配置文件约束 配置文件 configuration 中的元素，不但有类型限制，也有顺序限制。必须按照： 1properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers? 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!--dtd: 配置文件约束！配置文件 configuration 中的元素，不但有类型限制，也有顺序限制。必须按照The content of element type \"configuration\" must match \"(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)\".--&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; &lt;/settings&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--配置连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"xxx\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; ¶5、创建sql映射文件 在maven工程的resources目录下新建EmployeeDao.xml（名称与Dao接口名称一致）！ 该文件作为Dao的实现，类似之前的EmployeeDaoImpl实现类！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!--namespace:名称空间:写接口的全类名，相当于告诉MyBatis这个配置文件是实现哪个接口的;--&gt;&lt;mapper namespace=\"com.itnxd.dao.EmployeeDao\"&gt; &lt;!-- Employee getEmpById(Integer id); --&gt; &lt;!-- select:用来定义一个查询操作 id:方法名，相当于这个配置是对于某个方法的实现 resultType :指定方法运行后的返回值类型(全类名); (查询操作必须指定的) 可以配置typeAliases属性指定别名！ #{属性名}:代表取出传递过来的某个参数的值 参数也无需写！ --&gt; &lt;select id=\"getEmpById\" resultType=\"com.itnxd.bean.Employee\"&gt; /*sql语句不要写分号*/ select * from t_employee where id = #{id} &lt;/select&gt; &lt;!-- 增删改不用谢返回值类型！自动的！直接返回影响多少行！ 增删改不用写返回值类型;增删改是返回影响多少行 mybatis自动判断，如果是数字(int, 1ong) 如果是boolean (影响0行自动封装false,否则true) --&gt; &lt;delete id=\"deleteEmployee\"&gt; delete from t_employee where id = #{id} &lt;/delete&gt; &lt;update id=\"updateEmployee\"&gt; update t_employee set empname = #{empname}, gender = #{gender},email = #{email} where id = #{id} &lt;/update&gt; &lt;insert id=\"insertEmployee\"&gt; insert into t_employee(empname, gender, email) values(#{empname}, #{gender}, #{email}) &lt;/insert&gt;&lt;/mapper&gt; ¶6、将sql映射文件注册到mybatis中 在mybatis-config.xml中注册sql映射文件位置！ 12345678 &lt;!--引入我们自己编写的每一个接口的实现文件 resource :表示从类路径下找资源 --&gt; &lt;mappers&gt; &lt;mapper resource=\"EmployeeDao.xml\"/&gt; &lt;/mappers&gt; ¶7、测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 查询测试@Testpublic void test1() throws IOException { // 1. 根据全局配置文件创建出一个SqlSessionFactory // SqlSessionFactory:是SqlSession工厂，负责创建SqlSession对象; // SqlSession:sq1会话(代表和数据库的一次会话) String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 2. 获取和数据库的一次会话,类似getConnection // 参数可以添加true或false，表示是否自动提交！ try (SqlSession session = sqlSessionFactory.openSession()) { // 3、使用SqlSession操作数据库，获取到dao接口的实现 EmployeeDao employeeDao = session.getMapper(EmployeeDao.class); // 4. 调用Dao方法 Employee emp = employeeDao.getEmpById(3); System.out.println(emp); } catch (Exception e) { e.printStackTrace(); }}// 增删改测试@Testpublic void test2() throws IOException { String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { EmployeeDao employeeDao = session.getMapper(EmployeeDao.class); // 查 Employee emp = employeeDao.getEmpById(1); System.out.println(emp); // 改 int i = employeeDao.updateEmployee(new Employee(1, \"itnxd\", 1, \"itnxd@gmail.com\")); System.out.println(i); // 增 int i1 = employeeDao.insertEmployee(new Employee(null, \"admin\", 1, \"admin@gmail.com\")); System.out.println(i1); // 删 int i2 = employeeDao.deleteEmployee(1); System.out.println(i2); // 需要手动提交，也可在openSession方法中传入true实现自动提交！ session.commit(); } catch (Exception e) { e.printStackTrace(); }} ¶三、MyBatis全局配置文件 官方全局配置文件详解，点击这里！ ¶1、properties 引入外部配置文件！ 如下方为引入数据库配置信息文件，可以在environment中使用${}获取值！ 12345678&lt;!--1. properties和Spring的context: property-placeholder;引用外部配置文件resource:从类路径下开始引用url:引用磁盘路径或者网络路径的资源--&gt;&lt;properties resource=\"dbconfig.properties\"/&gt; ¶2、settings settings属性的各类设置，可以设置许多东西，官方地址，点击这里！ settings这是MyBatis中极为重要的调整设置，它们会改变MyBatis的运行时行为。 1234567891011121314151617181920212223&lt;settings&gt; &lt;!-- mapUnderscoreToCamelCase：驼峰命名开启 JavaBean为loginAccount sql为login_account 自动映射 --&gt; &lt;!--开启日志打印sql--&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; &lt;!--开启驼峰命名--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--开启属性延迟加载 开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt; &lt;!--开启全局缓存，默认为true,但最好显示开启--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; ¶3、typeAliases（了解） 类型别名，可以为常用的类型(JavaBean)起别名！ 一些官方别名：查看这里，防止被你占用！ 推荐：使用全类名，而不是别名！ 12345678910111213141516&lt;typeAliases&gt; &lt;!-- typeAlias:就是为一个javaBean起别名; 别名默认就是类名(不区分大小写) 也可以使用alias指定别名 &lt;typeAlias type=\"com.itnxd.bean.Employee\" alias=\"\"/&gt; 批量起别名 批量起别名; name=\"\"指定包名,默认别名就是类名(不区分大小写) 仍然想要起别名，在类上使用@Alias注解 推荐：使用全类名，可以点击，快速定位！ --&gt; &lt;package name=\"com.itnxd.bean\"/&gt;&lt;/typeAliases&gt; ¶4、typeHandlers（了解） MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型！ 12345678&lt;!--4. typeHandlers：MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型--&gt;&lt;typeHandlers&gt; &lt;!--自定义好的类型处理器就这么配置上就行了--&gt; &lt;typeHandler handler=\"\"/&gt;&lt;/typeHandlers&gt; ¶5、plugins（了解） 插件，动态代理的使用，可以提供强大功能！ ¶6、environments（了解） 配置一个具体环境，需要事务管理器 transactionManager 和数据源 dataSource（连接池） 做事务管理：mybatis不如spring，因此一般transactionManager标签不用配置。 数据库连接池：第三方连接池比默认的更强，因此这个一般也不用配置。 可以配置多个环境，使用 default 指定默认使用环境！ 后来的数据源和事务管理都是spring来做！ 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--6. environments，配置环境environment：配置一个具体环境，需要事务管理器和数据源（连接池） transactionManager dataSourcedefault：指定默认使用环境做事务管理：mybatis不如spring，因此一般transactionManager标签不用配置数据库连接池：第三方连接池比默认的更强，因此这个一般也不用配置后来的数据源和事务管理都是spring来做！--&gt;&lt;environments default=\"development\"&gt; &lt;!--id：当前环境的唯一标识--&gt; &lt;environment id=\"testEnv\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--配置连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--使用${}取出配置文件值--&gt; &lt;property name=\"driver\" value=\"${driverClass}\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://192.168.1.1/test\"/&gt; &lt;property name=\"username\" value=\"${username}\"/&gt; &lt;property name=\"password\" value=\"${password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--配置连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--使用${}取出配置文件值--&gt; &lt;property name=\"driver\" value=\"${driverClass}\"/&gt; &lt;property name=\"url\" value=\"${jdbcUrl}\"/&gt; &lt;property name=\"username\" value=\"${username}\"/&gt; &lt;property name=\"password\" value=\"${password}\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; ¶7、databaseIdProvider 数据库厂商标识，mybatis用来处理数据库移植性的！ type固定值：从官方文档扣过来即可！ 去Dao.xml中增加各类数据库实现即可！ 默认通过databaseId值区分数据库，若都不匹配执行没有添加databaseId属性的默认语句！ 可以精确匹配就精确匹配，否则使用默认的模糊匹配！ 1234567891011121314151617181920212223&lt;!--7. 数据库厂商标识（databaseIdProvider）mybatis用来考虑数据库移植性的type固定值：从官方文档扣过来即可去Dao.xml中增加各类数据库实现即可！默认通过databaseId值区分数据库，若都不匹配执行没有添加databaseId属性的默认语句！可以精确匹配就精确匹配，否则使用默认的模糊匹配！--&gt;&lt;databaseIdProvider type= \"DB_VENDOR\"&gt; &lt;!-- name:数据库厂商标识（固定值） value:给这个标识起一个好用的名字 MySQL、Oracle、SQL Server; --&gt; &lt;property name= \"MySQL\" value=\"mysql\"/&gt; &lt;property name= \"SQL Server\" value=\"sqlserver\"/&gt; &lt;property name= \"Oracle\" value=\"oracle\"/&gt;&lt;/databaseIdProvider&gt; 1234567891011121314&lt;select id=\"getEmpById\" resultType=\"com.itnxd.bean.Employee\"&gt; /*sql语句不要写分号*/ select * from t_employee where id = #{id}&lt;/select&gt;&lt;select id=\"getEmpById\" resultType=\"com.itnxd.bean.Employee\" databaseId=\"mysql\"&gt; /*sql语句不要写分号*/ select * from t_employee where id = #{id}&lt;/select&gt;&lt;select id=\"getEmpById\" resultType=\"com.itnxd.bean.Employee\" databaseId=\"oracle\"&gt; /*sql语句不要写分号*/ select * from t_employee where id = #{id}&lt;/select&gt; ¶8、mappers 写好的Dao.xml sql映射文件注册进来！ 普通注册 resource：类路径下找映射文件 class：直接写Dao接口的全类名 可以将xml放在和dao接口同目录下，而且文件名和接口名一致 还可以用来配置注解版本的Dao接口，不使用配置文件！ url：从磁盘或者网络路径 批量注册： 映射文件和dao必须同路径才可以 解决方法： 在maven工程下的resources文件夹下新建一个和dao包名同路径的文件夹，映射文件放到这里 同时配置pom.xml文件，让其将配置文件一同打包到与源文件同路径！ pom.xml文件： src/main/java：若映射文件和类文件同在该目录下，则指定maven打包将该目录一起打包 src/main/resources：若映射文件在工程下的resources目录下同报名路径，则指定maven打包将该目录一起打包 123456789101112131415161718192021&lt;!--处理maven不会把源文件路径下的配置文件打包到类路径！--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt;&lt;!--所在的目录--&gt; &lt;includes&gt;&lt;!--包括目录下的.properties,.xml文件都会扫描到--&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; mybatis-config.xml文件: 12345678910111213141516171819202122232425262728293031&lt;!--8. mappers：写好的Dao.xml sql映射文件注册进来--&gt;&lt;mappers&gt; &lt;!-- resource: 类路径下找映射文件 class: 直接写Dao接口的全类名 可以将xm1放在和dao接口同目录下，而且文件名和接口名-致 还可以用来配置注解版本的Dao接口，不使用配置文件！ url: 从磁盘或者网络路径 配合使用;重要的dao可以写配置; 简单的dao就直接标注解; --&gt; &lt;!--&lt;mapper class=\"com.itnxd.dao.EmployeeDao\"/&gt; &lt;mapper class=\"com.itnxd.dao.EmployeeAnnoDao\"/&gt;--&gt; &lt;!--&lt;mapper resource=\"com/itnxd/dao/EmployeeDao.xml\"/&gt;--&gt; &lt;!--&lt;mapper resource=\"EmployeeDao.xml\"/&gt;--&gt; &lt;!-- 批量注册 配置文件实现的，配置文件和dao必须同路径才可以！ 否则可以通过getMapper获取到Dao，但无法绑定配置文件的方法而报错！ 解决方法：在资源文件夹下新建一个和dao包名同路径的文件夹即可找到！ 同时配置pom.xml文件，让其将配置文件一同打包到与源文件同路径！ 因为：编译完成后配置文件和类文件是同路径的！可以找到！ --&gt; &lt;package name=\"com.itnxd.dao\"/&gt;&lt;/mappers&gt; ¶9、注解映射文件 重要的复杂的dao可以写配置 简单的dao就直接标注解 12345678910111213141516171819202122232425262728package com.itnxd.dao;import com.itnxd.bean.Employee;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;/** * @author ITNXD * @create 2021-04-06 20:57 */public interface EmployeeAnnoDao { @Select(\" select * from t_employee where id = #{id}\") Employee getEmpById(Integer id); @Insert(\"insert into t_employee(empname, gender, email) \" + \"values(#{empname}, #{gender}, #{email})\") int insertEmployee(Employee employee); @Update(\" update t_employee set empname = #{empname} \" + \"gender = #{gender},email = #{email} where id = #{id}\") int updateEmployee(Employee employee); @Delete(\"delete from t_employee where id = #{id}\") int deleteEmployee(Integer id);} ¶四、Sql映射配置文件 ¶0、可以写的标签 1234567891011cache – 该命名空间的缓存配置。cache-ref – 引用其它命名空间的缓存配置。resultMap – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。parameterMap（废弃） – 用来做复杂参数映射sql – 抽取可重用sql语句块。insert – 映射插入语句。update – 映射更新语句。delete – 映射删除语句。select – 映射查询语句。 增删改标签属性： id：对应的方法名 parameterType：默认可以自动推断，不写 flusthCache：后续介绍 timeout：一般使用spring管理！ statementType：默认为preparedStatement（一般不改），callable：调用存储过程使用 ¶1、获取参数值 ¶1.1、各种参数取值 单个参数：基本类型：#{随便写} 多个参数：内部使用Map存储，通过key取值，默认key为#{arg0, arg1 或 param1, param2} 使用@param注解为参数指定key，称之为命名参数（推荐）：#{指定的key} JavaBean：#{JavaBean的属性值}，无需. Map：#{key} 混合型： 使用注解：可以使用 #{JavaBean.属性} 获取 不使用注解：使用{paramN.属性} 获取 几个例子： 例子一：不使用@Param注解 默认有一个对应关系，(参数1，参数2 .. ) 对应 arg0, arg1或param1, param2！ 单个参数：随便写即可 多个参数：按照默认情况写（内部为使用Map保存） 123456789101112&lt;!--传参到底可以传那些参数！Employee getEmpByIdAndEmpName(Integer id, String empName);旧版本为 0,1，param1,param2[arg1, arg0, param1, param2]--&gt;&lt;select id=\"getEmpByIdAndEmpName\" resultType=\"com.itnxd.bean.Employee\"&gt; select * from t_employee where id = #{arg0} and empname = #{arg1}&lt;/select&gt;&lt;select id=\"getEmpByIdAndEmail3\" resultType=\"com.itnxd.bean.Employee\"&gt; select * from t_employee where id = #{id} and email = #{param2.email}&lt;/select&gt; 例子二：使用@Param注解（推荐） 使用注解起别名可以更方便获取值！ 使用@param注解为参数指定key，称之为命名参数！ 1Employee getEmpByIdAndEmail3(@Param(\"id\") Integer id, @Param(\"employee\") Employee employee); 123&lt;select id=\"getEmpByIdAndEmail3\" resultType=\"com.itnxd.bean.Employee\"&gt; select * from t_employee where id = #{id} and email = #{employee.email}&lt;/select&gt; ¶1.2、取值时可设置规则 javaType、jdbcType、mode、numericScale、resultMap、typeHandler、jdbcTypeName、expression等！ 实际上通常被设置的是：可能为空的列名指定 jdbcType eg：id=#{id,jdbcType=INT}; 只有jdbcType才可能是需要被指定的： 正常情况，默认不指定jdbcType，mysql没问题，oracle没问题; 万一传入的数据是null，mysql插入null没问题，oracle不知道null到底是什么类型 ¶1.3、#{key}和${key}区别 #{key}：获取参数的值，预编译到SQL中。安全。（无法使用在非参数位置进行预编译） ${key}：获取参数的值，拼接到SQL中。有SQL注入问题。ORDER BY ${name} 在不支持参数预编译的情况下，使用${}，例如表名位置。。 ¶2、获取自增主键的值 useGeneratedKeys：开启使用自增主键，mybatis自动获取自增主键 keyProperty：获取到自增主键交给JavaBean的该属性（java代码中可以调用getId方法获取到封装的自增主键） 123456789101112&lt;!-- 让MyBatis自动的将自增id赋值给传入的employee对象的id属性 useGeneratedKeys=\"true \": keyProperty=\"\":将刚才自增的id封装给哪个属性 --&gt;&lt;insert id=\"insertEmployee\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into t_employee(empname, gender, email) values(#{empname}, #{gender}, #{email})&lt;/insert&gt; 对于不支持自增数据库的处理： 例如Oracle! 使用selectKey标签和order属性指定提前运行的sql语句，便于主sql语句可以取到该值！ 同样查询到的最大id赋值给了JavaBean对应的属性！ 12345678910111213141516171819&lt;!-- 对于不支持自增的数据库可以这样搞！ 查询主键 order=\"BEFORE\": 在核心s.ql语句之前先运行一个查询sql查到id;将查到的id赋值给javaBean的哪个属性; 在执行sql之前，先执行一个sql查询出下一个id(即最大id+1)的值赋值给javaBean的id， 方便在主sql语句执行时可以获取到id！而不是null--&gt;&lt;insert id=\"insertEmployee2\"&gt; &lt;selectKey order=\"BEFORE\" resultType=\"Integer\" keyProperty=\"id\"&gt; select max(id) + 1 from t_employee &lt;/selectKey&gt; insert into t_employee(id, empname, gender, email) values(#{id}, #{empname}, #{gender}, #{email})&lt;/insert&gt; ¶3、resultType 指定返回值类型！ ¶2.1、集合 如果返回的是集合，写的是集合里面元素的类型! 1List&lt;Employee&gt; getAllEmps(); 123456&lt;!--resultType=\"\"。如果返回的是集合，写的是集合里面元素的类型--&gt;&lt;select id=\"getAllEmps\" resultType=\"com.itnxd.bean.Employee\"&gt; select * from t_employee&lt;/select&gt; ¶2.2、单条记录返回Map 查询返回一个Map，则写map，mybatis指定的别名，Map-&gt;map 1234/** * 列名作为key,值作为value */Map&lt;String, Object&gt; getEmpByIdReturnMap(Integer id); 1234567&lt;!--查询返回一个map,mybatis指定的别名，Map-&gt;map--&gt;&lt;select id=\"getEmpByIdReturnMap\" resultType=\"map\"&gt; select * from t_employee where id = #{id};&lt;/select&gt; ¶2.3、多条记录返回Map 使用@MapKey注解指定那个属性作为主键！ resultType写JavaBean类型！ 1234567/** * key是主键，value是对象 * @MapKey：指定以哪个主键作为key * @return */@MapKey(\"id\")Map&lt;Integer, Employee&gt; getAllEmpsReturnMap(); 1234567&lt;!--查询多条记录返回map resultType：多条记录要写JavaBean类型！--&gt;&lt;select id=\"getAllEmpsReturnMap\" resultType=\"com.itnxd.bean.Employee\"&gt; select * from t_employee&lt;/select&gt; ¶2.4、普通类型 直接写JavaBean类型！ ¶4、resultMap 自定义返回类型！自己定义每一列数据和JavaBean的映射规则！ 123456789101112131415161718192021222324252627282930&lt;!-- 自定义结果集:自己定义每一列数据和javaBean的映射规则 type=\"\":指定为哪个javaBean自定义封装规则，全类名 id=\"\":唯一标识，让别名在后面引用 select 上 resultMap属性指定自定义结果集id--&gt;&lt;resultMap id=\"myCat\" type=\"com.itnxd.bean.Cat\"&gt; &lt;!-- 指定主键列的对应规则; column= \"id\":指定哪一列是主键列 property=\"\":指定cat的哪个属性封装id这一列数据 当然主键也可以使用result标签，但使用id会告诉mybatis是主键，底层会做一些优化！ --&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;!--普通列--&gt; &lt;result property=\"name\" column=\"cname\"/&gt; &lt;result property=\"gender\" column=\"cgender\"/&gt; &lt;result property=\"age\" column=\"cage\"/&gt;&lt;/resultMap&gt;&lt;!--使用--&gt;&lt;select id=\"getCatById\" resultMap=\"myCat\"&gt; select * from t_cat where id = #{id}&lt;/select&gt; ¶5、联合查询 Key类和Lock类： 1234567891011121314151617181920public class Key { private Integer id; private String keyName; private Lock lock; // 当前钥匙可开哪把锁子 ...}public class Lock { private Integer id; private String lockName; // 将锁子对应的钥匙全部查到 private List&lt;Key&gt; keys; ...} ¶5.1、级联属性 12345678910111213141516&lt;!--&lt;select id=\"getKeyById\" resultType=\"com.itnxd.bean.Key\"&gt;--&gt;&lt;select id=\"getKeyById\" resultMap=\"myKey\"&gt; SELECT k.*, l.id lid, l.`lockName` FROM t_key k LEFT JOIN t_lock l ON k.`lockid`=l.`id` WHERE k.`id`=1&lt;/select&gt;&lt;!--自定义ResultMap--&gt;&lt;resultMap id=\"myKey\" type=\"com.itnxd.bean.Key\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"keyName\" column=\"keyName\"/&gt; &lt;result property=\"lock.id\" column=\"lid\"/&gt; &lt;result property=\"lock.lockName\" column=\"lockName\"/&gt;&lt;/resultMap&gt; ¶5.2、association（推荐） 比直接自定义更方便！处理JavaBean内的JavaBean！ 123456789101112131415161718192021&lt;!--&lt;select id=\"getKeyById\" resultType=\"com.itnxd.bean.Key\"&gt;--&gt;&lt;select id=\"getKeyById\" resultMap=\"myKey\"&gt; SELECT k.*, l.id lid, l.`lockName` FROM t_key k LEFT JOIN t_lock l ON k.`lockid`=l.`id` WHERE k.`id`=1&lt;/select&gt;&lt;!--2. mybatis推荐的association标签--&gt;&lt;resultMap id=\"myKey\" type=\"com.itnxd.bean.Key\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"keyName\" column=\"keyName\"/&gt; &lt;!--处理对象封装规则，用association，表示联合了一个对象--&gt; &lt;association property=\"lock\" javaType=\"com.itnxd.bean.Lock\"&gt; &lt;!--定义如何封装--&gt; &lt;id property=\"id\" column=\"lid\"/&gt; &lt;result property=\"lockName\" column=\"lockName\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; ¶5.3、collection 处理JavaBean内的集合！ 1234567891011121314151617181920212223242526272829&lt;select id=\"getLockById\" resultMap=\"myLock\"&gt; SELECT l.*, k.id kid, k.`keyName`, k.`lockId` FROM t_lock l LEFT JOIN t_key k ON k.`lockid`=l.`id` WHERE l.`id`=#{id}&lt;/select&gt;&lt;!--3. 使用collection查询集合--&gt;&lt;resultMap id=\"myLock\" type=\"com.itnxd.bean.Lock\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"lockName\" column=\"lockName\"/&gt; &lt;!-- collection:定义集合元素的封装 property=\"\":指定哪个属性是集合属性 javaType:指定对象类型; association ofType=\"\":指定集合里面元素的类型 --&gt; &lt;collection property=\"keys\" ofType=\"com.itnxd.bean.Key\"&gt; &lt;id property=\"id\" column=\"kid\"/&gt; &lt;result property=\"keyName\" column=\"keyName\"/&gt; &lt;!--疯狂套娃--&gt; &lt;!--&lt;association property=\"lock\" javaType=\"com.itnxd.bean.Lock\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"lockName\" column=\"lockName\"/&gt; &lt;/association&gt;--&gt; &lt;/collection&gt;&lt;/resultMap&gt; ¶6、分步查询 也就是一步步查，下一步根据上一步结果继续查询，直到查到最终结果！ 对于分步查询，我们可以开启延迟加载：即对于分的步，用到的时候再去发送sql语句！ 全局开启延迟加载 可使用fetch设置进行局部配置开或关（当然是在全局已经开启的情况下）默认为 fetchType=\"lazy\" ,如果本次的查询不想使用延迟加载，则可设置为fetchType=\"eager\" mybatis-config.xml： 1234567891011&lt;settings&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--开启属性延迟加载 开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;&lt;/settings&gt; KeyDao.xml文件： 1234567891011&lt;resultMap id=\"myKeySimple\" type=\"com.itnxd.bean.Key\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"keyName\" column=\"keyName\"/&gt; &lt;!--- fetchType：配置是否懒加载！ 全局已经配置为支持懒加载！ --&gt; &lt;association property=\"lock\" select=\"com.itnxd.dao.LockDao.getLockByIdSimple\" column=\"lockId\" fetchType=\"lazy\"/&gt;&lt;/resultMap&gt; 例子一：先根据获取lockId获取锁子信息，再将信息封装到key对象内！ KeyDao.xml文件： 123456789101112131415161718192021222324252627&lt;!--4. 分步查询--&gt;&lt;!--查询时带上锁子信息--&gt;&lt;select id=\"getKeyByIdSimple\" resultMap=\"myKeySimple\"&gt; SELECT * from t_key where id = #{id}&lt;/select&gt;&lt;!--id keyName lockId --&gt;&lt;resultMap id=\"myKeySimple\" type=\"com.itnxd.bean.Key\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"keyName\" column=\"keyName\"/&gt; &lt;!---告诉mybatis自己去调用一个查询查锁子 select=\"\":指定一个查询sql的唯一标识:mybatis自动调用指定的sql将查出的lock封装进来 防止id重复加上LockDao.xml的文件namespace Lock getLockByIdSimple(Integer id); 需要传入锁子id告诉mybatis把哪一列的值传递过去 column:指定将哪一列的数据传递过去 fetchType：配置是否支持懒加载！ 全局已经配置为支持懒加载！ --&gt; &lt;association property=\"lock\" select=\"com.itnxd.dao.LockDao.getLockByIdSimple\" column=\"lockId\" fetchType=\"lazy\"/&gt;&lt;/resultMap&gt; LockDao.xml文件： 123&lt;select id=\"getLockByIdSimple\" resultType=\"com.itnxd.bean.Lock\"&gt; SELECT * from t_lock where id = #{id}&lt;/select&gt; 例子二：先根据锁子id获取获取对应的所有钥匙，再将得到结果封装到keys属性！ LockDao.xml文件： 1234567891011121314&lt;!--Lock getLockByIdByStep(Integer id);--&gt;&lt;select id=\"getLockByIdByStep\" resultMap=\"myLockStep\"&gt; SELECT * from t_lock where id = #{id}&lt;/select&gt;&lt;!--collection分步查询--&gt;&lt;resultMap id=\"myLockStep\" type=\"com.itnxd.bean.Lock\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"lockName\" column=\"lockName\"/&gt; &lt;!--指定集合类型的类型属性的封装规则--&gt; &lt;collection property=\"keys\" select=\"com.itnxd.dao.KeyDao.getKeysByLockId\" column=\"id\"/&gt;&lt;/resultMap&gt; KeyDao.xml文件： 12345&lt;!--List&lt;Key&gt; getKeysByLockId(Integer id);--&gt;&lt;!--按照锁子id查出所有key--&gt;&lt;select id=\"getKeysByLockId\" resultType=\"com.itnxd.bean.Key\"&gt; select * from t_key where lockId = #{id}&lt;/select&gt; ¶7、关联关系中外键的选择 一对一关联：随便 一对多关联：多的一端 多对多关联：中间表存储对应关系 ¶五、动态Sql ¶0、EGNL表达式 用于下面test属性的条件书写！ OGNL（ Object Graph Navigation Language ）对象图导航语言，这是一种强大的表达式语言，通过它可以非常方便的来操作对象属性。 类似于我们的 EL。 访问对象属性： person.name 调用方法： person.getName() 调用静态属性/方法： @java.lang.Math@PI，@java.util.UUID@randomUUID() 调用构造方法： new com.atguigu.bean.Person(“admin”).name 运算符： +,-*,/,% 逻辑运算符： in,not in,&gt;,&gt;=,&lt;,&lt;=,==,!= 注意：xml 中特殊符号如”,&gt;,&lt;等这些都需要使用转义字符 ¶1、if标签 后面添加and用于连接！ 123456&lt;if test=\"id != null\"&gt; id &gt;= #{id} and&lt;/if&gt;&lt;if test=\"name != null &amp;amp;&amp;amp; !name.equals(&amp;quot;&amp;quot;) \"&gt; teachName like #{name} and&lt;/if&gt; ¶2、where标签 where可以不用手写，使用标签where，还可以过滤多余的and，or！ 注意：只能过滤条件前面的！不能过滤后面的！ 1234567891011&lt;where&gt; &lt;if test=\"id != null\"&gt; id &gt;= #{id} &lt;/if&gt; &lt;if test=\"name != null &amp;amp;&amp;amp; !name.equals(&amp;quot;&amp;quot;) \"&gt; and teachName like #{name} &lt;/if&gt; &lt;if test=\"birth != null\"&gt; and birth_date &amp;lt; #{birth} &lt;/if&gt;&lt;/where&gt; ¶3、trim标签 可以用于过滤前后多余字符！ 12345678910111213141516171819202122&lt;!-- prefix=\"\":前缀;为我们下面的sql整体添加一个前缀 prefixoverrides=\"\":取出整体字符串前面多余的字符 suffix=\"\"，为整体添加一个后缀 suffixoverrides=\"\":后面哪个多了可以去掉 推荐： 我们的查询条件就放在where标签中;每个and写在前面，where帮我们自动取除前面 多余的and--&gt;&lt;trim prefix=\"where\" prefixOverrides=\"and\" suffixOverrides=\"and\"&gt; &lt;if test=\"id != null\"&gt; id &gt;= #{id} &lt;/if&gt; &lt;if test=\"name != null &amp;amp;&amp;amp; !name.equals(&amp;quot;&amp;quot;) \"&gt; and teachName like #{name} &lt;/if&gt; &lt;if test=\"birth != null\"&gt; and birth_date &amp;lt; #{birth} &lt;/if&gt;&lt;/trim&gt; ¶4、foreach标签 遍历集合！ collection：指定要便利集合的key,List只能填list 解决：使用@Param注解指明key 123456789101112131415161718192021222324252627282930&lt;!--List&lt;Teacher&gt; getTeacherByIdIn(List&lt;Integer&gt; ids);--&gt;&lt;!--类型于sql中的in--&gt;&lt;select id=\"getTeacherByIdIn\" resultMap=\"myTeacher\"&gt; select * from t_teacher where id in &lt;!-- 4. foreach遍历集合 collection：指定要便利集合的key,List只能填list 解决：使用@Param注解指明key collection=\":指定要遍历的集合的key close=\"\";以什么结束 index=\"i\":索引; 如果遍历的是一个list; index:指定的变量保存了当前索引i item:保存当前遍历的元素的值 如果遍历的是一-个map: index:指定的变量就是保存了当前遍历的元素的key item:就是保存当前遍历的元素的值 item=\"变量名\":每次遍历出的元素起一个变量名方便引用 open=\"\":以什么开始 separator=\"\";每次遍历的元素的分隔符 --&gt; &lt;!--可以使用OGNL表达式的伪属性，详见ppt63页--&gt; &lt;if test=\"ids.isEmpty\"&gt;&lt;/if&gt; &lt;foreach collection=\"ids\" open=\"(\" close=\")\" item=\"id_item\" separator=\",\"&gt; #{id_item} &lt;/foreach&gt;&lt;/select&gt; ¶5、choose标签 类似switch case！ 123456789101112131415161718192021222324&lt;!--List&lt;Teacher&gt; getTeacherByConditionChose(Teacher teacher);5. choose(类似switch case)--&gt;&lt;select id=\"getTeacherByConditionChose\" resultMap=\"myTeacher\"&gt; select * from t_teacher &lt;where&gt; &lt;choose&gt; &lt;when test=\"id != null\"&gt; id = #{id} &lt;/when&gt; &lt;when test=\"name != null and !name.equals(&amp;quot;&amp;quot;)\"&gt; teachName = #{name} &lt;/when&gt; &lt;when test=\"birth != null\"&gt; birthDate = #{birth} &lt;/when&gt; &lt;otherwise&gt; 1 = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; ¶6、set标签 set 替换原生的update(可以解决逗号多余问题) 12345678910111213141516171819202122&lt;!-- int updateTeacher(Teacher teacher);6. set 替换原生的update(可以解决逗号多余问题)传入啥就修改啥--&gt;&lt;update id=\"updateTeacher\"&gt; update t_teacher &lt;set&gt; &lt;if test=\"name != null and !name.equals(&amp;quot;&amp;quot;)\"&gt; teachName = #{name}, &lt;/if&gt; &lt;if test=\"course != null and !course.equals(&amp;quot;&amp;quot;)\"&gt; class_name = #{course}, &lt;/if&gt; &lt;if test=\"address != null\"&gt; class_name = #{course}, &lt;/if&gt; &lt;if test=\"birth != null\"&gt; birth_date = #{birth) &lt;/if&gt; &lt;/set&gt; &lt;where&gt; id = #{id} &lt;/where&gt;&lt;/update&gt; ¶7、bind标签（了解） 对于传递进来的属性绑定一些内容，例如模糊匹配等等！ 12345678910111213141516171819202122&lt;!--7. bind标签 （一般不用，修改匹配规则麻烦）--&gt;&lt;select id=\"\"&gt; select * from t_teacher &lt;where&gt; &lt;if test=\"id != null\"&gt; id &gt;= #{id} &lt;/if&gt; &lt;!-- 绑定一个表达式的值到一个变量 将value: \"%name%\" 绑定到name属性的_name --&gt; &lt;bind name=\"_name\" value=\"'%' + name + '%'\"/&gt; &lt;if test=\"name != null &amp;amp;&amp;amp; !name.equals(&amp;quot;&amp;quot;) \"&gt; and teachName like #{name} &lt;/if&gt; &lt;if test=\"birth != null\"&gt; and birth_date &amp;lt; #{birth} &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; ¶8、sql标签 抽取可重用sql！ 123456789101112&lt;!--8. sql标签 抽取可重用sql include 标签包含可重用sql--&gt;&lt;sql id=\"selectSql\"&gt; select * from t_teacher&lt;/sql&gt;&lt;select id=\"\"&gt; &lt;include refid=\"selectSql\"/&gt;&lt;/select&gt; ¶六、缓存机制 自然是将查过的数据保存下来，方便下一次使用，而无需再次查询！ ¶1、一级缓存 Sqlsession级别缓存，也就是说每次会话关闭会自动清空缓存！ 每次查询，先看一级缓存中有没有，如果没有就去发送新的sql，每个sqlSession拥有自己的一级缓存! 一级缓存失效的几种情况： 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同，由于可能之前没查询过，所有还会发新的sql 同一个SqlSession两次查询期间执行了任何一次增删改操作，增删改操作会把缓存清空 同一个SqlSession两次查询期间手动清空了缓存（调用session.clearCache()） 一级缓存的工作机制： 同一次会话期间只要查询过的数据都会保存在当前 SqlSession 的一个 Map 中！ key: hashCode+查询的 Sqlid+编写的 sql 查询语句+参数 ¶2、二级缓存 namespace级别缓存，全局作用域缓存！ 一级缓存 SqlSession关闭或者提交以后, 一级缓存的数据会放在二级缓存中！ 二级缓存默认不开启，需要手动配置！ 全局配置mybatis-config.xml开启二级缓存： 1234&lt;!-- 开启全局缓存开关;--&gt;&lt;setting name= \"cacheEnabled\" value=\"true\"/&gt; 配置某个dao.xml文件，让其使用二级缓存： 12&lt;!--开启全局缓存（二级缓存）--&gt;&lt;cache/&gt; 每个实体类JavaBean都要加上implements Serializable 123public class Teacher implements Serializable { ...} 测试： 12345678910111213141516171819202122@Testpublic void test7() throws IOException, InterruptedException { String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // try中用完自动关闭，无需手动写！ try (SqlSession session = sqlSessionFactory.openSession(true)) { TeacherDao teacherDao = session.getMapper(TeacherDao.class); Teacher teacher = teacherDao.getTeacherById(1); System.out.println(teacher); } // 两次会话！ try (SqlSession session = sqlSessionFactory.openSession(true)) { TeacherDao teacherDao = session.getMapper(TeacherDao.class); Teacher teacher = teacherDao.getTeacherById(1); System.out.println(teacher); }} ¶3、二级缓存相关属性 12&lt;!--开启全局缓存（二级缓存）--&gt;&lt;cache/&gt; eviction=“FIFO”：缓存回收策略： LRU – 最近最少使用的：移除最长时间不被使用的对象。 FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 默认的是 LRU。 flushInterval：刷新间隔，单位毫秒，默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新 size：引用数目，正整数，代表缓存最多可以存储多少个对象，太大容易导致内存溢出 readOnly：只读，true/false true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。 false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全， 因此默认是 false。 ¶4、缓存相关属性设置 全局 setting 的 cacheEnable：配置二级缓存的开关，一级缓存一直是打开的。 select 标签的 useCache 属性：配置这个 select 是否使用二级缓存。一级缓存一直是使用的 sql 标签的 flushCache 属性：增删改默认 flushCache=true。sql 执行以后，会同时清空一级和二级缓存。查询默认 flushCache=false。 sqlSession.clearCache()：只是用来清除一级缓存。 ¶5、缓存原理 不会出现一级缓存和二级缓存中有同一个数据 二级缓存中：一级缓存关闭了就有了 一级缓存中：二级缓存中没有此数据，就会看一级缓存，一级缓存没有去查数据库 数据库的查询后的结果放在一级缓存中了 任何时候都是先看二级缓存、再看一级缓存，如果大家都没有就去查询数据库 缓存原理图示： ¶6、整合第三方缓存EhCache 原因：自带缓存太菜！ MyBatis留了一个Cache接口，可以让第三方进行实现！ EhCache非常专业的Java进程内的缓存框架！ ¶6.1、pom.xml导包 核心包和整合包，整合包（可选，不导包则需要自己继承Cache接口进行实现） 还依赖于slf4j-api和slf4j-log4j12 1234567891011121314151617181920212223242526&lt;!--第三方缓存--&gt;&lt;!-- https://mvnrepository.com/artifact/org.ehcache/ehcache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;3.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--针对mybatis对ehcache的实现（解决自己继承实现cache接口的步骤）--&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;2.0.0-alpha1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;2.0.0-alpha1&lt;/version&gt;&lt;/dependency&gt; ¶6.2、配置ehcache.xml 各个属性配置见下方注释！ 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\"&gt; &lt;!-- 磁盘保存路径 --&gt; &lt;diskStore path=\"D:\\ehcache\" /&gt; &lt;defaultCache maxElementsInMemory=\"100000\" maxElementsOnDisk=\"10000000\" eternal=\"false\" overflowToDisk=\"true\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; &lt;!-- 属性说明：l diskStore：指定数据在磁盘中的存储位置。l defaultCache：当借助CacheManager.add(\"demoCache\")创建Cache时，EhCache便会采用&lt;defalutCache/&gt;指定的的管理策略 以下属性是必须的：l maxElementsInMemory - 在内存中缓存的element的最大数目 l maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大l eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断l overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上 以下属性是可选的：l timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大l timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.l diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。l diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作l memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） --&gt; ¶6.3、在mapper.xmI中配置使用自定义的缓存 还可以使用cache-ref指定和其他dao.xml使用同一块缓存！ 12345&lt;!--使用第三方缓存ehcache--&gt;&lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/&gt;&lt;!--和别的Dao公用一块缓存--&gt;&lt;!--&lt;cache-ref namespace=\"com.itnxd.dao.TeacherDao\"/&gt;--&gt; ¶七、MyBatis逆向工程 MyBatis Generator: 简称 MBG，是一个专门为 MyBatis 框架使用者定制的代码生成器，可以快速的根据表生成对应的映射文件，接口，以及 bean 类。 可以通过数据库表生成对应的文件！ 官方地址：所有的配置都可以在这里找到详细答案，点击这里！ ¶1、pom.xml添加插件 该插件执行依赖于mybatis-generator-core和mysql-connector-java！ 指定配置文件地址： 12&lt;!--指定插件配置文件地址--&gt;&lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; 点击生成覆盖旧文件： 12&lt;!--如果相同直接覆盖--&gt;&lt;overwrite&gt;true&lt;/overwrite&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;build&gt; &lt;plugins&gt; &lt;!--MyBatis代码生成器插件 http://mybatis.org/generator/running/runningWithMaven.html --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;configuration&gt; &lt;!--指定插件配置文件地址--&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!--如果相同直接覆盖--&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 Mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; ¶2、generatorConfig.xml配置 配置插件详细配置，文件名和pom.xml配置相符即可！ 更详细配置参考官方文档！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;!--targetRuntime可指定生成级别，复杂sql或是简单sql http://mybatis.org/generator/configreference/context.html --&gt; &lt;context id=\"simple\" targetRuntime=\"MyBatis3\"&gt; &lt;!--指定连接的数据库信息--&gt; &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql:///mybatis\" password=\"xxxx\" userId=\"root\" /&gt; &lt;!-- 生成JavaBean： targetPackage：JavaBean的存放包的路径 targetProject：项目路径（包路径） --&gt; &lt;javaModelGenerator targetPackage=\"com.itnxd.bean\" targetProject=\"./src/main/java\"/&gt; &lt;!-- sql映射文件生成器，指定xml文件生成位置 --&gt; &lt;sqlMapGenerator targetPackage=\"com.itnxd.dao\" targetProject=\"src/main/resources\"/&gt; &lt;!--Dao接口生成器--&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.itnxd.dao\" targetProject=\"src/main/java\"/&gt; &lt;!-- 指定要生成的sql表 tableName：指定要生成的表 domainObjectName：这个表对应的JavaBean类 --&gt; &lt;table tableName=\"t_teacher\" domainObjectName=\"Teacher\"/&gt; &lt;table tableName=\"t_cat\" domainObjectName=\"Cat\"/&gt; &lt;table tableName=\"t_employee\" domainObjectName=\"Employee\"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; ¶3、生成所有文件 可以生成Bean，Dao，mapper.xml映射文件！ 双击命令即可！ 生成文件展示： ¶4、测试 xxxExample用来封装查询条件,null查询所有，没有条件！ 详细看下方代码！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Testpublic void test1() throws IOException { String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); try (SqlSession session = sqlSessionFactory.openSession()) { CatMapper catMapper = session.getMapper(CatMapper.class); Cat cat = catMapper.selectByPrimaryKey(1); System.out.println(cat); // xxxExample用来封装查询条件,null查询所有，没有条件 List&lt;Cat&gt; cats = catMapper.selectByExample(null); System.out.println(cats); // 封装查询条件的 /* and条件拼装到第一个criteria1 or条件拼装到第二个criteria2 再使用 xxxExample.or(criteria2);即可 */ CatExample catExample = new CatExample(); // Criteria：拼装查询条件 CatExample.Criteria criteria = catExample.createCriteria(); // and关系 criteria.andCnameLike(\"%猫%\"); criteria.andCageGreaterThan(3); // or关系（需要再次创建一个criteria） CatExample.Criteria criteria1 = catExample.createCriteria(); criteria1.andCageEqualTo(1); // or关系： catExample.or(criteria1); // 升序 catExample.setOrderByClause(\"id\"); // 降序 catExample.setOrderByClause(\"id desc\"); List&lt;Cat&gt; cats1 = catMapper.selectByExample(catExample); System.out.println(cats1); }} ¶八、SSM整合 整合完成项目结构图： ¶1、pom.xml导包 ¶1.1、Spring-IOC模块 1234567891011121314151617181920212223242526272829303132333435363738&lt;!--spring IOC 核心模块--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring日志依赖--&gt;&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; ¶1.2、Jdbc和事务模块 12345678910111213141516171819&lt;!--jdbc模块--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-orm --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt; ¶1.3、测试模块 12345678910111213141516&lt;!--测试模块--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--Junit--&gt;&lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.8.0-M1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; ¶1.4、AOP及动态代理模块 12345678910111213141516171819202122232425&lt;!--aop动态代理--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.aopalliance/com.springsource.org.aopalliance --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aopalliance&lt;/groupId&gt; &lt;artifactId&gt;com.springsource.org.aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; ¶1.5、SpringMvc模块 123456789101112131415161718&lt;!--springmvc模块--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt; ¶1.6、JSTL标签库 12345678910111213141516171819&lt;!--jstl-jar--&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jstl-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jstl-impl --&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jstl-impl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; ¶1.7、文件上传模块 1234567&lt;!--文件上传依赖--&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; ¶1.8、Hibernate的数据校验模块 12345678910111213&lt;!--hibernate的数据校验包--&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt; &lt;version&gt;6.0.0.Final&lt;/version&gt;&lt;/dependency&gt; ¶1.9、SpringMvc-Json-Ajax支持模块 12345678910111213141516171819&lt;!--SpringMvc-json-ajax--&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.12.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.12.2&lt;/version&gt;&lt;/dependency&gt; ¶1.10、谷歌验证码模块 由于谷歌官方并没有上传到Maven仓库，但是有人上传了，我们可以使用下面这个！ 1234567&lt;!--谷歌验证码--&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.penggle/kaptcha --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt; ¶1.11、MyBatis核心即整合Spring模块 1234567891011121314&lt;!--MyBatis核心--&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis整合spring包--&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt;&lt;/dependency&gt; ¶1.12、数据库驱动即连接池模块 1234567891011121314&lt;!--数据库驱动--&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt;&lt;/dependency&gt;&lt;!--c3p0数据库连接池--&gt;&lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt;&lt;/dependency&gt; ¶1.13、log4j日志模块 1234567&lt;!--loj4j日志，可以显示sql语句！--&gt;&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; ¶1.14、EhCache缓存模块 1234567891011121314151617181920212223242526&lt;!--第三方缓存--&gt;&lt;!-- https://mvnrepository.com/artifact/org.ehcache/ehcache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;3.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--针对mybatis对ehcache的实现（解决自己继承实现cache接口的步骤）--&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;2.0.0-alpha1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;2.0.0-alpha1&lt;/version&gt;&lt;/dependency&gt; ¶1.15、PageHelper分页插件模块 1234567&lt;!--分页插件依赖--&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt; ¶1.16、配置Maven打包resources下的xml到类路径 123456789101112131415161718192021&lt;!--处理maven不会把源文件路径下的配置文件打包到类路径！--&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt;&lt;!--所在的目录--&gt; &lt;includes&gt;&lt;!--包括目录下的.properties,.xml文件都会扫描到--&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; ¶2、web.xml配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--配置spring容器启动--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--指定spring配置文件位置--&gt; &lt;param-value&gt;classpath:spring/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置springmvc前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--两个标准配置--&gt; &lt;!--字符编码--&gt; &lt;!--配置请求和响应乱码，SpringMvc特有--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--支持REST风格的过滤器--&gt; &lt;!--为了支持REST，Spring需要使用Filter--&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;!--拦截所有请求--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; ¶3、Spring.xml配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mybatis-spring=\"http://mybatis.org/schema/mybatis-spring\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd\"&gt; &lt;!--配置分容器处理，禁用默认规则--&gt; &lt;context:component-scan base-package=\"com.itnxd\"&gt; &lt;!--除了Controller都要--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;!--&lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/&gt;--&gt; &lt;/context:component-scan&gt; &lt;!--0. 导入外部配置文件--&gt; &lt;context:property-placeholder location=\"classpath:dbconfig.properties\"/&gt; &lt;!--1. 配数据源--&gt; &lt;bean id=\"ds\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"user\" value=\"${jdbc.user}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/&gt; &lt;property name=\"driverClass\" value=\"${jdbc.driverClass}\"/&gt; &lt;property name=\"maxPoolSize\" value=\"${jdbc.maxPoolSize}\"/&gt; &lt;property name=\"minPoolSize\" value=\"${jdbc.minPoolSize}\"/&gt; &lt;/bean&gt; &lt;!--2. 配置JdbcTemplate操作数据库。pass--&gt; &lt;!--3. 配置使用mybatis操作数据库--&gt; &lt;!--可以根据配置文件得到sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!--指定mybatis配置文件路径--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis/mybatis-config.xml\"/&gt; &lt;!--指定用的数据源（即连接池）--&gt; &lt;property name=\"dataSource\" ref=\"ds\"/&gt; &lt;!--指定xml映射文件的位置--&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mybatis/mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!--我们要把每一个dao接口的实现加入到ioc容器--&gt; &lt;bean id=\"mapperScannerConfigurer\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!--指定dao接口所在包--&gt; &lt;property name=\"basePackage\" value=\"com.itnxd.dao\"/&gt; &lt;/bean&gt; &lt;!--或者--&gt; &lt;!--&lt;mybatis-spring:scan base-package=\"com.itnxd.dao\"/&gt;--&gt; &lt;!--4. 配置事务控制--&gt; &lt;!--配置事务控制器，控制数据源的关闭和提交--&gt; &lt;bean id=\"tm\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"ds\"/&gt; &lt;/bean&gt; &lt;!--5. 基于xml配置事务--&gt; &lt;aop:config&gt; &lt;!--配置切入点表达式--&gt; &lt;aop:pointcut id=\"txPoint\" expression=\"execution(* com.itnxd.service.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"myTx\" pointcut-ref=\"txPoint\"/&gt; &lt;/aop:config&gt; &lt;!--6. 配置事务增强，事务属性 transaction-manager= \"tm\":指定要配置的事务管理器的id --&gt; &lt;tx:advice id=\"myTx\" transaction-manager=\"tm\"&gt; &lt;!--配置事务属性--&gt; &lt;tx:attributes&gt; &lt;!--任何方法出现任何异常都回滚--&gt; &lt;tx:method name=\"*\" rollback-for=\"java.lang.Exception\"/&gt; &lt;!--get方法只读--&gt; &lt;tx:method name=\"get*\" read-only=\"true\"/&gt; &lt;!--配置插入方法隔离级别--&gt; &lt;!--&lt;tx:method name=\"insert*\" isolation=\"READ_UNCOMMITTED\"/&gt;--&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;/beans&gt; ¶4、SpringMvc.xml配置 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--开启组件扫描--&gt; &lt;!--配置分容器，SpringMvc只扫描除了Controller，禁用默认过滤规则--&gt; &lt;context:component-scan base-package=\"com.itnxd\" use-default-filters=\"false\"&gt; &lt;!--处理器注解--&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;!--进行错误控制的注解--&gt; &lt;!--&lt;context:include-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/&gt;--&gt; &lt;/context:component-scan&gt; &lt;!--配置视图解析器--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--配置文件上传解析器--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!--限制文件最大为20Mb --&gt; &lt;property name=\"maxUploadSize\" value=\"#{1024*1024*20}\"/&gt; &lt;!--设置编码--&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"/&gt; &lt;/bean&gt; &lt;!--扫描静态资源--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--扫描动态资源--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; ¶5、MyBatis.xml配置 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!--开启日志打印sql--&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; &lt;!--开启驼峰命名--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--开启属性延迟加载 开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt; &lt;!--开启全局缓存，默认为true,但最好显示开启--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/settings&gt; &lt;!--分页插件--&gt; &lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"/&gt; &lt;/plugins&gt; &lt;!--&lt;mappers&gt; &lt;package name=\"com.itnxd.dao\"/&gt; &lt;/mappers&gt;--&gt;&lt;/configuration&gt; ¶6、其他配置 ¶6.1、EhCache.xml配置 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\"&gt; &lt;!-- 磁盘保存路径 --&gt; &lt;diskStore path=\"D:\\ehcache\" /&gt; &lt;defaultCache maxElementsInMemory=\"100000\" maxElementsOnDisk=\"10000000\" eternal=\"false\" overflowToDisk=\"true\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; &lt;!-- 属性说明：l diskStore：指定数据在磁盘中的存储位置。l defaultCache：当借助CacheManager.add(\"demoCache\")创建Cache时，EhCache便会采用&lt;defalutCache/&gt;指定的的管理策略 以下属性是必须的：l maxElementsInMemory - 在内存中缓存的element的最大数目 l maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大l eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断l overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上 以下属性是可选的：l timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大l timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.l diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。l diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作l memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） --&gt; ¶6.2、log4j.xml配置 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"&gt;&lt;log4j:configuration xmlns:log4j=\"http://jakarta.apache.org/log4j/\"&gt; &lt;appender name=\"STDOUT\" class=\"org.apache.log4j.ConsoleAppender\"&gt; &lt;param name=\"Encoding\" value=\"UTF-8\" /&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \\n\" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=\"java.sql\"&gt; &lt;level value=\"debug\" /&gt; &lt;/logger&gt; &lt;logger name=\"org.apache.ibatis\"&gt; &lt;level value=\"info\" /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=\"debug\" /&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; ¶6.3、dbconfig.properties配置 123456jdbc.user=rootjdbc.password=xxxjdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql:///mybatisjdbc.maxPoolSize=20jdbc.minPoolSize=5 ¶7、测试 index.jsp页面： 12345678910111213141516171819&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%-- Created by IntelliJ IDEA. User: 15890 Date: 2021/4/8 Time: 15:32 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"getTeacher?id=1\"&gt;查询Teacher在success页面显示!&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; Controller程序： 12345678910@AutowiredTeacherService teacherService;@RequestMapping(\"/getTeacher\")public String getTeacher(@RequestParam(value = \"id\", defaultValue = \"1\") Integer id, Model model){ Teacher teacher = teacherService.getTeacherById(id); model.addAttribute(\"teacher\", teacher); return \"success\";} ¶九、PageHelper分页插件 PageHelper 是 MyBatis 中非常方便的第三方分页插件! 官方地址：官方项目地址！点击这里！ ¶1、pom.xml导包 1234567&lt;!--分页插件依赖--&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt; ¶2、MyBatis.xml配置 12345&lt;!--分页插件--&gt;&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"/&gt;&lt;/plugins&gt; ¶3、测试 Controller程序： 1234567891011121314151617181920212223242526@RequestMapping(\"/getAll\")public String getAll(@RequestParam(value = \"p\", defaultValue = \"1\") Integer p, Model model){ // 紧跟一次查询即可，这就是分页查询 PageHelper.startPage(p, 10); List&lt;Teacher&gt; list = teacherService.getAll(); // 第二个参数，连续要显示的页数 PageInfo&lt;Teacher&gt; pageInfo = new PageInfo&lt;&gt;(list, 5); System.out.println(\"当前页码：\" + pageInfo.getPageNum()); System.out.println(\"总页码：\" + pageInfo.getPages()); System.out.println(\"总记录数：\" + pageInfo.getTotal()); System.out.println(\"总记录数：\" + pageInfo.getTotal()); System.out.println(\"当前页记录条数：\" + pageInfo.getSize()); System.out.println(\"每页记录数\" + pageInfo.getPageSize()); System.out.println(\"前一页：\" + pageInfo.getPrePage()); System.out.println(\"取出pageInfo信息：\" + pageInfo.getList()); // 连续分页的int数组： int[] nums = pageInfo.getNavigatepageNums(); model.addAttribute(\"pageInfo\", pageInfo); /*model.addAttribute(\"teachers\", list);*/ return \"success\";} index.jsp页面： 123456789101112&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"getAll\"&gt;查询所有员工！&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; success.jsp页面： 取出从Model中传过来的pageInfo使用即可！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;success!&lt;/h1&gt;${teacher}&lt;br&gt;&lt;table cellspacing=\"0\" border=\"1\" cellpadding=\"5\"&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;course&lt;/th&gt; &lt;th&gt;address&lt;/th&gt; &lt;/tr&gt; &lt;%--&lt;c:forEach items=\"${teachers}\" var=\"teacher\"&gt;--%&gt; &lt;c:forEach items=\"${pageInfo.list}\" var=\"teacher\"&gt; &lt;tr&gt; &lt;td&gt;${teacher.id}&lt;/td&gt; &lt;td&gt;${teacher.name}&lt;/td&gt; &lt;td&gt;${teacher.course}&lt;/td&gt; &lt;td&gt;山西&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;tr&gt; &lt;td colspan=\"4\"&gt; &lt;a href=\"getAll?p=1\"&gt;首页&lt;/a&gt;&lt;a href=\"getAll?p=${pageInfo.prePage}\"&gt;前一页&lt;/a&gt; &lt;c:forEach items=\"${pageInfo.navigatepageNums}\" var=\"pageNum\"&gt; &lt;c:if test=\"${pageInfo.pageNum == pageNum}\"&gt; 【${pageNum}】 &lt;/c:if&gt; &lt;c:if test=\"${pageInfo.pageNum != pageNum}\"&gt; &lt;a href=\"getAll?p=${pageNum}\"&gt;${pageNum}&lt;/a&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;a href=\"getAll?p=${pageInfo.nextPage}\"&gt;后一页&lt;/a&gt;&lt;a href=\"getAll?p=${pageInfo.pages}\"&gt;末页&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库框架","slug":"数据库框架","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://www.itnxd.cn/tags/MyBatis/"},{"name":"PageHelper","slug":"PageHelper","permalink":"https://www.itnxd.cn/tags/PageHelper/"}],"author":"ITNXD"},{"title":"每日一题之AcWing 69.数组中数值和下标相等的元素","slug":"每日一题之AcWing-69-数组中数值和下标相等的元素","date":"2021-04-08T07:17:09.000Z","updated":"2021-04-10T07:57:27.596Z","comments":true,"path":"posts/31655.html","link":"","permalink":"https://www.itnxd.cn/posts/31655.html","excerpt":"","text":"题目连接：AcWing 69. 数组中数值和下标相等的元素 ¶一、题解 题目大意： 一个单调递增序列，有一些数是和下标匹配的，找出任意一个该数！ 思路： 很明显，还是二分，关键点，二分的核心：需要找到二段性是啥！ 从目标答案该数向左向右分析，可以得到： 该数左边，每个数都比下标要小 该数右边，每个数都比下标要大或相等 因此可以通过二分找到第二段第一个满足条件的即可，即第一个下标和数值匹配的数即可！ **时间复杂度： **O(logn) **空间复杂度： **O(1) ¶二、AC代码 参考代码： 12345678910111213class Solution {public: int getNumberSameAsIndex(vector&lt;int&gt;&amp; nums) { int l = 0, r = nums.size() - 1; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(nums[mid] &gt;= mid) r = mid; else l = mid + 1; } if(nums[r] == r) return r; return -1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"}],"author":"ITNXD"},{"title":"每日一题之LeetCode 154.寻找旋转排序数组中的最小值 II","slug":"每日一题之LeetCode-154-寻找旋转排序数组中的最小值-II","date":"2021-04-07T07:16:37.000Z","updated":"2021-04-10T07:57:27.599Z","comments":true,"path":"posts/23461.html","link":"","permalink":"https://www.itnxd.cn/posts/23461.html","excerpt":"","text":"题目链接：LeetCode 154. 寻找旋转排序数组中的最小值 II ¶一、题解 题目大意： 将一个递增序列（可能有重复元素）进行旋转，所谓旋转一次，就是将最后一个数和第一个数交换！要求旋转后的数组找到其最小值！ 思路： 仍然是二分，虽然本题的序列不是递增或递减，但是二分的本质是看是否有二段性！ 序列旋转过后一等会得到两个单调递增序列，由于有重复元素，因此旋转过后的第一段开始和第二段结束可能会有相等的部分！ 由于我们要找最小值，和重复元素无关，我们可以将第二段的重复元素先全部删掉！ 当然，全部删掉后若只剩下第一段，则直接返回第一点第一个点，即 nums[0] 这样第二段终点一定小于第一段起点！ 这样就有了二段性： 第一段都大于等于nums[0] 第二段都小于nums[0] 最终的答案当然就是第二段的第一个满足条件的点！ 时间复杂度： O(n)，若整段都是同样的数则会之间扫描一遍，因此达不到logn 空间复杂度： O(1) 、 ¶二、AC代码 参考代码： 123456789101112131415class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int n = nums.size() - 1; while(n &gt; 0 &amp;&amp; nums[n] == nums[0]) n --; if(nums[n] &gt; nums[0]) return nums[0]; int l = 0, r = n; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(nums[mid] &lt; nums[0]) r = mid; else l = mid + 1; } return nums[r]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"}],"author":"ITNXD"},{"title":"每日一题之AcWing 68.0到n-1中缺失的数字","slug":"每日一题之AcWing-68-0到n-1中缺失的数字","date":"2021-04-06T07:15:50.000Z","updated":"2021-04-10T07:57:27.588Z","comments":true,"path":"posts/20480.html","link":"","permalink":"https://www.itnxd.cn/posts/20480.html","excerpt":"","text":"题目连接：AcWing 68. 0到n-1中缺失的数字 ¶一、题解 题目大意： 0 到 n - 1 的数依次升序排列，其中有某个数不在该序列中！要求找出该数！ 思路： 很明显，是一道二分题目！ 但是最关键的是要找到如何二分，即这道题的二段性，也就是前一段满足一个条件而后一段满足另一个条件！ 还是很容易找到一个规律： 目标数的左边，都是下标和数值相等的 目标数的右边，都是下标和数值不相等的 因此我们可以利用二段性，二分出第一段最后一点，或者是第二段的第一个点！ 本题的答案当然就是第二段的第一个点，即第一个下标和数值不相等的点！ 还可以做一下特判，如果该序列的最后一个数 nums[n - 1] 与下标 n - 1 相同，直接返回 n！ 时间复杂度： O(logn) 空间复杂度： O(1) ¶二、AC代码 参考代码： 123456789101112131415class Solution {public: int getMissingNumber(vector&lt;int&gt;&amp; nums) { if(nums.empty()) return 0; int n = nums.size(); if(nums[n - 1] == n - 1) return n; int l = 0, r = n - 1; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(nums[mid] != mid) r = mid; else l = mid + 1; } return r; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"}],"author":"ITNXD"},{"title":"Spring全家桶之SpringMvc使用介绍","slug":"Spring全家桶之SpringMvc使用介绍","date":"2021-04-05T03:28:58.000Z","updated":"2021-04-08T09:56:39.934Z","comments":true,"path":"posts/22550.html","link":"","permalink":"https://www.itnxd.cn/posts/22550.html","excerpt":"","text":"¶一、SpringMvc概述 ¶1、SpringMvc概述 一种轻量级的、基于 MVC 的 Web 层应用框架。偏前端而不是基于业务逻辑层。Spring框架的一个后续产品！ MVC：新的软件架构模式 M: Model，模型，封装和映射数据(javaBean) V: View，视图，界面显示工作（.jsp) C: Controller，控制器，控制整个网站的跳转逻辑(Servlet) 概述： Spring 为展现层提供的基于 MVC 设计理念的优秀的 Web 框架，是目前最主流的MVC 框架之一 Spring3.0 后全面超越 Struts2，成为最优秀的 MVC 框架。 Spring MVC 通过一套 MVC 注解，让 POJO 成为处理请求的控制器，而无须实现任何接口。 支持 REST 风格的 URL 请求。 采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性。 ¶2、SpringMvc实现思想 看下图可知，SpringMvc将所有请求都交由Front Controller来进行控制处理！SpringMvc的核心部分就是前端控制器！ ¶3、第一个SpringMvc工程 这里我将使用IDEA的Maven项目进行创建！ ¶1、新建一个Maven模块 创建好的工程如图所示： ¶2、修改pom.xml 增加一行packaging标签，值为war，表示是一个web项目！ 点击IDEA右上方的标志，更新Maven项目 123456&lt;groupId&gt;com.itnxd.springmvc&lt;/groupId&gt;&lt;artifactId&gt;2_Test&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!--添加如下行--&gt;&lt;packaging&gt;war&lt;/packaging&gt; 如下图： ¶3、配置web.xml和web资源目录 点击Project Structure按钮 配置web.xml的路径并生成 配置web资源目录 我的路径如下： WebContent目录名可以随意起，但一般都是这个名！放的位置可以随意放，但一般放到工程目录下较为方便！ 123E:\\Java学习\\IdeaProject\\SpringMvc\\2_Test\\WebContent\\WEB-INF\\web.xmlE:\\Java学习\\IdeaProject\\SpringMvc\\2_Test\\WebContent 步骤如下图： 建好的目录结构如下： ¶4、使用Maven导包 需要导入spring基础包和支持web的包！ 使用自定义标签统一管理Spring包的版本！ pom.xml中配置如下： 配置完毕后点击右上角的Maven图标进行配置使用！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itnxd.springmvc&lt;/groupId&gt; &lt;artifactId&gt;2_Test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;14&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;14&lt;/maven.compiler.target&gt; &lt;!--统一管理spring版本--&gt; &lt;spring.version&gt;5.3.5&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--Spring基础核心模块--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--web模块--&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ¶5、web.xml配置 在这里需要配置前端控制器DispatcherServlet，SpringMvc最核心的部分！能拦截所有请求，并智能派发！ 关于前端控制器的拦截问题： Tomcat也有一个web.xml文件，处理*.jsp是Tomcat做的事，所有项目的web.xml都是继承于Tomcat服务器的web.xml! 服务器的web.xml中有一个DefaultServlet是url-pattern=/，该配置服务于静态资源（除jsp和servlet外都是静态资源），静态资源在Tomcat中不会被拦截而是会去服务器去找该资源文件进行返回！ 为何不可以访问静态资源：我们的配置中前端控制器url-pattern=/，相当于项目的配置覆盖了服务器DefaultServlet的配置，静态资源会通过前端控制器去RequestMapping去找对应的资源名，若没有相应的请求映射，则直接会返回错误 为何可以访问jsp：服务器的web.xml中有一个JspServlet，服务于jsp，不会进行拦截，而是去服务器去找到资源进行返回！我们并没有进行覆盖重写该配置，所以不会拦截jsp页面！ 12345678910DefaultServlet是Tomcat中处理静态资源的? 除过jsp，和servlet外剩下的都是静态资源; index.html:静态资源，tomcat就会在服务器下找到这个资源并返回; 我们前端控制器的/禁用了tomcat服务器中的DefaultServlet1）2） 静态资源会来到DispatcherServlet(前端控制器）看那个方法的RequestMapping是这个index.html，因为没有，所以无法访问3）为什么jsp又能访问？因为我们没有覆盖服务器中的JspServlet的配置4）/覆盖服务器的DefaultServlet，/*，*为通配符自然全部拦截。我们使用 /，可以迎合Rest风格的Url地址！ SpringMvc配置文件问题： 在DispatcherServlet中需要告知前端控制器SpringMvc的配置文件地址！可以使用init-param标签进行指定，param-value值中的/代表的地址是web资源根目录即WebContent/。 SpringMvc配置文件若不进行配置，则默认去web资源根目录/WEB-INF/xxx-servlet.xml去找！其中xxx代表servlet-name表现的值！ 一般，我们都将该配置文件放到WEB-INF下，并规范命名如上，即可省去该配置的书写！即如下部分可以省略！ 1234567&lt;init-param&gt; &lt;!-- 配置SpringMvc配置文件地址，也可不指定，使用默认即可！ --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/springmvc-servlet.xml&lt;/param-value&gt;&lt;/init-param&gt; 完整配置： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!-- SpringMvc思想是通过前端控制器拦截所有请求，并智能派发。 这个前端控制器是一个Servlet，需要在web.xml中配置！ --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--&lt;init-param&gt; &amp;lt;!&amp;ndash; 配置SpringMvc配置文件地址，也可不指定，使用默认即可！ &amp;ndash;&amp;gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt;--&gt; &lt;!-- 服务器启动创建对象，这里设置优先级，值越小，优先级越高！ --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 拦截请求： / ：除了jsp都进行拦截 /* ：全部拦截，拦截jsp会导致页面无法显示 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; ¶6、spingmvc-servlet.xml配置 开启组件扫描 可选：配置视图解析器来简化页面地址！ 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--开启组件扫描--&gt; &lt;context:component-scan base-package=\"com.itnxd\"&gt;&lt;/context:component-scan&gt; &lt;!--配置视图解析器：可以拼接页面地址--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;!--最终路径结果为：/WEB-INF/pages/xxx.jsp，xxx为jsp文件名--&gt; &lt;/bean&gt;&lt;/beans&gt; ¶7、第一个Controller程序 使用Controller注解表示创建对象，四个注解都可以，但Controller一般用于web层的servlet中！ 使用RequestMapping注解表示处理请求hello，返回值就是请求转发的地址！ 这里的地址可以由前面配置的视图解析器来简化，只需要简单的返回jsp文件名即可! 12345678910111213141516@Controllerpublic class MyController { /** * 请求映射：处理hello请求 * / : 代表当前项目 */ @RequestMapping(\"/hello\") public String myRequest(){ System.out.println(\"请求已收到！\"); // 表示返回请求转发地址！ // return \"/WEB-INF/pages/success.jsp\"; // 使用了视图解析器之后，可以简化为 return \"success\"; }} ¶8、运行结果 访问工程名/hello即可拦截并处理请求，转发到WEB-INF下的success.jsp页面！ ¶二、RequestMapping注解 指定可以处理那些请求！ DispatcherServlet 截获请求后，就通过控制器上 @RequestMapping 提供的映射信息确定请求所对应的处理方法。 ¶1、使用位置 方法上：则请求地址为/handle01 类上：则请求地址为/hello/handle01，即多了一层 注意： RequestMapping的value值可以省略/，但不建议省略！ 12345678910@RequestMapping(\"/hello\")@Controllerpublic class RequestMappingController { @RequestMapping(\"/handle01\") public String handle01(){ System.out.println(\"RequestMappingController.handle01()....\"); return \"success\"; }} ¶2、RequestMapping属性 value：默认属性，指定请求 method：限定请求方式，默认全接收，只支持POST,GET（表单只能发出这两种请求） HTTP请求类型：GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE 请求方式不匹配，会报错: HTTP状态 405 - 方法不允许 params：规定请求参数 params = {\"param1\"}：表示请求地址必须包含该参数，否则404 params = {\"!param1\"}：表示请求地址必须不包含该参数，否则404 params = {\"param1 != value1\"}：表示请求地址不带有该参数或者参数值不为value1，否则404 params = {“param1=value1”, “param2” ...}：表示同时满足多个要求 headers：规定请求头，和params一样可写简单的表达式！（同上） consumes：只接受内容类型为指定类型的请求，规定请求头中的Context-Type produces：告诉浏览器返回的内容类型是什么，给响应头添加Context-Type 12345678910// method参数：@RequestMapping(value = \"/handle02\", method = RequestMethod.POST)// params参数：@RequestMapping(value = \"/handle02\", params = {\"username\"})@RequestMapping(value = \"/handle02\", params = {\"!username\"})@RequestMapping(value = \"/handle02\", params = {\"username=aa\"})@RequestMapping(value = \"/handle02\", params = {\"username!=aa\"})@RequestMapping(value = \"/handle02\", params = {\"username=aa\", \"pwd\", \"!age\"}) // headers参数：以下表示只允许Edge浏览器访问！@RequestMapping(value = \"/handle03\", headers = {\"User-Agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Edg/89.0.774.57\"}) ¶3、RequestMapping模糊匹配 类似于正则表达式！ Ant 风格资源地址支持 3 种匹配符： ?：匹配任意一个字符 *：匹配任意多个字符和一层路径 **：匹配多层路径 注意：多个匹配，精确匹配优先！*和**，*优先！ 1234567// 模糊匹配举例：@RequestMapping(\"/ant01\") // 精确匹配@RequestMapping(\"/ant0?\") // 匹配一个字符@RequestMapping(\"/ant*\") // 匹配任意多个字符@RequestMapping(\"/a*/ant\") // 匹配一个字符@RequestMapping(\"/a/*/ant\") // 匹配一层路径@RequestMapping(\"/a/**/ant\") // 匹配多层路径 ¶4、PathVariable注解 用来处理RequestMapping映射地址中的占位符！ 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中！ URL 中的 {xxx} 占位符可以通过 @PathVariable(“xxx”) 绑定到操作方法的入参中！ 占位符格式：{xx} 12345@RequestMapping(\"/user/{id}\")public String PathVariableTest(@PathVariable(\"id\") String id){ System.out.println(id); return \"success\";} ¶三、REST ¶1、概述 REST：即 Representational State Transfer。（资源）表现层状态转化。是目前最流行的一种互联网软件架构。 系统希望以非常简洁的URL地址来发请求，可以使用请求方式来区分： GET查询 PUT更新 DELETE删除 POST添加 REST风格：/资源名/资源标识符 ¶2、使用 由于表单只能发送GET和POST请求，所以需要有一定的方法让程序可以识别到我们发的不同请求！ Spring提供了对Rest风格的支持！ SpringMVC中有一个Filter，他可以把普通的请求转化为规定形式的请求，配置这个HiddenHttpMethodFilter 建一个post类型的表单，携带一个 _method参数，参数值写 DELETE，PUT 注意： 8.x版本的Tomcat无法使用这两个请求，9和10正常！ 在jsp页面的上方添加isErrorPage=\"true\"，九大内置对象才会有exception对象！ 表示jsp页面若有错则封装到异常内，不要直接不执行！转发的jsp页面也要添加！ 在web.xml中配置： 12345678910&lt;!--为了支持REST，Spring需要使用Filter--&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;!--拦截所有请求--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; jsp页面： 123456789101112131415&lt;a href=\"book/1\"&gt;查询图书&lt;/a&gt;&lt;br&gt;&lt;form action=\"book\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"添加图书\"&gt;&lt;/form&gt;&lt;form action=\"book/1\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"put\"&gt; &lt;input type=\"submit\" value=\"修改图书\"&gt;&lt;/form&gt;&lt;form action=\"book/1\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"delete\"&gt; &lt;input type=\"submit\" value=\"删除图书\"&gt;&lt;/form&gt; Controller程序： 123456789101112131415161718192021222324@Controllerpublic class BookController { @RequestMapping(value = \"/book/{id}\", method = RequestMethod.GET) public String getBook(@PathVariable(\"id\") Integer id){ System.out.println(\"查询到了\" + id + \"号图书！\"); return \"success\"; } @RequestMapping(value = \"/book\", method = RequestMethod.POST) public String addBook(){ System.out.println(\"添加了图书！\"); return \"success\"; } @RequestMapping(value = \"/book/{id}\", method = RequestMethod.DELETE) public String deleteBook(@PathVariable(\"id\") Integer id){ System.out.println(\"删除了\" + id + \"号图书！\"); return \"success\"; } @RequestMapping(value = \"/book/{id}\", method = RequestMethod.PUT) public String updateBook(@PathVariable(\"id\") Integer id){ System.out.println(\"修改了\" + id + \"号图书！\"); return \"success\"; }} ¶3、非form标签发送不支持的请求方式 外部新增一个表单 通过JS更改该表单的action的值，并进行提交即可！ 123456789101112131415161718192021222324252627&lt;td&gt; 解决form表单造成的按钮样式 &lt;form action=\"${ctp}/emp/${emp.id}\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"delete\"&gt; &lt;input type=\"submit\" value=\"Delete\"&gt; &lt;/form&gt; &lt;a href=\"${ctp}/emp/${emp.id}\" class=\"deleteBtn\"&gt;Delete&lt;/a&gt;&lt;/td&gt;&lt;%--解决方案--%&gt;&lt;form id=\"deleteForm\" action=\"\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"DELETE\"/&gt;&lt;/form&gt;&lt;script&gt; $(function (){ $(\".deleteBtn\").click(function (){ // 1. 修改表单action为上方的删除连接 $(\"#deleteForm\").attr(\"action\", this.href); // 2. 提交表单 $(\"#deleteForm\").submit(); // 阻止默认超链接行为 return false; }); });&lt;/script&gt; ¶四、处理请求数据 ¶1、RequestParam 注解 用来获取请求参数！ 入参和请求参数名一样可以自动获取(请求地址没有该参数则为null,该参数=后不写则为空串) 可以使用@RequsetParam注解来获取请求参数，使用该注解则请求地址必须携带该参数，否则400 属性： value：指定获取参数的key default：设置默认value值 required：是否必须带该参数（默认为true） @PathVariable 和 @RequestParam 区分： @PathVariable：获取路径占位符（?号前的占位符） @RequestParam：获取请求参数（?后后的参数） 123456@RequestMapping(\"/nxd\")//public String handle01(@RequestParam(value = \"user\", required = false, defaultValue = \"你没带参数\") String user){public String handle01(@RequestParam(\"user\") String user){ System.out.println(user); return \"success\";} ¶2、RequestHeader注解 获取请求头重某个参数的值！ 注意：若没有该参数则报错500 属性： value：指定获取参数的key default：设置默认value值 required：是否必须带该参数（默认为true） 12345@RequestMapping(\"/nxd\")public String handle01(@RequestHeader(\"User-Agent\") String userAgent){ System.out.println(userAgent); return \"success\";} ¶3、CookieValue 注解 获取某个cookie值！ 属性： value：指定获取参数的key default：设置默认value值 required：是否必须带该参数（默认为true） ​ 12345@RequestMapping(\"/nxd\")public String handle01(@CookieValue(\"JSESSIONID\") String cookie){ System.out.println(cookie); return \"success\";} ¶4、使用 JavaBean作为参数 如果我们的请求参数是一个JavaBean，SpringMVC会自动的为这个JavaBean进行赋值！ 从request参数中尝试获取出来，并封装为JavaBean对象 还可以级联赋值（套娃操作，JavaBean中有JavaBean） 自然：想要成功赋值，最好保证属性名一致！ Controller： 12345@RequestMapping(\"/addBook\")public String addBook(Book book){ System.out.println(book); return \"success\";} jsp页面： 注意：级联嵌套操作，嵌套的类需要使用类名首字母小写.属性作为name属性！ 123456789101112&lt;form action=\"addBook\" method=\"post\"&gt; 书名：&lt;input type=\"text\" name=\"bookName\"&gt;&lt;br&gt; 作者：&lt;input type=\"text\" name=\"author\"&gt;&lt;br&gt; 价格：&lt;input type=\"text\" name=\"price\"&gt;&lt;br&gt; 库存：&lt;input type=\"text\" name=\"stock\"&gt;&lt;br&gt; 销量：&lt;input type=\"text\" name=\"sales\"&gt;&lt;br&gt; 省份：&lt;input type=\"text\" name=\"address.province\"&gt;&lt;br&gt; 城市：&lt;input type=\"text\" name=\"address.city\"&gt;&lt;br&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; Book类： Book中有Address！ 1234567891011public class Book { private String bookName; private String author; private Double price; private Integer stock; private Integer sales; private Address address; ....} Address类： 123456public class Address { private String province; private String city; .....} 解决中文乱码：上面的测试在有中文情况下会发生乱乱，无法正确封装为JavaBean对象！ 解决方案：请查看下一小节！ ¶5、SpringMvc解决请求响应乱码 请求乱码： GET请求：改Tomcat的配置文件server.xml;在8080端口处 URLEncoding=\"UTF-8\"（实测这个GET请求乱码无需处理） POST请求： 在第一次获取请求参数之前设置 request.setCharacterEncoding(\"utf-8\"); 若没有使用到request对象，可以在filter中设置，SpringMvc已经有了该filter, 在web.xml中设置 响应乱码: 在第一次获取响应参数之前设置`response.setContentType(\"text/html; charset=utf-8);` 新版的SpringMvc也可以在web.xml中进行配置 注意：该处理编码的filter一定要配置在其他filter的最前面，否则请求将会被前面的filter拦截！导致无法生效！ 建议： 使用SpringMVC前端控制器写完就直接写字符编码过滤器 Tomcat一装上，上手就是server.xml的8080处添加URIEncoding=\"UTF-8\"（实测这个GET请求乱码无需处理） web.xml： SpringMvc的处理编码的Filter：CharacterEncodingFilter，可以点进去看这个类的属性，有三个属性： encoding：编码格式 forceRequestEncoding：强制设置请求编码为encoding的值 forceResponseEncoding：强制设置响应编码为encoding的值，但这里并没有设置文件类型，可以在使用的地方进行设置 123456789101112131415161718192021222324252627&lt;!--配置请求和响应乱码，SpringMvc特有--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- CharacterEncodingFilter该类中有三个属性！ encoding：编码格式 forceRequestEncoding：强制设置请求编码为encoding的值 forceResponseEncoding：强制设置响应编码为encoding的值，但这里并没有设置文件类型，可以在使用的地方进行设置 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; ¶5、使用 Servlet 原生 API 作为参数 SpringMVC可以直接在参数上写原生API pom.xml中添加servlet-api： 12345&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt; 这些类使用需要导入Servlet-api 九大原生API： HttpServletRequest HttpServletResponse HttpSession java.security.Principal：https安全协议相关 Locale：国际化相关 InputStream：字节流 OutputStream：字节流 Reader：字符流 Writer：字符流 12345678910111213@RequestMapping(\"/handle02\")public String handle02(HttpSession session, HttpServletRequest request, HttpServletResponse response){ request.setAttribute(\"requestParam\", \"reqScope\"); session.setAttribute(\"sessionParam\", \"SessScope\"); // ServletInputStream inputStream = request.getInputStream(); // ServletOutputStream outputStream = response.getOutputStream(); // BufferedReader reader = request.getReader(); // PrintWriter writer = response.getWriter(); return \"success\";} ¶五、处理响应数据 SpringMvc提供了几种途径输出模型数据! ¶1、ModelAndView 处理方法返回值类型为 ModelAndView 时, 方法体可通过该对象添加模型数据！ （返回值）ModelAndView：既可传递数据又可去到相应页面！用在返回值类型！ 数据放在是request域中！ 12345678910@RequestMapping(\"/hh04\")public ModelAndView handle04(){ // 之前的返回值我们就叫视图名，视图解析器是会帮我们最终拼串得到页面的真实地址; // ModelAndView mav = new ModelAndView(\"success\"); ModelAndView mav = new ModelAndView(); // 或者这样： mav.setViewName(\"success\"); mav.addObject(\"msg\", \"你好！\"); return mav;} ¶2、Map和Model 入参为 org.springframework.ui.Model、org.springframework.ui.ModelMap 或 java.uti.Map 时，处理方法返回时，Map 中的数据会自动添加到模型中。 （传参）可以在方法处传入Map、或者Model或者ModelMap。给这些参数里面保存的所有数据都会放在域中。 Map、Model、ModelMap： 三者都是request域！ 三者具体类都是：BindingAwareModelMap 只要是BindingAwareModelMap,就会保存到request域中! 关系： Map：jdk中的接口 Model：spring中的接口 ModelMap：class BindingAwareModelMap：继承ModelMap实现Model 123456789101112131415161718@RequestMapping(\"/hh02\")public String handle02(Model model){ model.addAttribute(\"msg\", \"你好\"); System.out.println(model.getClass()); return \"success\";}@RequestMapping(\"/hh03\")public String handle03(ModelMap modelMap){ modelMap.addAttribute(\"msg\", \"你好\"); System.out.println(modelMap.getClass()); return \"success\";}@RequestMapping(\"/hh04\")public String handle04(Map&lt;String, Object&gt; map){ map.put(\"msg\", \"你好\"); System.out.println(map.getClass()); return \"success\";} ¶3、ModelAttribute 注解 方法入参标注该注解后, 入参的对象就会放到数据模型中！ 以前用于和hibernate结合使用，现在都是mybatis,几乎不用了！ 使用该注解的方法会提前于处理请求程序之前运行！ 实际场景应用场景： 并不是全字段修改，只会修改部分字段！ 不修改的字段可以在页面进行展示但是不要提供修改输入框，为了简单，Controller直接在参数位置来写Book对象，SpringMVC为我们自动封装book，（没有带的值是nul1)，如果接下来调用了一个全字段更新的dao操作，会将其他的字段可能变为null。 解决方法： 通过判断是否为空进行sql拼串来实现动态sql！太麻烦 另一个方法：(依赖于@ModelAttribute注解) 让SpringMVC别创建book对象，直接从数据库中取出对应id的数据 使用刚才从数据库取出的book对象，给它的里面设置值，（非null的进行设置，否则不进行设置） 将之前从数据库查到的对象，并且封装了请求参数的对象进行保存即可！ @ModelAttribute： 参数位置：目标方法入参前添加该注解获取提前方法的保存的对象 方法位置：这个方法就会提前于目标方法先运行(即标了该注解的方法会先执行)，并把方法的运行结果放在隐含模型中！ 该方法提前运行，则我们可以提前从数据库中查询出该对象！ 将该对象保存起来 告诉SpringMvc不要new了，使用这里从数据库查询到的book 使用注解@ModelAttribute，在入参前添加即可！ 存入隐含模型会使用一个key值： 如果@ModelAttribute注解指定value值，则该value值作为key 否则返回值类型首字母小写作为key值（Book类型，则key值为book） ​ 注意： 两个方法中的map和model是同一个对象！ 两个方法中的book也是同一个对象！ jsp页面： 123456789&lt;form action=\"hhh01\" method=\"post\"&gt; 书名：西游记&lt;br&gt; 作者：&lt;input type=\"text\" name=\"author\"&gt;&lt;br&gt; 价格：&lt;input type=\"text\" name=\"price\"&gt;&lt;br&gt; 库存：&lt;input type=\"text\" name=\"stock\"&gt;&lt;br&gt; 销量：&lt;input type=\"text\" name=\"sales\"&gt;&lt;br&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; Controller： 提前执行： 12345678910@ModelAttributepublic Book ModelAttributeTest(Map&lt;String, Object&gt; map){ Book book = new Book(1, \"dd\", \"dd\", 33.22, 33, 33); // 放到了隐含模型中！ map.put(\"hh\", book); map.put(\"book\", book); System.out.println(\"数据库中的book:\" + book); System.out.println(\"ModelAttribute...数据库查完并进行了保存！\"); return book;} 目标方法： 12345@RequestMapping(\"/hhh01\")public String updateBook(@ModelAttribute(\"book\") Book book, Model model){ System.out.println(book); return \"success\";} 总结：实际操作中，一般不使用ModelAttribute注解传key或返回值传key，大多都是使用Map进行put操作，更加方便，可以处理多个数据！ ¶4、SessionAttributes 注解（了解） 将模型中的某个属性暂存到 HttpSession 中，以便多个请求之间可以共享这个属性! SpringMVC提供了一种可以临时给Session域中保存数据的方式，使用一个注解@SessionAttributes，该注解只能标在类上 属性： value属性：只要key与该注解value属性的值匹配则同时给session中放一份; types属性：只要value类型与该注解types属性匹配则给session中放一份 建议： 后来推荐@SessionAttributes就别用了，可能会引发异常 给session中放数据请使用原生API 该注解最好不要使用： 为了避免可能引发的异常，若要使用，需要保证两点 要么隐含模型中有@sessionAttributes标注的属性 如果隐含模型中有，session还说有就一定要有。否则抛异常！ 12345@SessionAttributes(value = {\"msg\", \"hh\"}, types = {String.class})@Controllerpublic class OutputController { .....} ¶5、通过分析源码得到几种情况 验证自定义类型参数book的赋值情况！ ModelAttribute注解有value，则隐含模型通过该value值获取隐含模型中的key获取，标注ModelAttribute注解的提前执行方法中的map.put操作就是放到隐含模型的操作！ 1234567891011121314@RequestMapping(\"/hhh01\")public String updateBook(@ModelAttribute(\"hh\") Book book){ System.out.println(book); return \"success\";}@ModelAttributepublic void ModelAttributeTest(Map&lt;String, Object&gt; map){ Book book = new Book(1, \"dd\", \"dd\", 33.22, 33, 33); // 放到了隐含模型中！ map.put(\"hh\", book); System.out.println(\"数据库中的book:\" + book); System.out.println(\"ModelAttribute...数据库查完并进行了保存！\");} 没有ModelAttribute注解，则隐含模型使用参数类型Book首字母小写作为key获取，本情况：不写注解，可以让map.put(\"book\", book);即默认使用参数类名首字母小写去隐含模型中去找！ 1234567891011121314@RequestMapping(\"/hhh01\")public String updateBook(Book book){ System.out.println(book); return \"success\";}@ModelAttributepublic void ModelAttributeTest(Map&lt;String, Object&gt; map){ Book book = new Book(1, \"dd\", \"dd\", 33.22, 33, 33); // 放到了隐含模型中！ map.put(\"book\", book); System.out.println(\"数据库中的book:\" + book); System.out.println(\"ModelAttribute...数据库查完并进行了保存！\");} 隐含模型找不到，则去SessionAttributes注解中获取value值作为key，从session中获取，本情况：保证ModelAttribute注解中不与隐含模型对应即可 类上不添加SessionAttributes注解，由于找不到，会利用反射进行创建一个空对象 很明显，隐含模型中找不到，Session中找不到，则报错500！直接无法访问！（我们并没有在Session中添加该对象） 类似承诺session中有，结果没有，报错500，所以该SessionAttributes注解一般不要使用！ 123456789101112131415161718@SessionAttributes(value = \"hh\")@Controllerpublic class ModelAttributeController { @RequestMapping(\"/hhh01\") public String updateBook((@ModelAttribute(\"hh\") Book book){ System.out.println(book); return \"success\"; } @ModelAttribute public void ModelAttributeTest(Map&lt;String, Object&gt; map){ Book book = new Book(1, \"dd\", \"dd\", 33.22, 33, 33); // 放到了隐含模型中！ map.put(\"book\", book); System.out.println(\"数据库中的book:\" + book); System.out.println(\"ModelAttribute...数据库查完并进行了保存！\"); }} ModelAttribute注解的方法一个特性，方法返回值也会放入隐含模型 因此可以修改该提前方法返回值为Book，并返回该对象即可，无需map.put，默认key值为返回值类型小写即为book 我们可以使用@ModelAttribute(\"返回类型小写book\")来接收 我们想自定义接收@ModelAttribute(\"自定义key, hh\")，则只需要在ModelAttribute注解方法的注解@ModelAttribute添加value属性值为自定义key即可 12345678910111213141516171819202122232425262728@RequestMapping(\"/hhh01\")public String updateBook((@ModelAttribute(\"book\") Book book){ System.out.println(book); return \"success\";}@ModelAttributepublic Book ModelAttributeTest(Map&lt;String, Object&gt; map){ Book book = new Book(1, \"dd\", \"dd\", 33.22, 33, 33); System.out.println(\"数据库中的book:\" + book); System.out.println(\"ModelAttribute...数据库查完并进行了保存！\"); return book;}// 或：@RequestMapping(\"/hhh01\")public String updateBook((@ModelAttribute(\"hh\") Book book){ System.out.println(book); return \"success\";}@ModelAttribute(value = \"hh\")public Book ModelAttributeTest(Map&lt;String, Object&gt; map){ Book book = new Book(1, \"dd\", \"dd\", 33.22, 33, 33); System.out.println(\"数据库中的book:\" + book); System.out.println(\"ModelAttribute...数据库查完并进行了保存！\"); return book;} ¶六、视图解析 请求处理方法执行完成后，最终返回一个 ModelAndView 对象。对于那些返回 String，View 或 ModeMap 等类型的处理方法，Spring MVC 也会在内部将它们装配成一个ModelAndView 对象，它包含了逻辑名和模型对象的视图 Spring MVC 借助视图解析器（ViewResolver）得到最终的视图对象（View），最终的视图可以是 JSP ，也可能是 Excel、JFreeChart 等各种表现形式的视图 对于最终究竟采取何种视图对象对模型数据进行渲染，处理器并不关心，处理器工作重点聚焦在生产模型数据的工作上，从而实现 MVC 的充分解耦 视图解析器ViewResolver只是为了得到视图对象，视图对象View才能真正的转发（将模型数据全部放在请求域中）或者重定向到页面视图对象才能真正的渲染视图。 ¶1、视图 ¶1.1、常用的视图实现类 视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户。 为了实现视图模型和具体实现技术的解耦，Spring 在 org.springframework.web.servlet包中定义了一个高度抽象的 View 接口： 视图对象由视图解析器负责实例化。由于视图是无状态的，所以他们不会有线程安全的问题 无状态：上一次和下一次没有关系，下一次不会是哟红上一次的东西！ View接口： 常用视图实现类： ¶1.2、JstlView 可以快速方便的实现国际化功能！ 不使用SpringMvc的步骤略有复杂：纯i18n国际化配置步骤，学习JavaWeb写的记录！点击这里！ 导包导入jstl的依赖包 配置JstlView视图类型 创建资源文件并让SpringMvc管理国际化资源文件 使用&lt;fmt:message key=\"关键词\"&gt;&lt;/fmt:message&gt;即可 注意： 一定要过SpringMvc的视图解析流程，人家会创建一个JstlView帮你快速国际化 需要经过Controller的处理才可！直接访问无效 从源码分析createView方法可以知道，带上前缀redirect和forward之后就走对应的方法不会带有区域信息locale，但不带使用默认的就会携带该locale信息！也不能使用前缀！ 直接访问的效果：???welcome???您的光临！ pom.xml导包： 123456789101112131415161718&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jstl-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jstl-impl --&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jstl-impl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 创建国际化资源文件： 对于Maven项目来说，直接放到resource目录下即可！ springmvc-servlet.xml配置： 1234567891011121314151617181920&lt;!--配置视图解析器：可以拼接页面地址--&gt;&lt;!--导入JSTL的包，可以自动创建JstlViewResolver--&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;!--最终路径结果为：/WEB-INF/pages/xxx.jsp，xxx为jsp文件名--&gt; &lt;!--这里也可指定视图类型为JstlView--&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--让SpringMvc管理国际化资源--&gt;&lt;!--id必须为messageSource--&gt;&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt; &lt;!--basename指定基础名--&gt; &lt;property name=\"basename\" value=\"i18n\"&gt;&lt;/property&gt;&lt;/bean&gt; jsp页面使用： IDE会自动导入fmt标签的！ 123456789101112&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;fmt:message key=\"welcome\"/&gt;您的光临！&lt;/body&gt;&lt;/html&gt; ¶2、视图解析器 SpringMVC 为逻辑视图名的解析提供了不同的策略，可以在 Spring WEB 上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类。 视图解析器的作用比较单一：将逻辑视图解析为一个具体的视图对象。 所有的视图解析器都必须实现 ViewResolver 接口 ViewResolver 接口： 常用的视图解析器实现类： 程序员可以选择一种视图解析器或混用多种视图解析器 每个视图解析器都实现了Ordered接口并开放出一个order属性，可以通过 order属性指定解析器的优先顺序，order 越小优先级越高。 SpringMVC会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则将抛出ServletException异常 ¶3、请求转发和重定向 有前缀的转发和重定向操作，视图解析器不生效！ ¶3.1、forward 需求：转发到WebContent目录下的redirect.jsp页面 使用两层../让浏览器根据地址回退到工程根目录去找对应文件 使用SpringMvc的forward前缀 forward: 转发到目标页面，不参与拼串，独立解析 注意：一定要加 /，表示WebContent路径，即工程根路径，不加/则是相对路径，易出问题 支持套娃操作，如下方第三个方法 12345678910111213141516171819@RequestMapping(value = \"/nb01\")public String handler01(){ // 目标页面：redirect.jsp // 处理地址：WEB-INF/pages/redirect.jsp // 解决方案../../redirect.jsp return \"../../redirect\";}// 使用forward:@RequestMapping(value = \"/nb02\")public String handler02(){ return \"forward:/redirect.jsp\";}// 套娃操作：转发到nb02请求，即转发到上面的操作@RequestMapping(value = \"/nb03\")public String handler03(){ return \"forward:/nb02\";} ¶3.2、redirect redirect: /表示WebContent资源根目录 与原生Servlet重定向不同，SpringMvc会自动进行拼串，无需写项目路径 同样支持套娃操作 12345678910@RequestMapping(value = \"/nb04\")public String handler04(){ return \"redirect:/redirect.jsp\";}// 套娃：多次重定向@RequestMapping(value = \"/nb05\")public String handler05(){ return \"redirect:/nb04\";} ¶3.3、mvc标签 对于前两个小结方法内只有一个作用，请求转发或重定向，则我们可以更简洁的使用配置文件mvc标签实现！ springmvc-servlet.xml文件： &lt;mvc:view-controller path=\"/xxx\" view-name=\"xxx\"/&gt; path：指定哪个请求 view-name：指定映射给哪个视图，即转发地址 /开头的，同样经过上面视图解析器的拼串 forward或redirect开头的，同样不会经过上面视图解析器拼串 这样写同样保证可以走SpringMvc的整个流程，经过了Controller控制器处理，可以使用国际化，同样forward或redirect开头的无法使用国际化！ 副作用：其他请求将全部失效，无法访问！ 解决：开启mvc注解驱动模式（之后的内容同样会用到该模式，是mvc的开挂模式，高配运行） 12345&lt;mvc:view-controller path=\"/welcome01\" view-name=\"welcome\"/&gt;&lt;mvc:view-controller path=\"/welcome02\" view-name=\"forward:/WEB-INF/pages/welcome.jsp\"/&gt;&lt;!--开启mvc注解驱动模式。（mvc开挂模式,高配运行）--&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; ¶4、自定义视图和视图解析器 ¶4.1、自定义前缀 12345678910111213@RequestMapping(\"/download\")public String download(Model model){ // 自定义的逻辑： List&lt;String&gt; vname = new ArrayList&lt;&gt;(); vname.add(\"一些内容\"); vname.add(\"一些内容\"); // 放到模型中 model.addAttribute(\"vname\", vname); // 自定义前缀 itnxd: return \"itnxd:/success\";} ¶4.1、自定义视图 实现View接口和重写渲染render方法！ 视图用于渲染页面！处理逻辑都在render方法内！ 渲染的页面无法正确显示中文： 由于我们在前方使用SpringMvc配置乱码的编码问题时候，只是设置了响应的编码格式，并没有设置文件类型！因此在实现逻辑之前先response.setContentType(\"text/html\"); 12345678910111213141516171819202122232425262728293031323334353637public class MyItnxdView implements View { /** * * @param model * @param request * @param response * @throws Exception */ @Override public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception { // 这里可以获取保存的model信息： System.out.println(\"model信息：\" + model); // 这里会发生乱码： // 原因：由于web.xml中设置了响应的编码格式，没有设置文件类型导致 response.setContentType(\"text/html\"); List&lt;String&gt; vname = (List&lt;String&gt;) model.get(\"vname\"); response.getWriter().write(\"即将展现精彩内容！&lt;br&gt;\"); for (String s : vname) { response.getWriter().write(\"&lt;a href='#'&gt;下载\" + s + \".avi&lt;/a&gt;&lt;br&gt;\"); } } /** * 返回的数据的内容的类型！ * @return */ @Override public String getContentType() { return \"text/html; charset=utf-8\"; }} ¶4.2、自定义视图解析器 实现ViewResolver接口重写resolveViewName方法！ 实现Ordered重写getOrder方法，使得SpringMvc可以获取到多个视图解析器的优先级顺序！ 增加setOrder方法，使得可以在配置文件中进行设置优先级！ 123456789101112131415161718192021222324252627public class MyItnxdViewResolver implements ViewResolver, Ordered { private Integer order; @Override public View resolveViewName(String viewName, Locale locale) throws Exception { // 只处理我们自定义的前缀：itnxd if(viewName.startsWith(\"itnxd:\")){ return new MyItnxdView(); } // 不能处理返回null让其他视图解析器处理： return null; } @Override public int getOrder() { return order; } // 改变视图解析器的优先级! public void setOrder(Integer order){ this.order = order; }} springmvc-servlet.xml文件配置自定义视图解析器和优先级： 并进行设置Order参数！ InternalResourceViewResolver优先级默认值为Integer.MAX_VALUE，即优先级最低！ 不设置优先级会导致被InternalResourceViewResolver进行拼串导致页面地址错误！ 123456789101112&lt;!--配置自定义视图解析器--&gt;&lt;bean class=\"com.itnxd.view.MyItnxdViewResolver\"&gt; &lt;!-- 控制优先级，数字越小，优先级越高！ InternalResourceViewResolver优先级默认值为：Integer.MAX_VALUE 即SpringMvc自己的优先级是最低的！ --&gt; &lt;property name=\"order\" value=\"1\"&gt;&lt;/property&gt;&lt;/bean&gt; ¶七、SpringMvc表单标签 通过 SpringMVC 的表单标签可以实现将模型数据中的属性和 HTML 表单元素相绑定，以实现表单数据更便捷编辑和表单值的回显，SpringMVC认为，表单数据中的每一项最终都是要回显的！ path属性： path指定的是一个属性，这个属性是从隐含模型（请求域中取出的某个对象中的属性)﹔ path指定的每一个属性，请求域中必须有一个对象，拥有这个属性 这个对象就是请求域中的command 表单字段，对应 html 元素的 name 属性，支持级联属性，自动回显隐含模型中的某个对象与之对应的属性值 modelAttribute属性： 以前我们表单标签会从请求域中获取一个command对象，把这个对象中的每一个属性对应的显示出来 可以告诉SpringMVC不要去取command的值了，放了一个modelAttribute指定的值 取对象用的key就用我modelAttribute指定的 form标签： 一般情况下，通过 GET 请求获取表单页面，而通过 POST 请求提交表单页面，因此获取表单页面和提交表单页面的 URL 是相同的。 只要满足该最佳条件的契约，&lt;form:form&gt; 标签就无需通过 action 属性指定表单提交的 URL 可以通过 modelAttribute 属性指定绑定的模型属性，若没有指定该属性，则默认从 request 域对象中读取 command 的表单 bean，如果该属性值也不存在，则会发生错误。 form:errors： 显示表单组件或数据校验所对应的错误 &lt;form:errors path=\"*\"/&gt;：显示表单所有的错误* *&lt;form:errors path=\"user*\"/&gt;：显示所有以 user 为前缀的属性对应的错误 &lt;form:errors path=\"username\"/&gt;：显示特定表单对象属性的错误 form:select： 用于构造下拉框组件 items：指定要遍历的集合，自动遍历，可以是一个 List、String[] 或 Map itemValue：指定刚才遍历出来的这个对象的哪个属性是作为要提交的value值，可以是集合中 bean 的一个属性值 itemLabel：指定遍历出的这个对象的哪个属性是作为option标签体的值 需要添加form标签库：IDE自动添加 1&lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt; 12345678910111213141516171819&lt;%--指定绝对路径--%&gt;&lt;% pageContext.setAttribute(\"ctp\", request.getContextPath());%&gt;&lt;form:form action=\"${ctp}/emp\" modelAttribute=\"employee\" method=\"post\"&gt; lastName：&lt;form:input path=\"lastName\"/&gt;&lt;form:errors path=\"lastName\"/&gt;&lt;br&gt; email：&lt;form:input path=\"email\"/&gt;&lt;form:errors path=\"email\"/&gt;&lt;br&gt; gender：&lt;br&gt; 男&lt;form:radiobutton path=\"gender\" value=\"1\"/&gt;&lt;br&gt; 女&lt;form:radiobutton path=\"gender\" value=\"2\"/&gt;&lt;br&gt; birth：&lt;form:input path=\"birth\"/&gt; &lt;%--处理普通表单无法获取错误信息--%&gt; ${errorsInfo.birth} &lt;br&gt; dept： &lt;form:select path=\"department.id\" items=\"${depts}\" itemLabel=\"departmentName\" itemValue=\"id\"/&gt; &lt;input type=\"submit\"&gt;&lt;/form:form&gt; ¶八、数据转换&amp;数据格式化&amp;数据校验 ¶1、数据类型转换 SpringMVC封装自定义类型对象的时候：javaBean要和页面提交的数据进行一一绑定，页面提交的所有数据都是字符串！ 这就牵扯到了数据绑定期间的类型转换问题！ 分析底层得到： WebDataBinder：数据绑定器负责数据绑定工作 ConversionService组件：负责数据类型的转换以及格式化功能，内部已有一些类型转换器实现，自定义类型自然需要我们自己实现！ ¶自定义类型转换 步骤： 实现Converter接口，写一个自定义的类型转换器 Converter是ConversionService中的组件 你的Converter得放进ConversionService中 将WebDataBinder中的ConversionService设置成我们这个加了自定义类型转换器的ConversionService 实现Converter接口﹐写一个自定义的类型转换器 配置出ConversionService 12345678910111213141516171819202122232425262728/** * 两个泛型参数： * S : source * T : targrt * 将S转换为T * @author ITNXD * @create 2021-04-03 9:42 */public class MyStringToEmployeeConverter implements Converter&lt;String, Employee&gt; { @Autowired DepartmentDao departmentDao; @Override public Employee convert(String source) { System.out.println(\"页面提交的将要转换的字符串！\"); Employee employee = new Employee(); if(source.contains(\"-\")){ String[] split = source.split(\"-\"); employee.setLastName(split[0]); employee.setEmail(split[1]); employee.setGender(Integer.parseInt(split[2])); Department department = departmentDao.getDepartment(Integer.parseInt(split[3])); employee.setDepartment(department); } return employee; }} springmvc-servlet.xml配置： 12345678910111213&lt;bean id=\"conversionService\" class=\"org.springframework.format.support.ConversionServiceFactoryBean\"&gt; &lt;!--在converters中添加自定义的转换器--&gt; &lt;property name=\"converters\"&gt; &lt;!--为set属性赋值！--&gt; &lt;set&gt; &lt;bean class=\"com.itnxd.restcrud.Converter.MyStringToEmployeeConverter\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--告诉mvc使用我们自定义的转换器！同样使用mvc标签--&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt; 测试： 1234567891011/** * 发送的请求是什么? * quickAdd?empInfo=empAdmin-admin@qq.com-1-101 * @return */@RequestMapping(\"/quickAdd\")public String quickAdd(@RequestParam(\"empInfo\") Employee employee){ System.out.println(employee); employeeDao.save(employee); return \"redirect:/toList\";} ¶2、数据格式化 数据绑定期间的日期格式化问题：比如提交的日期进行转换 eg：birth=2017-12-15-----&gt;Date 2017/12/15 2017.12.15 2017-12-15 两大注解： @NumberFormat：可对类似数字类型的属性进行标注，它拥有两个互斥的属性： style ： 类 型 为 NumberFormat.Style 。 用 于 指 定 样 式 类 型 ， 包 括 三 种 ：Style.NUMBER（正常数字类型）、 Style.CURRENCY（货币类型）、 Style.PERCENT（百分数类型） pattern：类型为 String，自定义样式，如 pattern=\"#,###\" @DateTimeFormat：可对 java.util.Date、java.util.Calendar、java.long.Long 时间类型进行标注： pattern 属性：类型为字符串。指定解析/格式化字段数据的模式，如：”yyyy-MM-dd hh:mm:ss” iso 属性：类型为 DateTimeFormat.ISO。指定解析/格式化字段数据的 ISO 模式，包 括 四 种 ： ISO.NONE （ 不 使 用 ） – 默 认 、 ISO.DATE(yyyy-MM-dd) 、ISO.TIME(hh:mm:ss.SSSZ)、 ISO.DATE_TIME(yyyy-MM-dd hh:mm:ss.SSSZ) style 属性：字符串类型。通过样式指定日期时间的格式，由两位字符组成，第一位表示日期的格式，第二位表示时间的格式：S：短日期/时间格式、M：中日期/时间格式、L：长日期/时间格式、F：完整日期/时间格式、-：忽略日期或时间格式 两大转换器： ConversionServiceFactoryBean不支持格式化功能 FormattingConversionServiceFactoryBean，支持格式化功能，皆具类型转换和格式化！（默认支持的格式是/方式的日期） 123// 规定页面提交的日期格式，必须为下方格式，否则400错误@DateTimeFormat(pattern = \"yyyy-MM-dd\")private Date birth; springmvc.xml配置： 1234567891011121314&lt;!-- &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt;--&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;!--在converters中添加自定义的转换器--&gt; &lt;property name=\"converters\"&gt; &lt;!--为set属性赋值！--&gt; &lt;set&gt; &lt;bean class=\"com.itnxd.restcrud.Converter.MyStringToEmployeeConverter\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--告诉mvc使用我们自定义的转换器！同样使用mvc标签，上面已写！--&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt; ¶3、数据校验 只做前端校验是不安全的，(浏览器可以禁用js) 在重要数据一定要加上后端验证; 可以写程序将我们每一个数据取出进行校验，如果失败直接来到添加页面，提示其重新填写 SpringMvc可以用JSR303来做数据校验了 JSR303规范：Hibernate validator（第三方校验框架，实现了该规范） ¶3.1、导包 最好最好不要使用最新版，6.0即可，7.0无法使用，还不知道原因! pom.xml配置： 123456789101112131415&lt;!--hibernate的数据校验包--&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt; &lt;version&gt;6.0.0.Final&lt;/version&gt;&lt;/dependency&gt; ¶3.2、在JavaBean属性上添加校验注解 12345678910111213141516@NotEmpty(message = \"lastName不能为空！\")@Length(min = 6, max = 18) // 限制字符长度private String lastName;@Emailprivate String email;//1 male, 0 femaleprivate Integer gender;private Department department;@Past // 必须是过去时间（future必须是未来时间）// @DateTimeFormat为日期格式化注解，不属于校验注解// 规定页面提交的日期格式，必须为下方格式，否则400错误@DateTimeFormat(pattern = \"yyyy-MM-dd\")private Date birth; ¶3.3、Controller处理器添加@Valid注解 123456@RequestMapping(value = \"/emp\", method = RequestMethod.POST)public String addEmp(@Valid Employee employee){ System.out.println(employee); employeeDao.save(employee); return \"redirect:/toList\";} ¶3.4、查看校验结果 给需要校验的JavaBean后面**紧跟（中间不能有任何东西间隔）**一个BindingResult。这个BindingResult就是封装前一个bean的校验结果 表单显示错误信息： 普通表单，使用Model保存错误信息，使用EL表达式取出错误信息即可 SpringMvc的表单，直接可以使用&lt;form:errors path=\"lastName\"/&gt;获取错误信息 123456789101112131415161718192021222324252627282930@RequestMapping(value = \"/emp\", method = RequestMethod.POST)public String addEmp(@Valid Employee employee, BindingResult bindingResult, Model model){ // 校验错误 if(bindingResult.hasErrors()){ System.out.println(\"有校验错误！\"); Map&lt;String, Object&gt; errorsMap = new HashMap&lt;&gt;(); List&lt;FieldError&gt; fieldErrors = bindingResult.getFieldErrors(); for (FieldError error : fieldErrors) { System.out.println(\"错误提示信息：\" + error.getDefaultMessage()); System.out.println(\"错误的字段是：\" + error.getField()); // 将错误保存起来，处理不使用mvc表单标签获取不到错误信息的问题！ errorsMap.put(error.getField(), error.getDefaultMessage()); } // 解决普通表单获取错误信息 model.addAttribute(\"errorsInfo\", errorsMap); // 解决没有department信息问题！ /*Collection&lt;Department&gt; departments = departmentDao.getDepartments(); model.addAttribute(\"depts\", departments); model.addAttribute(\"employee\", new Employee());*/ // 添加到ModelAttribute方法中！ return \"addEmp\"; }else{ System.out.println(employee); employeeDao.save(employee); return \"redirect:/toList\"; }} ¶3.5、国际化定制错误消息 编写国际化文件： errors_zh_CN. properties errors_en_Us.properties 国际化文件的key有规定： 每一个字段发生错误以后，都会有自己的错误代码，国际化文件中错误消息的key必须对应一个错误代码： Email.emplbyee.email：校验规则.隐含模型中这个对象的key.对象的属性 Email.email：校验规则.属性名 Email.java.lang.String：校验规则.属性类型 Email： 举例： 高级国际化：动态传入消息参数 {0}：注解属性值 {其他}：字典序取值 1234567Email.email=email incorrect!#Email=email cuowu! 更精确的优先NotEmpty=must not empty!# 获取注解的长度参数Length.java.lang.String=length incorrect! {0} {1} {2}Past=must past time!typeMismatch.birth=geshi incorrect！ 让SpringMvc管理国际化资源： 1234567891011121314&lt;!--让SpringMvc管理国际化资源--&gt;&lt;!--id必须为messageSource--&gt;&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt; &lt;!--basename指定基础名--&gt; &lt;!-- &lt;property name=\"basename\" value=\"i18n\"/&gt;--&gt; &lt;!--多个国际化资源使用besenames，使用list赋值多个资源--&gt; &lt;property name=\"basenames\"&gt; &lt;list&gt; &lt;value&gt;i18n&lt;/value&gt; &lt;value&gt;errors&lt;/value&gt; &lt;value&gt;login&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; ¶3.6、使用message属性定制错误信息 使用message指定错误消息（不能实现国际化） 国际化优先级高于message 123@NotEmpty(message = \"lastName不能为空！\")@Length(min = 6, max = 18) // 限制字符长度private String lastName; ¶九、mvc:annotation-driven &lt;mvc:default-servlet-handler/&gt; &lt;mvc:annotation-driven/&gt; 接下来分析一下这两大mvc标签的几种情况！ 为了方便，下面以一和二来称呼两大标签！ mvc:annotation-driven会自动注册： RequestMappingHandlerMapping 、 RequestMappingHandlerAdapter 与 ExceptionHandlerExceptionResolver 三个 bean。 还将提供以下支持： 支持使用 ConversionService 实例对表单参数进行类型转换 支持使用 @NumberFormat、@DateTimeFormat 注解完成数据类型的格式化 支持使用 @Valid 注解对 JavaBean 实例进行 JSR 303 验证 支持使用 @RequestBody 和 @ResponseBody 注解 ¶1、一和二都没有 动态资源（@RequestMapping映射的资源）能访问，静态资源(html, js)不能访问！ HandlerMapping: 动态能访问：DefaultAnnotationHandlerMapping中的handlerMap中保存了每一个资源的映射信息; 静态不能访问：handlerMap中没有保存静态资源映射的请求， HandlerAdapter: 方法执行的适配器（过时的） AnnotationMethodHandlerAdapter：帮我们执行目标方法 ¶2、一有二没有 静态资源ok，动态资源完蛋！ HandlerMapping变化： 动态不能访问：DefaultAnnotationHandlerMapping没有了，用SimpleUrlHandlerwapping替换了，他的作就用是将所有请求直接交给tomcat 静态能访问的原因：simpleUrlHandlerMapping 把所有请求都映射给tomcat HandlerAdapter变化： AnnotationMethodHandlerAdapter都没有了：帮我们执行目标方法的适配器没有了 ¶3、一二都有 静态动态都可访问！ HandlerMapping变化： RequestMappingHandlerMapping：动态资源可以访问 handleMethods属性保存了每一个请求用哪个方法来处理 SimpleUrlHandlerMapping：将请求直接交给tomcat，有他，静态资源就没问题 HandlerAdapter变化： 原来的AnnotationMethodHandlerAdapter，被换成RequestMappingHandlerAdapter，确定参数都用成解析器了 ¶十、处理JSON ¶1、JackSon使用 SpringMvc可以利用Jackson来方便的处理Json数据！ 原生JavaWeb需要使用Gson来转换为Json数据！ 导包： pom.xml： 1234567891011121314151617181920&lt;!--SpringMvc-json--&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.12.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.12.2&lt;/version&gt;&lt;/dependency&gt; jsp页面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;% pageContext.setAttribute(\"ctp\", request.getContextPath()); %&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function (){ $(\"a\").click(function (){ $.ajax({ url:\"${ctp}/sendAjax\", type:\"GET\", success:function (data){ console.log(data); $.each(data, function (){ var empInfo = this.lastName + \"--\" + this.email + \" --\" + this.gender + \"--\" + this.birth; $(\"div\").append(empInfo + \"&lt;br&gt;\"); }); } }); return false; }); }); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;%--日期没变就说名异步请求了！--%&gt;&lt;%=new Date()%&gt;&lt;br&gt;&lt;a href=\"${ctp}/sendAjax\"&gt;获取全部emp!&lt;/a&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Controller： 添加@ResponseBody注解：返回数据会放到响应体中，jsp页面可以通过ajax请求获取到数据并展示到页面上！ 123456789101112/** * 将返回的数据放在响应体中; * 如果是对象，jackson包自动将对象转为json格式! * * @return */@ResponseBody@RequestMapping(\"/sendAjax\")public Collection&lt;Employee&gt; ajaxGetAll(){ Collection&lt;Employee&gt; all = employeeDao.getAll(); return all;} ¶2、@ResponseBody 将返回的数据放在响应体中！返回json数据，将对象转换为json数据，返回给浏览器！ 如果是对象，jackson包自动将对象转为json格式！ 我们可以用它替代response.getWriter().write()方法，将数据写到页面！ 12345678910111213@ResponseBody@RequestMapping(\"/sendAjax\")public Collection&lt;Employee&gt; ajaxGetAll(){ Collection&lt;Employee&gt; all = employeeDao.getAll(); return all;}@ResponseBody@RequestMapping(\"/responseBody\")public String responseBodyTest(){ return \"&lt;h1&gt;success&lt;/h1&gt;\";} ¶3、@RequestBody 获取一个请求的请求体！ @RequestBody：获取一个请求的请求体！接受json数据，封装为JavaBean @RequestParam：获取一个请求体参数 123456789101112131415161718// 获取请求体所有内容@RequestMapping(\"/requestBody\")public String requestBodyTest(@RequestBody String body){ System.out.println(body); return \"success\";}/** * Json到JavaBean的自动绑定！ * * @param employee * @return */@RequestMapping(\"/requestBody01\")public String requestBodyTest1(@RequestBody Employee employee){ System.out.println(employee); return \"success\";} jsp页面： 12345678910111213141516171819202122232425&lt;form action=\"${ctp}/requestBody\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" name=\"username\" value=\"tom\"/&gt;&lt;br&gt; &lt;input type=\"password\" name=\"password\" value=\"123453345\"/&gt;&lt;br&gt; &lt;input type=\"file\" name=\"file\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt;&lt;a href=\"${ctp}/requestBody01\"&gt;ajax发送json数据!&lt;/a&gt;&lt;script&gt; $(\"a\").click(function (){ var emp = {lastName:\"张三\", email:\"nb@mail.com\", gender:\"0\"}; var empJson = JSON.stringify(emp); $.ajax({ url:\"${ctp}/requestBody01\", type:\"post\", data:empJson, contentType:\"application/json\", success:function (data){ alert(data); } }); return false; });&lt;/script&gt; ¶4、ResponseEntity 可以自定义响应！作为返回值！ 123456789101112131415/** * ResponseEntity&lt;String&gt;：自定义响应！ * @return */@RequestMapping(\"/responseBody01\")public ResponseEntity&lt;String&gt; responseBodyTest01(){ String body = \"&lt;h1&gt;success&lt;/h1&gt;\"; MultiValueMap&lt;String, String&gt; headers = new HttpHeaders(); HttpStatus statusCode; headers.add(\"Set-Cookie\", \"username=itnxd\"); ResponseEntity&lt;String&gt; responseEntity = new ResponseEntity&lt;&gt;(body, headers, HttpStatus.OK); return responseEntity;} ¶5、HttpEntity 可以获取请求体和请求头！作为入参！ 12345678910/** * HttpEntity：可以获取请求体和请求头！ * 与之类似的：@RequestHeader：这个只能获取到某个请求头 * @return */@RequestMapping(\"/httpEntity\")public String httpEntityTest(HttpEntity&lt;String&gt; str){ System.out.println(str); return \"success\";} ¶6、文件下载 使用ResponseEntity实现文件下载！ 123456789101112131415161718192021222324252627282930313233/** * SpringMvc下载！ * 返回类型应该是字节流！ * @return */@RequestMapping(\"/download01\")public ResponseEntity&lt;byte[]&gt; download01(HttpServletRequest request) throws IOException { // 1. 获取要下载文件的流 // 获取servletContext对象！ ServletContext servletContext = request.getServletContext(); // 获取文件真实地址！ String realPath = servletContext.getRealPath(\"/index.jsp\"); System.out.println(realPath); //E:\\Java学习\\IdeaProject\\SpringMvc\\1_HelloWorld\\target\\1_HelloWorld-1.0-SNAPSHOT\\index.jsp FileInputStream fis = new FileInputStream(realPath); // 创建和文件流一样大小的字节数组 byte[] buffer = new byte[fis.available()]; fis.read(buffer); fis.close(); // 2. 将要下载的文件流返回 MultiValueMap&lt;String, String&gt; headers = new HttpHeaders(); // 设置文件下载的响应头 headers.add(\"Content-Disposition\", \"attachment;filename=\" + \"index.jsp\"); ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(buffer, headers, HttpStatus.OK); return responseEntity;} ¶7、文件上传 @RequestParam(\"header\") MultipartFile file: 自动将文件流封装到MultipartFile对象！ JavaWeb文件上传方法，点击这里查看！ 步骤： 文件上传表单准备enctype=\"multipant/form-data\" 导入fileupload; SpringMVC配置文件中，配置文件上传解析器。(SpringMvc九大组件之一MultipartResolver) 配置其实现类CommonsMultipartResolver 文件上传请求处理，在处理器方法上写一个@RequestParam( \"header \" ) MultipartFile file ,封装当前文件的信息，进行保存 导包pom.xml： 1234567&lt;!--文件上传依赖--&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; springmvc-servlet.xml： 12345678910111213&lt;!--配置文件上传解析器id=\"multipartResolver\"，固定值，九大组件的multipartResolver初始化会用到bean-id--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 限制文件最大为20Mb #{}：SpringMvc的表达式！ --&gt; &lt;property name=\"maxUploadSize\" value=\"#{1024*1024*20}\"/&gt; &lt;!--设置编码--&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"/&gt;&lt;/bean&gt; 单文件上传： 123456789101112131415161718@RequestMapping(\"/upload\")public String upload(@RequestParam(value = \"username\", required = false) String username, @RequestParam(\"header\") MultipartFile file, Model model){ System.out.println(\"username = \" + username); System.out.println(\"文件file input 的name值：\" + file.getName()); System.out.println(\"文件名：\" + file.getOriginalFilename()); // 文件保存：一句话 try { file.transferTo(new File(\"C:\\\\Users\\\\15890\\\\Desktop\\\\\" + file.getOriginalFilename())); model.addAttribute(\"msg\", \"文件上传成功！\"); } catch (IOException e) { model.addAttribute(\"msg\", \"文件上传失败！\" + e.getMessage()); e.printStackTrace(); }} 多文件上传： 12345678910111213141516171819202122@RequestMapping(\"/upload\") public String upload(@RequestParam(value = \"username\", required = false) String username, @RequestParam(\"header\") MultipartFile[] files, Model model){ /*=======================多文件上传！===============================*/ for (MultipartFile file : files) { // 非空再进行操作 if(!file.isEmpty()){ try { file.transferTo(new File(\"C:\\\\Users\\\\15890\\\\Desktop\\\\\" + file.getOriginalFilename())); model.addAttribute(\"msg\", \"文件上传成功！\"); } catch (IOException e) { model.addAttribute(\"msg\", \"文件上传失败！\" + e.getMessage()); e.printStackTrace(); } } } return \"success\"; } ¶十一、拦截器 SpringMVC提供了拦截器机制，允许运行目标方法之前进行一些拦截工作，或者目标方法运行之后进行一些其他处理！ Filter：javaWeb Handlerlnterceptor：SpringMVC，更加强大！ ¶1、概述 preHandle：在目标方法运行之前调用，返回boolean， return true ; (chain.doFilter())放行；return false，不放行 postHandle：在目标方法运行之后调用，目标方法调用后 afterCompletion：在请求整个完成之后，来到目标页面之后，chain.doFilter()放行，资源响应之后 什么时候用Filter什么时候用拦截器? 如果某些功能，需要其他组件配合完成，我们就使用拦截器 其他情况可以写filter ¶2、拦截器使用 实现Handlerlntercept接口 在SpringMVC配置文件中注册这个拦截器的工作，配置这个拦截器来拦截哪些请求的目标方法 拦截器实现： 123456789101112131415161718192021222324252627282930313233public class MyInterceptor implements HandlerInterceptor { /** * 目标方法运行之前运行！ * * return false：不放行，true:放行 * * @param request * @param response * @param handler * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\".................MyInterceptor.preHandle()..........\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"....................MyInterceptor.postHandle()..........\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"................MyInterceptor.afterCompletion()..........\"); }} springmvc-servlet.xml配置： 123456789101112131415161718&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--配置一个拦截器！认拦截所有请求--&gt; &lt;!--&lt;bean class=\"com.itnxd.interceptor.MyInterceptor\"/&gt;--&gt; &lt;!--配置一个拦截器，可以配置更详细的信息--&gt; &lt;mvc:interceptor&gt; &lt;!--配置拦截那些请求--&gt; &lt;!--只拦截test请求--&gt; &lt;mvc:mapping path=\"/test\"/&gt; &lt;!--配置拦截器具体类--&gt; &lt;bean class=\"com.itnxd.interceptor.MyInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/interceptor\"/&gt; &lt;bean class=\"com.itnxd.interceptor.MyInterceptor2\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; Controller： 123456@RequestMapping(\"/interceptor\")public String interceptor(){ System.out.println(\"Controller下的interceptor()........\"); // int i = 1 / 0; return \"success\";} ¶3、拦截器运行流程 ¶3.1、单个拦截器 正常流程： 拦截器的preHandle------&gt;目标方法-----&gt;拦截器postHandle-----&gt;页面-------&gt;拦截器的afterCompletion 运行流程： 12345................MyInterceptor.preHandle()..........Controller下的interceptor()............................MyInterceptor.postHandle()..........success.jsp页面运行...拦截器来到了success.jsp页面！................MyInterceptor.afterCompletion().......... 其他流程： 只要preHandle不放行就没有以后的流程; 只要放行了，afterCompletion一定会执行;（即使目标方法处理器炸了） ¶3.2、多个拦截器 正常流程： 类似Filter，一个来回，先顺序后逆序 12345678................MyInterceptor.preHandle()...........................MyInterceptor2.preHandle()...........Controller下的interceptor().........................MyInterceptor2.postHandle()...............................MyInterceptor.postHandle()..........success.jsp页面运行...拦截器来到了success.jsp页面！.................MyInterceptor2.afterCompletion()...........................MyInterceptor.afterCompletion().......... 异常流程︰ 不放行： 哪一块不放行从此以后都没有 放行的afterCompletion仍然执行： eg：MySecondInterceptor不放行，但是他前面已经放行了的拦截器的afterCompletion会执行 123.................MyInterceptor.preHandle()...........................MyInterceptor2.preHandle()...........................MyInterceptor.afterCompletion().......... ¶3.3、流程总结 拦截器的preHandle：是按照顺序执行拦截器的 拦截器的postHandle：是按照逆序执行 拦截器的afterCompletion：是按照逆序执行 已经放行了的拦截器的afterCompletion总会执行 ¶十二、国际化 区域信息获取，为SpringMvc的九大组件之一的AcceptHeaderLocaleResolver！ ¶1、概述 写好国际化资源文件 让Spring的ResourceBundleMessageSource管理国际化资源文件 直接去页面取值 springmvc配置文件： 123456789101112&lt;!--让SpringMvc管理国际化资源--&gt;&lt;!--id必须为messageSource--&gt;&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt; &lt;!--basename指定基础名--&gt; &lt;!-- &lt;property name=\"basename\" value=\"i18n\"/&gt;--&gt; &lt;!--多个国际化资源使用besenames，使用list赋值多个资源--&gt; &lt;property name=\"basenames\"&gt; &lt;list&gt; &lt;value&gt;i18n&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; jsp页面： 1&lt;fmt:message key=\"welcome\"/&gt;您的光临！ ¶2、区域化信息locale 国际化区域信息时决定国际化显示的因素！还是SpringMvc的九大组件之一！ private LocaleResolver localeResolver; 区域信息是由区域信息解析器解析得到的！默认会用一个 AcceptHeaderLocaleResolver! 1234567891011121314151617@Autowiredprivate MessageSource messageSource;@RequestMapping(\"/locale\")// 使用原生API，自动绑定当前local对象！public String LocalTest2(Locale locale, Model model){ System.out.println(locale); // zh_CN // 待转换字符串，国际化占位符参数数组，国际化对象locale String message = messageSource.getMessage(\"username\", null, locale); // 用户名 System.out.println(message); // 应用：放到隐含模型进行处理 JSR303校验 model.addAttribute(\"msg\", message); return \"success\";} ¶3、自定义区域信息解析器 实现LocaleResolver接口并重写方法即可！ 可以从来实现点击链接切换国际化信息！ LocaleResolver接口实现类： AcceptHeaderLocaleResolver：使用请求头的区域信息 FixedLocaleResolver：使用系统默认的区域信息 sessionLocaleResolver：区域信息是从session中获取。可以根据请求参数创建一个locale对象，把他放在session中 CookieLocaleResolver：从Session中获取 springmvc.xml： 1&lt;bean id=\"localeResolver\" class=\"com.itnxd.i18n.MyLocaleResolver\"/&gt; 自定义区域信息解析器： 1234567891011121314151617181920212223242526public class MyLocaleResolver implements LocaleResolver { /** * 如果请求参数带有区域信息，就用带了的，否则使用请求头的信息！ * @param request * @return */ @Override public Locale resolveLocale(HttpServletRequest request) { // 根据请求参数获取locale信息 String localeStr = request.getParameter(\"locale\"); Locale l = null; if(localeStr != null &amp;&amp; !\"\".equals(localeStr)){ l = new Locale(localeStr.split(\"_\")[0], localeStr.split(\"_\")[1]); }else{ l = request.getLocale(); } return l; } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) { throw new UnsupportedOperationException( \"Cannot change HTTP accept header - use a different locale resolution strategy\"); }} jsp页面： 12345678&lt;form action=\"\"&gt; &lt;fmt:message key=\"username\"/&gt;：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br&gt; &lt;fmt:message key=\"password\"/&gt; ：&lt;input type=\"password\" name=\"password\"/&gt; &lt;input type=\"submit\" value=\"&lt;fmt:message key=\"login\"/&gt;\"&gt;&lt;/form&gt;&lt;a href=\"login?locale=zh_CN\"&gt;中文&lt;/a&gt;&lt;a href=\"login?locale=en_US\"&gt;英文&lt;/a&gt; ¶4、使用SessionLocaleResolver 区域信息是从session中获取。可以根据请求参数创建一个locale对象，把他放在session中！ 12&lt;!--使用SessionLocaleResolver区域信息解析器--&gt;&lt;bean id=\"localeResolver\" class=\"org.springframework.web.servlet.i18n.SessionLocaleResolver\"/&gt; 123456789101112131415 @RequestMapping(\"/login\") public String LocalTest1(@RequestParam(value = \"locale\", defaultValue = \"zh_CN\") String localeStr, Locale locale, Model model, HttpSession session){ // 在session中放入区域信息 // 根据请求参数获取locale信息 Locale l = null; if(localeStr != null &amp;&amp; !\"\".equals(localeStr)){ l = new Locale(localeStr.split(\"_\")[0], localeStr.split(\"_\")[1]); }else{ l = locale; } // 固定写法！ session.setAttribute(SessionLocaleResolver.class.getName() + \".LOCALE\", l); return \"login\";} ¶5、更简便方式 结合LocaleChangeInterceptor实现自动获取请求参数的locale值，自动设置local解析器！ 拦截器和SessionLocaleResolver结合实现自动获取！ 自动获取请求参数的locale值，会在preHandle方法中进行设置！ 会使用 SessionLocaleResolver解析器进行设置，因此这两个都要设置！ 注意：请求参数key必须为locale 123456&lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/login\"/&gt; &lt;bean class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\"/&gt;&lt;/mvc:interceptor&gt;&lt;bean id=\"localeResolver\" class=\"org.springframework.web.servlet.i18n.SessionLocaleResolver\"/&gt; ¶十三、异常处理 Spring MVC 通过 HandlerExceptionResolver 处理程序的异常，包括 Handler 映射、数据绑定以及目标方法执行时发生的异常。 ¶1、概述 如果异常解析器都不能处理就直接抛出去! HandlerExceptionResolver异常解析器实现类 SimpleMappingExceptionResolver：通过配置的方式进行异常处理 DispatcherServlet.properties文件内的默认值： HandlerExceptionResolver（默认值） ExceptionHandlerExceptionResolver：@ExceptionHandler ResponseStatusExceptionResolver：@ResponseStatus 给自定义异常标注 DefaultHandlerExceptionResolver：判断是否SpringMVC自带的异常（没人处理则会有一个默认错误页面） ¶2、@ExceptionHandler 处理本类异常！ 给方法上随便写一个Exception，用来接收发生的异常 要携带异常信息不能给参数位置写Model 返回ModelAndView就行了 如果有多个@ExceptionHandler都能处理这个异常，精确优先 全局异常处理与本类同时存在，本类优先 1234567891011@ExceptionHandler(ArithmeticException.class) // 处理数学异常// 多个异常// @ExceptionHandler({ArithmeticException.class, NullPointerException.class})public ModelAndView handlerException01(Exception exception){ System.out.println(\"handlerException01..........\"); // 返回到myerror.jsp页面！ ModelAndView mv = new ModelAndView(\"myerror\"); mv.addObject(\"errorInfo\", exception); return mv;} ¶3、处理全局异常 一个专门用来处理全局异常的类，使用@ControllerAdvice标注即可！ 1234567891011121314@ControllerAdvicepublic class MyWholeException { @ExceptionHandler(ArithmeticException.class) // 处理数学异常 public ModelAndView handlerException01(Exception exception){ System.out.println(\"全局的 handlerException01..........\"); // 返回到myerror.jsp页面！ ModelAndView mv = new ModelAndView(\"myerror\"); mv.addObject(\"errorInfo\", exception); return mv; }} ¶4、@ResponseStatus 可以自定义错误页面的提示信息，以及状态码！ 自定义异常： 12345@ResponseStatus(reason = \"用户被拒绝登录！\", value = HttpStatus.NOT_ACCEPTABLE)public class UsernameNotFoundException extends RuntimeException{ static final long serialVersionUID = 1L;} ¶5、通过配置文件处理异常 SimpleMappingExceptionResolver：通过配置的方式进行异常处理！ 配置异常解析器，优先级最低，优先前三个处理，处理不了再交给配置文件的解析器！ springmvc-servlet.xml： 12345678910111213141516171819202122&lt;!-- 配置异常解析器，优先级最低，优先前三个处理，处理不了再交给配置文件的解析器 public void setExceptionMappings(Properties mappings) { this.exceptionMappings = mappings; } --&gt;&lt;bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt; &lt;!--配置各类异常去各类页面，Properties类型--&gt; &lt;property name=\"exceptionMappings\"&gt; &lt;props&gt; &lt;!-- key:异常全类名 value:异常要去的页面，视图名 --&gt; &lt;prop key=\"java.lang.NullPointerException\"&gt;myerror&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!--指定错误信息取时使用的key，内部默认为exception，可到页面获取错误信息--&gt; &lt;property name=\"exceptionAttribute\" value=\"ex\"/&gt;&lt;/bean&gt; ¶十四、SpringMvc运行流程 所有请求，前端控制器(DispatcherServlet )收到请求，调用doDispatch进行处理 根据HandlerMapping中保存的请求映射信息找到，处理当前请求的，处理器执行链（包含拦截器) 根据当前处理器找到他的HandlerAdapter (适配器) 拦截器的preHandle先执行 适配器执行目标方法，并返回ModelAndView ModelAttribute注解标注的方法提前运行 执行目标方法的时候（确定目标方法用的参数) 有注解：保存注解信息，最终得到这个注解应该对应解析的值 没注解： 看是否只原生API 看是否Model、Map以及其他的 都不是，看是否是简单类型：paramName 给atttName赋值，attrName(参数标了@ModelAttribute就是指定的value值，没标就是\"\") 如果是自定义类型 attrName使用参数类型首字母小写；或者使用入参@ModelAttribute的值 先看隐含模型中有没有这个attrName作为key对应的值；如果有就从隐含模型中获取并赋值 看是否是@SessionAttributes标注的属性，如果是，就从session中拿，如果拿不到就会抛异常（因此不建议使用） 都不是，就利用反射创建对象 拦截器的postHandle执行 处理结果(页面渲染流程) 如果有异常使用异常解析器处理异常，处理完后还会返回ModelAndView 调用render进行页面渲染 视图解析器根据视图名得到视图对象 视图对象调用render方法 执行拦截器的afterCompletion ¶十五、SpringMvc与Spring整合 ¶1、整合的目的 分工明确： SpringMVC的配置文件就来配置和网站转发逻辑以及网站功能有关的（视图解析器，文件上传解析器，支持ajax , xxx ) ; Spring的配置文件来配置和业务有关的(事务控制，数据源，xxx ) ; ¶2、单文件配置 都放在 SpringMVC 的配置文件中，也可以分多个 Spring 的配置文件, 然后使用 import 节点导入其他的配置文件！ 主要用于单文件内容太多，分文件之后的整合，本质还是一个IOC容器！ 两个配置文件： springmvc.xml spring.xml 可以使用import标签实现分文件的合并！ 1&lt;import resource=\"spring.xml\"/&gt; ¶3、分文件配置 主要是为了让配置文件各司其职，分工明确！ Spring管理业务逻辑组件，SpringMVC管理控制器组件！ 注意： 若 Spring 的 IOC 容器和 SpringMVC 的 IOC 容器扫描的包有重合的部分, 就会导致有的 bean 会被创建 2 次！ 在web.xml中指定两个配置文件路径！ 配置启动 Spring IOC 容器的 Listener！ 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--分容器，指定spring配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--指定springmvc配置文件--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc配置文件只处理Controller和ControllerAdvice！ 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--开启组件扫描--&gt; &lt;!--配置分容器，SpringMvc只扫描除了Controller，禁用默认过滤规则--&gt; &lt;context:component-scan base-package=\"com.itnxd\" use-default-filters=\"false\"&gt; &lt;!--处理器注解--&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;!--进行错误控制的注解--&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/&gt; &lt;/context:component-scan&gt; &lt;!--配置视图解析器：可以拼接页面地址--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;!--后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;!--最终路径结果为：/WEB-INF/pages/xxx.jsp，xxx为jsp文件名--&gt; &lt;/bean&gt; &lt;!--导入spring.xml配置文件--&gt; &lt;!--&lt;import resource=\"spring.xml\"/&gt;--&gt; &lt;!--关掉自动导入，实现分容器--&gt;&lt;/beans&gt; spring配置文件只处理其他注解 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--配置分容器处理，禁用默认规则--&gt; &lt;context:component-scan base-package=\"com.itnxd\"&gt; &lt;!--只扫描Controller处理器注解--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; ¶4、两大IOC容器关系 即父子容器！ Spring为父容器，SpringMvc为子容器，子可以访问父，父不可以访问子！ Spring MVC WEB 层容器可作为 “业务层”， Spring 容器的子容器！ 即 WEB 层容器可以引用业务层容器的 Bean，而业务层容器却访问不到 WEB 层容器的 Bean！ 因此Controller中可以装配service，反过来则不行！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Spring全家桶","slug":"Spring全家桶","permalink":"https://www.itnxd.cn/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"}],"tags":[{"name":"SpringMvc","slug":"SpringMvc","permalink":"https://www.itnxd.cn/tags/SpringMvc/"}],"author":"ITNXD"},{"title":"每日一题之LeetCode 781.森林中的兔子","slug":"每日一题之LeetCode-781-森林中的兔子","date":"2021-04-04T02:25:42.000Z","updated":"2021-04-06T03:08:30.074Z","comments":true,"path":"posts/43253.html","link":"","permalink":"https://www.itnxd.cn/posts/43253.html","excerpt":"","text":"题目链接：LeetCode 781. 森林中的兔子 ¶一、题解 一道有趣的数学问题，类似脑筋急转弯！ 题目大意： 通过每个兔子报的数（表示和自己一样颜色的兔子数），计算得到最少有多少只兔子！ 思路： 先将报的数相同的进行一下统计 设报的数为 x，报 x 数的兔子有 sum 只！ sum % (x + 1) == 0：则最少需要sum / (x + 1)种颜色，且sum只兔子都进行了回答 否则：最少需要sum / (x + 1) + 1 种颜色，共有(sum / (x + 1) + 1) * (x + 1) 只兔子回答了 ¶二、AC代码 参考代码： 1234567891011121314class Solution {public: int numRabbits(vector&lt;int&gt;&amp; answers) { unordered_map&lt;int, int&gt; hash; for(auto x : answers) hash[x] ++; int res = 0; for(auto it : hash){ int x = it.first, sum = it.second; if(sum % (x + 1) == 0) res += sum; else res += (sum / (x + 1) + 1) * (x + 1); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"思维题","slug":"思维题","permalink":"https://www.itnxd.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"},{"name":"数学","slug":"数学","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E5%AD%A6/"}],"author":"ITNXD"},{"title":"每日一题之AcWing 1222.密码脱落","slug":"每日一题之AcWing-1222-密码脱落","date":"2021-04-03T02:25:10.000Z","updated":"2021-04-06T03:08:30.042Z","comments":true,"path":"posts/62813.html","link":"","permalink":"https://www.itnxd.cn/posts/62813.html","excerpt":"","text":"题目链接：AcWing 1222. 密码脱落 ¶一、题解 题目大意： 给定一个字符串，求其最长回文子序列，返回其最少脱落的字母数！ 思路： 转态表示：由于是回文，因此我们使用区间来处理，使用f[i][j]表示区间 i 到 j 的回文子序列集合。属性为：最大值！ 状态计算： 都选：在a[i] == a[j]的情况下有解：f[i + 1][j - 1] + 2 a[i]选a[j]不选：f[i][j - 1]，a[i]不一定可以匹配，包含第四种情况 a[i]不选a[j]选：f[i + 1][j]，a[j]不一定可以匹配，包含第四种情况 都不选：f[i + 1][j - 1] 最终答案： n - f[0][n - 1] 因此： 只需要计算前三种情况即可，第四种情况已经被包含！ 注意： 当长度为1的时候特殊处理f[i][j] = 1，防止越界！ ¶二、AC代码 参考代码： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;string s;int f[N][N];int main(){ cin &gt;&gt; s; int n = s.size(); for(int len = 1; len &lt;= n; len ++){ for(int i = 0; i + len - 1 &lt; n; i ++){ int j = i + len - 1; if(len == 1) f[i][j] = 1; else{ f[i][j] = max(f[i][j - 1], f[i + 1][j]); if(s[i] == s[j]) f[i][j] = max(f[i][j], f[i + 1][j - 1] + 2); } } } cout &lt;&lt; n - f[0][n - 1] &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"https://www.itnxd.cn/tags/%E5%8C%BA%E9%97%B4DP/"}],"author":"ITNXD"},{"title":"每日一题之LeetCode 1143. 最长公共子序列","slug":"每日一题之LeetCode-1143-最长公共子序列","date":"2021-04-02T02:24:36.000Z","updated":"2021-04-06T03:08:30.066Z","comments":true,"path":"posts/55105.html","link":"","permalink":"https://www.itnxd.cn/posts/55105.html","excerpt":"","text":"题目链接：LeetCode 1143. 最长公共子序列 ¶一、题解 最长公共子序列，经典的线性DP问题！ 思路： 状态表示：两个字符串，使用二维数组f[i][j]表示字符串a的前i个和字符串b的前j个子串的集合！属性为：计算最大值！ 状态计算： 都选，在二者相同情况下有解：f[i - 1][j - 1] + 1 a[i]选b[j]不选：f[i][j - 1]，a[i]不一定可以匹配，包含第四种情况 a[i]不选b[j]选：f[i - 1][j]，b[j]不一定可以匹配，包含第四种情况 都不选：f[i - 1][j - 1] 最终答案： f[n][m] 因此： 只计算前三种情况最大值即可，第四种已经被包含在内！ 注意： 下标问题，f[i][j]对应字符串下标为i - 1, j - 1 ¶二、AC代码 参考代码： 12345678910111213class Solution {public: int longestCommonSubsequence(string a, string b) { int n = a.size(), m = b.size(); vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1)); for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++){ f[i][j] = max(f[i - 1][j], f[i][j - 1]); if(a[i - 1] == b[j - 1]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } return f[n][m]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"DP","slug":"DP","permalink":"https://www.itnxd.cn/tags/DP/"}],"author":"ITNXD"},{"title":"每日一题之AcWing 1381.阶乘","slug":"每日一题之AcWing-1381-阶乘","date":"2021-04-01T03:23:15.000Z","updated":"2021-04-06T03:08:30.058Z","comments":true,"path":"posts/33788.html","link":"","permalink":"https://www.itnxd.cn/posts/33788.html","excerpt":"","text":"题目链接：AcWing 1381. 阶乘 ¶一、题解 数学思想： 0是如何产生的？ 当然是有2和5相乘得到的！那么，只要我们将2和5都除掉，那不就没有0了！ 具体思路： 遍历过程中，将每个数的因子2和5计数并除掉 结果每次只保留个位数即可 由于因子2和因子5的个数不一定相等，所以再进行一次乘2运算 因子2的个数一定比因子5的多，因此最终一定是2被除了多次，我们只要再将其乘回来即可！乘的次数为a - b ¶二、AC代码 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int n;int main(){ cin &gt;&gt; n; int a = 0, b = 0, res = 1; for(int i = 1; i &lt;= n; i ++){ int x = i; while(x % 2 == 0) x /= 2, a ++; while(x % 5 == 0) x /= 5, b ++; res = res * x % 10; } for(int i = 0; i &lt; a - b; i ++) res = res * 2 % 10; cout &lt;&lt; res &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"因式分解","slug":"因式分解","permalink":"https://www.itnxd.cn/tags/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/"}],"author":"ITNXD"},{"title":"每日一题之LeetCode 1006.笨阶乘","slug":"每日一题之LeetCode-1006-笨阶乘","date":"2021-03-31T03:22:52.000Z","updated":"2021-04-06T03:08:30.066Z","comments":true,"path":"posts/337.html","link":"","permalink":"https://www.itnxd.cn/posts/337.html","excerpt":"","text":"题目链接：LeetCode 1006. 笨阶乘 ¶一、题解 ¶解法一： 思路： 找规律！ n * (n - 1) / (n - 2) + (n - 3) - (n - 4) * (n - 5) / (n - 6) + (n - 7) - (n - 8).... 对于乘除法：n(n - 1)/(n - 2)，多项式进行一下除法可知道结果为n + 1 + 2 / (n - 2)，因此在n &gt; 4的情况下，最终结果为n + 1，在n &lt;= 4的情况下，则直接算即可！ n &gt; 4的情况下： 第一组三项为n + 1，同理，下一组三项的乘除法结果为n - 3，可以发现正好和第四项抵消！ 结论：除了前三个，连续的四个数结果都为0。 所以有四种情况，根据模4结果处理！ 因此最终为： n &gt; 4 时： n % 4 == 0：最终结果为n + 1 + 5 - 4 * 3 / 2 + 1 n % 4 == 1：最终结果为n + 1 + 2 - 1 n % 4 == 2：最终结果为n + 1 + 3 - 2 * 1 n % 4 == 3：最终结果为n + 1 + 4 - 3 * 2 / 1 n &lt; 4时： n == 1：1 n == 2：2 * 1 n == 3：3 * 2 + 1 n == 4：4 * 3 + 2 - 1 ¶解法二： 思路： 用栈保存数据，保存用于加减法的数据！可以每四次运算循环一次！ 乘除法直接用当前栈顶数据计算即可，计算完毕再入栈 加减法直接入栈；减法入栈该数的相反数即可！ 此时栈内元素都是用于加法的数据，最后将栈的数据依次计算出来即可 记得每次运算都要判断是否为0！ ¶二、AC代码 参考代码一： 123456789101112131415class Solution {public: stack&lt;int&gt; stk; int clumsy(int N) { if(N == 1) return 1; if(N == 2) return 2 * 1; if(N == 3) return 3 * 2 / 1; if(N == 4) return 4 * 3 / 2 + 1; if(N % 4 == 0) return N + 1 + 5 - 4 * 3 / 2 + 1; if(N % 4 == 1) return N + 1 + 2 - 1; if(N % 4 == 2) return N + 1 + 3 - 2 * 1; // N % 4 == 3 return N + 1 + 4 - 3 * 2 / 1; }}; 参考代码二： 12345678910111213141516171819class Solution {public: stack&lt;int&gt; stk; int clumsy(int N) { stk.push(N--); while(N){ if(N) stk.top() *= N --; if(N) stk.top() /= N --; if(N) stk.push(N --); if(N) stk.push(-N --); } int res = 0; while(stk.size()){ res += stk.top(); stk.pop(); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"},{"name":"找规律","slug":"找规律","permalink":"https://www.itnxd.cn/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"}],"author":"ITNXD"},{"title":"每日一题之AcWing 15.二维数组中的查找","slug":"每日一题之AcWing-15-二维数组中的查找","date":"2021-03-30T03:22:11.000Z","updated":"2021-04-06T03:08:30.058Z","comments":true,"path":"posts/20007.html","link":"","permalink":"https://www.itnxd.cn/posts/20007.html","excerpt":"","text":"题目链接：AcWing 15. 二维数组中的查找 ¶一、题解 题目大意： 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。判断是否包含某个数字！ 思路分析： 本题真的是一个思维题目！巧妙的很！ 我们可以将右上角位置作为突破口！ 对于有上角来说，它是一行最大，它又是一列最小！ 这是一个很好的特性！ 若目标数字小于右上角，则它一定不是最后一列，删掉即可 若目标数字大于右上角，则它一定不是第一行，删掉即可 若目标数子等于右上角，则表名已经找到，否则没有找到 时间复杂度：矩阵一共有 n 行，m 列，则复杂度为 O(n + m) 空间复杂度：O(1) ¶二、AC代码 12345678910111213class Solution {public: bool searchArray(vector&lt;vector&lt;int&gt;&gt; array, int target) { if(array.empty() || array[0].empty()) return false; int i = 0, j = array[0].size() - 1; while(i &lt; array.size() &amp;&amp; j &gt;= 0){ if(array[i][j] == target) return true; if(array[i][j] &gt; target) j --; else i ++; } return false; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://www.itnxd.cn/tags/%E6%80%9D%E7%BB%B4/"}],"author":"ITNXD"},{"title":"每日一题之AcWing 77.翻转单词顺序","slug":"每日一题之AcWing-77-翻转单词顺序","date":"2021-03-29T03:28:02.000Z","updated":"2021-03-29T07:59:40.015Z","comments":true,"path":"posts/6719.html","link":"","permalink":"https://www.itnxd.cn/posts/6719.html","excerpt":"","text":"题目链接：AcWing 77. 翻转单词顺序 ¶一、题解 思路一： 开一个额外的字符串来存储每个单词 倒序进行扫描一遍，然后进行拼接res += tmp + \" \"即可 最后记得还要进行一次res += tmp 时间复杂度：O(n) 空间复杂度：O(n) 可以参考代码一！ 思路二： 思路一很明显使用了额外的空间，更优的做法是不使用额外的空间进行原地处理！ 可以先将整个字符串进行反转 然后对每一个单词进行反转即可 时间复杂度：O(n) 空间复杂度：O(1) 参考代码二！ ¶二、AC代码 参考代码一： 123456789101112class Solution {public: string reverseWords(string s) { string res, tmp; for(int i = s.size() - 1; i &gt;= 0; i --){ if(s[i] == ' ') res += tmp + \" \", tmp = \"\"; else tmp = s[i] + tmp; } res += tmp; return res; }}; 参考代码二： 12345678910111213class Solution {public: string reverseWords(string s) { reverse(s.begin(), s.end()); for(int i = 0; i &lt; s.size(); i ++){ int j = i; while(j &lt; s.size() &amp;&amp; s[j] != ' ') j ++; reverse(s.begin() + i, s.begin() + j); i = j; } return s; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"ITNXD"},{"title":"每日一题之LeetCode 190.颠倒二进制位","slug":"每日一题之LeetCode-190-颠倒二进制位","date":"2021-03-29T03:27:40.000Z","updated":"2021-03-29T07:59:40.029Z","comments":true,"path":"posts/51716.html","link":"","permalink":"https://www.itnxd.cn/posts/51716.html","excerpt":"","text":"题目链接：LeetCode 190. 颠倒二进制位 ¶一、题解 题目意思： 将一个32位无符号整数进行反转！ 思路： 可以从后往前取出该无符号整数的每一位即n &gt;&gt; 1 &amp; 1 然后将结果左移空出最后一位再加上上一步的结果即可，(res &lt;&lt; 1) + (n &gt;&gt; i &amp; 1) 注意： 加法优先级高于位运算 移位运算高于与或非 时间复杂度：O(1) 空间复杂度：O(1) ¶二、AC代码 参考代码： 12345678class Solution {public: uint32_t reverseBits(uint32_t n) { uint32_t res = 0; for(int i = 0; i &lt; 32; i ++) res = (res &lt;&lt; 1) + (n &gt;&gt; i &amp; 1); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}],"author":"ITNXD"},{"title":"每日一题之AcWing 19.二叉树的下一个节点","slug":"每日一题之AcWing-19-二叉树的下一个节点","date":"2021-03-28T03:27:05.000Z","updated":"2021-03-29T07:59:40.009Z","comments":true,"path":"posts/43631.html","link":"","permalink":"https://www.itnxd.cn/posts/43631.html","excerpt":"","text":"题目链接：AcWing 19. 二叉树的下一个节点 ¶一、题解 题目大意： 给定一个二叉树中的一个节点，找到使用中序遍历的下一个节点！ 思路： 分情况讨论即可！ 若当前节点有右子树（例如下图的C），则表示当前节点的左子树已经遍历完毕，则只要去找他的右子树得最左边节点就是该节点的后继节点（即B） 若当前节点没有右子树（例如下图的D），则表示当前节点左子树已经遍历完毕，需要沿着父节点找，找第一个是其父节点左儿子的节点，例如当前节点是D，则第一个满足是其父节点左儿子的节点是F，则C的father就是D的后继，即F是D的后继。 简图如下： 时间复杂度：O(n) 空间复杂度：O(1) ¶二、AC代码 参考代码： 12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode *father; * TreeNode(int x) : val(x), left(NULL), right(NULL), father(NULL) {} * }; */class Solution {public: TreeNode* inorderSuccessor(TreeNode* p) { while(p-&gt;right){ p = p-&gt;right; while(p-&gt;left) p = p-&gt;left; return p; } while(p-&gt;father &amp;&amp; p-&gt;father-&gt;right == p) p = p-&gt;father; return p-&gt;father; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"},{"name":"树的遍历","slug":"树的遍历","permalink":"https://www.itnxd.cn/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"}],"author":"ITNXD"},{"title":"每日一题之LeetCode 173.二叉搜索树迭代器","slug":"每日一题之LeetCode-173-二叉搜索树迭代器","date":"2021-03-28T03:26:39.000Z","updated":"2021-03-29T07:59:40.021Z","comments":true,"path":"posts/23863.html","link":"","permalink":"https://www.itnxd.cn/posts/23863.html","excerpt":"","text":"题目链接：LeetCode 173. 二叉搜索树迭代器 ¶一、题解 题目大意： 实现一个中序遍历的二叉树！但是要通过迭代器实现！即完成下面三个方法！ 思路： 其实就是二叉树中序遍历非递归写法的拆分！ 二叉树非递归中序遍历写法：LeetCode的94题就是！ 构造器处理第一部分 next处理下一部分，然后还得处理和构造器相同的部分 hasNext则可以直接判断栈是否为空即可 时间复杂度： O(n) 空间复杂度： O(h)，h为树的高度 ¶二、AC代码 参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class BSTIterator {public: stack&lt;TreeNode*&gt; stk; BSTIterator(TreeNode* root) { while(root){ stk.push(root); root = root-&gt;left; } } int next() { auto root = stk.top(); stk.pop(); int val = root-&gt;val; root = root-&gt;right; while(root){ stk.push(root); root = root-&gt;left; } return val; } bool hasNext() { return stk.size(); }};/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj = new BSTIterator(root); * int param_1 = obj-&gt;next(); * bool param_2 = obj-&gt;hasNext(); */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"树的遍历","slug":"树的遍历","permalink":"https://www.itnxd.cn/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"}],"author":"ITNXD"},{"title":"Java自动化构建工具之Maven的使用介绍","slug":"Java自动化构建工具之Maven的使用介绍","date":"2021-03-27T07:10:02.000Z","updated":"2021-03-27T15:18:42.695Z","comments":true,"path":"posts/49783.html","link":"","permalink":"https://www.itnxd.cn/posts/49783.html","excerpt":"","text":"¶一、Maven介绍 ¶1、Maven是什么 Maven是一款服务于Java平台的自动化构建工具！是Apache的一款开源的项目管理工具！ 什么是构建？ 简单来说：就是以“Java源文件”、“框架配置文件”、“JSP”、“HTML”、“图片”等资源为“原材料”，去“生产”一个可以运行的项目的过程。 构建过程中的各个环节： 清理∶将以前编译得到的旧的class字节码文件删除，为下一次编译做准备[2]编译∶将Java源程序编程成class字节码文件 测试∶自动测试，自动调用junit程序 报告∶测试程序执行的结果 打包∶动态Web工程打war包，Java工程打jar包 安装：Maven特定的概念——将打包得到的文件复制到“仓库”中的指定位置 部署︰将动态Web工程生成的war包复制到Servlet容器的指定目录下，使其可以运行 ¶2、Maven能干什么 如果项目非常庞大，就不适合继续使用package来划分模块。借助于Maven就可以将一个项目拆分成多个工程。 借助于Maven，可以将jar包仅仅保存在“仓库”中，有需要使用的工程“引用”这个文件接口，并不需要真的把jar包复制过来。 借助于Maven可以一种规范的方式下载jar包。因为所有知名框架或第三方工具的jar包以及按照统一的规范存放在了Maven的中央仓库中。 借助于Maven可以自动将一个包被依赖的所有jar包全部导入进来。 ¶二、Maven配置 Maven下载地址： http://maven.apache.org/download.cgi Maven 的核心程序中仅仅定义了抽象的生命周期，而具体的操作则是由 Maven 的插件来完成的。可是Maven 的插件并不包含在 Maven 的核心程序中，在首次使用时需要联网下载。 ¶1、Maven配置 环境变量配置M2_HOME为Maven安装路径 环境变量配置PATH为%M2_HOME%\\lib CMD运行命令mvn -v查看是否配置正确 ¶2、Maven的settings.xml配置 文件位于安装目录的conf目录下！ 配置默认的本地仓库位置 一般默认地址为：C:\\Users[当前登录的用户名].m2\\repository 1&lt;localRepository&gt;D:\\MyMavenRep&lt;/localRepository&gt; 配置阿里镜像地址 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;&lt;/mirror&gt; 指定JDK和编译器信息 123456789101112131415&lt;profile&gt; &lt;!-- 配置为使用jdk8 --&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;!-- 激活，使用该配置 --&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;!-- 编译器配置 --&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; ¶三、Maven工程目录结构 根目录︰工程名 src目录︰源码 pom.xml文件：Maven工程的核心配置文件 main目录∶存放主程序 test目录∶存放测试程序 java目录∶存放Java源文件 resources目录∶存放框架或其他工具的配置文件 target目录：存放编译后的内容 ¶四、常用Maven命令 注意∶执行与构建过程相关的Maven命令，必须进入pom.xml所在的目录。与构建过程相关∶编译、测试、打包、…… 常用命令： mvn clean：清理 mvn compile：编译主程序 mvn test-compile：编译测试程序 mvn test：执行测试 mvn package：打包 mvn install：安装 mvn site：生成站点 ¶五、POM POM（Project Object Model）：项目对象模型。将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。Maven 工程的核心配置。可以说学习 Maven 就是学习 pom.xml 文件中的配置。 ¶六、坐标 所谓坐标，就是可以用来唯一定位目标的方法！ Maven中的坐标由三个标签唯一决定！可以在 Maven 的仓库中唯一的确定一个 Maven 工程。 我们自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：mvn install 三大标签又被称之为：GAV坐标 groupId：公司或组织的域名倒序+当前项目名称 artifactId：当前项目的模块名称 version：当前模块的版本 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Maven工程坐标与仓库路径对应关系： 以上方依赖举例：org/springframework/spring-core/4.0.O.RELEASE/spring-core-4.0.0.RELEASE.jar ¶七、仓库 ¶1、仓库分类 本地仓库 远程仓库 私服：搭建在局域网使用的Maven仓库 中央仓库：架设在互联网上的官方Maven仓库 中央仓库镜像：镜像仓库，自然是为了加速，分担流量 优先级： 本地仓库，本地仓库没有则去中央仓库找，找到则下载到本地仓库，下次使用同一包，则无需去中央仓库下载！ ¶2、仓库中的文件 Maven自身所需要的插件 第三方框架或工具的jar包 我们自己开发的Maven工程 ¶八、依赖 Maven解析依赖信息时会到本地仓库中查找被依赖的jar包。 对于我们自己开发的Maven工程，使用mvn install命今安装后就可以进入仓库。 ¶1、依赖范围 如下图： 使用scope标签指定： 123456789&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ¶1.1、compile 默认值，表示该依赖在编译和运行时都生效 对主程序是否有效：有效 对测试程序是否有效：有效 是否参与打包：参与 是否参与部署：参与 典型例子：spring-core ¶1.2、test 见名之意，就是针对测试程序的！ 对主程序是否有效：无效 对测试程序是否有效：有效 是否参与打包：不参与 是否参与部署：不参与 典型例子：Junit ¶1.3、provided 见名之意，Tomcat服务器有的，即被提供的，就不需要再导包部署到容器运行了！ 对主程序是否有效：有效 对测试程序是否有效：有效 是否参与打包：不参与 是否参与部署：不参与 典型例子：servlet-api ¶2、依赖的传递性 A依赖B，A则会具有B声明为compile范围的依赖！ 只需要将B使用命令mvn install到本地仓库即可在A中通过GAV坐标形式引入！ 好处：可以传递的依赖不必在每个模块工程中都重复声明，在”最下面”的工程中依赖一次即可。 注意：非compile范围的依赖不能传递。所以在各个工程模块中,如果有需要就得重复声明依赖。 ¶3、依赖的排除 由于依赖的传递性会导致一些不需要的依赖被传递过来，则可以使用exclusions标签指定排除的依赖！ 无需指定版本号，默认全部排除！ 1234567891011121314151617&lt;!-- 项目A的pom.xml --&gt;&lt;dependencies&gt; &lt;!-- 依赖项目B --&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;DemoB&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;!-- 不写版本号 --&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ¶4、依赖的原则 解决模块之间jar包冲突问题！ 最短路径优先原则： A依赖B，B依赖C，若B和C有同一个依赖，即使版本不同，A仍然使用更近的B！ 路径相同时先声明者优先： A依赖B，A依赖C，B和C无关，则路径相同的情况下，A依赖pom.xml文件中先声明的！ ¶5、统一管理依赖版本 若想指定统一版本，例如Spring各个包的版本，可以使用自定义标签进行指定，然后在需要的地方统一引用即可！ 1234567&lt;properties&gt; &lt;!--自定义标签--&gt; &lt;spring.version&gt;4.0.0.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;!--指定版本的地方直接引用即可--&gt;&lt;version&gt;${ atguigu. spring. version }&lt;/version&gt; 可以使用下面的标签指定编码方式： 1234&lt;properties&gt; &lt;!--内置标签--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt; ¶6、依赖的继承 由于非 compile 范围的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置！ 例如Junit，各个模块版本会不一致！ ¶6.1、创建打包方式为pom的父工程 创建打包方式为pom的父工程，并在其中使用dependencyManagement统一管理依赖！ 12345678910111213141516&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;&lt;artifactId&gt;Parent&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;!--在父工程中管理依赖--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; ¶6.2、子工程引用父工程实现继承 注意：标签中的relateivePath是相对于当前pom.xml目录的父工程路径！ 删除子工程的版本号配置，也可以不删除，即表示不使用父工程版本！ 删除范围scope！ 注意：配置了继承，执行安装命令要先安装父工程！ 1234567891011121314151617181920212223&lt;!--这个groupId父工程也有，也可以删掉--&gt;&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;&lt;artifactId&gt;WebProject01&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt;&lt;!--在子工程中声明使用父工程--&gt;&lt;parent&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 指定从当前子工程的pom.xml文件出发，查找父工程的pom.xml的路径 --&gt; &lt;relativePath&gt;../Parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt;&lt;!--在子工程中声明使用父工程具体依赖--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!-- 无需声明版本号，继承父工程的版本号 --&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ¶九、生命周期 Maven 生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven 就可以自动化的执行构建命令了。 各个构建环节执行的顺序: 不能打乱顺序,必须按照既定的正确顺序来执行。 Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的。 Maven核心程序为了更好的实现自动化构建,按照这一 的特点执行生命周期中的各个阶段，不论现在要执行生命周期中的哪一个阶段，都是从这个生命周期最初的位置开始执行。 Maven 的生命周期与插件目标相互绑定，以完成某个具体的构建任务。例如：compile 就是插件 maven-compiler-plugin 的一个目标；pre-clean 是插件 maven-clean-plugin 的一个目标。 ¶十、聚合 一键安装各个模块工程！ 将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进行 clean 操作。而使用了聚合之后就可以批量进行 Maven 工程的安装、清理工作。 可以在其他工程做聚合操作，也可以直接在实现继承的父工程中做聚合操作！一般就在实现继承的父工程内！ 在总的聚合工程（父工程）中使用 modules/module 标签组合，指定模块工程的相对路径即可： 12345&lt;modules&gt; &lt;module&gt;../Hello&lt;/module&gt; &lt;module&gt;../HelloFriend&lt;/module&gt; &lt;module&gt;../MakeFriends&lt;/module&gt;&lt;/modules&gt; 使用方式： 在聚合工程的pom.xml上点右键 run as - maven install即可！ ¶十一、在Eclipse中使用Maven Eclipse内置了Maven插件！ ¶1、Maven插件的设置 设置路径：window -&gt; preference -&gt; Maven installations：指定Maven核心程序的位置。不建议使用插件自带的Maven程序，而应该使用我们自己解压的那个。 user settings：指定conf/settings.xml的位置，进而获取本地仓库的位置。 ¶2、创建Maven版的Java工程 打包方式设置为jar即可！ 若右键new没有Maven project选项，可以在如下位置进行设置： 在下方选项卡中找到Maven Project勾选上即可！ 记得勾选如下位置： 这样创建的为标准结构的Maven工程！ 解决Eclipse工程JDK默认为1.5的bug： 直接在Maven的settings.xml中添加配置如下： 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; ¶3、创建Maven版的Web工程（了解） 打包方式设置为war即可！ 解决创建完成之后因缺少 web.xml 文件工程pom.xml出现小红叉： 在工程上右键→Build Path→Configure Build Path… 点击 Project Facets 表示 Eclipse 当前工程不是 Web 工程，点击应用 再告诉 Eclipse 当前工程是一个 Web 工程，点击应用并关闭，出现一个配置项，设置一个Content diretory目录存放web资源，设置为WebContext或src/main/webapp，此时会生成web.xml文件和WEB-INF目录 ¶4、在 Eclipse 中导入 Maven 工程 点击 File→Import… 标准的Maven工程自然就可以方式一导入！ 手动创建的 Maven 项目时，由于项目中没有 Eclipse 生成的一些文件，使用方式一导入时 Eclipse 认为它不是一个工程！只能使用方式二！ Eclipse是通过pom.xml文件识别为Maven项目的 导入到 Eclipse 中之后就会生成一些 Eclipse 能识别的文件 有了这些 Eclipse 能识别的文件之后以后再往 Eclipse 中导入的时候选择方式一和方式二都可以 ¶十二、在IDEA中使用Maven Idea 中也自带 Maven 插件，而且我们也可以给自带的 Maven 插件进行配置，所以我们可以使用自带的 Maven，也可以使用我们安装的 Maven 核心程序。 ¶1、Maven插件设置 ¶2、创建Maven版的Java工程 直接新建Module，记得勾选下方圈中的部分，表示创建标准结构的Maven工程！ ¶3、创建Maven版的Web工程（了解） 创建方式同上，修改配置打包方式为war如下： 123456&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;&lt;artifactId&gt;WebMavenProject&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!--手动指定为Web工程的打包方式war--&gt;&lt;packaging&gt;war&lt;/packaging&gt; 在project structure中设置添加生成web.xml配置文件： ¶4、在Idea中导入Maven工程 Idea导入和Eclipse一样，也是引用，而非复制，若想导入到本项目路径下，需要手动复制，再进行导入！ 在project structure中导入： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"构建工具","slug":"构建工具","permalink":"https://www.itnxd.cn/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://www.itnxd.cn/tags/Maven/"}],"author":"ITNXD"},{"title":"每日一题之LeetCode 61.旋转链表","slug":"每日一题之LeetCode-61-旋转链表","date":"2021-03-27T03:25:06.000Z","updated":"2021-03-29T07:59:40.034Z","comments":true,"path":"posts/29975.html","link":"","permalink":"https://www.itnxd.cn/posts/29975.html","excerpt":"","text":"题目链接：LeetCode 61. 旋转链表 ¶一、题解 题目大意： 给定一个链表，将链表每个节点都向后移动k个位置！ 思路： k的数非常大，所以可以和链表长度去个模！ 由于k %= n，所以以防除0问题，先在最开始判断一下，若链表长度为0，则直接返回即可 将每个节点后移k位，即将链表后k个节点移到链表开头即可 指针向后移动n - k - 1次即可走到后k个节点的上一个节点 然后处理一下指针指向即可！ 时间复杂度： O(n) 空间复杂度： O(1) ¶二、AC代码 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* rotateRight(ListNode* head, int k) { if(!head) return head; int n = 0; for(auto p = head; p; p = p-&gt;next) n ++; k %= n; if(!k) return head; auto p = head; for(int i = 0; i &lt; n - k - 1; i ++) p = p-&gt;next; auto tail = p; while(tail-&gt;next) tail = tail-&gt;next; tail-&gt;next = head, head = p-&gt;next, p-&gt;next = NULL; return head; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"ITNXD"},{"title":"Spring全家桶之Spring5新功能-整合Log4j2日志、Nullable注解、整合JUnit5","slug":"Spring全家桶之Spring5新功能-整合Log4j2日志、Nullable注解、整合JUnit5","date":"2021-03-26T07:25:48.000Z","updated":"2021-03-26T09:09:10.396Z","comments":true,"path":"posts/34962.html","link":"","permalink":"https://www.itnxd.cn/posts/34962.html","excerpt":"","text":"整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的类和方法在代码库中删除！ Spring5中文版新功能可以在这里看到：https://cntofu.com/book/95/33-what-new-in-the-spring-framework.md ¶一、Spring整合Log4j2日志框架 Spring 5.0 框架自带了通用的日志封装 ，Spring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2 ¶1、导包 ¶2、创建 log4j2.xml 配置文件 配置文件要放到src下，且名字只能为 log4j2.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，可以看到log4j2内部各种详细输出--&gt;&lt;configuration status=\"INFO\"&gt; &lt;!--先定义所有的appender--&gt; &lt;appenders&gt; &lt;!--输出日志信息到控制台--&gt; &lt;console name=\"Console\" target=\"SYSTEM_OUT\"&gt; &lt;!--控制日志输出的格式--&gt; &lt;PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/&gt; &lt;/console&gt; &lt;/appenders&gt; &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt; &lt;!--root：用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出--&gt; &lt;loggers&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"Console\"/&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 12345// 手动创建日志输出！public static void main(String[] args) { logger.info(\"hello log4j2!!!\"); logger.warn(\"hello lo4j2!!!\");} ¶二、Spring5新注解Nullable Spring5 框架核心容器支持@Nullable 注解。 @Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空 ¶三、Spring整合Junit单元测试 导包：spring-test-5.3.5.jar ¶1、Spring整合Junit4 1234567891011121314151617181920212223@RunWith(SpringJUnit4ClassRunner.class) // 指定单元测试框架@ContextConfiguration(\"classpath:bean1.xml\") // 指定加载的配置文件public class Junit4Test {// 以前写法：// @Test// public void test1() {// ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\");// UserService userService = context.getBean(\"userService\", UserService.class);// userService.accountMoney();// } // 现在写法： @Autowired private UserService userService; @Test public void test1(){ userService.accountMoney(); }} ¶2、Spring整合Junit5 Junit5的注解有一个复合注解@SpringJUnitConfig，可以一次性完成两个注解！ 123456789101112131415//@ExtendWith(SpringExtension.class) // 指定单元测试框架//@ContextConfiguration(\"classpath:bean1.xml\") // 指定加载的配置文件// Spring5对于junit5的复合注解@SpringJUnitConfig(locations = \"classpath:bean1.xml\")public class Junit5Test { @Autowired private UserService userService; @Test public void test1(){ userService.accountMoney(); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Spring全家桶","slug":"Spring全家桶","permalink":"https://www.itnxd.cn/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"}],"tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://www.itnxd.cn/tags/Spring5/"},{"name":"Log4j2","slug":"Log4j2","permalink":"https://www.itnxd.cn/tags/Log4j2/"},{"name":"Junit5","slug":"Junit5","permalink":"https://www.itnxd.cn/tags/Junit5/"},{"name":"Nullable","slug":"Nullable","permalink":"https://www.itnxd.cn/tags/Nullable/"}],"author":"ITNXD"},{"title":"Spring全家桶之Spring5-JdbcTemplate与事务操作","slug":"Spring全家桶之Spring5-JdbcTemplate与事务操作","date":"2021-03-26T02:43:29.000Z","updated":"2021-03-26T09:09:10.414Z","comments":true,"path":"posts/22145.html","link":"","permalink":"https://www.itnxd.cn/posts/22145.html","excerpt":"","text":"¶一、JdbcTemplate 可以使用Spring提供的JdbcTemplate来操作数据库！ 虽然后面会被其他框架代替！ ¶1、导包 导入如下包： ¶2、配置XML 开启注解扫描 配置数据库连接池 配置JdbcTemplate 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--添加context和aop命名空间!--&gt; &lt;!--开启组件扫描--&gt; &lt;context:component-scan base-package=\"com.atguigu\"&gt;&lt;/context:component-scan&gt; &lt;!--数据库连接池配置：--&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///user_db\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"xxx\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--jdbcTemplate配置：--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;!--注入dataSource:--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; ¶3、创建Service和Dao 123456789101112@Repositorypublic class UserDaoImpl implements UserDao {}@Servicepublic class UserService { // 注入Dao @Autowired private UserDao userDao;} ¶4、增删改查操作 UserDaoImpl实现： queryForObject有三个参数 ： 第一个参数：sql 语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装\\ 第三个参数：sql 语句值 query有三个参数： 第一个参数：sql 语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装 第三个参数：sql 语句值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Repositorypublic class UserDaoImpl implements UserDao { // 注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; @Override public void addUser(User user) { String sql = \"insert into t_user values(?, ?, ?)\"; int update = jdbcTemplate.update(sql, user.getUserId(), user.getUserName(), user.getUserStatus()); System.out.println(update); } @Override public void update(User user) { String sql = \"update t_user set user_name = ? where user_id = ?\"; int update = jdbcTemplate.update(sql, user.getUserName(), user.getUserId()); System.out.println(update); } @Override public void delete(String id) { String sql = \"delete from t_user where user_id = ?\"; int update = jdbcTemplate.update(sql, id); System.out.println(update); } @Override public int queryCount() { String sql = \"select count(*) from t_user\"; return jdbcTemplate.queryForObject(sql, Integer.class); } @Override public User queryBook(String id) { String sql = \"select * from t_user where user_id = ?\"; return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), id); } @Override public List&lt;User&gt; queryForAll() { String sql = \"select * from t_user\"; return (List&lt;User&gt;) jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class)); }} ¶5、批量操作 123456789101112131415161718192021222324/** * 将list集合中的object数组拿到，遍历后填入占位符！ * @param batchArgs */@Overridepublic void batchAdd(List&lt;Object[]&gt; batchArgs) { String sql = \"insert into t_user values(?,?,?)\"; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));}@Overridepublic void batchUpdate(List&lt;Object[]&gt; batchArgs) { String sql = \"update t_user set user_name = ? where user_id = ?\"; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));}@Overridepublic void batchDelete(List&lt;Object[]&gt; batchArgs) { String sql = \"delete from t_user where user_id = ?\"; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));} ¶二、事务操作 以转账多钱和少钱为例！ ¶1、概述 事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层） 在 Spring 进行事务管理操作 编程式事务管理 声明式事务管理（使用）：即具体事务管理有Spring底层实现 声明式事务管理 基于注解方式（使用） 基于 xml 配置文件方式 在 Spring 进行声明式事务管理，底层使用 AOP 原理 Spring事务管理API：提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类 ¶2、导包 导的包同上一节的JdbcTemplate！ ¶3、创建Dao和Service service 注入 dao，在 dao 注入 JdbcTemplate，在 JdbcTemplate 注入 DataSource！ UserDaoImpl： 123456789101112131415161718192021@Repositorypublic class UserDaoImpl implements UserDao { @Autowired private JdbcTemplate jdbcTemplate; // lucy给mary转账100 @Override public void addMoney() { String sql = \"update t_account set money = money - ? where username = ?\"; jdbcTemplate.update(sql, 100, \"lucy\"); } @Override public void reduceMoney() { String sql = \"update t_account set money = money + ? where username = ?\"; jdbcTemplate.update(sql, 100, \"mary\"); }} UserService： 编程式事务管理和声明式事务管理！ 123456789101112131415161718192021222324252627282930313233343536@Servicepublic class UserService { @Autowired private UserDao userDao; // 转账方法： public void accountMoney(){ // 下面这一步步的手动实现就叫做 编程式事务管理！// try{// // 1. 开启事务//// // 2. 业务逻辑// // lucy少100// userDao.reduceMoney();// // mary多100// userDao.addMoney();// // 3. 事务提交// }catch (Exception e){// // 4. 事务回滚//// e.printStackTrace();// } // 使用事务注解后： // lucy少100 userDao.reduceMoney(); int i = 1 / 0; // 模拟异常 // mary多100 userDao.addMoney(); }} ¶3、基于注解的声明式事务管理 ¶3.1、XML配置 开启注解扫描 配置数据库连接池 配置jdbcTemplate 创建事务管理器 开启事务注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--添加context和aop和tx命名空间!--&gt; &lt;!--开启组件扫描--&gt; &lt;context:component-scan base-package=\"com.atguigu\"&gt;&lt;/context:component-scan&gt; &lt;!--数据库连接池配置：--&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///user_db\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"xxx\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--jdbcTemplate配置：--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;!--注入dataSource:--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--创建事务管理器--&gt; &lt;!--DataSourceTransactionManager：myBatis和jdbc使用--&gt; &lt;!--HibernateTransactionManager：Hibernate使用--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!--注入数据源DataSource，ref指定我们上面创建的数据库连接池--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启事务注解，tx名称空间，指定使用哪个事务管理器--&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt; ¶3.2、Service层上添加事务注解 在 service 类上面（或者 service 类里面方法上面）添加事务注解： @Transactional，这个注解添加到类上面，也可以添加方法上面 如果把这个注解添加类上面，这个类里面所有的方法都添加事务 如果把这个注解添加方法上面，为这个方法添加事务 Transactional事务注解有以下参数： propagation：事务传播行为，多事务方法直接进行调用，这个过程中事务 是如何进行管理的，前两个重要： Spring中的七种传播行为： ioslation：事务隔离级别，默认为REPEATABLE_READ timeout：超时时间 事务需要在一定时间内进行提交，如果不提交进行回滚 默认值是 -1 ，设置时间以秒单位进行计算 readOnly：是否只读 读：查询操作，写：添加修改删除操作 readOnly 默认值 false，表示可以查询，可以添加修改删除操作 设置 readOnly 值是 true，设置成 true 之后，只能查询 rollbackFor：回滚，设置出现哪些异常进行事务回滚 noRollbackFor：不回滚，设置出现哪些异常不进行事务回滚 代码参考： 12345678@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.REPEATABLE_READ, timeout = 5, readOnly = false, rollbackFor = Exception.class)public class UserService { } ¶4、基于XML配置的声明式事务管理 配置事务管理器 配置通知 配置切入点和切面 1234567891011121314151617181920212223242526272829303132&lt;!--基于xml方式实现！--&gt; &lt;!--一、创建事务管理器--&gt; &lt;!--DataSourceTransactionManager：myBatis和jdbc使用--&gt; &lt;!--HibernateTransactionManager：Hibernate使用--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!--注入数据源DataSource，ref指定我们上面创建的数据库连接池--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--xml方式不需要：--&gt;&lt;!-- &amp;lt;!&amp;ndash;开启事务注解，tx名称空间，指定使用哪个事务管理器&amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;tx:annotation-driven transaction-manager=\"transactionManager\"&gt;&lt;/tx:annotation-driven&gt;--&gt; &lt;!--二、配置通知--&gt; &lt;tx:advice id=\"txAdvice\"&gt; &lt;!--配置事务参数--&gt; &lt;tx:attributes&gt; &lt;!--指定哪种规则的方法上面添加事务--&gt; &lt;tx:method name=\"accountMoney\" isolation=\"REPEATABLE_READ\" timeout=\"5\"/&gt; &lt;!--或者：account*表示以account开头的都添加事务--&gt; &lt;tx:method name=\"account*\" propagation=\"REQUIRED\"&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--三、配置切入点和切面--&gt; &lt;aop:config&gt; &lt;!--配置切入点，使用切入点表达式--&gt; &lt;aop:pointcut id=\"pt\" expression=\"execution(* com.atguigu.service.UserService.*(..))\"/&gt; &lt;!--配置切面--&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; ¶5、完全注解开发 创建配置类，使用配置类替代 xml 配置文件！ 1234567891011121314151617181920212223242526272829303132333435363738@Configuration // 表名是注解类@ComponentScan(basePackages = {\"com.atguigu\"}) // 开启组件扫描@EnableTransactionManagement // 开启事务public class TXConfig { // 创建数据库连接池 @Bean public DruidDataSource getDruidDataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(\"jdbc:mysql:///user_db\"); dataSource.setDriverClassName(\"com.mysql.cj.jdbc.driver\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"xxx\"); return dataSource; } // 创建JdbcTemplate对象 @Bean public JdbcTemplate getJdbcTemplate(DataSource dataSource){ // 到IOC容器中找到上面方法的druidDataSource JdbcTemplate jdbcTemplate = new JdbcTemplate(); // 注入DataSource jdbcTemplate.setDataSource(dataSource); // 或者直接调用，这里不会再次创建，这样写没有问题！// jdbcTemplate.setDataSource(getDruidDataSource()); return jdbcTemplate; } // 创建事务管理器 // 注入DataSource：两种方法都可，同上 @Bean public DataSourceTransactionManager getDataSourceTransactionManager(){ DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); // 注入DataSource transactionManager.setDataSource(getDruidDataSource()); return transactionManager; }} 测试： 1234567// 基于完全注解@Testpublic void test3() { ApplicationContext context = new AnnotationConfigApplicationContext(TXConfig.class); UserService userService = context.getBean(\"userService\", UserService.class); userService.accountMoney();} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Spring全家桶","slug":"Spring全家桶","permalink":"https://www.itnxd.cn/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"}],"tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://www.itnxd.cn/tags/Spring5/"},{"name":"JdbcTemplate","slug":"JdbcTemplate","permalink":"https://www.itnxd.cn/tags/JdbcTemplate/"},{"name":"声明式事务","slug":"声明式事务","permalink":"https://www.itnxd.cn/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"}],"author":"ITNXD"},{"title":"Spring全家桶之Spring5-AOP使用介绍","slug":"Spring全家桶之Spring5-AOP使用介绍","date":"2021-03-26T01:09:56.000Z","updated":"2021-03-26T09:09:10.423Z","comments":true,"path":"posts/38615.html","link":"","permalink":"https://www.itnxd.cn/posts/38615.html","excerpt":"","text":"¶一、AOP概述 ¶1、概述 Aspect Oriented Programming，面向切面编程，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 通俗描述：不通过修改源代码方式，在主干功能里面添加新功能 ¶2、AOP底层原理 底层自然是通过动态代理实现的！ ¶2.1、JDK动态代理 有接口情况，使用 JDK 动态代理！ 创建接口实现类代理对象，增强类的方法！ ¶2.2、CGLIB动态代理 没有接口情况，使用 CGLIB 动态代理！ 创建子类的代理对象，增强类的方法！ ¶二、JDK动态代理 ¶1、创建接口，定义方法 123public interface UserDao { int add(int a, int b);} ¶2、创建接口实现类，实现方法 12345678public class UserDaoImpl implements UserDao { @Override public int add(int a, int b) { System.out.println(\"add方法执行了！\"); return a + b; }} ¶3、使用 Proxy 类创建接口代理对象 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)： 参数一：类加载器，任何类都可，都是调用的系统类加载器 参数二：实现类接口，Class[]类型，即xxxDao，支持多个接口 参数三：InvocationHandler，实现这个接口 InvocationHandler，创建代理对象，写增强的部分 12345678910111213141516171819202122public class JDKProxy { public static void main(String[] args) { // 创建接口实现类的代理对象！ Class[] interfaces = {UserDao.class}; /*Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { return null; } });*/ // 类似：UserDao userDao = new UserDaoImpl(); UserDao userDao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(new UserDaoImpl())); int res = userDao.add(2, 5); System.out.println(res); }} 代理对象UserDaoProxy类，实现InvocationHandler： 将要被代理的类传递过来，通过有参构造传递，一般是接口的实现类 重写invoke方法，实现方法增强 可以通过method.getName()来判断传入的方法，进行区别对待，增强不同方法！ public Object invoke(Object obj, Object... args)： 参数一：调用增强方法的对象实现类对象UserDaoImpl 参数二：增强方法add的参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class UserDaoProxy implements InvocationHandler { // 假设要增强UserDaoImpl的add方法！ /* 1. 将要被代理的类传过来 通过有参构造传递 */ private Object obj; public UserDaoProxy(Object obj){ this.obj = obj; } /** * 增强方法的逻辑！ * * 可以通过method.getName来判断传入的方法，进行区别对待，增强不同方法！ * * @param proxy 代理对象 * @param method 当前方法 * @param args 参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 方法之前：获取到当前增强方法的名称 System.out.println(\"方法执行之前执行！\" + \" 方法名：\" + method.getName() + \" 参数：\" + Arrays.toString(args)); // 被增强的方法执行 // 参数一：调用增强方法的对象实现类对象UserDaoImpl // 参数二：增强方法add的参数 Object res = method.invoke(obj, args); // 方法之后 System.out.println(\"方法执行之后执行！\" + obj); return res; }} ¶三、AOP相关术语 ¶1、连接点 指的是类里面哪些方法可以被增强，这些方法就是连接点！ ¶2、切入点 实际真正被增强的方法称为切入点！ ¶3、通知 实际增强的逻辑部分称为通知！ 通知分类： 前置通知：执行目标方法之前运行 后置通知：目标方法正常执行完之后执行 环绕通知：目标方法前后分别执行，需要显式调用目标方法 异常通知：目标方法出现异常执行 最终通知：一定会执行 ¶4、切面 是一个动作，将通知应用到切入点的过程！ 人话：就是将增强的实现逻辑应用到需要被增强方法的过程！ ¶四、AOP使用 ¶1、导包 从下载的Spring5的包内找到下面几个包，导入即可！ 图中几个两个com开头的包不在Spring5包内，需要额外下载！可以从名称看到，他的作用就是支持CGLIB！ AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作！ 注意：旧版本com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar会报错！新版JDK不兼容，要使用aspectjweaver-1.9.6.jar 下载地址：https://mvnrepository.com/artifact/org.aspectj/aspectjweaver ¶2、切入点表达式 切入点表达式作用：知道对哪个类里面的哪个方法进行增强 语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]) ) 权限修饰符可以省略，默认为public 返回类型可以使用通配符*表示 全类名和方法名也可使用通配符代替 参数列表，固定写法(..) 注意点：表示返回类型的*号后面一定要有一个空格 几个例子： 12345execution(* com.atguigu.dao.BookDao.add(..))execution(* com.atguigu.dao.BookDao.* (..))execution(* com.atguigu.dao.*.* (..)) ¶3、基于AspectJ 注解 ¶3.1、创建增强类和被增强类 User 12345public class User { public void add(){ System.out.println(\"add().............\"); }} UserProxy 12345678910public class UserProxy { /** * 前置通知！ */ @Before(value = \"execution(* com.atguigu.aop.anno.User.add(..))\") public void before(){ System.out.println(\"UserProxy.before()................\"); }} ¶3.2、具体步骤 引入context名称空间，开启注解扫描 使用注解创建User和UserProxy对象 在增强类上面添加注解 @Aspect 引入aop名称空间，在 spring 配置文件中开启生成代理对象 配置不同类型的通知 User： 12@Component(value = \"user\")public class User { UserProxy： 在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置！ 前置通知：执行目标方法之前运行 后置通知：目标方法正常执行完之后执行 环绕通知：目标方法前后分别执行，需要显式调用目标方法 proceedingJoinPoint.proceed() 异常通知：目标方法出现异常执行 最终通知：一定会执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Component // 生成代理对象@Aspect // 生成代理对象！public class UserProxy { /** * 前置通知！ */ @Before(value = \"execution(* com.atguigu.aop.anno.User.add(..))\") public void before(){ System.out.println(\"UserProxy.before()................\"); } /** * 后置通知：正常返回会执行！ */ @AfterReturning(value = \"execution(* com.atguigu.aop.anno.User.add(..))\") public void afterReturning(){ System.out.println(\"afterReturning()................\"); } /** * 最终通知：正常返回和抛异常都会执行！因此称之为最终通知！ */ @After(value = \"execution(* com.atguigu.aop.anno.User.add(..))\") public void after(){ System.out.println(\"after()................\"); } /** * 异常通知：有异常才会执行！ */ @AfterThrowing(value = \"execution(* com.atguigu.aop.anno.User.add(..))\") public void afterThrowing(){ System.out.println(\"afterThrowing()................\"); } /** * 环绕通知：在被增强方法前后执行！需要显示调用被增强方法! * @param proceedingJoinPoint * @throws Throwable */ @Around(value = \"execution(* com.atguigu.aop.anno.User.add(..))\") public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { System.out.println(\"around()之前................\"); // 执行被增强的方法！ proceedingJoinPoint.proceed(); System.out.println(\"around()之后................\"); }} XML配置： 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--添加context和aop命名空间!--&gt; &lt;!--1. 开启注解扫描--&gt; &lt;context:component-scan base-package=\"com.atguigu.aop.anno\"&gt;&lt;/context:component-scan&gt; &lt;!--2. 开启Aspect生成代理对象--&gt; &lt;!--回去找有Aspect注解的类，有就生成代理对象--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 测试： 12345678@Testpublic void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); // 这里的id无需配置，已经通过注解Component实现，value默认为首字符小写 User user = context.getBean(\"user\", User.class); user.add();} 执行结果： 后三个执行顺序或有不同，可能为如此，也可能为完全倒序，原因是spring版本更新后，底层修改了执行顺序！ 12345678910111213执行顺序： around()之前................ before()................ add()............. afterReturning()................ after()................ around()之后................有异常的执行顺序： around()之前................ before()................ afterThrowing()................ after()................ ¶3.3、相同切入点抽取 抽取： 12345678/** * 相同切入点抽取！ * 用到该切入点的直接在五种通知的value中调用该方法即可！ * 也可以使用final字符串常量抽取！ */@Pointcut(value = \"execution(* com.atguigu.aop.anno.User.add(..))\")public void pointCut(){} 使用： 1234@Before(value = \"pointCut()\")public void before(){ System.out.println(\"UserProxy.before()................\");} ¶3.4、设置增强类优先级 在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高! 1234567891011121314@Component // 生成代理对象@Aspect // 生成代理对象！@Order(value = 1) // 设置优先级，值越小优先级越高public class UserProxy {}@Component // 代理对象创建@Aspect // 生成代理对象@Order(value = 0) // 设置优先级，值越小优先级越高public class PersonProxy {} ¶3.5、完全注解开发 创建配置类： 12345@Configuration // 表名是配置类@ComponentScan(basePackages = {\"com.atguigu.aop.anno\"}) // 开启注解扫描@EnableAspectJAutoProxy(proxyTargetClass = true) // 开启Aspect生成代理对象public class AOPConfig {} 测试： 12345678@Testpublic void test3(){ ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(AOPConfig.class); User user = context.getBean(\"user\", User.class); user.add();} ¶4、基于AspectJ 配置文件（了解） 创建增强类和被增强类 在XML中配置创建两个对象 在XML中配置切入点 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--添加context和aop命名空间!--&gt; &lt;!--1. 创建对象--&gt; &lt;bean id=\"book\" class=\"com.atguigu.aop.xml.Book\"&gt;&lt;/bean&gt; &lt;bean id=\"bookProxy\" class=\"com.atguigu.aop.xml.BookProxy\"&gt;&lt;/bean&gt; &lt;!--2. 配置aop增强--&gt; &lt;aop:config&gt; &lt;!--配置切入点--&gt; &lt;aop:pointcut id=\"p\" expression=\"execution(* com.atguigu.aop.xml.Book.buy(..))\"/&gt; &lt;!--配置切面：通知应用到切入点的过程--&gt; &lt;aop:aspect ref=\"bookProxy\"&gt; &lt;!--增强作用在具体的方法上：哪个通知方法作用到哪个具体方法上--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"p\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试： 1234567@Testpublic void test2(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"bean2.xml\"); Book book = context.getBean(\"book\", Book.class); book.buy();} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Spring全家桶","slug":"Spring全家桶","permalink":"https://www.itnxd.cn/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"}],"tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://www.itnxd.cn/tags/Spring5/"},{"name":"AOP","slug":"AOP","permalink":"https://www.itnxd.cn/tags/AOP/"}],"author":"ITNXD"},{"title":"Spring全家桶之Spring5-IOC使用介绍","slug":"Spring全家桶之Spring5-IOC使用介绍","date":"2021-03-25T14:36:57.000Z","updated":"2021-03-25T07:40:32.489Z","comments":true,"path":"posts/50148.html","link":"","permalink":"https://www.itnxd.cn/posts/50148.html","excerpt":"","text":"¶一、Spring介绍 Spring 是轻量级的开源的 JavaEE 框架。Spring 可以解决企业应用开发的复杂性！ ¶1、概述 Spring 有两个核心部分： IOC：控制反转，把创建对象过程交给 Spring 进行管理 Aop：面向切面，不修改源代码进行功能增强 Spring 特点： 方便解耦，简化开发 Aop 编程支持 方便程序测试 方便和其他框架进行整合 方便进行事务操作 降低 API 开发难度 ¶2、Spring下载 下载地址，点击这里！ 下载完成后解压找到lib目录，其中就是相关jar包！ SpringIOC基本包： 注意：Spring使用依赖于一个日志包，commons-logging包，为第三方包！ ¶二、IOC概述 ¶1、什么是IOC IOC：（Inversion Of Control）控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理 使用 IOC 目的：为了降低耦合度 ¶2、IOC底层原理 三大组成部分： xml 解析 工厂模式 反射 原理如下方简图： ¶三、IOC容器两种接口 IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂! Spring 提供 IOC 容器实现两种方式：（两个接口） BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象 ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人进行使用 加载配置文件时候就会将配置文件中对象进行创建 两种Bean创建示例： getBean方法：参数只有Class对象时，会获取到此类的所有实现类(子类)，参数也可为id值和Class对象！ 123456789101112131415@Testpublic void test2(){ // 1. 加载配置文件（马上创建） BeanFactory context = new ClassPathXmlApplicationContext(\"bean1.xml\"); // (使用时候创建) BeanFactory context1 = new XmlBeanFactory(new InputStreamResource( BeanFactory.class.getResourceAsStream(\"bean1.xml\"))); // 2. 获取配置创建的对象 User user = context.getBean(\"user\", User.class); System.out.println(user); // 调用方法！ user.hello();} ApplicationContext 接口有实现类： FileSystemXmlApplicationContext：加载的是配置文件在系统的全路径C://....（一般不用） ClassPathXmlApplicationContext：加载的是配置文件在src下的相对路径 ¶四、IOC操作Bean管理 Bean 管理指的是两个操作： Spring 创建对象 Spirng 注入属性！ Bean 管理操作有两种方式： 基于 xml 配置文件方式实现 基于注解方式实现 ¶1、基XML方式 ¶1.1、导包 ¶1.2、创建XML配置文件 创建方式如下： ¶1.3、创建对象 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--1、配置user对象创建！--&gt; &lt;bean id=\"user\" class=\"com.atguigu.spring.User\"&gt;&lt;/bean&gt;&lt;/beans&gt; 在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建： 在 bean 标签有很多属性，两个常用的属性： id 属性：唯一标识 class 属性：类全路径（包类路径） 补充：name属性，针对以前的struct1实现，可以添加特殊符号，作用同id属性，但id属性不可加特殊符号 创建对象时候，默认也是执行无参数构造方法完成对象创建： 若该类有有参构造器，则会发生No default constructor found（NoSuchMethodException）异常！ 即底层使用反射调用构造器使用的是newInstance()方法，该方法不传参数，则默认调用无参构造器，而你有了有参构造器，则系统默认的无参构造器就失效了，所以创建构造器要有参无参一起写！或者都不写！ ¶1.4、注入属性 注意： 容器中使用property标签时会调用set方法为属性赋值！ property标签的name属性由getter/setter方法的方法名决定！ 1.4.1 通过set方法注入 配置文件中配置！该方法调用set方法注入，类内没有set方法会报错！ 123456789&lt;!--2、set方法注入属性（可以又多组）--&gt;&lt;bean id=\"person\" class=\"com.atguigu.spring.Person\"&gt; &lt;!-- 使用property标签配置属性！ name：属性名 value：属性值 --&gt; &lt;property name=\"name\" value=\"itnxd\"&gt;&lt;/property&gt;&lt;/bean&gt; 1.4.2 通过有参构造注入 无需set方法和空参构造，该类不要求有无参构造器，默认会从xml配置文件读取构造器参数进行调用对应的有参构造！ xml文件的constructor-arg标签 可以不使用name属性，但要求这些标签的顺序必须与构造器中参数的顺序一致 构造器重载时，可以在 constructor-arg标签 中使用type属性指定参数的类型 可以在 constructor-arg标签 中使用index属性指定构造器中参数的索引，从0开始 12345678&lt;!--3、有参构造器注入（可以又多组）--&gt;&lt;!--无需set方法和空参构造--&gt;&lt;bean id=\"order\" class=\"com.atguigu.spring.Order\"&gt; &lt;constructor-arg name=\"name\" value=\"itnxd\"&gt;&lt;/constructor-arg&gt; &lt;!--&lt;constructor-arg name=\"name\" value=\"itnxd\" type=\"java.lang.String\"&gt;&lt;/constructor-arg&gt;--&gt; &lt;!--index为构造器第几个参数，基本不使用该方法！--&gt; &lt;!--&lt;constructor-arg index=\"0\" value=\"itnxd\"&gt;&lt;/constructor-arg&gt;--&gt;&lt;/bean&gt; 1.4.3 通过p名称空间注入 即在最上方添加一行xmlns:p=\"http://www.springframework.org/schema/p\"！ 同样需要有对应属性的set方法，无需构造器！ 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--4、添加p名称空间，即上方最后一行--&gt; &lt;!--底层还是前一种方式的set方法注入--&gt; &lt;bean id=\"stu\" class=\"com.atguigu.spring.Stu\" p:name=\"itnxd\"&gt; &lt;/bean&gt;&lt;/beans&gt; ¶1.5、注入其他属性 1.5.1 字面量null值 虽然不设置默认为null，这里只是表示可以通过xml设置 需要有set方法和空参构造！ 12345&lt;bean name=\"order1\" class=\"com.atguigu.spring.Order\"&gt; &lt;property name=\"name\"&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; 1.5.2 属性值包含特殊符号 把&lt;&gt;进行转义 &amp;lt; &amp;gt; 把带特殊符号内容写到 &lt;![CDATA[]]&gt; 12345678 &lt;bean name=\"order2\" class=\"com.atguigu.spring.Order\"&gt; &lt;!--&lt;property name=\"name\" value=\"&amp;lt;itnxd&amp;gt;\"&gt;&lt;/property&gt;--&gt; &lt;!--或者 &lt;![CDATA[]]&gt; --&gt; &lt;property name=\"name\"&gt; &lt;!--这里最好放到两个value标签里，不要换行，否则输出就有空格了--&gt; &lt;value&gt;&lt;![CDATA[&lt;itnxd&gt;]]&gt;&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; ¶1.6、注入属性，外部bean 外部bean例子: 通过service层去调用dao层！ 需要有Set方法！ 1234567891011121314151617181920212223public class UserService { // 现在方式： // 1. 创建UserDao属性，并生成对应set方法 private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } // 2. 在bean2.xml中配置 public void show(){ System.out.println(\"UserService show() ....\"); userDao.update(); // // service调用dao！//// // 原始方式：// UserDao userDao = new UserDaoImpl();// userDao.update(); }} XML配置： ref：表示引用外部的bean，通过id值引用 12345678910111213&lt;!--1. 创建service和dao对象--&gt;&lt;bean id=\"userService\" class=\"com.atguigu.spring.service.UserService\"&gt; &lt;!-- 2. 注入dao name：service中的属性值 ref：该属性值对应的实现类的bean标签的id值 --&gt; &lt;property name=\"userDao\" ref=\"userDaoImpl\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--全类名不能是接口，使用他的是实现类即可--&gt;&lt;bean id=\"userDaoImpl\" class=\"com.atguigu.spring.dao.UserDaoImpl\"&gt;&lt;/bean&gt; ¶1.7、注入属性，内部bean 与外部bean一样，只是将该bean进行了嵌套! 需要有对应属性的set方法！ Emp里有Dept对象！ 123456789101112&lt;!--内部bean--&gt;&lt;bean id=\"emp\" class=\"com.atguigu.spring.bean.Emp\"&gt; &lt;!--普通属性--&gt; &lt;property name=\"name\" value=\"itnxd\"&gt;&lt;/property&gt; &lt;property name=\"gender\" value=\"boy\"&gt;&lt;/property&gt; &lt;!--对象类型属性--&gt; &lt;property name=\"dept\"&gt; &lt;bean id=\"dept\" class=\"com.atguigu.spring.bean.Dept\"&gt; &lt;property name=\"name\" value=\"学生部门\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; ¶1.8、注入属性，级联赋值 表示一个类中有另个一类的属性，为另一个类赋值时候，需要通过类.属性进行赋值：dept.name 123456789101112131415161718192021222324&lt;!--级联赋值一--&gt;&lt;bean id=\"emp\" class=\"com.atguigu.spring.bean.Emp\"&gt; &lt;!--普通属性--&gt; &lt;property name=\"name\" value=\"itnxd\"&gt;&lt;/property&gt; &lt;property name=\"gender\" value=\"boy\"&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=\"dept\" ref=\"dept\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"dept\" class=\"com.atguigu.spring.bean.Dept\"&gt; &lt;property name=\"name\" value=\"学生部门\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--级联赋值二--&gt;&lt;bean id=\"emp1\" class=\"com.atguigu.spring.bean.Emp\"&gt; &lt;!--普通属性--&gt; &lt;property name=\"name\" value=\"itnxd\"&gt;&lt;/property&gt; &lt;property name=\"gender\" value=\"boy\"&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=\"dept\" ref=\"dept1\"&gt;&lt;/property&gt; &lt;!--在这里赋值(需要有对应属性的get方法)--&gt; &lt;property name=\"dept.name\" value=\"学生部门\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"dept1\" class=\"com.atguigu.spring.bean.Dept\"&gt;&lt;/bean&gt; ¶1.9、基于xml注入集合属性 同样需要有set方法！ 注入数组类型属性 注入 List 集合类型属性 注入 Map 集合类型属性 在集合里面设置对象类型值 JavaBean类型： 12345678910public class Stu { private String[] str; private List&lt;String&gt; list; private Map&lt;String, String&gt; map; private Set&lt;String&gt; set; private List&lt;Course&gt; courseList; ...set方法} XML配置实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!--xml 注入集合属性一(需要有属性对应的set方法)--&gt;&lt;bean id=\"stu\" class=\"com.atguigu.spring1.Stu\"&gt; &lt;!--数组类型属性注入--&gt; &lt;property name=\"str\"&gt; &lt;array&gt; &lt;value&gt;java 课程&lt;/value&gt; &lt;value&gt;数据库课程&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--list 类型属性注入--&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;小三&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map 类型属性注入--&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"JAVA\" value=\"java\"&gt;&lt;/entry&gt; &lt;entry key=\"PHP\" value=\"php\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set 类型属性注入--&gt; &lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;value&gt;Redis&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--注入 list 集合类型，值是对象--&gt; &lt;property name=\"courseList\"&gt; &lt;list&gt; &lt;ref bean=\"course1\"&gt;&lt;/ref&gt; &lt;ref bean=\"course2\"&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--创建多个 course 对象--&gt;&lt;bean id=\"course1\" class=\"com.atguigu.spring1.Course\"&gt; &lt;property name=\"name\" value=\"Spring5 框架\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"course2\" class=\"com.atguigu.spring1.Course\"&gt; &lt;property name=\"name\" value=\"MyBatis 框架\"&gt;&lt;/property&gt;&lt;/bean&gt; 把集合注入公共部分提取出来： 类里为private List&lt;String&gt; list类型！ 在 spring 配置文件中引入名称空间 util！ 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" 这里添加一行： xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation= \"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd 这里添加一行：同上方，将关键词全改为util即可！ http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"&gt; &lt;!--对公共部分进行提取！--&gt; &lt;!--在 spring 配置文件中引入名称空间 util--&gt; &lt;!--1. 提取list集合属性--&gt; &lt;util:list id=\"bookList\"&gt; &lt;value&gt;易筋经&lt;/value&gt; &lt;value&gt;九阴真经&lt;/value&gt; &lt;value&gt;九阳神功&lt;/value&gt; &lt;/util:list&gt; &lt;!--2.提取 list 集合类型属性注入使用--&gt; &lt;bean id=\"book\" class=\"com.atguigu.spring1.Book\"&gt; &lt;property name=\"list\" ref=\"bookList\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; ¶2、基于注解方式 可以使用注解来简化XML配置！ ¶2.1、导包 spring-aop-5.3.5.jar ¶2.2、四大创建对象的注解 Spring 针对 Bean 管理中创建对象提供注解： @Service：一般用于Service层 @Controller：一般用于Web层（Servlet） @Repository：一般用于Dao层 @Component：其他层次使用 上面四个注解功能是一样的，都可以用来创建 bean 实例 ¶2.3、注解方式创建对象 开启组件扫描（引入context命名空间） 如果扫描多个包，多个包使用逗号隔开 在类上面添加创建对象注解（四种任意一种即可） 在注解里面 value 属性值可以省略不写 默认值是类名称，首字母小写 开启注解扫描细节配置 use-default-filters=\"false\"：表示现在不使用默认 filter，自己配置 filter context:include-filter ：设置扫描哪些内容 context:exclude-filter：设置不扫描那些内容 expression：指定该注解是否扫描 类上添加创建对象注解： 12345//UserService --&gt; userService@Service(value = \"userService\") // 同bean的写法public class UserService { } XML配置： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" 添加context名称空间： xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd 还有这一行： http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--一、开启组件扫描（引入context命名空间） 指定那个包那个类！ 1 如果扫描多个包，多个包使用逗号隔开 2 扫描包上层目录 --&gt; &lt;!-- &lt;context:component-scan base-package=\"com.atguigu.spring.dao, com.atguigu.spring.service\"&gt;&lt;/context:component-scan&gt;--&gt; &lt;!--或--&gt; &lt;context:component-scan base-package=\"com.atguigu.spring\"&gt;&lt;/context:component-scan&gt; &lt;!--二、开启组件扫描细节配置--&gt; &lt;!--示例 1 use-default-filters=\"false\" 表示现在不使用默认 filter，自己配置 filter context:include-filter ，设置扫描哪些内容 expression：表示只扫描该注解的类 --&gt; &lt;context:component-scan base-package=\"com.atguigu.spring\" use-default-filters=\"false\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; &lt;!--示例 2 下面配置扫描包所有内容 context:exclude-filter： 设置哪些内容不进行扫描 默认全部扫描中排除exclude-filter! --&gt; &lt;context:component-scan base-package=\"com.atguigu\"&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 测试： 基于注解和XML混合方式： 1234567891011@Testpublic void test1(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); UserService userService = context.getBean(\"userService\", UserService.class); System.out.println(userService); userService.show();} ¶2.4、注解方式实现属性注入 2.4.1 @Autowired：根据属性类型进行自动装配 不需要添加 set 方法！ 第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解 第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解 1234567891011@Repositorypublic class UserDaoImpl implements UserDao{ }@Servicepublic class UserService { @Autowired private UserDao userDao;} 2.4.2 @Qualifier：根据名称进行注入 这个@Qualifier 注解的使用，一定要和上面@Autowired 一起使用！ 相当于一步步缩小范围来唯一确定，Autowired通过类型缩小范围，Qualifier再通过名称唯一确定！ 123456789101112@Repository(value = \"userDaoImpl_1\")public class UserDaoImpl implements UserDao{ }@Servicepublic class UserService { @Autowired @Qualifier(value = \"userDaoImpl_1\") private UserDao userDao;} 2.4.3 @Resource：可以根据类型注入，可以根据名称注入 jdk11及以上已经移除该包！ 需要引入：import javax.annotation.Resource; javax为拓展包，需要去下载导入该包javax.annotation-api-1.3.2.jar 下载地址：https://mvnrepository.com/artifact/javax.annotation/javax.annotation-api 关于Resource介绍： 总结： 默认byName，也可byType 指定name属性，则为byName 指定type属性，则为byType 同时指定name和type，则可唯一匹配 1234567891011121314@Repository(value = \"userDaoImpl_1\")public class UserDaoImpl implements UserDao{ }@Servicepublic class UserService { // @Resource(name = \"userDaoImpl_1\") // @Resource(type = UserDaoImpl.class) @Resource private UserDao userDao;} 2.4.4 @Value：注入普通类型属性 12@Value(\"abc\")private String name; ¶3、完全注解开发 创建配置类，实现完全注解开发，摆脱XML方式！ @Configuration：表名是一个配置类 @ComponentScan(basePackages = {\"com.atguigu.spring\"})：替代XML开启组件扫描，basePackages指定扫描包路径 配置类： 12345@Configuration // 作为配置类，替代xml文件@ComponentScan(basePackages = {\"com.atguigu.spring\"}) // 替代xml的组件扫描public class SpringConfig {} 测试： 12345678910@Testpublic void test2(){ ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(\"userService\", UserService.class); System.out.println(userService); userService.show();} ¶五、Spring两种Bean ¶1、普通Bean 在配置文件中定义 bean 类型就是返回类型 ¶2、工厂FactoryBean 在配置文件定义 bean 类型可以和返回类型不一样！ 第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean 第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型 12345678910111213141516171819public class MyBean implements FactoryBean&lt;Course&gt; { @Override public Course getObject() throws Exception { Course course = new Course(); course.setName(\"course\"); return course; } @Override public Class&lt;?&gt; getObjectType() { return null; } @Override public boolean isSingleton() { return false; }} XML： 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"myBean\" class=\"com.atguigu.spring2.MyBean\"&gt;&lt;/bean&gt;&lt;/beans&gt; 测试： 返回类型不一定是MyBean！ 12345678910@Testpublic void test13(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"bean7.xml\"); // bean的类型和返回类型不一样！ Course course = context.getBean(\"myBean\", Course.class); System.out.println(course);} ¶六、Bean作用域 ¶1、Bean属性Scope 在 Spring 里面，默认情况下，bean 是单实例对象，我们可以通过scope属性来设置单例还是多例！ scope 属性值： singleton，表示是单实例对象 prototype，表示是多实例对象 注意： 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用 getBean 方法时候创建多实例对象 scope：也可以是session和request（意思同javaWeb） 1&lt;bean id=\"book\" class=\"com.atguigu.spring1.Book\" scope=\"prototype\"&gt;&lt;/bean&gt; ¶七、Bean生命周期 ¶1、五步 通过构造器创建 bean 实例（无参数构造） 为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） 调用 bean 的初始化的方法（需要进行配置初始化的方法） bean 可以使用了（对象获取到了） 当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法） 演示： 123456789101112131415161718192021222324public class Order { private String name; public Order() { System.out.println(\"1. 执行无参构造创建bean实例\"); } public void setName(String name) { this.name = name; System.out.println(\"2. 调用set方法设置属性值\"); } // 3. 配置初始化 bean9.xml // 创建初始化方法，去配置文件中配置为初始化方法去执行 public void initMethod(){ System.out.println(\"3. 调用初始化方法\"); } // 5. 配置销毁方法 // 需要去配置文件配置 public void destroyMethod(){ System.out.println(\"5. 执行销毁的方法\"); }} 1234567891011121314@Testpublic void test15(){ ApplicationContext context = new ClassPathXmlApplicationContext(\"bean9.xml\"); com.atguigu.spring2.Order order = context.getBean(\"order\", com.atguigu.spring2.Order.class); System.out.println(\"4. 获取到bean对象创建的实例\"); System.out.println(order); // 5. 手动让bean实例销毁 // 需要强转为子类才可调用其中的方法！ ((ClassPathXmlApplicationContext) context).close();} XML配置初始化和销毁方法： 1234&lt;!--配置初始化方法！ init-method标签，配置销毁方法！destroy-method标签--&gt;&lt;bean id=\"order\" class=\"com.atguigu.spring2.Order\" init-method=\"initMethod\" destroy-method=\"destroyMethod\"&gt; &lt;property name=\"name\" value=\"itnxd\"&gt;&lt;/property&gt;&lt;/bean&gt; ¶2、七步 bean 的后置处理器，bean 生命周期有七步：初始化前后各一个（第三步和第五步） 通过构造器创建 bean 实例（无参数构造） 为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） 把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization 调用 bean 的初始化的方法（需要进行配置初始化的方法） 把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization bean 可以使用了（对象获取到了） 当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法） 添加后置处理器： 创建类，实现接口 BeanPostProcessor，创建后置处理器 配置xml文件，该文件中的bean都会默认使用这个后置处理器！ 1234567891011121314public class MyBeanPost implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"在初始化之前执行的postProcessBeforeInitialization方法！\"); return null; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"在初始化之后执行的postProcessBeforeInitialization方法！\"); return null; }} 12&lt;!--配置后置处理器--&gt;&lt;bean id=\"myBeanPost\" class=\"com.atguigu.spring2.MyBeanPost\"&gt;&lt;/bean&gt; ¶八、XML自动装配 根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入！ 通过bean 标签属性 autowire，配置自动装配： byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样 byType 根据属性类型注入，只能有一个对应beanId 123456789101112&lt;!--手动装配--&gt;&lt;!-- &lt;bean id=\"emp\" class=\"com.atguigu.spring3.Emp\"&gt; &lt;property name=\"dept\" ref=\"dept\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dept\" class=\"com.atguigu.spring3.Dept\"&gt;&lt;/bean&gt;--&gt;&lt;bean id=\"emp\" class=\"com.atguigu.spring3.Emp\" autowire=\"byName\"&gt;&lt;/bean&gt;&lt;!-- &lt;bean id=\"emp\" class=\"com.atguigu.spring3.Emp\" autowire=\"byType\"&gt;&lt;/bean&gt;--&gt;&lt;bean id=\"dept\" class=\"com.atguigu.spring3.Dept\"&gt;&lt;/bean&gt;&lt;!-- &lt;bean id=\"dept1\" class=\"com.atguigu.spring3.Dept\"&gt;&lt;/bean&gt;--&gt; ¶九、XML外部属性文件 以使用XML配置Druid数据库连接池举例： 先导入druid的包！ ¶1、直接配置 123456&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"xxx\"&gt;&lt;/property&gt;&lt;/bean&gt; ¶2、引入外部属性文件 通过src目录下新建jdbc.properties配置文件然后使用XML进行读取！ 注意： classpath 对应 src目录下 需要引入context名称空间 jdbc.properties： 1234prop.driverClass=com.mysql.cj.jdbc.Driverprop.url=jdbc:mysql://localhost:3306/testprop.userName=rootprop.password=xxx XML文件： 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" 引入context名称空间： xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd 加入以下这一行，关键词全改为context http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\"&gt;&lt;/context:property-placeholder&gt; &lt;!--配置连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"${prop.driverClass}\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"${prop.url}\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"${prop.userName}\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"${prop.password}\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Spring全家桶","slug":"Spring全家桶","permalink":"https://www.itnxd.cn/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"}],"tags":[{"name":"Spring5","slug":"Spring5","permalink":"https://www.itnxd.cn/tags/Spring5/"},{"name":"IOC","slug":"IOC","permalink":"https://www.itnxd.cn/tags/IOC/"}],"author":"ITNXD"},{"title":"每日一题之LeetCode 82.删除排序链表中的重复元素 II","slug":"每日一题之LeetCode-82-删除排序链表中的重复元素-II","date":"2021-03-25T07:47:59.000Z","updated":"2021-03-29T07:04:38.739Z","comments":true,"path":"posts/24068.html","link":"","permalink":"https://www.itnxd.cn/posts/24068.html","excerpt":"","text":"题目链接：LeetCode 82. 删除排序链表中的重复元素 II ¶一、题解 同样又是一道熟悉的链表题目：题目要求将有重复的节点全部删掉！ 这道题还是比较好想的： 如下图： 为了统一该链表，防止第一个节点就是重复节点导致，头结点的改变，我们使用虚拟头结点指向该头节点，实现统一操作！ 用一个指针p指向当前节点，另一个指针q指向下一个节点 接下来，q从p-&gt;next开始，一直走到第一个与p-&gt;next不同元素的位置，这时有两种情况： p-&gt;next-&gt;next == q：则说明p后面没有重复元素，直接后移p = p-&gt;next p-&gt;next-&gt;next != q：则说明p后面有重复元素，则跳过这一堆重复元素，p直接指向q即可，p-&gt;next = q 最后返回dummy-&gt;next即可 时间复杂度：O(n) 空间复杂度：O(1) ¶二、AC代码 参考代码： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* deleteDuplicates(ListNode* head) { auto dummy = new ListNode(-1); dummy-&gt;next = head; auto p = dummy; while(p-&gt;next){ auto q = p-&gt;next; while(q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next; if(p-&gt;next-&gt;next == q) p = p-&gt;next; else p-&gt;next = q; } return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"ITNXD"},{"title":"每日一题之AcWing 131. 直方图中最大的矩形","slug":"每日一题之AcWing-131-直方图中最大的矩形","date":"2021-03-24T07:46:55.000Z","updated":"2021-03-29T07:01:25.695Z","comments":true,"path":"posts/32399.html","link":"","permalink":"https://www.itnxd.cn/posts/32399.html","excerpt":"","text":"题目链接：AcWing 131. 直方图中最大的矩形 这道题自然就是非常典型的单调栈问题！ ¶一、题解 该题目如下图：找一个最大的矩形出来！ 有了前面单调栈知识的积累，会轻易的发现这道题就是一道单调栈的应用！ 我们看图可以知道，以其中一个矩形的顶部作为一条边，那么他向左和向右最大能拓展的长度就是他的宽度！最终面积就是能拓展的最大宽度乘以该矩形的高就是以该矩形顶部为边的最大矩形！每个矩形都枚举一次即可得到最大矩形的面积！ 问题来了，如何快速找到该矩形向左和向右最远能拓展到哪里呢？ 其实，这个问题换句话说就是，如何可以快速的找到左边或右边第一个比他低的矩形的位置！ 现在可以发现了吧！ 这就是单调栈的定义呗！ 具体操作： 从左到右维护一个单调栈，从右到做维护一个单调栈即可！ 由于要维护两次，为了方便我们使用自己实现的栈结构q l r数组分别表示左边或右边第一个比他矮的矩形的下标位置 最终面积就是h[i] * (r[i] - l[i] - 1) 注意点： 本题数据大，可能爆int，使用long long强转一下！ 两次扫描之间，记得清空栈 为了便于处理边界数据，从1 - n进行循环 边界数据h[0], h[n + 1]为-1 左右边界q[0]所代表的的下标的值分别为0和n + 1 时间复杂度：O(n) 空间复杂度：O(n) ¶二、AC代码 参考代码： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;int n, h[N], l[N], r[N], q[N];int main(){ while(cin &gt;&gt; n, n){ for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; h[i]; int tt = 0; q[0] = 0, h[0] = -1; for(int i = 1; i &lt;= n; i ++){ while(h[q[tt]] &gt;= h[i]) tt --; l[i] = q[tt], q[++ tt] = i; } tt = 0, q[0] = n + 1, h[n + 1] = -1; for(int i = n; i &gt;= 1; i --){ while(h[q[tt]] &gt;= h[i]) tt --; r[i] = q[tt], q[++ tt] = i; } LL res = 0; for(int i = 1; i &lt;= n; i ++) res = max(res, (LL)h[i] * (r[i] - l[i] - 1)); cout &lt;&lt; res &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"https://www.itnxd.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"author":"ITNXD"},{"title":"每日一题之LeetCode 456.132模式","slug":"每日一题之LeetCode-456-132模式","date":"2021-03-24T07:46:33.000Z","updated":"2021-03-29T07:05:34.232Z","comments":true,"path":"posts/910.html","link":"","permalink":"https://www.itnxd.cn/posts/910.html","excerpt":"","text":"题目链接：LeetCode 456. 132模式 这是一道非典型的单调栈问题！ ¶一、题解 先来简单分析一下该题： 就是找是否有满足如下条件的数 i &lt; j &lt; k 并且 nums[i] &lt; nums[k] &lt; nums[j]，对于本题，我们可以从暴力角度考虑，即三层for循环，但实在是过于暴力，于是乎就产生了一个新的想法： 我们可以枚举每个nums[i]，对于每个nums[i]，判断其后是否有一个慢如如下要求的nums[k]： nums[k] &gt; nums[i] nums[i] 和 nums[k] 之间存在一个 nums[j] 且 nums[j] &gt; nums[k] 对于如上要求的nums[k]，我们可以进行转化： 即只要找到满足要求（所谓满足要求，这里是指上面的两个要求都满足）的nums[k]中最大的nums[k]即可！ 即此时的nums[k]是大于nums[i]的数且比num[j]小的数中的最大的数！ 而这样的数一定满足要求！ 如果有这样的数，则本题有解，否则无解 那么，如何求得满足要求的最大的 nums[k] 呢？ 这里就要用到单调栈的知识了，但求这样一个数又和单调栈的经典定义不太一样，这便是这道题的难点！ 经典的单调栈的为：在一个序列中可以求出左边第一个比他小或右边第一个比他小，左边第一个比他大或右边第一个比他大的数！ 很明显，则并不是一个经典的单调栈问题！ 我们用一个栈stk来存储当前未满足要求的nums集合！我们会惊奇的发现 ，未满足要求的集合是单调的！ 这时，可以我们就可来维护一个未满足条件的单调栈来解题！ 我们用一个right_max数组来存储当前当前数右边比他大的最大的数，即满足要求的数 若存在right_max，使得nums[i] &lt; right_max，即可说明存在一个132序列，否则说明无解！ 还有一个比较容易困惑的事情： 当前得到的right_max并不是给当前的nums[i]使用的，而是给下一次循环的nums[i]之前的nums[i - 1]使用的！ 即 num[i - 1] num[i] right_max三者为i,j,k的关系，right_max会在下一层循环num[i - 1]时候会用到，这时候已经保证了nums[j] &gt; nums[k]，且nums[k]取到最大的条件了！ 如何维护该单调栈呢？ 对于当前的nums[i]（此时的nums[i]就是132序列的nums[j]）来说，若栈中有元素比当前nums[i]要小，我们要取到比nums[i]小的区间内的最大值，因此，该区间就可以被删去，只要该最大值存在，那么栈中该区间中的任意值就都不会被使用到！ 时间复杂度：O(n) 空间复杂度：O(n) ¶二、AC代码 参考代码： 12345678910111213141516class Solution {public: bool find132pattern(vector&lt;int&gt;&amp; nums) { stack&lt;int&gt; stk; int right_max = INT_MIN; for(int i = nums.size() - 1; i &gt;= 0; i --){ if(nums[i] &lt; right_max) return true; while(stk.size() &amp;&amp; stk.top() &lt; nums[i]){ right_max = max(right_max, stk.top()); stk.pop(); } stk.push(nums[i]); } return false; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"https://www.itnxd.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"author":"ITNXD"},{"title":"每日一题之AcWing 1497.树的遍历","slug":"每日一题之AcWing-1497-树的遍历","date":"2021-03-23T07:46:10.000Z","updated":"2021-03-29T07:03:35.960Z","comments":true,"path":"posts/20698.html","link":"","permalink":"https://www.itnxd.cn/posts/20698.html","excerpt":"","text":"题目链接：AcWing 1497.树的遍历 经典的题目，给定中序和后序遍历得到层序遍历！ ¶一、题解 一道经典的问题，通过中序和后序遍历建树，然后再bfs搜一遍即可得到层序遍历的结果！ 如何通过中序和后序进行建树呢？ 我们知道，后序遍历的最后一个节点是根节点 中序遍历可以通过后序遍历得到的根节点将该序列分为两部分，左子树和右子树 然后即可递归的找到每一个根节点 一个问题，如何快速的从中序遍历序列中找到根节点所在的下标呢？ 很简单，在进行输入中序遍历的时候可以使用哈希表将中序遍历的值和下标进行一次存储，便可在使用的时候通过O(1)的时间内将其找出来！ 其他存储： 左右子树的存储同样使用哈希表进行存储，很方便！ 具体来说： 需要一个递归函数，该函数返回值为当前的根节点 参数为当前中序遍历的区间[il, ir]和后序遍历的区间[pl, pr] 若中序序列中根节点的下标为k，则可以得到： 对于左子树：(il, k - 1, pl, k - 1 - il + pl) 对于右子树：(k + 1, ir, k - 1 - il + pl + 1, pr - 1) 时间复杂度：O(n) 空间复杂度：O(n) ¶二、AC代码 参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;using namespace std;const int N = 40;int n, postOrder[N], inOrder[N];unordered_map&lt;int, int&gt; l, r, pos;// 中序左右，后序左右int build(int il, int ir, int pl, int pr){ int root = postOrder[pr]; int k = pos[root]; if(il &lt; k) l[root] = build(il, k - 1, pl, k - 1 - il + pl); if(ir &gt; k) r[root] = build(k + 1, ir, k - 1 - il + pl + 1, pr - 1); return root;}void bfs(int root){ queue&lt;int&gt; q; q.push(root); while(q.size()){ int k = q.front(); q.pop(); cout &lt;&lt; k &lt;&lt; \" \"; if(l.count(k)) q.push(l[k]); if(r.count(k)) q.push(r[k]); }}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) cin &gt;&gt; postOrder[i]; for(int i = 0; i &lt; n; i ++) cin &gt;&gt; inOrder[i], pos[inOrder[i]] = i; int root = build(0, n - 1, 0, n - 1); bfs(root); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"树的遍历","slug":"树的遍历","permalink":"https://www.itnxd.cn/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"}],"author":"ITNXD"},{"title":"每日一题之AcWing 85.不用加减乘除做加法","slug":"每日一题之AcWing-85-不用加减乘除做加法","date":"2021-03-22T07:43:05.000Z","updated":"2021-03-25T12:59:16.427Z","comments":true,"path":"posts/24538.html","link":"","permalink":"https://www.itnxd.cn/posts/24538.html","excerpt":"","text":"题目链接：AcWing 85.不用加减乘除做加法 计算机底层加法的实现原理 — 全加器！ ¶一、题解 要求不使用加减乘除实现加法！这样的话，必然就是计算机底层实现加法的原理了！即全加器的实现！ 所谓全加器：就是将一个数加另一个数转换为不进位加法与加法的和！ 过程如下： 先通过异或运算得到不进位加法的结果 再通过与运算得到进位加法的进的位，由于进位是向左边的数进位，因此将结果左移一位即可 二者相加即为最终结果！ 一个问题，上一步要用到加法，题目要求不能使用加法，如何处理？ 我们可以将得到的两个结果通过迭代的方式再次进行一次异或和与运算，直到进位结果为0为止！得到的就是最终答案**！** 那么，如何确定该循环一定会结束？ 我们会发现每次进行进位运算时，都会左移1，即末尾会至少多个0，每次迭代多一个0，那么最多迭代32次，必然该数为0，退出循环！ 时间复杂度：O(1) 空间复杂度：O(1) ¶二、AC代码 参考如下： 1234567891011class Solution {public: int add(int num1, int num2){ while(num2){ int sum = num1 ^ num2; int carry = (num1 &amp; num2) &lt;&lt; 1; num1 = sum, num2 = carry; } return num1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://www.itnxd.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"全加器","slug":"全加器","permalink":"https://www.itnxd.cn/tags/%E5%85%A8%E5%8A%A0%E5%99%A8/"}],"author":"ITNXD"},{"title":"每日一题之AcWing 3302.表达式求值","slug":"每日一题之AcWing-3302-表达式求值","date":"2021-03-21T12:46:10.000Z","updated":"2021-03-29T07:41:03.679Z","comments":true,"path":"posts/46950.html","link":"","permalink":"https://www.itnxd.cn/posts/46950.html","excerpt":"","text":"题目链接：AcWing 3302. 表达式求值 本题可以作为模板，处理含有任何运算符的中缀表达式问题！ ¶一、题意 给定一个表达式，其中运算符仅包含 +,-,*,/（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。 ¶二、题解 简单分析： 给定一个中缀表达式，例如(2+2)*(1+1)，要我们计算出最终结果！包含加减乘除和括号！ 这时候，我们想到了后缀表达式，但是由于后缀表达式的特殊性，我们只要将该表达式放入一个栈中，遇到数字入栈，遇到运算符则出栈两个栈顶元素计算后再入栈，最终栈顶元素就是我们的表达式的值！ 但是中缀表达式不一样，它并没有这样的性质！ 后缀表达式是表达式树的后序遍历，中缀表达式就是表达式树的中序遍历！ 对于上方样例(2+2)*(1+1)，表达式树的后序遍历为2 2 + 1 1 + *，没有问题；中序遍历为2 + 2 * 1 + 1，很明显，中序遍历得到的结果有一个优先级问题！ 括号：括号只影响表达式优先级，不影响表达式树的结构！ 我们建立表达式树进行分析： 叶子节点为运算数 其他节点为运算符 如下方简图： 我们可以对该表达式树进行递归运算，但是并没有必要将树建立出来，我们可以利用中缀表达式的性质，用栈来达到和递归一样的效果！ 当我们遍历到根节点，它是一个运算符，这时我们并不能直接和右节点运算，和后缀表达式不一样，因为右子树还没有被遍历，我们只有遍历完右子树才能和当前运算符进行运算！ 好了，一个重要问题，如何判断一颗子树被遍历完了？ 只要我们往下走（往下遍历），则说明该子树没有被遍历；只要我们往上走（往上遍历），说明该子树已经被遍历完毕！ 针对运算符又如何判断呢？ 如下图：栈中运算符（上一个）为乘法，当前运算符为加法 若当前比上一个运算符优先级要低，则要先算a和b再算c，表示以上一个节点为根节点的子树已经遍历完毕了 若当前和上一个运算符优先级相同（都为乘法），则要先算a和b再算c，同优先级从左向右，也可表明该子树遍历完毕 若当前比上一个运算符优先级要高（乘法加法互换a + b * c）, 则无法计算a和b，表明该子树没有遍历完毕 总结：只要当前运算符优先级不大于上一个运算符优先级，就表明该子树被遍历完毕了，该子树就可以进行计算了！ 还有一个括号问题： 若为左括号，不必进行额外处理 若为右括号，我们只需要将从右括号开始从右向左计算到左括号即可 为何为从右向左： 解释一：由于我们只有当当前运算符优先级不大于上一个运算符优先级的时候才会去计算该子树，意味着剩下的表达式，或者说括号内的表达式都一定是优先级递增的，因为优先级逆序的都由于子树被遍历完毕而被计算完了，所以括号内的一定是优先级递增的，从右向左运算完全符合运算法则！ 解释二：或者说，一个运算符没有被计算过的话，一定是往下走的，向子树去走，如果往上走，说明该运算符已经计算过了！ 由于括号内的运算符还没有被计算过，则说明是往下走的！可以往下走，则说明当前比上一个运算符优先级要高，所以运算符优先级必然是递增的！ 双栈存储： 一个存储运算符 一个存储运算数 本题完全可以拓展： 由于本题的解法实在属于模板，毕竟处理第一行，后面代码都没有出现运算符，因此可以拓展到任何运算符的情况的题！ 只需要做一个修改即可：将哈希表的运算符加上多出来的运算符和其优先级，并在eval函数中实现他的运算即可！ 时间复杂度： O(n) 空间复杂度： O(n) ¶三、AC代码 参考如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;stack&gt;using namespace std;stack&lt;int&gt; num;stack&lt;char&gt; op;string str;// 处理最后两个数的运算，注意：出栈顺序和运算顺序是相反的！void eval(){ auto a = num.top(); num.pop(); auto b = num.top(); num.pop(); auto c = op.top(); op.pop(); if(c == '+') num.push(b + a); else if(c == '-') num.push(b - a); else if(c == '*') num.push(b * a); else if(c == '/') num.push(b / a);}int main(){ cin &gt;&gt; str; unordered_map&lt;char, int&gt; map{{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}}; for(int i = 0; i &lt; str.size(); i ++){ auto c = str[i]; // 将连续数字抠出来 if(isdigit(c)){ int x = 0, j = i; while(j &lt; str.size() &amp;&amp; isdigit(str[j])) x = x * 10 + str[j ++] - '0'; // 放入num栈中，for循环i要++，因此此处i应该为j - 1 num.push(x), i = j - 1; }else if(c == '(') op.push(c); // 左括号无需处理，直接如op栈 else if(c == ')'){ // 遇到右括号，则从右向左依次处理num栈中的数，直到遇到op栈的左括号 while(op.top() != '(') eval(); // 左括号出栈 op.pop(); }else{ // 四种运算符：只要op栈中的运算符优先级不小于当前运算符优先级即可进行运算 while(op.size() &amp;&amp; map[op.top()] &gt;= map[c]) eval(); // 运算完毕或者当前运算符优先级更高则当前运算符c直接入栈 op.push(c); } } // 处理剩下的部分，直到运算符处理完毕 while(op.size()) eval(); cout &lt;&lt; num.top() &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"},{"name":"模板","slug":"模板","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%9D%BF/"}],"author":"ITNXD"},{"title":"每日一题之LeetCode-92. 反转链表 II反转链表","slug":"每日一题之LeetCode-92. 反转链表 II反转链表","date":"2021-03-19T01:47:32.000Z","updated":"2021-03-25T07:40:07.246Z","comments":true,"path":"posts/25333.html","link":"","permalink":"https://www.itnxd.cn/posts/25333.html","excerpt":"","text":"¶一、反转链表I 题目链接：https://www.acwing.com/problem/content/33/ ¶1、解法一 如下方简图： 迭代： 维护两个一前一后的指针a, b即可，每次将 b 指向 a 完成反转 然后 a, b 两个指针都后移一步，由于b指向a会导致b-&gt;next丢失，所以先将其保存下来作为c指针 直到b指针为空，再将头结点指向空，返回a节点即可 时间复杂度：O(n)​ 空间复杂度：O(1) AC代码： 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { if(!head || !head-&gt;next) return head; auto a = head, b = a-&gt;next; while(b){ auto c = b-&gt;next; b-&gt;next = a; a = b, b = c; } head-&gt;next = NULL; return a; }}; ¶2、题解二 递归： 可使用reverseList 函数，该函数内部通过递归实现，该函数可以翻转一个链表，并返回新链表的头节点tail，也就是原链表的尾节点。 因此，我们可以让他反转除了头结点以外的节点 然后让反转后新链表的尾结点也就是head-&gt;next指向头结点完成整条链表反转 最后将整条新链表的尾结点即head指向空即可! 时间复杂度：O(n)​ 空间复杂度：总共递归 n 层，系统栈的空间复杂度是 O(n)​ AC代码： 123456789101112131415161718/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { if(!head || !head-&gt;next) return head; auto tail = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return tail; }}; ¶二、反转链表II 题目链接：https://leetcode-cn.com/problems/reverse-linked-list-ii/ ¶1、题解 这是反转链表I的变形，指定了区间的反转！ 如下方图示： 迭代： 思路同上方的反转链表I，同样是维护一前一后两个指针b，c即可！ 由于左端点的位置情况有两种，若为头结点则反转后头结点不再是头结点，若不为头结点，则反转后该头结点还是头结点；所以，我们新建虚拟头结点指向头结点，即可将该两种情况统一处理！ 先找到左端点的上一个端点a，即循环m - 1次即可 通过a节点找到需要维护的b，c节点 让c节点指向b节点，然后两节点同步后移一步 由于c指向b会导致c-&gt;next丢失，所以先将其保存下来作为d指针 循环n - m次即可完成该区间的反转 然后完成上图的两个节点的乱指！即左端点a-&gt;next指向右端点的下一个节点c，左端点的上一个节点a指向右端点b即可！ 时间复杂度：O(n)​ 空间复杂度：O(1) ¶2、AC代码 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseBetween(ListNode* head, int m, int n) { auto dummy = new ListNode(-1); dummy-&gt;next = head; auto a = dummy; for(int i = 0; i &lt; m - 1; i ++) a = a -&gt;next; auto b = a-&gt;next, c = b-&gt;next; for(int i = 0; i &lt; n - m; i ++){ auto d = c-&gt;next; c-&gt;next = b; b = c, c = d; } a-&gt;next-&gt;next = c, a-&gt;next = b; return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"ITNXD"},{"title":"JavaWeb之JSON、Ajax、i18n的使用","slug":"JavaWeb之JSON、Ajax、i18n的使用","date":"2021-03-18T09:33:40.000Z","updated":"2021-03-18T14:39:04.888Z","comments":true,"path":"posts/59901.html","link":"","permalink":"https://www.itnxd.cn/posts/59901.html","excerpt":"","text":"¶一、JSON ¶1、概述 JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON采用完全独立于语言的文本格式，而且很多语言都提供了对 json 的支持。 这样就使得 JSON 成为理想的数据交换格式。 json 是一种轻量级的数据交换格式。（轻量级指的是跟 xml 做比较。） 数据交换指的是客户端和服务器之间业务数据的传递格式。 ¶2、JSON基本使用 json 是由键值对组成，并且由花括号（大括号）包围。每个键由引号引起来，键和值之间使用冒号进行分隔，多组键值对之间进行逗号进行分隔。 json 本身是一个对象。 json 中的 key 我们可以理解为是对象中的一个属性。 json 中的 key 访问就跟访问对象的属性一样： json 对象.key 123456789101112131415161718192021222324252627282930313233343536// json的定义var jsonObj = { \"key1\":12, \"key2\":\"abc\", \"key3\":true, \"key4\":[11,\"arr\",false], \"key5\":{ \"key5_1\" : 551, \"key5_2\" : \"key5_2_value\" }, \"key6\":[{ \"key6_1_1\":6611, \"key6_1_2\":\"key6_1_2_value\"},{ \"key6_2_1\":6621, \"key6_2_2\":\"key6_2_2_value\" }]};alert(typeof jsonObj); // object// json的访问alert(jsonObj.key1); //12alert(jsonObj.key2); // abcalert(jsonObj.key3); // truealert(jsonObj.key4);// 得到数组[11,\"arr\",false]// json 中 数组值的遍历for(var i = 0; i &lt; jsonObj.key4.length; i++) { alert(jsonObj.key4[i]);}alert(jsonObj.key5.key5_1);//551alert(jsonObj.key5.key5_2);//key5_2_valuealert( jsonObj.key6 );// 得到 json 数组// 取出来每一个元素都是 json 对象var jsonItem = jsonObj.key6[0];// alert( jsonItem.key6_1_1 ); //6611alert( jsonItem.key6_1_2 ); //key6_1_2_value ¶3、JSON两方法 json 的存在有两种形式： 对象的形式存在，我们叫它 json 对象。一般我们要操作 json 中的数据的时候，需要 json 对象的格式 字符串的形式存在，我们叫它 json 字符串。一般我们要在客户端和服务器之间进行数据交换的时候，使用 json 字符串。 两个方法： JSON.stringify()：把 json 对象转换成为 json 字符串 JSON.parse()：把 json 字符串转换成为 json 对象 代码示例： 12345678910// json对象转字符串// 类似java的toString方法：var jsonString = JSON.stringify(jsonObj);alert(jsonString);// json字符串转json对象var jsonObj1 = JSON.parse(jsonString);alert(jsonObj1); ¶4、Java与JSON转换 Java与JSON的转换需要使用谷歌的Gson包！ gson-2.2.4.jar Gson的两个方法： toJson()：参数可以是JavaBean、Map、List fromJson()： 参数一：JSON字符串 参数二：要转换的类型 JavaBean：直接为对应类.class List：需要使用TypeToken.getType()获取 ¶4.1、JavaBean与JSON 12345678910111213@Testpublic void test1(){ Person p = new Person(1, \"itnxd\"); // 1. JavaBean -&gt; JSON Gson gson = new Gson(); String s = gson.toJson(p); System.out.println(s); // 2. JSON -&gt; JavaBean Person person = gson.fromJson(s, Person.class); System.out.println(person);} ¶4.2、List集合与JSON 123456789101112131415161718192021@Testpublic void test2(){ ArrayList&lt;Person&gt; person = new ArrayList&lt;&gt;(); person.add(new Person(1, \"itnxd\")); person.add(new Person(2, \"itnnn\")); Gson gson = new Gson(); // 1. List -&gt; Json String s = gson.toJson(person); System.out.println(s); // 2. Json -&gt; List // 方案一： List&lt;Person&gt; list = gson.fromJson(s, new PersonListType().getType()); // 方案二： List&lt;Person&gt; list = gson.fromJson(s, new TypeToken&lt;List&lt;Person&gt;&gt;(){}.getType()); System.out.println(list); System.out.println(list.get(1));} 获取Type方案一： 创建继承TypeToken的类！ 使用：new 该类.getType()即可 泛型参数为你的List集合，如List&lt;Person&gt; 12public class PersonListType extends TypeToken&lt;List&lt;Person&gt;&gt; {} 获取Type方案二： 使用匿名内部类实现！（推荐） 使用：new TypeToken&lt;List&lt;Person&gt;&gt;(){}.getType() 泛型参数为你的List集合，如List&lt;Person&gt; ¶4.3、Map与JSON 获取Type方案与List转换类似，参见4.2！ 1234567891011121314151617181920@Testpublic void test3(){ Map&lt;Integer, Person&gt; map = new HashMap&lt;&gt;(); map.put(1, new Person(1, \"it\")); map.put(2, new Person(2, \"it2\")); Gson gson = new Gson(); // 1. Map -&gt; Json String s = gson.toJson(map); System.out.println(s); // 2. Json -&gt; Map // Map&lt;Integer, Person&gt; map1 = gson.fromJson(s, new PersonMapType().getType()); // 使用匿名内部类实现： Map&lt;Integer, Person&gt; map1 = gson.fromJson(s, new TypeToken&lt;Map&lt;Integer, Person&gt;&gt;(){}.getType()); System.out.println(map1); System.out.println(map1.get(1));} ¶二、Ajax ¶1、概述 AJAX 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。 Ajax 是一种浏览器通过 js 异步发起请求，局部更新页面的技术。 Ajax 请求的局部更新，浏览器地址栏不会发生变化 局部更新不会舍弃原来页面的内容 ¶2、原生Ajax请求（了解） 向服务器发送请求： 方法 描述 open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string) 将请求发送到服务器。 string：仅用于 POST 请求 GET 还是 POST？ 与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 服务器响应： 如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 属性 描述 responseText 获得字符串形式的响应数据。 responseXML 获得 XML 形式的响应数据。 onreadystatechange 事件： 当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 XMLHttpRequest 对象的三个重要的属性： 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status 200: “OK” 404: 未找到页面 在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。 当 readyState 等于 4 且状态为 200 时，表示响应已就绪！ 使用 Callback 函数： callback 函数是一种以参数形式传递给另一个函数的函数。 如果您的网站上存在多个 AJAX 任务，那么您应该为创建 XMLHttpRequest 对象编写一个标准的函数，并为每个 AJAX 任务调用该函数。 该函数调用应该包含 URL 以及发生 onreadystatechange 事件时执行的任务（每次调用可能不尽相同）： 1234567891011121314151617181920212223242526function ajaxRequest() { // 1、我们首先要创建XMLHttpRequest var xmlHttpRequest = new XMLHttpRequest(); // 2、调用open方法设置请求参数 // 参数：method, url, async：true（异步）或 false（同步） xmlHttpRequest.open(\"get\", \"http://localhost:8080/19_json_ajax_i18n/ajaxServlet?action=JavaScriptAjax\", true); // 本步骤要在第三步前完成绑定！ // 4、在send方法前绑定onreadystatechange事件，处理请求完成后的操作。 // 接收响应 xmlHttpRequest.onreadystatechange = function (){ if(xmlHttpRequest.readyState == 4 &amp;&amp; xmlHttpRequest.status == 200){ // 把响应数据放到div里面！ // document.getElementById(\"div01\").innerText = xmlHttpRequest.responseText; // 让显示更加人性化！转换为JSON对象 var JsonObj = JSON.parse(xmlHttpRequest.responseText); document.getElementById(\"div01\").innerText = \"编号：\" + JsonObj.id + \"\\n\" + \"姓名：\" + JsonObj.name; } }; // 3、调用send方法发送请求 xmlHttpRequest.send();} ¶3、jquery中的Ajax请求 由于原生JS实现Ajax过于复杂，可使用jQuery封装好的对象使用！ ¶3.1、$.ajax 详细参数查看这里，这里只讲最常见参数！ url：表示请求的地址 type：表示请求的类型 GET 或 POST 请求 data：表示发送给服务器的数据，两种格式： name=value&amp;name=value {key:value} success：请求成功，响应的回调函数 dataType：响应的数据类型，常用的数据类型有： text 表示纯文本（需要自己转换为JSON对象使用） xml 表示 xml 数据（弃用） json 表示 json 对象（常用：回调函数的参数是已经转换完毕的JSON对象，可直接使用） 1234567891011121314$.ajax({ url:\"http://localhost:8080/19_json_ajax_i18n/ajaxServlet\", // data: \"action=JqueryAjax\", data:{action:\"JqueryAjax\"}, type:\"GET\", success: function (msg){ // 无需再进行转换 // let dataJson = JSON.parse(data); $(\"#msg\").html(\"编号：\" + msg.id + \"，\" + \"姓名：\" + msg.name ); }, // data_type: \"text\" // text：需要自己转换为json对象使用，可以直接使用json实现自动转换 dataType: \"json\"}); ¶3.2、$.get与$.post 与上方相比少了type参数！ url：请求的 url 地址 data：发送的数据 callback：成功的回调函数 dataType：返回的数据类型 12345678910111213// ajax--get请求$(\"#getBtn\").click(function(){ $.get(\"http://localhost:8080/19_json_ajax_i18n/ajaxServlet\",\"action=JqueryGet\",function (data) { $(\"#msg\").html(\" get 编号：\" + data.id + \" , 姓名：\" + data.name); },\"json\");});// ajax--post请求$(\"#postBtn\").click(function(){ $.post(\"http://localhost:8080/19_json_ajax_i18n/ajaxServlet\",\"action=JqueryPost\",function (data) { $(\"#msg\").html(\" post 编号：\" + data.id + \" , 姓名：\" + data.name); },\"json\");}); ¶3.3、$.getJSON 与上方相比少了dataType参数！ url：请求的 url 地址 data：发送给服务器的数据 callback：成功的回调函数 12345$(\"#getJSONBtn\").click(function(){ $.getJSON(\"http://localhost:8080/19_json_ajax_i18n/ajaxServlet\",\"action=JqueryGetJSON\",function (data) { $(\"#msg\").html(\" getJSON 编号：\" + data.id + \" , 姓名：\" + data.name); });}); ¶3.4、serialize 表单序列化 serialize() serialize()：可以把表单中所有表单项的内容都获取到，并以 name=value&amp;name=value 的形式进行拼接。 1234567891011121314$(\"#submit\").click(function(){ // 获取表单信息拼接 alert($(\"#form01\").serialize()); // 参数拼接： // \"action=jQuerySerialize&amp;\" + $(\"#form01\").serialize() // 把参数序列化 $.getJSON(\"http://localhost:8080/19_json_ajax_i18n/ajaxServlet\",\"action=JquerySerialize&amp;\" + $(\"#form01\").serialize(),function (data) { $(\"#msg\").html(\" Serialize 编号：\" + data.id + \" , 姓名：\" + data.name); });}); **ajaxServlet.java：**可以获取到序列化的参数！ 1234567891011121314151617protected void JquerySerialize(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"JquerySerialize请求已到达！\"); System.out.println(req.getParameter(\"username\")); System.out.println(req.getParameter(\"password\")); Person person = new Person(1, \"itnxd\"); // 客户端与服务器交流需要使用JSON字符串 // Servlet处理响应，js中处理接收！ Gson gson = new Gson(); String personJSONString = gson.toJson(person); // 响应到客户端 resp.getWriter().write(personJSONString);} ¶4、使用Ajax校验用户名 前端JS： 123456789101112// 为用户名绑定ajax请求$(\"#username\").blur(function (){ var username = this.value; $.getJSON(\"userServlet\", \"action=ajaxExistUsername&amp;username=\" + username, function (data){ // 用户名不存在 if(data.existUsername){ $(\"span.errorMsg\").text(\"用户名已存在！\"); }else{ $(\"span.errorMsg\").text(\"用户名可用！\"); } });}); Servlet程序： 12345678910111213141516171819202122/** * 使用ajax处理用户名验证！ * @param req * @param resp * @throws ServletException * @throws IOException */protected void ajaxExistUsername(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 获取参数 String username = req.getParameter(\"username\"); // 2. 调用userService的existUsername检查用户名是否存在 // 此处为调用数据库操作！ boolean existUsername = userService.existUsername(username); // 3. 封装为map对象 HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(\"existUsername\", existUsername); // 4. 使用Gson解析为Json Gson gson = new Gson(); String json = gson.toJson(hashMap); // 5. 传回客户端 resp.getWriter().write(json);} ¶三、i18n（了解） ¶1、概述 国际化（Internationalization）指的是同一个网站可以支持多种不同的语言，以方便不同国家，不同语种的用户访问。 关于国际化我们想到的最简单的方案就是为不同的国家创建不同的网站，比如苹果公司，他的英文官网是：http://www.apple.com 而中国官网是 http://www.apple.com/cn，苹果公司这种方案并不适合全部公司，而我们希望相同的一个网站，而不同人访问的时候可以根据用户所在的区域显示不同的语言文字，而网站的布局样式等不发生改变。 国际化的英文 Internationalization，但是由于拼写过长，老外想了一个简单的写法叫做 I18N，代表的是 Internationalization这个单词，以 I 开头，以 N 结尾，而中间是 18 个字母，所以简写为 I18N。以后我们说 I18N 和国际化是一个意思。 国际化实现的三要素： ¶2、国际化资源 properties 用来配置语言文件的配置文件！ 这里只配置两个即中文和英文！ src下新建： i18n_en_US.properties： 12345678910username=usernamepassword=passwordsex=sexage=ageregist=registboy=boygirl=girlemail=emailreset=resetsubmit=submit i18n_zh_CN.properties： 12345678910username=用户名password=密码sex=性别age=年龄regist=注册boy=男girl=女email=邮箱reset=重置submit=提交 ¶3、Local对象介绍 通过该对象获取默认国家信息，或指定国家信息，如需要也可以遍历国家信息查看！ 123456789101112131415161718@Testpublic void testLocale(){ Locale locale = Locale.getDefault(); // 获取系统默认的国家语言信息 System.out.println(locale); // zh_CN // 所有可用的语言信息！ // for (Locale availableLocale : Locale.getAvailableLocales()) { // System.out.println(availableLocale); // } // 指定获取某国 System.out.println(Locale.CHINA); System.out.println(Locale.US);} ¶4、ResourceBundle介绍 根据给定的baseName和Locale读取相应的配置文件，得到文字信息! 12345678910111213@Testpublic void testI18n(){ // 获取Locale对象 // Locale locale = Locale.US; Locale locale = Locale.CHINA; // 通过指定的 basename 和 Locale 对象，读取 相应的配置文件 ResourceBundle bundle = ResourceBundle.getBundle(\"i18n\", locale); System.out.println(\"username：\" + bundle.getString(\"username\")); System.out.println(\"password：\" + bundle.getString(\"password\")); System.out.println(\"Sex：\" + bundle.getString(\"sex\")); System.out.println(\"age：\" + bundle.getString(\"age\"));} ¶5、通过请求头国际化页面 使用：在需要处理语言的地方 &lt;%=i18n.getString(\"xxx\")%&gt;，获取对应的语言字符串！ jsp页面： 123456789101112131415&lt;% // 方案一：从请求头获取语言信息自动识别 // accept-language: zh-CN,zh;q=0.9 // 从请求头中获取 Locale 信息（语言） Locale locale = request.getLocale(); System.out.println(locale); // 获取读取包（根据 指定的 baseName 和 Locale 读取 语言信息） ResourceBundle i18n = ResourceBundle.getBundle(\"i18n\", locale); // 获取读取包（根据 指定的 baseName 和 Locale 读取 语言信息） ResourceBundle i18n = ResourceBundle.getBundle(\"i18n\", locale);%&gt; ¶6、通过显示的选择语言类型进行国际化 通过页面的按钮显示的发送请求参数country=xxx！ 使用：在需要处理语言的地方 &lt;%=i18n.getString(\"xxx\")%&gt;，获取对应的语言字符串！ jsp页面： 12&lt;a href=\"i18n.jsp?country=cn\"&gt;中文&lt;/a&gt;|&lt;a href=\"i18n.jsp?country=usa\"&gt;english&lt;/a&gt; 123456789101112131415&lt;% // 方案二：通过点击给地址传参country确定 // 从请求头中获取 Locale 信息（语言） Locale locale = null; String country = request.getParameter(\"country\"); if (\"cn\".equals(country)) { locale = Locale.CHINA; } else if (\"usa\".equals(country)) { locale = Locale.US; } else { locale = request.getLocale(); } // 获取读取包（根据 指定的 baseName 和 Locale 读取 语言信息） ResourceBundle i18n = ResourceBundle.getBundle(\"i18n\", locale);%&gt; ¶7、JSTL 标签库实现国际化 记得引入&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;，当然IDE会自动引入！ 使用：在需要处理语言的地方 &lt;fmt:message key=\"xxx\" /&gt;，获取对应的语言字符串！ jsp页面： 12&lt;a href=\"i18n_fmt.jsp?locale=zh_CN\"&gt;中文&lt;/a&gt;|&lt;a href=\"i18n_fmt.jsp?locale=en_US\"&gt;english&lt;/a&gt; 1234567891011&lt;%--1 使用标签设置 Locale 信息--%&gt; &lt;fmt:setLocale value=\"${param.locale}\" /&gt; &lt;%--2 使用标签设置 baseName--%&gt; &lt;fmt:setBundle basename=\"i18n\"/&gt; &lt;%--3 输出指定 key 的国际化信息--%&gt; &lt;fmt:message key=\"username\" /&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://www.itnxd.cn/categories/JavaWeb/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"https://www.itnxd.cn/tags/JSON/"},{"name":"Ajax","slug":"Ajax","permalink":"https://www.itnxd.cn/tags/Ajax/"},{"name":"i18n","slug":"i18n","permalink":"https://www.itnxd.cn/tags/i18n/"}],"author":"ITNXD"},{"title":"JavaWeb之Filter过滤器、ThreadLocal的使用","slug":"JavaWeb之Filter过滤器、ThreadLocal的使用","date":"2021-03-18T09:29:01.000Z","updated":"2021-03-18T12:16:26.069Z","comments":true,"path":"posts/24926.html","link":"","permalink":"https://www.itnxd.cn/posts/24926.html","excerpt":"","text":"¶一、Filter ¶1、概述 Filter 过滤器它是 JavaWeb 的三大组件之一。三大组件分别是：Servlet 程序、Listener 监听器、Filter 过滤器。 Filter 过滤器它是 JavaEE 的规范。也就是接口。 Filter 过滤器它的作用是：拦截请求，过滤响应。 拦截请求常见的应用场景有： 权限检查 日记操作 事务管理 ¶2、Filter使用 Filter 过滤器的使用步骤： 编写一个类去实现 Filter 接口 实现过滤方法 doFilter() 到 web.xml 中去配置 Filter 的拦截路径 AdminFilter.java： doFilter方法中的filterChain.doFilter()方法必须要写，可以让未被拦截的请求继续向下执行，若不写该方法，则不被拦截的请求也无法访问到目标资源文件！具体原理请看下方的Filter实现原理图示！ 123456789101112131415161718192021222324252627282930313233343536373839404142public class AdminFilter implements Filter { public AdminFilter(){ System.out.println(\"1. 构造器方法\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"2. 初始化方法\"); } /** * 专门用于拦截请求！可以处理权限检查！ * @param servletRequest * @param servletResponse * @param filterChain * @throws IOException * @throws ServletException */ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"3. doFilter方法\"); HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; HttpSession session = httpServletRequest.getSession(); Object user = session.getAttribute(\"user\"); if(user == null){ // 未登录则转发到登录页面 servletRequest.getRequestDispatcher(\"/login.jsp\").forward(servletRequest, servletResponse); }else{ // 登录则放行：让用户继续访问! filterChain.doFilter(servletRequest, servletResponse); } } @Override public void destroy() { System.out.println(\"5. 销毁方法\"); }} web.xml： url-pattern：配置拦截路径，拦截到的请求使用Filter实现类中的doFilter()方法捕捉处理！ 12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;AdminFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.atguigu.filter.AdminFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;!--配置filter过滤器的拦截路径！--&gt;&lt;filter-mapping&gt; &lt;!--表示当前的拦截路径给哪个filter使用！--&gt; &lt;filter-name&gt;AdminFilter&lt;/filter-name&gt; &lt;!-- 配置拦截路径！ / 映射到工程的web目录 /* 表示匹配该目录下所有文件 --&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Filter实现原理： ¶3、Filter生命周期 构造器方法 init 初始化方法（前两步web工程启动时执行，Filter已经创建） doFilter 过滤方法，每次拦截到请求，就会执行 destroy 销毁，停止 web 工程的时候，就会执行（停止 web 工程，也会销毁 Filter 过滤器） ¶4、FilterConfig类 Filter 过滤器的配置文件类。 Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。 FilterConfig 类的作用是获取 filter 过滤器的配置内容： 获取 Filter 的名称 filter-name 的内容 获取在 Filter 中配置的 init-param 初始化参数 获取 ServletContext 对象 web.xml配置初始化参数： 1234567891011121314&lt;filter&gt; &lt;filter-name&gt;AdminFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.atguigu.filter.AdminFilter&lt;/filter-class&gt; &lt;!--这里配置init-param参数--&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;itnxd&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;AdminFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 获取配置信息： 123456789101112131415161718192021@Overridepublic void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"2. 初始化方法\"); // FilterConfig类的使用： // 1、获取 Filter 的名称 filter-name 的内容 String filterName = filterConfig.getFilterName(); System.out.println(\"filter-name的值是：\" + filterName); // 2、获取在 Filter 中配置的 init-param 初始化参数 String username = filterConfig.getInitParameter(\"username\"); System.out.println(\"初始化参数的username的值是：\" + username); // 3、获取 ServletContext 对象 System.out.println(filterConfig.getServletContext());} ¶5、FilterChain过滤器链 多个过滤器时候的执行顺序！ 多个过滤器时执行过程图示： Filter1代码： 12345678910@Overridepublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"Filter1的前置代码1\"); System.out.println(\"Filter1的线程：\" + Thread.currentThread().getName()); filterChain.doFilter(servletRequest, servletResponse); System.out.println(\"Filter1的线程：\" + Thread.currentThread().getName()); System.out.println(\"Filter1的后置代码2\");} Filter2代码： 12345678910@Overridepublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"Filter2的前置代码1\"); System.out.println(\"Filter2的线程：\" + Thread.currentThread().getName()); filterChain.doFilter(servletRequest, servletResponse); System.out.println(\"Filter2的线程：\" + Thread.currentThread().getName()); System.out.println(\"Filter2的后置代码2\");} 总结： 这些总结可以根据上方图示来理解！ Filter执行顺序由web.xml顺序决定 若删除Filter2的filterChain.doFilter方法，则访问不到资源，直接跳回Filter1 若删除Filter1的filterChain.doFilter方法，则Filter2也无法执行 同一个拦截目标经过的Filter共用一个线程 同一个拦截目标经过的Filter中的request域共用(一次请求，一次响应) ¶6、拦截路径 精确匹配 1.html 目录匹配 admin/* 后缀名匹配 *.jsp 注意： url-pattern标签可以有多个！ Filter过滤器它只关心请求的地址是否匹配，不关心请求的资源是否存在！ 1234567891011&lt;filter&gt; &lt;filter-name&gt;Filter2&lt;/filter-name&gt; &lt;filter-class&gt;com.atguigu.filter.Filter2&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;Filter2&lt;/filter-name&gt; &lt;url-pattern&gt;/target.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt; &lt;url-pattern&gt;/*.html&lt;/url-pattern&gt;&lt;/filter-mapping&gt; ¶二、ThreadLocal ¶1、概述 ThreadLocal 的作用，它可以解决多线程的数据安全问题。 ThreadLocal 它可以给当前线程关联一个数据（可以是普通变量，可以是对象，也可以是数组，集合） 可以用来处理项目中的数据库事务问题，即始终使用ThreadLocal维护一个Connection连接，可以进行事务管理！ 补充：对于数据库事务问题，据我理解，只要所有数据库操作都传入一个连接对象，且不在操作中进行关闭连接就可以达到事务操作的目的！正如康师傅的JDBC中的考虑事务操作的通用增删改查的实现，点击这里！ ¶2、ThreadLocal 特点 ThreadLocal 可以为当前线程关联一个数据。（它可以像 Map 一样存取数据，key 为当前线程） 每一个 ThreadLocal 对象，只能为当前线程关联一个数据，如果要为当前线程关联多个数据，就需要使用多个ThreadLocal 对象实例。 每个 ThreadLocal 对象实例定义的时候，一般都是 static 类型 ThreadLocal 中保存数据，在线程销毁后。会由 JVM 虚拟自动释放。 ¶3、ThreadLocal使用 ThreadLocal中定义了set、get、remove方法，用来关联 / 取出 / 移除数据 ThreadLocalTest类： 该类中调用多个线程分别使用ThreadLocal绑定一个随机数，会发现每个线程始终绑定一个随机数，即使在该线程结束前调用别的类，在别的类中打印线程名和绑定的值仍然是一样的！ 作用主要就是为了解决多线程问题，只要该ThreadLocal没有结束前，使用是一个线程，绑定的内容也是唯一的！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ThreadLocalTest { // ConcurrentHashMap是线程安全的Map！// public static Map&lt;String, Object&gt; map = new ConcurrentHashMap&lt;&gt;(); // 或 public static Map&lt;String, Object&gt; mao = new Hashtable&lt;&gt;(); // 使用ThreadLocal，key为当前线程！ public static ThreadLocal&lt;Object&gt; threadLocal = new ThreadLocal&lt;&gt;(); private static Random random = new Random(); public static class Task implements Runnable{ @Override public void run() { // 在 Run 方法中，随机生成一个变量（线程要关联的数据），然后以当前线程名为 key 保存到 map 中 Integer i = random.nextInt(1000); String name = Thread.currentThread().getName(); System.out.println(\"线程【\"+ name +\"】生成的随机数是：\" + i);// map.put(name, i); threadLocal.set(i); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } new OrderService().createOrder(); // 在 Run 方法结束之前，以当前线程名获取出数据并打印。查看是否可以取出操作// Object value = map.get(\"name\"); Object value = threadLocal.get(); System.out.println(\"在线程【\"+ name +\"】快结束时得到的随机数是：\" + i); } } public static void main(String[] args) { Task task = new Task(); for(int i = 0; i &lt; 3; i ++){ new Thread(task).start(); } }} OrderService类： 123456789public class OrderService { public void createOrder(){ String name = Thread.currentThread().getName();// System.out.println(\"当前线程【\"+ name +\"】保存的数据是：\" + ThreadLocalTest.map.get(name)); System.out.println(\"当前线程【\"+ name +\"】保存的数据是：\" + ThreadLocalTest.threadLocal.get()); }} ¶三、Tomcat配置错误页面 error-code：错误码（404，500） location：错误时要跳转的路径 123456789101112131415&lt;!--error-page 标签配置，服务器出错之后，自动跳转的页面--&gt;&lt;error-page&gt; &lt;!--error-code 是错误类型--&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;!--location 标签表示。要跳转去的页面路径--&gt; &lt;location&gt;/pages/error/error500.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;!--error-page 标签配置，服务器出错之后，自动跳转的页面--&gt;&lt;error-page&gt; &lt;!--error-code 是错误类型--&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;!--location 标签表示。要跳转去的页面路径--&gt; &lt;location&gt;/pages/error/error404.jsp&lt;/location&gt;&lt;/error-page&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://www.itnxd.cn/categories/JavaWeb/"}],"tags":[{"name":"Filter","slug":"Filter","permalink":"https://www.itnxd.cn/tags/Filter/"},{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"https://www.itnxd.cn/tags/ThreadLocal/"}],"author":"ITNXD"},{"title":"JavaWeb之谷歌Kaptcha验证码使用","slug":"JavaWeb之谷歌Kaptcha验证码使用","date":"2021-03-18T08:40:28.000Z","updated":"2021-03-18T09:27:05.139Z","comments":true,"path":"posts/44470.html","link":"","permalink":"https://www.itnxd.cn/posts/44470.html","excerpt":"","text":"¶一、概述 ¶1、表单重复提交 一些操作可能会导致表单的重复提交，造成数据错误的发生！这时验证码就横空出世了！ 提交完表单。服务器使用请求转发进行页面跳转。这个时候，用户按下功能键 F5，就会发起最后一次的请求。造成表单重复提交问题。解决方法：使用重定向来进行跳转 用户正常提交服务器，但是由于网络延迟等原因，迟迟未收到服务器的响应，这个时候，用户以为提交失败，就会着急，然后多点了几次提交操作，也会造成表单重复提交。 用户正常提交服务器。服务器也没有延迟，但是提交完成后，用户回退浏览器。重新提交。也会造成表单重复提交。 ¶2、验证码解决表单重复提交原理 如下图所示： 经过Servlet程序进行拦截！ ¶二、谷歌Kaptcha使用 ¶1、导包 需要导入谷歌验证码的包kaptcha-2.3.2.jar ¶2、XML配置 在web.xml文件中进行配置如下： 12345678&lt;servlet&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;KaptchaServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/kaptcha.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 每次访问http:ip:port/工程路径/kaptcha.jpg都会生成一个新的验证码！ ¶3、在表单中使用 表单中如下： 在img标签中加入该链接即可！ 123456&lt;form action=\"registServlet\" method=\"get\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br&gt; 验证码：&lt;input type=\"text\" name=\"code\" style=\"width: 60px\"/&gt; &lt;img src=\"http://localhost:8080/15_code/kaptcha.jpg\" alt=\"\"&gt;&lt;br&gt; &lt;input type=\"submit\"/&gt;&lt;/form&gt; ¶4、在Servlet中处理 注意： 每次刷新页面获取到的验证码会被自动保存到Session域中 属性名为：KAPTCHA_SESSION_KEY 由于验证码只使用一次，请获取后立马删除 12345678910111213141516171819202122232425public class RegistServlet extends HttpServlet { /* 谷歌验证码开源包也是使用Tomcat8，servlet-api包最好也用8.0的！ * */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 获取Session域中的验证码！ String token = (String) req.getSession().getAttribute(KAPTCHA_SESSION_KEY); // 获取完毕，马上删除 req.getSession().removeAttribute(KAPTCHA_SESSION_KEY); // 获取表单中的信息 String code = req.getParameter(\"code\"); String username = req.getParameter(\"username\"); if(token != null &amp;&amp; token.equalsIgnoreCase(code)){ System.out.println(\"保存到数据库：\" + username); resp.sendRedirect(req.getContextPath() + \"/ok.jsp\"); }else{ System.out.println(\"请不要重复提交表单！\"); } }} ¶5、点击图片切换验证码 在前端 JS 页面中处理即可！ 注意： 重新设置img标签的src属性，其实就是再次给服务器发送了一次请求，所以验证码会改变 为了解决除谷歌浏览器以外其他浏览器的缓存问题，可以简单的修改资源路径，在后面添加一个唯一的参数即可！ 这里采用时间戳方式保证唯一性即可！ 123$(\"#code_img\").click(function (){ this.src = \"${basePath}\" + \"kaptcha.jpg?d=\" + new Date();}); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://www.itnxd.cn/categories/JavaWeb/"}],"tags":[{"name":"Kaptcha","slug":"Kaptcha","permalink":"https://www.itnxd.cn/tags/Kaptcha/"},{"name":"验证码","slug":"验证码","permalink":"https://www.itnxd.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"}],"author":"ITNXD"},{"title":"JavaWeb之Cookie和Session使用","slug":"JavaWeb之Cookie和Session使用","date":"2021-03-15T14:50:10.000Z","updated":"2021-03-16T03:02:04.748Z","comments":true,"path":"posts/56534.html","link":"","permalink":"https://www.itnxd.cn/posts/56534.html","excerpt":"","text":"¶一、Cookie ¶1、Cookie概述 Cookie 翻译过来是饼干的意思。 Cookie 是服务器通知客户端保存键值对的一种技术。 客户端有了 Cookie 后，每次请求都发送给服务器。 每个 Cookie 的大小不能超过 4kb，对同一个域名下的总cookie数量限制为20个。 作用： Cookie一般用于存储少量的安全性较低的数据 在不登陆的情况下，完成服务器对客户端的身份识别， ¶2、Cookie创建 BaseServlet.java： 创建的Servlet程序都继承自该抽象类！可以使用反射动态获取执行方法！ 123456789101112131415161718192021222324252627282930public abstract class BaseServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 解决post请求中文乱码问题： req.setCharacterEncoding(\"UTF-8\"); // 解决响应中中文乱码问题： resp.setContentType(\"text/html; charset=UTF-8\"); // 获取隐藏域action的参数！ String action = req.getParameter(\"action\"); // 使用反射动态获取action的值对应的方法去调用，避免大量的if判断！ try { Method method = this.getClass().getDeclaredMethod(action, HttpServletRequest.class, HttpServletResponse.class); method.invoke(this, req, resp); } catch (Exception e) { e.printStackTrace(); } }} Cookie创建： 请求头收到响应头发来的Set-Cookie，客户端就会保存为Cookie! 若没有，则新创建 若有，则覆盖更新 123456789protected void createCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 创建Cookie Cookie cookie = new Cookie(\"key2\", \"value2\"); // 2. 通知客户端保存Cookie resp.addCookie(cookie); resp.getWriter().write(\"cookie创建成功！\");} ¶3、服务器获取Cookie Cookie获取代码： 12345678910111213protected void getCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Cookie[] cookies = req.getCookies(); for (Cookie cookie : cookies) { resp.getWriter().write(cookie.getName() + \": \" + cookie.getValue() + \"&lt;br&gt;\"); } // 查找特定Cookie，封装到CookieUtils里 Cookie findCookie = CookieUtils.FindCookie(\"key1\", cookies); if(findCookie != null){ resp.getWriter().write(findCookie.getName() + \": \" + findCookie.getValue()); }} 由于查找特定Cookie需要循环，所以将其封装到WebUtils工具类： 12345678910111213141516171819202122public class CookieUtils { /** * 查找特定Cookie！ * @param name * @param cookies * @return */ public static Cookie FindCookie(String name, Cookie[] cookies){ if(name == null || cookies == null || cookies.length == 0){ return null; } for (Cookie cookie : cookies) { if(name.equals(cookie.getName())){ return cookie; } } return null; }} ¶4、Cookie值的修改 方案一：创建同名Cookie对象进行覆盖 方案二：找到要修改Cookie对象，使用Set方法设置 注意： 汉字，二进制：使用BASE64编码。 对于Version 0 cookie，值不应包含空格、方括号、圆括号、等号、逗号、双引号、斜杠、问号、at符号、冒号和分号。空值在所有浏览器上的行为不一定相同。 Tomcat 8之后Cookie可以存中文，但特殊中文字符仍不支持，建议使用URL编码格式 12345678910111213141516171819202122protected void updateCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 方案一： // 1、先创建一个要修改的同名（指的就是 key）的 Cookie 对象 // 2、在构造器，同时赋于新的 Cookie 值。 Cookie cookie = new Cookie(\"key1\", \"newValue\"); // 3、调用 response.addCookie( Cookie ); resp.addCookie(cookie); resp.getWriter().write(cookie.getName() + \": \" + cookie.getValue()); // 方案二： // 1、先查找到需要修改的 Cookie 对象 Cookie cookie1 = CookieUtils.FindCookie(\"key2\", req.getCookies()); if(cookie1 != null){ // 2、调用 setValue()方法赋于新的 Cookie 值。 cookie1.setValue(\"newValue2\"); // 3、调用 response.addCookie()通知客户端保存修改 resp.addCookie(cookie1); } resp.getWriter().write(cookie1.getName() + \": \" + cookie1.getValue());} ¶5、浏览器查看Cookie ¶6、Cookie生命控制 Cookie 的生命控制指的是如何管理 Cookie 什么时候被销毁（删除）! 需要使用到 setMaxAge()方法： 正数，表示在指定的秒数后过期 负数，表示浏览器一关，Cookie 就会被删除（默认值是-1） 零，表示马上删除 Cookie 12345678910111213141516171819202122232425// 浏览器关闭后删除 protected void defaultLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Cookie cookie = new Cookie(\"default\", \"default\"); cookie.setMaxAge(-1); resp.addCookie(cookie); }// 马上删除protected void deleteNow(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 先找到你要删除的 Cookie 对象 Cookie cookie = CookieUtils.FindCookie(\"key2\", req.getCookies()); if(cookie != null){ // 调用 setMaxAge(0); cookie.setMaxAge(0); // 表示马上删除，都不需要等待浏览器关闭 // 调用 response.addCookie(cookie); resp.addCookie(cookie); }}// 一小时后删除protected void life3600(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Cookie cookie = new Cookie(\"life3600\", \"life3600\"); cookie.setMaxAge(3600); resp.addCookie(cookie);} ¶7、Cookie有效路径Path的设置 Cookie 的 path 属性可以有效的过滤哪些 Cookie 可以发送给服务器。哪些不发。 path 属性是通过请求的地址来进行有效的过滤。 注意： 访问：http://localhost:8080/14_cookie_session/cookie.html不会得到path1的cookie，毕竟不匹配abc路径 访问：http://localhost:8080/14_cookie_session/abc/cookie.html可以得到 请求头可以看到set-cookie属性，但是application看不到！ 默认情况：参数是web工程路径/14_cookie_session，只有本工程可访问 要使本ip和port内所有项目共享：可以设置参数为 / 即 http://ip:port/ 不同的服务器间cookie的共享：使用Cookie对象的setDomain(String path)方法，参数设置为一级域名，则一级域名相同的不同服务器之间Cookie可共享 123456protected void setPath(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Cookie cookie = new Cookie(\"path1\", \"path1\"); cookie.setPath(req.getContextPath() + \"/abc\"); resp.addCookie(cookie);} ¶8、免用户名登录练习 即再次登录时，无需输入用户名，浏览器默认显示上次登录用户名！ 如下图所示： login.jsp： 12345&lt;form action=\"http://localhost:8080/14_cookie_session/loginServlet\" method=\"get\"&gt; 用户名：&lt;input type=\"text\" name=\"username\" value=\"${cookie.username.value}\"&gt; 密码：&lt;input type=\"password\" name=\"password\"&gt; &lt;input type=\"submit\" value=\"登录\"&gt;&lt;/form&gt; LoginServlet.java： 1234567891011121314151617public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); if(\"itnxd\".equals(username) == \"123456\".equals(password)){ // 登录成功 Cookie cookie = new Cookie(\"username\", username); cookie.setMaxAge(60 * 60 * 24 * 7); // 七天有效 resp.addCookie(cookie); System.out.println(\"登录成功！\"); }else{ System.out.println(\"登录失败！\"); } }} ¶二、Session ¶1、Session概述 Session是服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存到服务器端！ Session 就一个接口（HttpSession）。 Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术。 每个客户端都有自己的一个 Session 会话。 Session 会话中，我们经常用来保存用户登录之后的信息。 ¶2、Session的创建和获取 request.getSession()： 第一次调用是：创建 Session 会话 之后调用都是：获取前面创建好的 Session 会话对象。 isNew()：判断到底是不是刚创建出来的（新的） **getId()：**得到 Session 的会话 id 值。每个会话都有一个身份证号。也就是 ID 值。而且这个 ID 是唯一的！ 1234567891011protected void createOrGetSession(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 创建或获取Session对象 HttpSession session = req.getSession(); // 判断是否是创建 boolean isNew = session.isNew(); // 获取会话id String id = session.getId(); resp.getWriter().write(\"Session的id是：\" + id + \"&lt;br/&gt;\"); resp.getWriter().write(\"Session是否是新创建的：\" + isNew + \"&lt;br/&gt;\");} ¶3、Session域数据的存取 123456789protected void setAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.getSession().setAttribute(\"session1\", \"session1\"); resp.getWriter().write(\"在Session域中保存了数据！\");}protected void getAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Object attribute = req.getSession().getAttribute(\"session1\"); resp.getWriter().write(\"Session域中保存的session1的值是：\" + attribute);} ¶4、Session生命周期控制 Session超时指的是两次请求之间最大间隔时长！ **public void setMaxInactiveInterval(int interval)：**设置 Session 的超时时间（以秒为单位），超过指定的时长，Session就会被销毁。 值为正数的时候，设定 Session 的超时时长。 负数表示永不超时（极少使用） public int getMaxInactiveInterval()：获取 Session 的超时时间 public void invalidate()：让当前 Session 会话马上超时无效。 注意： Session 默认的超时时间长为 30 分钟。 Tomcat配置文件的web.xml文件中配置了超时时长 1234567&lt;!-- C:\\Users\\15890\\AppData\\Local\\JetBrains\\IntelliJIdea2020.3\\tomcat\\4d4e0435-4fce-483b-a230-26a04fd14dc4\\conf 该路径下的web.xml指定了超时时长--&gt;&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 可通过设置工程下的web.xml文件指定超时时长 1234&lt;!--修改Tomcat服务器默认的Session超时时间为20分钟！一般不进行修改！--&gt;&lt;session-config&gt; &lt;session-timeout&gt;20&lt;/session-timeout&gt;&lt;/session-config&gt; 也可通过setMaxInactiveInterval(int interval)设置指定的Session超时 Session超时演示： 12345678910111213141516171819protected void defaultLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { int maxInactiveInterval = req.getSession().getMaxInactiveInterval(); // 默认1800秒，即30分钟 resp.getWriter().write(\"Session的默认超时时长为：\" + maxInactiveInterval + \"秒\")}protected void life3s(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 设置Session 3秒后超时 // 先点击创建，再点击设置3秒，再点击获取，三秒内都为false，超过3秒为true(即重新创建的Session) // 想要使得新建的再次超时，还需要再次点击设置3秒，重复操作 req.getSession().setMaxInactiveInterval(3); resp.getWriter().write(\"当前Session已设置为3秒后超时！\");}protected void deleteNow(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.getSession().invalidate(); resp.getWriter().write(\"当前Session点击该按钮后马上失效！\");} ¶5、浏览器和Session之间的技术 Session 技术，底层其实是基于 Cookie 技术来实现的。 ¶6、Session与Cookie总结 Session的特点： Session用于存储一次会话的多次请求数据，存在服务器端，一次会话只有一个session对象 Session可以存储任意类型，任意大小的数据 Session与Cookie的区别： Session存储数据在服务器端，Cookie在客户端 Session没有数据大小的限制，Cookie有(4KB) Session数据安全，Cookie相对不安全 客户端关闭服务器不关闭，两次获取的Session是否是同一个对象? 默认情况下，不是一个对象，默认情况下客户端关闭后Cookie就会被销毁，再次启动客户端发请求给服务器端，服务器端会重新创建Session并响应给客户端保存为Cookie 可通过设置该Session对应的Cookie（即JSESSIONID）的存活时间实现同一个Session对象的目的！ 客户端不关闭服务器关闭，两次获取的Session是否是同一个对象? 不是同一个对象，（第二次为新创建的，但数据相同！）但为了保证数据不丢失，Tomcat服务器完成两步操作： Session钝化：在服务器正常关闭之前，将Session对象序列化到硬盘上 Session活化：在服务器启动之后，将Session文件反序列化成为内存中的Session对象 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://www.itnxd.cn/categories/JavaWeb/"}],"tags":[{"name":"Cookie","slug":"Cookie","permalink":"https://www.itnxd.cn/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"https://www.itnxd.cn/tags/Session/"}],"author":"ITNXD"},{"title":"JavaWeb之文件的上传和下载","slug":"JavaWeb之文件的上传和下载","date":"2021-03-15T11:26:30.000Z","updated":"2021-03-15T14:47:44.541Z","comments":true,"path":"posts/15689.html","link":"","permalink":"https://www.itnxd.cn/posts/15689.html","excerpt":"","text":"¶一、文件上传 ¶1、文件上传介绍 要有一个 form 标签，method=post 请求 form 标签的 encType 属性值必须为 multipart/form-data 值 在 form 标签中使用 input type=file 添加上传的文件 编写服务器代码（Servlet 程序）接收，处理上传的数据。 注意：encType=multipart/form-data 表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼接，然后以二进制流的形式发送给服务器。 upload.jsp文件： 注意：get的url长度有限制，post无限制，一般上传使用post 123456&lt;%--get的url长度有限制，post无限制--%&gt;&lt;form action=\"uploadServlet\" method=\"post\" enctype=\"multipart/form-data\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt; 头像：&lt;input type=\"file\" name=\"photo\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;br&gt;&lt;/form&gt; 配置XML文件： 12345678&lt;servlet&gt; &lt;servlet-name&gt;UploadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atguigu.servlet.UploadServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;UploadServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/upload&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; uploadServlet文件： 注意：以流的形式发送，无法通过请求参数接收！form表单的enctype属性决定的！ 使用如下方式接收上传的文件，在控制台自然是乱码的，毕竟是二进制数据！ 12345678910111213141516171819@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException{ System.out.println(\"收到文件了！\"); /*以流的形式发送，无法通过请求参数接收！ form表单的enctype属性决定的！ * */ // System.out.printf(req.getParameter(\"username\")); // System.out.printf(req.getParameter(\"photo\")); // 需要以流形式接收！ ServletInputStream is = req.getInputStream(); // 够大为100k，读一次即可读完！ byte[] buffer = new byte[102400000]; int len = is.read(buffer); // 可在控制台打印输出！自然为 System.out.println(new String(buffer, 0, len));} 文件上传发送的HTTP协议内容： 注意：谷歌浏览器中上传的文件的数据显示的是空行，毕竟数据太多，还不是文本数据，但不影响服务器接收数据！ ¶2、使用第三方包解决 需要使用第三方包 commons-fileupload.jar来解决！ ¶2.1、导包 commons-fileupload.jar commons-io.jar ¶2.2、该开源库的常用方法 ServletFileUpload 类，用于解析上传的数据： public static final boolean isMultipartContent(HttpServletRequest request)：判断当前上传的数据格式是否是多段的格式。 public List&lt;FileItem&gt; parseRequest(HttpServletRequest request)：解析上传的数据，返回包含每一个表单项的List集合 FileItem类，表示每一个表单项： public boolean isFormField()：如果当前表单项是普通表单项，返回true，文件类型返回false public String getFieldName()：获取当前表单项的name属性值 public String getString()：获取当前表单项的value属性值，参数为”UTF-8”可解决乱码问题 public String getName()：获取上传的文件名 public void write(File file)：将上传的文件写到参数File所指向的硬盘位置 ¶2.3、解析上传数据的代码 注意：此开源jar包并不兼容Tomcat10，Tomcat10实在太新了。请安装Tomcat8使用! 12345678910111213141516171819202122232425262728293031323334353637383940414243public class UploadServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException{ // 1. 判断上传数据是否是多段数据 /* tomcat10实在太新了，包都无法兼容，安装tomcat8使用! * */ if(ServletFileUpload.isMultipartContent(req)){ // 2. 创建 FileItemFactory工厂类 FileItemFactory fileItemFactory = new DiskFileItemFactory(); // 3. 创建用于解析上传数据的工具类ServletFileUpload ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory); try { // 4. 解析上传数据，得到表单项FileItem集合 List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req); for (FileItem fileItem : list) { // 5. 判断每一个表单项是普通类型还是文件类型 if(fileItem.isFormField()){ // 普通类型 System.out.println(\"表单项的name属性为：\" + fileItem.getFieldName()); // 写入字符集，防止乱码 System.out.println(\"表单项的value属性为：\" + fileItem.getString(\"UTF-8\")); }else{ // 上传的文件类型 System.out.println(\"表单项的name属性为：\" + fileItem.getFieldName()); System.out.println(\"上传的文件名为：\" + fileItem.getName()); // 写入本地： fileItem.write(new File(\"C:\\\\Users\\\\15890\\\\Desktop\\\\\" + fileItem.getName())); } } } catch (Exception e) { e.printStackTrace(); } } }} ¶二、文件下载 ¶1、文件下载过程 获取要下载的文件名 创建ServletContext对象 回传客户端前，通过ServletContext对象设置响应头告诉客户端返回的数据类型及用途 通过ServletContext对象流读取该文件 通过Response获取输出流 通过commons-io包下的 IOUtils工具类的copy方法读到输出流 ¶2、代码实现 注意点： 告诉客户端设置数据类型：resp.setContentType(mimeType) 告诉客户端为下载用途：resp.setHeader(\"Content-Disposition\", \"attachment; fileName=\" + fileName) Content-Disposition：表示收到数据如何处理 attachment：表示附件，用于下载 fileName：表示下载文件的保存名字 下载文件名为中文的乱码问题： 使用URL编码即可： String fileName = URLEncoder.encode(downloadFileName, \"UTF-8\") 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class DownLoadServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 获取要下载文件名// String downloadFileName = \"美女.jpg\"; String downloadFileName = \"ghs.mp4\"; // 2. 读取要下载的文件（ServletContext） ServletContext servletContext = getServletContext(); // 3. 回传到客户端前，通过响应头告诉客户端返回的数据类型及用途 // 获取要下载文件的类型！ String mimeType = servletContext.getMimeType(\"/file/\" + downloadFileName); // 通过响应头设置告诉客户端文件类型 resp.setContentType(mimeType); System.out.println(\"文件类型为：\" + mimeType); // 通过响应头告诉客户端获取到的文件是用于下载的 // Content-Disposition：表示收到数据如何处理 // attachment：表示附件，用于下载 // fileName：表示下载文件的保存名字 // 处理中文文件名下载乱码问题:使用URL编码：把汉字转换为%xx%xx格式 String fileName = URLEncoder.encode(downloadFileName, \"UTF-8\"); resp.setHeader(\"Content-Disposition\", \"attachment; fileName=\" + fileName); // 通过User-Agent判断浏览器类型，分别处理！ // 处理火狐，使用Base64编码// if(req.getHeader(\"User-Agent\").contains(\"Firefox\")){// // 新版本火狐已不需要！// String str = \"attachment; fileName=\" + \"=?utf-8?B?\" + Base64.getEncoder().encodeToString(downloadFileName.getBytes(\"utf-8\")) + \"?=\";// // 设置到响应头中// resp.setHeader(\"Content-Disposition\", str);// }else{// // 处理谷歌和IE，使用URL编码// String fileName = URLEncoder.encode(downloadFileName, \"UTF-8\");// resp.setHeader(\"Content-Disposition\", \"attachment; fileName=\" + fileName);// } // 4. 使用流读取该文件 InputStream resourceAsStream = servletContext.getResourceAsStream(\"/file/\" + downloadFileName); // 5. 通过Response获取输出流 ServletOutputStream outputStream = resp.getOutputStream(); // 6. 通过commons-io包下的 IOUtils工具类的copy方法读到输出流 IOUtils.copy(resourceAsStream, outputStream); }} ¶3、火狐浏览器乱码问题（了解） 以前的火狐浏览器下载的文件名含有中文会乱码，使用URL编码后仍然乱码，必须使用BASE64编码！ But：如今新时代的火狐浏览器使用和谷歌或IE浏览器一样的URL编码即可正确显示中文文件名！ So：下方处理火狐浏览器下载中文乱码的内容，仅作为学习记录，了解即可！ ¶3.1、Base64使用 注意：jdk8之后不再支持BASE64Decoder和BASE64Encoder两个类！ 取而代之的是java.util.Base64类！ JDK8之前的旧版、废弃版：（了解） 123456789101112131415161718192021import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder;//jdk8之后不再支持上述两个类public class Base64Test { public static void main(String[] args) throws Exception { String content = \"这是需要Base64编码的内容\"; System.out.println(\"初始内容：\" + content); // 创建一个Base64编码器 BASE64Encoder base64Encoder = new BASE64Encoder(); // 执行Base64编码操作，encode()参数是字节数组 String encodedString = base64Encoder.encode(content.getBytes(\"UTF-8\")); System.out.println(\"编码后的结果：\" + encodedString ); // 创建Base64解码器 BASE64Decoder base64Decoder = new BASE64Decoder(); // 解码操作 byte[] bytes = base64Decoder.decodeBuffer(encodedString); //以utf-8编码，以utf-8解码 String str = new String(bytes, \"UTF-8\"); System.out.println(\"解码后的结果：\" + str); }} JDK8之后的新版、高效率版： 与sun.misc套件和Apache Commons Codec所提供的Base64编解码器来比较的话，Java 8提供的Base64拥有更好的效能。 实际测试编码与解码速度的话，Java 8提供的Base64，要比sun.misc套件提供的还要快至少11倍，比Apache Commons Codec提供的还要快至少3倍。 因此在Java上若要使用Base64，这个Java 8底下的java.util套件所提供的Base64类别绝对是首选！ 1234567891011121314151617public class Base64Test { public static void main(String[] args) throws UnsupportedEncodingException { String str = \"这是我的祖国！\"; // 编码： Base64.Encoder encoder = Base64.getEncoder(); String s = encoder.encodeToString(str.getBytes(StandardCharsets.UTF_8)); System.out.println(s); // 6L+Z5piv5oiR55qE56WW5Zu977yB // 解码： Base64.Decoder decoder = Base64.getDecoder(); String s1 = new String(decoder.decode(s), \"UTF-8\"); System.out.println(s1); // 这是我的祖国！ }} ¶3.2、火狐乱码解决（了解） 谷歌浏览器请求头： Content-Disposition: attachment; filename=中文名 火狐浏览器请求头：Content-Disposition: attachment; filename==?charset?B?xxxxx?= filename后的参数介绍： =? 表示编码内容的开始 charset 表示字符集(UTF-8、GBK等) B 表示BASE64编码 xxxx 表示BASE64编码后的内容 ?= 表示编码内容的结束 通过User-Agent判断浏览器类型，分别处理：（了解） 123456789101112// 通过User-Agent判断浏览器类型，分别处理！// 处理火狐，使用Base64编码if(req.getHeader(\"User-Agent\").contains(\"Firefox\")){ // 新版本火狐已不需要！ String str = \"attachment; fileName=\" + \"=?utf-8?B?\" + Base64.getEncoder().encodeToString(downloadFileName.getBytes(\"utf-8\")) + \"?=\"; // 设置到响应头中 resp.setHeader(\"Content-Disposition\", str);}else{ // 处理谷歌和IE，使用URL编码 String fileName = URLEncoder.encode(downloadFileName, \"UTF-8\"); resp.setHeader(\"Content-Disposition\", \"attachment; fileName=\" + fileName);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://www.itnxd.cn/categories/JavaWeb/"}],"tags":[{"name":"文件上传下载","slug":"文件上传下载","permalink":"https://www.itnxd.cn/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"}],"author":"ITNXD"},{"title":"JavaWeb之EL表达式和JSTL标签库","slug":"JavaWeb之EL表达式和JSTL标签库","date":"2021-03-11T09:19:55.000Z","updated":"2021-03-11T12:51:14.423Z","comments":true,"path":"posts/12961.html","link":"","permalink":"https://www.itnxd.cn/posts/12961.html","excerpt":"","text":"¶一、EL表达式 ¶1、EL表达式概述 EL 表达式的全称是：Expression Language。是表达式语言。 EL 表达式的什么作用：EL 表达式主要是代替 jsp 页面中的表达式脚本在 jsp 页面中进行数据的输出。 因为 EL 表达式在输出数据的时候，要比 jsp 的表达式脚本要简洁很多。 EL 表达式的格式是：${表达式} EL 表达式在输出 null 值的时候，输出的是空串。jsp 表达式脚本输出 null 值的时候，输出的是 null 字符串。 1234567891011&lt;% request.setAttribute(\"key1\", \"value1\");%&gt;表达式脚本输出：&lt;%=request.getAttribute(\"key1\")%&gt; &lt;br&gt;&lt;%-- 放入key值即可！ --%&gt;EL表达式输出：${key1} &lt;br&gt;表达式脚本输出：&lt;%=request.getAttribute(\"key2\")%&gt; &lt;br&gt;EL表达式输出：${key2} &lt;br&gt;表达式脚本判空输出：&lt;%=request.getAttribute(\"key2\") == null ? \"\" : request.getAttribute(\"key2\")%&gt; &lt;br&gt; ¶2、EL表达式搜索域数据的顺序 EL 表达式主要是在 jsp 页面中输出数据。主要是输出域对象中的数据。 当四个域中都有相同的 key 的数据的时候，EL 表达式会按照四个域的从小到大的顺序去进行搜索，找到就输出。 123456789101112131415&lt;% // 往四个域中都分别保存了数据 pageContext.setAttribute(\"key\", \"pageContext\"); request.setAttribute(\"key\", \"request\"); session.setAttribute(\"key\", \"session\"); application.setAttribute(\"key\", \"application\");%&gt;&lt;%-- 按照作用域范围大小，从小到大，就近原则去取！ 注意：session需要关闭浏览器才会销毁！ application需要重启服务器才会销毁！--%&gt;${key} ¶3、EL表达式输出Java类 EL 表达式输出 Bean 的普通属性，数组属性。List 集合属性，map 集合属性！ 注意：EL表达式是通过对应属性的get方法获取的！没有对应的get方法则无法访问！boolean类型通过is方法获得！ 12345678public class Person { private String name; private String[] phones; private List&lt;String&gt; cities; private Map&lt;String,Object&gt; map; .....} 示例如下： 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;% Person person = new Person(); person.setName(\"ITNXD\"); person.setPhones(new String[]{\"18610541354\",\"18688886666\",\"18699998888\"}); List&lt;String&gt; cities = new ArrayList&lt;String&gt;(); cities.add(\"北京\"); cities.add(\"上海\"); cities.add(\"深圳\"); person.setCities(cities); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"key1\",\"value1\"); map.put(\"key2\",\"value2\"); map.put(\"key3\",\"value3\"); person.setMap(map);pageContext.setAttribute(\"p\", person); %&gt; 输出 Person：${ p }&lt;br/&gt; 输出 Person 的 name 属性：${p.name} &lt;br&gt; 输出 Person 的 pnones 数组属性值：${p.phones[2]} &lt;br&gt; 输出 Person 的 cities 集合中的元素值：${p.cities} &lt;br&gt; 输出 Person 的 List 集合中个别元素值：${p.cities[2]} &lt;br&gt; 输出 Person 的 Map 集合: ${p.map} &lt;br&gt; 输出 Person 的 Map 集合中某个 key 的值: ${p.map.key3} &lt;br&gt; &lt;%--EL表达式是通过get方法获取的！没有对应的get方法则无法访问！--%&gt; 输出 Person 的 age 属性：${p.age} &lt;br&gt;&lt;/body&gt; ¶4、EL表达式运算 ¶4.1、关系运算 ¶4.2、逻辑运算 ¶4.3、算术运算 ¶4.4、empty运算 empty 运算可以判断一个数据是否为空，如果为空，则输出 true,不为空输出 false。 以下几种情况为空： 值为 null 值的时候，为空 值为空串的时候，为空 值是 Object 类型数组，长度为零的时候 list 集合，元素个数为零 map 集合，元素个数为零 12345678910111213141516171819&lt;% request.setAttribute(\"key1\", null); request.setAttribute(\"key2\", new Object()); request.setAttribute(\"key3\", \"\"); request.setAttribute(\"key4\", new Object[]{}); request.setAttribute(\"key5\", new ArrayList&lt;Integer&gt;()); request.setAttribute(\"key6\", new HashMap&lt;String, Integer&gt;());%&gt;${empty key1}${empty key2}${empty key3}${empty key4}${empty key5}${empty key6} ¶4.5、三元运算符 格式：表达式 1？表达式 2：表达式 3 如果表达式 1 的值为真，返回表达式 2 的值，如果表达式 1 的值为假，返回表达式 3 的值。 1${ 12 != 12 ? \"不等于\":\"等于\" } ¶4.6、“.”点运算 和 [] 中括号运算符 .点运算，可以输出 Bean 对象中某个属性的值。 []中括号运算，可以输出有序集合中某个元素的值。 注意：[]中括号运算，还可以输出 map 集合中 key 里含有特殊字符的 key 的值。 12345678910111213&lt;% Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"a.a.a\", \"aaaValue\"); map.put(\"bb\", \"bbbValue\"); map.put(\"c-c-c\", \"cccValue\"); request.setAttribute(\"map\", map);%&gt;${map.bb}&lt;%--有特殊字符使用中括号括起来，并使用引号引起来，单双引号都可！--%&gt;${map[\"a.a.a\"]}&lt;%--找不到c,则会以0运算，结果为0--%&gt;${map.c-c-c} ¶5、EL表达式11个隐含对象 EL 个达式中 11 个隐含对象，是 EL 表达式中自己定义的，可以直接使用。 ¶5.1、四个特定域对象使用 pageScope requestScope sessionScope applicationScope 123456789101112131415 &lt;% pageContext.setAttribute(\"key1\", \"pageContext1\"); pageContext.setAttribute(\"key2\", \"pageContext2\"); request.setAttribute(\"key2\", \"request\"); session.setAttribute(\"key2\", \"session\"); application.setAttribute(\"key2\", \"application\");%&gt;&lt;%--同样作用域问题，默认为最小作用域pageContext--%&gt;${key2}&lt;%--想要获取需要使用四个特定域对象！--%&gt;${requestScope.key2}${sessionScope.key2}${applicationScope.key2} ¶5.2、pageContext 对象使用 pageContext、pageContextImpl 它可以获取 jsp 中的九大内置对象： Request,response,application,config,session,exception,out,page,pageContext 注意：EL表达式默认去找对应属性的get方法！无需再次写get! request.getScheme()：它可以获取请求的协议 request.getServerName()：获取请求的服务器 ip 或域名 request.getServerPort()：获取请求的服务器端口号 getContextPath()：获取当前工程路径 request.getMethod()：获取请求的方式（GET 或 POST） request.getRemoteHost()：获取客户端的 ip 地址 session.getId()：获取会话的唯一标识 123456789101112131415161718192021&lt;%--org.apache.jasper.runtime.PageContextImpl@158751e5--%&gt;${pageContext}&lt;br&gt;&lt;%=request.getScheme()%&gt;&lt;br&gt;1. 协议： ${pageContext.request.scheme}&lt;br&gt;2. 服务器 ip： ${pageContext.request.serverName}&lt;br&gt;3. 服务器端口： ${pageContext.request.serverPort}&lt;br&gt;4. 获取工程路径： ${pageContext.request.contextPath}&lt;br&gt;5. 获取请求方法： ${pageContext.request.method}&lt;br&gt;6. 获取客户端 ip 地址： ${pageContext.request.remoteHost}&lt;br&gt;7. 获取会话的 id 编号： ${pageContext.session.id}&lt;br&gt;&lt;% /*简便写法，req就表示pageContext.request*/ pageContext.setAttribute(\"req\", request);%&gt;1. 协议：&lt;br&gt; ${req.scheme} ¶5.3、param、paramValues对象的使用 param Map&lt;String,String&gt;： 它可以获取请求参数的值 paramValues Map&lt;String,String[]&gt;： 它也可以获取请求参数的值，获取多个值的时候使用。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%-- http://localhost:8080/11_EL_JSTL/f.jsp?username=itnxd&amp;password=9999 在后面添加参数即可获取到！ {password=9999, username=itnxd}--%&gt;${param}&lt;br&gt;输出请求参数username的值：${param.username}&lt;br&gt;输出请求参数password的值：${param.password}&lt;br&gt;&lt;%-- {password=[Ljava.lang.String;@278ba21, username=[Ljava.lang.String;@cbf441e, hobby=[Ljava.lang.String;@880d151}--%&gt; ${paramValues}&lt;br&gt;&lt;%-- 例如hobby有多个值，则只能使用paramValues获取！ http://localhost:8080/11_EL_JSTL/f.jsp?username=itnxd&amp;password=9999&amp;hobby=python&amp;hobby=cpp&amp;hobby=java 输出请求参数username的值：itnxd 输出请求参数password的值：9999 输出请求参数hobby的值：[Ljava.lang.String;@4d824e25--%&gt;输出请求参数username的值：${paramValues.username[0]}&lt;br&gt;输出请求参数password的值：${paramValues.password[0]}&lt;br&gt;&lt;%--[Ljava.lang.String;@4d824e25--%&gt;输出请求参数hobby的值：${paramValues.hobby}&lt;br&gt;输出请求参数hobby的值：${paramValues.hobby[0]}&lt;br&gt;输出请求参数hobby的值：${paramValues.hobby[1]}&lt;br&gt;输出请求参数hobby的值：${paramValues.hobby[2]}&lt;br&gt;&lt;%-- 遍历输出paramValues的值！ 讲到JSTL会有遍历！--%&gt; ¶5.4、header、headerValues对象的使用 header：它可以获取请求头的信息 headerValues：它可以获取请求头的信息，它可以获取多个值的情况 1234567891011121314151617181920212223242526&lt;%-- 请求头： {sec-fetch-mode=navigate, sec-fetch-site=none, accept-language=zh-CN,zh;q=0.9, cookie=JSESSIONID=1344E72E74FE9D73D18790C77093CCCD; goSessionid=OpXuceHmsYklJ-IXbQpZk1V23NRp2vhWhnruBe3I7aE%3D; Webstorm-9f808640=3b2f49b2-7084-46ed-84b3-60c2292a9e29; Idea-898f7731=e37b1876-f485-4481-921d-da5853ecd0c3; Webstorm-e01d478=665eb7b3-3726-4179-a46c-f044518546e5; Idea-898f7733=304f9d70-c0f4-4aa1-b403-f0137f8f5b27; Hm_lvt_8d3bd59bf6303bd5f44677445d369df5=1613967148,1614062180,1614999148,1615085606, sec-fetch-user=?1, accept=text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9, sec-ch-ua=\"Chromium\";v=\"88\", \"Google Chrome\";v=\"88\", \";Not A Brand\";v=\"99\", sec-ch-ua-mobile=?0, host=localhost:8080, upgrade-insecure-requests=1, connection=keep-alive, cache-control=max-age=0, accept-encoding=gzip, deflate, br, user-agent=Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36, sec-fetch-dest=document}--%&gt; ${header}&lt;br&gt; &lt;hr&gt;&lt;%-- {sec-fetch-mode=[Ljava.lang.String;@202f1058, sec-fetch-site=[Ljava.lang.String;@49b7b0c5, accept-language=[Ljava.lang.String;@66149d54, cookie=[Ljava.lang.String;@337032dd, sec-fetch-user=[Ljava.lang.String;@6b85493b, accept=[Ljava.lang.String;@1f40ed16, sec-ch-ua=[Ljava.lang.String;@5dfc3d97, sec-ch-ua-mobile=[Ljava.lang.String;@6fa81a2f, host=[Ljava.lang.String;@2e254a70, upgrade-insecure-requests=[Ljava.lang.String;@36953aff, connection=[Ljava.lang.String;@ab9b93f, cache-control=[Ljava.lang.String;@25efb325, accept-encoding=[Ljava.lang.String;@219d1b22, user-agent=[Ljava.lang.String;@3ec08f2c, sec-fetch-dest=[Ljava.lang.String;@79f7a98a}--%&gt; ${headerValues}&lt;br&gt; &lt;hr&gt; &lt;%--特殊字符需要中括号[]和引号（单双都可）--%&gt; 输出请求头中的User-Agent：${header.User-Agent}&lt;br&gt; &lt;%--0--%&gt; &lt;%-- 输出请求头中的User-Agent：Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36 --%&gt; 输出请求头中的User-Agent：${header[\"User-Agent\"]}&lt;br&gt; 输出请求头中的Connection：${header[\"Connection\"]}&lt;br&gt; 输出请求头中的Connection：${header.Connection}&lt;br&gt; 使用headerValues输出请求头中的User-Agent：${headerValues[\"User-Agent\"][0]}&lt;br&gt; ¶5.5、cookie对象的使用 cookie：它可以获取当前请求的 Cookie 信息 123456789101112131415&lt;%-- 下方运行结果： {goSessionid=jakarta.servlet.http.Cookie@5d54917d, Idea-898f7731=jakarta.servlet.http.Cookie@66a38548, Webstorm-e01d478=jakarta.servlet.http.Cookie@4e123a21, Idea-898f7733=jakarta.servlet.http.Cookie@59f25158, JSESSIONID=jakarta.servlet.http.Cookie@20d4ec62, Webstorm-9f808640=jakarta.servlet.http.Cookie@5a27a4f5} jakarta.servlet.http.Cookie@91228a5 获取cookie的名称：JSESSIONID 获取cookie的值：0AF4F9558A6A7BD88594920E5999E181--%&gt; ${cookie}&lt;br&gt; ${cookie.JSESSIONID}&lt;br&gt; &lt;%--调用cookie的getName()方法--%&gt; 获取cookie的名称：${cookie.JSESSIONID.name}&lt;br&gt; &lt;%--调用cookie的getValue()方法--%&gt; 获取cookie的值：${cookie.JSESSIONID.value}&lt;br&gt; ¶5.6、initParam对象使用 initParam：它可以获取在 web.xml 中配置的&lt;context-param&gt;上下文参数 web.xml： 12345678&lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;itnxd&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;89898989&lt;/param-value&gt;&lt;/context-param&gt; 使用initParam获取参数： 1234567891011&lt;%-- 处理域数据！ 输出结果： {password=89898989, username=itnxd} 输出&lt;context-param&gt;中username的值为：itnxd 输出&lt;context-param&gt;中password的值为：89898989--%&gt; ${initParam}&lt;br&gt; 输出&amp;lt;context-param&amp;gt;中username的值为：${initParam.username}&lt;br&gt; 输出&amp;lt;context-param&amp;gt;中password的值为：${initParam.password}&lt;br&gt; ¶二、JSTL标签库 ¶1、JSTL概述 JSTL 标签库 全称是指 JSP Standard Tag Library JSP标准标签库。是一个不断完善的开放源代码的 JSP 标签库。 EL 表达式主要是为了替换 jsp 中的表达式脚本，而标签库则是为了替换代码脚本。这样使得整个 jsp 页面变得更佳简洁。 分类，五个不同标签库： 目前只使用第一个核心库！ ¶2、JSTL配置 由于没有使用Mavent会有一堆版本问题！ 先去下方stackoverflow查看各个版本的解决方案！ Tomcat10安装JSTL非Maven用户可用：stackoverflow的解决方案，点击这里! 两个包下载地址： jakarta.servlet.jsp.jstl：https://repo.maven.apache.org/maven2/jakarta/servlet/jsp/jstl/jakarta.servlet.jsp.jstl-api/ jakarta.servlet.jsp.jstl-api：https://repo.maven.apache.org/maven2/jakarta/servlet/jsp/jstl/jakarta.servlet.jsp.jstl-api/ 在 jsp 标签库中使用 taglib 指令引入标签库： 123456789CORE 标签库：&lt;%@ taglib prefix=“c” uri=“http://java.sun.com/jsp/jstl/core” %&gt;XML 标签库：&lt;%@ taglib prefix=“x” uri=“http://java.sun.com/jsp/jstl/xml” %&gt;FMT 标签库：&lt;%@ taglib prefix=“fmt” uri=“http://java.sun.com/jsp/jstl/fmt” %&gt;SQL 标签库：&lt;%@ taglib prefix=“sql” uri=“http://java.sun.com/jsp/jstl/sql” %&gt;FUNCTIONS 标签库：&lt;%@ taglib prefix=“fn” uri=“http://java.sun.com/jsp/jstl/functions” %&gt; ¶3、JSTL核心库 ¶2.1、set（使用很少） 作用：set 标签可以往域中保存数据 格式：域对象.setAttribute(key,value) scope 属性设置保存到哪个域： page：表示 PageContext 域（默认值） request：表示 Request 域 session：表示 Session 域 application：表示 ServletContext 域 var 属性设置 key value 属性设置 value 123保存之前：${pageScope.key1}&lt;br&gt;&lt;c:set scope=\"page\" var=\"key1\" value=\"value1\"/&gt;保存之后：${pageScope.key1}&lt;br&gt; ¶2.2、if if 标签用来做 if 判断。 test 属性表示判断的条件（使用 EL 表达式输出） 123456&lt;c:if test=\"${12 == 12}\"&gt; &lt;h1&gt;12等于12&lt;/h1&gt;&lt;/c:if&gt;&lt;c:if test=\"${12 != 12}\"&gt; &lt;h1&gt;12不等于12&lt;/h1&gt;&lt;/c:if&gt; ¶2.2、choose、when、otherwise 作用：多路判断。类似switch ... case .... default choose：标签开始选择判断 when：标签表示每一种判断情况（无需switch的break操作） test：属性表示当前这种判断情况的值（一般使用EL表达式） otherwise：标签表示剩下的情况 注意的点： 标签里不能使用 html 注释，要使用 jsp 注释 when 标签的父标签一定要是 choose 标签 123456789101112131415161718192021222324252627282930313233 &lt;%request.setAttribute(\"height\", 180);%&gt;&lt;c:choose&gt; &lt;%--&lt;!-- 这是 html 注释, 会报错 --&gt;--%&gt; &lt;%--jsp注释才可以！--%&gt; &lt;c:when test=\"${ requestScope.height &gt; 190 }\"&gt; &lt;h2&gt;小巨人&lt;/h2&gt; &lt;/c:when&gt; &lt;c:when test=\"${ requestScope.height &gt; 180 }\"&gt; &lt;h2&gt;很高&lt;/h2&gt; &lt;/c:when&gt; &lt;c:when test=\"${ requestScope.height &gt; 170 }\"&gt; &lt;h2&gt;还可以&lt;/h2&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;%--套娃一定要加&lt;c:choose&gt;标签！--%&gt; &lt;c:choose&gt; &lt;c:when test=\"${requestScope.height &gt; 160}\"&gt; &lt;h3&gt;大于 160&lt;/h3&gt; &lt;/c:when&gt; &lt;c:when test=\"${requestScope.height &gt; 150}\"&gt; &lt;h3&gt;大于 150&lt;/h3&gt; &lt;/c:when&gt; &lt;c:when test=\"${requestScope.height &gt; 140}\"&gt; &lt;h3&gt;大于 140&lt;/h3&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; 其他小于 140 &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; ¶2.4、forEach 用于遍历！ begin：属性设置开始的索引 end：属性设置结束的索引 var：属性表示循环的变量(也是当前正在遍历到的数据) items：表示遍历的数据源（遍历的集合） step：属性表示遍历的步长值 varStatus：属性表示当前遍历到的数据的状态 varStatus的常用方法： 同样无需get和is，自动去找对应的get和is方法！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;%--简单遍历--%&gt;&lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;c:forEach begin=\"1\" end=\"10\" var=\"i\"&gt; &lt;tr&gt; &lt;td&gt;第${i}行&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;%--遍历数组--%&gt;&lt;% request.setAttribute(\"arr\", new String[]{\"11\", \"22\", \"33\"});%&gt;&lt;c:forEach items=\"${requestScope.arr}\" var=\"item\"&gt; ${item}&lt;br&gt;&lt;/c:forEach&gt;&lt;%--遍历集合--%&gt;&lt;% Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(\"AA\", 11); hashMap.put(\"BB\", 22); hashMap.put(\"CC\", 33); // for ( Map.Entry&lt;String,Integer&gt; entry : hashMap.entrySet()) {} request.setAttribute(\"map\", hashMap);%&gt;&lt;c:forEach items=\"${requestScope.map}\" var=\"entry\"&gt; &lt;h1&gt;${entry}&lt;h1/&gt; &lt;%--这里调用的仍是对应的get方法！--%&gt; &lt;h3&gt;key = ${entry.key}，value = ${entry.value}&lt;/h3&gt;&lt;/c:forEach&gt; &lt;%--遍历List--%&gt;&lt;% List&lt;Student&gt; stu = new ArrayList&lt;&gt;(); for(int i = 1; i &lt;= 10; i++) { stu.add(new Student(i, \"name\" + i, \"pwd\" + i, 18 + i, \"phone\" + i)); } request.setAttribute(\"stu\", stu);%&gt;&lt;table border=\"1\" cellspacing=\"0\" width=\"600\"&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;密码&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;电话&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;tr&gt; &lt;c:forEach begin=\"2\" end=\"9\" step=\"2\" varStatus=\"status\" items=\"${requestScope.stu}\" var=\"stu\"&gt; &lt;tr&gt; &lt;td&gt;${stu.id}&lt;/td&gt; &lt;td&gt;${stu.username}&lt;/td&gt; &lt;td&gt;${stu.password}&lt;/td&gt; &lt;td&gt;${stu.age}&lt;/td&gt; &lt;td&gt;${stu.phone}&lt;/td&gt; &lt;td&gt;${status}&lt;/td&gt; &lt;%-- varStatus的常用方法使用： &lt;td&gt;${status.current}&lt;/td&gt; &lt;td&gt;${status.index}&lt;/td&gt; &lt;td&gt;${status.count}&lt;/td&gt; &lt;td&gt;${status.firsh}&lt;/td&gt; &lt;td&gt;${status.last}&lt;/td&gt; &lt;td&gt;${status.begin}&lt;/td&gt; &lt;td&gt;${status.end}&lt;/td&gt; &lt;td&gt;${status.step}&lt;/td&gt; --%&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://www.itnxd.cn/categories/JavaWeb/"}],"tags":[{"name":"EL","slug":"EL","permalink":"https://www.itnxd.cn/tags/EL/"},{"name":"JSTL","slug":"JSTL","permalink":"https://www.itnxd.cn/tags/JSTL/"}],"author":"ITNXD"},{"title":"JavaWeb之JSP使用总结","slug":"JavaWeb之JSP使用总结","date":"2021-03-11T04:03:57.000Z","updated":"2021-03-11T09:12:54.353Z","comments":true,"path":"posts/31659.html","link":"","permalink":"https://www.itnxd.cn/posts/31659.html","excerpt":"","text":"¶一、JSP概述 JSP 的全称是 java server pages。Java 的服务器页面。JSP 的主要作用是代替 Servlet 程序回传 html 页面的数据。 因为 Servlet 程序回传 html 页面数据是一件非常繁锁的事情。开发成本和维护成本都极高。 ¶1、举例证明繁琐 这是使用Servlet程序使用字符流写到HTML页面的内容： 12345678910111213141516171819public class PrintHtml extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\"text/html; charset=utf-8\"); PrintWriter writer = resp.getWriter(); writer.write(\"&lt;!DOCTYPE html&gt;\\r\\n\"); writer.write(\"&lt;html lang=\\\"en\\\"&gt;\\r\\n\"); writer.write(\"&lt;head&gt;\\r\\n\"); writer.write(\" &lt;meta charset=\\\"UTF-8\\\"&gt;\\r\\n\"); writer.write(\" &lt;title&gt;Title&lt;/title&gt;\\r\\n\"); writer.write(\"&lt;/head&gt;\\r\\n\"); writer.write(\" 这是Servlet程序写的HTML页面内容！\\r\\n\"); writer.write(\"&lt;/body&gt;\\r\\n\"); writer.write(\"&lt;/html&gt;\\r\\n\"); }} 这是使用JSP程序使用字符流写到HTML页面的内容： 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 这是 html 页面数据&lt;/body&gt;&lt;/html&gt; ¶2、如何访问 同Servlet和Html程序访问一样，都是映射到了web目录！例如：http://loscalhost:8080/工程名/xxx.jsp ¶3、JSP本质 JSP 页面本质上是一个 Servlet 程序。 当我们第一次访问 JSP 页面的时候。Tomcat 服务器会帮我们把 JSP 页面翻译成为一个 java 源文件。并且对它进行编译成为.class 字节码程序。 被翻译为servlet程序的代码存放位置： ​ C:\\Users\\15890\\AppData\\Local\\JetBrains\\IntelliJIdea2020.3\\tomcat\\af55c368-5e26-45a9-8ee3-43963b4a4710\\work\\Catalina\\localhost\\10_Jsp\\org\\apache\\jsp 可以在IDEA启动服务的时候的日志中看到！ 打开翻译的Java源文件可以看到他继承自HttpServlet类： 首先继承org.apache.jasper.runtime.HttpJspBase 其次HttpJspBase继承Httpservlet 在翻译的源代码中public void _jspService(......)会看到他也是将整个内容用字符流的write方法写入到页面！ ¶二、三种语法 ¶1、JSP头部的page指令 jsp 的 page 指令可以修改 jsp 页面中一些重要的属性，或者行为。 123&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" errorPage=\"/error.jsp\"%&gt; language 属性： 表示 jsp 翻译后是什么语言文件。暂时只支持 java。 contentType 属性： 表示 jsp 返回的数据类型是什么。也是源码中 response.setContentType()参数值 pageEncoding 属性： 表示当前 jsp 页面文件本身的字符集。 import 属性： 跟 java 源代码中一样。用于导包，导类。 autoFlush 属性： 设置当 out 输出流缓冲区满了之后，是否自动刷新冲级区。默认值是 true。 buffer 属性： 设置 out 缓冲区的大小。默认是 8kb errorPage 属性： 设置当 jsp 页面运行时出错，自动跳转去的错误页面路径。（斜杠打头，映射到web目录） isErrorPage 属性： 设置当前 jsp 页面是否是错误信息页面。默认是 false。如果是 true 可以获取异常信息。 session 属性： 设置访问当前 jsp 页面，是否会创建 HttpSession 对象。默认是 true。 extends 属性： 设置 jsp 翻译出来的 java 类默认继承谁。 ¶2、JSP中的常用脚本 ¶2.1、声明脚本（极少用） 格式：&lt;%! 声明 java 代码 %&gt; 该内容会被直接翻译（原封不动）到源代码！ 声明类属性 声明 static 静态代码块 声明类方法 声明内部类 12345678910111213141516171819202122232425&lt;%! private Integer id; private String name; private static Map&lt;String, Integer&gt; map;%&gt;&lt;%! static { map = new HashMap&lt;String, Integer&gt;(); map.put(\"aa\", 1); }%&gt;&lt;%! public void show(){ System.out.println(\"hhh\"); }%&gt;&lt;%! public static class A{ private int id; }%&gt; ¶2.2、表达式脚本（常用） 格式：&lt;%=表达式%&gt; 表达式脚本的作用是：在 jsp 页面上输出数据。 表达式脚本的特点： 所有的表达式脚本都会被翻译到_jspService() 方法中_ 表达式脚本都会被翻译成为 out.print()输出到页面上 由于表达式脚本翻译的内容都在_jspService() 方法中,所以_jspService()方法中的对象都可以直接使用。 表达式脚本中的表达式不能以分号结束。 12345&lt;%=12%&gt; &lt;br&gt;&lt;%=12.3%&gt; &lt;br&gt;&lt;%=\"我是字符串\"%&gt; &lt;br&gt;&lt;%=map%&gt; &lt;br&gt;&lt;%=request.getParameter(\"username\")%&gt; &lt;br&gt; ¶2.3、代码脚本 格式：&lt;% java语句 %&gt; 代码脚本的作用：可以在 jsp 页面中，编写我们自己需要的功能（写的是 java 语句）。 代码脚本的特点： 代码脚本翻译之后都在_jspService() 方法中 代码脚本由于翻译到_jspService()方法中，所以在_jspService()方法中的现有对象都可以直接使用。 还可以由多个代码脚本块组合完成一个完整的 java 语句。 代码脚本还可以和表达式脚本一起组合使用，在 jsp 页面上输出数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;% if(true) System.out.println(\"哈哈哈\"); %&gt; &lt;% for (int i = 0; i &lt; 10; i++) { System.out.println(i); } %&gt; &lt;% System.out.println(request.getParameter(\"username\")); %&gt;&lt;%-- 拆分也可以，全部都是直接移动到源文件中！ --%&gt; &lt;% for (int i = 0; i &lt; 10; i++) { %&gt; &lt;%=i%&gt; &lt;br&gt; &lt;% System.out.println(\"hhh\"); } %&gt; &lt;table border=\"1px\" cellspacing=\"0\"&gt; &lt;% for (int i = 0; i &lt; 10; i++) { %&gt; &lt;tr&gt; &lt;td&gt; 第&lt;%=i%&gt;行 &lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt; &lt;/table&gt; &lt;% if(true){ %&gt; &lt;h1&gt;你好帅！&lt;/h1&gt; &lt;% } %&gt; ¶3、JSP中的三种注释 Html注释：Html 注释会被翻译到 java 源代码中。在_jspService 方法里，以 out.writer 输出到客户端。浏览器自动识别为注释，不会输出！ Java注释：java 注释会被翻译到 java 源代码中。 JSP注释：jsp 注释可以注掉 jsp 页面中所有代码。 123456789101112131415161718&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--这是html注释，网页右键查看源代码会看到！--&gt; &lt;% // java单行注释 /*java多行注释*/ %&gt; &lt;%-- JSP注释，可注释一切jsp页面代码 --%&gt;&lt;/body&gt;&lt;/html&gt; ¶三、九大内置对象 jsp 中的内置对象，是指 Tomcat 在翻译 jsp 页面成为 Servlet 源代码后，内部提供的九大对象，叫内置对象！ request：请求对象 response：响应对象 pageContext：JSP的上下文对象 session：会话对象 application：ServletContext对象 config：ServletConfig对象 out：JSP输出流对象 page：指向当前JSP的对象 exception：异常对象 ¶四、四大域对象 ¶1、四大域对象 pageContext (PageContextImpl 类)：当前 jsp 页面范围内有效 request (HttpServletRequest 类)：一次请求内有效 session (HttpSession 类)：一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器） application (ServletContext 类)：整个 web 工程范围内都有效（只要 web 工程不停止，数据都在） 注意：从上到下作用域依次增大！ ¶2、作用域 域对象是可以像 Map 一样存取数据的对象。四个域对象功能一样。不同的是它们对数据的存取范围。 虽然四个域对象都可以存取数据。在使用上它们是有优先顺序的。 四个域在使用的时候，优先顺序分别是，他们从小到大的范围的顺序。 pageContext ====&gt;&gt;&gt; request ====&gt;&gt;&gt; session ====&gt;&gt;&gt; application 两个文件是为了使用请求转发模拟一次请求！ scope.jsp： 1234567891011121314151617181920212223242526272829&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" errorPage=\"error.jsp\"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jsp 四大域对象作用范围&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;scope.jsp 页面&lt;/h1&gt; &lt;% // 往四个域中都分别保存了数据 pageContext.setAttribute(\"key\", \"pageContext\"); request.setAttribute(\"key\", \"request\"); session.setAttribute(\"key\", \"session\"); application.setAttribute(\"key\", \"application\"); %&gt; pageContext 域是否有值：&lt;%=pageContext.getAttribute(\"key\")%&gt; &lt;br&gt; request 域是否有值：&lt;%=request.getAttribute(\"key\")%&gt; &lt;br&gt; session 域是否有值：&lt;%=session.getAttribute(\"key\")%&gt; &lt;br&gt; application 域是否有值：&lt;%=application.getAttribute(\"key\")%&gt; &lt;br&gt; &lt;% request.getRequestDispatcher(\"/scope2.jsp\").forward(request,response); %&gt;&lt;/body&gt;&lt;/html&gt; scope2.jsp： 12345678910111213141516&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;scope2.jsp 页面&lt;/h1&gt; pageContext 域是否有值：&lt;%=pageContext.getAttribute(\"key\")%&gt; &lt;br&gt; request 域是否有值：&lt;%=request.getAttribute(\"key\")%&gt; &lt;br&gt; session 域是否有值：&lt;%=session.getAttribute(\"key\")%&gt; &lt;br&gt; application 域是否有值：&lt;%=application.getAttribute(\"key\")%&gt; &lt;br&gt;&lt;/body&gt;&lt;/html&gt; ¶3、解决Tomcat10.x版本问题 一个大bug，新版本Tomcat10.x安装目录下的lib包，没有pageContext类，导入包后无法使用！ 需要导入旧版本的包！ 旧版本包在tomcat10无法运行servlet，新版本包没有pageContext类！ 新旧版本一起导入！。。。。最终解决问题！ 猜想应该是版本不一样导致的，后面使用Maven来解决该问题！ Servlet程序使用新包jakarta 四大域对象就看他从哪里能找到包了，找到谁用谁… ¶五、out与response.getWriter输出区别 ¶1、out.write与out.print out.write()：输出字符串没有问题 out.print()：输出任意数据都没有问题**（都转换成为字符串后调用的 write 输出）** 123456789&lt;% out.write(\"1&lt;br&gt;\"); // 1 out.write(1); // 1对应的ASCII码字符 out.write(\"&lt;br&gt;\"); out.print(12); // 12 out.print(\"12\"); // 12 response.getWriter().write(12345); // 12345%&gt; ¶2、相同点 response 中表示响应，我们经常用于设置返回给客户端的内容（输出） out 也是给客户端做输出使用的。 ¶3、不同点 先执行out.flush刷新缓冲区追加到response缓冲区尾 再执行response刷新缓存区，将全部数据写入客户端 ¶4、使用建议 由于 jsp 翻译之后，底层源代码都是使用 out 来进行输出，所以一般情况下。我们在 jsp 页面中统一使用 out 来进行输出。避免打乱页面输出内容的顺序。 在 jsp 页面中，可以统一使用 **out.print()**来进行输出. ¶六、常用标签 ¶1、静态包含 格式：&lt;%@ include file=\"\"%&gt; file 属性指定你要包含的 jsp 页面的路径 地址中第一个斜杠 / 表示为 http://ip:port/工程路径/ 映射到代码的 web 目录 静态包含的特点： 静态包含不会翻译被包含的 jsp 页面。 静态包含其实是把被包含的 jsp 页面的代码拷贝到包含的位置执行输出。 用途： 可重复利用的内容，例如：网站导航，菜单，轮播广告，页脚等等！ 12345&lt;body&gt; 头部内容&lt;br&gt; 主题内容&lt;br&gt; &lt;%@ include file=\"/include/footer.jsp\"%&gt;&lt;/body&gt; footer.jsp： 12345&lt;body&gt; 页脚信息&lt;/body&gt; ¶2、动态包含 格式： &lt;jsp:include page=\"\"&gt;&lt;/jsp:include&gt; page 属性是指定你要包含的 jsp 页面的路径 动态包含也可以像静态包含一样。把被包含的内容执行输出到包含位置 动态包含的特点： 动态包含会把包含的 jsp 页面也翻译成为 java 代码 动态包含底层代码使用如下代码去调用被包含的 jsp 页面执行输出。JspRuntimeLibrary.include(request, response, \"/include/footer.jsp\", out, false); 动态包含，还可以传递参数 动态包含底层原理： 动态包含举例： 12345678910&lt;body&gt; 头部内容&lt;br&gt; 主题内容&lt;br&gt; &lt;jsp:include page=\"/include/footer.jsp\"&gt; &lt;jsp:param name=\"username\" value=\"itnxd\"/&gt; &lt;jsp:param name=\"password\" value=\"6666\"/&gt; &lt;/jsp:include&gt;&lt;/body&gt; footer.jsp： 12345678&lt;body&gt; 页脚信息 &lt;%--动态包含获取属性参数信息！--%&gt; 用户名为：&lt;%=request.getParameter(\"username\")%&gt; &lt;br&gt; 密码为：&lt;%=request.getParameter(\"password\")%&gt;&lt;/body&gt; ¶3、标签转发 使用JSP标签实现的请求转发功能！ 格式：&lt;jsp:forward page=\"\"&gt;&lt;/jsp:forward&gt; page 属性设置请求转发的路径 使用： 1&lt;jsp:forward page=\"/scope2.jsp\"&gt;&lt;/jsp:forward&gt; 与以下方法作用一致： 123&lt;% request.getRequestDispatcher(\"/scope2.jsp\").forward(request,response);%&gt; ¶七、Listener监听器 ¶1、概述 Listener 监听器它是 JavaWeb 的三大组件之一。JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监听器。 Listener 它是 JavaEE 的规范，就是接口 监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。 ¶2、ServletContextListener 监听器 ServletContextListener 它可以监听 ServletContext 对象的创建和销毁。 ServletContext 对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁。 监听到创建和销毁之后都会分别调用 ServletContextListener 监听器的方法反馈。 使用步骤： 编写一个类去实现 ServletContextListener 实现其两个回调方法 到 web.xml 中去配置监听器 12345678910111213141516171819public class MyServletContextListener implements ServletContextListener { /** * 在 ServletContext 对象创建之后马上调用，做初始化 * @param sce */ @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(\"ServletContextListener创建了！\"); } /** * 在 ServletContext 对象销毁之后调用 * @param sce */ @Override public void contextDestroyed(ServletContextEvent sce) { System.out.println(\"ServletContextListener被销毁了！\"); }} web.xml配置： 123&lt;listener&gt; &lt;listener-class&gt;com.atguigu.listener.MyServletContextListener&lt;/listener-class&gt;&lt;/listener&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://www.itnxd.cn/categories/JavaWeb/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://www.itnxd.cn/tags/JSP/"},{"name":"Listener","slug":"Listener","permalink":"https://www.itnxd.cn/tags/Listener/"}],"author":"ITNXD"},{"title":"JavaWeb之Servlet使用总结","slug":"JavaWeb之Servlet使用总结","date":"2021-03-08T12:03:24.000Z","updated":"2021-03-09T07:13:22.618Z","comments":true,"path":"posts/58740.html","link":"","permalink":"https://www.itnxd.cn/posts/58740.html","excerpt":"","text":"¶一、Servlet介绍 Servlet 是 JavaEE 规范之一。规范就是接口！ Servlet 就 JavaWeb 三大组件之一。三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监听器。 Servlet 是运行在服务器上的一个 java 小程序，它可以接收客户端发送过来的请求，并响应数据给客户端。 ¶二、Servlet程序创建 ¶1、通过实现Servlet接口创建Servlet程序 ¶1.1、创建步骤 创建Web工程方式，点击这里！ 编写一个类去实现 Servlet 接口 实现 service 方法，处理请求，并响应数据 到 web.xml 中去配置 servlet 程序的访问地址 ¶1.2、Servlet创建 注意：需要导入servlet的jar包，直接去Tomcat安装目录下的lib目录找到servlet-api.jar复制到当前lib目录并Add as Library即可！ 包名略有不同： 旧版本包名为为javax.servlet.xxx 新版本包名为jakarta.servlet.xxx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class HelloServlet implements Servlet { public HelloServlet(){ System.out.println(\"1. 构造器方法\"); } @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\"2. 初始化方法\"); } @Override public ServletConfig getServletConfig() { return null; } /** *service方法专门用来处理请求和响应！ * * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"3. service方法 ---- HelloServlet被执行了！\"); } /** * 处理Get请求！ */ public void doGet(){ System.out.println(\"Get请求\"); } /** * 处理Post请求！ */ public void doPost(){ System.out.println(\"Post请求\"); } @Override public String getServletInfo() { return null; } @Override public void destroy() { System.out.println(\"4. destroy销毁方法\"); }} ¶1.3、配置XML servlet和servlet-mapping标签共同配置一个Servlet程序，一个程序一组配置！ 注意：Servlet程序的访问地址区分大小写！ 创建servlet标签：表示配置一个Servlet程序 创建servlet-name标签：给Servlet程序起别名（一般为类名） 创建servlet-class标签：Servlet程序的全类名 创建servlet-mapping标签：为Servlet程序配置访问地址 创建servlet-name标签：指明访问地址的配置对象（一般为类名） 创建url-pattern标签：访问地址，以/开始 注意：/表示 http://ip:port/工程名，全地址为http://ip:端口/工程名 + url-pattern信息 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!-- 一、servlet标签给Tomcat配置Servlet程序 --&gt; &lt;servlet&gt; &lt;!--servlet-name标签 Servlet程序起一个别名（一般是类名） --&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--servlet-class是Servlet程序的全类名--&gt; &lt;servlet-class&gt;com.atguigu.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--二、servlet-mapping标签给servlet程序配置访问地址--&gt; &lt;servlet-mapping&gt; &lt;!--servlet-name标签的作用是告诉服务器，当前配置的地址给哪个Servlet程序使用--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- url-pattern标签配置访问地址 访问地址为：http://localhost:8081/工程名/hello --&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; ¶1.4、运行Servlet程序 点击运行即可！ 注意点： 配置文件，web文件，java源文件更改需要重新部署Redeploy，除了java文件外似乎可以直接使用选项Update classes and resouces，但是似乎好多时候部署的项目都不会自动更新，建议直接使用Redeploy进行重新部署，可解决一切bug问题，当然重启服务器也可解决，但重启耗时属实费事耗时！ ¶1.5、Servlet的生命周期 构造器和初始化：第一次创建Servlet时调用 service方法：每次请求都会调用 destroy方法：web工程停止时调用 ¶1.6、URL地址访问Servlet过程 ¶1.7、GET和POST请求分发处理 将ServletRequest对象向下转型为HttpServletRequest来调用getMethod()方法获取method类型！ 1234567891011121314151617181920212223242526272829303132333435/** *service方法专门用来处理请求和响应！ * * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */@Overridepublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(\"3. service方法 ---- HelloServlet被执行了！\"); // 1. 向下转型调用getMethod()方法！ HttpServletRequest request = (HttpServletRequest) servletRequest; String method = request.getMethod(); if(\"GET\".equals(method)){ doGet(); }else{ doPost(); }}/** * 处理Get请求！ */public void doGet(){ System.out.println(\"Get请求\");}/** * 处理Post请求！ */public void doPost(){ System.out.println(\"Post请求\");} ¶2、通过继承HttpServlet创建Servlet程序（推荐） ¶2.1、创建步骤 一般在实际项目开发中，都是使用继承 HttpServlet 类的方式去实现 Servlet 程序。 编写一个类去继承 HttpServlet 类 根据业务需要重写 doGet 或 doPost 方法 到 web.xml 中的配置 Servlet 程序的访问地址 ¶2.2、Servlet创建 123456789101112131415161718192021222324252627public class HelloServlet2 extends HttpServlet { /** * HelloServlet2的doGet方法！ * * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"HelloServlet2的doGet方法调用！\"); } /** * HelloServlet2的doPost方法！ * * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"HelloServlet2的doPost方法调用！\"); }} ¶2.3、配置XML 略：同上一种方式！ ¶3、使用IDEA创建Servlet程序 注意：新版本IDEA并无此选项可直接创建Servlet程序！ ¶3.1、使IDEA支持直接创建Servlet的方法 找到当前web工程下的imi配置文件，例如：07_Servlet.iml 找到如下位置添加如下信息即可！ 无需重启即可生效，若无法生效，可重启尝试 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;module type=\"JAVA_MODULE\" version=\"4\"&gt; &lt;component name=\"FacetManager\"&gt; &lt;facet type=\"web\" name=\"Web\"&gt; &lt;configuration&gt; &lt;descriptors&gt; &lt;deploymentDescriptor name=\"web.xml\" url=\"file://$MODULE_DIR$/web/WEB-INF/web.xml\" /&gt; &lt;/descriptors&gt; &lt;webroots&gt; &lt;root url=\"file://$MODULE_DIR$/web\" relative=\"/\" /&gt; &lt;/webroots&gt; 在这里添加如下内容： ------------------------------------------------------ &lt;sourceRoots&gt; &lt;root url=\"file://$MODULE_DIR$/src\" /&gt; &lt;/sourceRoots&gt; ----------------------------------------------------- &lt;/configuration&gt; &lt;/facet&gt; &lt;/component&gt; &lt;component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\"&gt; &lt;exclude-output /&gt; &lt;content url=\"file://$MODULE_DIR$\"&gt; &lt;sourceFolder url=\"file://$MODULE_DIR$/src\" isTestSource=\"false\" /&gt; &lt;/content&gt; &lt;orderEntry type=\"jdk\" jdkName=\"14\" jdkType=\"JavaSDK\" /&gt; &lt;orderEntry type=\"sourceFolder\" forTests=\"false\" /&gt; &lt;orderEntry type=\"module-library\"&gt; &lt;library&gt; &lt;CLASSES&gt; &lt;root url=\"jar://$MODULE_DIR$/web/WEB-INF/lib/servlet-api.jar!/\" /&gt; &lt;/CLASSES&gt; &lt;JAVADOC /&gt; &lt;SOURCES&gt; &lt;root url=\"jar://$MODULE_DIR$/../../../学习笔记/4、JavaWeb/apache-tomcat-10.0.2-src.zip!/apache-tomcat-10.0.2-src/java\" /&gt; &lt;/SOURCES&gt; &lt;/library&gt; &lt;/orderEntry&gt; &lt;/component&gt;&lt;/module&gt; 配置生效后，会在右键菜单出现创建选项，如下： ¶3.2、Servlet创建 通过IDEA创建Servlet特点： 自动生成两个重写方法doGet()、doPost()方法 自动生成一半XML配置文件servelt标签，servlet-mapping标签仍需手动配置 注意： 当前先以XML配置，后续再讲注解配置！先不要勾选如下配置！ 生成代码如下： 1234567891011public class HelloServlet3 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"HelloServlet3的doGet方法调用！\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"HelloServlet3的doPost方法调用！\"); }} ¶三、Servlet类继承体系 类继承体系如下： GenericServlet实现了三大接口：Servlet、ServletConfig、java.io.Serializable ¶四、ServletConfig类介绍 ¶1、概述 简单理解，局部变量，局部配置信息！ ServletConfig 类从类名上来看，就知道是 Servlet 程序的配置信息类。 Servlet 程序和 ServletConfig 对象都是由 Tomcat 负责创建，我们负责使用。 Servlet 程序默认是第一次访问的时候创建，ServletConfig 是每个 Servlet 程序创建时，就创建一个对应的 ServletConfig 对象。 ¶2、作用 可以获取 Servlet 程序的别名 servlet-name 的值 获取初始化参数 init-param 获取 ServletContext 对象 ¶3、配置XML 配置位置：servlet标签内部，局部配置，正常！ 初始化参数：是一组组键值对！可以多组！ 123456789101112131415161718192021222324252627&lt;!-- 一、servlet标签给Tomcat配置Servlet程序 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atguigu.servlet.HelloServlet&lt;/servlet-class&gt; &lt;!-----------------------------------------------------------------------------------------&gt; &lt;!--二、配置init-param初始化参数！--&gt; &lt;init-param&gt; &lt;!--参数名--&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;!--参数值--&gt; &lt;param-value&gt;xxx&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306/test&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-----------------------------------------------------------------------------------------&gt;&lt;/servlet&gt; ¶4、通过Java程序获取配置 当前ServletConfig对象只能获取当前Servlet程序的配置信息，无法获取其他人的信息！（局部配置只给自己用！） 关于获取servletConfig对象： 可以通过getServletConfig()方法获取servletConfig对象！ 在implements Servlet的类中，需要重写public ServletConfig getServletConfig() {}方法才可获取！ 在extends HttpServlet的类中，父类的父类GenericServlet有该类实现返回当前ServletConfig对象! **注意：**该方法需要在重写的init方法中显示调用父类的super.init(config)方法为ServletConfig对象赋值！否则将发生空指针异常！ 12345678910111213141516171819202122232425262728293031323334353637383940414243// implements Servlet的init方法：@Overridepublic void init(ServletConfig servletConfig) throws ServletException { System.out.println(\"2. 初始化方法\"); // 1、可以获取 Servlet 程序的别名 servlet-name 的值 System.out.println(\"HelloServlet程序的别名是：\" + servletConfig.getServletName()); // 2、获取初始化参数 init-param（写在&lt;servlet&gt;&lt;servlet/&gt;之中） System.out.println(\"初始化参数username的值是\" + servletConfig.getInitParameter(\"username\")); System.out.println(\"初始化参数password的值是\" + servletConfig.getInitParameter(\"password\")); System.out.println(\"初始化参数url的值是\" + servletConfig.getInitParameter(\"url\")); // 3、获取 ServletContext 对象 System.out.println(\"servletConfig对象为：\" + servletConfig.getServletContext()); // 可以通过getServletConfig()方法获取servletConfig对象！ // 在implements Servlet的类中，需要重写public ServletConfig getServletConfig() {}方法才可获取！ // 在extends HttpServlet的类中，父类的父类GenericServlet有该类实现返回当前ServletConfig对象! ServletConfig servletConfig1 = getServletConfig(); System.out.println(servletConfig1); // null}// extends HttpServlet的init方法：/** * 对init方法的重写： * 注意：一定要显示调用super.init()方法，将当前config对象赋值给父类实现覆盖！ * 否则会发生空指针异常！ * @param config * @throws ServletException */@Overridepublic void init(ServletConfig config) throws ServletException { // 调用父类init方法！ super.init(config); System.out.println(\"重写init初始化方法做了一些操作！\"); // 可以调用该方法获取当前servletConfig对象！该方法有GenericServlet父类实现！ System.out.println(getServletConfig());} ¶五、ServletContext类介绍 ¶1、概述 简单理解：就是针对整个web工程的全局配置，任何Servlet程序都可以访问！ ServletContext 是一个接口，它表示 Servlet 上下文对象 一个 web 工程，只有一个 ServletContext 对象实例。 ServletContext 对象是一个域对象。 ServletContext 是在 web 工程部署启动的时候创建。在 web 工程停止的时候销毁。 什么是域对象? 域对象，是可以像 Map 一样存取数据的对象，叫域对象。这里的域指的是存取数据的操作范围，整个 web 工程。 三个操作全局配置的方法： setAttribute() getAttribute() removeAttribute() ¶2、作用 获取 web.xml 中配置的上下文参数 context-param 获取当前的工程路径，格式: /工程路径 获取工程部署后在服务器硬盘上的绝对路径 像 Map 一样存取数据 ¶3、配置XML 配置位置：一般放到XML的最前面，表示是针对整个web工程的全局配置！ 是一组组键值对，可以由多组！ 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!------------------------------------------------------------------------&gt; &lt;!--context-param配置，是上下文参数，属于整个web工程！--&gt; &lt;context-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;itnxd&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;password123&lt;/param-value&gt; &lt;/context-param&gt; &lt;!------------------------------------------------------------------------&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atguigu.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; ¶4、通过Java程序处理配置 关于获取工程部署后在服务器硬盘上的绝对路径： /会被服务器解析为http://ip:port/工程名/，然后被映射到IDEA工程下的web目录 斜杠后面可以添加路径及文件名，该路径以web目录为根目录 启动部署后输出的第一行内容：Using CATALINA_BASE: \"C:\\Users\\15890\\AppData\\Local\\JetBrains\\IntelliJIdea2020.3\\tomcat\\a65c5dac-b285-42bc-bb15-73d8c6c7bf83\" 该路径为Tomcat服务器在C盘的一个针对IDEA的web项目的配置目录 该路径C:\\Users\\15890\\AppData\\Local\\JetBrains\\IntelliJIdea2020.3\\tomcat\\a65c5dac-b285-42bc-bb15-73d8c6c7bf83\\conf\\Catalina\\localhost下有一个07_Servlet.xml配置文件 内容为&lt;Context path=\"/07_Servlet\" docBase=\"E:\\Java学习\\IdeaProject\\JavaWeb\\out\\artifacts\\07_Servlet_war_exploded\" /&gt; 该路径就是对IDEA的web工程下web目录的一个映射 其实就是之前讲到的一种部署方式：通过Tomcat配置信息进行web项目映射！点击这里！ 12345678910111213141516171819202122232425262728293031public class ContextServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 获取ServletContext对象 ServletContext servletContext = getServletConfig().getServletContext(); // 2. 获取上下文参数 String username = servletContext.getInitParameter(\"username\"); String password = servletContext.getInitParameter(\"password\"); System.out.println(\"context-param参数username值：\" + username); System.out.println(\"context-param参数password值：\" + password); // 3. 获取工程路径 System.out.println(\"当前工程路径是：\" + servletContext.getContextPath()); // /07_Servlet // 4. 获取工程部署后在服务器硬盘上的绝对路径 System.out.println(\"工程部署的路径是：\" + servletContext.getRealPath(\"/\")); // E:\\Java学习\\IdeaProject\\JavaWeb\\out\\artifacts\\07_Servlet_war_exploded\\ System.out.println(\"工程下CSS的绝对路径是：\" + servletContext.getRealPath(\"/css\")); System.out.println(\"工程下CSS下1.css的路径是：\" + servletContext.getRealPath(\"/css/1.css\")); // 5. 像 Map一样存取数据 ContextServlet2.java中查看！ } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { }} 关于像Map一样存取数据： 配置作用时间：在 web 工程部署启动的时候创建。在 web 工程停止的时候销毁，所有由程序创建的属性会在重新部署或重启服务器后自动被销毁 作用域：针对整个web工程：所以其他Servlet程序也可以访问到这些属性，并且该servletContext对象地址唯一确定！ 123456789101112131415161718192021222324252627public class ContextServlet2 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 父类GenericServlet也实现了该方法，return getServletConfig().getServletContext(); ServletContext servletContext = getServletContext(); // 5. 像 Map一样存取数据 // 设置 servletContext.setAttribute(\"key1\", \"value1\"); servletContext.setAttribute(\"key2\", \"value2\"); // 获取 Object value1 = servletContext.getAttribute(\"key1\"); Object value2 = servletContext.getAttribute(\"key2\"); System.out.println(\"获取context-param中的域数据（全局数据）key1的值为：\" + value1); System.out.println(\"获取context-param中的域数据（全局数据）key2的值为：\" + value2); // 移除 servletContext.removeAttribute(\"key2\"); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { }} ¶六、HTTP 协议介绍 ¶1、概述 什么是协议? 协议是指双方，或多方，相互约定好，大家都需要遵守的规则，叫协议。 HTTP 协议? 就是指，客户端和服务器之间通信时，发送的数据，需要遵守的规则，叫 HTTP 协议。 HTTP 协议中的数据又叫报文。 多种请求方法： ¶2、请求HTTP协议格式 客户端给服务器发送数据叫请求。 服务器给客户端回传数据叫响应。 请求主要分为 GET 请求，和 POST 请求两种 ¶2.1、GET请求 GET请求组成： 请求行 请求的方式 GET 请求的资源路径 请求的协议的版本号 HTTP/1.1 请求头 key : value 组成不同的键值对，表示不同的含义。 如下图： 使用GET请求的情景： form 标签 method=get a 标签 link 标签引入 css Script 标签引入 js 文件 img 标签引入图片 iframe 引入 html 页面 在浏览器地址栏中输入地址后敲回车 ¶2.2、POST请求 POST请求组成： 请求行: 请求的方式 POST 请求的资源路径[+?+请求参数] 请求的协议的版本号 HTTP/1.1 请求头： key : value 不同的请求头，有不同的含义 空行 请求体：就是发送给服务器的数据 如下图： 使用POST请求的情景： form 标签 method=post ¶2.3、常用请求头 Accept: 表示客户端可以接收的数据类型 Accpet-Languege: 表示客户端可以接收的语言类型 User-Agent: 表示客户端浏览器的信息 Host： 表示请求时的服务器 ip 和端口号 ¶2.4、全部请求头一览表 ¶3、响应HTTP协议格式 ¶3.1、响应HTTP协议组成 响应行 响应的协议和版本号 响应状态码 响应状态描述符 响应头 key : value 不同的响应头，有其不同含义 空行 响应体：就是回传给客户端的数据 如下图： ¶3.2、常见响应码 200 表示请求成功 302 表示请求重定向 404 表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误） 500 表示服务器已经收到请求，但是服务器内部错误（代码错误） ¶3.3、全部响应头一览表 ¶4、MIME格式 MIME 是 HTTP 协议中数据类型。 MIME 的英文全称是\"Multipurpose Internet Mail Extensions\" 多功能 Internet 邮件扩充服务。MIME 类型的格式是“大类型/小类型”，并与某一种文件的扩展名相对应。 所谓MIME格式：就是请求头和响应头中content-type的值，表示数据类型！ 常见MIME类型： ¶七、HttpServletRequest类介绍 ¶1、概述 每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中。然后传递到 service 方法（doGet 和 doPost）中给我们使用。我们可以通过 HttpServletRequest 对象，获取到所有请求的信息。 ¶2、常用方法 ¶2.1、一般方法 getRequestURI() 获取请求的资源路径 getRequestURL() 获取请求的统一资源定位符（绝对路径） getRemoteHost() 获取客户端的 ip 地址 在 IDEA 中，使用 localhost 访问时，得到的客户端 ip 地址是 127.0.0.1，新版本中为：0:0:0:0:0:0:0:1 在 IDEA 中，使用 127.0.0.1 访问时，得到的客户端 ip 地址是 127.0.0.1 在 IDEA 中，使用 真实 ip 访问时，得到的客户端 ip 地址是真实的客户端 ip 地址 getHeader() 获取请求头 getMethod() 获取请求的方式 GET 或 POST 12345678910111213public class RequestAPIServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(req.getRequestURI()); System.out.println(req.getRequestURL()); System.out.println(req.getRemoteHost()); System.out.println(req.getHeader(\"User-Agent\")); System.out.println(req.getMethod()); }} ¶2.2、请求参数获取 getParameter() 获取请求的参数 getParameterValues() 获取请求的参数（多个值的时候使用） setAttribute(key, value) 设置域数据 getAttribute(key) 获取域数据 getRequestDispatcher() 获取请求转发对象 操作步骤： 发送请求：访问http://localhost:8080/08_Servlet/form.html勾选选项后点击提交按钮 接收并查看请求：IDEA控制台查看信息 12345678910111213141516171819202122&lt;!--form.html文件：--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"http://localhost:8080/08_Servlet/PatameterServlet\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type=\"password\" name=\"password\"/&gt;&lt;br/&gt; 兴&amp;nbsp;&amp;nbsp;&amp;nbsp;趣：&lt;input type=\"checkbox\" name=\"hobby\" value=\"C++\"&gt;C++ &lt;input type=\"checkbox\" name=\"hobby\" value=\"Java\"&gt;Java &lt;input type=\"checkbox\" name=\"hobby\" value=\"Python\"&gt;Python&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526public class PatameterServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); String[] hobbies = request.getParameterValues(\"hobby\"); System.out.println(\"用户名：\" + username); System.out.println(\"密 码：\" + password); System.out.println(\"爱 好：\" + Arrays.toString(hobbies)); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"------------doPost--------------\"); String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); String[] hobbies = request.getParameterValues(\"hobby\"); System.out.println(\"用户名：\" + username); System.out.println(\"密 码：\" + password); System.out.println(\"爱 好：\" + Arrays.toString(hobbies)); }} ¶3、乱码解决 ¶3.1、GET请求乱码 我目前没发生乱码，先进行一下记录！ 1234// 获取请求参数String username = req.getParameter(\"username\");//解决：先以 iso8859-1 进行编码，再以 utf-8 进行解码username = new String(username.getBytes(\"iso-8859-1\"), \"UTF-8\"); ¶3.2、POST请求乱码 在doPost最前方设置字符集解决乱码！ 注意：必须将该设置放到调用方法之前才会有效 1234567891011121314151617@Overrideprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置请求体的字符集为 UTF-8，从而解决 post 请求的中文乱码问题 // 注意：必须将该设置放到调用方法之前才会有效！ request.setCharacterEncoding(\"UTF-8\"); System.out.println(\"------------doPost--------------\"); String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); String[] hobbies = request.getParameterValues(\"hobby\"); System.out.println(\"用户名：\" + username); System.out.println(\"密 码：\" + password); System.out.println(\"爱 好：\" + Arrays.toString(hobbies));} ¶4、请求转发 ¶4.1、概述 请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发。 ¶4.2、请求转发特点 浏览器地址栏没有变化 他们是一次请求 他们共享Request域中的数据 可以转发到WEB-INF目录下**（直接无法访问，只有请求转发可以）** 不可以访问工程以外的资源 ¶4.3、请求转发示例 注意： 请求转发路径必须要以斜杠打头！/ 斜杠表示地址为：http://ip:port/工程名/ , 映射到 IDEA 代码的 web 目录 无法访问Web工程以外的资源，必须以斜杠开头！ 请求转发可以获取WEB-INF下的文件，具体见下方代码 使用requestDispatcher.forward(req, resp)方法转发到其他地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Servlet1代码：public class Servlet1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 获取请求参数，获取材料 Object username = req.getParameter(\"username\"); System.out.println(\"在Servlet1（柜台一）中查看参数（材料）：\" + username); // 2. 保存参数，材料盖章 req.setAttribute(\"key1\", \"柜台一的章\"); // 3. 获取请求转发路径，问路Servlet2怎么走 /* 请求转发必须要以斜杠打头，/ 斜杠表示地址为：http://ip:port/工程名/ , 映射到 IDEA 代码的 web 目录 */ RequestDispatcher requestDispatcher = req.getRequestDispatcher(\"/Servlet2\"); // 请求转发可以获取WEB-INF下的文件！ // RequestDispatcher requestDispatcher = req.getRequestDispatcher(\"/WEB-INF/a.html\"); // 无法访问Web工程以外的资源，必须一斜杠开头！ // 请求的资源[/08_Servlet/https://www.baidu.com/]不可用 // RequestDispatcher requestDispatcher = req.getRequestDispatcher(\"https://www.baidu.com/\"); // 4. 请求转发，走向Servlet2 requestDispatcher.forward(req, resp); }}// Servlet2代码：public class Servlet2 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 5. 获取请求参数，获取材料 Object username = req.getParameter(\"username\"); System.out.println(\"在Servlet1（柜台二）中查看参数（材料）：\" + username); // 6. 查看材料是否盖章 Object value1 = req.getAttribute(\"key1\"); System.out.println(\"柜台是否有章：\" + value1); // 7. 处理Servlet2自己业务 System.out.println(\"处理Servlet2自己业务\"); // 8. 一次请求转发完成，返回到客户端 System.out.println(\"一次请求转发完成，返回到客户端\"); }} ¶4.2、base标签使用 base标签可以设置当前页面中所有相对路径工作时，参照哪个路径来进行跳转！ 主要用来解决请求转发导致的浏览器地址栏不发生改变，而相对路径却是参考浏览器地址进行判断导致的地址回退错误问题！ 运行结果： 不使用请求转发，由于浏览器地址动态改变，并不会产生地址回退错误 使用请求转发（需要在index.html写入a标签的地址为当前Servlet程序，即ForwardC），由于浏览器地址不发生改变，地址回退参考地址是转发前的地址，而不是转发后的地址导致回退错误 使用base标签（在回退的c.html文件写入base标签的地址为当前c.html的绝对路径），相当于针对相对路径的参考路径写死了！ web目录下的index.html文件 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是web工程下的index.html文件！&lt;/p&gt; &lt;a href=\"a/b/c.html\"&gt;跳转到a/b/c.html文件！&lt;/a&gt; &lt;br/&gt; &lt;!-- 使用ForwardC类 --&gt; &lt;a href=\"http://localhost:8080/08_Servlet/ForwardC\"&gt;使用请求转发到：a/b/c.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; web下的a下的b下的c.html文件 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!-- base 标签设置页面相对路径工作时参照的地址 href 属性就是参数的地址值 base路径中的最后一个c.html可以省略！当然还是得保留最后一个斜杠表名为一个目录！ http://localhost:8080/08_Servlet/a/b/ 显示指明使用跳转时候的参照路径，防止使用请求转发导致地址栏地址的不改动造成参照地址错误，请求不到目标地址！ --&gt; &lt;base href=\"http://localhost:8080/08_Servlet/a/b/c.html\"&gt; &lt;/head&gt;&lt;body&gt; &lt;p&gt;这是web工程下的a下的b下的c.html文件&lt;/p&gt; &lt;a href=\"../../index.html\"&gt;跳转到首页index.html！&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; ForwardC的Servlet程序 1234567public class ForwardC extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"经过了ForwardC程序转发！\"); req.getRequestDispatcher(\"a/b/c.html\").forward(req, resp); }} ¶5、Web项目的路径与 / 含义 ¶5.1、相对路径与绝对路径 相对路径 . 表示当前目录 .. 表示上一级目录 资源名 表示当前目录/资源名 绝对路径：`http://ip:port/工程路径/资源路径 注意：在实际开发中，路径都使用绝对路径，而不简单的使用相对路径。 绝对路径 base标签 + 相对路径 ¶5.2、斜杠 / 含义 在 web 中 / 斜杠 是一种绝对路径。 / 斜杠 如果被浏览器解析，得到的地址是：http://ip:port/ / 斜杠 如果被服务器解析，得到的地址是：http://ip:port/工程路径 &lt;url-pattern&gt;/servlet1&lt;/url-pattern&gt; servletContext.getRealPath(“/”) request.getRequestDispatcher(“/”) 特殊情况： response.sendRediect(“/”)把斜杠发送给浏览器解析。得到 http://ip:port/ ¶八、HttpServletResponse类介绍 ¶1、概述 HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息，我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 对象来进行设置！ 简单来说： HttpServletRequest ：负责接收客户端请求 HttpServletResponse ：负责响应客户端请求 ¶2、两个输出流 getOutputStream()：字节流，常用于下载（传递二进制数据） getWriter()： 字符流，常用于回传字符串（常用） 注意：二者不可同时使用，否则报错！ ¶3、向客户端回传数据 使用字符流响应请求向浏览器发送数据！浏览器页面会有内容！ 123456789public class ResponseIOServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 举例：向客户端回传字符串数据！ PrintWriter writer = resp.getWriter(); writer.write(\"服务器响应的内容...\"); }} ¶4、响应乱码解决 解决方案一：先设置服务器字符集，再通过响应头设置浏览器字符集为UTF-8**（不推荐）** 解决方案二：使用setContentType(\"text/html; charset=UTF-8\")即可，可同时设置服务器，浏览器，响应头都为UTF-8**（推荐）** 注意：方案二一定要在获取流对象前调用才会生效！简单来说，设置字符集直接放到方法第一行即可！ 1234567891011121314151617181920public class ResponseIOServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 中文会发生乱码： // 服务器默认字符集为：ISO-8859-1 System.out.println(resp.getCharacterEncoding()); // 解决方案一： // 设置服务器字符集为UTF-8 resp.setCharacterEncoding(\"UTF-8\"); // 通过响应头设置浏览器字符集为UTF-8，默认为GBK resp.setHeader(\"Content-Type\", \"text/html; charset=UTF-8\"); // 解决方案二： // 它会同时设置服务器和客户端都使用 UTF-8 字符集，还设置了响应头 // 此方法一定要在获取流对象之前调用才有效 resp.setContentType(\"text/html; charset=UTF-8\"); }} ¶5、请求重定向 请求重定向：是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求重定向（因为之前的地址可能已经被废弃）。 ¶5.1、请求重定向图示 ¶5.2、请求重定向特点 浏览器地址栏会发生变化 两次请求 不共享Request域中数据（两次请求完全无关） 不能访问WEB-INF下的资源（只能使用请求转发访问） 可以访问工程外的资源 ¶5.3、重定向方案一（不推荐） 123456789public class Response1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 设置状态码为302 resp.setStatus(302); // 2. 设置响应头，说明新地址 resp.setHeader(\"Location\", \"http://localhost:8080/08_Servlet/Response2\"); }} ¶5.4、重定向方案二（推荐） 123456789public class Response1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 方案二：（推荐） resp.sendRedirect(\"http://localhost:8080/08_Servlet/Response2\"); // 也可以 resp.sendRedirect(\"https://www.baidu.com\"); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://www.itnxd.cn/categories/JavaWeb/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://www.itnxd.cn/tags/Servlet/"}],"author":"ITNXD"},{"title":"Tomcat服务器使用及IDEA整合Tomcat","slug":"Tomcat服务器使用及IDEA整合Tomcat","date":"2021-03-07T02:39:29.000Z","updated":"2021-03-07T10:01:04.912Z","comments":true,"path":"posts/61877.html","link":"","permalink":"https://www.itnxd.cn/posts/61877.html","excerpt":"","text":"¶一、Tomcat服务器使用 ¶1、常用web服务器 Tomcat：由 Apache 组织提供的一种 Web 服务器，提供对 jsp 和 Servlet 的支持。它是一种轻量级的 javaWeb 容器（服务器），也是当前应用最广的 JavaWeb 服务器（免费）。 Jboss：是一个遵从 JavaEE 规范的、开放源代码的、纯 Java 的 EJB 服务器，它支持所有的 JavaEE 规范（免费）。 GlassFish： 由 Oracle 公司开发的一款 JavaWeb 服务器，是一款强健的商业服务器，达到产品级质量（应用很少）。 Resin：是 CAUCHO 公司的产品，是一个非常流行的服务器，对 servlet 和 JSP 提供了良好的支持，性能也比较优良，resin 自身采用 JAVA 语言开发（收费，应用比较多）。 WebLogic：是 Oracle 公司的产品，是目前应用最广泛的 Web 服务器，支持 JavaEE 规范，而且不断的完善以适应新的开发要求，适合大型项目（收费，用的不多，适合大公司）。 ¶2、Tomcat与Servlet版本对应关系 ¶3、Tomcat安装目录介绍 bin 专门用来存放 Tomcat 服务器的可执行程序 conf 专门用来存放 Tocmat 服务器的配置文件 lib 专门用来存放 Tomcat 服务器的 jar 包 logs 专门用来存放 Tomcat 服务器运行时输出的日记信息 temp 专门用来存放 Tomcdat 运行时产生的临时数据 webapps 专门用来存放部署的 Web 工程。 work 是 Tomcat 工作时的目录，用来存放 Tomcat 运行时 jsp 翻译为 Servlet 的源码，和 Session 钝化的目录。 ¶4、Tomcat服务器启动 ¶3.1、启动 注意：启动若一闪而过，则为环境变量JAVA_HOME没有配置正确！ 命令行输入catalina run 双击安装目录下的startup.bat 经测试：Tomcat10.0版本启动与关闭可直接使用Configure Tomcat进行设置： ¶3.2、关闭 命令行输入catalina stop 双击安装目录下的shutdown.bat Dos窗口下直接ctrl + c ¶5、Tomcat端口修改 默认端口为8080，若需修改在安装目录下找到 conf 目录，找到 server.xml 配置文件，进行修改！ 注意： 修改配置信息后需要重启服务器生效！ ¶6、部署项目到Tomcat中 只需要把 web 工程的目录拷贝到 Tomcat 的 webapps 目录下即可。 找到 Tomcat 下的目录conf\\Catalina\\localhost\\ 下，创建配置文件xxx.xml： &lt;!-- Context 表示一个工程上下文 path 表示工程的访问路径:/abc docBase 表示你的工程目录在哪里 --&gt; &lt;Context path=\"/abc\" docBase=\"E:\\book\" /&gt; 注意：一定要保存为utf-8编码，当然你要是使用IDE当我没说！ 关于访问情况： 不加路径默认为ROOT根目录 不加路径后面的文件名，默认为index.html ¶二、IDEA整合Tomcat 本教程针对最新版IDEA，即2020.3版本，与旧版本略有不同！这里一并说明各版本差异！ ¶1、整合Tomcat IDEA由于过于智能，自动将Tomcat Home 和 Tomcat base directory配置好了！ 旧版本没有配置的手动选择Tomcat安装目录即可！ IDEA设置路径：File | Settings | Build, Execution, Deployment | Application Servers 点击绿色的+号进行添加Tomcat Server ¶2、IDEA创建动态Web工程 ¶2.1、创建普通Web工程 新建一个module，选择Java 在module上右键选择Add Framework Support... 然后选择Web Application，并勾选右边Create web.xml即可 工程目录结构如下： ¶2.2、创建Maven Web工程 新建一个module，选择Java Enterprise，选择Application server（默认已经选好），其余默认next即可！ 选择Libraries and Frameworks为Web Profile即可！点击next完成 注意：旧版本IDEA选择Web Application，点击Create web.xml即可！ 依次输入项目保存路径，包名，项目名称和版本号，点击finish即可！ ¶3、Web工程文件目录介绍 java目录：存放java源码 resources目录：存放配置文件 webapp目录：存放web资源，html js css等 WEB-INF目录：受服务器保护的目录，浏览器无法直接访问 web.xml文件：是整个动态web工程的配置部署描述文件，可以配置许多web工程的组件，Servlet、Filter、Listener、Session等 lib目录：为自己新建，存放用到的第三方库 ¶4、lib目录添加jar包 方式一：选中全部要使用jar包，右键Add as library即可 方式二：点击Project Structure的绿色+号，找到项目文件目录的lib目录选中需要用到的jar包，确认即可！可以创建一个名称例如：06_web，右键该库06_web选择Add to Modules，选择创建的web工程模块即可！ ¶5、Artifacts设置 Artifacts，它的作用是整合编译后的 java 文件，资源文件等，有不同的整合方式，比如war、jar、war exploded 等，对于 Module 而言，有了 Artifact 就可以部署到 web 容器中了。其中 war 和 war exploded 区别就是后者不压缩，开发时选后者便于看到修改文件后的效果。 要想使用Tomcat启动，必须配置好Artifacts设置！ **进入Project Structure设置：**选择需要部署的Module即可！ ¶6、IDEA中Tomcat配置修改 点击如下位置的Edit Configurations ...即可进入设置！ 修改Tomcat运行实例名称为Web工程名，一个工程一个实例，防止冲突 修改Tomcat端口号和JMX端口号，防止冲突 配置资源热部署，资源变动刷新即可发生改变，自动部署**（自然会更加占用内存）** 修改默认使用浏览器 修改工程访问路径 控制台输出乱码解决方案： 将Tomcat安装目录下的conf目录下的logging.properties文件中的编码方式UTF-8全部修改为GBK，重新部署即可！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://www.itnxd.cn/categories/JavaWeb/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://www.itnxd.cn/tags/Tomcat/"}],"author":"ITNXD"},{"title":"JavaWeb之jQuery使用总结","slug":"JavaWeb之JQuery使用总结","date":"2021-03-06T02:45:03.000Z","updated":"2021-03-06T12:53:26.816Z","comments":true,"path":"posts/13535.html","link":"","permalink":"https://www.itnxd.cn/posts/13535.html","excerpt":"","text":"由于jQuery内容、选择器等等异常之多，只能随用随查，我找到一个不错的在线查询手册，欢迎查看！ jQuery在线查询手册 ¶一、jQuery概述 ¶1、jQuery介绍 什么是 jQuery ? jQuery，顾名思义，也就是 JavaScript 和查询（Query），它就是辅助 JavaScript 开发的 js 类库。 jQuery 核心思想！！！ 它的核心思想是 write less,do more(写得更少,做得更多)，所以它实现了很多浏览器的兼容问题。 jQuery 流行程度 jQuery 现在已经成为最流行的 JavaScript 库，在世界前 10000 个访问最多的网站中，有超过 55%在使用jQuery。 jQuery 好处！！！ jQuery 是免费、开源的，jQuery 的语法设计可以使开发更加便捷，例如操作文档对象、选择 DOM 元素、制作动画效果、事件处理、使用 Ajax 以及其他功能 ¶2、jQuery的引入 方式一：本地引入 1&lt;script type=\"text/javascript\" src=\"../script/jquery-3.6.0.js\"&gt;&lt;/script&gt; 方式二：使用bootcdn BootCdn官网，点击这里！ CdnJs官网，点击这里！ 1234567&lt;!--BootCdn--&gt;&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;!--CdnJs--&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.js\" integrity=\"sha512-n/4gHW3atM3QqRcbCn6ewmpxcLAHGaDjpEBu4xZd47N0W2oQ+6q7oc3PXstrJYXcbNU1OHdQ1T7pAP+gi5Yu8g==\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js\" integrity=\"sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; ¶3、jQuery核心函数$ $ 是 jQuery 的核心函数，能完成 jQuery 的很多功能。$()就是调用$这个函数！ 注意：$(document).ready(function (){})是$(function(){})的全写形式！ 1234567891011121314151617181920212223// $()就是调用$这个函数$();// 1、传入参数为 [ 函数 ] 时：表示页面加载完成之后。相当于 window.onload = function(){}$(function (){ alert(\"相当于window.onload()\")});// 2、传入参数为 [ HTML 字符串 ] 时：会对我们创建这个 html 标签对象$(function (){ $(\"&lt;div&gt;div标签&lt;/div&gt;\").appendTo(\"body\");});// 3、传入参数为 [ 选择器字符串 ] 时：// $(“#id 属性值”); id 选择器，根据 id 查询标签对象// $(“标签名”); 标签名选择器，根据指定的标签名查询标签对象// $(“.class 属性值”); 类型选择器，可以根据 class 属性查询标签对象$(function (){ alert($(\"p\").length);});// 4、传入参数为 [ DOM 对象 ] 时：会把这个 dom 对象转换为 jQuery 对象$(function (){ let p = document.getElementsByTagName(\"p\"); alert(p) // [object HTMLCollection] alert($(p)); // [object Object]}); ¶4、jQuery对象和Dom对象区分 jQuery对象的本质：DOM对象数据 + 提供的一系列功能函数 jQuery 对象和 Dom 对象使用区别： jQuery 对象不能使用 DOM 对象的属性和方法 DOM 对象也不能使用 jQuery 对象的属性和方法 Dom 对象和 jQuery 对象互转： DOM 对象转化为 jQuery 对象：$( DOM对象 ) jQuery 对象转化为 DOM 对象：jQuery对象[下标] 注意： jQuery对象alert的结果是[object Object] DOM对象alert的结果是[object HTML标签名Element] 123456789101112131415// jQuery对象是对DOM对象的封装！$(function (){ let $btn = $(\"button\"); for (let i = 0; i &lt; $btn.length; i++) { alert($btn[i]); // [object HTMLCollection] }});// 互相转化$(function (){ let p = document.getElementsByTagName(\"p\"); alert(p) // [object HTMLCollection] alert($(p)); // [object Object] alert($(p)[0]) // [object HTMLParagraphElement]}); ¶二、jQuery选择器 选择器太多，这里只是罗列一下常用的，具体使用还是查看在线手册，点击这里！ ¶1、基本过滤器 #ID 选择器：根据 id 查找标签对象 .class 选择器：根据 class 查找标签对象 element 选择器：根据标签名查找标签对象 *选择器：表示任意的，所有的元素 selector1，selector2 组合选择器：合并选择器 1，选择器 2 的结果并返回 p.myClass：表示标签名必须是 p 标签，而且 class 类型还要是 myClass ¶2、层级选择器 ancestor descendant 后代选择器 ：在给定的祖先元素下匹配所有的后代元素 parent &gt; child 子元素选择器：在给定的父元素下匹配所有的子元素 prev + next 相邻元素选择器：匹配所有紧接在 prev 元素后的 next 元素 prev ~ sibings 之后的兄弟元素选择器：匹配 prev 元素之后的所有 siblings 元素 ¶3、基本筛选器 :first 获取第一个元素 :last 获取最后个元素 :not(selector) 去除所有与给定选择器匹配的元素 :even 匹配所有索引值为偶数的元素，从 0 开始计数 :odd 匹配所有索引值为奇数的元素，从 0 开始计数 :eq(index) 匹配一个给定索引值的元素 :gt(index) 匹配所有大于给定索引值的元素 :lt(index) 匹配所有小于给定索引值的元素 :header 匹配如 h1, h2, h3 之类的标题元素 :animated 匹配所有正在执行动画效果的元素 ¶4、内容过滤器 :contains(text) 匹配包含给定文本的元素 :empty 匹配所有不包含子元素或者文本的空元素 :parent 匹配含有子元素或者文本的元素 :has(selector) 匹配含有选择器所匹配的元素的元素 ¶5、可见性过滤器 :hidden :visible ¶6、属性过滤器 [attribute] 匹配包含给定属性的元素。 [attribute=value] 匹配给定的属性是某个特定值的元素 [attribute!=value] 匹配所有不含有指定的属性，或者属性不等于特定值的元素。 [attribute^=value] 匹配给定的属性是以某些值开始的元素 [attribute$=value] 匹配给定的属性是以某些值结尾的元素 [attribute*=value] 匹配给定的属性是以包含某些值的元素 [attrSel1][attrSel2][attrSelN] 复合属性选择器，需要同时满足多个条件时使用。 ¶7、表单过滤器 :input 匹配所有 input, textarea, select 和 button 元素 :text 匹配所有 文本输入框 :password 匹配所有的密码输入框 :radio 匹配所有的单选框 :checkbox 匹配所有的复选框 :submit 匹配所有提交按钮 :image 匹配所有 img 标签 :reset 匹配所有重置按钮 :button 匹配所有 input type=button &lt;button&gt;按钮 :file 匹配所有 input type=file 文件上传 :hidden 匹配所有不可见元素 display:none 或 input type=hidden ¶8、表单对象属性过滤器 :enabled 匹配所有可用元素 :disabled 匹配所有不可用元素 :checked 的 匹配所有选中的单选，复选，和下拉列表中选中的 option 标签对象 :selected 的 匹配所有选中的 option ¶9、元素筛选器 ¶9.1、过滤 eq() 获取给定索引的元素 功能跟 :eq() 一样 first() 获取第一个元素 功能跟 :first 一样 last() 获取最后一个元素 功能跟 :last 一样 filter(exp) 留下匹配的元素 is(exp) 判断是否匹配给定的选择器，只要有个匹配就返回，true has(exp) 返回包含有匹配选择器的元素的元素 功能跟 :has 一样 not(exp) 删除匹配选择器的元素 功能跟 :not 一样 ¶9.2、查找 children(exp) 返回匹配给定选择器的子元素 功能跟 parent&gt;child 一样 next() 返回当前元素的下一个兄弟元素 功能跟 prev + next 功能一样 nextAll() 返回当前元素后面所有的兄弟元素 功能跟 prev ~ siblings 功能一样 nextUntil() 返回当前元素到指定匹配的元素为止的后面元素 parent() 返回父元素 prev(exp) 返回当前元素的上一个兄弟元素 prevAll() 返回当前元素前面所有的兄弟元素 prevUnit(exp) 返回当前元素到指定匹配的元素为止的前面元素 find(exp) 返回匹配给定选择器的后代元素 功能跟 ancestor descendant 一样 siblings(exp) 返回所有兄弟元素 ¶9.3、串联 add() 把 add 匹配的选择器的元素添加到当前 jQuery 对象中 ¶三、jQuery的DOM ¶1、DOM属性操作 注意：以下所有方法都是不传参为获取，传参为设置！ html() 它可以设置和获取起始标签和结束标签中的内容。 跟 dom 属性 innerHTML 一样。 text() 它可以设置和获取起始标签和结束标签中的文本。 跟 dom 属性 innerText 一样。 val() 它可以设置和获取表单项的 value 属性值。 跟 dom 属性 value 一样 注意：val专门处理表单项！ attr() 可以设置和获取属性的值，不推荐操作 checked、readOnly、selected、disabled 等等。attr 方法还可以操作非标准的属性。比如自定义属性：abc,bbj a.attr('name')取出a的name值 a.attr(\"name\",\"username\")把a的name值设置为username prop() 可以设置和获取属性的值, 只推荐操作 checked、readOnly、selected、disabled 等等。 a.prop('id') 取出a的id值 a.prop('id',\"bj\") 设置a的id值为bj removeAttr(name)：移除属性 removeProp(name)：移除属性 ¶2、DOM增删改 ¶2.1、内部插入 appendTo(content)：a.appendTo(b)， 把a加到所有b里面的最后 prependTo(content)：a.prependTo(b)，把a添加到所有b里面的最前 ¶2.2、外部插入 insertAfter(content)：a.insertAfter(b)，把a插入到所有b的后面 insertBefore(content)：a.insertBefore(b)，把a插入到所有b的前面 ¶2.3、替换 replaceWith(content|fn)：a.replaceWith(b)，用b替换所有a replaceAll(selector)：a.replaceAll(b)，用a替换所有的b ¶2.4、删除 empty()：删除匹配的元素集合中所有的子节点。 remove([expr])：从DOM中删除所有匹配的元素。这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。但除了这个元素本身得以保留之外，其他的比如绑定的事件，附加的数据等都会被移除。 ¶四、jQuery的CSS样式 addClass()：添加样式 removeClass()：删除样式 toggleClass()：有则删除，无则添加样式 offset()：获取和设置元素的坐标。语法：jQuery对象.offset({top:值，left:值})； ¶五、jQuery的事件 ¶1、文档加载 $(function(){})和window.onload = function(){}的区别： 触发时间： jQuery 的页面加载完成之后是浏览器的内核解析完页面的标签创建好 DOM 对象之后就会马上执行。 原生 JS 的页面加载完成之后，除了要等浏览器内核解析完标签创建好 DOM 对象，还要等标签显示时需要的内容加载 完成。 执行顺序：jQuery先，原生JS后 执行次数：jQuery全部执行，原生JS只执行最后一个 ¶2、事件绑定与移除 事件绑定方法：jquery对象.事件方法(回调函数(){ 触发事件执行的代码 }).事件方法(回调函数(){ 触发事件执行的代码 })...... click()：有参为绑定事件，无参则为触发事件 mouseover()：鼠标移入事件 mouseout()：鼠标移出事件 bind()：可以给元素一次性绑定一个或多个事件 one()：用法与bind一致，但是one方法绑定的事件只会响应一次 unbind()：与bind方法相反的操作，解除事件的绑定 live()：用来绑定事件，即使这个元素先前并未绑定，而是后面动态创建出来的也自动绑定 ¶4、事件冒泡 什么是事件的冒泡？ 事件的冒泡是指，父子元素同时监听同一个事件。当触发子元素的事件的时候，同一个事件也被传递到了父元素的事件里去响应。 那么如何阻止事件冒泡呢？ 在子元素事件函数体内，return false; 可以阻止事件的冒泡传递。 ¶5、事件对象 事件对象，是封装有触发的事件信息的一个 javascript 对象。 如何获取呢 javascript 事件对象呢？ 在给元素绑定事件的时候，在事件的 function( event ) 参数列表中添加一个参数，这个参数名，我们习惯取名为 event。这个 event 就是 javascript 传递参事件处理函数的事件对象。 1234567$(\"#areaDiv\").bind(\"mouseover mouseout\",function (event) { if (event.type == \"mouseover\") { console.log(\"鼠标移入\"); } else if (event.type == \"mouseout\") { console.log(\"鼠标移出\"); }}); ¶六、jQuery的动画 以下方法都可添加参数： 第一个参数：动画执行的时长(速度) 第二个参数：回调函数 show()：将隐藏的元素显示 hide()：将显示的元素隐藏 toggle()：显示则隐藏，隐藏则显示 fadeIn()：淡入 fadeOut()：淡出 fadeToggle()：淡入/淡出切换 fadeTo(speed,opacity,[fn])：在指定时长内将透明度修改到指定的值，第三个参数为回调函数 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://www.itnxd.cn/categories/JavaWeb/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://www.itnxd.cn/tags/jQuery/"}],"author":"ITNXD"},{"title":"Java与数据库连接的纽带之JDBC使用总结","slug":"Java与数据库连接的纽带之Jdbc使用总结","date":"2021-03-04T03:05:39.000Z","updated":"2021-03-04T14:24:10.559Z","comments":true,"path":"posts/49844.html","link":"","permalink":"https://www.itnxd.cn/posts/49844.html","excerpt":"","text":"¶一、JDBC概述 ¶1、对JDBC的理解 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API）！ 简单理解：JDBC，是SUN提供的一套 API，使用这套API可以实现对具体数据库的操作；不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。提供数据库驱动jar包。我们可以导入这些jar包进行编程。 如下图所示： JDBC接口（API）包括两个层次： 面向应用的API：Java API，抽象接口，供应用程序开发人员使用 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 ¶2、 Java中数据存储技术分类 在Java中，数据库存取技术可分为如下几类： **JDBC**直接访问数据库 JDO (Java Data Object )技术 第三方O/R工具，如Hibernate, Mybatis 等 JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。 ¶二、获取数据库连接 本教程全部使用最新版的mysql数据库驱动，mysql-connector-java-8.0.23.jar 注意：新版本驱动将旧版驱动遗弃了，由com.mysql.jdbc.Driver改为 com.mysql.cj.jdbc.Driver ¶1、方式一 直接使用Driver连接数据库！ 1234567891011121314public void test1() throws SQLException { Driver driver = new com.mysql.cj.jdbc.Driver(); // jdbc:mysql：协议 // test：具体数据库 String url = \"jdbc:mysql://localhost:3306/test\"; Properties info = new Properties(); info.setProperty(\"user\", \"root\"); info.setProperty(\"password\", \"123\"); Connection conn = driver.connect(url, info); System.out.println(conn);} 几种常用数据库的 JDBC URL： jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值 jdbc:mysql://localhost:3306/test jdbc:mysql://localhost:3306/test**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456 ¶2、方式二 对方式一的迭代：如下程序中不出现第三方API，程序具有更好的移植性！ 123456789101112131415161718public void test2() throws Exception { // 1. 获取driver实现类对象，使用反射 Class&lt;?&gt; clazz = Class.forName(\"com.mysql.cj.jdbc.Driver\"); Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance(); // 2. 提供要连接的数据库 String url = \"jdbc:mysql://localhost:3306/test\"; // 3. 提供连接需要的用户名和密码 Properties info = new Properties(); info.setProperty(\"user\", \"root\"); info.setProperty(\"password\", \"123\"); // 4. 获取连接 Connection conn = driver.connect(url, info); System.out.println(conn);} ¶3、方式三 使用DriverManager替换Driver！ 12345678910111213141516171819@Testpublic void test3() throws Exception{ // 1. 获取driver实现类对象，使用反射 Class&lt;?&gt; clazz = Class.forName(\"com.mysql.cj.jdbc.Driver\"); Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance(); // 2. 提供连接信息 String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"123\"; // 3. 注册驱动 DriverManager.registerDriver(driver); // 4. 获取连接（有多个重载方法！） Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn);} ¶4、方式四 对方式三的优化！ 几个注意点： java.sql.driver中使用静态代码块完成了驱动的注册！该步骤可以省略！ 1234567static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(\"Can't register driver!\"); }} 数据库厂家（mysql）已经内置了Class.forName(\"com.mysql.cj.jdbc.Driver\");其中的指定的包名在：该包下的META-INF/services/java.sql.Driver文件中为com.mysql.cj.jdbc.Driver虽然可以省略，但不建议省略，可能有的数据库厂家没有内置！目前mysql和oracle都内置了！ 123456789101112131415161718public void test4() throws Exception{ // 1. 提供连接信息 String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"xxx\"; // 2. 加载Driver Class.forName(\"com.mysql.cj.jdbc.Driver\"); // Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance(); // DriverManager.registerDriver (driver); // 3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn);} ¶5、方式五（终极版） 对方式四改进，最终版本！ 将连接所需信息写到配置文件中再进行读取！ 防止部署到tomcat配置文件读取不到，我们将配置文件放到src下！ 优点： 实现了数据与代码的分离 如果需要修改配置文件信息，可以避免程序重新打包 1234567891011121314151617181920public void test5() throws Exception { // 自定义类是系统类加载器：类加载器主要作用就是获取src下的配置文件！ // 1. 读取配置文件的四个基本信息 InputStream is = CollectionTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties properties = new Properties(); properties.load(is); String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); String url = properties.getProperty(\"url\"); String driverClass = properties.getProperty(\"driverClass\"); // 2. 加载驱动 Class.forName(driverClass); // 3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn);} jdbc.properties文件内容如下： 12345# JDBC配置文件，不要有空格！user=rootpassword=xxxurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=truedriverClass=com.mysql.cj.jdbc.Driver 使用配置文件的好处： 实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码 如果修改了配置信息，省去重新编译的过程。 用到的类加载器如图： ¶三、使用PreparedStatement实现CRUD操作 ¶1、java.sql下的三大接口 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 ¶2、Statement的弊端 **SQL注入：**SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user='1' OR 1 = ' AND password = ' OR '1' = '1') ，从而利用系统的 SQL 引擎完成恶意行为的做法。 在上述语句中，user：1' OR 1 = ，password： OR '1' = '1，该语句传到数据库服务器会被理解为几个与或语句，而最后一个语句永远成立，导致数据发生错误与不安全！ 拼串：String sql = \"SELECT user,password FROM user_table WHERE USER = '\" + userName + \"' AND PASSWORD = '\" + password + \"'\"; 存在拼串操作，繁琐 存在SQL注入问题 Statement没办法操作Blob类型变量 Statement实现批量插入时，效率较低 所以：使用preparedStatement替换，解决上述所有问题！ ¶3、两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 注意：sql是需要结合列名和表的属性名来写。注意起别名。 ¶4、preparedStatement使用 ¶4.1、preparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql)方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 ¶4.2、PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 ¶4.3、 Java与SQL对应数据类型转换 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP ¶4.4、数据库连接与释放封装到JDBCUtils中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class JDBCUtils { /** * 获取数据库的连接！ * * @return Connection * @throws Exception */ public static Connection getConnection() throws Exception{ // 1. 读取配置文件的四个基本信息 InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties properties = new Properties(); properties.load(is); String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); String url = properties.getProperty(\"url\"); String driverClass = properties.getProperty(\"driverClass\"); // 2. 加载驱动 Class.forName(driverClass); // 3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); return conn; } /** * 关闭连接和 Statement的操作！ * * @param conn Connection * @param ps Statement */ public static void closeResource(Connection conn, Statement ps){ try { if(ps != null) ps.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(conn != null) conn.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } /** * 资源关闭操作！ * * @param conn Connection * @param ps Statement * @param rs ResultSet */ public static void closeResource(Connection conn, Statement ps, ResultSet rs){ try { if(ps != null) ps.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(conn != null) conn.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(rs != null) rs.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } }} ¶4.5、增删改实现 若执行查询语句，有结果集，则返回true，若执行增删改操作，无返回集，则返回false 可以使用executeUpdate()方法根据返回值判断执行结果的成与败：根据影响的行数返回值，0或非0！来判断是否成功！return ps.executeUpdate(); 1234567891011121314151617181920212223242526272829303132333435363738public void update(String sql, Object ...args) { Connection conn = null; PreparedStatement ps = null; try { // 1. 获取数据库连接 conn = JDBCUtils.getConnection(); // 2. 预编译sql语句，返回PrepareStatement实例 ps = conn.prepareStatement(sql); // 3. 填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 4. 执行操作 ps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { // 5. 资源关闭 JDBCUtils.closeResource(conn, ps); }}// 测试通用增删改操作！// 注意：若表名为关键字，需要加上``，例如order@Testpublic void test3(){ // 删： String sql = \"delete from customers where id = ?\"; update(sql, 3); // 改： String sql1 = \"update `order` set order_name = ? where order_id = ?\"; update(sql1, \"DD\", 2); // 增： String sql2 = \"insert into customers(name, email, birth) values(?, ?, ?)\"; update(sql2, \"陈小纭\", \"cxy@gmail.com\", new Date(System.currentTimeMillis()));} ¶4.6、查询实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * 1、针对所有表查询的通用方法！ * * @param clazz Class&lt;T&gt; * @param sql String * @param args Object * @param &lt;T&gt; 泛型方法 * @return T */public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object ...args){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); // 获取结果集的元数据！ ResultSetMetaData metaData = rs.getMetaData(); // 通过结果集的元数据获取列数！ int columnCount = metaData.getColumnCount(); if(rs.next()){ T t = clazz.getDeclaredConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { // 获取到每一列的值 Object columnValue = rs.getObject(i + 1); // 获取到每一列的别名或列名！（建议） String columnLabel = metaData.getColumnLabel(i + 1); // 使用反射设置值，给customer指定的属性columnLabel，赋值为columnValue Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnValue); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps, rs); } return null;}// 对通用方法的测试！@Testpublic void test(){ String sql = \"select order_id orderId, order_name orderName, order_date orderDate from `order` where order_id = ?\"; Orders order = getInstance(Orders.class, sql, 1); System.out.println(order); String sql1 = \"select id, name, email from customers where id = ?\"; Customers customer = getInstance(Customers.class, sql1, 1); System.out.println(customer);}/** * 2、针对所有表查询的通用方法！---解决多条数据返回！ * @param clazz Class&lt;T&gt; * @param sql String * @param args Object * @param &lt;T&gt; 泛型方法 * @return List&lt;T&gt; */public &lt;T&gt; List&lt;T&gt; getList(Class&lt;T&gt; clazz, String sql, Object ...args){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); // 获取结果集的元数据！ ResultSetMetaData metaData = rs.getMetaData(); // 通过结果集的元数据获取列数！ int columnCount = metaData.getColumnCount(); // 创建List集合 ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while(rs.next()){ T t = clazz.getDeclaredConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { // 获取到每一列的值 Object columnValue = rs.getObject(i + 1); // 获取到每一列的别名或列名！（建议） String columnLabel = metaData.getColumnLabel(i + 1); // 使用反射设置值，给customer指定的属性columnLabel，赋值为columnValue Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnValue); } list.add(t); } return list; } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps, rs); } return null;}@Testpublic void test2(){ String sql = \"select id, name, email from customers where id &lt; ?\"; List&lt;Customers&gt; list = getList(Customers.class, sql, 5); list.forEach(System.out::println); // 或 String sql1 = \"select id, name, email from customers\"; List&lt;Customers&gt; list1 = getList(Customers.class, sql1); list1.forEach(System.out::println);} ¶5、ResultSet与ResultSetMetaData介绍 ¶5.1、ResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(String columnName) 获取每一列的值。 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。 ¶5.2、ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象！ ResultSetMetaData meta = rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名（无别名则为列名） getColumnCount()：返回当前 ResultSet 对象中的列数。 getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 isNullable(int column)：指示指定列中的值是否可以为 null。 isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 ¶四、操作Blob类型字段 ¶1、BLOB类型介绍 MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。 需要注意的是：如果存储的文件过大，数据库的性能会下降。 如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet=16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。 注意：mysql8.0以上mediumblob（16m）没有package的1m限制！无需去my.ini去配置！ MySQL的四种BLOB类型： ¶2、插入实现 123456789101112131415161718192021public void test1() { Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtils.getConnection(); String sql = \"insert into customers(name, email, birth, photo) values(?, ?, ?, ?)\"; ps = conn.prepareStatement(sql); ps.setObject(1, \"牛逼\"); ps.setObject(2, \"nb@gmail.com\"); ps.setObject(3, \"2021-02-01\"); ps.setBlob(4, new FileInputStream(\"hh2.png\")); ps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps); }} ¶4、查询实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void test2() { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; InputStream is = null; FileOutputStream fos = null; try { conn = JDBCUtils.getConnection(); String sql = \"select id,name,email,birth,photo from customers where id = ?\"; ps = conn.prepareStatement(sql); ps.setInt(1, 22); rs = ps.executeQuery(); if(rs.next()){ // 可以通过索引也可以通过别名！ int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String email = rs.getString(\"email\"); Date birth = rs.getDate(\"birth\"); Blob photo = rs.getBlob(\"photo\"); Customers cust = new Customers(id, name, email, birth); System.out.println(cust); // 将二进制图片写入本地！ is = photo.getBinaryStream(); fos = new FileOutputStream(\"nb.jpg\"); byte[] buffer = new byte[1024]; int len = 0; while((len = is.read(buffer)) != -1){ fos.write(buffer, 0, len); } } } catch (Exception e) { e.printStackTrace(); } finally { try { if(is != null) is.close(); } catch (IOException e) { e.printStackTrace(); } try { if(fos != null) fos.close(); } catch (IOException e) { e.printStackTrace(); } JDBCUtils.closeResource(conn, ps, rs); }} ¶五、批量插入 ¶1、方式一：使用Statement 已经弃用Statement，了解即可！每次都创建sql语句！效率极低！ 123456Connection conn = JDBCUtils.getConnection();Statement st = conn.createStatement();for(int i = 1;i &lt;= 20000;i++){ String sql = \"insert into goods(name)values('name_\" + i + \"')\"; st.execute(sql);} ¶2、方式二：使用prepareStatement 优化：使用prepareStatement的预编译SQL语句，减少SQL创建次数！一次编译，多次使用！可参考prepareStatement与statement的区别！ 123456789101112131415161718192021222324public void test1() { Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtils.getConnection(); String sql = \"insert into goods(name) values(?)\"; ps = conn.prepareStatement(sql); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) { ps.setObject(1, \"name_\" + i); ps.execute(); } long end = System.currentTimeMillis(); System.out.println(\"用时：\" + (end - start)); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps); }} ¶3、方式三：使用Batch优化 注意点： mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。rewriteBatchedStatements=true 写在配置文件的url后面。 三个相关方法： addBatch(String)：添加需要批量处理的SQL语句或是参数； executeBatch()：执行批量处理语句； clearBatch(): 清空缓存的数据 jdbc.properties文件修改如下： 1url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true 代码实现： 1234567891011121314151617181920212223242526272829303132public void test2(){ Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtils.getConnection(); String sql = \"insert into goods(name) values(?)\"; ps = conn.prepareStatement(sql); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000; i++) { ps.setObject(1, \"name_\" + i); // 1. 攒够缓存Batch ps.addBatch(); if(i % 500 == 0){ // 2. 批量执行缓存Batch ps.executeBatch(); // 3. 清空缓存Batch ps.clearBatch(); } } long end = System.currentTimeMillis(); System.out.println(\"用时：\" + (end - start)); // 100w数据用时27300 } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps); }} ¶4、方式四：关闭自动提交（最优） mysql默认执行完语句都会自动提交，因此可以设置关闭自动提交来提高效率！执行完毕再进行手动提交！ 123456789101112131415161718192021222324252627282930313233343536373839public void test3(){ Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtils.getConnection(); // 一、关闭自动提交 conn.setAutoCommit(false); String sql = \"insert into goods(name) values(?)\"; ps = conn.prepareStatement(sql); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000; i++) { ps.setObject(1, \"name_\" + i); // 1. 攒够缓存Batch ps.addBatch(); if(i % 500 == 0){ // 2. 批量执行缓存Batch ps.executeBatch(); // 3. 清空缓存Batch ps.clearBatch(); } } // 二、手动提交 conn.commit(); long end = System.currentTimeMillis(); System.out.println(\"用时：\" + (end - start)); // 100w数据用时19448 } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps); }} ¶六、数据库事务 参考我之前写的文章，数据库事务处理，点击这里！ ¶1、对通用增删改考虑事务的优化 传入Connection连接即可，再外部连接使用全部结束后再关闭！ 注意： 以防发生自动提交，在获取连接后关闭自动提交！发生异常时进行回滚操作！最终在关闭连接前进行还原事务为自动提交！归还资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public void update(Connection conn, String sql, Object ...args) { PreparedStatement ps = null; try { // 1. 预编译sql语句，返回PrepareStatement实例 ps = conn.prepareStatement(sql); // 2. 填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 3. 执行操作 ps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { // 5. 资源关闭（以防关闭连接导致自动提交，传入null） JDBCUtils.closeResource(null, ps); }}// 测试考虑事务操作的update！public void test2(){ // 1. 处理一个连接多条语句 Connection conn = null; try { conn = JDBCUtils.getConnection(); // 2. 处理DML语言的默认提交 conn.setAutoCommit(false); String sql = \"update user_table set balance = balance - 100 where user = ?\"; update(conn, sql, \"AA\"); // 模拟网络异常： System.out.println(10 / 0); String sql1 = \"update user_table set balance = balance + 100 where user = ?\"; update(conn, sql1, \"BB\"); // 3. 手动提交 conn.commit(); } catch (Exception e) { e.printStackTrace(); // 4. 发生异常进行回滚 try { if(conn != null) conn.rollback(); } catch (SQLException throwables) { throwables.printStackTrace(); } } finally { // 5. 还原事务为自动提交（用在数据库连接池归还连接时还原为最初状态） try { conn.setAutoCommit(true); } catch (SQLException throwables) { throwables.printStackTrace(); } // 6. 关闭数据库连接！ JDBCUtils.closeResource(conn, null); }} ¶2、对通用查考虑事务的优化 传入Connection连接即可，再外部连接使用全部结束后再关闭！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 1、针对所有表查询的通用方法！v2.0 (考虑事务) * * @param clazz Class&lt;T&gt; * @param sql String * @param args Object * @param &lt;T&gt; 泛型方法 * @return T */public &lt;T&gt; T getInstance(Connection conn, Class&lt;T&gt; clazz, String sql, Object ...args){ PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); // 获取结果集的元数据！ ResultSetMetaData metaData = rs.getMetaData(); // 通过结果集的元数据获取列数！ int columnCount = metaData.getColumnCount(); if(rs.next()){ T t = clazz.getDeclaredConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { // 获取到每一列的值 Object columnValue = rs.getObject(i + 1); // 获取到每一列的别名或别名！（建议） String columnLabel = metaData.getColumnLabel(i + 1); // 使用反射设置值，给customer指定的属性columnLabel，赋值为columnValue Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnValue); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps, rs); } return null;} ¶3、会导致数据自动提交的操作 DDL操作一旦执行，都会自动提交。`set autocommit = false` 对DDL操作失效 DML默认情况下，一旦执行，就会自动提交。我们可以通过`set autocommit = false`的方式取消DML操作的自动提交。 默认在关闭连接时，会自动的提交数据 ¶4、JDBC隔离级别的设置 1234567891011public void test3() throws Exception{ Connection conn = JDBCUtils.getConnection(); // 查看当前事务隔离界别(1, 2, 4, 8) System.out.println(conn.getTransactionIsolation()); // 修改为 read uncommitted // 1. 通过对应数字修改 // conn.setTransactionIsolation(1); // 2. 通过隔离级别名称修改 conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);} ¶七、数据访问对象DAO DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更有利于代码的维护和升级 ¶1、三部分组成 BaseDao：实现数据库增删改、查、分组函数的通用操作抽象类！只用于继承不用于实现！ XxxDao：实现对于某一个具体类的各种操作规范的接口，只用于定义规范，具体由XxxDaoImpl实现！ XxxDaoImpl：实现XxxDao定义的规范！ ¶2、BaseDao实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180public abstract class BaseDao&lt;T&gt; { // 反射：获取父类实现类的泛型！ // BaseDao作为通用父类，此处clazz是不确定的，无法声明为静态的，只能在子类实例化时创建！ private Class&lt;T&gt; clazz = null; // 如下方法使用clazz都是通过对象调用的，所以应该在对象实例化之前就知道clazz是谁！ // 可以显示赋值，构造器赋值，代码块赋值！ // 通过反射获取父类实现类的泛型，即本例子的customer泛型！ // 获取BaseDao的子类继承父类中的泛型！ // clazz为非静态，这里只能使用非静态代码块！ // 解释：此处this指的是创建对象时的类，即当前类的实现类CustomerDaoImpl！ // 代码块写在父类Dao中，可以动态的通过反射获取泛型，而无需在子类中进行重复创建！ { // 1. 获取当前对象的父类的泛型！ Type genericSuperclass = this.getClass().getGenericSuperclass(); // 2. 转换为带参数泛型！ ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass; // 3. 获取泛型参数 Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); // 4. 获取第一个参数，即customer! clazz = (Class&lt;T&gt;) actualTypeArguments[0]; } /** * 1. 考虑事务操作的通用增删改！ * * @param conn Connection * @param sql String * @param args Object */ public void update(Connection conn, String sql, Object ...args) { PreparedStatement ps = null; try { // 1. 预编译sql语句，返回PrepareStatement实例 ps = conn.prepareStatement(sql); // 2. 填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 3. 执行操作 ps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { // 5. 资源关闭（以防关闭连接导致自动提交，传入null） JDBCUtils.closeResource(null, ps); } } /** * 2、考虑事务操作的通用查询！ ----解决返回一条数据！ * * 此时不是泛型方法，去掉泛型方法声明，去掉class参数！ * * @param sql String * @param args Object * @return T */ public T getInstance(Connection conn, String sql, Object ...args){ PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); // 获取结果集的元数据！ ResultSetMetaData metaData = rs.getMetaData(); // 通过结果集的元数据获取列数！ int columnCount = metaData.getColumnCount(); if(rs.next()){ T t = clazz.getDeclaredConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { // 获取到每一列的值 Object columnValue = rs.getObject(i + 1); // 获取到每一列的别名或别名！（建议） String columnLabel = metaData.getColumnLabel(i + 1); // 使用反射设置值，给customer指定的属性columnLabel，赋值为columnValue Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnValue); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps, rs); } return null; } /** * 3、考虑事务操作的通用查询！---解决多条数据返回！ * * 此时不是泛型方法，去掉泛型方法声明，去掉class参数！ * * @param sql String * @param args Object * @return List&lt;T&gt; */ public List&lt;T&gt; getList(Connection conn, String sql, Object ...args){ PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); // 获取结果集的元数据！ ResultSetMetaData metaData = rs.getMetaData(); // 通过结果集的元数据获取列数！ int columnCount = metaData.getColumnCount(); // 创建List集合 ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while(rs.next()){ T t = clazz.getDeclaredConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { // 获取到每一列的值 Object columnValue = rs.getObject(i + 1); // 获取到每一列的别名或别名！（建议） String columnLabel = metaData.getColumnLabel(i + 1); // 使用反射设置值，给customer指定的属性columnLabel，赋值为columnValue Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnValue); } list.add(t); } return list; } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(null, ps, rs); } return null; } /** * 4. 考虑特殊值返回的操作（例如分组函数） * * @param conn Connection * @param sql String * @param args Object * @param &lt;E&gt; 泛型方法 * @return E */ public &lt;E&gt; E getValue(Connection conn, String sql, Object ...args){ PreparedStatement ps = null; ResultSet rs = null; try { ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); if(rs.next()){ return (E) rs.getObject(1); } } catch (SQLException throwables) { throwables.printStackTrace(); } finally { JDBCUtils.closeResource(null, ps, rs); } return null; }} ¶3、CustomerDao实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 再一步优化！ * * 该接口用于规范customers表的通用操作！ * * @author ITNXD * @create 2021-03-02 22:57 */public interface CustomerDAO { /** * 通过传入的Customers中的id插入数据！ * @param conn Connection * @param cust Customers */ void insert(Connection conn, Customers cust); /** * 通过传入的Customers中的id更新数据！ * @param conn Connection * @param cust Customers */ void update(Connection conn, Customers cust); /** * 通过传入的id删除数据！ * @param conn Connection * @param id int */ void deleteById(Connection conn, int id); /** * 通过传入的id获取Customer! * @param conn Connection * @param id int */ Customers getCustomerById(Connection conn, int id); /** * 获取表中所有数据构成的集合！ * @param conn Connection * @return List */ List&lt;Customers&gt; getAll(Connection conn); /** * 获取表中的数据项总数！ * @param conn Connection * @return long */ long getCount(Connection conn); /** * 获取最大生日日期返回！ * @param conn Connection * @return Date */ Date getMaxBirth(Connection conn);} ¶4、CustomerDaoImpl实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CustomerDAOImpl extends BaseDao&lt;Customers&gt; implements CustomerDAO { @Override public void insert(Connection conn, Customers cust) { String sql = \"insert into customers(name, email, birth) values(?,?,?)\"; update(conn, sql, cust.getName(), cust.getEmail(), cust.getbirth()); } @Override public void update(Connection conn, Customers cust) { String sql = \"update customers set name=?,email=?,birth=? where id = ?\"; update(conn, sql, cust.getName(), cust.getEmail(), cust.getbirth(), cust.getId()); } @Override public void deleteById(Connection conn, int id) { String sql = \"delete from customers where id = ?\"; update(conn, sql, id); } @Override public Customers getCustomerById(Connection conn, int id) { String sql = \"select id, name, email, birth from customers where id = ?\"; // 优化，customer实现类操作customer，所以应该无需传入customer.class// return getInstance(conn, Customers.class, sql, id); return getInstance(conn, sql, id); } @Override public List&lt;Customers&gt; getAll(Connection conn) { String sql = \"select id, name, email, birth from customers\"; // 优化，customer实现类操作customer，所以应该无需传入customer.class// return getList(conn, Customers.class, sql); return getList(conn, sql); } @Override public long getCount(Connection conn) { String sql = \"select count(*) from customers\"; return getValue(conn, sql); } @Override public Date getMaxBirth(Connection conn) { String sql = \"select Max(birth) from customers\"; return getValue(conn, sql); }} ¶5、测试该模块体系 IDEA中快速生成测试：要测试的类上右go to -&gt; test 选择要测试方法和放在哪个包下就行！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * 测试CustomerDAOImpl类！ * * 快速生成测试：要测试的类上右键go to -&gt; test 选择要测试方法和放在哪个包下就行！ * * @author ITNXD * @create 2021-03-03 9:50 */class CustomerDAOImplTest { private CustomerDAOImpl dao = new CustomerDAOImpl(); @Test void insert() { Connection conn = null; try { conn = JDBCUtils.getConnection(); Customers cust = new Customers(1, \"牛逼\", \"nb@gmail.com\", new Date(System.currentTimeMillis())); dao.insert(conn, cust); System.out.println(\"添加成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } } @Test void update() { Connection conn = null; try { conn = JDBCUtils.getConnection(); Customers cust = new Customers(1, \"牛逼\", \"nb@gmail.com\", new Date(System.currentTimeMillis())); dao.update(conn, cust); System.out.println(\"更新成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } } @Test void deleteById() { Connection conn = null; try { conn = JDBCUtils.getConnection(); dao.deleteById(conn, 1); System.out.println(\"删除成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } } @Test void getCustomerById() { Connection conn = null; try { conn = JDBCUtils.getConnection(); Customers cust = dao.getCustomerById(conn, 2); System.out.println(cust); System.out.println(\"获取成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } } @Test void getAll() { Connection conn = null; try { conn = JDBCUtils.getConnection(); List&lt;Customers&gt; list = dao.getAll(conn); list.forEach(System.out::println); System.out.println(\"获取成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } } @Test void getCount() { Connection conn = null; try { conn = JDBCUtils.getConnection(); long count = dao.getCount(conn); System.out.println(count); System.out.println(\"获取成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } } @Test void getMaxBirth() { Connection conn = null; try { conn = JDBCUtils.getConnection(); Date birth = dao.getMaxBirth(conn); System.out.println(birth); System.out.println(\"获取成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } }} ¶八、数据库连接池 ¶1、数据库连接池技术的优点 类似于线程池，提高效率！ 1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 ¶2、多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，**速度相对较慢，稳定性还可以。**hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 BoneCP 是一个开源组织提供的数据库连接池，速度快 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 ¶3、C3P0 需要导入：c3p0-0.9.1.2.jar开源包 123456789101112131415161718192021222324252627282930313233343536373839/* 方式一：*/@Testpublic void test1() throws Exception { // 从doc目录下的文档找到复制过来！ // 获取C3P0数据库连接池： ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass( \"com.mysql.cj.jdbc.Driver\" ); //loads the jdbc driver cpds.setJdbcUrl( \"jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true\" ); cpds.setUser(\"root\"); cpds.setPassword(\"xxx\"); // 通过设置相关参数对数据库连接池进行管理： // 设置初始数据库连接池连接数： cpds.setInitialPoolSize(10); Connection conn = cpds.getConnection(); System.out.println(conn); // 销毁C3P0数据库连接池： // 一般不进行销毁！ DataSources.destroy(cpds);}// 方式二：使用配置文件!/* 1. 使用properties文件：c3p0.properties 2. 使用xml文件配置：c3p0-config.xml 文件内容参考c3p0包下的文档例子！（推荐） 注意：都在src下 注意：idea文件创建xml：https://www.cnblogs.com/lvchengda/p/12620098.html */@Testpublic void test2() throws SQLException { // 参数为xml文件中自定义的named-config ComboPooledDataSource cpds = new ComboPooledDataSource(\"myC3p0\"); Connection conn = cpds.getConnection(); System.out.println(conn);} c3p0-config.xml文件： 注意事项： 所有的name命名都为小驼峰命名 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;c3p0-config&gt;&lt;!-- 注意：name命名为小驼峰命名!--&gt;&lt;!-- 注意：name命名为小驼峰命名!--&gt;&lt;!-- 注意：name命名为小驼峰命名!--&gt;&lt;!-- 注意：name命名为小驼峰命名!--&gt;&lt;!-- 配置命名：随意--&gt; &lt;named-config name=\"myC3p0\"&gt; &lt;!--提供获取连接的四个基本参数！--&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;!--如果为默认的：localhost:3306 则可省略--&gt;&lt;!-- &lt;property name=\"JdbcUrl\"&gt;jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&lt;/property&gt;--&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql:///test?rewriteBatchedStatements=true&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;xxx&lt;/property&gt;&lt;!-- 进行数据库连接池管理的基本信息！--&gt;&lt;!-- 当数据库连接池连接数不够时c3p0一次性向数据库服务器申请的连接数！--&gt; &lt;property name=\"acquireIncrement\"&gt;50&lt;/property&gt;&lt;!-- c3p0数据库连接池初始化的连接数！--&gt; &lt;property name=\"initialPoolSize\"&gt;10&lt;/property&gt;&lt;!-- c3p0数据库连接池维护的最少连接数！--&gt; &lt;property name=\"minPoolSize\"&gt;10&lt;/property&gt;&lt;!-- c3p0数据库连接池维护的最多连接数！--&gt; &lt;property name=\"maxPoolSize\"&gt;1000&lt;/property&gt;&lt;!-- c3p0数据库连接池最多维护的Statement个数！--&gt; &lt;property name=\"maxStatements\"&gt;50&lt;/property&gt;&lt;!-- 每个连接最多可使用的Statement数！--&gt; &lt;property name=\"maxStatementsPerConnection\"&gt;2&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; ¶4、DBCP 需要导入： commons-dbcp-1.4.jar：连接池的实现 ``commons-pool-1.5.5.jar`：连接池的依赖库 **Tomcat 的连接池正是采用该连接池来实现的。**该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 文档位置：E:commons-dbcp-1.4\\apidocs\\index.html 方式一： */@Testpublic void test1() throws SQLException { // 创建DBCP数据库连接池 BasicDataSource sources = new BasicDataSource(); // 设置基本信息： sources.setDriverClassName(\"com.mysql.cj.jdbc.Driver\"); sources.setUrl(\"jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true\"); sources.setUsername(\"root\"); sources.setPassword(\"xxx\"); // 设置其他连接池相关属性！ // E:\\Java学习\\尚硅谷Java\\1、JavaSE+JavaWeb\\4、尚硅谷_宋红康_JDBC核心技术(2019新版)\\3-资料\\2-驱动\\03-数据库连接池驱动\\dbcp.txt sources.setInitialSize(10); sources.setMaxActive(10); Connection conn = sources.getConnection(); System.out.println(conn);}// 方式二：使用配置文件：(推荐)@Testpublic void test2() throws Exception { Properties properties = new Properties(); // 方式一：默认为src下： // InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"dbcp.properties\"); // 方式二：默认为当前项目下，所以要转到src下： FileInputStream is = new FileInputStream(\"src/dbcp.properties\"); properties.load(is); DataSource source = BasicDataSourceFactory.createDataSource(properties); Connection conn = source.getConnection(); System.out.println(conn);} dbcp.properties文件： 123456driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=xxxinitialSize=10 可配置的连接池属性： 属性 默认值 说明 initialSize 0 连接池启动时创建的初始化连接数量 maxActive 8 连接池中可同时连接的最大的连接数 maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 poolPreparedStatements false 开启池的Statement是否prepared maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数 minEvictableIdleTimeMillis 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间 removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接 removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 ¶5、Druid（推荐） 又称为德鲁伊！ Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。 12345678910111213/* druid API文档：druid-1.1.10\\doc\\index.html */@Testpublic void test1() throws Exception{ Properties properties = new Properties(); InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"druid.properties\"); properties.load(is); DataSource source = DruidDataSourceFactory.createDataSource(properties); Connection conn = source.getConnection(); System.out.println(conn);} druid.properties文件： 1234567driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=xxxinitialSize=10maxActive=20 详细配置参数： 配置 缺省 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this) url 连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/使用ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 ¶6、使用数据库连接池对JDBCUtils重构 JDBCUtils实现了数据库的连接和资源释放操作！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/** * 对JDBCUtils的重构！使用数据库连接池！ * * @author ITNXD * @create 2021-03-03 15:24 */public class JDBCUtils { /** * 获取数据库的连接！（最基础） * * @return Connection * @throws Exception */ public static Connection getConnection() throws Exception{ // 1. 读取配置文件的四个基本信息 InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties properties = new Properties(); properties.load(is); String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); String url = properties.getProperty(\"url\"); String driverClass = properties.getProperty(\"driverClass\"); // 2. 加载驱动 Class.forName(driverClass); // 3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); return conn; } // 数据库连接池只需创建一个！ private static ComboPooledDataSource cpds = new ComboPooledDataSource(\"myC3p0\"); /** * 1.1 使用c3p0数据库连接池重构的getConnection()方法！ * * @return Connection * @throws SQLException 异常 */ public static Connection getConnection1() throws SQLException { Connection conn = cpds.getConnection(); return conn; } /** * 1.2 使用dbcp数据库连接池重构的getConnection()方法！ * * @return Connection * @throws Exception 异常 */ private static DataSource source; static{ try { Properties properties = new Properties(); // 方式一：默认为src下： // InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"dbcp.properties\"); // 方式二：默认为当前项目下，所以要转到src下： FileInputStream is = new FileInputStream(\"src/dbcp.properties\"); properties.load(is); DataSource source = BasicDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } public static Connection getConnection2() throws Exception { Connection conn = source.getConnection(); return conn; } /** * 1.3 使用druid数据库连接池重构的getConnection()方法！ * @return Connection * @throws Exception */ private static DataSource source1 = null; static{ try { Properties properties = new Properties(); InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"druid.properties\"); properties.load(is); source1 = DruidDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } public static Connection getConnection3() throws Exception{ Connection conn = source1.getConnection(); return conn; } /** * 2. 关闭连接和 Statement的操作！ * * @param conn Connection * @param ps Statement */ public static void closeResource(Connection conn, Statement ps){ try { if(ps != null) ps.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(conn != null) conn.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } /** * 3. 资源关闭操作！ * * @param conn Connection * @param ps Statement * @param rs ResultSet */ public static void closeResource(Connection conn, Statement ps, ResultSet rs){ try { if(ps != null) ps.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(conn != null) conn.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(rs != null) rs.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } }} ¶九、Apache-DBUtil实现CRUD操作 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装! 需要导入：commons-dbutils-1.3.jar开源包！ dbutils API文档：commons-dbutils-1.3\\apidocs\\index.html API介绍： org.apache.commons.dbutils.QueryRunner：提供数据库操作的一系列重载的update()和query()操作 org.apache.commons.dbutils.ResultSetHandler：此接口用于处理数据库查询操作得到的结果集。不同的结果集的情形，由其不同的子类来实现 工具类：org.apache.commons.dbutils.DbUtils ¶1、QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 public int update(Connection conn, String sql, Object... params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 插入 public &lt;T&gt; T insert(Connection conn,String sql,ResultSetHandler&lt;T&gt; rsh, Object... params) throws SQLException：只支持INSERT语句 批处理 public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public &amp;lt;T&amp;gt; T insertBatch(Connection conn,String sql,ResultSetHandler&amp;lt;T&amp;gt; rsh,Object[][] params)throws SQLException：只支持INSERT语句 查询 public Object query(Connection conn, String sql, ResultSetHandler rsh,Object... params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 123456789101112131415161718192021222324// dbutils API文档：commons-dbutils-1.3\\apidocs\\index.htmlpublic class QueryRunnerTest { // 测试增删改： @Test public void test1() { Connection conn = null; try { QueryRunner runner = new QueryRunner(); // 使用德鲁伊数据库连接池获取连接： conn = JDBCUtils.getConnection3(); String sql = \"insert into customers(name, email, birth) values(?,?,?)\"; int insertCount = runner.update(conn, sql, \"牛逼1\", \"nb1@gmail.com\", \"2021-3-3\"); System.out.println(insertCount); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } }} ¶2、ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs) 接口的主要实现类： ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 **BeanHandler：**将结果集中的第一行数据封装到一个对应的JavaBean实例中。 **BeanListHandler：**将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 **MapHandler：**将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 **MapListHandler：**将结果集中的每一行数据都封装到一个Map里，然后再存放到List **ScalarHandler：**查询单个值对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145// 测试查询1：/* BeanHander：是ResultSetHandler的实现类！用于封装表中一条记录！ */@Testpublic void testQuery1(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id, name, email, birth from customers where id = ?\"; BeanHandler&lt;Customers&gt; handler = new BeanHandler&lt;Customers&gt;(Customers.class); Customers customers = runner.query(conn, sql, handler, 20); System.out.println(customers); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); }}// 测试查询2：/* BeanListHandler：是ResultSetHandler的实现类！用于封装表中多条记录！ */@Testpublic void testQuery2(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id, name, email, birth from customers where id &lt; ?\"; BeanListHandler&lt;Customers&gt; handler = new BeanListHandler&lt;Customers&gt;(Customers.class); List&lt;Customers&gt; list = runner.query(conn, sql, handler, 20); list.forEach(System.out::println); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); }}// 测试查询3：/* MapHandler：是ResultSetHandler的实现类！对应表中一条记录！ 将字段和相应字段的值作为map中的key和value! */@Testpublic void testQuery3(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id, name, email, birth from customers where id = ?\"; MapHandler handler = new MapHandler(); Map&lt;String, Object&gt; map = runner.query(conn, sql, handler, 20); System.out.println(map); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); }}// 测试查询4：/* MapListHandler：是ResultSetHandler的实现类！对应表中多条记录！ 将字段和相应字段的值作为map中的key和value! */@Testpublic void testQuery4(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id, name, email, birth from customers where id &lt; ?\"; MapListHandler handler = new MapListHandler(); List&lt;Map&lt;String, Object&gt;&gt; list = runner.query(conn, sql, handler, 20); list.forEach(System.out::println); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); }}// 测试查询5：/* ScalarHandler：是ResultSetHandler的实现类！返回分组函数查询的结果！ 查询特殊值！ */@Testpublic void testQuery5(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select count(*) from customers\"; ScalarHandler handler = new ScalarHandler(); long count = (long) runner.query(conn, sql, handler); System.out.println(count); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); }}// 测试查询6：/* 使用ResultSetHandler实现自定义handler 查询特殊值！ */@Testpublic void testQuery6(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id, name, email, birth from customers where id = ?\"; // 自定义类实现：匿名内部类里实现重写方法！ ResultSetHandler&lt;Customers&gt; handler = new ResultSetHandler&lt;&gt;() { @Override public Customers handle(ResultSet rs) throws SQLException { if(rs.next()){ int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String email = rs.getString(\"email\"); Date birth = rs.getDate(\"birth\"); return new Customers(id, name, email, birth); } return null; } }; Customers cust = runner.query(conn, sql, handler, 7); System.out.println(cust); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); }} ¶3、DbUtils工具类 DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 12345678910111213141516171819202122232425 /* 资源关闭操作：使用DBUtils库实现： */public static void closeResource1(Connection conn, Statement ps, ResultSet rs){ // 没啥意思的关闭操作！ // try { // DbUtils.close(conn); // } catch (SQLException throwables) { // throwables.printStackTrace(); // } // try { // DbUtils.close(ps); // } catch (SQLException throwables) { // throwables.printStackTrace(); // } // try { // DbUtils.close(rs); // } catch (SQLException throwables) { // throwables.printStackTrace(); // } // 这样一次性关闭并处理异常！ DbUtils.closeQuietly(conn, ps, rs);} ¶十、JDBC总结 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void testUpdateWithTx() { Connection conn = null; try { //1.获取连接的操作 //① 手写的连接：JDBCUtils.getConnection(); //② 使用数据库连接池：C3P0;DBCP;Druid conn.setAutoCommit(false); //2.对数据表进行一系列CRUD操作 //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0) //version2.0的增删改public void update(Connection conn,String sql,Object ... args){} //version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args){} //② 使用dbutils提供的jar包中提供的QueryRunner类 //提交数据 conn.commit(); } catch (Exception e) { e.printStackTrace(); try { //回滚数据 conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } }finally{ //3.关闭连接等操作 //① JDBCUtils.closeResource(); //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://www.itnxd.cn/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://www.itnxd.cn/tags/JDBC/"}],"author":"ITNXD"},{"title":"再学MySql之使用大总结","slug":"再学MySql之使用大总结","date":"2021-02-22T03:58:51.000Z","updated":"2021-02-23T06:35:09.210Z","comments":true,"path":"posts/30836.html","link":"","permalink":"https://www.itnxd.cn/posts/30836.html","excerpt":"","text":"¶一、DQL语言 DQL(Data Query Language)：数据查询语言，用于查询！ ¶1、基础查询 ¶1.1、语法 查询列表可以是：表中的字段、常量值、表达式、函数 查询的结果是一个虚拟的表格 SELECT *代表查询该表全部字段 查询字符型和日期型的常量值必须用单引号引起来，数值型不需要 1SELECT 查询列表 FROM 表名; ¶1.2、别名 12SELECT xxx 别名 FROM 表名;SELECT xxx AS 别名 FROM 表名; ¶1.3、去重 1SELECT DISTINCT xxx FROM 表名; ¶1.4、关于+号 仅有运算符的功能！ select 数值+数值：直接运算 select 字符+数值：先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算 select null+值：结果都为null ¶1.5、几个函数 contact(xxx,xxx,xxx ...)：字符串拼接 ifnull(expr1, expr2)：判断expr1是否为null，如果为null返回expr2，否则返回expr1 isnull(xxx)：判断该字段值是否为null，是返回1，否则返回0 ¶2、条件查询 ¶2.1、语法 123select 查询列表from 表名where 筛选条件; ¶2.2、运算符 条件运算符：&gt;、&lt;、=、!=、&lt;&gt;、&gt;=、&lt;= 逻辑运算符：and or not 模糊查询关键字： like：一般搭配通配符使用，可以判断字符型或数值型。 通配符：%任意多个字符，_任意单个字符 若匹配_ 或 %则需要使用转移字符\\，或使用escape自定义转义字符 between xxx and xxx：在两范围之间，包含临界值 in(xxx, xxx ...)： in列表的值类型必须一致或兼容 in列表中不支持通配符 is null：=或&lt;&gt;不能用于判断null值，is null或is not null可以判断null值 is not null：略 安全等于&lt;=&gt;：可以判断可判断null和普通数值型，由于长得模棱两可，可读性低，一般不用 123SELECT last_nameFROM employeesWHERE last_name LIKE '_$_%' ESCAPE '$'; ¶3、排序查询 ¶3.1、语法 1234select 查询列表from 表名【where 筛选条件】order by 排序的字段或表达式; ¶3.2、注意点 asc代表的是升序，可以省略。desc代表的是降序 order by子句可以支持 单个字段、别名、表达式、函数、多个字段 order by子句在一般放在查询语句的最后面，除了limit子句 ¶4、常见函数 sql语言中索引从1开始！ ¶1、字符函数 我之前的教程！点击这里！ concat(exp1, exp2, exp3 …): 字符串连接 substr(str1, int): 截取从int位置开始之后str1剩余的所有字符（索引从1开始） substr(str1, int1, int2): 截取str1中从int1开始的int2个字符 upper(str)：变大写 lower(str)：变小写 replace(str1, str2, str3)：str1中的所有str2被替换成了str3 length(str)：获取字节长度（一个汉字是三个字节） trim(str): 去前后空格 (不光去空格 ) SELECT TRIM('aa' FROM 'aaa哈哈哈aaa')：返回a哈哈哈a lpad(str1, int, str2)：左填充，结果的长度为int，str1长度若不够int，将str2填充到str1左侧，直到长度为 int，如果str1长度大于int，则从左往右取int个输出，int不是指字节，指字符 rpad(str1, int, str2)：右填充 instr(str1, str2): 获取str1中第一次出现str2的索引值，如果找不到返回0 ¶2、数学函数 我之前的教程！点击这里！ ceil(x): 向上取整 floor(x)：向下取整 round(x, [d])：四舍五入，d代表保留小数位数 mod(n, m)：取模 truncate(x, d): 截断，将数值保留int位小数，剩余尾数截断 rand(): 获取随机数，返回0-1之间的小数 ¶3、日期函数 我之前的教程！点击这里！ ¶4、其他函数 version(): 当前数据库服务器的版本 database(): 当前打开的数据库 user(): 当前用户 password('字符’)：返回该字符的密码形式，新版mysql已不支持` md5(‘字符’): 返回该字符的md5加密形式 ¶5、流程控制函数 if(条件表达式，表达式1，表达式2)：类似三元运算符 可以作为表达式放在任何位置 case情况1：类似于switch case，else省略，若都不匹配，则返回null 可以放在任何位置： 如果放在begin end 外面，作为表达式结合着其他语句使用 如果放在begin end 里面，一般作为独立的语句使用 123456case 表达式when 常量1 then 要显示的值1when 常量2 then 要显示的值2...else 要显示的值n（else可省略）end as 别名 case情况2：类似于if else 123456case when 条件1 then 要显示的值1when 条件2 then 要显示的值2...else 要显示的值n end as 别名 例如： 12345678SELECT salary 原始工资,department_id,CASE department_idWHEN 30 THEN salary*1.1WHEN 40 THEN salary*1.2WHEN 50 THEN salary*1.3ELSE salaryEND AS 新工资FROM employees; ¶6、分组函数 又叫做：聚合函数，统计函数，组函数 主要有：sum avg max min count 参数类型： sum, avg：适用于数值型，字符型也不报错，返回0 max, min：数值型，字符型 count：不为null的个数 **注意：**以上分组函数都忽略null值 可以和distinct搭配实现去重，eg：SELECT SUM(DISTINCT salary) FROM employees; 和分组函数一同查询的字段要求是group by后的字段，其他不行 count(*)：不忽略null，即返回总行数！ 如下写法，相当于加了一列： 12SELECT COUNT(1) FROM employees;SELECT COUNT('hh') FROM employee; 效率： myisam引擎：count(*)效率最高 innodb引擎：count(*)和count(1)差不多，比count(字段)高 ¶5、分组查询 ¶5.1、语法 注意：查询的列表比较特殊，要求是分组函数和group by后出现的字段 123456select 查询列表from 表【where 筛选条件】group by 分组的字段(可为多个)【having 】【order by 排序的字段】; 举例： 123SELECT MAX(salary), job_idFROM employeesGROUP BY job_id; ¶5.2、having &amp; where where：对分组前结果进行筛选，放在group by之前 having：对分组后的结果进行筛选，放在group by之后，聚集函数一般放在having后！ ¶6、连接查询 又称为多表查询！防止未添加连接条件导致产生笛卡尔积现象！ 为方便操作，一般为表起别名！ 注意：为表起了别名，则查询的字段将不能再使用原表名进行限定，只能使用别名 ¶6.1、分类 mysql虽然不支持全外连接，但可以使用UNION，左连接一次，右连接一次，再使用UNION合并来实现全外连接！ 年代分类 sql92：仅仅支持内连接（where后添加连接条件，已被弃用） sql99：全支持，但mysql不支持全连接！(on后添加连接条件) 功能分类 内连接（等值连接（交集）、非等值连接、自连接） 外连接（左外、右外、全外（mysql不支持）） 交叉连接 ¶6.2、sql99语法 1、内连接 12345678select 查询列表from 表1 别名【inner】 join 表2 别名 on 连接条件where 筛选条件group by 分组列表having 分组后的筛选order by 排序列表limit 子句; 2、左外&amp;右外连接 left join 左边的就是主表，right join 右边的就是主表，full join 两边都是主表！ 12345678select 查询列表from 表1 别名left|right|full【outer】 join 表2 别名 on 连接条件where 筛选条件group by 分组列表having 分组后的筛选order by 排序列表limit 子句; 3、交叉连接 类似笛卡尔积！ 123select 查询列表from 表1 别名cross join 表2 别名; ¶6.3、总结 内连接和左右外连接 其他几种 ¶7、子查询 可由后面的视图代替，提高可读性! 嵌套在其他语句内部的select语句称为子查询或内查询，外面如果为select语句，则此语句称为外查询或主查询！ 外面的语句可以是insert、update、delete、select等，一般select作为外面语句较多！ ¶7.1、分类 按出现位置 select后面：支持标量子查询 from后面：支持表子查询（子查询结果为一张虚拟表，要求必须起别名） where或having后面：支持标量子查询、列子查询 、行子查询 exists后面（相关子查询）：标量子查询、列子查询、行子查询、表子查询 按结果集行列 标量子查询（单行子查询）：结果集为一行一列 列子查询（多行子查询）：结果集为多行一列 行子查询：结果集为多行多列 表子查询：结果集为多行多列 exists(完整的查询语句)：结果为1或0，可用in代替！ 举例： 12345678910111213141516# 使用inSELECT department_nameFROM departments dWHERE d.`department_id` IN( SELECT department_id FROM employee;);# 使用existsSELECT department_nameFROM departments dWHERE EXISTS( SELECT * FROM employees e WHERE d.`department_id`=e.`department_id`); ¶7.2、注意点 子查询放在小括号内 子查询一般放在条件的右侧 子查询的执行优先于主查询，主查询用到了子查询的结果 标量子查询，一般搭配单行操作符使用 &lt; &gt; &gt;= &lt;= - &lt;&gt; 列子查询：一般搭配多行操作符使用 in \\ not in \\ any/some \\ all in 等于其中一个即可 not in 不是其中每个 any/some 比较其中一个即可 （可替换为max,min） all 比较所有值 （可替换为max,min） 列子查询举例： 1234567891011121314151617181920212223242526272829303132333435案例1：返回location_id是1400或1700的部门中的所有员工姓名SELECT last_nameFROM employeesWHERE department_id IN( SELECT DISTINCT department_id FROM departments WHERE location_id IN(1400,1700));# 或SELECT last_nameFROM employeesWHERE department_id = ANY( SELECT DISTINCT department_id FROM departments WHERE location_id IN(1400,1700));案例2：返回location_id不是1400或1700的部门中的所有员工姓名SELECT last_nameFROM employeesWHERE department_id NOT IN( SELECT DISTINCT department_id FROM departments WHERE location_id IN(1400,1700));# 或SELECT last_nameFROM employeesWHERE department_id &lt;&gt; ALL( SELECT DISTINCT department_id FROM departments WHERE location_id IN(1400,1700)); ¶8、分页查询 ¶8.1、语法 offset：起始索引（起始索引从0开始，唯一一个从0开始的，其他都是1开始） size：显示条数 123456789select 查询列表from 表【join type join 表2on 连接条件where 筛选条件group by 分组字段having 分组后的筛选order by 排序的字段】limit 【offset,】size; ¶8.2、注意点 limit语句放在查询语句的最后 要显示的页数 page，每页的条目数size，limit (page-1)*size, size; 使用order by和limit组合，可以找到一个列中最大值、最小值 ¶9、联合查询 多次查询合并！ 将一条比较复杂的查询语句拆分成多条语句！ ¶9.1、语法 12345查询语句1union 【all】查询语句2union 【all】... ¶9.2、注意点 要求多条查询语句的查询列数必须一致 要求多条查询语句的查询的各列类型、顺序最好一致 union 去重，union all包含重复项 ¶10、查询总结 各大关键字的位置及其执行顺序！ 123456789select 查询列表 ⑦from 表1 别名 ①连接类型 join 表2 ②on 连接条件 ③where 筛选 ④group by 分组列表 ⑤having 筛选 ⑥order by排序列表 ⑧limit 起始条目索引，条目数; ⑨ ¶二、DML语言 DML(Data Manipulation Language)：数据操纵语言，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心！ ¶1、插入 ¶1.1、语法 123两种方式：insert into 表名(字段名,...) values(值,...);insert into 表名 set 字段=值,字段=值,...; ¶1.2、区别和注意点 方式一只需保证对应一致即可 方式一支持插入多行,方式二不支持 方式一支持子查询，方式二不支持 不可以为null的列必须插入值，可以为null的列可以写或不写 省略列名，默认所有列，值和表列的顺序要一致。 12345678910# 方式一插入多行insert into 表名 values(值,...),values(值,...),...# 方式一子查询INSERT INTO beauty(id,NAME,phone)SELECT id,boyname,'1234567'FROM boys WHERE id&lt;3; ¶2、修改 ¶1.1、语法 123456789# 修改单表update 表名 set 字段=值,字段=值 【where 筛选条件】;# 修改多表update 表1 别名 left|right|inner join 表2 别名 on 连接条件 set 字段=值,字段=值 【where 筛选条件】; ¶3、删除 可以使用delete和truncate！ ¶3.1、语法 123456789# 单表删除delete from 表名 【where 筛选条件】【limit 条目数】;# 级联删除(多表删除)delete 别名1,别名2 from 表1 别名 inner|left|right join 表2 别名 on 连接条件【where 筛选条件】; 1truncate table 表名 ¶3.2、delete &amp; truncate delete 可以加where 条件，truncate不能加 truncate删除，效率高一丢丢 假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始；而truncate删除后，再插入数据，自增长列的值从1开始。 truncate删除没有返回值，delete删除有返回值 truncate删除不能回滚，delete删除可以回滚. ¶三、DDL语言 DDL(Data Definition Language)：数据定义语言，处理库和表的管理及各种约束！以create、alter、drop三种指令为核心！ ¶1、库的管理 ¶1.1、创建库 1create database 【if not exists】 库名【 character set 字符集名】; ¶1.2、修改库 12345# 更改库名RENAME DATABASE 库名 TO 新库名;# 更改库的字符集ALTER DATABASE 库名 CHARACTER SET 字符集名; ¶1.3、删除库 1drop database 【if exists】 库名; ¶2、表的管理 ¶2.1、创建表 1234567create table 表名( 列名 列的类型【(长度) 约束】, 列名 列的类型【(长度) 约束】, 列名 列的类型【(长度) 约束】, ... 列名 列的类型【(长度) 约束】); ¶2.2、修改表 1234567891011121314151617# 语法：alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;# 修改列名ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 列类型;# 修改列的类型或约束alter table 表名 modify column 列名 新类型 【新约束】;# 添加新列ALTER TABLE 表名 ADD COLUMN 列名 列类型 约束条件; # 删除列ALTER TABLE 表名 DROP COLUMN 列名;# 修改表名ALTER TABLE 表名 RENAME 【TO】 新表名; ¶2.3、删除表 1drop table 【if exists】 表名; ¶2.4、复制表 1、复制表的结构 1CREATE TABLE 新表名 LIKE 旧表; 2、复制表的结构以及数据 12create table 新表名 select 查询列表 from 旧表【where 筛选】; ¶3、数据类型 ¶3.1、分类 整型型：tinyint(1)、smallint(2)、mediumint(3)、int/integer(4)、bigint(8) 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值 如果不设置长度，会有默认的长度长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！ 小数型：float(M,D)浮点型 ：4字节，double(M,D)定点型： 8字节 M代表整数部位+小数部位的字符个数，D代表小数部位 如果超出范围，则报out or range异常，并且插入临界值 M和D都可以省略，但对于定点数，M默认为10，D默认为0 如果精度要求较高，则优先考虑使用定点数 字符型：char、varchar、binary(二进制)、varbinary(二进制)、enum(枚举)、set(集合)、text、blob(较大二进制) char：固定长度的字符，写法为char(M)，最大长度不能超过M，其中M可以省略，默认为1 varchar：可变长度的字符，写法为varchar(M)，最大长度不能超过M，其中M不可以省略 日期型：date、time、year、datetime(8字节，范围：1000—9999)、timestamp(4字节，范围：1970-2038) timestamp：比较容易受时区、语法模式、版本的影响，更能反映当前时区的真实时间 SET time_zone='+9:00'：可设置时区 小栗子： 12345678910111213141516171819CREATE TABLE tab_char( c1 ENUM('a','b','c'));INSERT INTO tab_char VALUES('a');INSERT INTO tab_char VALUES('b');INSERT INTO tab_char VALUES('c');INSERT INTO tab_char VALUES('A');SELECT * FROM tab_set;CREATE TABLE tab_set( s1 SET('a','b','c','d'));INSERT INTO tab_set VALUES('a');INSERT INTO tab_set VALUES('A,B');INSERT INTO tab_set VALUES('a,c,d'); ¶4、常见约束 ¶4.1、常见约束 NOT NULL：非空，该字段的值必填 UNIQUE：唯一，该字段的值不可重复 DEFAULT：默认，该字段的值不用手动插入有默认值 CHECK：检查，mysql不支持 PRIMARY KEY：主键，该字段的值不可重复并且非空 ，等同于unique + not null FOREIGN KEY：外键，该字段的值引用了另外的表的字段 ¶4.2、主键 &amp; 唯一键 一个表至多有一个主键，但可以有多个唯一 主键不允许为空，唯一可以为空 注意：新版支持唯一多null 联合主键：PRIMARY KEY(xxx, xxx) ，索引会显示两个主键（二者为整体来决定） 联合唯一键： UNIQUE(seat, age)，类似！ ¶4.2、外键 外键写法：[constraint 约束名] foreign key(从表被约束的列) references 主表(主表被引用列) 用于限制两个表的关系，从表的字段值引用了主表的某字段值 外键列和主表的被引用列要求类型一致，意义一样，名称无要求 主表的被引用列要求是一个key（一般是主键或唯一键） 插入数据，先插入主表。删除数据，先删除从表 可以通过以下两种方式来删除主表的记录： 1、级联删除：删除主表该数据的同时将从表该数据也删除 注意：接下来使用delete删除时，主表删除谁则从表对应数据行也删除 12# 例子：ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE; 2、级联置空：删除主表该数据的同时将从表该数据也置空 注意：接下来使用delete删除时，主表删除谁则从表对应数据（使用主表外键的列）置空 12# 例子：ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL; ¶4.3、约束使用 1、创建表时添加约束 列级约束：不可以设置约束名 只支持默认、非空、主键、唯一键 一个字段可写多个，顺序随意，空格隔开即可 表级约束：【constraint 约束名】 约束类型(字段名) 只支持主键、外键、唯一键 可选部分不写默认为字段名！ 对主键无效！ 注意：主键、外键、唯一键会自动生成索引。可使用SHOW INDEX FROM 表名查看索引！ 123456789101112131415161718192021222324# 列级约束CREATE TABLE stuinfo( id INT PRIMARY KEY,#主键 stuName VARCHAR(20) NOT NULL UNIQUE,#非空 gender CHAR(1) CHECK(gender='男' OR gender ='女'),#检查 seat INT UNIQUE,#唯一 age INT DEFAULT 18,#默认约束 majorId INT REFERENCES major(id)#外键);# 表级约束CREATE TABLE stuinfo( id INT, stuname VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT, CONSTRAINT pk PRIMARY KEY(id),#主键 主键名改了无效，一定是primary CONSTRAINT uq UNIQUE(seat),#唯一键 CONSTRAINT ck CHECK(gender ='男' OR gender = '女'),#检查 CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键); 2、修改表时添加或删除约束 2.1、非空 1234# 添加非空alter table 表名 modify column 字段名 字段类型 not null;# 删除非空alter table 表名 modify column 字段名 字段类型 ; 2.2、默认 1234# 添加默认alter table 表名 modify column 字段名 字段类型 default 值;# 删除默认alter table 表名 modify column 字段名 字段类型 ; 2.3、主键 1234# 添加主键alter table 表名 add【 constraint 约束名】 primary key(字段名);# 删除主键alter table 表名 drop primary key; 2.4、唯一 1234# 添加唯一alter table 表名 add【 constraint 约束名】 unique(字段名);# 删除唯一alter table 表名 drop index 索引名; 2.5、外键 1234# 添加外键alter table 表名 add【 constraint 约束名】 foreign key(字段名) references 主表（被引用列）;# 删除外键alter table 表名 drop foreign key 约束名; 3、通用或建议写法 1234567891011121314151617# 语法CREATE TABLE 表名( 字段名 字段类型 列级约束, 字段名 字段类型, 表级约束);# 例子CREATE TABLE IF NOT EXISTS stuinfo( id INT PRIMARY KEY, stuname VARCHAR(20), sex CHAR(1), age INT DEFAULT 18, seat INT UNIQUE, majorid INT, CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)); ¶4.4、自增长列 不用手动插入值，可以自动提供序列值，默认从1开始，步长为1！ 1、注意点 一个表至多有一个自增长列 自增长列只能支持数值型 自增长列必须为一个key（主键、唯一键、外键） 2、更改默认起始值和步长 对于更改起始值：也可以在第一次插入时指定该值，则之后自增就以该值开始！ 注意：使用set设置变量，影响范围为当前会话，可以添加global|session修改为所有会话，永久改变，只能修改配置文件！ 1234# 更改起始值SET auto_increment_offset=值;# 更改步长set auto_increment_increment=值; 3、创建表时设置自增长列 自增长列赋值可以为null，还是自增！也可在插入时不插入该列！ 1234create table 表( 字段名 字段类型 约束 auto_increment, ...); 4、修改表时设置自增长列 1alter table 表 modify column 字段名 字段类型 约束 auto_increment; 5、删除自增长列 1alter table 表 modify column 字段名 字段类型 约束 ; ¶4.5、索引 以前写的教程，点击这里查看！ ¶四、DCL语言 DCL(Data Control Language)：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括grant、revoke 等。 总链接：数据库教程之字符集.安全管理.维护，之前写的教程，点击这里！ 字符集和校对顺序，点击这里！ 安全管理，用户管理，访问控制，点击这里！ 数据库维护，备份，日志，点击这里！ 改善性能，mysql使用建议，点击这里！ ¶五、TCL语言 TCP(Transaction Control Language)：事务控制语言，处理事务及使用隔离级别解决并发问题！ ¶1、事务 事务：一条或多条sql语句组成一个执行单位，一组sql语句要么都执行要么都不执行，把多条语句作为一个整体进行操作的功能，被称为数据库事务！ ¶1.1、事务的ACID四个特性 A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行； C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100； I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离； D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。 ¶1.2、事务的创建 隐式事务：事务没有明显的开启和结束的标记 显示事务：事务具有明显的开启和结束的标记，前提：必须先设置自动提交功能为禁用 12345678910111213set autocommit=0;# 步骤1：开启事务set autocommit=0;【start transaction;】# 步骤2：编写事务中的sql语句(select insert update delete)语句1;语句2;...# 步骤3：结束事务commit;提交事务rollback;回滚事务 ¶1.3、使用保留点savepoint 12345678SET autocommit=0;START TRANSACTION;DELETE FROM account WHERE id=25;SAVEPOINT a;#设置保存点DELETE FROM account WHERE id=28;ROLLBACK TO a;#回滚到保存点SELECT * FROM account; ¶2、隔离级别 我之前写的教程更加详细：隔离级别，点击这里！ ¶2.1、注意点 serializable：效率低，类似于java多线程的锁，同一时刻只能有一个事务操作 oracle支持两种：serializable \\ read committed ¶2.2、默认隔离级别 mysql（如果使用InnoDB）中默认 第三个隔离级别 repeatable read oracle中默认第二个隔离级别 read committed ¶2.3、查看隔离级别 1234# 旧版使用，新版本无法使用select @@tx_isolation; # 8.0版本改为：select @@transaction_isolation; ¶2.4、设置隔离级别 1set session|global transaction isolation level 隔离级别; 在变量章节详细讲解！ session ：当前事务（可选，不写则不会马上生效） global：全局，一般设置后需重启mysql ¶六、视图 mysql5.1版本出现的新特性，本身是一个虚拟表，它的数据来自于表，通过执行时动态生成。只保存了sql逻辑，不保存查询结果！ 简化sql语句，提高了sql的重用性 保护基表的数据，提高了安全性(即封装性，将子查询封装) ¶1、视图和表对比 表保存数据，视图仅保存逻辑语句 视图一般用于查询，表一般用于增删改查 ¶2、创建视图 使用：可以将视图名称当做表名使用即可！ 123# 语法：create view 视图名as 查询语句; ¶3、修改视图 1234567# 方式一：存在则修改，不存在则创建create or replace view 视图名as 查询语句;# 方式二alter view 视图名as 查询语句; ¶4、删除视图 1drop view 视图名,视图名,...; ¶5、查看视图 12345# 视图结构DESC myv3;# 显示视图创建过程SHOW CREATE VIEW myv3; ¶6、更新视图 和表的操作一致，insert, update, delete！ 以下视图不允许更新： 包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all join 常量视图 where后的子查询用到了from中的表 用到了不可更新的视图 ¶七、变量 global：所有会话（当前mysql所有连接，重启失效） session：默认值，当前会话 永久生效：修改配置文件 ¶1、系统变量 分类： 全局变量 会话变量 ¶1.1、查看所有系统变量 1show global|【session】variables; ¶1.2、查看满足条件的部分系统变量 1show global|【session】 variables like '%char%'; ¶1.3、查看指定的系统变量的值 1select @@global|【session】系统变量名; ¶1.4、为某个系统变量赋值 1234# 方式一：set global|【session】系统变量名=值;# 方式二：set @@global|【session】系统变量名=值; ¶2、自定义变量 分类： 用户变量 局部变量 ¶2.1、用户变量 作用域：针对于当前连接（会话）生效 位置：begin end里面，也可以放在外面 注意：一般添加@ 123456789101112131415# 声明并赋值：推荐使用第二种（防止=歧义）set @变量名=值; #或set @变量名:=值; #或select @变量名:=值;# 更新值# 方式一：set @变量名=值; #或set @变量名:=值; #或select @变量名:=值;# 方式二：select xx into @变量名 from 表;# 查询select @变量名; ¶2.2、局部变量 作用域：仅仅在定义它的begin end中有效 位置：只能放在begin end中，而且只能放在第一句 注意：一般不添加@ 12345678910111213# 声明declare 变量名 类型 【default 值】;# 赋值或更新# 方式一：set 变量名=值; #或set 变量名:=值; #或select @变量名:=值;# 方式二：select xx into 变量名 from 表;# 查询select 变量名; ¶八、存储过程和函数 类似于方法！ ¶1、存储过程 视图是逻辑语句，存储过程是执行完的集合！一组预先编译好的SQL语句的集合，理解成批处理语句！ 存储过程无法被修改，只可以删除之后重建！ ¶1.1、创建 如果存储过程体仅仅只有一句话，begin end可以省略。 存储过程体中的每条sql语句的结尾要求必须加分号。 需要使用分隔符结束！ 123456DELIMITER $CREATE PROCEDURE 存储过程名(参数模式 参数名 参数类型, ...)BEGIN 存储过程体（一组合法的SQL语句）; ...END$ 参数模式： in：该参数需要调用方传入值（默认，可省略，但不建议） out：该参数可以作为返回值 inout：该参数既需要传入值，又可以返回值 几个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#1.空参列表#案例：插入到admin表中五条记录DELIMITER $CREATE PROCEDURE myp1()BEGIN INSERT INTO admin(username,`password`) VALUES('john1','0000'),('lily','0000'),('rose','0000'),('jack','0000'),('tom','0000');END $#调用：CALL myp1()$#2.创建带in模式参数的存储过程#案例：创建存储过程实现 根据女神名，查询对应的男神信息CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))BEGIN SELECT bo.* FROM boys bo RIGHT JOIN beauty b ON bo.id = b.boyfriend_id WHERE b.name=beautyName;END $#调用CALL myp2('柳岩')$#3.创建out 模式参数的存储过程#案例：根据输入的女神名，返回对应的男神名和魅力值CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) BEGIN SELECT boys.boyname ,boys.usercp INTO boyname,usercp FROM boys RIGHT JOIN beauty b ON b.boyfriend_id = boys.id WHERE b.name=beautyName ;END $#调用CALL myp7('小昭',@name,@cp)$SELECT @name,@cp$#4.创建带inout模式参数的存储过程#案例1：传入a和b两个值，最终a和b都翻倍并返回CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)BEGIN SET a=a*2; SET b=b*2;END $#调用SET @m=10$SET @n=20$CALL myp8(@m,@n)$SELECT @m,@n$ ¶1.2、分隔符 防止遇到分号提前结束语句！ 结束标记一旦指定，则当前会话结束标记都应为该符号！ sqlyog有点bug，每次运行都必须得指定该分隔符，控制台没问题！ 123delimiter 结束标记delimiter $ ¶1.3、调用 1234567891011121314call 存储过程名(实参列表)# 调用in模式的参数：call sp1（‘值’）;# 调用out模式的参数：set @name; call sp1(@name);select @name;# 调用inout模式的参数：set @name=值; call sp1(@name); select @name; ¶1.4、查看 1show create procedure 存储过程名; ¶1.5、删除 12# 只能一个个删除drop procedure 存储过程名; ¶2、函数 ¶2.1、函数与存储过程区别 存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新 函数：有且仅有1个返回，适合做处理数据后返回一个结果 ¶2.2、创建 函数体中仅有一句话，则可以省略begin end 使用 delimiter语句设置结束标记 12345delimiter $CREATE FUNCTION 函数名(参数名 参数类型, ...) RETURNS 返回类型BEGIN 函数体END$ 几个例子： 12345678910111213141516171819202122232425#1.无参有返回#案例：返回公司的员工个数CREATE FUNCTION myf1() RETURNS INTBEGIN DECLARE c INT DEFAULT 0;#定义局部变量 SELECT COUNT(*) INTO c#赋值 FROM employees; RETURN c;END $SELECT myf1()$#2.有参有返回#案例1：根据员工名，返回它的工资CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLEBEGIN SET @sal=0;#定义用户变量 SELECT salary INTO @sal #赋值 FROM employees WHERE last_name = empName; RETURN @sal;END $SELECT myf2('k_ing') $ ¶2.3、调用 1SELECT 函数名(参数列表); ¶2.4、查看 1show create function 函数名; ¶2.5、删除 1drop function 函数名； ¶九、流程控制结构 ¶1、分支结构 if函数和case结构看第一章的第四节的第五小结的流程控制函数！ ¶1.1、if结构 只能放在begin end中！ 123456# 语法：if 条件1 then 语句1;elseif 条件2 then 语句2;...else 语句n;end if; 例子： 12345678910111213#案例：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回DCREATE FUNCTION test_if(score FLOAT) RETURNS CHARBEGIN DECLARE ch CHAR DEFAULT 'A'; IF score&gt;90 THEN SET ch='A'; ELSEIF score&gt;80 THEN SET ch='B'; ELSEIF score&gt;60 THEN SET ch='C'; ELSE SET ch='D'; END IF; RETURN ch;END $SELECT test_if(87)$ ¶2、循环结构 位置：都只能放在begin end中 ¶2.1、while 123【名称:】while 循环条件 do 循环体end while 【名称】; ¶2.2、loop 类似死循环！ 123【名称：】loop 循环体end loop 【名称】; ¶2.3、repeat 类似do while！ 1234【名称:】repeat 循环体until 结束条件 end repeat 【名称】; ¶2.4、循环控制语句 leave：类似于break，用于跳出所在的循环 iterate：类似于continue，用于结束本次循环，继续下一次 几个例子： 12345678910111213141516171819202122232425262728293031#1.添加leave语句#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止CREATE PROCEDURE test_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 1; a:WHILE i&lt;=insertCount DO INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000'); IF i&gt;=20 THEN LEAVE a; END IF; SET i=i+1; END WHILE a;END $CALL test_while1(100)$#2.添加iterate语句#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次CREATE PROCEDURE test_while2(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 0; a:WHILE i&lt;=insertCount DO SET i=i+1; IF MOD(i,2)!=0 THEN ITERATE a; END IF; INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000'); END WHILE a;END $CALL test_while2(100)$ ¶十、游标和触发器 总链接：数据库教程之游标及触发器，之前写的教程，点击这里! 游标 触发器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.itnxd.cn/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.itnxd.cn/tags/MySQL/"}],"author":"ITNXD"},{"title":"再学Java之单例、模板方法、动静态代理设计模式","slug":"再学Java之单例、模板方法、动静态代理设计模式","date":"2021-02-17T13:29:59.000Z","updated":"2021-02-21T15:15:38.427Z","comments":true,"path":"posts/22183.html","link":"","permalink":"https://www.itnxd.cn/posts/22183.html","excerpt":"","text":"¶一、设计模式之单例设计模式 设计模式： 设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。 常用设计模式 — 23种经典的设计模式 GOF 创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 单例设计模式： 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。 ¶1、饿汉式实现 坏处：对象加载时间过长。 好处：饿汉式是线程安全的 123456789101112131415161718192021222324public class SingletonTest1 { public static void main(String[] args) { Bank bank1 = Bank.getInstance(); Bank bank2 = Bank.getInstance(); System.out.println(bank1 == bank2); // true }}class Bank{ // 1. 私有化类构造器 private Bank() { } // 2. 内部创建类对象 // 4. 要求此对象也声明为静态 private static Bank instance = new Bank(); // 3. 提供公共静态方法，返回类对象 public static Bank getInstance() { return instance; }} ¶2、懒汉式实现 好处：延迟对象的创建。 目前的写法坏处：线程不安全 12345678910111213141516171819202122232425262728public class SingletonTest2 { public static void main(String[] args) { Order order1 = Order.getInstance(); Order order2 = Order.getInstance(); System.out.println(order1 == order2); // true }}class Order{ //1.私化类的构造器 private Order(){ } //2.声明当前类对象，没初始化 //4.此对象也必须声明为static的 private static Order instance = null; //3.声明public、static的返回当前类对象的方法 public static Order getInstance(){ if(instance == null) { instance = new Order(); } return instance; }} ¶3、懒汉式线程安全实现 1234567891011121314151617181920212223242526272829303132333435363738class Order1{ private Order1(){} private static Order1 instance = null; // 方式一：效率稍差 /*public static Order1 getInstance(){ synchronized (Order1.class) { if(instance == null) { instance = new Order1(); } return instance; } }*/ // 方式二：效率稍高 public static Order1 getInstance(){ if(instance == null){ synchronized (Order1.class) { if(instance == null) { instance = new Order1(); } } } return instance; } // synchronized 写到函数声明上也可 /*public static synchronized Order1 getInstance(){ if(instance == null) { instance = new Order1(); } return instance; }*/} ¶4、单例设计模式应用场景 网站的计数器，一般也是单例模式实现，否则难以同步。 应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。 Application 也是单例的典型应用 Windows的Task Manager (任务管理器)就是很典型的单例模式 Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 ¶二、设计模式之模板方法设计模式 ¶1、解决的问题 在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变 部分可以抽象出来，供不同子类实现。这就是一种模板模式。 ¶2、模板方法应用 模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有： 数据库访问的封装 Junit单元测试 JavaWeb的Servlet中关于doGet/doPost方法调用 Hibernate中模板程序 Spring中JDBCTemlate、HibernateTemplate等 ¶3、代码实现 12345678910111213141516171819202122232425262728293031323334353637383940abstract class Template{ //计算某段代码执行所需要花费的时间 public void spendTime(){ long start = System.currentTimeMillis(); this.code();//不确定的部分、易变的部分 long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start)); } public abstract void code();}// 模板方法实现抽象接口：class SubTemplate extends Template{ @Override public void code() { for(int i = 2;i &lt;= 1000;i++){ boolean isFlag = true; for(int j = 2;j &lt;= Math.sqrt(i);j++){ if(i % j == 0){ isFlag = false; break; } } if(isFlag){ System.out.println(i); } } }} ¶三、设计模式之静态代理设计模式 ¶1、解决的问题 代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。 ¶2、静态代理的缺点 代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。 每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。 ¶3、代码实现 代理类：通用的入口 被代理类：具体的某一个 1234567891011121314151617181920212223242526272829303132333435363738394041public class StaticProxyTest { public static void main(String[] args) { // 创建被代理类对象: NikeProxyClothFactory nike = new NikeProxyClothFactory(); // 创建代理类对象： ProxyClothFactory proxyClothFactory = new ProxyClothFactory(nike); // 使用代理类对象调用被代理类方法： proxyClothFactory.produceCloth(); }}interface ClothFactory{ void produceCloth();}// 代理类：class ProxyClothFactory implements ClothFactory{ // 用被代理类对象实例化： private ClothFactory clothFactory; public ProxyClothFactory(ClothFactory clothFactory) { this.clothFactory = clothFactory; } @Override public void produceCloth() { System.out.println(\"代理工厂做一些准备工作！\"); clothFactory.produceCloth(); System.out.println(\"代理工厂做一些后续工作！\"); }}// 被代理类：class NikeProxyClothFactory implements ClothFactory{ @Override public void produceCloth() { System.out.println(\"Nike工厂生产一批衣服！\"); }} ¶四、设计模式之动态代理设计模式 反射的应用！ 代理模式的原理： 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 ¶1、需要解决的两个主要问题 如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。（通过Proxy.newProxyInstance()实现） 当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。(通过InvocationHandler接口的实现类及其方法invoke() ¶2、动态代理的特点 动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。 ¶3、代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class DynamicProxyTest { public static void main(String[] args) { // 例子一： // 1. 通过被代理类动态创建一个代理类对象 // 体现多态，我拿接口去接收！ Human human = (Human) ProxyFactory.getProxyInstance(new SuperMan()); // 2. 通过该代理类对象调用方法，自动调用被代理类的同方法！ human.eat(\"apple\"); String belief = human.getBelief(); System.out.println(belief); System.out.println(\"=====================================\"); // 例子二：动态性的体现；创建静态代理中用过的衣服工厂的例子！ ClothFactory nike = (ClothFactory) ProxyFactory.getProxyInstance(new NikeProxyClothFactory()); nike.produceCloth(); // 至此：实现任何被代理类的动态代理！ }}interface Human{ String getBelief(); void eat(String food);}// 被代理类：class SuperMan implements Human{ @Override public String getBelief() { return \"I believe I can fly!\"; } @Override public void eat(String food) { System.out.println(\"超人喜欢吃\" + food); }}// 1. 专门生产代理类的工厂：解决问题一class ProxyFactory{ // 2. 调用此方法，返回一个代理类对象！ // obj：被代理类对象！ public static Object getProxyInstance(Object obj){ MyInvocationHandler handler = new MyInvocationHandler(); // 9. 通过MyInvocationHandler绑定当前被代理类对象！ handler.bind(obj); // 3.调用Proxy.newProxyInstance方法获取代理类对象 // 参数一：指明被代理类的classLoader // 参数二：指明被代理类实现的接口 // 6. 参数三：指明被代理类的InvocationHandler，即解决问题二！ return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler); }}// 4.class MyInvocationHandler implements InvocationHandler{ // 8. 创建被代理类对象： private Object obj; public void bind(Object obj){ this.obj = obj; } // 5. 当我们通过代理类对象，调用方法a时，会自动调用如下方法：invoke() @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 7. 通过第三步的参数传来的方法名、参数去调用被代理类的方法！ // 10. 通过第九步绑定的被代理类对象来调用该对象的method方法！ return method.invoke(obj, args); }} ¶4、AOP动态代理（Aspect Orient Programming） 使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理 这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异 1234567891011121314151617181920212223242526272829303132class HumanUtil{ public void method1(){ System.out.println(\"===================通用方法一=======================\"); } public void method2(){ System.out.println(\"===================通用方法二=======================\"); }}// 改造上面的该方法：class MyInvocationHandler1 implements InvocationHandler{ private Object obj; public void bind(Object obj){ this.obj = obj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { HumanUtil humanUtil = new HumanUtil(); humanUtil.method1(); Object returnVal = method.invoke(obj, args); humanUtil.method2(); return returnVal; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.itnxd.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"ITNXD"},{"title":"再学Java之StringBuffer、StringBuilder、枚举类、注解、集合和泛型","slug":"再学Java之StringBuffer、StringBuilder、枚举类、注解和集合、泛型","date":"2021-02-15T11:06:25.000Z","updated":"2021-02-17T14:43:14.771Z","comments":true,"path":"posts/54748.html","link":"","permalink":"https://www.itnxd.cn/posts/54748.html","excerpt":"","text":"¶一、StringBuffer VS StringBuilder ¶1、String、StringBuffer、StringBuilder三者的对比 `String`：不可变的字符序列，底层使用`char[]`存储。 `StringBuffer`：可变的字符序列，**线程安全的，效率低**。底层使用`char[]`存储。 `StringBuilder`：可变的字符序列，**JDK5.0**新增的，**线程不安全的，效率高**。底层使用`char[]`存储。 因此，他们的效率高低依次为：StringBuilder &gt; StringBuffer &gt; String 注意： JDK8之后的版本使用的是byte[]存储！ ¶2、使用建议 只要不是多线程问题，操作共享数据，都使用新增的StringBuilder！ ¶3、StringBuffer、StringBuilder内存解析 二者在内存层面存储扩容方面几乎一致，这里以StringBuffer为例！ ¶3.1、先来看一下String的存储 String底层使用private final存储！ 12String str = new String(); // char[] value = new char[0];String str1 = new String(\"abc\"); // char[] value = new char[]{'a','b','c'}; ¶3.2、StringBuffer 默认开辟长度为16的数组 若为有参构造器，则开辟参数的长度 + 16的数组 扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍 + 2，同时将原数组中的元素复制到新的数组中。 12345StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。System.out.println(sb1.length());//sb1.append('a');//value[0] = 'a';sb1.append('b');//value[1] = 'b';StringBuffer sb2 = new StringBuffer(\"abc\");//char[] value = new char[\"abc\".length() + 16]; ¶3.3、总结 开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)，提高效率！ ¶二、枚举类 JDK5.0之前，自定义枚举类，JDK5.0之后，使用enum关键字！ ¶1、自定义枚举类 1234567891011121314151617181920212223242526272829303132333435//1. 自定义枚举类class Season{ //1.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私化类的构造器,并给对象属性赋值 private Season(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } //3.提供当前枚举类的多个对象：public static final的 public static final Season SPRING = new Season(\"春天\",\"春暖花开\"); public static final Season SUMMER = new Season(\"夏天\",\"夏日炎炎\"); public static final Season AUTUMN = new Season(\"秋天\",\"秋高气爽\"); public static final Season WINTER = new Season(\"冬天\",\"冰天雪地\"); //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } //4.其他诉求2：提供toString() @Override public String toString() { return \"Season{\" + \"seasonName='\" + seasonName + '\\'' + \", seasonDesc='\" + seasonDesc + '\\'' + '}'; }} ¶2、使用enum关键字 enum类的主要方法： values() 方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符 串必须是枚举类对象的名字。如不是，会有运行时异常：IllegalArgumentException。 toString()：返回当前枚举类对象常量的名称 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) { Season1 autumn = Season1.AUTUMN; // 默认实现了toString()，为常量名 System.out.println(autumn); // AUTUMN System.out.println(Season1.class.getSuperclass()); // class java.lang.Enum // 也可以重写： System.out.println(autumn); // Season{seasonName='秋天', seasonDesc='秋高气爽'} /*=============================================*/ //1. toString():返回枚举类对象的名称 System.out.println(autumn.toString()); // AUTUMN //2. values():返回所的枚举类对象构成的数组 Season1[] values = Season1.values(); for (int i = 0; i &lt; values.length; i++) { System.out.println(values[i]); } Thread.State[] values1 = Thread.State.values(); for (int i = 0; i &lt; values1.length; i++) { System.out.println(values1[i]); } //3. valueOf(String objName):返回枚举类中对象名是objName的对象。 //如果没objName的枚举类对象，则抛异常：IllegalArgumentException // Season1 autumn11 = Season1.valueOf(\"AUTUMN1\"); Season1 autumn1 = Season1.valueOf(\"AUTUMN\"); System.out.println(autumn1); // ======================= // 1. 每个对象都是相同的show Season1 summer = Season1.SUMMER; summer.show(); // 这是一个季节！ // 2. 每个对象都有自己的show Season1.SPRING.show(); Season1.SUMMER.show(); Season1.AUTUMN.show(); Season1.WINTER.show();} 使用enum定义枚举类之后，如何让枚举类对象分别实现接口： 实现接口，在枚举类中实现抽象方法 让枚举类对象分别实现接口中的抽象方法 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 2. 使用enumenum Season1 implements Info{ //1.提供当前枚举类的对象，多个对象之间用\",\"隔开，末尾对象\";\"结束 SPRING(\"春天\",\"春暖花开\"){ @Override public void show() { System.out.println(\"春天在哪里！\"); } }, SUMMER(\"夏天\",\"夏日炎炎\"){ @Override public void show() { System.out.println(\"夏天在哪里！\"); } }, AUTUMN(\"秋天\",\"秋高气爽\"){ @Override public void show() { System.out.println(\"秋天在哪里！\"); } }, WINTER(\"冬天\",\"冰天雪地\"){ @Override public void show() { System.out.println(\"冬天在哪里！\"); } }; //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; private Season1(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } //4.其他诉求1：提供toString() @Override public String toString() { return \"Season{\" + \"seasonName='\" + seasonName + '\\'' + \", seasonDesc='\" + seasonDesc + '\\'' + '}'; } @Override public void show() { System.out.println(\"这是一个季节！\"); }} ¶三、注解 JDK5.0 新增的功能！ 框架 = 注解 + 反射机制 + 设计模式 ¶1、注解概述 Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 ¶2、注解的作用 生成文档相关的注解 在编译时进行格式检查(JDK内置的几个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 跟踪代码依赖性，实现替代配置文件功能 12345678910111213141516@Testpublic void test1(){ // @Deprecated Date date = new Date(2021, 2, 3); // 灰色是一个未使用的警告 int i1 = 10; // 这样就变黑了，编译将不会再有警告 @SuppressWarnings(\"unused\") int i2 = 10; // 表示未使用和未使用泛型 @SuppressWarnings({\"unused\", \"rawtypes\"}) ArrayList arrayList = new ArrayList();} ¶3、自定义注解 参照@SuppressWarnings定义！ 注解声明为：@interface 内部定义成员，通常使用value表示 可以指定成员的默认值，使用default定义 如果自定义注解没成员，表明是一个标识作用。 说明： 如果注解有成员，在使用注解时，需要指明成员的值。 自定义注解必须配上注解的信息处理流程(使用反射)才意义。 自定义注解通常都会指明两个元注解：Retention、Target 123456789101112131415161718192021222324// 自定义注解@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE, TYPE_PARAMETER, TYPE_USE})@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation{ // 1. 可以没有成员变量，没有则表名是一个标识 // 2. 声明成员变量，可以使用default定义默认值 String value() default \"hello\"; // 3. 也可定义为数组，表示参数为多个// String[] value1();}@Testpublic void test2(){ // 自定义注解若有成员，必须显示赋值（default除外） @MyAnnotation(value = \"hi\") int n = 10; // 提供了默认值，可以不写值 @MyAnnotation int m = 10;} ¶4、JDK中的四种元注解 对现有的注解进行解释说明的注解！ 后两种不常用。前两种常用，一般自定义注解都要有后两种！ Retention：指定所修饰的 Annotation 的生命周期：SOURCE\\CLASS（默认行为)\\RUNTIME，只有声明为RUNTIME生命周期的注解，才能通过反射获取。 RetentionPolicy.SOURCE：在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注解 RetentionPolicy.CLASS：在class文件中有效（即class保留） ，当运行 Java 程序时, JVM不会保留注解。 这是默认值 RetentionPolicy.RUNTIME：在运行时有效（即运行时保留），当运行 Java 程序时, JVM会保留注解。程序可以通过反射获取该注解 Target：用于指定被修饰的 Annotation 能用于修饰哪些程序元素 Documented：表示所修饰的注解在被javadoc解析时，保留下来。 Inherited：被它修饰的 Annotation 将具继承性。（解释：即父类使用了带有Inherited的注解，子类自动具有该注解） Target注解的课取值： ¶5、JDK8中的新注解 ¶5.1、可重复注解@Repeatable 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 1234567891011121314151617181920212223242526272829303132333435363738// JDK8之前实现方式：数组@interface MyAnnotation{ String value() default \"hello\";}@interface MyAnnotations{ MyAnnotation[] value();}// 使用@MyAnnotations({@MyAnnotation(value = \"aa\"), @MyAnnotation(value = \"bb\")})class Person{}/****************************************************************/// JDK8之中实现方式：@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE, TYPE_PARAMETER, TYPE_USE})@Retention(RetentionPolicy.RUNTIME)// 多一个该注解：@Repeatable(MyAnnotations.class)@interface MyAnnotation{ String value() default \"hello\";}@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE, TYPE_PARAMETER, TYPE_USE})@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotations{ MyAnnotation[] value();}// 使用：@MyAnnotation(value = \"aa\")@MyAnnotation(value = \"bb\")class Person{} ¶5.2、类型注解 在target的属性中加入该类型即可！ ElementType.TYPE_PARAMETER ：表示该注解能写在类型变量的声明语句中，如：泛型声明 ElementType.TYPE_USE ：表示该注解能写在使用类型的任何语句中。 1234567891011// 类型注解一：TYPE_PARAMETER 能写在类型变量的声明语句中，可以修饰泛型！// 在target的属性中加入该类型即可！class P&lt;@MyAnnotation T&gt;{ // 类型注解二：TYPE_USE 能写在使用类型的任何语句中！ // 在target的属性中加入该类型即可！ public void show()throws @MyAnnotation Exception{ int i = (@MyAnnotation int) 111L; ArrayList&lt;@MyAnnotation String&gt; list = new ArrayList&lt;&gt;(); }} ¶四、集合 集合概述： Collection：单列集合 List：存储序的、可重复的数据（JDK1.2） ArrayList：线程不安全的，效率高，底层使用Object[] elementData存储。（JDK1.2） LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高，底层使用双向链表存储。（JDK1.2） Vector：作为List接口的古老实现类，线程安全的，效率低，底层使用Object[] elementData存储。（JDK1.0） Set：存储无序的、不可重复的数据（JDK1.2） HashSet：线程不安全的，可以存储null值（JDK1.2） LinkedHashSet：HashSet的子类，HashSet基础上加了双链表，可按序遍历。对于频繁的插入、删除操作，使用此类效率比HashSet高。（JDK1.4） TreeSet：可以照添加对象的指定属性，进行排序。（JDK1.2） Map：双列数据，存储key-value对的数据（JDK1.2） HashMap：线程不安全的，效率高。可存储null的key和value（JDK1.2） LinkedHashMap：HashMap的子类，HashMap基础上加了双链表，可按序遍历。对于频繁的插入、删除操作，使用此类效率比HashMap高（JDK1.4） TreeMap：可按key进行自然排序或定制排序。（JDK1.2） Hashtable：作为古老的实现类，线程安全的，效率低，不能存储null的key和value。（JDK1.0） Properties：常用来处理配置文件。key和value都是String类型。（JDK1.0） ¶1、List源码分析 ¶1.1、ArrayList JDK7中的ArrayList的对象的创建类似于单例的饿汉式，而JDK8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。 JDK7中： ArrayList list = new ArrayList()：底层创建了长度是10的Object[]数组elementData 扩容：默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中 开发中建议：使用带参的构造器：ArrayList list = new ArrayList(int capacity) JDK8中： ArrayList list = new ArrayList()：底层Object[] elementData初始化为{}，并没创建长度为10的数组 第一次调用add()时，底层才创建了长度10的数组，并将数据添加到elementData[0] ¶1.2、LinkedList LinkedList list = new LinkedList()：内部声明了Node类型的first和last属性，默认值为null list.add(123)：将123封装到Node中，创建了Node对象。 其中Node静态内部类长这样： 体现了LinkedList的双向链表的说法！ 1234567891011private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; }} ¶1.3、Vector 在多线程问题中，即使vector是线程安全的，也不去用它，而去用Collections工具类的SynchronizedList方法去将ArrayList扔进去返回的就是线程安全的集合！ JDK7和JDK8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组 扩容方面：默认扩容为原来的数组长度的2倍。 ¶2、Set源码分析 关于存储数据无序的、不可重复的说明： 无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。 不可重复性：保证添加的元素照equals()判断时，不能返回true即：相同的元素只能添加一个。 因此，HashSet和LinkedHashSet存储对象所在类的要求： 向Set（主要指：HashSet、LinkedHashSet）中添加的数据，其所在的类一定要重写hashCode()和equals() 重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码 重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算hashCode值。 Set接口中没额外定义新的方法，使用的都是Collection中声明过的方法！ 三个实现类底层都是以Map存储的，详细的请看下一节的Map源码分析！ ¶2.1、HashSet 七上八下存储： JDK 7 ：元素a放到数组中，指向原来的元素。 JDK 8 ：原来的元素在数组中，指向元素a HashSet元素添加过程： 我们向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置)，判断数组此位置上是否已经元素： 如果此位置上没其他元素，则元素a添加成功。 —&gt;情况1 如果此位置上其他元素b(或以链表形式存在的多个元素)，则比较元素a与元素b的hash值： 如果hash值不相同，则元素a添加成功。—&gt;情况2 如果hash值相同，进而需要调用元素a所在类的equals()方法： equals()返回true,元素a添加失败。 equals()返回false,则元素a添加成功。—&gt;情况3 HashSet底层实际是用HashMap存储的： 具体细节在下面Map源码分析中详解！ 12345private transient HashMap&lt;E,Object&gt; map;public HashSet() { map = new HashMap&lt;&gt;();} ¶2.2、LinkedHashSet 继承自HashSet，同样底层实际使用LinkedHashMap存储！ 再添加数据的同时，维护了两个变量存储前后数据位置，类似双链表方式维护！ 具体在HashMap中详细讲解！ ¶2.3、TreeSet 向TreeSet中添加的数据，要求是相同类的对象。 两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator） 底层仍然是使用的TreeMap存储 ¶3、Map源码分析 Map中的key：无序的、不可重复的，使用Set存储所的key —&gt; key所在的类要重写equals()和hashCode() Map中的value：无序的、可重复的，使用Collection存储所的value —&gt;value所在的类要重写equals() 一个键值对：key-value构成了一个Entry对象。 Map中的entry：无序的、不可重复的，使用Set存储所的entry ¶3.1、HashMap JDK7中： HashMap map = new HashMap()： 在实例化以后，底层创建了长度是16的一维数组Entry[] table map.put(key1,value1)： 首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。 如果此位置上的数据为空，此时的key1-value1添加成功。 ---- 情况1 如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值： 如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。---- 情况2 如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较： 如果equals()返回false:此时key1-value1添加成功。---- 情况3 如果equals()返回true:使用value1替换value2。 补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。 在不断的添加过程中，会涉及到扩容问题：当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。 JDK8中与之前的不同之处： new HashMap()：底层没创建一个长度为16的数组 JDK8底层的数组是：Node[],而非Entry[] 首次调用put()方法时，底层创建长度为16的数组 JDK7底层结构：数组+链表。jdk8底层结构：数组+链表+红黑树。 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素） 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。 HashMap底层典型属性的属性的说明： DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 DEFAULT_LOAD_FACTOR：HashMap的默认负载因子：0.75 threshold：扩容的临界值 = 容量 * 填充因子`：16 * 0.75 =&gt; 12 TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树，8 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量，64 UNTREEIFY_THRESHOLD ：Bucket中红黑树存储的Node小于该默认值，转化为链表 MIN_TREEIFY_CAPACITY ：桶中的Node被树化时最小的hash表容量。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。） 负载因子（填充比）的作用： 负载因子的大小决定了HashMap的数据密度。 负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。 负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。 按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数 ¶3.2、LinkedHashMap LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap. 区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node. 123456789101112131415161718192021static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; }}static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); }} ¶3.3、TreeMap 向TreeMap中添加key-value，要求key必须是由同一个类创建的对象！ 照key进行排序：自然排序 、定制排序 ¶3.4、Properties 是Hashtable的子类常用来处理配置文件。key和value都是String类型！ 本测试不放到main中找不到配置文件！ 配置文件中文乱码：打开IDEA设置的file encoding 中的Properties的勾勾！并且删掉原配置文件重新新建！ 配置文件新建方式：选择Resource Bundle写入文件名回车即可！ 配置文件中不要有空格！ 123456789101112131415161718192021222324public static void main(String[] args){ FileInputStream fis = null; try { Properties pros = new Properties(); // 加载配置文件到流 fis = new FileInputStream(\"test.properties\"); pros.load(fis); String name = pros.getProperty(\"name\"); String password = pros.getProperty(\"password\"); System.out.println(name + \" \" + password); } catch (IOException e) { e.printStackTrace(); } finally { if(fis != null){ try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } }} ¶五、泛型 JDK5.0新增！ ¶1、泛型注意事项 泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass&lt;E&gt;(){} 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。 泛型不同的引用不能相互赋值：尽管在编译时ArrayList&lt;String&gt;和ArrayList&lt;Integer&gt;是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。 经验：泛型要使用一路都用。要不用，一路都不要用。 jdk1.7，泛型的简化操作：ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;&gt;(); 泛型的指定中不能使用基本数据类型，可以使用包装类替换 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。（静态方法在类创建时加载时，但此时还没有造对象，T并不清楚） 异常类不能是泛型的 try catch(T e)也不行！ 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity];参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型： 子类不保留父类的泛型：按需实现 2. 没有类型 擦除 2. 具体类型 子类保留父类的泛型：泛型子类 全部保留 部分保留 关于第10点的说明： 防止晕头转向，这里稍微总结一下：看每种情况后面的泛型！ 123456789101112131415161718192021222324252627282930313233class Father&lt;T1, T2&gt; {}// 子类不保留父类的泛型// 1)没有类型 擦除：&lt;Object,Object&gt;class Son1 extends Father {// 等价于class Son extends Father&lt;Object,Object&gt;{}// 2)具体类型：&lt;Integer, String&gt;class Son2 extends Father&lt;Integer, String&gt; {}// 子类保留父类的泛型 // 1)全部保留：&lt;任意类型1, 任意类型2&gt;class Son3&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; {}// 2)部分保留：&lt;Integer, 任意类型2&gt;class Son4&lt;T2&gt; extends Father&lt;Integer, T2&gt; {}//====================================================================================// 子类不保留父类的泛型// 1)没有类型 擦除：&lt;Object,Object&gt;class Son&lt;A, B&gt; extends Father{//等价于class Son extends Father&lt;Object,Object&gt;{}// 2)具体类型：默认为&lt;Integer, String&gt;，但子类泛型若指定，父类泛型失效class Son2&lt;A, B&gt; extends Father&lt;Integer, String&gt; {}// 子类保留父类的泛型// 1)全部保留：&lt;任意类型1, 任意类型2，任意类型3，任意类型4&gt;class Son3&lt;T1, T2, A, B&gt; extends Father&lt;T1, T2&gt; {}// 2)部分保留：&lt;Ingeter, 任意类型2，任意类型3，任意类型4&gt;class Son4&lt;T2, A, B&gt; extends Father&lt;Integer, T2&gt; {} ¶2、泛型方法 泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。 换句话说，泛型方法所属的类是不是泛型类都没关系。 泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。 ¶2.1、格式 1[ 访问权限] &lt; 泛型&gt; 型 返回类型 名 方法名([ 泛型标识 称 参数名称]) 抛出的异常 ¶2.2、举例 123456789101112131415161718// &lt;E&gt;：作用：表名E是一个泛型而不是一个类！public &lt;E&gt; List&lt;E&gt; copyArrayFromList(E[] arr){ ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); for(E e : arr){ list.add(e); } return list;}@Testpublic void test5(){ Person&lt;String&gt; p = new Person&lt;&gt;(); Integer[] integer = new Integer[] {1, 2, 3, 4}; // 泛型方法调用时，指明泛型参数类型 List&lt;Integer&gt; list = p.copyArrayFromList(integer); System.out.println(list); // [1, 2, 3, 4]} ¶3、泛型在继承方面体现 虽然类A是类B的父类，但是G&lt;A&gt; 和G&lt;B&gt;二者不具备子父类关系，二者是并列关系。 补充：类A是类B的父类（或接口），A&lt;G&gt; 是 B&lt;G&gt; 的父类 1234567891011121314151617@Testpublic void test6(){ ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); // 编译错误：二者内存上指向同一个地址，对list1的操作会导致list2也修改，会产生类型不一致问题！ // list1 = list2; List&lt;String&gt; list3 = null; AbstractList&lt;String&gt; list5 = null; ArrayList&lt;String&gt; list4 = null; // 编译通过： list3 = list4;` list5 = list4;} ¶4、通配符使用 通配符：? 类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;是没关系的，二者共同的父类是：G&lt;?&gt; 限制条件的通配符的使用： ? extends A: 上界是A。 G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类 ? super A: 下界是A 。G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Testpublic void test7(){ ArrayList&lt;Object&gt; list1 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); ArrayList&lt;?&gt; list = new ArrayList&lt;&gt;(); // 可赋值！ list = list1; list = list2; show(list); // 允许读不允许写： // list.add(\"AA\"); // 不允许写：null除外（任何类型都可以使用null赋值） list.add(null); // 允许读：返回为Object（任何类型父类都是Object） Object o = list.get(0); ArrayList&lt;? extends Person&gt; list3 = null; ArrayList&lt;? super Person&gt; list4 = null; ArrayList&lt;Person&gt; list5 = null; ArrayList&lt;Sons&gt; list6 = null; ArrayList&lt;Object&gt; list7 = null; // ========================= // 父类接收子类 list3 = list5; list3 = list6; // list3 = list7; // 父类接收子类 list4 = list5; // list4 = list6; list4 = list7; // 读取数据举例：都是拿上界去接受即可！ Person p = list3.get(0); Object o1 = list4.get(0); // 写入数据举例： // 编译错误：list3就是继承自Person的子类，但并不明确是哪个子类，无法放入数据！ // list3.add(new Person()); // 编译正确：list4是Person的父类，自然可以放入Person及其子类！ list4.add(new Person()); list4.add(new Sons());}public void show(List&lt;?&gt; list){ Iterator&lt;?&gt; iterator = list.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://www.itnxd.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"泛型","slug":"泛型","permalink":"https://www.itnxd.cn/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"StringBuilder","slug":"StringBuilder","permalink":"https://www.itnxd.cn/tags/StringBuilder/"},{"name":"StringBuffer","slug":"StringBuffer","permalink":"https://www.itnxd.cn/tags/StringBuffer/"},{"name":"枚举类","slug":"枚举类","permalink":"https://www.itnxd.cn/tags/%E6%9E%9A%E4%B8%BE%E7%B1%BB/"},{"name":"集合","slug":"集合","permalink":"https://www.itnxd.cn/tags/%E9%9B%86%E5%90%88/"}],"author":"ITNXD"},{"title":"再学Java之面向对象与异常","slug":"再学Java之面向对象与异常","date":"2021-02-15T05:09:23.000Z","updated":"2021-02-17T13:34:31.204Z","comments":true,"path":"posts/6640.html","link":"","permalink":"https://www.itnxd.cn/posts/6640.html","excerpt":"","text":"这里仅记录我认为没有了解透彻的知识，并不很全面系统，仅用于自己的查漏补缺！不过，我相信我没写的大家都是了解清楚的！ ¶一、面向对象学习的三条主线 Java类及类的成员：属性、方法、构造器；代码块、内部类 面向对象的大特征：封装性、继承性、多态性、(抽象性) 其它关键字：this、super、static、final、abstract、interface、package、import等 ¶二、零零碎碎 ¶1、可变个数形参 JDK 5.0新增的内容： 可变个数形参的格式：数据类型 ... 变量名 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个，2个，。。。 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。 可变个数形参在方法的形参中，必须声明在末尾 可变个数形参在方法的形参中，最多只能声明一个可变形参。 ¶2、方法重载 参数个数或者参数类型不同即可！ ¶3、Eclipse的Junit单元测试 步骤： 选中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步 创建Java类，进行单元测试。 此时的Java类要求： 此类是public的 此类提供公共的无参的构造器 ¶4、包装类 ¶4.1、八种基本数据类型对应的包装类 ¶4.2、基本数据类型、包装类、String的转换 基本数据类型 —&gt; 包装类 ：调用包装类的构造器 包装类 —&gt; 基本数据类型 ：调用包装类的Xxx的xxxValue()方法 基本数据类型 &lt;—&gt; 包装类：JDK 5.0 新特性：自动装箱 与自动拆箱 基本数据类型、包装类 —&gt; String: 调用String重载的valueOf(Xxx xxx) 可能会报NumberFormatException异常！ String —&gt; 基本数据类型、包装类: 调用包装类的parseXxx(String s) ¶4.3、包装类注意点 123456789101112131415161718192021222324@Testpublic void test6() { // 注意点一： // 三元运算符要保证两个表达式一致，例如int和String就会编译出错。 // 这里相当于自动向上转型，都按照Double进行比较了！ Object obj = true ? new Integer(1) : new Double(2.0); System.out.println(obj); // 1.0 // 注意点二： // Integer类内部有一个IntegerCache的结构，定义了一个缓存数组，存储-128 ~ 127的数，因为最常用， // 从缓存加载可以提高速度！ // 所以Integer自动装箱的数如果在上述范围，则取到的是同一个地址！ Integer in1 = new Integer(1); Integer in2 = new Integer(1); System.out.println(in1 == in2); // false Integer in3 = 1; Integer in4 = 1; System.out.println(in3 == in4); // true Integer in5 = 128; Integer in6 = 128; System.out.println(in5 == in6); // false} ¶三、面向对象 ¶1、四种权限修饰符 4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类。 修饰类的话，只能使用：缺省、public 四种权限修饰符的具体修饰范围： ¶2、JavaBean使用 所谓JavaBean，是指符合如下标准的Java类,是java语言的可重用组件： 类是公共的 一个无参的公共的构造器 属性，且对应的`get、set`方法 123456789101112public class JavaBeanTest { String name; public JavaBeanTest() { } public void setName(String s) { name = s; } public String getName() { return name; }} ¶3、this关键字 this修饰：属性、方法、构造器 this不能调用自己本身的构造器！（this无法递归。。。) 注意点： 我们在类的构造器中，可以显式的使用this(形参列表)方式，调用本类中指定的其他构造器 构造器中不能通过this(形参列表)方式调用自己 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了this(形参列表) 规定：this(形参列表)必须声明在当前构造器的首行 构造器内部，最多只能声明一个this(形参列表)，用来调用其他的构造器 ¶4、super关键字 super修饰：属性、方法、构造器 super调用属性、方法： 我们可以在子类的方法或构造器中。通过使用super.属性或super.方法的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略super. 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用super.属性的方式，表明调用的是父类中声明的属性。 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用super.方法的方式，表明调用的是父类中被重写的方法。 super调用构造器： 我们可以在子类的构造器中显式的使用super(形参列表)的方式，调用父类中声明的指定的构造器 super(形参列表)的使用，必须声明在子类构造器的首行！ 我们在类的构造器中，针对于this(形参列表)或super(形参列表)只能二选一，不能同时出现 在构造器的首行，没显式的声明this(形参列表)或super(形参列表)，则默认调用的是父类中空参的构造器：super() 在类的多个构造器中，至少一个类的构造器中使用了super(形参列表)，调用父类中的构造器 ¶5、import关键字 在源文件中显式的使用import结构导入指定包下的类、接口 声明在包的声明和类的声明之间 如果需要导入多个结构，则并列写出即可 可以使用xxx.的方式，表示可以导入xxx包下的所结构 如果使用的类或接口是java.lang包下定义的，则可以省略import结构 如果使用的类或接口是本包下定义的，则可以省略import结构 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。 使用xxx.*方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入 import static：导入指定类或接口中的静态结构：属性或方法。 ¶6、面向对象的继承性 ¶6.1、子类继承父类的不同 特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。 ¶6.2、方法重写 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 **特殊情况**：子类不能重写父类中声明为`private`权限的方法 **返回值类型**： * 父类被重写的方法的返回值类型是`void`，则子类重写的方法的返回值类型只能是`void` * 父类被重写的方法的返回值类型是`A`类型，则子类重写的方法的返回值类型可以是`A`类或`A`类的子类 * 父类被重写的方法的返回值类型是基本数据类型(比如：`double`)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是`double`) 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写))。 ¶6.3、重载与重写 对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为**“早绑定”或“静态绑定”** 而对于重写（即多态），只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为**“晚绑定”或“动态绑定”** ¶7、面向对象的多态性 ¶7.1、多态性的使用 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法！ 但在运行期，我们实际执行的是子类重写父类的方法。 虚拟方法调用：调用父子类同名方法，实际执行的是子类重写父类的方法！此时父类方法称为虚拟/虚方法 总结：编译，看左边；运行，看右边。（编译在父类，运行在子类） ¶7.2、多态性的使用前提 类的继承关系 方法的重写 ¶7.3、多态性使用的注意点 对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边） ¶7.4、多态是编译时行为还是运行时行为？ 运行时行为（只有在运行才能真正确定是哪个对象！） ¶7.5、向下转型 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。 解决方法：向下转型！ 注意点： 使用强转时，可能出现`ClassCastException`的异常。 为了避免在向下转型时出现`ClassCastException`的异常，我们在向下转型之前，先进行`instanceof`的判断，一旦返回`true`，就进行向下转型。如果返回`false`，不进行向下转型。 ¶8、static关键字 static修饰：属性、方法、代码块、内部类 补充：栈（局部变量），堆（new出来的结构），方法区（类的加载信息，静态域，常量池） ¶8.1、static修饰属性 属性，是否使static修饰，又分为：静态属性 vs 非静态属性(实例变量) static修饰属性的其他说明： 静态变量随着类的加载而加载。可以通过类.静态变量的方式进行调用 静态变量的加载要早于对象的创建。 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。 ¶8.2、static修饰方法：静态方法、类方法 随着类的加载而加载，可以通过类.静态方法的方式进行调用 静态方法中，只能调用静态的方法或属性 ¶8.3、static的注意点 在静态的方法内，不能使用this关键字、super关键字，关于静态属性和静态方法的使用，大家都从生命周期的角度去理解！ ¶8.4、使用static关键字 关于属性： 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。 类中的常量也常常声明为static 关于方法： 操作静态属性的方法，通常设置为static的 **工具类中的方法，习惯上声明为`static`的。** 比如：`Math、Arrays、Collections` ¶9、代码块使用 代码块的作用：用来初始化类、对象的信息 分类：代码块要是使用修饰符，只能使用static。静态代码块 vs 非静态代码块 静态代码块： 内部可以输出语句 随着类的加载而执行,而且只执行一次 作用：初始化类的信息 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行 静态代码块的执行要优先于非静态代码块的执行 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构 非静态代码块： 内部可以输出语句 随着对象的创建而执行 每创建一个对象，就执行一次非静态代码块 作用：可以在创建对象时，对对象的属性等进行初始化 如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法 ​ 简单补充：类内不能直接对属性进行操作，但可以将其放到代码块内进行初始化！ 实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序： 由父及子，静态先行。 属性的赋值顺序： ① 默认初始化 ② 显式初始化 / ⑤在代码块中赋值（谁在前谁先执行，后覆盖前） ③ 构造器中初始化 ④ 有了对象以后，可以通过\"对象.属性\"或\"对象.方法\"的方式，进行赋值 执行的先后顺序：① - ② / ⑤ - ③ - ④ ¶10、final关键字 final修饰：类、方法、变量 修饰类:此类不能被其他类所继承。 修饰方法：表明此方法不可以被重写 修饰变量：此时的\"变量\"就称为是一个常量 修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化 修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。 static final 用来修饰属性：全局常量 ¶11、abstract关键字 abstract修饰：类、方法 ¶11.1、abstract修饰类：抽象类 此类不能实例化 抽象类中一定有构造器，便于子类实例化时调用 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 抽象的使用前提：继承性 ¶11.2、abstract修饰方法：抽象方法 抽象方法只方法的声明，没方法体 包含抽象方法的类，一定是一个抽象类。反之，**抽象类中可以没有抽象方法的。** 若子类重写了父类中的所的抽象方法后，此子类方可实例化 若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用`abstract`修饰 ¶11.3、abstract注意点： `abstract`不能用来修饰：属性、构造器等结构 `abstract`不能用来修饰私有方法、静态方法、`final`的方法、`final`的类 补充：abstract 和 final水火不容！ 12345678910111213141516171819// 抽象类abstract class Person{ String name; int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public void show() { System.out.println(\"show()...\"); } // 抽象方法： public abstract void eat();} ¶11.4、抽象类的匿名类 目的：只用一次该抽象类的子类，无需再使用class编写，而是用完就销毁，方便！ 12345678910111213141516171819202122232425public static void main(String[] args) { Son son = new Son(); method(son); // 非匿名的类，非匿名的对象！ method(new Son()); // 非匿名的类，匿名的对象 // 1. 抽象类的匿名类：创建了一个匿名子类的对象，多态性，由父类Person接收 Person p = new Person() { @Override public void eat() { System.out.println(\"匿名类...\"); } }; // 多态性... method(p); // 2. 直接在方法内部使用时进行匿名编写 // 匿名的类，匿名的对象 method(new Person() { @Override public void eat() { System.out.println(\"匿名类...\"); } });} ¶12、interface关键字 Java中，接口和类是并列的两个结构！ ¶12.1、接口中可定义的成员 JDK7及以前：只能定义全局常量和抽象方法 全局常量：`public static final`的，但是书写时，**可以省略不写** 抽象方法：`public abstract`的，但是书写时，**可以省略不写** 接口中不能定义构造器的！意味着接口不可以实例化 123456789interface Flyable{ public static final int MAX_SPEED = 7900; // 系统自动添加：public static final int MIN_SPEED = 1; public abstract void fly(); // 系统自动添加：public abstract void stop();} ¶12.2、其他注意点 如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化 如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类 Java类可以实现多个接口 接口与接口之间可以继承，而且可以多继承 接口，实际上可以看做是一种规范 123456789101112// 接口之间可以继承！interface AA{}interface BB{}interface CC extends AA, BB{} ¶12.3、Java8中关于接口的新规范 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法 知识点1：接口中定义的静态方法，只能通过接口来调用。 知识点2：通过实现类的对象，可以调用接口中的默认方法。 如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法 知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法， 那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt; **类优先原则** 知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法， 那么在实现类没重写此方法的情况下，报错。--&gt; **接口冲突。**这就需要我们必须在实现类中重写此方法 知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法？ 123456789101112131415161718192021222324252627282930interface AAA{ public static void method1() { System.out.println(\"静态方法一\"); } public default void method2() { System.out.println(\"默认方法二\"); } // 默认就是public，省略不写 default void method3() { System.out.println(\"默认方法二\"); }}class SuperClass{ public void method3() { System.out.println(\"SuperClass\"); }}class BBB extends SuperClass implements AAA{ public void method() { // 调用父类方法 super.method3(); // 接口调用静态方法 AAA.method1(); // 接口调用非静态方法 AAA.super.method2(); AAA.super.method3(); }} ¶13、内部类 ¶13.1、内部类的分类 成员内部类（静态、非静态 ） 局部内部类(方法内、代码块内、构造器内) ¶13.2、成员内部类的使用 一方面，作为外部类的成员： 调用外部类的结构 可以被`static`修饰 可以被4种不同的权限修饰 另一方面，作为一个类： 类内可以定义属性、方法、构造器等 可以被`final`修饰，表示此类不能被继承。言外之意，不使用`final`，就可以被继承 可以被`abstract`修饰 ¶13.3、局部内部类的使用 注意点： 在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num) 的话,要求此局部变量声明为final的。 jdk 7及之前版本：要求此局部变量显式的声明为final的 jdk 8及之后的版本：可以省略final的声明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class InnerClassTest { public static void main(String[] args) { // 4.1 如何创建成员内部类的对象？(静态的，非静态的) // 静态： Person.Dog dog = new Person.Dog(); dog.show(); // 非静态： // Person.Bird bird = new Person.Bird(); 错误 Person p = new Person(); Person.Bird bird = p.new Bird(); bird.sing(); bird.display(\"333\"); } // 第6点解释：相当于InnerClassTest和两个AA两个字节码文件，互相独立 public void method() { // 局部变量：实际为final int num = 10; class AA{ // 此时num相当于局部变量num的副本 // num = 20; 错误，不能修改 public void show() { System.out.println(num); } } }}class Person{ String name = \"111\"; int age; public void eat() { System.out.println(\"人吃饭\"); } // 静态成员内部类： static class Dog{ String name; int age; public void show() { System.out.println(\"狗子\"); } } // 非静态成员内部类： class Bird{ String name = \"222\"; public Bird() { } // 4.2 如何在成员内部类中调用外部类的结构？ public void sing() { // 1.调用外部类的非静态属性一 eat(); // 2.调用外部类的非静态属性二 Person.this.eat(); } public void display(String name) { System.out.println(name); // 形参 System.out.println(this.name); // 内部类属性 System.out.println(Person.this.name); // 外部类属性 } } // 局部内部类： public Person() { class AA{ } } public void show() { class BB{ } } { class CC{ } } // ========================================================= // 局部内部类的使用： //返回一个实现了Comparable接口的类的对象 public Comparable getComparable() { //创建一个实现了Comparable接口的类:局部内部类 //方式一： class MyComparable implements Comparable{ @Override public int compareTo(Object o) { return 0; } } // return new MyComparable(); // 方法二：创建了一个实现该接口的匿名实现类的匿名对象 return new Comparable() { @Override public int compareTo(Object o) { // TODO Auto-generated method stub return 0; } }; }} ¶13.4、总结 成员内部类和局部内部类，在编译以后，都会生成字节码文件： 格式： 员内部类：外部类$内部类名.class 局部内部类：`外部类$数字 内部类名.class` ¶四、异常 ¶1、异常体系结构 1234567891011121314java.lang.Throwable |-----java.lang.Error:一般不编写针对性的代码进行处理。 |-----java.lang.Exception:可以进行异常的处理 |------编译时异常(checked) |-----IOException |-----FileNotFoundException |-----ClassNotFoundException |------运行时异常(unchecked,RuntimeException) |-----NullPointerException |-----ArrayIndexOutOfBoundsException |-----ClassCastException |-----NumberFormatException |-----InputMismatchException |-----ArithmeticException ¶2、如何自定义异常类？ 继承于现的异常结构：RuntimeException 、Exception 提供全局常量：serialVersionUID 提供重载的构造器 123456789public class MyException extends Exception{ static final long serialVersionUID = -338751699319999948L; public MyException() { } public MyException(String msg) { super(msg); }} ¶3、throw 和 throws区别 throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。 throws 属于异常处理的一种方式，声明在方法的声明处。 ¶4、注意点 catch中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓。 catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 常用的异常对象处理的方式： ① String getMessage() ② printStackTrace() ¶5、编译时异常和运行时异常 体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。 体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。 ¶6、开发中应该如何 如果父类中被重写的方法没throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理。 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://www.itnxd.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"author":"ITNXD"},{"title":"LeetCode刷题-130. 被围绕的区域","slug":"LeetCode刷题-130-被围绕的区域","date":"2020-08-08T15:16:17.000Z","updated":"2020-08-12T15:08:09.131Z","comments":true,"path":"posts/10602.html","link":"","permalink":"https://www.itnxd.cn/posts/10602.html","excerpt":"","text":"题目链接：130. 被围绕的区域 ¶题解： 经典的逆向思维算法，Flood Fill ¶题目简述： 给定一个二维矩阵只包含O和X，找到没有被包围的O用X填充。 ¶题解： 题目理解： 任何与边界的O相连的O都会被填充为X 任何与不与边界的O相连的O都不会被填充为X 逆向思维Flood Fill： 我们先将与边界上的O相连的O全部标记出来，即换一个字符例如# 此时除了X和#剩下的O就是需要被修改为X的了 只需一遍扫描即可，将O换为X，将#换为O 注意：vector为空的特判！ 时间复杂度：每个点最多遍历两次，为O(n^2) ¶AC代码： 123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;vector&lt;char&gt;&gt; board; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int n, m; void solve(vector&lt;vector&lt;char&gt;&gt;&amp; _board) { board = _board; if(board.empty() || board[0].empty()) return; n = board.size(), m = board[0].size(); for(int i = 0; i &lt; n; i++){ if(board[i][0] == 'O') dfs(i, 0); if(board[i][m - 1] == 'O') dfs(i, m - 1); } for(int i = 0; i &lt; m; i++){ if(board[0][i] == 'O') dfs(0, i); if(board[n - 1][i] == 'O') dfs(n - 1, i); } for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ if(board[i][j] == '#') board[i][j] = 'O'; else if(board[i][j] == 'O') board[i][j] = 'X'; } } _board = board; } void dfs(int x, int y){ board[x][y] = '#'; for(int i = 0; i &lt; 4; i++){ int a = x + dx[i], b = y + dy[i]; if(a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m &amp;&amp; board[a][b] == 'O') dfs(a, b); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"Flood Fill","slug":"Flood-Fill","permalink":"https://www.itnxd.cn/tags/Flood-Fill/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-129. 求根到叶子节点数字之和","slug":"LeetCode刷题-129-求根到叶子节点数字之和","date":"2020-08-08T15:16:05.000Z","updated":"2020-08-12T15:08:09.129Z","comments":true,"path":"posts/59814.html","link":"","permalink":"https://www.itnxd.cn/posts/59814.html","excerpt":"","text":"题目链接：129. 求根到叶子节点数字之和 ¶题解： 简单递归求解二叉树问题！ ¶题目简述： 给定一棵二叉树，求出所有从根节点到叶子节点构成的数的和！ ¶题解： 简单DFS： 从根节点开始搜索 当前节点为空直接返回 当前节点的左右儿子都不存在时即为叶子节点，进行累加当前和后返回 搜索左子树和右子树，值为sum * 10 + val 时间复杂度：每个节点遍历一次，为O(n) ¶AC代码： 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int res; int sumNumbers(TreeNode* root) { dfs(root, 0); return res; } void dfs(TreeNode* root, int sum){ if(!root) return; if(!root-&gt;left &amp;&amp; !root-&gt;right){ res += sum * 10 + root-&gt;val; return; } dfs(root-&gt;left, sum * 10 + root-&gt;val); dfs(root-&gt;right, sum * 10 + root-&gt;val); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-128. 最长连续序列","slug":"LeetCode刷题-128-最长连续序列","date":"2020-08-08T15:15:50.000Z","updated":"2020-08-12T15:08:09.123Z","comments":true,"path":"posts/44196.html","link":"","permalink":"https://www.itnxd.cn/posts/44196.html","excerpt":"","text":"题目链接：128. 最长连续序列 ¶题解： ¶题目简述： 给定一个无序序列，求最长连续序列长度！ 要求时间复杂度为：O(n) ¶题解： 哈希： 先将所有数存到哈希表 对于连续序列，我们可以从一个数开始，每次加一进行判断是否存在即可！ 为了保证不重复遍历，我们每次只枚举该连续区间的起始值即可，例如1 2 3 4，我们只枚举从1开始，而不枚举从2 3 4开始！即保证S.count(x) &amp;&amp; !S.count(x - 1! 每次更新最大值即可，区间长度为y - x + 1 注意： 对于重复数字特别多的时候，上述做法会造成所有重复数字的重复枚举，时间复杂度增大，为了解决该问题，我们可以将枚举过的数字全部删掉，这样可以保证所有数字只枚举一次！ 时间复杂度：所有数只枚举一次O(n) ¶AC代码： 1234567891011121314151617class Solution {public: int longestConsecutive(vector&lt;int&gt;&amp; nums) { unordered_set&lt;int&gt; S; for(auto x : nums) S.insert(x); int res = 0; for(auto x : nums){ if(S.count(x) &amp;&amp; !S.count(x - 1)){ int y = x; S.erase(x); while(S.count(y + 1)) y ++, S.erase(y); res = max(res, y - x + 1); } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-127. 单词接龙","slug":"LeetCode刷题-127-单词接龙","date":"2020-08-08T15:15:33.000Z","updated":"2020-08-12T15:08:09.126Z","comments":true,"path":"posts/25443.html","link":"","permalink":"https://www.itnxd.cn/posts/25443.html","excerpt":"","text":"题目链接：127. 单词接龙 ¶题解： 是上一道题的简化版，只需要记录方案数即可！ ¶题目简述： 和上一题一样，给定起始和终止单词和一个字典，求每次只能改变一个单词并且该单词存在于字典可以到达终止单词的方案数！ ¶题解： 具体见上一题： 可以通过博客上方搜索功能搜索或者使用文章下方上一篇按钮跳转！ 由于只需要记录方案数，所以我们只需要上一道题的最短路的过程即可，即只需要BFS并在中途计数既可！ 最终答案：if(t == endWord) return dist[t]; 时间复杂度：同样见上一题分析，为O(26nL^2 + nL)即O(nL^2) ¶AC代码： 12345678910111213141516171819202122232425262728class Solution {public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { unordered_set&lt;string&gt; S; unordered_map&lt;string, int&gt; dist; queue&lt;string&gt; q; q.push(beginWord); dist[beginWord] = 1; for(auto x : wordList) S.insert(x); while(q.size()){ auto s = q.front(); q.pop(); for(int i = 0; i &lt; s.size(); i++){ string t = s; for(char j = 'a'; j &lt;= 'z'; j++){ if(j == s[i]) continue; t[i] = j; if(S.count(t) &amp;&amp; dist.count(t) == 0){ dist[t] = dist[s] + 1; if(t == endWord) return dist[t]; q.push(t); } } } } return 0; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://www.itnxd.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-126. 单词接龙 II","slug":"LeetCode刷题-126-单词接龙-II","date":"2020-08-08T15:15:16.000Z","updated":"2020-08-12T15:08:09.121Z","comments":true,"path":"posts/48766.html","link":"","permalink":"https://www.itnxd.cn/posts/48766.html","excerpt":"","text":"题目链接：126. 单词接龙 II ¶题解： 是一道难题，DFS和BFS的结合使用！ ¶题目简述： 给定两个不一样的单词和一个字典，找到所有从一个单词到另一个单词的序列！ 单词的变化每次转换只能改变一个字母，字典中不一定存在起始单词！ ¶题解： 这道题本质是一道求最短路的问题：即从起始单词到结束单词的最短路，并且边权为一，可以使用BFS来求最短路！ 这道题不仅仅要求最短路的长度，而是要记录出所有最短路的路径，这里需要使用DFS来搜索路径！ 关于建图方法： 假设单词数为n，单词长度为L 枚举所有单词，判断两两单词（n^2）是否只有一位不同（L），为 n^2L 枚举每个单词，每个单词的每一位（26nL）判断是否只有一位不同，哈希表优化判断存在或使用过，为 26nL^2 简单计算： 当26L &lt; n 时，使用第二种，否则使用第一种，本题的数据为n &gt; 26L，所以要使用第二种，否则超时 进入正题！！！本题思路： DFS + BFS： 使用BFS来求一个dist数组，表示当前点到起始点的最短路径长度 使用第二种建图方式，即要枚举每一位的二十六种变化即可，若该点在字典中并且没有被遍历过，即S.count(t) &amp;&amp; dist.count(t) == 0，我们就进行遍历dist[t] = dist[s] + 1，正常宽搜顺序，将当前点加入队列即可！ 若搜到了终点，直接break，跳到上一层循环，防止搜索不必要的路径 通过dist数组来倒着DFS搜索到起点的路径即可 dfs(endWord) 对于最当前点s，只需要搜索可以到达改点的路径，即s的邻接点，并且只要保证dist[s] = dist[t] + 1即说明有一条从t到s的最短路径，当然我们要保证该点在字典中即dist.count(t) != 0 接下来继续向上搜索，直到起始单词，由于路径数组path是倒序存储的，所以搜到起点要将容器进行反转计入答案，完事之后再将其恢复 若BFS搜完发现最短路径数组dist中没有终点单词，即dist.count(endWord) == 0，说明字典中都没有终点单词或者通过字典中单词根本变不成终点单词，直接return，防止进行不必要的DFS 注意： 对于BFS的生成的单词是否在字典中的判断，采用了unordered_set来做，提前将其全部插入哈希表，判断为O(L) 对于DFS的生成的单词是否在字典中的判断，采用dist数组来做，为什么不采用BFS用到的S数组呢？因为字典中不一定有起始单词，而dist一定有 时间复杂度： 建图：见上面建图分析，为O(26nL^2) 最短路BFS：每个点遍历一次，每次需要O(L)进行判断字典中是否存在或使用过，总共为O(nL) 搜索路径DFS：路径数量是指数级别的，记录方案需要O(nL)，总共为O(2^n nL) 终上为：O(26nL^2 + nL + 2^n nL) = O(2^n nL) ¶AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; path; unordered_set&lt;string&gt; S; unordered_map&lt;string, int&gt; dist; string beginWord; queue&lt;string&gt; q; vector&lt;vector&lt;string&gt;&gt; findLadders(string _beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { beginWord = _beginWord; q.push(beginWord); dist[beginWord] = 0; for(auto x : wordList) S.insert(x); while(q.size()){ auto s = q.front(); q.pop(); for(int i = 0; i &lt; s.size(); i++){ string t = s; for(char j = 'a'; j &lt;= 'z'; j++){ if(j == t[i]) continue; t[i] = j; if(S.count(t) &amp;&amp; dist.count(t) == 0){ dist[t] = dist[s] + 1; if(t == endWord) break; q.push(t); } } } } if(dist.count(endWord) == 0) return res; path.push_back(endWord); dfs(endWord); return res; } void dfs(string s){ if(s == beginWord){ reverse(path.begin(), path.end()); res.push_back(path); reverse(path.begin(), path.end()); return; } for(int i = 0; i &lt; s.size(); i++){ string t = s; for(char j = 'a'; j &lt;= 'z'; j++){ if(j == s[i]) continue; t[i] = j; if(dist.count(t) &amp;&amp; dist[t] + 1 == dist[s]){ path.push_back(t); dfs(t); path.pop_back(); } } } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"最短路","slug":"最短路","permalink":"https://www.itnxd.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-125. 验证回文串","slug":"LeetCode刷题-125-验证回文串","date":"2020-08-08T15:15:04.000Z","updated":"2020-08-12T15:08:09.116Z","comments":true,"path":"posts/33082.html","link":"","permalink":"https://www.itnxd.cn/posts/33082.html","excerpt":"","text":"题目链接：125. 验证回文串 ¶题解： 简单回文串的验证！ ¶题目简述： 验证一个字符串是不是回文串，只考虑数字和大小写字母！ ¶题解： 简单双指针： 一个指针从前向后，一个指针从后向前 遇到不少字母和数字则向后或向前移动 由于题目忽略大小写的存在，我们将其全部转化为小写字母比较即可！ 注意： tolower() 和 toupper()：位于cctype或ctype.h头文件 时间复杂度：O(n) ¶AC代码： 1234567891011121314class Solution {public: bool check(char c){ return c &gt;= '0' &amp;&amp; c &lt;= '9' || c &gt;= 'a' &amp;&amp; c &lt;= 'z' || c &gt;= 'A' &amp;&amp; c &lt;= 'Z'; } bool isPalindrome(string s) { for(int i = 0, j = s.size() - 1; i &lt; j; i++, j--){ while(i &lt; j &amp;&amp; !check(s[i])) i++; while(i &lt; j &amp;&amp; !check(s[j])) j--; if(i &lt; j &amp;&amp; tolower(s[i]) != tolower(s[j])) return false; } return true; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-124. 二叉树中的最大路径和","slug":"LeetCode刷题-124-二叉树中的最大路径和","date":"2020-08-08T15:14:51.000Z","updated":"2020-08-12T15:08:09.112Z","comments":true,"path":"posts/20454.html","link":"","permalink":"https://www.itnxd.cn/posts/20454.html","excerpt":"","text":"题目链接：124. 二叉树中的最大路径和 ¶题解： 很是巧妙的递归求解路径问题！ ¶题目简述： 非空二叉树返回最大路径和！路径定义为从任意一个节点出发到任意一个节点序列！ ¶题解： 思考： 如何将所有路径遍历全面（注意：路径是任意点到任意点，不一定是要经过根节点或者叶子节点）！ 对于一条路径，该路径的最高点是一定的，所以我们来枚举它的最高点！ 对于该最高点的路径有几种情况：res = max(res, left + root-&gt;val + right) 根节点 根节点和左子树最大值 根节点和右子树最大值 根节点和左右子树最大值 对于计算左右子树的最大值： int dfs(TreeNode* root)：计算当前根节点的最大路径 return root-&gt;val + max(left, right)：返回根节点和左右子树最大值的和 left = max(0, dfs(root-&gt;left))：保证往下走是可以增大路径的，和0取一下max。若为负值，即不走当前路径 right = max(0, dfs(root-&gt;right))：同理 时间复杂度：每个节点遍历一次，为O(n) ¶AC代码： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int res; int maxPathSum(TreeNode* root) { res = INT_MIN; dfs(root); return res; } int dfs(TreeNode* root){ if(!root) return 0; int left = max(0, dfs(root-&gt;left)); int right = max(0, dfs(root-&gt;right)); res = max(res, left + root-&gt;val + right); return root-&gt;val + max(left, right); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-123. 买卖股票的最佳时机 III","slug":"LeetCode刷题-123-买卖股票的最佳时机-III","date":"2020-08-08T15:14:39.000Z","updated":"2020-08-12T15:08:09.108Z","comments":true,"path":"posts/15796.html","link":"","permalink":"https://www.itnxd.cn/posts/15796.html","excerpt":"","text":"题目链接：123. 买卖股票的最佳时机 III ¶题解： 上一题的再次进阶版！ ¶题目简述： 给定一个序列，从中选择两次交易（保证：后者大于前者，并且下一次交易前必须把当前股票卖出），求其最大值作为股票的最大利润！ 上上一题只能交易一次，上一题可以交易多次，这题只能交易两次！ ¶题解一：较好理解的 贪心 + 动态规划： 贪心解释： 将区间按每个点分为两部分，每部分计算一下只交易一次的最大收益，最终答案就是每个点分为的两部分和的最大值！ 状态表示： l和r数组分别表示区间为0 ~ i和i + 1 ~ n - 1交易一次的最大收益！ 状态计算： 对于l[i]：就是前面0 ~ i - 1的最小值和当前值的差 对于r[i]：就是后面i + 2 ~ n - 1的最大值与当前值的差 最终答案： max(res, l[i] + r[i]) 注意： l和r数组的区间范围 时间复杂度： O(n) 空间复杂度： O(n) ¶AC代码一： 123456789101112131415161718192021// i为第一段的末尾下标 0 ~ i i + 1 ~ n - 1class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); if(!n) return 0; vector&lt;int&gt; l(n + 1), r(n + 1); for(int i = 1, minv = prices[0]; i &lt; n; i++){ l[i] = max(l[i - 1], prices[i] - minv); minv = min(minv, prices[i]); } for(int i = n - 3, maxv = prices[n - 1]; i &gt;= 0; i--){ r[i] = max(r[i + 2], maxv - prices[i + 1]); maxv = max(maxv, prices[i + 1]); } int res = 0; for(int i = 0; i &lt; n; i++) res = max(res, l[i] + r[i]); return res; }}; ¶题解二：不太好理解的 思路算法和上面解法一完全一致，只是做了优化减少了一层循环！ 很明显：上面的更加直观明显，建议看上面题解一！ 题解一是枚举的是分界点，本题解枚举的分界点的含义是第二次交易的起点！ 为了方便区间改变了一下： 左边范围为0 ~ i - 1 右边范围为i ~ n - 1 所以，将该点作为第二次交易起点的情况就是：该点之前的最大交易和以该点为交易起点的最大交易的和取最大值！ 左边值为：l[i]，右边值为：maxv - prices[i] 所以最终答案为：max(res, l[i] + maxv - prices[i]) 注意： 唯一变化，枚举点的含义变了！ minv maxv初值选取要写对 时间复杂度： O(n) ¶AC代码二： 1234567891011121314151617181920// i为第二段的起始位置下标 0 ~ i - 1 i ~ n - 1class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); vector&lt;int&gt; l(n + 1); for(int i = 1, minv = INT_MAX; i &lt; n; i++){ l[i] = max(l[i - 1], prices[i - 1] - minv); minv = min(minv, prices[i - 1]); } int res = 0; for(int i = n - 1, maxv = 0; i &gt;= 0; i--){ res = max(res, l[i] + maxv - prices[i]); maxv = max(maxv, prices[i]); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"前后缀分解","slug":"前后缀分解","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E5%90%8E%E7%BC%80%E5%88%86%E8%A7%A3/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-122. 买卖股票的最佳时机 II","slug":"LeetCode刷题-122-买卖股票的最佳时机-II","date":"2020-08-08T15:14:26.000Z","updated":"2020-08-12T15:08:09.104Z","comments":true,"path":"posts/13431.html","link":"","permalink":"https://www.itnxd.cn/posts/13431.html","excerpt":"","text":"题目链接：122. 买卖股票的最佳时机 II ¶题解： 上一题的进化版！ ¶题目简述： 给定一个序列，从中选择多次两点（保证：后者大于前者，并且下一次交易前必须把当前股票卖出），求其最大值作为股票的最大利润！ 上一题只能交易一次，这题可以交易多次！ ¶题解： **贪心：**类似上一题 首先给出结论： 一个区间的交易可以拆分为单天的交易！ 证明： 1234假设i,j,k三点，i &lt; j &lt; k，对于区间[i, j],[j, k]，以及[i, k]，可以发现：他们的收益分别为 j - i + k - j 和 k - i会发现是一样的！所以：一个区间的收益，可以简化为每一天的收益和！ 要想使得股票收益最大，我们只需要将单天收益为正值的累加起来即可！即res += max(0, prices[i] - prices[i - 1]) 时间复杂度：O(n) ¶AC代码： 123456789class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int res = 0; for(int i = 1; i &lt; prices.size(); i++) res += max(0, prices[i] - prices[i - 1]); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-121. 买卖股票的最佳时机","slug":"LeetCode刷题-121-买卖股票的最佳时机","date":"2020-08-08T15:14:04.000Z","updated":"2020-08-12T15:08:09.095Z","comments":true,"path":"posts/45780.html","link":"","permalink":"https://www.itnxd.cn/posts/45780.html","excerpt":"","text":"题目链接：121. 买卖股票的最佳时机 ¶题解： 简单的贪心问题！ ¶题目简述： 给定一个序列，从中选择两点（保证：后者大于前者），求其最大值作为股票的最大利润！ ¶题解： 贪心： res表示0 ~ i区间的最大股票收益，minv表示该区间的最小值。 求最大值，则当前区间的最小值和当前区间的最后一个值的差自然就是该区间的最大股票收益了，遍历一遍该数组即可得到最大股票收益！ 得到1 ~ i - 1的最小值minv 做差即可：price[i] - minv 时间复杂度：O(n) ¶AC代码： 1234567891011class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int res = 0, minv = INT_MAX; for(int i = 0; i &lt; prices.size(); i++){ res = max(res, prices[i] - minv); minv = min(minv, prices[i]); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-120. 三角形最小路径和","slug":"LeetCode刷题-120-三角形最小路径和","date":"2020-08-07T14:10:33.000Z","updated":"2020-08-08T15:12:49.209Z","comments":true,"path":"posts/52215.html","link":"","permalink":"https://www.itnxd.cn/posts/52215.html","excerpt":"","text":"题目链接：120. 三角形最小路径和 ¶题解： 简单动态规划题！ ¶题目简述： 给定一个三角形，求自顶向下的最小路径！ ¶题解： 动态规划： 状态表示： 使用原数组f[i][j]表示该位置到达最底部的最小距离！ 状态计算： 只能移动到下一行正下方和右下方，所以该值为f[i][j] += min(f[i + 1][j], f[i + 1][j + 1])，即当前值加上从最下面到达当前层的下一层的距离！ 最终答案： f[0][0] 注意： 最后一行不必处理！处理也可以！ 时间复杂度：O(n^2) 空间复杂度：O(1) ¶AC代码： 12345678910class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; f) { int n = f.size(); for(int i = n - 2; i &gt;= 0; i--) for(int j = 0; j &lt;= i; j++) f[i][j] += min(f[i + 1][j], f[i + 1][j + 1]); return f[0][0]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-119. 杨辉三角 II","slug":"LeetCode刷题-119-杨辉三角-II","date":"2020-08-07T14:10:23.000Z","updated":"2020-08-08T15:02:00.697Z","comments":true,"path":"posts/50033.html","link":"","permalink":"https://www.itnxd.cn/posts/50033.html","excerpt":"","text":"题目链接：119. 杨辉三角 II ¶题解： 类似于上一个杨辉三角！ ¶题目简述： 赶回第k行杨辉三角，要求空间O(k) ¶题解一：普通版 思路： 为了省空间到O(k)，我么使用滚动数组解决 一个数组记录上一层，一个数组记录下一层，来回滚动即可 时间复杂度：O(n^2) ¶AC代码一： 123456789101112131415class Solution {public: vector&lt;int&gt; getRow(int rowIndex) { vector&lt;int&gt; res, last; for(int i = 0; i &lt;= rowIndex; i++){ res.clear(); for(int j = 0; j &lt;= i; j++){ if(!j || j == i) res.push_back(1); else res.push_back(last[j] + last[j - 1]); } last = res; } return res; }}; ¶题解二：位运算优化 思路： 对于滚动数组是有特点的，我们可以用位运算来优化一下： 位运算滚动数组： 根据行数编号的奇偶来运算，上一层若为奇数，则下一层为偶数，使用i表示下一层，则上一层为i - 1，若直接这样那么空间复杂度是n^2级别的，但是，我们只要两层，可以对其奇偶进行判断即可，即和1左与运算即可，当前层为i &amp; 1，上一层为i - 1 &amp; 1，这样就把空间降到了两层！ 使用位运算优化： 会比普通的滚动数组快一点！ 最后答案： f[n &amp; 1] 实现： 构建二维数组，第一维只有2，使用时将第一维都与1做一下与运算即可！ 时间复杂度：O(n) ¶AC代码二： 123456789101112class Solution {public: vector&lt;int&gt; getRow(int n) { vector&lt;vector&lt;int&gt;&gt; f(2, vector&lt;int&gt;(n + 1)); for(int i = 0; i &lt;= n; i++){ f[i &amp; 1][0] = f[i &amp; 1][i] = 1; for(int j = 1; j &lt; i; j++) f[i &amp; 1][j] = f[i - 1 &amp; 1][j - 1] + f[i - 1 &amp; 1][j]; } return f[n &amp; 1]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递推","slug":"递推","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E6%8E%A8/"},{"name":"位运算","slug":"位运算","permalink":"https://www.itnxd.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"滚动数组","slug":"滚动数组","permalink":"https://www.itnxd.cn/tags/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-118. 杨辉三角","slug":"LeetCode刷题-118-杨辉三角","date":"2020-08-07T14:10:12.000Z","updated":"2020-08-08T14:26:28.433Z","comments":true,"path":"posts/46834.html","link":"","permalink":"https://www.itnxd.cn/posts/46834.html","excerpt":"","text":"题目链接：118. 杨辉三角 ¶题解： 简单的杨辉三角！ ¶题目简述： 给定一个数，生成杨辉三角的那几行！ ¶题解： 递推： 对于每一行第一个和最后一个都是1，即!j || j == i 其他数字，都等于该数正上方和左上方的和，即res[i - 1][j - 1] + res[i - 1][j] 时间复杂度：O(n^2) ¶AC代码： 123456789101112131415class Solution {public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) { vector&lt;vector&lt;int&gt;&gt; res; for(int i = 0; i &lt; numRows; i++){ vector&lt;int&gt; level; for(int j = 0; j &lt;= i; j++){ if(!j || j == i) level.push_back(1); else level.push_back(res[i - 1][j - 1] + res[i - 1][j]); } res.push_back(level); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递推","slug":"递推","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E6%8E%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-117. 填充每个节点的下一个右侧节点指针 II","slug":"LeetCode刷题-117-填充每个节点的下一个右侧节点指针-II","date":"2020-08-07T14:10:02.000Z","updated":"2020-08-08T14:20:22.859Z","comments":true,"path":"posts/18637.html","link":"","permalink":"https://www.itnxd.cn/posts/18637.html","excerpt":"","text":"题目链接：117. 填充每个节点的下一个右侧节点指针 II ¶题解： 上一题的进阶版，二叉树变得更加的普通！ ¶题目简述： 给定一棵非常普通的二叉树，每个节点多一个next指针，我们需要将其指向同一行紧挨着的下一个节点！ 要求空间O(1) ¶题解： 不要求空间则可以通过简单BFS实现！ 和上一题思想类似： 不过这个题我么无法直接通过上一层来找到下一层的对应关系，但是我们可以对下一层进行构造横向链表！ 若下一层存在：构建虚拟头结点以及尾指针，进行尾插法形成下一层单链表 若上一层节点左儿子存在，则尾插法插入该节点 若上一层节点右儿子存在，则尾插法插入该节点 走向下一层，cur = head-&gt;next，由于head为虚拟头节点 时间复杂度：同样每个节点遍历一次，为O(n) ¶AC代码： 12345678910111213141516171819202122232425262728293031323334/*// Definition for a Node.class Node {public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {}};*/class Solution {public: Node* connect(Node* root) { if(!root) return root; auto cur = root; while(cur){ auto head = new Node(-1), tail = head; for(auto p = cur; p; p = p-&gt;next){ if(p-&gt;left) tail = tail-&gt;next = p-&gt;left; if(p-&gt;right) tail = tail-&gt;next = p-&gt;right; } cur = head-&gt;next; } return root; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-116. 填充每个节点的下一个右侧节点指针","slug":"LeetCode刷题-116-填充每个节点的下一个右侧节点指针","date":"2020-08-07T14:09:50.000Z","updated":"2020-08-08T13:59:27.438Z","comments":true,"path":"posts/54940.html","link":"","permalink":"https://www.itnxd.cn/posts/54940.html","excerpt":"","text":"题目链接：116. 填充每个节点的下一个右侧节点指针 ¶题解： 类似链表的操作题！ ¶题目简述： 给定一个二叉树，该二叉树每个节点多一个next指针用来横着指向下一个节点！ 要求：空间O(1) ¶题解： 类似BFS： 该题要求空间O(1)，所以使用很简单的栈实现的BFS就不能使用了！ 思路： 若下一层存在，则通过上一层的每个节点p来链接下一层之间的关系： 先连接上一层根节点的左儿子为其右儿子，即 p-&gt;left-&gt;next = p-&gt;right 若上一层有后一个节点：（即此时为两个父亲四个儿子正中间的情况），即p-&gt;right-&gt;next = p-&gt;next-&gt;left 接下来，走到下一层，即level = level-&gt;left 时间复杂度：每个节点遍历一次为O(n) ¶AC代码： 123456789101112131415161718192021222324252627282930313233/*// Definition for a Node.class Node {public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {}};*/class Solution {public: Node* connect(Node* root) { if(!root) return root; auto level = root; while(level-&gt;left){ for(auto p = level; p; p = p-&gt;next){ p-&gt;left-&gt;next = p-&gt;right; if(p-&gt;next) p-&gt;right-&gt;next = p-&gt;next-&gt;left; } level = level-&gt;left; } return root; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-115. 不同的子序列","slug":"LeetCode刷题-115-不同的子序列","date":"2020-08-07T14:09:40.000Z","updated":"2020-08-08T13:43:47.987Z","comments":true,"path":"posts/39299.html","link":"","permalink":"https://www.itnxd.cn/posts/39299.html","excerpt":"","text":"题目链接：115. 不同的子序列 ¶题解： 熟悉的动态规划又来了！ ¶题目简述： 给定两个字符串，问按顺序可以从第一个字符串中找到多少种方案可以组成第二个字符！ ¶题解： **动态规划：**同样字符串前面加空格更好的处理边界问题！ 状态表示： 两个字符串，使用二维数组f[i][j]表示s串前i个字符和t串前j个字符的方案数 状态计算： 两种情况： s[i] != t[j]：则当前状态f[i][j] = f[i - 1][j]，即为s串前i - 1个字符和t串前j个字符的方案数 s[i] == t[j]：则当前状态f[i][j] = f[i - 1][j] + f[i - 1][j - 1]，即可以匹配最后一个字符即为f[i - 1][j - 1]，也可以不匹配即为f[i - 1][j] 最终答案： f[n][m] 边界条件： f[i][0] = 1，即s串前i个字符和t串前0个字符（空格）的方案数都是1，s一定有一个空格（开始部分）。 时间复杂度：O(nm) ¶AC代码： 12345678910111213141516class Solution {public: int numDistinct(string s, string t) { int n = s.size(), m = t.size(); s = ' ' + s, t = ' ' + t; vector&lt;vector&lt;long long&gt;&gt; f(n + 1, vector&lt;long long&gt;(m + 1)); for(int i = 0; i &lt;= n; i++) f[i][0] = 1; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ f[i][j] = f[i - 1][j]; if(s[i] == t[j]) f[i][j] += f[i - 1][j - 1]; } } return f[n][m]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-114. 二叉树展开为链表","slug":"LeetCode刷题-114-二叉树展开为链表","date":"2020-08-07T14:09:28.000Z","updated":"2020-08-08T10:38:34.224Z","comments":true,"path":"posts/34497.html","link":"","permalink":"https://www.itnxd.cn/posts/34497.html","excerpt":"","text":"题目链接：114. 二叉树展开为链表 ¶题解： 找规律？ ¶题目简述： 讲一个二叉树变为一个链表，具体查看题目链接！ ¶题解： 思路： 若当前点存在左子树，则将左子树右链插入当前节点的右儿子 否则，当前节点走到右子树 就是每次将从左上到右下方向的链插入到该父节点的右链！ 时间复杂度：外层循环遍历每个节点一次为O(n)，内存循环会将每个右链遍历一次，每个节点最多被遍历两次，为O(n) ¶AC代码： 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: void flatten(TreeNode* root) { while(root){ auto p = root-&gt;left; if(p){ while(p-&gt;right) p = p-&gt;right; p-&gt;right = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = NULL; } root = root-&gt;right; } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-113. 路径总和 II","slug":"LeetCode刷题-113-路径总和-II","date":"2020-08-07T14:09:15.000Z","updated":"2020-08-08T10:25:02.538Z","comments":true,"path":"posts/47363.html","link":"","permalink":"https://www.itnxd.cn/posts/47363.html","excerpt":"","text":"题目链接：113. 路径总和 II ¶题解： 和上一题类似，简单递归！ ¶题目简述： 和上一题类似，多加了一个记录路径的要求！ ¶题解： 递归： 根节点为空直接返回 将当前节点加入路径 答案条件：到了叶子结点并且sum减到了0 左子树不空递归左子树 右子树不空递归右子树 将当前加点删掉，恢复状态 由于要走遍所有情况，所以和上一题相比少了一个都不空的情况！ 时间复杂度：遍历所有节点为O(n)，记录所有路径为O(n)，总复杂度为O(n^2) ¶AC代码： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) { dfs(root, sum); return res; } void dfs(TreeNode* root, int sum){ if(!root) return; path.push_back(root-&gt;val); sum -= root-&gt;val; if(!root-&gt;left &amp;&amp; !root-&gt;right){ if(sum == 0) res.push_back(path); } if(root-&gt;left) dfs(root-&gt;left, sum); if(root-&gt;right) dfs(root-&gt;right, sum); path.pop_back(); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-112. 路径总和","slug":"LeetCode刷题-112-路径总和","date":"2020-08-07T14:09:02.000Z","updated":"2020-08-08T10:10:56.946Z","comments":true,"path":"posts/61574.html","link":"","permalink":"https://www.itnxd.cn/posts/61574.html","excerpt":"","text":"题目链接：112. 路径总和 ¶题解： 简单递归！ ¶题目简述： 给定一个二叉树和一个目标值，问是否有从根节点到叶子节点的和为目标值的线路！ ¶题解： **递归：**从根节点开始减，直到叶子节点判断是否为0即可，几种情况 根节点为空：返回false 左右子树都空：返回!sum 左右子树都不空：左边符合直接返回true，否则处理右边 左右子树一个空一个非空：放回该方向是否符合！ 注意： 注释部分为分开写法 可以合并为最后一句：左边存在且符合直接返回，不符合继续看右边是否存在，存在则看是否符合，最终返回！ 时间复杂度：遍历每个节点一次，为O(n) ¶AC代码： 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool hasPathSum(TreeNode* root, int sum) { if(!root) return false; sum -= root-&gt;val; if(!root-&gt;left &amp;&amp; !root-&gt;right) return !sum; // if(root-&gt;left &amp;&amp; root-&gt;right) return hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum); // if(root-&gt;left) return hasPathSum(root-&gt;left, sum); // return hasPathSum(root-&gt;right, sum); return root-&gt;left &amp;&amp; hasPathSum(root-&gt;left, sum) || root-&gt;right &amp;&amp; hasPathSum(root-&gt;right, sum); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-111. 二叉树的最小深度","slug":"LeetCode刷题-111-二叉树的最小深度","date":"2020-08-07T14:08:40.000Z","updated":"2020-08-08T09:58:13.462Z","comments":true,"path":"posts/24315.html","link":"","permalink":"https://www.itnxd.cn/posts/24315.html","excerpt":"","text":"题目链接：111. 二叉树的最小深度 ¶题解： 求二叉树的深度问题！ ¶题目简述： 求二叉树的最小深度！ ¶题解： **简单递归：**最小深度一定是左右子树中较小的一个，递归去处理，分几种情况： 根节点为空：返回0 左右子树都为空：返回1 左右子树都非空：返回左右子树的较小深度加一 左右子树一个空一个非空：返回该子树深度加一 时间复杂度：遍历每个节点一次，为O(n) ¶AC代码： 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int minDepth(TreeNode* root) { if(!root) return 0; if(!root-&gt;left &amp;&amp; !root-&gt;right) return 1; if(root-&gt;left &amp;&amp; root-&gt;right) return min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1; if(root-&gt;left) return minDepth(root-&gt;left) + 1; return minDepth(root-&gt;right) + 1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-110. 平衡二叉树","slug":"LeetCode刷题-110-平衡二叉树","date":"2020-08-05T11:25:37.000Z","updated":"2020-08-07T14:07:34.652Z","comments":true,"path":"posts/58905.html","link":"","permalink":"https://www.itnxd.cn/posts/58905.html","excerpt":"","text":"题目链接：110. 平衡二叉树 ¶题解： 平衡二叉树的判断！ ¶题目简述： 给定一棵二叉树判断是否是平衡二叉树！ ¶题解： 平衡二叉树定义：所有 左右子树高度差不超过1 思路：根据定义来求解 求每个左右子树的高度，判断高度差是否大于1即可，即abs(lh - rh) &gt; 1 二叉树高度，同之前的求高度问题，左右高度最大值加一即可，即max(lh, rh) + 1 其实就是递归求二叉树高度问题多了一个变量来存储是否差值超过了1！ 时间复杂度：每个节点遍历一次，为O(n) ¶AC代码： 1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool res; bool isBalanced(TreeNode* root) { res = true; dfs(root); return res; } int dfs(TreeNode* root){ if(!root) return 0; int lh = dfs(root-&gt;left), rh = dfs(root-&gt;right); if(abs(lh - rh) &gt; 1) res = false; return max(lh, rh) + 1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"平衡二叉树","slug":"平衡二叉树","permalink":"https://www.itnxd.cn/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-109. 有序链表转换二叉搜索树","slug":"LeetCode刷题-109-有序链表转换二叉搜索树","date":"2020-08-05T11:25:17.000Z","updated":"2020-08-07T14:00:50.248Z","comments":true,"path":"posts/11732.html","link":"","permalink":"https://www.itnxd.cn/posts/11732.html","excerpt":"","text":"题目链接：109. 有序链表转换二叉搜索树 ¶题解： 同样是构造二叉搜索树！链表比较麻烦一点！ ¶题目简述： 将有序链表构造为高度平衡的二叉搜索树！ ¶题解： 链表构造二叉树会麻烦一点！ **思路：**总思路和数组相同，递归解决，仍是区间角度考虑！ 与数组不同，这个无法使用正常的区间，由于是链表，只能使用一个指针指向区间起点！ 为了找到节点数，需要遍历一次求长度 长度为1直接返回当前节点（也是为了处理边界问题） 找到中间节点：我们应该扎到左子树区间的终点cur，这样可以通过改点找到右子树的起点cur-&gt;next-&gt;next，循环n / 2 - 1次即可，保证左边比右边多一（偶数时）或者相等（奇数时），可以处理边界条件（当节点为2时，防止左右子树起点都不正确） 先处理右子树，在处理左子树，否则左子树的区间长度就不是一半了，变成整个区间了，不正确！先处理右子树，处理完将cur-&gt;next = NULL将区间分为两段head ~ cur， cur-&gt;next-&gt;next ~ NULL 最后返回当前根节点root，区间为空返回NULL 时间复杂度：递归logn层，每层为O(n)，总复杂度为O(nlogn) ¶AC代码： 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; *//** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* sortedListToBST(ListNode* head) { if(!head) return NULL; int n = 0; for(auto p = head; p; p = p-&gt;next) n++; if(n == 1) return new TreeNode(head-&gt;val); auto cur = head; for(int i = 0; i &lt; n / 2 - 1; i++) cur = cur-&gt;next; auto root = new TreeNode(cur-&gt;next-&gt;val); root-&gt;right = sortedListToBST(cur-&gt;next-&gt;next); cur-&gt;next = NULL; root-&gt;left = sortedListToBST(head); return root; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-108. 将有序数组转换为二叉搜索树","slug":"LeetCode刷题-108-将有序数组转换为二叉搜索树","date":"2020-08-05T11:24:51.000Z","updated":"2020-08-07T14:01:23.619Z","comments":true,"path":"posts/58650.html","link":"","permalink":"https://www.itnxd.cn/posts/58650.html","excerpt":"","text":"题目链接：108. 将有序数组转换为二叉搜索树 ¶题解： 构造二叉搜索树问题！ ¶题目简述： 将有序数组构造为高度平衡的二叉搜索树！ ¶题解： 仍然从区间角度去考虑递归子问题来解决！ 思路： 对于有序数组，二叉搜索树的根节点一定是区间的中心，即 l + r &gt;&gt; 1 根节点：root = new TreeNode(nums[mid]) 左子树区间：l, mid - 1 右子树区间：mid + 1, r l &gt; r区间为空返回NULL 关于高度平衡即左右子树高度差小于一的证明： 很明显，和二分一样，高度一定是Log2 (n + 1)上取整的！ 关于更加数学化的证明：参考 y 总证明！点击这里！ 时间复杂度：每个节点遍历一次，为O(n) ¶AC代码： 1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) { return build(nums, 0, nums.size() - 1); } TreeNode* build(vector&lt;int&gt;&amp; nums, int l, int r){ if(l &gt; r) return NULL; int mid = l + r &gt;&gt; 1; auto root = new TreeNode(nums[mid]); root-&gt;left = build(nums, l, mid - 1); root-&gt;right = build(nums, mid + 1, r); return root; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树搜索树","slug":"二叉树搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%90%9C%E7%B4%A2%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-107. 二叉树的层次遍历 II","slug":"LeetCode刷题-107-二叉树的层次遍历-II","date":"2020-08-05T11:24:27.000Z","updated":"2020-08-07T13:18:20.822Z","comments":true,"path":"posts/61896.html","link":"","permalink":"https://www.itnxd.cn/posts/61896.html","excerpt":"","text":"题目链接：107. 二叉树的层次遍历 II ¶题解： 和第102道题一样！ ¶题目简述： 二叉树层次遍历，要求先遍历最底层！ ¶题解： 嗯，按照正常顺序层序遍历，最后将答案进行反转即可！ 正常层序遍历思路参见第102道题题解！使用博客搜索框搜索即可！ 时间复杂度：O(n) ¶AC代码： 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(q.size()){ vector&lt;int&gt; level; int len = q.size(); while(len --){ auto t = q.front(); q.pop(); level.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); } res.push_back(level); } reverse(res.begin(), res.end()); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://www.itnxd.cn/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-106. 从中序与后序遍历序列构造二叉树","slug":"LeetCode刷题-106-从中序与后序遍历序列构造二叉树","date":"2020-08-05T11:24:13.000Z","updated":"2020-08-07T13:13:47.063Z","comments":true,"path":"posts/35952.html","link":"","permalink":"https://www.itnxd.cn/posts/35952.html","excerpt":"","text":"题目链接：106. 从中序与后序遍历序列构造二叉树 ¶题解： 二叉树的后中序构造二叉树！ ¶题目简述： 给定二叉树的后中序遍历来构造一颗二叉树！ ¶题解： 后序遍历：根节点最后遍历 中序遍历：通过后序遍历得到的值找到中序序列的根节点下标位置，将序列分为左右子树 与前中序一样，详细见上一道题！ 这里只给出下标对应关系： 左子树下标： pl, k - 1 - il + pl, il, k - 1 右子树下标： k - 1 - il + pl + 1, pr - 1, k + 1, ir 下标计算同上一道前中序计算，参考上一题！ 时间复杂度：同样适用哈希表将复杂度降为O(n) ¶AC代码： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: unordered_map&lt;int, int&gt; pos; TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { for(int i = 0; i &lt; inorder.size(); i++) pos[inorder[i]] = i; return build(postorder, inorder, 0, postorder.size() - 1, 0, inorder.size() - 1); } TreeNode* build(vector&lt;int&gt;&amp; postorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir){ if(pl &gt; pr) return NULL; auto root = new TreeNode(postorder[pr]); int k = pos[root-&gt;val]; root-&gt;left = build(postorder, inorder, pl, k - 1 - il + pl, il, k - 1); root-&gt;right = build(postorder, inorder, k - 1 - il + pl + 1, pr - 1, k + 1, ir); return root; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"后序遍历","slug":"后序遍历","permalink":"https://www.itnxd.cn/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-105. 从前序与中序遍历序列构造二叉树","slug":"LeetCode刷题-105-从前序与中序遍历序列构造二叉树","date":"2020-08-05T11:23:54.000Z","updated":"2020-08-07T13:08:53.539Z","comments":true,"path":"posts/53963.html","link":"","permalink":"https://www.itnxd.cn/posts/53963.html","excerpt":"","text":"题目链接：105. 从前序与中序遍历序列构造二叉树 ¶题解： 二叉树的前中序构造二叉树！ ¶题目简述： 给定二叉树的前中序遍历来构造一颗二叉树！ ¶题解： 必会知识： 前序遍历的第一个节点一定是根节点 中序遍历可以借助前序遍历得到的根节点将区间分为左右子树两部分 看明白了吧，按照左右子树区间进行递归即可！ 思路： 由于我们要从中序遍历找前序遍历得到的根节点，所以事先将中序遍历的节点和下标关系存储于哈希表，使得可以在O(1)时间查询到下标 根节点：前序遍历的第一个节点，root = new TreeNode(preorder[pl]) 当没有节点时即pl &gt; pr，返回NULL TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir)，参数分别为：前序，中序，前序起始下标，前序终止下标，中序起始下标，中序终止下标 k为中序遍历根节点下标，创建一个根节点，左右子树递归得到 左子树下标： pl + 1, k - 1 - il + pl + 1, il, k - 1 右子树下标：k - 1 - il + pl + 1 + 1, pr, k + 1, ir 下标计算见下图： 时间复杂度：由于哈希表的应用使得复杂度降到了O(n) ¶AC代码： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: unordered_map&lt;int, int&gt; pos; TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { for(int i = 0; i &lt; inorder.size(); i++) pos[inorder[i]] = i; return build(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1); } TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir){ if(pl &gt; pr) return NULL; auto root = new TreeNode(preorder[pl]); int k = pos[root-&gt;val]; root-&gt;left = build(preorder, inorder, pl + 1, k - 1 - il + pl + 1, il, k - 1); root-&gt;right = build(preorder, inorder, k - 1 - il + pl + 1 + 1, pr, k + 1, ir); return root; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"前序遍历","slug":"前序遍历","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-104. 二叉树的最大深度","slug":"LeetCode刷题-104-二叉树的最大深度","date":"2020-08-05T11:23:29.000Z","updated":"2020-08-07T12:22:06.831Z","comments":true,"path":"posts/10832.html","link":"","permalink":"https://www.itnxd.cn/posts/10832.html","excerpt":"","text":"题目链接：104. 二叉树的最大深度 ¶题解： 二叉树深度问题！ ¶题目简述： 求二叉树的最大深度！ ¶题解： 很简单的！ 思路： 深度对于根结点来说就是左子树和右子树的最大深度加一即可，则我们递归去求其高度！ 时间复杂度：O(n) ¶AC代码： 12345678910111213141516/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int maxDepth(TreeNode* root) { if(!root) return 0; return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-103. 二叉树的锯齿形层次遍历","slug":"LeetCode刷题-103-二叉树的锯齿形层次遍历","date":"2020-08-05T11:23:13.000Z","updated":"2020-08-07T12:17:41.698Z","comments":true,"path":"posts/24916.html","link":"","permalink":"https://www.itnxd.cn/posts/24916.html","excerpt":"","text":"题目链接：103. 二叉树的锯齿形层次遍历 ¶题解： 同样是二叉树层序遍历！ ¶题目简述： 给定一个二叉树进行层序遍历，但是要保证左右，右左顺序来回交替遍历！ ¶题解： **思路：**和上一题一模一样，多了一个条件，即当层数（从0开始）为奇数时，将遍历得到的vector反转一次即可！ 时间复杂度：O(n) ¶AC代码： 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); int k = 0; while(q.size()){ vector&lt;int&gt; level; int len = q.size(); while(len --){ auto t = q.front(); q.pop(); level.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); } if(k++ % 2) reverse(level.begin(), level.end()); res.push_back(level); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://www.itnxd.cn/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-102. 二叉树的层序遍历","slug":"LeetCode刷题-102-二叉树的层序遍历","date":"2020-08-05T11:22:59.000Z","updated":"2020-08-07T12:12:52.684Z","comments":true,"path":"posts/30623.html","link":"","permalink":"https://www.itnxd.cn/posts/30623.html","excerpt":"","text":"题目链接：102. 二叉树的层序遍历 ¶题解： 二叉树层序遍历，很巧的思路！ ¶题目简述： 给定一个二叉树，返回一个层序遍历的二维vector! ¶题解： 很明显是一个BFS： 思路： 宽搜进行遍历每一层 遍历当前层时将下一层全部入队即可，循环次数就是当前层的节点数 时间复杂度：O(n) ¶AC代码： 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(q.size()){ vector&lt;int&gt; level; int len = q.size(); while(len --){ auto t = q.front(); q.pop(); level.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); } res.push_back(level); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://www.itnxd.cn/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-101. 对称二叉树","slug":"LeetCode刷题-101-对称二叉树","date":"2020-08-05T11:22:27.000Z","updated":"2020-08-06T04:14:37.999Z","comments":true,"path":"posts/63008.html","link":"","permalink":"https://www.itnxd.cn/posts/63008.html","excerpt":"","text":"题目链接：101. 对称二叉树 ¶题解： 简单递归！ ¶题目简述： 给定一棵二叉树判断是否是对称的！ ¶题解一：递归 对于根节点来说，对称意味着左子树和右子树一致。 对于左子树和右子树，即保证左子树的左子树和右子树的右子树一致并且左子树的右子树和右子树的左子树一致即可！ 则我们可以递归分解为子问题来解决！ 递归DFS： dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left); 最终答案：dfs(root-&gt;left, root-&gt;right) 递归出口：和前几道题一样： !p &amp;&amp; !q：都空返回true !p || !q || p-&gt;val != q-&gt;val：一个空一个非空，或者都不空但值不相同返回false 注意： 根节点为空，直接返回true 时间复杂度：每个节点只被遍历一次，为O(n) ¶AC代码一： 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSymmetric(TreeNode* root) { if(!root) return true; return dfs(root-&gt;left, root-&gt;right); } bool dfs(TreeNode* p, TreeNode* q){ if(!p &amp;&amp; !q) return true; if(!p || !q || p-&gt;val != q-&gt;val) return false; return dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left); }}; ¶题解二：非递归 非递归写法：即用两个栈来模拟正常的中序遍历和反着的中序遍历（右根左）！ 注意点： while条件为lc || rc || left.size() 内部while条件为lc &amp;&amp; rc，左的往左走，右的往右走 退出while的判断为lc || rc，退出循环的情况一定是都空（不需要处理）或者是一个空一个不空（需要处理，无法对称） 值不相同，无法对称 左的往右走，右的往左走 时间复杂度：每个节点只被遍历一次，为O(n) ¶AC代码二： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSymmetric(TreeNode* root) { if(!root) return true; stack&lt;TreeNode*&gt; left, right; auto lc = root-&gt;left, rc = root-&gt;right; while(lc || rc || left.size()){ while(lc &amp;&amp; rc){ left.push(lc), lc = lc-&gt;left; right.push(rc), rc = rc-&gt;right; } if(lc || rc) return false; lc = left.top(), rc = right.top(); left.pop(), right.pop(); if(lc-&gt;val != rc-&gt;val) return false; lc = lc-&gt;right, rc = rc-&gt;left; } return true; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-100. 相同的树","slug":"LeetCode刷题-100-相同的树","date":"2020-08-03T10:16:50.000Z","updated":"2020-08-06T02:12:19.549Z","comments":true,"path":"posts/37006.html","link":"","permalink":"https://www.itnxd.cn/posts/37006.html","excerpt":"","text":"题目链接：100. 相同的树 ¶题解： 简单判断两颗二叉树是否相同！ ¶题目简述： 给定两颗二叉树，判断是否相同！ ¶题解一：DFS 两树相同，即对应的左子树相同，对应的右子树相同即可！ 思路： 左子树相同，并且右子树相同即可，即isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right) 递归出口： 两子树都空，返回true 一子树空，一子树不空，或者两子树都不空但值不同，返会false **时间复杂度：**所有节点遍历一次， 为 O(n) ¶AC代码一： 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { if(!p &amp;&amp; !q) return true; if(!p || !q || p-&gt;val != q-&gt;val) return false; return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); }}; ¶题解二：BFS 使用BFS来遍历一次两树即可！ 思路： 每次都是将同一方向的两树入队，左左右右，使得需要比较的节点为相邻状态即可！ 若两树都空，跳过即可，continue 若一树空，一树不空，或者两树都不空但是值不一样，直接返回false 然后按照左左右右顺序入队两棵树 循环结束没有返回false，则最终返回true 很明显，递归更好写！ 时间复杂度：遍历一遍所有节点，为O(n) ¶AC代码二： 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { queue&lt;TreeNode*&gt; Q; Q.push(p), Q.push(q); while(Q.size()){ p = Q.front(), Q.pop(); q = Q.front(), Q.pop(); if(!q &amp;&amp; !p) continue; if(!p || !q || p-&gt;val != q-&gt;val) return false; Q.push(p-&gt;left), Q.push(q-&gt;left); Q.push(p-&gt;right), Q.push(q-&gt;right); } return true; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-99. 恢复二叉搜索树","slug":"LeetCode刷题-99-恢复二叉搜索树","date":"2020-08-03T10:16:32.000Z","updated":"2020-08-06T02:12:19.716Z","comments":true,"path":"posts/9694.html","link":"","permalink":"https://www.itnxd.cn/posts/9694.html","excerpt":"","text":"题目链接：99. 恢复二叉搜索树 ¶题解： 一个占用空间为O(1)的新的二叉树遍历算法面世！ ¶题目简述： 交换了两个节点的二叉搜索树，需要我们将其恢复回来！ 要求空间复杂度为O(1) ¶题解一：空间O(n) 先给出空间占用为O(n)的算法！ 当前很好想，就是使用递归或非递归的栈来实现！ 现在先简单介绍一下这题怎么能找出两个被交换的节点？ 我们知道，二叉搜索树中序遍历有序，若交换两个点会造成逆序对出现，我们就根据逆序对来找两个点的位置！ 两种情况： 交换两元素相邻：如 1 3 2 4 5 6 7，即3，2逆序对，就是交换的两个节点 交换两元素不相邻：如 1 6 3 4 5 2 7，即6，2交换，对于相邻元素的逆序对有两个，即6 3和5 2，即交换位置为第一个相邻元素逆序对的第一个值和第二个相邻元素逆序对的第二个值！ 具体做法： 与中序遍历递归写法一样，多一个指针指向当前节点的上一个节点last，每次进行相邻元素判断是否是逆序对，是则更新两个交换指针first, second，之后再次遇到只更新second即可 最后进行两节点值的交换swap(first-&gt;val, second-&gt;val) 时间复杂度：O(n) 空间复杂度：O(n) ¶AC代码一： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* first, *second, *last; void recoverTree(TreeNode* root) { dfs(root); swap(first-&gt;val, second-&gt;val); } void dfs(TreeNode* root){ if(!root) return; dfs(root-&gt;left); if(last &amp;&amp; last-&gt;val &gt; root-&gt;val){ if(!first) first = last, second = root; else second = root; } last = root; dfs(root-&gt;right); }}; ¶题解二：空间O(1) 为了符合题目要求只能使用这个牛逼有难写的Morris遍历，可将空间复杂度降低到O(1)! Morris-traversal：核心就是将栈进行了优化，非递归栈的最大作用是为了回溯时找到该节点（即栈顶），而这个遍历就是为了优化这一步！优化步骤：将子树最后遍历的节点的右指针指向要回溯的节点！ 该遍历算法流程： 若该节点没有左子树，则遍历当前节点，然后遍历右子树 若该节点有左子树，则找该节点的前驱结点p（即指向该节点的节点，这里指的是该子树要遍历的最后一个节点） 若p-&gt;right == NULL：说明我们的遍历顺序是从上面下来的，即该左子树并没有进行遍历，然后将前驱结点指向根节点p-&gt;right = root ，继续遍历左子树root = root-&gt;left！ 若p-&gt;right != NULL：说明我们的遍历顺序是从下面上去的，则该左子树已经遍历过了，将当前状态清空p-&gt;right = NULL，遍历当前节点，继续遍历右子树root = root-&gt;right！ 我们要在上面两处遍历当前点的情况时进行寻找逆序对，和题解一一样！ 最终结果：将first second的值进行交换即可！ 如何去找该子树最后一个被遍历的节点？ 很简单，即先往左走一步，然后一直往右走到底就是该节点！想想是不是！右节点一定是最后遍历的！ 注意： 找该节点时的条件为：p-&gt;right &amp;&amp; p-&gt;right != root，使用p-&gt;right != root，防止形成环成为死循环！ 时间复杂度：关键在于求前驱结点的while循环，求前驱结点的最坏情况为O(n)，然而对于二叉树来说，每条边最多被遍历两次，时间复杂度为O(2n)，即为O(n) 哪两次呢？ 第一次：对于左儿子没有右子树的情况，后面的点即左儿子最多会被根节点遍历一次！第二次：对于左儿子有右子树的情况，后面的点最多被根节点遍历一次！终上所述，每个节点最多遍历两次！ 空间复杂度：没有开辟额外空间，为O(1) ¶AC代码二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: void recoverTree(TreeNode* root) { TreeNode *first = NULL, *second = NULL, *last = NULL; while(root){ // 没有左子树 if(!root-&gt;left){ // 遍历当前根节点 if(last &amp;&amp; last-&gt;val &gt; root-&gt;val){ if(!first) first = last, second = root; else second = root; } // 更新当前节点的上一个节点为当前节点 last = root; // 走向右子树 root = root-&gt;right; }else{ // 有左子树 // 走向第一个左儿子 auto p = root-&gt;left; // 走向第一个左儿子的最右边即前驱结点 while(p-&gt;right &amp;&amp; p-&gt;right != root) p = p-&gt;right; // 说明是从上面下来的 if(!p-&gt;right) p-&gt;right = root, root = root-&gt;left; else{ // 说明是从下面上来的 // 恢复该指针 p-&gt;right = NULL; // 遍历当前节点 if(last &amp;&amp; last-&gt;val &gt; root-&gt;val){ if(!first) first = last, second = root; else second = root; } last = root; // 走向右子树 root = root-&gt;right; } } } swap(first-&gt;val, second-&gt;val); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"Morris-traversal","slug":"Morris-traversal","permalink":"https://www.itnxd.cn/tags/Morris-traversal/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-98. 验证二叉搜索树","slug":"LeetCode刷题-98-验证二叉搜索树","date":"2020-08-03T10:16:15.000Z","updated":"2020-08-06T02:12:19.713Z","comments":true,"path":"posts/58463.html","link":"","permalink":"https://www.itnxd.cn/posts/58463.html","excerpt":"","text":"题目链接：98. 验证二叉搜索树 ¶题解： 判断是否是二叉搜索树！递归写法有点意思！ ¶题目简述： 判断是否是二叉搜索树！ ¶题解一：非递归 我们知道二叉搜索树中序遍历后是有序的！ 思路： 中序遍历二叉搜索树 两个变量指向一前一后 若后面大于前面直接返回false 时间复杂度：O(n) ¶AC代码一： 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isValidBST(TreeNode* root) { TreeNode* pre = NULL; stack&lt;TreeNode*&gt; stk; while(root || stk.size()){ while(root){ stk.push(root); root = root-&gt;left; } root = stk.top(); stk.pop(); if(pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) return false; pre = root; root = root-&gt;right; } return true; }}; ¶题解二：递归 递归写法就不太好写了！ 思路： 由二叉搜索树定义来递归验证，即验证左子树和右子树是否符合，逐级向上，直到根节点！ dfs的vector返回值存储三项，当前子树是否是二叉搜索树，当前子树的最小值，当前子树的最大值！ 具体来说： 若左子树存在则遍历左子树 若左子树不是二叉搜索树，或者左子树是二叉搜索树但根节点小于左子树的最大值，则说明当前根节点不是二叉搜索树，标记res[0] = 0 更新包含当前根节点的子树的最大最小值 若右子树存在则遍历右子树 若右子树不是二叉搜索树，或者右子树是二叉搜索树但根节点大于右子树的最小值，则说明当前根节点不是二叉搜索树，标记res[0] = 0 更新包含当前根节点的子树的最大最小值 返回res 最终结果： dfs[root][0] 时间复杂度： 每个节点遍历一次，为 O(n) ¶AC代码二： 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isValidBST(TreeNode* root) { if(!root) return true; return dfs(root)[0]; } vector&lt;int&gt; dfs(TreeNode* root){ vector&lt;int&gt; res({1, root-&gt;val, root-&gt;val}); if(root-&gt;left){ auto t = dfs(root-&gt;left); if(!t[0] || t[2] &gt;= root-&gt;val) res[0] = 0; res[1] = min(res[1], t[1]); res[2] = max(res[2], t[2]); } if(root-&gt;right){ auto t = dfs(root-&gt;right); if(!t[0] || t[1] &lt;= root-&gt;val) res[0] = 0; res[1] = min(res[1], t[1]); res[2] = max(res[2], t[2]); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-97. 交错字符串","slug":"LeetCode刷题-97-交错字符串","date":"2020-08-03T10:16:01.000Z","updated":"2020-08-06T02:25:40.565Z","comments":true,"path":"posts/40380.html","link":"","permalink":"https://www.itnxd.cn/posts/40380.html","excerpt":"","text":"题目链接：97. 交错字符串 ¶题解： 简单动态规划！ ¶题目简述： 给定三个字符串，前两个字符串能否组成第三个字符串！ ¶题解： 动态规划： 状态表示： 两个字符串，使用二维数组f[i][j]，s1串的前i个字符串和s2串的前j个字符能否构成s3串的前i + j个字符！ **状态计算：**同样的套路，只考虑最后一步，即能交错形成的条件： 当s1[i] == s3[i + j]时：s1串的前i - 1个和s2的前j个匹配 当s2[j] == s3[i + j]时：s1串的前i个和s2的前j - 1个匹配 综上所述： 状态转移方程为：f[i][j] = f[i - 1][j] || f[i][j - 1] 初始转态： f[0][0] == true 同样取决于能否将所有状态全部计算对！不解释了！ 最终结果： f[n][m] 时间复杂度：O(n^2) ¶AC代码： 12345678910111213141516171819class Solution {public: bool isInterleave(string s1, string s2, string s3) { int n = s1.size(), m = s2.size(); if(n + m != s3.size()) return false; s1 = ' ' + s1, s2 = ' ' + s2, s3 = ' ' + s3; vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1)); for(int i = 0; i &lt;= n; i++){ for(int j = 0; j &lt;= m; j++){ if(!i &amp;&amp; !j) f[i][j] = true; else{ if(i &amp;&amp; s1[i] == s3[i + j]) f[i][j] = f[i - 1][j]; if(j &amp;&amp; s2[j] == s3[i + j]) f[i][j] = f[i][j] || f[i][j - 1]; } } } return f[n][m]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-96. 不同的二叉搜索树","slug":"LeetCode刷题-96-不同的二叉搜索树","date":"2020-08-03T10:15:40.000Z","updated":"2020-08-06T02:12:19.698Z","comments":true,"path":"posts/31482.html","link":"","permalink":"https://www.itnxd.cn/posts/31482.html","excerpt":"","text":"题目链接：96. 不同的二叉搜索树 ¶题解： 本题就是求卡特兰数，这里使用动态规划来写！ ¶题目简述： 求n个节点可以构成二叉搜索树的个数！ ¶题解： 可以直接利用卡特兰数公式来求，似乎不太好求！ 这里使用动态规划来求： 和上一道类似，同样是乘法原理，j表示长度为1 ~ i的根节点的位置，左子树的长度为 j - 1，右子树的长度为i - j 状态表示：f[i]表示i长度的二叉搜索树个数 状态计算： f[i] += f[j - 1] * f[i - j]（j可以取该区间任何位置，累加关系） 乘法原理，左边乘以右边 初始转态： f[0] = 1，同样这个初始状态由能否使得所有状态算对即可！当i, j都为1时，f[i] = f[j - 1] * f[i - j] 应该为1，即f[0] = 1 最终答案： f[n] 即n长度的二叉搜索树个数 注意：对于1 ~ 5 和2 ~ 6可以构成的二叉搜索树是一样的，可以这样想，将1 ~ 5构成的二叉搜索树根据对应关系可以全部替换为2 ~ 6，即二叉搜索树的个数时有区间长度决定的！ 时间复杂度：O(n^2) ¶AC代码： 1234567891011class Solution {public: int numTrees(int n) { vector&lt;int&gt; f(n + 1); f[0] = 1; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) f[i] += f[j - 1] * f[i - j]; return f[n]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"卡特兰数","slug":"卡特兰数","permalink":"https://www.itnxd.cn/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-95. 不同的二叉搜索树 II","slug":"LeetCode刷题-95-不同的二叉搜索树-II","date":"2020-08-03T10:15:25.000Z","updated":"2020-08-06T02:12:19.720Z","comments":true,"path":"posts/3575.html","link":"","permalink":"https://www.itnxd.cn/posts/3575.html","excerpt":"","text":"题目链接：95. 不同的二叉搜索树 II ¶题解： 生成所有二叉搜索树！有意思的题！ ¶题目简述： 给定一个序列，生成所有二叉搜索树的序列！ ¶题解： 递归DFS： 对于一个区间的二叉搜索树，我们只需要枚举根节点所在的位置即可，通过递归一步步构建不同的二叉搜索树！ 从1 ~ n开始搜索 枚举根节点位置为l ~ r 递归左子树l ~ i - 1，右子树i + 1 ~ r 由于相当于乘法原理，左子树随便一种情况和右子树随便一种情况组合都是一个合法的二叉搜索树 左子树取一种情况，右子树取一种情况，构建根节点，连接起来形成当前结构的二叉搜索树 将当前所有二叉搜索树插入res并返回 递归终止条件： l &gt; r：即为空树，返回NULL n == 0：即输入为0，直接返回空容器{} 注意： 根节点一定要随用随创建，若创建第一层for循环，会导致覆盖情况发生，由于存储的是指针，最后存储将都会是一样的一个二叉树 此处的res不能创建到全局的，那样无法完成下一层向上一层的传递 时间复杂度：是卡特兰数，n个节点构成的二叉搜索树种类是卡特兰数，即 C2nn / n + 1 ！对于n个点的二叉搜索树，方案数如下： 其实推完公式就是卡特兰数，这里就不推了！ ¶AC代码： 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&lt;TreeNode*&gt; generateTrees(int n) { if(!n) return {}; return dfs(1, n); } vector&lt;TreeNode*&gt; dfs(int l, int r) { if(l &gt; r) return {NULL}; vector&lt;TreeNode*&gt; res; for(int i = l; i &lt;= r; i++){ auto left = dfs(l, i - 1), right = dfs(i + 1, r); for(auto&amp; l : left){ for(auto&amp; r : right){ auto root = new TreeNode(i); root-&gt;left = l, root-&gt;right = r; res.push_back(root); } } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-94. 二叉树的中序遍历","slug":"LeetCode刷题-94-二叉树的中序遍历","date":"2020-08-03T10:15:09.000Z","updated":"2020-08-06T02:12:19.677Z","comments":true,"path":"posts/16898.html","link":"","permalink":"https://www.itnxd.cn/posts/16898.html","excerpt":"","text":"题目链接：94. 二叉树的中序遍历 ¶题解： 开始进入二叉树的世界！ ¶题目简述： 给定一个二叉树，返回中序遍历序列！ ¶题解： 中序遍历：即左根右的顺序去遍历！ 递归： 从根节点开始遍历 遍历左子树 访问当前根节点 遍历右子树 递归到空节点返回 时间复杂度：O(n) ¶AC代码一：递归实现 1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; res; vector&lt;int&gt; inorderTraversal(TreeNode* root) { dfs(root); return res; } void dfs(TreeNode* root){ if(!root) return; dfs(root-&gt;left); res.push_back(root-&gt;val); dfs(root-&gt;right); }}; ¶AC代码：非递归实现（模板） 非递归：即借助栈来实现！ 思想： 先将左子树都压入栈中 出栈栈顶 指向当前栈顶的右子树 终止条件： 栈空并且当前节点为空 时间复杂度：O(n) 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stk; while(root || stk.size()){ while(root){ stk.push(root); root = root-&gt;left; } root = stk.top(); stk.pop(); res.push_back(root-&gt;val); root = root-&gt;right; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-93. 复原IP地址","slug":"LeetCode刷题-93-复原IP地址","date":"2020-08-03T10:06:50.000Z","updated":"2020-08-06T02:12:19.657Z","comments":true,"path":"posts/14783.html","link":"","permalink":"https://www.itnxd.cn/posts/14783.html","excerpt":"","text":"题目链接：93. 复原IP地址 ¶题解： 带有剪枝的搜索，挺有意思！ ¶题目简述： 给定一串数字，需要将其可以转化为的IP地址返回！ ¶题解： 暴力搜索DFS：void dfs(string s, int u, int k, string path) u：当前搜索到的位置 k：当前搜索的点的个数 path：当前状态下的IP地址 思路： 对于前导0的处理，即012，IP地址没有前导0的，这个已经见过很多次了，直接i &gt; u &amp;&amp; s[u] == '0'即可判断！ 然后搜索下一位时保证下一位在0 ~ 255范围即为合法数字，否则直接return 下一个数的搜索要从上一个数的后一位开始，即i = u开始 终止条件： u == s.size()：即搜到了字符串末尾 剪枝优化：u &lt; s.size() &amp;&amp; k == 4：即没有搜到最后，已经够了四个点 答案： u == s.size() &amp;&amp; k == 4：即恰好组成一组IP地址，此时将该IP地址path最后的小数点去掉，即为答案 时间复杂度：一共n位，n - 1个空隙可插入点，即从n - 1个空隙三个点，即时间复杂度为：Cn-13 ¶AC代码： ¶AC代码： 123456789101112131415161718192021222324class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; restoreIpAddresses(string s) { dfs(s, 0, 0, \"\"); return res; } void dfs(string s, int u, int k, string path){ if(u == s.size()){ if(k == 4){ path.pop_back(); res.push_back(path); } return; } if(k == 4) return; for(int i = u, t = 0; i &lt; s.size(); i++){ if(i &gt; u &amp;&amp; s[u] == '0') return; t = t * 10 + s[i] - '0'; if(t &lt;= 255) dfs(s, i + 1, k + 1, path + to_string(t) + '.'); else return; } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"搜索","slug":"搜索","permalink":"https://www.itnxd.cn/tags/%E6%90%9C%E7%B4%A2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-92. 反转链表 II","slug":"LeetCode刷题-92-反转链表-II","date":"2020-08-03T10:06:21.000Z","updated":"2020-08-06T02:12:19.669Z","comments":true,"path":"posts/56919.html","link":"","permalink":"https://www.itnxd.cn/posts/56919.html","excerpt":"","text":"题目链接：92. 反转链表 II ¶题解： 又是链表操作题，记得要画图哦！ ¶题目简述： 将一个链表的m ~ n位置进行翻转！ ¶题解： 思路： 将m ~ n进行指针翻转 将m指向n的下一位， 将a指向n 如下图： 具体来说： 首先找到m的前一个位置a 让b指向m， c指向m的下一位，t指向c的下一位 接下来将m ~ n进行指针翻转，即让c指向b 然后b c指针顺次后移 最后将该链如上图所示，连起来！懒得解释了，看图吧！ 时间复杂度：O(n) ¶AC代码： 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseBetween(ListNode* head, int m, int n) { auto dummy = new ListNode(-1); dummy-&gt;next = head; auto a = dummy; for(int i = 0; i &lt; m - 1; i++) a = a-&gt;next; auto b = a-&gt;next, c = b-&gt;next; for(int i = 0; i &lt; n - m; i++){ auto t= c-&gt;next; c-&gt;next = b; b = c, c = t; } auto t = a-&gt;next; a-&gt;next = b; t-&gt;next = c; return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-91. 解码方法","slug":"LeetCode刷题-91-解码方法","date":"2020-08-03T03:16:42.000Z","updated":"2020-08-06T02:12:19.653Z","comments":true,"path":"posts/45808.html","link":"","permalink":"https://www.itnxd.cn/posts/45808.html","excerpt":"","text":"题目链接：91. 解码方法 ¶题解： 简单的动态规划题！ ¶题目简述： 将A ~ Z编码为 1 ~ 26，给定一个数字字符串求共有多少种解码方式！ ¶题解： 动态规划： 状态表示： f[i]表示前i个字符的解码方法数 **状态计算：**考虑最后一步 最后一位不为0时，解码数为f[i - 1] 最后两位为10 ~ 26时，解码数为f[i - 2] 综上所述，状态转移方程为： f[i] = f[i - 1] + f[i - 2] 最终结果： f[n] 初始转态： f[0] = 1 ，初始转态为0还是1由是否能满足所有状态的正确性决定，由于f[1] = s[1] != '0' ? 1: 0;，所以f[0] = 1! 时间复杂度：O(n) 注意： 为了使得处理边界简单，将字符串前面加空格处理！ ¶AC代码： 1234567891011121314151617class Solution {public: int numDecodings(string s) { int n = s.size(); s = ' ' + s; vector&lt;int&gt; f(n + 1); f[0] = 1; for(int i = 1; i &lt;= n; i++){ if(s[i] != '0') f[i] += f[i - 1]; if(i &gt; 1){ int t = s[i] - '0' + (s[i - 1] - '0') * 10; if(t &gt;= 10 &amp;&amp; t &lt;= 26) f[i] += f[i - 2]; } } return f[n]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-90. 子集 II","slug":"LeetCode刷题-90-子集-II","date":"2020-07-25T03:43:41.000Z","updated":"2020-07-25T14:49:35.995Z","comments":true,"path":"posts/51468.html","link":"","permalink":"https://www.itnxd.cn/posts/51468.html","excerpt":"","text":"题目链接：90. 子集 II ¶题解： 又是不能重复的递归问题，和LeetCode刷题-47.全排列II此题的关键位置有点像！ ¶题目简述： 给定一个包含重复元素的无序序列，返回该序列可以构成的不能重复的所有组合！ ¶题解： 递归： 关键部分：如何去重？ 首先将数组排序，使得相同元素挨到一起 对于1 2 2来说，处理1 x x时，第二位只使用第一个2即可，不要让他使用第二个2即可！ i &lt;= start ：保证该位置的第一次选择直接使用第一个重复元素 i &lt;= start &amp;&amp; nums[i] == nums[i - 1]：保证该位置的下一种选择方案要保证不是重复元素 时间复杂度：最多有 2^n 个子集，每个子集存储需要O(n)计算量，总时间复杂度为：O(n * 2^n) ¶AC代码一： for循环去处理长度为0 ~ n的情况！ 递归出口：当前位数 == 需要位数，即u == n AC代码二更加简洁！ 1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path, nums; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; _nums) { nums = _nums; sort(nums.begin(), nums.end()); for(int i = 0; i &lt;= nums.size(); i++) dfs(i, 0, 0); return res; } void dfs(int n, int u, int start){ if(u == n){ res.push_back(path); return; } for(int i = start; i &lt; nums.size(); i++){ if(i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; path.push_back(nums[i]); dfs(n, u + 1, i + 1); path.pop_back(); } }}; ¶AC代码二： 不用那么麻烦，使用for循环，由于递归本就是一颗二叉树，所以到达每个节点都是一种情况，所以可以像下面这样写！ 1234567891011121314151617181920class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path, nums; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; _nums) { nums = _nums; sort(nums.begin(), nums.end()); dfs(0); return res; } void dfs(int start){ res.push_back(path); for(int i = start; i &lt; nums.size(); i++){ if(i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; path.push_back(nums[i]); dfs(i + 1); path.pop_back(); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-89. 格雷编码","slug":"LeetCode刷题-89-格雷编码","date":"2020-07-25T03:43:27.000Z","updated":"2020-07-25T14:49:35.992Z","comments":true,"path":"posts/56047.html","link":"","permalink":"https://www.itnxd.cn/posts/56047.html","excerpt":"","text":"题目链接：89. 格雷编码 ¶题解： 一个有趣的题，做法也是特殊的，需要记住！ ¶题目简述： 格雷编码是一个二进制数组合，每两个二进制数对应位数只能有一位不同，所有的组合对应的数集合称之为格雷编码！ 给定一个数，为二进制位数，返回该位数的格雷编码集合！ ¶题解： 特殊题目： 特殊做法，记住即可！ 思路： n位二进制，共有2^n种组合！ 先将n-1位的二进制位，上下轴对称，再将轴上方的最后补0，轴下方的最后补1即可！ 如下图： 简单解释一下正确性： 对n - 1来说，已经满足格雷编码性质，现在来看n的情况： 对于轴上部分，原来相邻的都差一位不同，在最后都加一个相同的0则还是相邻之间差一位 对于轴下部分，原来相邻的都差一位不同，在最后都加一个相同的1则还是相邻之间差一位 对于轴上下相邻部分，由于轴对称，原来是完全一致的，现在一个加0，一个加1，也满足差一位的性质 对于数组具体存储数字的处理： 轴上的部分在最后加0，相当于整体左移一位，即res[i] *= 2 或 res[i] &lt;&lt; 1，没有产生新数据，原数据发生改变 轴下的部分在最后加1，相当于原数加1产生的新数假如数组末尾，即res.push_back(res[i] + 1) 当然，对轴下部分的处理的顺序和图片上的不一致，如果对第一个数加1，相当于轴下的最后一个数，从图上来说，即轴下的新数据是从下往上添加到数组末尾的，产生了新的数据 初始转态： 为n = 0时候，数组只要一个0. 时间复杂度：对于给定的n，计算量为：1 + 2 + 4 + 8 + … + 2^n-1 = 2 * (2^n-1 - 1) = 2^n - 2，即O(2^n) ¶AC代码： 12345678910111213class Solution {public: vector&lt;int&gt; grayCode(int n) { vector&lt;int&gt; res(1, 0); while(n--){ for(int i = res.size() - 1; i &gt;= 0; i--){ res[i] *= 2; res.push_back(res[i] + 1); } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"找规律","slug":"找规律","permalink":"https://www.itnxd.cn/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"},{"name":"格雷编码","slug":"格雷编码","permalink":"https://www.itnxd.cn/tags/%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-88. 合并两个有序数组","slug":"LeetCode刷题-88-合并两个有序数组","date":"2020-07-25T03:43:06.000Z","updated":"2020-07-25T14:49:35.986Z","comments":true,"path":"posts/33104.html","link":"","permalink":"https://www.itnxd.cn/posts/33104.html","excerpt":"","text":"题目链接：88. 合并两个有序数组 ¶题解： 挺有意思的题，使用原数组多余空间来存储！ ¶题目简述： 给定两个有序序列，第一个序列的总长度为两序列之和，多出来的长度为0，即空的！要求使用原数组（可以放得下两数组的数据）不开辟空间进行有序存储！ ¶题解： 嗯，如果从前向后扫描，会将第一个数组的前面覆盖掉！ 既然第一个数组后面是空的，何不利用起来，先往第一个数组最后从后向前放数据，这样就不会造成覆盖问题！ **具体：**从后向前扫描，较大的放到第一个数组最后，依次向前放 双指针？一个指针i指向第一个数组最后一个元素，一个指针j指向第二个数组最后一个元素，然后从后向前扫描即可！ nums1[i] &gt; nums2[j]：nums1[k--] = nums1[i--]; nums1[i] &lt;= nums2[j]：nums1[k--] = nums1[i--]; 结束条件：其中一个数组扫描完了 **最后：**两种情况 第二个数组没扫描完，则从后向前依次放到第一个数组 第一个数组没扫描完，则不用操作，想想，是不是？因为剩下的空间和第一个数组空间一致，并且，第一个数组本来就是有序的，所以他们所在的位置都是在正确位置上，不需要处理！ 时间复杂度：O(n) ¶AC代码： 123456789101112class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int k = n + m - 1; int i = m - 1, j = n - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0){ if(nums1[i] &gt; nums2[j]) nums1[k--] = nums1[i--]; else nums1[k--] = nums2[j--]; } while(j &gt;= 0) nums1[k--] = nums2[j--]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%BB%84/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-87. 扰乱字符串","slug":"LeetCode刷题-87-扰乱字符串","date":"2020-07-25T03:42:54.000Z","updated":"2020-07-25T14:49:35.989Z","comments":true,"path":"posts/30973.html","link":"","permalink":"https://www.itnxd.cn/posts/30973.html","excerpt":"","text":"题目链接：87. 扰乱字符串 ¶题解： 本题也可以使用动态规划，但是似乎是三位数组的表示，及其复杂！ 本题可以使用递归分解子问题求解！较为简单一些！ ¶题目简述： 给定一个字符串，我们可以把它逐层分解为子串，类似于二叉树，我们可以对非叶子节点（叶子节点只有一个字符）进行交换，然后该节点对应的儿子节点和父节点就会发生改变，最终的字符串就会发生一部分的反转！ 给定原串和一个待确认字符串，求解是否是原串通过反转得到的，即为扰乱字符串！ ¶题解： 由于动态规划及其复杂，我们这里换一种思路来做！ 递归思想： 对于该扰乱字符串的简单理解，就是将一部分长度内的字符串在某个位置进行了前后对调，既然如此，我们就可以通过递归找到该长度的字符串，进而和待匹配串对应的位置进行比较即可！ **两种情况：**该区间反转和该区间未反转 简单举例：以gr区间和eat区间为例， 此时区间长度i = 2： 不反转，great和great：则需要原串的前i个字符和待匹配串的前i个字符匹配，并且原串的后n - i个字符与待匹配串的后n - i个字符匹配，即isScramble(s1.substr(0, i), s2.substr(0, i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i)) 反转，great和eatgr：则需要原串的前i个字符和待匹配串的后i个字符匹配，并且原串的后n - i个字符与待匹配串的前n - i个字符匹配，即isScramble(s1.substr(0, i), s2.substr(n- 1)) &amp;&amp; isScramble(s1.substr(i), s2.substr(0, n - i)) 递归出口： 若子问题原串于待匹配串完全相同，则返回true 否则进行排序，查看是否一致，不一致则说明不可能匹配（例如字符个数不同，字符种类不同），直接返回false 若一致，则说明有可能匹配，继续进行递归求解 需要枚举每个区间长度，找到直接终止程序，否则继续查找所有可能，找完还没找到一种正确情况，这说明无法匹配，返回false 时间复杂度：用an表示两个字符串区间长度为n时的计算量，则 12345678an = 4(a1 + a2 + ... an-1)因为：每次都需要四个递归式同理：an-1 = 4(a1 + a2 + ... an-2)两式相减得：an - an-1 = 4an-1an = 5an-1 = 5^2 an-2 = .... = 5^n a0an = 5^n 所以时间复杂度为：O(5^n) ¶AC代码： 123456789101112131415161718class Solution {public: bool isScramble(string s1, string s2) { if(s1 == s2) return true; string t1 = s1, t2 = s2; sort(t1.begin(), t1.end()), sort(t2.begin(), t2.end()); if(t1 != t2) return false; int n = s1.size(); for(int i = 1; i &lt; n; i++){ if(isScramble(s1.substr(0, i), s2.substr(0, i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i))) return true; if(isScramble(s1.substr(0, i), s2.substr(n - i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(0, n - i))) return true; } return false; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-86. 分隔链表","slug":"LeetCode刷题-86-分隔链表","date":"2020-07-25T03:42:41.000Z","updated":"2020-07-25T14:49:35.982Z","comments":true,"path":"posts/44795.html","link":"","permalink":"https://www.itnxd.cn/posts/44795.html","excerpt":"","text":"题目链接：86. 分隔链表 ¶题解： 又是一道链表题，自己做又写成了死循环。。。 一定要画图去做！ ¶题目简述： 给定一个无序链表，给定一个目标值，将小于目标值的节点放到大于等于目标值的左边！ ¶题解： 很明显：要将链表一分为二，一部分放小于目标值，一部分放大于目标值。 具体思路：如下图 遇到小的放到一个链表，遇到大的放到另一个链表，最后将小的链表尾指向大的链表头，再将大的链表的末尾指向空即可！ 注意：为了防止两个链表头找不到，一定要预先设置两个头lh, rh，并设置虚拟头结点，否则lt, rt后面的指向会乱，而且会构成死循环！（我好像就错到了这里） 时间复杂度：O(n) ¶AC代码： 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* partition(ListNode* head, int x) { auto lh = new ListNode(-1), rh = new ListNode(-1); auto lt = lh, rt = rh; for(auto p = head; p; p = p-&gt;next){ if(p-&gt;val &lt; x) lt = lt-&gt;next = p; else rt = rt-&gt;next = p; } lt-&gt;next = rh-&gt;next; rt-&gt;next = NULL; return lh-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-85. 最大矩形","slug":"LeetCode刷题-85-最大矩形","date":"2020-07-25T03:42:22.000Z","updated":"2020-07-25T14:49:35.979Z","comments":true,"path":"posts/16580.html","link":"","permalink":"https://www.itnxd.cn/posts/16580.html","excerpt":"","text":"题目链接：85. 最大矩形 ¶题解： 似乎动态规划也可以做，但好像是三维的数组表示，比较复杂！ 本题可以借助上一题思想，使用单调栈求矩形面积！ 本题求矩形面积，使用动态规划较为复杂，如果求的是正方形，使用动态规划就简单了！ ¶题目简述： 给定一个只包含0，1的矩阵，找到一个只包含1的面积最大的矩形！ ¶题解： 暴力思想：枚举每个点，将其作为右下角，枚举长宽，枚举长宽围成的矩形内的0，1。 时间复杂度为：O(n^2 * n^2 * n^2)，爆炸级别的复杂度！ 正确思想： 本题竟然能和单调栈求矩形面积的上一题有关联！ 我们按照矩阵的每一行作为可能出现都是1的矩形的底边，从该底边求一个最大矩形即可，和上一题类似，求最大矩形面积一样，将所有行作为底边枚举一遍求出来的就是所有可以形成的矩形，最大矩形就是答案！ 完全使用上一题求最大矩形的函数 枚举每一行，并取最大值即可 关键问题：如何求柱子高度，即从当前点可以向上走的高度（即该柱子都是1）？ 可以使用动态规划： 状态表示：h[i][j]表示该位置向上可以走的最大距离 状态计算：h[i][j] = 1 + h[i - 1][j]，即该位置为上一个位置的最大距离加上自己本身，前提是本身得是1，否则该位置为h[i][j] = 0 最终答案：res = max(res, largestRectangleArea(h[i])) 时间复杂度：枚举n行，每行单调栈求矩形面积需要枚举m列，所以为：O(n * m) ，即O(n^2)级别的 ¶AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; h) { int n = h.size(); vector&lt;int&gt; left(n), right(n); stack&lt;int&gt; stk; for(int i = 0; i &lt; n; i ++){ while (stk.size() &amp;&amp; h[stk.top()] &gt;= h[i]) stk.pop(); if (stk.empty()) left[i] = -1; else left[i] = stk.top(); stk.push(i); } stk = stack&lt;int&gt;(); for(int i = n - 1; i &gt;= 0; i --){ while (stk.size() &amp;&amp; h[stk.top()] &gt;= h[i]) stk.pop(); if (stk.empty()) right[i] = n; else right[i] = stk.top(); stk.push(i); } int res = 0; for(int i = 0; i &lt; n; i ++ ) res = max(res, h[i] * (right[i] - left[i] - 1)); return res; } int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { if(matrix.empty() || matrix[0].empty()) return 0; int n = matrix.size(), m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; h(n, vector&lt;int&gt;(m)); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) if(matrix[i][j] == '1'){ if(i) h[i][j] = 1 + h[i - 1][j]; else h[i][j] = 1; } int res = 0; for(int i = 0; i &lt; n; i++) res = max(res, largestRectangleArea(h[i])); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"https://www.itnxd.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-84. 柱状图中最大的矩形","slug":"LeetCode刷题-84-柱状图中最大的矩形","date":"2020-07-25T03:42:07.000Z","updated":"2020-07-25T14:49:35.984Z","comments":true,"path":"posts/64100.html","link":"","permalink":"https://www.itnxd.cn/posts/64100.html","excerpt":"","text":"题目链接：84. 柱状图中最大的矩形 ¶题解： 第二次遇到单调栈了，不太好理解的一个算法和思路！ 和LeetCode刷题-42.接雨水很是类似！ ¶题目简述： 给了一堆高高低低的柱子，要求从中找到一个面积最大的矩形！ ¶题解： 首先想一下以某一个柱子为矩形上边界怎样得到该最大矩形？ 很好想，只要在其左右两边找到离他最近的第一个比他矮的柱子即可！因为比他高，则说明可以继续向外拓展，比他矮就不行了！ 到了这里，就会发现本题的实质就是：找到一个数左边第一个比他小的数和右边第一个比他大的数即可，面积就是左右间隔乘以该柱子高度取最大值即可！ 这里就要想到使用单调栈了，单调栈的核心就是：找到一个数左边第一个比他小的数！ 现在先稍微解释一下单调栈实现的原理： 由于该栈单调递增，对于当前处理的柱子来说，需要找到左边第一个比他矮的柱子 所以从栈顶开始往回看第一个比他矮的，比他高则该栈顶出栈，直到找到比他矮的，然后该柱子进栈 一个问题：删了该栈顶不会影响后面的柱子吗，当然不会！对于后面的柱子，也要找左边第一个比他矮的柱子，如果下一个柱子比当前栈顶高，则第一个矮的就是当前栈顶（即上一个柱子）否则，下一个柱子比当前栈顶矮，则之前出栈的柱子都比他高，所以该出栈柱子不会使第一个比他矮的柱子，即删除的柱子对后面柱子处理不会产生影响！ 所以该栈就是扫描到谁就是以谁为栈顶的一个递增序列！ 时间复杂度：O(n) ¶TLE代码： 暴力求解左右两边第一个矮柱子！ 时间复杂度：O(n^2) 妥妥超时！ 12345678910111213class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int res = 0; for(int i = 0; i &lt; heights.size(); i++){ int j = i + 1, k = i - 1; while(j &lt; heights.size() &amp;&amp; heights[j] &gt;= heights[i]) j++; while(k &gt;= 0 &amp;&amp; heights[k] &gt;= heights[i]) k--; res = max(res, heights[i] * (j - k - 1)); } return res; }}; ¶AC代码一：单调栈 使用left[i]，right[i]来表示i柱子左右两边比他第一个矮的柱子的下标！ 对于本题的一些细节： 如果该柱子左边都比他高，则当前柱子的左边比他第一矮的为 -1 如果该柱子右边都比他高，则当前柱子的左边比他第一矮的为 n 最终答案：res = max(res, h[i] * (right[i] - left[i] - 1)) 注意： 栈第二次使用前要清空 时间复杂度：O(n) 空间复杂度： O(n) 比下面的AC代码二多一点空间，但更好理解 1234567891011121314151617181920212223242526class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; h) { int n = h.size(); vector&lt;int&gt; left(n), right(n); stack&lt;int&gt; stk; for(int i = 0; i &lt; n; i ++){ while (stk.size() &amp;&amp; h[stk.top()] &gt;= h[i]) stk.pop(); if (stk.empty()) left[i] = -1; else left[i] = stk.top(); stk.push(i); } stk = stack&lt;int&gt;(); for(int i = n - 1; i &gt;= 0; i --){ while (stk.size() &amp;&amp; h[stk.top()] &gt;= h[i]) stk.pop(); if (stk.empty()) right[i] = n; else right[i] = stk.top(); stk.push(i); } int res = 0; for(int i = 0; i &lt; n; i ++ ) res = max(res, h[i] * (right[i] - left[i] - 1)); return res; }}; ¶AC代码二：单调栈 相比上一个单调栈的写法：此写法不如上一种好理解！主要是省了两个数组空间… 思想一模一样， 略有不同： 上一个直接预处理当前柱子i的昨天最矮和右边最矮。 本方法直接处理每个栈顶t，即遇到当前柱子i比栈顶t矮，则说明右边第一个矮的已经找到就是当前柱子i，栈顶出栈，而左边第一个比他矮的就更简单了，就是该栈顶的上一个元素stk.top()（因为该栈递增，所以栈顶的上一个元素就是当前栈顶左边第一个比他矮的元素），两种情况： 若该栈顶没有上一个元素，则说明该栈顶的左边比他矮的没有，则为起始位置，面积为：h[t] * i 若该栈顶有上一个元素，则说明当前栈顶（原栈顶已出栈）就是左边第一个比他矮的柱子，面积为： h[t] * (i - stk.top() - 1) 注意： 为了保证栈递增，如果h[stk.top()] &lt;= h[i]，则当前柱子直接入栈！ 为了处理最后一个柱子，将柱子最后加一个-1，因为他每次处理的都是i柱子之前的栈内的柱子，所以最后一个处理不到，加一个-1，即可处理到！ 综上所述：还是AC代码一既正确又好理解！ 时间复杂度：O(n) 空间复杂度： O(n) 12345678910111213141516171819class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; h) { int n = h.size(); h.push_back(-1); stack&lt;int&gt; stk; int res = 0; for(int i = 0; i &lt;= n; i++){ while(stk.size() &amp;&amp; h[stk.top()] &gt; h[i]){ int t = stk.top(); stk.pop(); if(stk.empty()) res = max(res, h[t] * i); else res = max(res, h[t] * (i - stk.top() - 1)); } stk.push(i); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://www.itnxd.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-83. 删除排序链表中的重复元素","slug":"LeetCode刷题-83-删除排序链表中的重复元素","date":"2020-07-25T03:41:50.000Z","updated":"2020-07-25T14:49:35.967Z","comments":true,"path":"posts/20015.html","link":"","permalink":"https://www.itnxd.cn/posts/20015.html","excerpt":"","text":"题目链接：83. 删除排序链表中的重复元素 ¶题解： 与上一个题类似，链表操作！ ¶题目简述： 给定一个有序链表，将有重复的元素删掉（有重复的保留一个） 与上一题全删有点不同 ¶题解： 由于重复元素可以保留一个，所以第一个节点处理和后面一样，所以这里不需要建立虚拟头结点了！ 思路： 判断后面节点和当前已扫描节点形成的链表的最后一个节点是否相同 若相同，则跳过当前节点，指向该节点下一个节点l-&gt;next = l-&gt;next-&gt;next 若不同，则指向当前节点，即l = l-&gt;next 相同时，保证末尾l不动，next移动，不同时，l直接移到不同的节点。 时间复杂度：O(n) ¶AC代码： 1234567891011121314151617181920/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if(!head) return head; auto l = head; while(l-&gt;next){ if(l-&gt;val == l-&gt;next-&gt;val) l-&gt;next = l-&gt;next-&gt;next; else l = l-&gt;next; } return head; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-82. 删除排序链表中的重复元素 II","slug":"LeetCode刷题-82-删除排序链表中的重复元素-II","date":"2020-07-25T03:41:38.000Z","updated":"2020-07-25T14:49:35.977Z","comments":true,"path":"posts/1807.html","link":"","permalink":"https://www.itnxd.cn/posts/1807.html","excerpt":"","text":"题目链接：82. 删除排序链表中的重复元素 II ¶题解： 链表的操作题，感觉对这类链表操作还不太熟练，多做做吧！ ¶题目简述： 给定一个有序链表，只要出现重复元素，就将该段重复元素删去（注意：不是删的只留一个，而是该段全删） ¶题解： 类似双指针做法： 一个指针p-&gt;next指向已扫描位置的下一个位置，一个指针q指向第一个与上一个指针值不一样的位置。(直到与上一个指针不同是为止！) 此时有两种情况： 两指针相距一即p-&gt;next-&gt;next == q：即待扫描该位后面无重复元素，已扫描链表后移p = p-&gt;next 两指针相距大于一即p-&gt;next-&gt;next != q：即待扫描的该位后面有重复元素，跳过重复一段，直接指向第一个不重复元素p，即p-&gt;next = q 注意： 由于要从没有扫描的下一个位置开始，为了方便，建立虚拟头结点，此时未扫描部分对第一个节点的处理就和其他节点统一了，最终返回dummy-&gt;next 时间复杂度：O(n) ¶AC代码： 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* deleteDuplicates(ListNode* head) { auto dummy = new ListNode(-1); dummy-&gt;next = head; auto p = dummy; while(p-&gt;next){ auto q = p-&gt;next-&gt;next; while(q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next; if(p-&gt;next-&gt;next == q) p = p-&gt;next; else p-&gt;next = q; } return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-81. 搜索旋转排序数组 II","slug":"LeetCode刷题-81-搜索旋转排序数组-II","date":"2020-07-23T02:53:18.000Z","updated":"2020-07-23T10:27:12.237Z","comments":true,"path":"posts/38820.html","link":"","permalink":"https://www.itnxd.cn/posts/38820.html","excerpt":"","text":"题目链接：81. 搜索旋转排序数组 II ¶题解： 和之前题目类似：LeetCode刷题-33.搜索旋转排序数组 ¶题目简述： 给定一个有序有重复元素的序列，从某一个点反转一下，问该序列是否存在目标值！ 比之前类似题目多了一个重复元素！ ¶题解一：二分 其实不需要使用二分，因为二分最坏时间复杂度也为O(n)！ 我们使用二分的思路来做一下： 与之前写法完全一致，就是多了一点，不能直接进行二分！ 由于多了重复元素，会使得，该序列前一个升序的开始和后一个升序的结尾会有重合部分，无法通过二分得到中间值！ 所以：将第二个升序序列从末尾开始，如果和第一个升序序列开始一样，就删去，这样就完全转化为之前的题目了！ 具体操作： while(R &gt;= 0 &amp;&amp; nums[0] == nums[R]) R--; 就多了这一句，将重复部分删掉，注意删到只有一个元素的情况，直接判断返回即可 接下来和之前类似题目一模一样 先二分得到两端升序序列的分隔点 再判断在哪个序列 进行第二次二分找目标值 最后判断返回结果 具体思路：参考之前题目：LeetCode刷题-33.搜索旋转排序数组 时间复杂度： 最坏情况为，整个序列元素完全一样，这样第一个while循环会扫描n次，所以最坏时间复杂度为 O(n)，所以不如直接扫描一遍来的快！ ¶AC代码一： 123456789101112131415161718192021222324class Solution {public: bool search(vector&lt;int&gt;&amp; nums, int target) { if(nums.empty()) return false; int R = nums.size() - 1; while(R &gt;= 0 &amp;&amp; nums[0] == nums[R]) R--; if(R &lt; 0) return nums[0] == target; int l = 0, r = R; while(l &lt; r){ int mid = l + r + 1 &gt;&gt; 1; if(nums[mid] &gt;= nums[0]) l = mid; else r = mid - 1; } if(nums[0] &lt;= target) l = 0; else l = r + 1, r = R; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid; else l = mid + 1; } return nums[r] == target; }}; ¶题解二：直接扫描 没什么可解释的！ 时间复杂度： O(n) ¶AC代码二： 12345678class Solution {public: bool search(vector&lt;int&gt;&amp; nums, int target) { for(auto x : nums) if(x == target) return true; return false; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"},{"name":"线性扫描","slug":"线性扫描","permalink":"https://www.itnxd.cn/tags/%E7%BA%BF%E6%80%A7%E6%89%AB%E6%8F%8F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-80. 删除排序数组中的重复项 II","slug":"LeetCode刷题-80-删除排序数组中的重复项-II","date":"2020-07-23T02:52:28.000Z","updated":"2020-07-23T10:27:12.229Z","comments":true,"path":"posts/40432.html","link":"","permalink":"https://www.itnxd.cn/posts/40432.html","excerpt":"","text":"题目链接：80. 删除排序数组中的重复项 II ¶题解： 与之前一道题几乎类似：LeetCode刷题-26.删除排序数组中的重复项 ¶题目简述： 类似题目是删除排序数组重复项，最多出现一次，这个题是最多出现两次！ 要求：使用原地算法，即不开辟额外空间！ ¶题解： 思路： k &lt; 2时，直接存储到原数组 k &gt; 2时，判断当前元素和和该元素之前的前两个元素是否相同，若之前已经有两个和当前元素相同，则该元素多余直接跳过，否则累积起来，即nums[k ++ ] = x 最后返回长度k 时间复杂度：O(n) ¶AC代码： 12345678910class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { int k = 0; for(auto&amp; x : nums) if(k &lt; 2 || nums[k - 1] != x || nums[k - 2] != x) nums[k ++ ] = x; return k; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"Mr.Niu"},{"title":"LeetCode刷题-79. 单词搜索","slug":"LeetCode刷题-79-单词搜索","date":"2020-07-23T02:52:15.000Z","updated":"2020-07-23T10:27:12.234Z","comments":true,"path":"posts/24999.html","link":"","permalink":"https://www.itnxd.cn/posts/24999.html","excerpt":"","text":"题目链接：79. 单词搜索 ¶题解： 纯搜索题！ ¶题目简述： 在一个矩阵中找一个字符串，看是否存在，找的时候只能上下左右找，不能走走过的地方！ ¶题解： DFS搜索： bool dfs(int x, int y, int u) x, y：为当前位置下标 u：记录当前搜到的个数 递归出口：u == word.size() - 1 思路： 把每个点都当做起点进行搜索，每次搜索四个方向 若当前搜索位置和待匹配字符不匹配，直接return false 否则标记当前位置为*表示该位置已使用，且无法与待匹配字符进行匹配 开始搜索四个方向，保证下标不越界 如果有一个方向符合条件，直接终止搜索，返回return true，即if(dfs(tx, ty, u + 1)) return true;（可以保证有一条有效路径就直接终止搜索） for循环结束，说明当前位置无法继续向前，还原该位置标记，返回return false 有一个起点符合即终止，全部起点都不匹配，直接返回return false 注意： 向四个方向搜索，判断条件没有写是否访问该点，其实写不写都可以，因为下一次搜索如果搜索上一次用过的，会在下一次搜索的第一句话直接返回false，所以无影响 时间复杂度： 由于有n2个起点，每个起点除了第一个位置四个方向，后面都是三个方向（不能走回头路），每个方向的深度为k即待匹配字符串的长度，所以总时间复杂度为：O(n 2 * 3 k)。是一个指数级别的爆搜，会爆掉时间，但是一般由于数据较水，也可以通过剪枝，使得搜到的子问题很小，一般不需要考虑爆搜时间复杂度！ ¶AC代码：不使用数组标记 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;vector&lt;char&gt;&gt; board; string word; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; _board, string _word) { board = _board, word = _word; int n = board.size(), m = board[0].size(); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) if(dfs(i, j, 0)) return true; return false; } bool dfs(int x, int y, int u){ if(board[x][y] != word[u]) return false; if(u == word.size() - 1) return true; char t = board[x][y]; board[x][y] = '*'; int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1}; for(int i = 0; i &lt; 4; i++){ int tx = x + dx[i], ty = y + dy[i]; if(tx &gt;= 0 &amp;&amp; tx &lt; board.size() &amp;&amp; ty &gt;= 0 &amp;&amp; ty &lt; board[0].size()){ if(dfs(tx, ty, u + 1)) return true; } } board[x][y] = t; return false; }}; ¶AC代码：使用数组标记 由于使用数组标记，就不具备上面的注意点那条性质了，必须乖乖的判断是否访问过！ 这样写会额外开辟一个数组空间，显然前者更加优一点！ 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;char&gt;&gt; board; vector&lt;vector&lt;bool&gt;&gt; vis; string word; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; _board, string _word) { board = _board, word = _word; int n = board.size(), m = board[0].size(); vis = vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(m)); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) if(dfs(i, j, 0)) return true; return false; } bool dfs(int x, int y, int u){ if(board[x][y] != word[u]) return false; if(u == word.size() - 1) return true; vis[x][y] = true; int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1}; for(int i = 0; i &lt; 4; i++){ int tx = x + dx[i], ty = y + dy[i]; if(tx &gt;= 0 &amp;&amp; tx &lt; board.size() &amp;&amp; ty &gt;= 0 &amp;&amp; ty &lt; board[0].size() &amp;&amp; !vis[tx][ty]){ if(dfs(tx, ty, u + 1)) return true; } } vis[x][y] = false; return false; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"搜索","slug":"搜索","permalink":"https://www.itnxd.cn/tags/%E6%90%9C%E7%B4%A2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-78. 子集","slug":"LeetCode刷题-78-子集","date":"2020-07-23T02:52:04.000Z","updated":"2020-07-23T10:27:12.221Z","comments":true,"path":"posts/61204.html","link":"","permalink":"https://www.itnxd.cn/posts/61204.html","excerpt":"","text":"题目链接：78. 子集 ¶题解： 与之前的题几乎一致：AcWing-92.递归实现指数型枚举 ¶题目简述： 给定一个集合，枚举所有子集，包括空集！ ¶题解一：使用二进制 和之前题一样，做法一模一样： 每个数选与不选两种情况，一共有0 ~ 1 &lt;&lt; nums.size() - 1种情况，枚举每个二进制位是否为1即可！ 时间复杂度： 一共枚举2n 个数，每个数枚举n位，总时间复杂度为 O(2n * n) 注意： 当 n &gt;= 30时，2n &gt; 109 会超时 ¶AC代码一： 12345678910111213class Solution {public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; res; for(int state = 0; state &lt; 1 &lt;&lt; nums.size(); state ++){ vector&lt;int&gt; path; for(int k = 0; k &lt; nums.size(); k++) if(state &gt;&gt; k &amp; 1) path.push_back(nums[k]); res.push_back(path); } return res; }}; ¶题解二：使用DFS 思路： 使用for循环分别去搜索位数为0 ~ nums.size()的序列 dfs(int u, int cnt, int start)：参数分别为 目标位数，当前第几位，下一次的起始位置（防止重复） ¶AC代码二： 1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;int&gt; nums; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; _nums) { nums = _nums; sort(nums.begin(), nums.end()); for(int i = 0; i &lt;= nums.size(); i++) dfs(i, 0, 0); return res; } void dfs(int u, int cnt, int start){ if(cnt == u){ res.push_back(path); return; } for(int i = start; i &lt; nums.size(); i++){ path.push_back(nums[i]); dfs(u, cnt + 1, i + 1); path.pop_back(); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-77. 组合","slug":"LeetCode刷题-77-组合","date":"2020-07-23T02:51:52.000Z","updated":"2020-07-23T10:27:12.219Z","comments":true,"path":"posts/14686.html","link":"","permalink":"https://www.itnxd.cn/posts/14686.html","excerpt":"","text":"题目链接：77. 组合 ¶题解： 简单递归！ ¶题目简述： 在 n 个数选取 k 个数的组合！ ¶题解： DFS思路：dfs(int u, int start) u：记录当前搜到了第几个数 start：记录当前数的开始位置，即从上一个数的后一个开始，有效避免重复 res累积答案，path保存每一组合法序列！ 递归出口：u == k 搜完u个数即终止！ 时间复杂度： 方案数为 O(Cnk )，每个方案需要O(k)，总时间复杂度为O(Cnk * k) ¶AC代码： 12345678910111213141516171819202122class Solution {public: int n, k; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; combine(int _n, int _k) { n = _n, k = _k; dfs(0, 1); return res; } void dfs(int u, int start){ if(u == k){ res.push_back(path); return; } for(int i = start; i &lt;= n; i++){ path.push_back(i); dfs(u + 1, i + 1); path.pop_back(); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-76. 最小覆盖子串","slug":"LeetCode刷题-76-最小覆盖子串","date":"2020-07-23T02:51:41.000Z","updated":"2020-07-23T10:27:12.206Z","comments":true,"path":"posts/59607.html","link":"","permalink":"https://www.itnxd.cn/posts/59607.html","excerpt":"","text":"题目链接：76. 最小覆盖子串 ¶题解： 滑动窗口界的一大难题！ ¶题目简述： 给定两个字符串，从一个串找到包含另一个字符串所有字符的子串，并找到最短的一个！ ¶题解： 双指针算法： 两个指针都从起点从左向右，i指针指向该区间终点，j指针指向该区间起点，维护一段区间i ~ j使得该区间包含待匹配字符串的每个字符。 具体做法： 为了判断该区间是否包含待匹配字符串的每个字符，我们使用一个哈希表动态存储该区间每个字符出现的次数 使用变量cnt统计该区间有效字符个数（即待匹配字符串中对应匹配的字符），只要该区间当前字符个数小于等于待匹配字符串的当前字符个数，即为有效字符，进行统计，即hs[s[j]] &lt;= ht[s[j]] 维护起点j，若新加入的字符导致hs[s[j]] &gt; ht[s[j]]，则说明起点j可以后移，即 hs[s[j ++ ]] --，还得保证起点j一定是一个合法字符（即起点一定不是待匹配字符串没有的字符，如：ADOBECODEBA 匹配 ABC，应该要将起点A删去，再将DOBECODE删去。剩下BA，即这里是需要while来控制的） 当cnt == t.size()：即该区间已经匹配，进行更新res即可，res为空也要更新！ 使用双指针算法的条件：一定要有单调性，即一个指针后移，另一个指针也要后移！ 对于本题：i' &lt; i, j &lt; j'时，当i向后走到i'，由于原来的j ~ i已经匹配，所以j一定不会往前走到j'，即j一定会不动或者向后走，这样就保证了单调性！ 时间复杂度： O(n) ¶AC代码： 12345678910111213141516171819class Solution {public: string minWindow(string s, string t) { unordered_map&lt;char, int&gt; hs, ht; for(auto&amp; c : t) ht[c] ++; int cnt = 0; string res; for(int i = 0, j = 0; i &lt; s.size(); i ++){ hs[s[i]] ++; if(hs[s[i]] &lt;= ht[s[i]]) cnt ++; while(hs[s[j]] &gt; ht[s[j]]) hs[s[j ++ ]] --; if(cnt == t.size()){ if(res.empty() || i - j + 1 &lt; res.size()) res = s.substr(j, i - j + 1); } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://www.itnxd.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-75. 颜色分类","slug":"LeetCode刷题-75-颜色分类","date":"2020-07-22T14:26:43.000Z","updated":"2020-07-23T10:27:12.216Z","comments":true,"path":"posts/3416.html","link":"","permalink":"https://www.itnxd.cn/posts/3416.html","excerpt":"","text":"题目链接：75. 颜色分类 ¶题解： 通过双指针思路将区间划分开，并进行维护区间操作！ ¶题目简述： 给定0、1、2三个数字的乱序序列，按照0，1，2的顺序将相同数字排到一起！ 要求不使用排序函数！ ¶题解： 思路：双指针，其实是三指针，i和j 从前往后扫描，k从后往前扫描，维护下面三个区间 0 ~ j - 1：保证都是0 j ~ i - 1：保证都是1 nums.size() - 1 ~ k + 1：保证都是2 i和k相遇即排好序！ nums[i]的三种情况： nums[i] == 0：swap(nums[j++], nums[i++]) 交换后i位置为1，可以直接往后走，即i++ nums[i] == 1：该位置属于为1的区间，直接i后移，即i++ nums[i] == 2：swap(nums[i], nums[k--]) 交换后i位置未知，不可以直接往后走 时间复杂度： O(n) ¶AC代码： 12345678910class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { for(int i = 0, j = 0, k = nums.size() - 1; i &lt;= k;){ if(nums[i] == 0) swap(nums[i++], nums[j++]); else if(nums[i] == 2) swap(nums[i], nums[k--]); else i++; } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"三指针","slug":"三指针","permalink":"https://www.itnxd.cn/tags/%E4%B8%89%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-74. 搜索二维矩阵","slug":"LeetCode刷题-74-搜索二维矩阵","date":"2020-07-22T14:26:29.000Z","updated":"2020-07-23T10:27:12.225Z","comments":true,"path":"posts/59764.html","link":"","permalink":"https://www.itnxd.cn/posts/59764.html","excerpt":"","text":"题目链接：74. 搜索二维矩阵 ¶题解： 二维的二分，第一次见，其实可以通过取除和取余转换为一维！ ¶题目简述： 给定一个二维有序矩阵，从左到右，从上到下，都是升序序列，每行最末小于下一行最开始！ 判断知否存在一个目标值！ ¶题解： 嗯，暴力，使用额外数组将二维变为一维！ 再进行二分！ 二分条件：v[mid] &gt;= target 注意： 对空矩阵判断，两种情况[]，[[]]，所以需要matrix.empty() || matrix[0].empty() 其实可以将一个0 ~ n * m - 1的数转变为一个二维下标的： matrix[mid / m][mid % m]：第一个算行，第二个算列即可！ 详细代码见AC代码二！ ¶AC代码一：暴力 12345678910111213141516171819class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { if(matrix.empty() || matrix[0].empty()) return false; int n = matrix.size(), m = matrix[0].size(); vector&lt;int&gt; v(n * m); int k = 0; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) v[k++] = matrix[i][j]; int l = 0, r = k - 1; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(v[mid] &gt;= target) r = mid; else l = mid + 1; } return v[r] == target; }}; ¶AC代码二：正解 1234567891011121314class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { if(matrix.empty() || matrix[0].empty()) return false; int n = matrix.size(), m = matrix[0].size(); int l = 0, r = n * m - 1; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(matrix[mid / m][mid % m] &gt;= target) r = mid; else l = mid + 1; } return matrix[r / m][r % m] == target; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"},{"name":"二维二分","slug":"二维二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E7%BB%B4%E4%BA%8C%E5%88%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-73. 矩阵置零","slug":"LeetCode刷题-73-矩阵置零","date":"2020-07-22T14:26:14.000Z","updated":"2020-07-23T10:27:12.199Z","comments":true,"path":"posts/11107.html","link":"","permalink":"https://www.itnxd.cn/posts/11107.html","excerpt":"","text":"题目链接：73. 矩阵置零 ¶题解： LeetCode题目总是要求不使用额外空间。。导致这道题做法就特别取巧，不好想！ ¶题目简述： 给定一个矩阵只有0和其他数，将是0的对应的改行与该列都变为0！ 要求不使用额外空间！ ¶题解： 本来这题开一个数组即可，非要求原地处理。。。 现在给出空间O(1)的算法： 使用两个变量r0和c0分别记录第一列和第一行是否有0 使用矩阵的第一行matrix[0][j]记录第j列是否有0（j 的范围为 1 - m - 1) 使用矩阵的第一列matrix[i][0]记录第i行是否有0 （i 的范围为 1 - n - 1) 现在就可以根据上面的记录去处理每一行和每一列了！ 时间复杂度： O(n * m) ¶AC代码： 12345678910111213141516171819202122232425262728293031class Solution {public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if(matrix.empty()) return; int n = matrix.size(), m = matrix[0].size(); int r0 = 1, c0 = 1; for(int i = 0; i &lt; n; i++) if(!matrix[i][0]) r0 = 0; for(int i = 0; i &lt; m; i++) if(!matrix[0][i]) c0 = 0; for(int i = 1; i &lt; n; i++) for(int j = 0; j &lt; m; j++) if(!matrix[i][j]) matrix[i][0] = 0; for(int i = 1; i &lt; m; i++) for(int j = 0; j &lt; n; j++) if(!matrix[j][i]) matrix[0][i] = 0; for(int i = 1; i &lt; n; i++) if(!matrix[i][0]) for(int j = 0; j &lt; m; j++) matrix[i][j] = 0; for(int i = 1; i &lt; m; i++) if(!matrix[0][i]) for(int j = 0; j &lt; n; j++) matrix[j][i] = 0; if(!r0) for(int i = 0; i &lt; n; i++) matrix[i][0] = 0; if(!c0) for(int i = 0; i &lt; m; i++) matrix[0][i] = 0; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"取巧算法","slug":"取巧算法","permalink":"https://www.itnxd.cn/tags/%E5%8F%96%E5%B7%A7%E7%AE%97%E6%B3%95/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-72. 编辑距离","slug":"LeetCode刷题-72-编辑距离","date":"2020-07-22T14:26:00.000Z","updated":"2020-07-23T10:27:12.211Z","comments":true,"path":"posts/60666.html","link":"","permalink":"https://www.itnxd.cn/posts/60666.html","excerpt":"","text":"题目链接：72. 编辑距离 ¶题解： 动态规划应用，很有意思！ ¶题目简述： 将一个单词变为另一个单词，只有三种操作，替换，删除，插入！问最少步数！ ¶题解： 动态规划： 状态表示： 两个字符串，使用二维数组f[i][j]表示a字符串的的0 - i和b字符串的 0 - j匹配时的最少步数！ 状态计算： 处理最后一步， 三种情况 删除一个字符：f[i][j] = f[i - 1][j] + 1 即a字符串删除一个会匹配，则a字符串的前i - 1个是和b字符串的前j个匹配，所以当前最少步数就是该匹配最少步数加一（当前删除操作的一步） 插入一个字符：f[i][j] = f[i][j - 1] + 1 解释：与上面同理 替换一个字符：两种情况 a[i] == b[j]：即该字符已经匹配无需替换，f[i - 1][j - 1] + 0 a[i] != b[j]：即该字符已经匹配需要替换，f[i - 1][j - 1] + 1 综上所述： 状态转移方程为：f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1; f[i][j] = min(f[i][j], f[i - 1][j - 1] + t); 最终答案： f[n][m] 表示a字符串变为b字符串的最少步数！ 初始化： f[i][0] = i, f[0][j] = j 即一个为空，一个不空，则最少需要不空的长度才可以转变为一样 注意： 为了不对边界0的处理，字符串都在最前端加一个空格！ 时间复杂度： O(n) ¶AC代码： 123456789101112131415161718class Solution {public: int minDistance(string a, string b) { int n = a.size(), m = b.size(); a = ' ' + a, b = ' ' + b; vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1)); for(int i = 0; i &lt;= n; i++) f[i][0] = i; for(int i = 0; i &lt;= m; i++) f[0][i] = i; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1; int t = a[i] == b[j] ? 0: 1; f[i][j] = min(f[i][j], f[i - 1][j - 1] + t); } } return f[n][m]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-71. 简化路径","slug":"LeetCode刷题-71-简化路径","date":"2020-07-22T14:25:39.000Z","updated":"2020-07-23T10:27:12.203Z","comments":true,"path":"posts/59982.html","link":"","permalink":"https://www.itnxd.cn/posts/59982.html","excerpt":"","text":"题目链接：71. 简化路径 ¶题解： 模拟题，总是处理两个斜杠中间字符！ ¶题目简述： 给定一个绝对路径，该绝对路径以/开始，不一定以/结束，并且可能会出现连续斜杠，要求转换为最简的路径！ ./：当前目录 ../：上层目录 根目录没有上层目录，仍为根目录 ¶题解： 思路： 将两个斜杠中间的字符截取出来，进行判断 答案的格式保证一定是/xxx/xxx... .：即为当前目录，不处理，跳过即可 ..：即返回上一层目录，将当前答案字符串res从后向前删到第一个斜杠，再将此处斜杠删掉（保证不越界） 空：即两个斜杠挨着，不处理，跳过 目录名：合法目录，将在答案最后加一个斜杠，再加上当前目录名 /：即累积的中间字符结束 注意： 以防给定的绝对路径最后不是空格，导致最后一组斜杠中间的字符无法截取，我们给最后没有斜杠的绝对路径加一个斜杠进行统一！ 每次将name字符串清空 对于在根目录进行上层操作的行为，会使得最后答案为空，所以在最后判断一下是否为空，是则返回一个斜杠！ string的back()和pop_back()属于C++ 11 标准！ ¶AC代码： 12345678910111213141516171819202122class Solution {public: string simplifyPath(string path) { string res, name; if (path.back() != '/') path += '/'; for (auto c : path) { if (c != '/') name += c; else { if (name == \"..\") { while (res.size() &amp;&amp; res.back() != '/') res.pop_back(); if (res.size()) res.pop_back(); } else if (name != \".\" &amp;&amp; name != \"\") { res += '/' + name; } name.clear(); } } if (res.empty()) res = \"/\"; return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"}],"author":"Mr.Niu"},{"title":"蓝桥杯省赛-1207. 大臣的旅费","slug":"蓝桥杯省赛-1207-大臣的旅费","date":"2020-07-21T09:57:22.000Z","updated":"2020-07-21T13:41:29.829Z","comments":true,"path":"posts/61315.html","link":"","permalink":"https://www.itnxd.cn/posts/61315.html","excerpt":"","text":"题目链接：蓝桥杯省赛-1207. 大臣的旅费 题目来源：第四届蓝桥杯省赛C++A组 ¶题解： 本题用到了许多知识！下面给出参考教程及必备知识！ 链式前向星：我的简单总结！点击这里！ 树的直径及树形DP：秦淮岸灯火阑珊大佬的数的直径及树形DP讲义！点击这里！ 秦淮岸大佬讲义对应视频：点击这里！ 两次BFS搜索：DaulFrank大佬的两次BFS搜索！点击这里！ 两次DFS搜索：小呆呆大佬的两次DFS搜索！点击这里！ ¶两次搜索与树形DP区别： 两次搜索可以求出数的直径的路径与值！写起来略麻烦！ 树形DP仅仅可以求出值！写起来简单！ ¶知识积累一：树的直径 首先先引入圆的直径： 圆的直径就是圆上两点连线的最长的时候，所以树的直径就是树上最远两个点的距离！ 官方解释： 在一棵树中，每一条边都有权值，树中的两个点之间的距离，定义为连接两点的路径上边权之和，那么树上最远的两个点，他们之间的距离，就被称之为，树的直径。 树的直径的别称，树的最长链。 请注意：树的直径，还可以认为是一条路径，不一定是只是一个数值。 稍做解释： 当树的边权都为1或者没有边权时，即为树的最长连 当树的边权不都为1时，树的直径为一条路径上的边权之和最大的那条 ¶知识积累二：树形DP 主要用来求树的直径！ 树形DP定义： 设1号节点为根节点，那么一张N个点，N−1条边的无向图,我们可以认为它是一棵有根树。 我们不妨设dis[x]表示从节点x出发，以x为根的子树，能过到达最远节点的距离。 也就是对于x节点而言的最长链。（**注意：**此处x到达的只能是孩子节点，不能到达父节点） 做一个规约： 父节点为 x 子节点为 y dis[x]表示从x节点出发的最长链的边权和 ver[i]表示以i为终点的边权 res 表示树的直径，即最大的边权之和 接下来继续： 状态表示： dis[x] 含义见上面！ 转态计算：dis[x] = max(dis[x], dis[y] + ver[i]) 简单解释：从x出发的最长链 = 从儿子节点出发的最长链 + 父亲到儿子的距离 并且最后取一个最大值（即找一边权和最大的） 再看此时的数的直径如何计算？ **先给出结论：数的直径 = 最长链 + 次长链 即 res = max(res, dis[x] + dis[y] + ver[i]); ** 简单解释： 从一个节点出发的最长链和次长链的和就是一条待选择的，所有节点的最长链和次长链的和的最大值即为树的直径！ 对于最长链和次长链的两种情况： dis[x] &lt; dis[y] + ver[i]：即当前儿子的路径更长，由于原来最长为dis[x]，现在儿子最长，则最长链：dis[y] + ver[i]； 次长链为：dis[x] dis[x] &gt; dis[y] + ver[i]：即当前儿子的路径不如父亲长，此时：最长链：dis[x] 次长链：？dis[y] + ver[i]是吗？不是的，此时的儿子还不一定遍历完了，所以，此时的儿子这条路径可能为第二长，第三长 … 对于第一种情况：res = dis[x] + dis[y] + ver[i] 对于第二种情况：res = dis[x] + dis[y] + ver[i] （虽然此时的儿子路径不一定是次长，但是后面遍历的过程会逐渐更新） 此时的y指的是x的所有儿子节点，所以最终数的直径为：res = max(res, dis[x] + dis[y] + ver[i]) 注意点： 下面代码顺序不能换，一定要先搜索到根节点，然后先更新树的直径，再更新父节点的边权！ 后两句顺序反了会导致父节点先更新，答案树的直径逻辑就不对了！ 123dp(y);res = max(res, dis[x] + dis[y] + ver[i]);dis[x] = max(dis[x], dis[y] + ver[i]); ¶模板：树的直径 下面的例题就是树的直径模板题！ 代码见 AC代码一 ！ ¶题目简述： 给定n个节点，n - 1条边的带权无向图，问从一个节点到另一个节点的最大边权之和的路径的路费！ 对于路费：如果边权之和为1 则路费为11 边权和为 2 路费为 11 + 12 …类似 即 11 + 12 + 13 + 14… ¶题解一：树形DP 有了上面两个知识积累，会发现这个题就是让你求数的直径，然后将数的直径转换为路费即可！ 对于路费：是一个以11为首相，1为公差，项数为树的直径的等差数列，求和公式为 res * 11 + res * (res - 1ll) / 2 注意： 防止结果溢出，使用1ll强转一下 无向图，需要正反存储两次边 正反存储两次边，所以对于链式前向星存储，每条边的编号tot的范围为 2 * (n - 1) 一条边需要两个编号（正反向），所以edge ver Next数组都是2倍空间！ 注意链式前向星head数组的初始化，即最开始邻接表都指向-1 时间复杂度： $O(n)$ ¶AC代码一： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int head[N], edge[N * 2], ver[N * 2], Next[N * 2], n, tot;int vis[N], dis[N], res;void add(int u, int v, int w){ edge[tot] = v; ver[tot] = w; Next[tot] = head[u]; head[u] = tot++;}void dp(int x){ vis[x] = 1; for(int i = head[x]; ~i; i = Next[i]){ int y = edge[i]; if(vis[y]) continue; dp(y); res = max(res, dis[x] + dis[y] + ver[i]); dis[x] = max(dis[x], dis[y] + ver[i]); }}int main(){ cin &gt;&gt; n; memset(head, -1, sizeof head); for(int i = 0; i &lt; n - 1; i++){ int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, w); } dp(1); printf(\"%lld\\n\", res * 11 + res * (res - 1ll) / 2); return 0;} ¶知识积累三：两次搜索 两次搜索思量： 随便选一点x开始搜索，找到离当前点最远的y 从y开始搜索，找到离当前节点最远的z y到z的路径就是树的直径！ 由于是搜索，是可以记录路径的！ 证明： y一定是树的直径的一个端点 仍然使用反证法： 假设：y不是树的直径的一个端点，且 u - v 为树的直径！ 默认条件： 离 x 最远的节点为 y 情况一： x - y 与 u - v 有交点，且 离 x 最远的节点为 y，则： 123451 + 4 &gt;= 1 + 3即 3 &lt;= 43 + 2 &lt;= 4 + 2即 u - v 不一定最长若u - v 为直径，则u - y, v - y 都是直径，与假设矛盾， 即y一定是树的直径的一个端点！ 情况二： x - y 与 u - v 没有交点，且 离 x 最远的节点为 y，则： 1234561 + 2 &gt;= 1 + 3 + 5即 2 &gt;= 3 + 52 + 3 &gt; 52 + 3 + 4 &gt; 5 + 4即 u - v 一定不是最长与假设矛盾，从y出发一定有比 u - v更长的路径，如 2 - 3 - 4 、2 - 3 - 5 终上所述： 从一个点搜索到距离最远的点，改点一定是树的直径的一个端点！ 从树的直径出发搜一个最远的点，一定是树的直径！ ¶题解二：两次DFS搜索 使用DFS搜索：两种方法，建议使用第二种，少开辟一个数组，并且减少一次初始化操作！ void dfs(int x, int distance) ：参数为父节点和当前已经累积的距离 void dfs(int x, int father, int distance)：参数为父节点和当前节点的父节点，以及当前已经累积的距离 搜索入口：dfs(1, -1, 0) 以1号边为根节点开始搜索，根节点没有父节点为-1 简单的思路： 从根节点开始，往下搜索一个儿子就将当前儿子的权累加父节点，直到搜完节点，得到每个叶子节点从根到自己的权之和！ 遍历一次每个节点，找到从根节点最远的节点，即dis数组最大的那个节点的下标即可！ 再从当前最大权的节点搜索一次，找到离当前端点最远的节点即可！ 再次遍历一次每个及诶单，找到该最远的节点！ 等差求和 注意： 第二次搜索dis数组不需要初始化，因为下一次搜索会全部进行覆盖！ 时间复杂度： $O(n)$ ¶AC代码二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// 使用vis数组判断 第二次搜索需要初始化一次该数组#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int head[N], edge[N * 2], ver[N * 2], Next[N * 2], n, tot;int vis[N], dis[N], res;void add(int u, int v, int w){ edge[tot] = v; ver[tot] = w; Next[tot] = head[u]; head[u] = tot++;}void dfs(int x, int distance){ dis[x] = distance; vis[x] = 1; for(int i = head[x]; ~i; i = Next[i]){ int j = edge[i]; if(vis[j]) continue; dfs(j, distance + ver[i]); }}int main(){ cin &gt;&gt; n; memset(head, -1, sizeof head); for(int i = 0; i &lt; n - 1; i++){ int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, w); } dfs(1, 0); int u = 1; for(int i = 1; i &lt;= n; i++) if(dis[i] &gt; dis[u]) u = i; memset(vis, 0, sizeof vis); dfs(u, 0); for(int i = 1; i &lt;= n; i++) res = max(res, dis[i]); printf(\"%lld\\n\", res * 11 + res * (res - 1ll) / 2); return 0;}/************************************************************************************************//************************************************************************************************/// 不使用vis数组 使用father变量判断#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int head[N], edge[N * 2], ver[N * 2], Next[N * 2], n, tot;int vis[N], dis[N], res;void add(int u, int v, int w){ edge[tot] = v; ver[tot] = w; Next[tot] = head[u]; head[u] = tot++;}void dfs(int x, int father, int distance){ dis[x] = distance; for(int i = head[x]; ~i; i = Next[i]){ int y = edge[i]; if(y == father) continue; dfs(y, x, distance + ver[i]); }}int main(){ cin &gt;&gt; n; memset(head, -1, sizeof head); for(int i = 0; i &lt; n - 1; i++){ int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, w); } dfs(1, -1, 0); int u = 1; for(int i = 1; i &lt;= n; i++) if(dis[i] &gt; dis[u]) u = i; dfs(u, -1, 0); for(int i = 1; i &lt;= n; i++) res = max(res, dis[i]); printf(\"%lld\\n\", res * 11 + res * (res - 1ll) / 2); return 0;} ¶题解三：两次BFS搜索 两次BFS搜索： 思路： 与两次DFS思想一致，走到儿子就更新儿子的权，下方BFS过程也是一个标准过程！ 先进行vis 和 dis数组的初始化 随便一个节点进行搜索 将当前节点假如队列，标记使用过 出队列，将当前队首的所有没有访问过的儿子节点进队 更新儿子节点的权为父节点权与当前路径之和，即 dis[y] = dis[x] + ver[i]; 为了减少最后的扫描，可以在其中进行统计最大权的下标max_i 标记儿子用过，儿子入队 队列为空结束 从最大权的下标max_i开始第二次搜索找到树的直径的终点！ 等差求和 时间复杂度： $O(n)$ ¶AC代码三： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// https://www.acwing.com/solution/content/7896/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int head[N], edge[N * 2], ver[N * 2], Next[N * 2], n, tot;int vis[N], dis[N], res;void add(int u, int v, int w){ edge[tot] = v; ver[tot] = w; Next[tot] = head[u]; head[u] = tot++;}int bfs(int u){ queue&lt;int&gt; q; memset(vis, 0, sizeof vis); memset(dis, 0, sizeof dis); int max_i; q.push(u); vis[u] = 1; while(q.size()){ int x = q.front(); q.pop(); for(int i = head[x]; ~i; i = Next[i]){ int y = edge[i]; if(vis[y]) continue; dis[y] = dis[x] + ver[i]; if(dis[y] &gt; res){ res = dis[y]; max_i = y; } vis[y] = 1; q.push(y); } } return max_i;}int main(){ cin &gt;&gt; n; memset(head, -1, sizeof head); for(int i = 0; i &lt; n - 1; i++){ int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, w); } int u = bfs(1); bfs(u); printf(\"%lld\\n\", res * 11 + res * (res - 1ll) / 2); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://www.itnxd.cn/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[{"name":"树的直径","slug":"树的直径","permalink":"https://www.itnxd.cn/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"两次搜索","slug":"两次搜索","permalink":"https://www.itnxd.cn/tags/%E4%B8%A4%E6%AC%A1%E6%90%9C%E7%B4%A2/"},{"name":"树形DP","slug":"树形DP","permalink":"https://www.itnxd.cn/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"链式前向星","slug":"链式前向星","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-70. 爬楼梯","slug":"LeetCode刷题-70-爬楼梯","date":"2020-07-20T13:46:14.000Z","updated":"2020-07-21T03:10:22.374Z","comments":true,"path":"posts/42551.html","link":"","permalink":"https://www.itnxd.cn/posts/42551.html","excerpt":"","text":"题目链接：70. 爬楼梯 ¶题解： 简单动态规划问题！ ¶题目简述： 每次只能爬一个台阶或两个台阶，求爬到第 n 个台阶的方案数！ ¶题解： 动态规划： 状态表示：f[i]表示爬到第 i 个台阶的方案数 状态计算：f[i] = f[i - 1] + f[i - 2] 简单解释：爬到第 i 个台阶的最后一步，一定是跨了一步或跨了两步，所以到达当前台阶的方案数一定是前 i - 1个台阶的方案数和前 i - 2 个台阶的方案数之和！ 初始转态： f[0] = 1 f[1] = 1 最终结果： f[n] 优化一下，不开辟数组，降低空间复杂度，只使用三个变量即可，如下！ 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ ¶AC代码： 123456789101112131415161718192021class Solution {public: int cnt; int climbStairs(int n) { // vector&lt;int&gt; f(n + 1); // f[0] = 1; // f[1] = 1; // for(int i = 2; i &lt;= n; i++){ // f[i] = f[i - 1] + f[i - 2]; // } // return f[n]; int a = 1, b = 1, c; if(n &lt;= 1) return 1; for(int i = 2; i &lt;= n; i++){ c = a + b; a = b; b = c; } return c; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-69. x 的平方根","slug":"LeetCode刷题-69-x-的平方根","date":"2020-07-20T13:46:00.000Z","updated":"2020-07-21T03:10:22.373Z","comments":true,"path":"posts/15768.html","link":"","permalink":"https://www.itnxd.cn/posts/15768.html","excerpt":"","text":"题目链接：69. x 的平方根 ¶题解： 二分应用求平方根！一定要斟酌好使用哪个模板！ ¶题目简述： 开平方，小数部分舍去求整数部分！ ¶题解： 使用二分解决，一定要选对模板！ 选不对模板，会有特别情况需要去处理！ ¶AC代码一：二分模板一 防止溢出，加一个 1ll 条件：mid &lt;= x / mid （不要使用mid * mid会溢出）最终找到的是小于等于根号x的最大整数！ 123456789101112class Solution {public: int mySqrt(int x) { int l = 0, r = x; while(l &lt; r){ int mid = l + r + 1ll &gt;&gt; 1; if(mid &lt;= x / mid) l = mid; else r = mid - 1; } return r; }}; ¶AC代码二：二分模板二 防止溢出，加一个 0ll 条件：mid &gt;= x / mid （不要使用mid * mid会溢出）最终找到的是大于等于根号x的最小整数！（根号9 找到的是 3； 根号10 找到的是4） 使用此模板需要特判： x 为 0 或 1 进入while会成为死循环，特判返回x 如果针对根号10的情况，即r &gt; x / r 需要 r-- 1234567891011121314class Solution {public: int mySqrt(int x) { if(x &lt;= 1) return x; int l = 0, r = x; while(l &lt; r){ int mid = l + 0ll + r &gt;&gt; 1; if (mid &gt;= x / mid) r = mid; else l = mid + 1; } if(r &gt; x / r) r--; return r; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-68. 文本左右对齐","slug":"LeetCode刷题-68-文本左右对齐","date":"2020-07-20T13:45:42.000Z","updated":"2020-07-21T03:10:22.370Z","comments":true,"path":"posts/6698.html","link":"","permalink":"https://www.itnxd.cn/posts/6698.html","excerpt":"","text":"题目链接：68. 文本左右对齐 ¶题解： 又是一道有点恶心的模拟题，刚开始竟然没有看懂题！ ¶题目简述： 给定一堆单词，和一个最大长度，要求在不超过最大长度的条件下尽可能多放单词，并使得单词之间尽可能均匀分布！ ¶题解： 题目解释： 假如一行放三个单词长度不超过最大长度，放四个超过了，则当前行只能放三个，还得保证三个单词之间的两个空隙尽可能相等（使用空格填充），如果无法相等，则保证左边的比右边的多一！ 举个例子： 该行最多放四个单词，总长为9， 最大长度为20，则剩余空格数为11个，要均匀分布到三个空隙，所以11 / 3 = 3 … 2 所以三个空隙空格数依次为：3 + 1， 3 + 1，4 即可！ 分析： 左对齐： 最后一行需要左对齐 某一行只有一个单词需要左对齐 左右对齐：一般情况，不是最后一行和不仅仅只有一个单词**！** 具体做法： 先找到一行能放的最大长度，该长度包括两个单词间的一个空隙 若为一个单词或最后一行，即j == words.size() || j == i + 1，将单词间隔一个空隙，后面的位置填补空格 若为一般情况，需要计算空隙数cnt = j - i - 1以及剩余空格数maxWidth - len + cnt(因为len中已经包含了两个单词间的一个空隙，所以多减了，再加回来) 如果剩余空格和空隙无法平均分配，则将前面的多加一，即k &lt; blank % cnt，即空隙为string(blank / cnt + 1, ' ')；剩余的空隙为string(blank / cnt, ' ') 将当前行假如res 更新下一行起点为i = j ¶AC代码： 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) { vector&lt;string&gt; res; for(int i = 0; i &lt; words.size();){ int j = i + 1; int len = words[i].size(); while(j &lt; words.size() &amp;&amp; len + 1 + words[j].size() &lt;= maxWidth) len += 1 + words[j++].size(); string line; // 最后一行或该行只有一个单词 左对齐 if(j == words.size() || j == i + 1){ line += words[i]; for(int k = i + 1; k &lt; j; k++) line += ' ' + words[k]; while(line.size() &lt; maxWidth) line += ' '; }else{ // 一般情况，左右对齐 // 空隙数 剩余空格数 int cnt = j - i - 1, blank = maxWidth - len + cnt; line += words[i]; int k = 0; while(k &lt; blank % cnt) line += string(blank / cnt + 1, ' ') + words[i + k + 1], k++; while(k &lt; cnt) line += string(blank / cnt, ' ') + words[i + k + 1], k++; } res.push_back(line); // 更新下一行起点 i = j; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-67. 二进制求和","slug":"LeetCode刷题-67-二进制求和","date":"2020-07-20T13:45:28.000Z","updated":"2020-07-21T03:10:22.371Z","comments":true,"path":"posts/15234.html","link":"","permalink":"https://www.itnxd.cn/posts/15234.html","excerpt":"","text":"题目链接：67. 二进制求和 ¶题解： 类似于高精度加法！ ¶题目简述： 两个二进制数的加法！ ¶题解： 为了方便做加法，现将两个字符串倒序！ 模拟加法即可！ 循环终止条件：i &lt; a.size() || i &lt; b.size() || t 最终再次倒序，即为答案！ ¶AC代码： 12345678910111213141516class Solution {public: string addBinary(string a, string b) { reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); string res; for(int i = 0, t = 0; i &lt; a.size() || i &lt; b.size() || t; i++){ if(i &lt; a.size()) t += a[i] - '0'; if(i &lt; b.size()) t += b[i] - '0'; res += t % 2 + '0'; t /= 2; } reverse(res.begin(), res.end()); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"https://www.itnxd.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-66. 加一","slug":"LeetCode刷题-66-加一","date":"2020-07-20T13:45:14.000Z","updated":"2020-07-21T03:10:22.362Z","comments":true,"path":"posts/48186.html","link":"","permalink":"https://www.itnxd.cn/posts/48186.html","excerpt":"","text":"题目链接：66. 加一 ¶题解： 简单题！ ¶题目简述： 给定一个数字序列，最后一位加一，满十进一，求加一后的序列！ ¶题解： 从最后一位开始，给他加一，然后更新当前位的值为digits[i] %= 10 t更新为digits[i] / 10 最后若进位到最前面，需要进行插入，即在最前面插入t即可! ¶AC代码： 12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { vector&lt;int&gt; res; int t = 1; for(int i = digits.size() - 1; i &gt;= 0; i--){ digits[i] += t; t = digits[i] / 10; digits[i] %= 10; } if(t) digits.insert(digits.begin(), t); return digits; }};// 几乎一样：class Solution {public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { vector&lt;int&gt; res; int t = 1; for(int i = digits.size() - 1; i &gt;= 0; i--){ t += digits[i]; digits[i] = t % 10; t /= 10; } if(t) digits.insert(digits.begin(), t); return digits; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-65. 有效数字","slug":"LeetCode刷题-65-有效数字","date":"2020-07-20T13:44:52.000Z","updated":"2021-02-06T14:43:33.221Z","comments":true,"path":"posts/47819.html","link":"","permalink":"https://www.itnxd.cn/posts/47819.html","excerpt":"","text":"题目链接：65. 有效数字 ¶题解： 恶心人的字符串模拟题，边界条件一大堆！ ¶题目简述： 判断一个字符串是否可以转化为数字！ ¶题解： 步骤： 去掉首尾空格 若只有正负号，返回false 若只有一个.或者.e、.E都不成立，返回false 循环整个字符串： 对于.：若多于一个或者在e或E之后，返回false 对于e 或 E：e 或 E前后为空，或者多于一个，返回false 对于e 或 E：e 或 E后为正负号，且正负号后面没有数字，返回false 不是. e E 0-9：直接返回false 剩下其他情况合法，返回true 老多的边界条件！！！ ¶AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: bool isNumber(string s) { int i = 0, j = s.size() - 1; // 去掉前后空格 while(i &lt; s.size() &amp;&amp; s[i] == ' ') i++; while(j &gt;= 0 &amp;&amp; s[j] == ' ') j--; if(i &gt; j) return false; s = s.substr(i, j - i + 1); // 只有正负号 if(s[0] == '+' || s[0] == '-') s = s.substr(1); if(s.empty()) return false; // . .e .E 都不成立 if(s[0] == '.' &amp;&amp; (s.size() == 1 || s[1] == 'e' || s[1] == 'E')) return false; int dot = 0, e = 0; for(int i = 0; i &lt; s.size(); i++){ if(s[i] == '.'){ // 多余一个点或点在e之后 .2.3 3e5.2 if(dot &gt; 0 || e &gt; 0) return false; dot ++; }else if(s[i] == 'e' || s[i] == 'E'){ // e前为空 e后为空 e出现过 if(!i || i + 1 == s.size() || e &gt; 0) return false; // e后有正负号 if(s[i + 1] == '+' || s[i + 1] == '-'){ // e后正负号后没有数字 if(i + 2 == s.size()) return false; // 跳过正负号 i ++; } e ++; // 不是. e 0-9 }else if(s[i] &lt; '0' || s[i] &gt; '9') return false; } return true; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-64. 最小路径和","slug":"LeetCode刷题-64-最小路径和","date":"2020-07-20T13:44:50.000Z","updated":"2020-07-21T03:10:22.353Z","comments":true,"path":"posts/27804.html","link":"","permalink":"https://www.itnxd.cn/posts/27804.html","excerpt":"","text":"题目链接：64. 最小路径和 ¶题解： 和前两道类似，同样使用动态规划！ ¶题目简述： 给定一个方格，从左上走到右下，求最小代价！ ¶题解： 动态规划： 状态表示： f[i][j]表示到达当前点的最小代价 状态计算： 在不越界的情况下 f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j] 初始转态：f[0][0] = gird[0][0] 最终结果：f[n - 1][m - 1] 时间复杂度： $O(n \\times m)$ ¶AC代码： 12345678910111213141516class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(), m = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m, INT_MAX)); f[0][0] = grid[0][0]; for(int i = 0; i &lt; n; i++){ for(int j =0; j &lt; m; j++){ if(i &amp;&amp; j) f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j]; else if(i) f[i][j] = f[i - 1][j] + grid[i][j]; else if(j) f[i][j] = f[i][j - 1] + grid[i][j]; } } return f[n - 1][m - 1]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-63. 不同路径 II","slug":"LeetCode刷题-63-不同路径-II","date":"2020-07-20T13:44:16.000Z","updated":"2021-02-06T14:43:03.243Z","comments":true,"path":"posts/8265.html","link":"","permalink":"https://www.itnxd.cn/posts/8265.html","excerpt":"","text":"题目链接：63. 不同路径 II ¶题解： 和上一道题相比多了一些障碍物设置，基本类似！ ¶题目简述： 仍然是n * m的方格从左上到右下的路径数，路径中可能有障碍物！ ¶题解： 动态规划： 状态表示：f[i][j]表示从起点到当前位置的路径数！ 状态计算：由于到当前位置只有两条路径，即上和左，所以状态转移方程为，f[i][j] = f[i - 1][j] + f[i][j - 1] 初始状态由path[0][0]决定，若起点有障碍物，则f[0][0]为0，且最终方案数为0 若终点path[n - 1][m - 1]有障碍物，则最终方案数为0 以上两种情况需要特判！ 最终结果：f[n - 1][m - 1] 与上一道题不同之处： 当前位置有了障碍物则到达当前位置的方案数为f[i][j] = 0 时间复杂度：$O(n \\times m)$ ¶AC代码： 1234567891011121314151617181920class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; path) { int n = path.size(), m = path[0].size(); vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m)); if(path[n - 1][m - 1] || path[0][0]) return 0; f[0][0] = 1; for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ if(path[i][j]){ f[i][j] = 0; continue; } if(i - 1 &gt;= 0) f[i][j] += f[i - 1][j]; if(j - 1 &gt;= 0) f[i][j] += f[i][j - 1]; } } return f[n - 1][m - 1]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-62. 不同路径","slug":"LeetCode刷题-62-不同路径","date":"2020-07-20T13:43:28.000Z","updated":"2020-07-21T03:10:22.357Z","comments":true,"path":"posts/21929.html","link":"","permalink":"https://www.itnxd.cn/posts/21929.html","excerpt":"","text":"题目链接：62. 不同路径 ¶题解： 简单的动态规划题目！ 一个方格，算出从左上走到右下的不同方案数！ ¶题解一： 直接爆搜，时间会爆炸的！ ¶TLE代码： 123456789101112131415161718class Solution {public: int cnt; int n, m; int uniquePaths(int _m, int _n) { n = _n, m = _m; dfs(1, 1); return cnt; } void dfs(int x, int y){ if(x &gt; n || y &gt; m) return; if(x == n &amp;&amp; y == m){ cnt ++; } dfs(x, y + 1); dfs(x + 1, y); }}; ¶题解二： 使用动态规划： 状态表示：f[i][j]表示从起点到当前位置的路径数！ 状态计算：由于到当前位置只有两条路径，即上和左，所以状态转移方程为，f[i][j] = f[i - 1][j] + f[i][j - 1] 初始状态，f[0][0] = 1，最终结果：f[n - 1][m - 1] 注意：防止越界，进行一下特判！ 时间复杂度： O(n * m) ¶AC代码： 1234567891011121314class Solution {public: int uniquePaths(int m, int n) { vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m)); f[0][0] = 1; for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ if(i - 1 &gt;= 0) f[i][j] += f[i - 1][j]; if(j - 1 &gt;= 0) f[i][j] += f[i][j - 1]; } } return f[n - 1][m - 1]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-61. 旋转链表","slug":"LeetCode刷题-61-旋转链表","date":"2020-07-20T13:42:55.000Z","updated":"2020-07-21T03:10:22.359Z","comments":true,"path":"posts/20286.html","link":"","permalink":"https://www.itnxd.cn/posts/20286.html","excerpt":"","text":"题目链接：61. 旋转链表 ¶题解： 直接移动 ¶题目简述： 将一个链表向后移动k个位置！ ¶题解一：暴力 傻傻的移动k次即可，每次将倒数第一个节点指向最前面的头结点，倒数第二个节点指向空，完成一个交换即可！ 由于k太大，会导致超时，所以请看题解二！ ¶TLE代码： 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* rotateRight(ListNode* head, int k) { auto dummy = new ListNode(-1); dummy-&gt;next = head; if(head == NULL) return head; for(int i = 0; i &lt; k; i++){ auto l = dummy; while(l-&gt;next-&gt;next) l = l-&gt;next; auto t = l-&gt;next; l-&gt;next = NULL; auto s = dummy-&gt;next; dummy-&gt;next = t; t-&gt;next = s; } return dummy-&gt;next; }}; ¶题解二：取余优化 如果k是节点数的倍数，那么会发现我们做了倍数次重复操作。。。 所以直接对节点数取余，然后就是我们实际需要移动的次数！ 具体操作： 先遍历链表，计算节点数以及找到最后一个节点 若k是节点数的整数倍，直接返回原来的表头，即不需要移动，都是重复操作 否则，找到前len - k和后k位置，将二者交换即可！ 简单的链表连接操作，不说了！ ¶AC代码： 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* rotateRight(ListNode* head, int k) { auto dummy = new ListNode(-1), l = dummy; dummy-&gt;next = head; if(head == NULL) return head; int len = 0; ListNode* tail; while(l-&gt;next){ l = l-&gt;next; tail = l; len++; } k %= len; if(k == 0) return head; l = dummy; for(int i = 0; i &lt; len - k; i++) l = l-&gt;next; tail-&gt;next = dummy-&gt;next; dummy-&gt;next = l-&gt;next; l-&gt;next = NULL; return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题- 60. 第k个排列","slug":"LeetCode刷题-60-第k个排列","date":"2020-07-20T13:42:25.000Z","updated":"2020-07-21T03:10:22.355Z","comments":true,"path":"posts/40239.html","link":"","permalink":"https://www.itnxd.cn/posts/40239.html","excerpt":"","text":"题目链接：60. 第k个排列 ¶题解： 依次考虑每一位，很是巧妙的做法！ ¶题目简述： 求一个序列字典序的第k个排列！ ¶题解一： 直接使用全排列函数：next_permutation() 第k个序列，就是要循环k - 1次。 时间复杂度：$O(n! \\times k)$ ¶AC代码一： 1234567891011class Solution {public: string getPermutation(int n, int k) { string res; for(int i = 1; i &lt;= n; i++) res += i + '0'; for(int i = 0; i &lt; k - 1; i++){ next_permutation(res.begin(), res.end()); } return res; }}; ¶题解二： 计数 思路： 从高到低依次考虑每一位 对于每一位，从小到大枚举没有使用过的数，确定当前位 看下方的一个例子： n = 4, k = 10 第一位放1，后面有3！= 6种情况，放2后面也有3！= 6种情况，而k = 10，所以第一位一定是2，k = 10 - 6= 4 第二位放1，后面有2！= 2种情况，放3后面也有2！= 2种情况，而k = 4，所以第二位一定是3， k = 4 - 2 = 2 第三位放1，后面有1！= 1种情况，放4后面也有1！= 1种情况，而k = 2，所以第三位一定是4，k = 2 - 1 = 1 第四位放1，后面有1种情况，而k = 1, 所以第四位一定是1，k = 1 时间复杂度：$O(n^2)$ 注意： else内进入后即已经找到当前为改填的数，标记为true后直接break！ ¶AC代码二： 12345678910111213141516171819202122class Solution {public: string getPermutation(int n, int k) { string res; vector&lt;bool&gt; vis(10); for(int i = 0; i &lt; n; i++){ int fact = 1; for(int j = 1; j &lt;= n - i - 1; j++) fact *= j; for(int j = 1; j &lt;= n; j++){ if(!vis[j]){ if(fact &lt; k) k -= fact; else { res += j + '0'; vis[j] = true; break; } } } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"全排列","slug":"全排列","permalink":"https://www.itnxd.cn/tags/%E5%85%A8%E6%8E%92%E5%88%97/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-59. 螺旋矩阵 II","slug":"LeetCode刷题-59-螺旋矩阵-II","date":"2020-07-09T13:40:21.000Z","updated":"2020-07-21T03:10:22.349Z","comments":true,"path":"posts/63939.html","link":"","permalink":"https://www.itnxd.cn/posts/63939.html","excerpt":"","text":"题目链接：59. 螺旋矩阵 II ¶题解： 螺旋矩阵问题，和上一个基本类似。 ¶题目简述： 给定一个数字 n，按照从右、下、左、上的顺序生成一个螺旋矩阵！ ¶题解： 和54题-螺旋矩阵类似，同样使用两个方向数组，参考上一篇题解，同样是一个方向走到不能走就换方向。 此处的res数组存储每个位置要填的值！ ¶AC代码： 12345678910111213141516171819class Solution {public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n)); int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(n)); for(int i = 1, x = 0, y = 0, d = 0; i &lt;= n * n; i++){ res[x][y] = i; vis[x][y] = true; int a = x + dx[d], b = y + dy[d]; if(a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n || vis[a][b]){ d = (d + 1) % 4; a = x + dx[d], b = y + dy[d]; } x = a, y = b; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-58. 最后一个单词的长度","slug":"LeetCode刷题-58-最后一个单词的长度","date":"2020-07-08T13:47:51.000Z","updated":"2020-07-08T14:45:19.089Z","comments":true,"path":"posts/33807.html","link":"","permalink":"https://www.itnxd.cn/posts/33807.html","excerpt":"","text":"题目链接：58. 最后一个单词的长度 ¶题解： 简单题！ ¶题目简述： 返回最后一个字符串的长度！ ¶题解： 思路： 先将末尾多余的空格过滤掉！ 再从后往前扫描，进行统计，直到遇到第一个空格为止！ 注意： 特判字符串为空的情况！ ¶AC代码： 1234567891011121314class Solution {public: int lengthOfLastWord(string s) { if(s.size() == 0) return 0; int res = 0; int n = s.size() - 1; while(n &amp;&amp; s[n] == ' ') n--; for(int i = n; i &gt;= 0; i--){ if(s[i] == ' ') return res; res ++; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-57. 插入区间","slug":"LeetCode刷题-57-插入区间","date":"2020-07-08T13:47:29.000Z","updated":"2020-07-08T14:45:19.085Z","comments":true,"path":"posts/4935.html","link":"","permalink":"https://www.itnxd.cn/posts/4935.html","excerpt":"","text":"题目链接：57. 插入区间 ¶题解： 看似和上一题区间合并类似，实则没什么关系！ ¶题目简述： 给一个按照区间左端点排序的列表，给定一个待插入区间，使得插入后，没有重叠元素！ ¶题解： 由于已经排好序了，所以我们就不需要排序了！ 分三段处理： 找到可以插入待插入区间的上一个区间，即从开始到该区间是不需要参与合并的，即a[k][1] &lt; b[0] 找到可以和待插入区间合并的区间的最后一个区间，即a[k][0] &lt;= b[1]，不断更新待插入区间的右端点，直到无法合并结束，此时区间为待插入区间 最后一段就是剩下的区间了，按顺序插入即可 看一下简图： 注意： 处理第二段不要越界，即k &lt; a.size() 时间复杂度： 扫描一遍，为O(n) ¶AC代码： 123456789101112131415class Solution {public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; a, vector&lt;int&gt;&amp; b) { vector&lt;vector&lt;int&gt;&gt; res; int k = 0; while(k &lt; a.size() &amp;&amp; a[k][1] &lt; b[0]) res.push_back(a[k++]); if(k &lt; a.size()){ b[0] = min(a[k][0], b[0]); while(k &lt; a.size() &amp;&amp; a[k][0] &lt;= b[1]) b[1] = max(b[1], a[k++][1]); } res.push_back(b); while(k &lt; a.size()) res.push_back(a[k++]); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-56. 合并区间","slug":"LeetCode刷题-56-合并区间","date":"2020-07-08T13:46:14.000Z","updated":"2020-07-08T14:45:19.079Z","comments":true,"path":"posts/63206.html","link":"","permalink":"https://www.itnxd.cn/posts/63206.html","excerpt":"","text":"题目链接：56. 合并区间 ¶题解： 区间合并问题，先人的总结，先按照左端点排序再进行合并！ ¶题目简述： 给定一堆区间，将重叠的区间进行合并，重新返回！ ¶题解： 思路： 按照左端点排序，左端点相同，按照右端点排序 使用l，r两个指针维护最大可拓展区间 若当前左端点严格大于右指针，说明当前区间无法和上一个区间合并，则将上一个区间保存起来，更新新的左右指针为当前区间 若当前左端点小于等于上一个区间，则说明当前区间可以与上一个区间进行合并，则更新最大可拓展区间的右端点（即右指针） 最后将最后一个区间也保存起来 稍做解释： 按左端点排序，再按右端点排序，那么如果有重叠部分的区间，该区间的左端点一定在上一个区间的左端点的后面！这样如果有重叠就合并，没有就插入新的容器！ 时间复杂度： 排序O(nlogn)，线性扫描O(n)，总时间复杂度为O(nlogn) 注意点： 特判为空的情况，直接返回 记得要把最后一个区间插入 vector进行排序默认按照第一个值，第二个值等等进行排序 ¶AC代码： 1234567891011121314151617class Solution {public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { vector&lt;vector&lt;int&gt;&gt; res; if(intervals.empty()) return res; sort(intervals.begin(), intervals.end()); int l = intervals[0][0], r = intervals[0][1]; for(int i = 1; i &lt; intervals.size(); i++){ if(intervals[i][0] &gt; r) { res.push_back({l, r}); l = intervals[i][0], r = intervals[i][1]; } else r = max(r, intervals[i][1]); } res.push_back({l, r}); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-55. 跳跃游戏 ","slug":"LeetCode刷题-55-跳跃游戏","date":"2020-07-07T06:11:12.000Z","updated":"2020-07-07T09:18:51.765Z","comments":true,"path":"posts/23034.html","link":"","permalink":"https://www.itnxd.cn/posts/23034.html","excerpt":"","text":"题目链接：55. 跳跃游戏 ¶题解： 这个是45题跳跃游戏的简化版！ ¶题目简述： 本题和 LeetCode刷题-45.跳跃游戏II一样，上一题是要计算到达终点的最小步数！本题不一定能走到终点，问是否能走到终点！ ¶题解一： 首先：能跳到的位置一定是连续的一段，即某个位置跳不到，后面位置一定跳不到！ 反证法： 假如能跳到i + 1位置，跳不到i位置，那么跳到i + 1位置的位置应该在i位置之前，因为i位置无法跳到，无法从他开始跳，那么该位置可以调到i + 1一定可以跳到i，矛盾！假设不成立，即跳到的位置一定是连续的一段！ 解法，一模一样： 同样是具有单调性的动态规划，找到第一个可以到达当前位置i的位置即可！若last已经到了当前位置i，说明到不了当前位置i，也就到不了最后的终点，直接返回false 否则：说明全部点都能到达，返回true 时间复杂度：O(n) 空间复杂度：O(1) ¶AC代码一： 1234567891011class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for(int i = 1, last = 0; i &lt; n; i++){ while(last &lt; i &amp;&amp; last + nums[last] &lt; i) last++; if(last == i) return false; } return true; }}; ¶题解二： 另一种解释：基本和题解一类似！ 使用j表示从可以跳到的最远位置，i表示扫描到的位置！ 若j &lt; i：说明当前能跳到的最远位置到不了i，即到不了终点，直接返回false 否则：更新j，即j = max(j, i + nums[i])，即从第i个位置可以跳多远，更新一下j 初始化：j = 0，能跳到的最远处为起点！ ¶AC代码二： 12345678910class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { for(int i = 0, j = 0; i &lt; nums.size(); i++){ if(j &lt; i) return false; j = max(j, i + nums[i]); } return true; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-54. 螺旋矩阵 ","slug":"LeetCode刷题-54-螺旋矩阵","date":"2020-07-07T06:10:12.000Z","updated":"2020-07-07T09:18:51.762Z","comments":true,"path":"posts/395.html","link":"","permalink":"https://www.itnxd.cn/posts/395.html","excerpt":"","text":"题目链接：54. 螺旋矩阵 ¶题解： 又是旋转相关的模拟题！ ¶题目简述： 给定一个矩阵，按照右下左上的顺序进行遍历！ ¶题解： 枚举 n * m个点，按照右下左上的顺序循环进行，如螺旋般，一个方向走到头，换下一个方向！ 使用0,1,2,3分别表示四个方向，走到头就换一下方向，即d = (d + 1) % 4 使用dx和dy数组表示四个方向坐标的变化。 如果，坐标越界（第一次访问该方向），或者已经访问过的位置（不是第一次访问该方向），就要换到当前方向的下一个方向，同时更新当前坐标。即a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || vis[a][b] 注意：数组为空的判断！ ¶AC代码： 123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { vector&lt;int&gt; res; int n = matrix.size(); if(n == 0) return res; int m = matrix[0].size(); int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(m)); for(int i = 0, x = 0, y = 0, d = 0; i &lt; n * m; i++){ res.push_back(matrix[x][y]); vis[x][y] = true; int a = x + dx[d], b = y + dy[d]; if(a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || vis[a][b]){ d = (d + 1) % 4; a = x + dx[d], b = y + dy[d]; } x = a, y = b; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-53. 最大子序和 ","slug":"LeetCode刷题-53-最大子序和","date":"2020-07-07T06:09:12.000Z","updated":"2020-07-07T09:18:51.758Z","comments":true,"path":"posts/60904.html","link":"","permalink":"https://www.itnxd.cn/posts/60904.html","excerpt":"","text":"题目链接：53. 最大子序和 ¶题解： 动态规划应用！ ¶题目简述： 给定一个数组，找一个连续区间，使得该区间和最大！ ¶题解一： 同样使用闫式DP分析法： 状态表示： f[i]表示以i位置结尾的区间的最大和 状态计算： f[i] = max(f[i - 1] + nums[i], nums[i]) 初始化： f[0] = nums[0]，res = nums[0] 稍做解释： f[i] nums[i] i - 1 ~ i,i - 2 ~ i…0 ~ i ，将最后一位i抛掉以后，剩下的其实就是f[i - 1]，此种情况的和为 f[i - 1] + nums[i] 最终就是：f[i] = max(f[i - 1] + nums[i], nums[i]) 时间复杂度：O(n) 空间复杂度：O(n) ¶AC代码一： 12345678910111213class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; f(nums.size()); int res = nums[0]; f[0] = nums[0]; for(int i = 1; i &lt; nums.size(); i++){ f[i] = max(f[i - 1] + nums[i], nums[i]); res = max(res, f[i]); } return res; }}; ¶题解二：优化空间占用 会发现都是前后的关系：f[i - 1] f[i]，那么完全可以使用last变量来代替，而不去使用数组！ 注意：res 初始化为 极小值！ 时间复杂度：O(n) 空间复杂度：O(1) ¶AC代码二： 123456789101112class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int res = INT_MIN; for(int i = 0, last = 0; i &lt; nums.size(); i++){ // last = nums[i] + max(last, 0); last = max(last + nums[i], nums[i]); res = max(res, last); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-52. N皇后 II ","slug":"LeetCode刷题-52-N皇后-II","date":"2020-07-07T06:08:12.000Z","updated":"2020-07-07T09:18:51.755Z","comments":true,"path":"posts/47720.html","link":"","permalink":"https://www.itnxd.cn/posts/47720.html","excerpt":"","text":"题目链接：52. N皇后 II ¶题解： 同样是N皇后，比上一题更加简单。 ¶题目简述： N皇后问题，问最后的方案数！ ¶题解： 具体思路详见上一题 51题！ 由于问方案数，我们就不必开数组去存储路径了。 在递归出口i == n时， 直接进行统计即可res++. ¶AC代码： 1234567891011121314151617181920212223class Solution {public: vector&lt;bool&gt; col, dg, udg; int res; int totalNQueens(int n) { col = vector&lt;bool&gt;(n); dg = udg = vector&lt;bool&gt;(n * 2); dfs(0, n); return res; } void dfs(int i, int n){ if(i == n){ res ++; return; } for(int j = 0; j &lt; n; j++){ if(!col[j] &amp;&amp; !dg[i + j] &amp;&amp; !udg[i - j + n]){ col[j] = dg[i + j] = udg[i - j + n] = true; dfs(i + 1, n); col[j] = dg[i + j] = udg[i - j + n] = false; } } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-51. N 皇后 ","slug":"LeetCode刷题-51-N-皇后","date":"2020-07-07T06:07:12.000Z","updated":"2020-07-07T09:18:51.751Z","comments":true,"path":"posts/29682.html","link":"","permalink":"https://www.itnxd.cn/posts/29682.html","excerpt":"","text":"题目链接：51. N 皇后 ¶题解： 经典的N皇后问题！ ¶题目简述： n * n 的棋盘放n个皇后，保证每行每列每条斜线都不能有大于一个皇后！ ¶题解： DFS来一遍即可！ 使用col dg udg分别存储列和两条对角线是否有皇后。使用res存储答案，使用path存储路径。 void dfs(int i, int n) i：代表第几层 n：代表皇后数或棋盘行列数 递归出口： i == n即n个皇后都已经找到，将当前方案加入答案res 使用dg[i + j]和udg[i - j + n] 来标识两条对角线，原因就是你可以将它看成坐标系，一条对角线为y = x + b，另一条为y = -x + b，即可解的b = y - x, b = y + x，y - x可能越界，让他偏移n，即可保证不越界。 递归开始： 只要列以及两条斜线以及没有被访问过，即可访问！使用path[i][j]记录路径，表示i行的j列有一个皇后，更新标记，最后清空标记！ 注意：数组的初始化，path需要全部初始化为.，col要初始化n个位置，dg udg要初始化n * 2个位置。 ¶AC代码： 12345678910111213141516171819202122232425262728class Solution {public: vector&lt;bool&gt; col, dg, udg; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; path; vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { col = vector&lt;bool&gt;(n); dg = udg = vector&lt;bool&gt;(n * 2); path = vector&lt;string&gt;(n, string(n, '.')); dfs(0, n); return res; } void dfs(int i, int n){ if(i == n){ res.push_back(path); return; } for(int j = 0; j &lt; n; j++){ if(!col[j] &amp;&amp; !dg[i + j] &amp;&amp; !udg[i - j + n]){ col[j] = dg[i + j] = udg[i - j + n] = true; path[i][j] = 'Q'; dfs(i + 1, n); path[i][j] = '.'; col[j] = dg[i + j] = udg[i - j + n] = false; } } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-50. Pow(x, n)","slug":"LeetCode刷题-50-Pow-x-n","date":"2020-07-07T02:54:18.000Z","updated":"2020-07-07T09:18:51.744Z","comments":true,"path":"posts/4834.html","link":"","permalink":"https://www.itnxd.cn/posts/4834.html","excerpt":"","text":"题目链接：50. Pow(x, n) ¶题解： 快速幂应用！ ¶题目简述： 浮点数的幂运算！ ¶题解： 详见之前的这道题详解！ 不同之处，可能有负数，一个数的负数次幂，等于1 除以正数次幂，判断一下即可！ 注意：由于有负数，要求绝对值可能会越界，使用LL强转一下即可！ ¶AC代码： 123456789101112class Solution {public: double myPow(double x, int n) { typedef long long LL; double res = 1; for(LL k = abs((LL)n); k; k &gt;&gt;= 1){ if(k &amp; 1) res *= x; x *= x; } return n &gt; 0 ? res : 1 / res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"快速幂","slug":"快速幂","permalink":"https://www.itnxd.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-49.字母异位词分组","slug":"LeetCode刷题-49-字母异位词分组","date":"2020-07-07T02:53:42.000Z","updated":"2020-07-07T09:18:51.748Z","comments":true,"path":"posts/15108.html","link":"","permalink":"https://www.itnxd.cn/posts/15108.html","excerpt":"","text":"题目链接：49.字母异位词分组 ¶题解： 又是一个好巧的做法，借用排序即可处理！ ¶题目简述： 将一组字符串数组中每个字符串每个字符相同且数量一致的放到一组返回！ ¶题解： 怎么处理？ 既然你不一样，我就把你变成一样的，排个序不就行了，排完序后，该是一组的就都变成同一个字符串了，然后使用哈希表做一下映射即可！ 具体做法： 定义一个哈希表：unordered_map&lt;string, vector&lt;string&gt;&gt; hash;第一维度存储排序后统一的字符串，第二维度存储没有排序的原始字符串。例如：aet 对应 ate, aet, tae, tea, eat, eta 然后再将第二维度导入一个新数组即可！ ¶AC代码： 1234567891011121314class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { unordered_map&lt;string, vector&lt;string&gt;&gt; hash; for(auto&amp; str : strs){ string s = str; sort(str.begin(), str.end()); hash[str].push_back(s); } vector&lt;vector&lt;string&gt;&gt; res; for(auto&amp; item : hash) res.push_back(item.second); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"哈希表","slug":"哈希表","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-48.旋转图像","slug":"LeetCode刷题-48-旋转图像","date":"2020-07-07T02:53:21.000Z","updated":"2020-07-07T09:18:51.740Z","comments":true,"path":"posts/39221.html","link":"","permalink":"https://www.itnxd.cn/posts/39221.html","excerpt":"","text":"题目链接：48.旋转图像 ¶题解： 将一个矩阵反转，顺时针，逆时针，以及180度反转！ 有更精妙的方法吗？详见下文！ ¶题目简述： 将一个矩阵顺时针反转90度！ 不能使用额外的数组！ ¶题解： 第一想法：转圈来回换，例如1 3 9 7，2 6 8 4， … 但是找下标的关系会很复杂，我第一次就是这样做的，果然，找下标成功将我绕晕了！ 有没有更好的办法了？ 有的！ 对于顺时针90度，先按主对角线对称，再按中间竖线对称！ 对于逆时针90度，先按主对角线对称，再按中间横线对称！ 对于180度，先按主对角线对称，再按副对角线对称！ 顺时针90度： 逆时针90度： 180度： ¶AC代码： 12345678910111213141516class Solution {public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; i; j++){ swap(matrix[i][j], matrix[j][i]); } } for(int i = 0; i &lt; n; i++){ for(int j = 0, k = n - 1; j &lt; k; j++, k--){ swap(matrix[i][j], matrix[i][k]); } } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"旋转","slug":"旋转","permalink":"https://www.itnxd.cn/tags/%E6%97%8B%E8%BD%AC/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-47.全排列II","slug":"LeetCode刷题-47-全排列II","date":"2020-07-07T02:52:56.000Z","updated":"2020-07-07T09:18:51.732Z","comments":true,"path":"posts/23499.html","link":"","permalink":"https://www.itnxd.cn/posts/23499.html","excerpt":"","text":"题目链接：47.全排列II ¶题解： 相比上一道多了重复元素！ ¶题目简述： 给定一个可包含重复数字的序列，返回所有不重复的全排列。 ¶题解： 和 46 题类似，多了重复元素和去重！ 步骤也多了两步： 排序，使得相同的元素排到一起 过滤，同一个位置同一个相同元素只用没有使用的第一个元素，并且使用顺序一定是从前到后 过滤方法：i &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !vis[i - 1]即遇到和上一个相同，上一个没有被用过，则说明当前数不是第一次被用，就不要取用，跳过即可！ **举个例子：**1(1) 1(2) 3 可能为 1(1) 1(2) 3也可能为1(2) 1(1) 3 ，我们要去除重复的，可以只将顺序排列的留下即可！即相同数的第一个没有被用到，就不要使用第二个，第三个！可以保证相同数只有一种情况，即顺序排列的情况！ ¶AC代码： 123456789101112131415161718192021222324252627class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;bool&gt; vis; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); vis = vector&lt;bool&gt;(nums.size()); dfs(0, nums); return res; } void dfs(int cnt, vector&lt;int&gt;&amp; nums){ if(cnt == nums.size()){ res.push_back(path); return; } for(int i = 0; i &lt; nums.size(); i++){ if(!vis[i]){ if(i &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !vis[i - 1]) continue; path.push_back(nums[i]), vis[i] = true; dfs(cnt + 1, nums); path.pop_back(), vis[i] = false; } } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-46.全排列","slug":"LeetCode刷题-46-全排列","date":"2020-07-07T02:52:37.000Z","updated":"2020-07-07T09:18:51.736Z","comments":true,"path":"posts/44968.html","link":"","permalink":"https://www.itnxd.cn/posts/44968.html","excerpt":"","text":"题目链接：46.全排列 ¶题解： 全排列问题，经典DFS！ ¶题目简述： 给定没有重复元素的序列，输出全排列！ ¶题解： 直接搜索加回溯就行了： 参数： cnt：表示当前搜到第几位数 nums：传入原数组 递归出口：cnt == nums.size() 搜索过的直接跳过即可，使用vis数组标记即可！ ¶AC代码： 1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;bool&gt; vis; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { vis = vector&lt;bool&gt;(nums.size()); dfs(0, nums); return res; } void dfs(int cnt, vector&lt;int&gt;&amp; nums){ if(cnt == nums.size()){ res.push_back(path); return; } for(int i = 0; i &lt; nums.size(); i++){ if(vis[i]) continue; path.push_back(nums[i]); vis[i] = true; dfs(cnt + 1, nums); path.pop_back(); vis[i] = false; } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-45.跳跃游戏II","slug":"LeetCode刷题-45-跳跃游戏II","date":"2020-07-06T12:42:28.000Z","updated":"2020-07-07T09:18:51.718Z","comments":true,"path":"posts/31960.html","link":"","permalink":"https://www.itnxd.cn/posts/31960.html","excerpt":"","text":"题目链接：45.跳跃游戏II ¶题解： 普通动态规划超时，需要想到是否具有单调性，再从单调性出发使用贪心求解！ 动态规划难度尚可，加上单调性就复杂了许多！ ¶题目简述： 给了一个非负整数数组，每个位置代表能从当前位置挑的最大步数，题目规定一定可以跳到终点，问最短步数！ ¶题解一：动态规划 同样使用闫式DP分析法： 状态表示：使用f[i]数组表示跳到i位置的最小步数 状态计算： 那么f[i]应该为前面的所有位置跳到当前位置的步数中的最小值。即t = min(t, f[j] + 1) 最终答案：答案就是f[n - 1] 解释一下：j + nums[j] &gt;= i表示能从j位置跳到i位置 时间复杂度：O(n ^ 2) 空间复杂度：O(n) 时间复杂度有点高，会超时TLE，请看题解二，利用单调性！ ¶超时代码： 1234567891011121314151617class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n + 1); for(int i = 1; i &lt; n; i++){ int t = INT_MAX; for(int j = 0; j &lt; i; j++){ if(j + nums[j] &gt;= i){ t = min(t, f[j] + 1); } } f[i] = t; } return f[n - 1]; }}; ¶题解二：动态规划 + 单调性 + 贪心 既然动态规划会超时，我们就需要想想该状态数组是否具有单调性！ 我们会发现，f数组是单调递增的，可能为0,1,1,2,3,4,4,4,5,6....也就是f[i - 1] &lt;= f[i] 开始证明： 反证法： 假设f[i - 1] &gt; f[i]，不妨假设是从k（k位置一定在i - 1 位置之前）位置跳到了f[i]，即 k + nums[k] &gt;= i，那么k + nums[k] &gt;= i - 1一定成立！此时f[i - 1] &lt;= f[i]，即能跳到后一个位置，一定能跳到前一个位置，这样到达前一个位置的步数一定不会大于后一个位置的步数！即假设不成立，状态数组是单调递增的！ 有了单调性的性质，计算步数就会简单多了！ 我们只需要尽可能找到靠前的能跳到当前位置的位置即可，因为其后面的一定可以跳过去，步数也一定会比前面能跳过去的位置要多，所以最优解就是从前往后第一个可以跳到当前位置的位置！即while(last &lt; i &amp;&amp; last + nums[last] &lt; i) last++; last位置就是第一个可以跳过去的位置，也就是最优解。当前位置的最小步数，当然就是上一个位置的最小步数 + 1，即f[i] = f[last] + 1 最终答案：f[n - 1] 时间复杂度：最多扫描两遍，为O(n) 空间复杂度：O(n) ¶AC代码： 123456789101112class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n + 1); for(int i = 1, last = 0; i &lt; n; i++){ while(last &lt; i &amp;&amp; last + nums[last] &lt; i) last++; f[i] = f[last] + 1; } return f[n - 1]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-44.通配符匹配","slug":"LeetCode刷题-44-通配符匹配","date":"2020-07-06T12:41:42.000Z","updated":"2020-07-07T09:18:51.728Z","comments":true,"path":"posts/18504.html","link":"","permalink":"https://www.itnxd.cn/posts/18504.html","excerpt":"","text":"题目链接：44.通配符匹配 ¶题解： 又是一道关于正则表达式匹配问题的，和上一道10.正则表达式匹配几乎类似！ 同样的做法，再来一次动态规划！ ¶题目简述： ? ：可以匹配任何单个字符。 *： 可以匹配任意字符串（包括空字符串）。 给一个字符串，给一个正则，检查能否匹配。 很明显，这个定义和正则的含义不尽相同，没关系，根据题意来就行了。 ¶题解： 同样使用闫式DP分析法： 分为状态表示和状态计算： 如下图，由于我写过了一遍，就不再写了！ 状态转移方程如下： 当p[j] != '*' f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == '?') 当 p[j] == '*' f[i][j] = f[i][j - 1] || i &amp;&amp; f[i - 1][j] （添加 i 防止越界） 注意点： 初始状态f[0][0] = true j从0开始无意义，因为非空串无法匹配空串 第一个if同样需要防止越界 最终答案为f[n][m] 将字符串从0开始，可以省去边界情况的处理 时间复杂度：O(n * m) ¶AC代码： 12345678910111213141516171819class Solution {public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); s = ' ' + s, p = ' ' + p; vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1)); f[0][0] = true; for(int i = 0; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ if(i &amp;&amp; p[j] != '*'){ f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == '?'); }else if(p[j] == '*'){ f[i][j] = f[i][j - 1] || i &amp;&amp; f[i - 1][j]; } } } return f[n][m]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-43.字符串相乘","slug":"LeetCode刷题-43-字符串相乘","date":"2020-07-06T12:41:23.000Z","updated":"2020-07-07T09:18:51.724Z","comments":true,"path":"posts/1953.html","link":"","permalink":"https://www.itnxd.cn/posts/1953.html","excerpt":"","text":"题目链接：43.字符串相乘 ¶题解： 高精度乘以高精度！ ¶题目简述： 两个字符串高精度相乘返回结果的字符串！ ¶题解： 模拟小学乘法即可！ 两个数相乘，最后积的位数为两数长度之和或者为长度之和减 1 ！ 思路： 先将字符串映射成数字，再倒序存到数组，为了方便计算！ 两层循环，让第二个数的每一位去乘第一个数，存到新数组c[i + j]，这样可以保证该放到同一列的都在同一列 然后将需要进位的给了下一位，即c[i + j + 1] += c[i + j] / 10 再将本位的余数留下即可，即c[i + j] %= 10 最后需要将末尾的零去掉，即反转为正常数字的前导0.（例如乘以0，或者位数为两数之和减 1） 在将其映射为字符串，倒序存储到新数组，返回！ 算了，懒得画图了，太好理解了！ 时间复杂度： O(n * m) ¶AC代码： 123456789101112131415161718192021class Solution {public: string multiply(string num1, string num2) { int n = num1.size(), m = num2.size(); vector&lt;int&gt; a(n), b(m), c(n + m); for(int i = 0; i &lt; n; i++) a[n - i - 1] = num1[i] - '0'; for(int i = 0; i &lt; m; i++) b[m - i - 1] = num2[i] - '0'; for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ c[i + j] += a[i] * b[j]; c[i + j + 1] += c[i + j] / 10; c[i + j] %= 10; } } int len = n + m; while(len &gt; 1 &amp;&amp; c[len - 1] == 0) len--; string res = \"\"; for(int i = len - 1; i &gt;= 0; i--) res += c[i] + '0'; return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"https://www.itnxd.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-42.接雨水","slug":"LeetCode刷题-42-接雨水","date":"2020-07-05T01:18:21.000Z","updated":"2021-02-06T14:42:50.861Z","comments":true,"path":"posts/57751.html","link":"","permalink":"https://www.itnxd.cn/posts/57751.html","excerpt":"","text":"题目链接：42.接雨水 ¶题解： 多种做法，第一次接触确实有点难，单调栈的应用，以及双指针这个神奇算法的应用！ 计算这种面积，不要瞎想，大概两种，一种计算纵向，一种计算横向！ 下面三种解法，推荐去看双指针和单调栈，学习算法，尽可能多的一题多解，双指针解法是最优的，但是单调栈也是一种思想，多学点没坏处！ ¶题目简述： 接雨水，给定一堆柱子，问柱子之间的凹槽最多放多少水！如下图：蓝色部分就是最多的接水量。 ¶题解一：三次扫描 计算纵向：即每个柱子上方可以存水的量，累加即可！ 如何计算？ 观察会发现，当前柱子能存的水取决于当前柱子左边最高的柱子和当前柱子右边最高的柱子，由于短板效应，所以能存的水为左右两边最高的柱子的较小值与当前柱子高度的差值。 如何计算左右最高的柱子？ 简单办法：直接扫描一遍即可，使用两个数组保存该位置左右的最高柱子，left_max[i]表示i位置（包括自己）的柱子左边的最高柱子，同理right_max[i]表示i位置（包括自己）右边最高柱子。一个从左向右扫描维护该数组，一个从右向左扫描维护该数组即可。 第三次扫描，直接计算每个柱子的可存水的高度即可！即min(left_max[i], right_max[i]) - height[i] 注意：因为要进行动态维护，要和前一个最大值比较，所以数组left_max从1开始，right_max从n - 1开始。 时间复杂度： 三次线性扫描，为 O(n) 空间复杂度： 开辟了两个额外数组，空间占用为 O(n) 注意：判断为空的情况！ 为什么要扫描三次，一次扫描不行吗？ 答案是可以，使用双指针来维护！详见题解二！ ¶AC代码一： 1234567891011121314151617class Solution {public: int trap(vector&lt;int&gt;&amp; height) { int n = height.size(), res = 0; if(n == 0) return 0; vector&lt;int&gt; left_max(n), right_max(n); left_max[0] = height[0]; for(int i = 1; i &lt; n; i++) left_max[i] = max(left_max[i - 1], height[i]); right_max[n - 1] = height[n - 1]; for(int i = n - 2; i &gt;= 0; i--) right_max[i] = max(right_max[i + 1], height[i]); for(int i = 0; i &lt; n; i++) res += min(left_max[i], right_max[i]) - height[i]; return res; }}; ¶题解二：双指针 同样是计算纵向！ 使用双指针，一次扫描，不用多余的空间！ 首先：思想就是一个桶能装多少水，一定是由短板决定的，所以我们就是根据这句话来想，我们不去找左右最大值，直接找短板即可！ 当前算法过程就是不断的计算左柱子和右柱子，直到左右相碰结束！ 具体解法： 使用l和r分别指向左右两个指针 使用left_max和right_max分别指向l左边最大值和r右边最大值 左边最大值小于右边最大值时，即left_max &lt; right_max，说明height[l]这根柱子的短板已经找到，为left_max，当前总面积累加为res += left_max - height[l] 然后左指针右移，l++ 更新left_max，即left_max = max(left_max, height[l]) 左边最大值大于等于右边最大值时，同理！ 具体解释： 为什么左最大小于右最大，即为左柱子的短板；为什么右最大小于左最大，即为右柱子的短板？ 还是短板效应！ 如果左最大小于右最大，左边柱子的赛点就到了，左边最大即为当前柱子的短板！你想啊，虽然两个指针中间还有未走完的路，但是右边的最大值一定会在后续更新到更大，不管怎样，相比之下，左右最大值中的最小值一定是当前左边的最大值。同理右边较小时也是！ 时间复杂度： l 和 r一共扫描一遍数组，为 O(n) 空间复杂度： 没有使用额外空间，空间占用为 O(1) 注意：判断为空的情况！ ¶AC代码二： 12345678910111213141516171819202122// 双指针 时间 O(n) 空间 O(1)class Solution {public: int trap(vector&lt;int&gt;&amp; height) { int n = height.size(), res = 0; if(n == 0) return 0; int left_max = height[0], right_max = height[n - 1]; int l = 0, r = n - 1; while(l &lt; r){ if(left_max &lt; right_max){ res += left_max - height[l++]; left_max = max(left_max, height[l]); }else{ res += right_max - height[r--]; right_max = max(right_max, height[r]); } } return res; }}; ¶题解三：单调栈 计算横向！ 我是第一次接触单调栈！ 本题可以使用单调栈，所谓单调栈就是具有单调性的栈。。。 为了存到水，那么一定要有凹槽，即左边下去，右边起来，我们用栈来维护左边下去的这一段，即当前栈是一个单调递减的栈！ 如下图： 我们在栈中存储左边那四根递减的柱子！ 具体算法： 有了凹槽才需要计算面积，所以，递减的栈要找到大于栈顶的位置才需要计算面积。 首先出栈栈顶并将其记为top，然后当前stk.top()、top、i就构成了一个凹槽，可以进行一次计算， 即红色块面积，宽度为i - stk.top() - 1，高度为min(height[i], height[stk.top()]) - height[top] 算完后while结束，继续下一次for循环，i后移，严格保证栈的单调性 此时栈又不单调了，进行处理，此时i到了i'，会发现多出了黄色三个矩形块的面积，2,3,4号矩形，可以在while内循环全部干掉，边干边出栈，最后栈内为1,6 每次while循环结束，将当前位置 i压入栈内。 具体看下方图理解一下，这里维护了一个单调栈，永远单调，遇到凹槽就进行计算累加，横向的面积！ 注意：如果出栈一次后，栈空，即当前的形状不是凹槽，就像当前只有top和i一样，无法存水，break即可！ 时间复杂度： 扫描一次，为 O(n) 空间复杂度： 栈开辟了一个数组，空间占用为 O(n) ¶AC代码三： 123456789101112131415161718// 单调栈 时间O(n) 空间O(n)class Solution {public: int trap(vector&lt;int&gt;&amp; height) { stack&lt;int&gt; stk; int res = 0; for(int i = 0; i &lt; height.size(); i++){ while(stk.size() &amp;&amp; height[stk.top()] &lt; height[i]){ int top = stk.top(); stk.pop(); if(stk.empty()) break; res += (i - stk.top() - 1) * (min(height[i], height[stk.top()]) - height[top]); } stk.push(i); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://www.itnxd.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-41.缺失的第一个正数","slug":"LeetCode刷题-41-缺失的第一个正数","date":"2020-07-05T01:17:41.000Z","updated":"2021-02-06T14:43:18.102Z","comments":true,"path":"posts/50883.html","link":"","permalink":"https://www.itnxd.cn/posts/50883.html","excerpt":"","text":"题目链接：41.缺失的第一个正数 ¶题解： 一种排序算法的应用？ ¶题目简述： 给定一组未排序数组，找出其中没有出现过的最小正整数！ 要求：时间 O(n) 空间 O(1) ¶题解： 由于时间为O(n)限制，不能直接使用sort再扫描，现在给出一种排序： 小于等于0，大于 n 的数字不用管（因为我们要正数的排序，排序的最后一个数应该为n，所以大于n的不用管） 从前向后扫描，保证每个数字出现在正确位置上，即 5 应该跑到下标为 4 的位置，即nums[i]要跑到下标为nums[i] - 1的位置 扫描一遍以后，整个数组1 ~ n的数字已经正确归位，所以只需要从前向后再扫描一遍没出现过的数字即可，即nums[i] != i + 1。若全部匹配，则说明是第 n +1 个数没有出现 具体解释： 遇到1 ~ n的就进行归位，将该数放到该放的位置，使用swap进行交换，交换完成后一个数已经归位，交换过来的数若不是它该待的正确位置，继续进行交换，直到当前位置为正确数字或遇到不在1 ~ n范围内的数结束当前位置。 时间复杂度： 别看有两层循环，但是两层循环加起来最多执行n次，因为while循环一次就会归位一个该归位的数（1 ~ n），所以时间复杂度为O(n) 空间复杂度： 没有使用额外空间，所以空间复杂度为 O(1) ¶AC代码： 123456789101112131415class Solution {public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for(int i = 0; i &lt; n; i++) while(nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - 1]) swap(nums[i], nums[nums[i] - 1]); for(int i = 0; i &lt; n; i++) if(nums[i] != i + 1) return i + 1; return n + 1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"}],"author":"Mr.Niu"},{"title":"数据库教程之字符集.安全管理.维护","slug":"数据库教程之字符集-安全管理-维护","date":"2020-07-03T02:23:19.000Z","updated":"2021-09-13T07:54:38.676Z","comments":true,"path":"posts/28616.html","link":"","permalink":"https://www.itnxd.cn/posts/28616.html","excerpt":"","text":"¶一、字符集和校对顺序 ¶1、字符集和校对顺序 在MySQL的正常数据库活动（ SELECT 、 INSERT 等）中，不需要操心太多的东西。使用何种字符集和校对的决定在服务器、数据库和表级进行。 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对为规定字符如何比较的指令。 ¶2、使用字符集和校对顺序 ¶2.1 查看支持的字符集 使用命令：SHOW CHARACTER SET; callation为校对顺序！ 这条语句显示所有可用的字符集以及每个字符集的描述和默认校对。 123456789101112131415161718192021mysql&gt; SHOW CHARACTER SET;+----------+---------------------------------+---------------------+--------+| Charset | Description | Default collation | Maxlen |+----------+---------------------------------+---------------------+--------+| armscii8 | ARMSCII-8 Armenian | armscii8_general_ci | 1 || ascii | US ASCII | ascii_general_ci | 1 || big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 || binary | Binary pseudo charset | binary | 1 || cp1250 | Windows Central European | cp1250_general_ci | 1 || cp1251 | Windows Cyrillic | cp1251_general_ci | 1 || cp1256 | Windows Arabic | cp1256_general_ci | 1 || cp1257 | Windows Baltic | cp1257_general_ci | 1 || cp850 | DOS West European | cp850_general_ci | 1 || cp852 | DOS Central European | cp852_general_ci | 1 || cp866 | DOS Russian | cp866_general_ci | 1 || cp932 | SJIS for Windows Japanese | cp932_japanese_ci | 2 || dec8 | DEC West European | dec8_swedish_ci | 1 || eucjpms | UJIS for Windows Japanese | eucjpms_japanese_ci | 3 || euckr | EUC-KR Korean | euckr_korean_ci | 2 |.......... ¶2.2 查看支持的校对顺序 非常多，展示部分！ 用来显示所有可用的校对，以及它们适用的字符集。有的字符集具有不止一种校对。 使用命令：SHOW COLLATION; 1234567891011121314151617mysql&gt; SHOW COLLATION;+----------------------------+----------+-----+---------+----------+---------+---------------+| Collation | Charset | Id | Default | Compiled | Sortlen | Pad_attribute |+----------------------------+----------+-----+---------+----------+---------+---------------+| armscii8_bin | armscii8 | 64 | | Yes | 1 | PAD SPACE || armscii8_general_ci | armscii8 | 32 | Yes | Yes | 1 | PAD SPACE || ascii_bin | ascii | 65 | | Yes | 1 | PAD SPACE || ascii_general_ci | ascii | 11 | Yes | Yes | 1 | PAD SPACE || big5_bin | big5 | 84 | | Yes | 1 | PAD SPACE || big5_chinese_ci | big5 | 1 | Yes | Yes | 1 | PAD SPACE || binary | binary | 63 | Yes | Yes | 1 | NO PAD || cp1250_bin | cp1250 | 66 | | Yes | 1 | PAD SPACE || cp1250_croatian_ci | cp1250 | 44 | | Yes | 1 | PAD SPACE || cp1250_czech_cs | cp1250 | 34 | | Yes | 2 | PAD SPACE || cp1250_general_ci | cp1250 | 26 | Yes | Yes | 1 | PAD SPACE |.......... ¶2.3 确认默认字符集和校对顺序 通常系统管理在安装时定义一个默认的字符集和校对。 此外，也可以在创建数据库时，指定默认的字符集和校对。 字符集很少是服务器范围（甚至数据库范围）的设置。不同的表，甚至不同的列都可能需要不同的字符集，而且两者都可以在创建表时指定。 为了确定所用的字符集和校对，可以使用以下语句： 1234567891011121314151617181920212223242526-- 默认字符集mysql&gt; SHOW VARIABLES LIKE 'character%';+--------------------------+--------------------------+| Variable_name | Value |+--------------------------+--------------------------+| character_set_client | utf8mb4 || character_set_connection | utf8mb4 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | utf8mb4 || character_set_server | utf8mb4 || character_set_system | utf8 || character_sets_dir | D:\\MySQL\\share\\charsets\\ |+--------------------------+--------------------------+8 rows in set, 1 warning (0.00 sec)-- 默认校对顺序mysql&gt; SHOW VARIABLES LIKE 'collation%';+----------------------+--------------------+| Variable_name | Value |+----------------------+--------------------+| collation_connection | utf8mb4_0900_ai_ci || collation_database | utf8mb4_0900_ai_ci || collation_server | utf8mb4_0900_ai_ci |+----------------------+--------------------+3 rows in set, 1 warning (0.00 sec) ¶2.4 指定字符集和校对顺序 在CREATE语句最后加上DEFAULT CHARACTER SET 字符集名 COLLATE 校对顺序名; 如果不指定，则使用2.3中的默认值！ 123456CREATE TABLE mytable( columnn1 INT， columnn2 VARCHAR(10)) DEFAULT CHARACTER SET hebrewCOLLATE hebrew_general_ci; ¶2.5 单独对某列设定字符集和校对顺序 既对整个表设定也对某个列设定！ 1234567CREATE TABLE mytable(columnn1 INT，columnn2 VARCHAR(10)，co1umnn3 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ci) DEFAULT CHARACTER SET hebrewCOLLATE hebrew_general_ci; ¶2.6 对ORDER BY子句设定校对顺序 通过对该排序设定校对顺序，可以临时区分大小写来排序！即latin1_genera1_Cs可以区分大小写的校对顺序。 123SELECT * FROM customersORDER BY lastname, firstname COLLATE latin1_genera1_Cs; ¶2.7 其他支持设定校对顺序的语句 COLLATE 还可以用于 GROUP BY 、 HAVING 、聚集函数、别名等。 如果绝对需要，串可以在字符集之间进行转换。为此，使用 Cast() 或 Convert ()函数。 ¶二、安全管理 ¶1、访问控制 说白了就是分配给谁多大的权限进行数据库操作！ MySQL默认有一个root用户，对MySQL服务具有完全的控制！在日常工作中，决不能使用root，应该创建一系列账号，用于管理及用户使用！ 仅在绝对需要时使用它（或许在你不能登录其他管理账号时使用）。不应该在日常的MySQL操作中使用 root 。 举例子如下： 多数用户只需要对表进行读和写，但少数用户甚至需要能创建和删除表； 某些用户需要读表，但可能不需要更新表； 你可能想允许用户添加数据，但不允许他们删除数据； 某些用户（管理员）可能需要处理用户账号的权限，但多数用户不需要； 你可能想让用户通过存储过程访问数据，但不允许他们直接访问数据； 你可能想根据用户登录的地点限制对某些功能的访问。 ¶2、管理用户 ¶2.1 创建用户账号 GRANT 语句也可以创建用户账号，但一般来说CREATE USER是最清楚和最简单的句子。此外，也可以通过直接插入行到 user 表来增加用户，不过为安全起见，一般不建议这样做。MySQL用来存储用户账号信息的表（以及表模式等）极为重要，对它们的任何毁坏都可能严重地伤害到MySQL服务器。因此，相对于直接处理来说，最好是用标记和函数来处理这表。 语法： CREATE USER 用户名 IDENTIFIED BY '口令' 该口令为纯文本，MySQL会在存入user表之前进行加密！ 注意：查询用户可到mysql表下的user表查询！ user表中localhost表示仅可在本机使用此用户登录数据库 user表中通配符 % 代表可以在任意主机使用此用户登录数据库 创建用户时不添加主机名则默认为%！ 1234CREATE USER ben IDENTIFIED BY 'p@$$wOrd' ;CREATE USER 'xxx'@'localhost' IDENTIFIED BY '123';CREATE USER 'xxx'@'%' IDENTIFIED BY '123'; CREATE USER 创建一个新用户账号。在创建用户账号时不一定需要口令，不过这个例子用 IDENTIFIED BY 'p@$$wOrd' 给出了一个口令。 指定散列口令： 语法：CREATE USER 用户名 IDENTIFIED BY PASSWORD 重命名用户名： 语法：RENAME USER 用户名 TO 新用户名 1RENAME USER ben TO bforta; ¶2.2 删除用户账号 语法： DROP USER 用户名 DROP USER 删除用户账号和所有相关的账号权限。 在MySQL 5以前， DROP USER 只能用来删除用户账号，不能删除相关的权限。因此，如果使用旧版本的MySQL，需要先用 REVOKE 删除与账号相关的权限，然后再用 DROP USER 删除账号。 1DROP USER ben; ¶2.3 设置访问权限 新建的用户没有权限，只能进行登录操作！ ¶2.3.1 查看用户权限 语法：SHOW GRANTS 用户名 下面显示有一个权限： USAGE ON *.*，USAGE表名没有任何权限。 MySQL的权限用用户名和主机名结合定义。如果不指定主机名，则使用默认的主机名 % （授予用户访问权限而不管主机名）。如：'ben' @ '%' 1234567mysql&gt; SHOW GRANTS FOR ben;+---------------------------------+| Grants for ben@% |+---------------------------------+| GRANT USAGE ON *.* TO `ben`@`%` |+---------------------------------+1 row in set (0.00 sec) ¶2.3.2 授予用户权限 三步： 要授予的权限； 被授予访问权限的数据库或表； 用户名。 此 GRANT 允许用户在crashcourse.*（ crashcourse 数据库的所有表）上使用 SELECT 。通过只授予SELECT 访问权限，用户 ben对 crashcourse 数据库中的所有数据具有只读访问权限。 语法：GRANT 权限 ON 目标数据库 TO 用户 多个权限使用逗号分隔即可！ 1234567891011GRANT SELECT ON crashcourse.* TO ben;-- 使用SHOW FRANTS 查询权限mysql&gt; SHOW GRANTS FOR ben;+----------------------------------------------+| Grants for ben@% |+----------------------------------------------+| GRANT USAGE ON *.* TO `ben`@`%` || GRANT SELECT ON `crashcourse`.* TO `ben`@`%` |+----------------------------------------------+2 rows in set (0.00 sec) ¶2.3.3 撤销用户权限 语法：REVOKE 权限 ON 目标数据库 FROM 用户 撤销的权限必须存在，否则会报错！ 多个权限使用逗号分隔即可！ 1REVOKE SELECT ON crashcourse.* FROM bforta; GRANT 和 REVOKE 的几个层次： 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 ¶2.3.4 权限信息如下 ¶2.4 更改口令（密码） 语法：SET PASSWORD FOR 用户名 = Passward('新口令'); 或 update user set password = password(‘新密码’) where user = ‘用户名’; 1234SET PASSWORD FOR ben = Password('sdjfaosljdfk');# 或update user set password = password(‘xxx’) where user = ‘ben’; 设置自己口令： 在不指定用户名时， SET PASSWORD 更新当前登录用户的口令。 1SET PASSWORD = Password('sdjfaosljdfk'); ¶三、数据库维护 ¶1、备份数据 像所有数据一样，MySQL的数据也必须经常备份。由于MySQL数据库是基于磁盘的文件，普通的备份系统和例程就能备份MySQL的数据。但是，由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效。 首先刷新未写数据 为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用 FLUSH TABLES 语句。 解决方案： 使用命令行实用程序 mysqldump 转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。 可用命令行实用程序 mysqlhotcopy 从一个数据库复制所有数据（并非所有数据库引擎都支持这个实用程序）。 可以使用MySQL的 BACKUP TABLE 或 SELECT INTO OUTFILE 转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用 RESTORETABLE 来复原。 代码示例： 12345678# 备份mysqldump -u用户名 -p密码 需要备份的数据库名称 &gt; 保存路径# 还原：a.登录数据库b.创建数据库c.使用数据库d.执行语法：source 文件路径 ¶2、进行数据库维护 ¶2.1 检查表键是否正确 语法： ANALYZE TABLE 表名 1234567mysql&gt; ANALYZE TABLE orders;+-------------+---------+----------+----------+| Table | Op | Msg_type | Msg_text |+-------------+---------+----------+----------+| test.orders | analyze | status | OK |+-------------+---------+----------+----------+1 row in set (0.13 sec) ¶2.2 对表进行多种问题检查 语法： CHECK TABLE 表名 在 MyISAM 表上还对索引进行检查。 CHECK TABLE 支持一系列的用于 MyISAM 表的方式。CHANGED 检查自最后一次检查以来改动过的表。 EXTENDED 执行最彻底的检查， FAST 只检查未正常关闭的表， MEDIUM 检查所有被删除的链接并进行键检验， QUICK 只进行快速扫描。如下所示， CHECK TABLE 发现和修复问题： 如果 MyISAM 表访问产生不正确和不一致的结果，可能需要用REPAIR TABLE 来修复相应的表。这条语句不应该经常使用，如果需要经常使用，可能会有更大的问题要解决。 如果从一个表中删除大量数据，应该使用 OPTIMIZE TABLE 来收回所用的空间，从而优化表的性能。 12345678910mysql&gt; CHECK TABLE orders，orderitems ;+--------------------------+-------+----------+------------------------------------------------+| Table | Op | Msg_type | Msg_text |+--------------------------+-------+----------+------------------------------------------------+| test.orders，orderitems | check | Error | Table 'test.orders，orderitems' doesn't exist || test.orders，orderitems | check | status | Operation failed |+--------------------------+-------+----------+------------------------------------------------+2 rows in set (0.00 sec) ¶3、诊断启动问题 服务器启动问题通常在对MySQL配置或服务器本身进行更改时出现。MySQL在这个问题发生时报告错误，但由于多数MySQL服务器是作为系统进程或服务自动启动的，这些消息可能看不到。在排除系统启动问题时，首先应该尽量用手动启动服务器。MySQL服务器自身通过在命令行上执行 mysqld 启动。 几个重要的 mysqld命令行选项： --help 显示帮助——一个选项列表； --safe-mode 装载减去某些最佳配置的服务器； --verbose 显示全文本消息（为获得更详细的帮助消息与 --help联合使用）； --version 显示版本信息然后退出。 ¶4、查看日志文件 MySQL维护管理员依赖的一系列日志文件。主要的日志文件有以下几种。 错误日志。它包含启动和关闭问题以及任意关键错误的细节。此日志通常名为 hostname.err ，位于 data 目录中。此日志名可用--log-error 命令行选项更改。 查询日志。它记录所有MySQL活动，在诊断问题时非常有用。此日志文件可能会很快地变得非常大，因此不应该长期使用它。此日志通常名为 hostname.log ，位于 data 目录中。此名字可以用--log 命令行选项更改。 二进制日志。它记录更新过数据（或者可能更新过数据）的所有语句。此日志通常名为 hostname-bin ，位于 data 目录内。此名字可以用 --log-bin 命令行选项更改。注意，这个日志文件是MySQL5中添加的，以前的MySQL版本中使用的是更新日志。 缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询。这个日志在确定数据库何处需要优化很有用。此日志通常名为hostname-slow.log ， 位 于 data 目 录 中 。 此 名 字 可 以 用--log-slow-queries 命令行选项更改。 在使用日志时，可用 FLUSH LOGS 语句来刷新和重新开始所有日志文件。 ¶四、改善性能 数据库管理员把他们生命中的相当一部份时间花在了调整、试验以改善DBMS性能之上。在诊断应用的滞缓现象和性能问题时，性能不良的数据库（以及数据库查询）通常是最常见的祸因。 下面的内容并不能完全决定MySQL的性能。只是提供进行性能优化探讨和分析的一个出发点。 首先，MySQL（与所有DBMS一样）具有特定的硬件建议。在学习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但对用于生产的服务器来说，应该坚持遵循这些硬件建议。 一般来说，关键的生产DBMS应该运行在自己的专用服务器上。 MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大小等。（为查看当前设置，可使用 SHOW VARIABLES; 和 SHOW STATUS; 。） MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多个任务。如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢。如果你遇到显著的性能不良，可使用 SHOW PROCESSLIST显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL 命令终结某个特定的进程（使用这个命令需要作为管理员登录）。 总是有不止一种方法编写同一条 SELECT 语句。应该试验联结、并、子查询等，找出最佳的方法。 使用 EXPLAIN 语句让MySQL解释它将如何执行一条 SELECT 语句。 一般来说，存储过程执行得比一条一条地执行其中的各条MySQL语句快。 应该总是使用正确的数据类型。 决不要检索比需求还要多的数据。换言之，不要用 SELECT * （除非你真正需要每个列）。 有的操作（包括 INSERT ）支持一个可选的 DELAYED 关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。 在导入数据时，应该关闭自动提交。你可能还想删除索引（包括FULLTEXT 索引），然后在导入完成后再重建它们。 必须索引数据库表以改善数据检索的性能。确定索引什么不是一件微不足道的任务，需要分析使用的 SELECT 语句以找出重复的WHERE 和 ORDER BY 子句。如果一个简单的 WHERE 子句返回结果所花的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。 你的 SELECT 语句中有一系列复杂的 OR 条件吗？通过使用多条SELECT 语句和连接它们的 UNION 语句，你能看到极大的性能改进。 索引改善数据检索的性能，但损害数据插入、删除和更新的性能。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。（索引可根据需要添加和删除。） LIKE 很慢。一般来说，最好是使用 FULLTEXT 而不是 LIKE 。 数据库是不断变化的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变。 最重要的规则就是，每条规则在某些条件下都会被打破。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"关系型数据库","slug":"数据库/关系型数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"字符集","slug":"字符集","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"name":"安全管理","slug":"安全管理","permalink":"https://www.itnxd.cn/tags/%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/"},{"name":"数据库维护","slug":"数据库维护","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/"},{"name":"改善性能","slug":"改善性能","permalink":"https://www.itnxd.cn/tags/%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD/"}],"author":"Mr.Niu"},{"title":"数据库教程之游标及触发器","slug":"数据库教程之游标及触发器","date":"2020-07-02T10:12:23.000Z","updated":"2021-09-13T07:54:18.744Z","comments":true,"path":"posts/43244.html","link":"","permalink":"https://www.itnxd.cn/posts/43244.html","excerpt":"","text":"¶一、游标 游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。 在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。 注意：只能用于存储过程 不像多数DBMS，MySQL游标只能用于存储过程(和函数)。 ¶1、使用游标 在声明游标后，可根据需要频繁地打开和关闭游标。在游标打开后， 可根据需要频繁地执行取操作。 首先声明(定义)游标。这个过程实际上没有检索数据，只是定义要使用的SELECT语句。 声明后，必须打开游标使用。这个过程用前面定义的SELECT语句把数据实际检索出来。 对于填有数据的游标，根据需要取出(检索)各行 结束游标使用时，必须关闭游标 ¶2、创建游标 游标创建用DELCARE语句，(和前面的存储过程中声明变量的关键字一样)。 DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句。 DECLARE 语句用来定义和命名游标，这里为 ordernumbers 。 存储过程处理完成后，游标就消失（因为它局限于存储过程）。 123456CREATE PROCEDURE processorders()BEGIN DELCARE ordernumbers CURSOR FOR SELECT order_num FROM orders;END; ¶3、打开关闭游标 在处理OPEN语句时执行查询，存储检索出的数据以供浏览和滚动。 CLOSE释放游标使用的所有内部内存和资源，因此在每个游标不再需要时都应该关闭。 隐含关闭：如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。 12345-- 打开游标OPEN ordernumbers;-- 关闭游标CLOSE ordernumbers; 修改版本： 这个存储过程声明、打开和关闭一个游标。但对检索出的数据什么也没有做… 12345678910111213CREATE PROCEDURE processorders()BEGIN -- Delcare the cursor DELCARE ordernumbers CURSOR FOR SELECT order_num FROM orders; -- Open the cursor OPEN ordernumbers; -- Close the cursor CLOSE ordernumbers;END; ¶4、使用游标数据 在一个游标被打开后，可以使用 FETCH 语句分别访问它的每一行。 FETCH指定检索什么数据(所需的列)，检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行(不重复读取同一行)。 ¶4.1 FETCH获取一条数据 FETCH用来检索当前行的order_num列(将自动从第一行开始)到一个名为o的局部声明的变量中。 12345678910111213141516171819CREATE PROCEDURE processorders()BEGIN -- Declare local variables DECLARE o INT; -- Delcare the cursor DELCARE ordernumbers CURSOR FOR SELECT order_num FROM orders; -- Open the cursor OPEN ordernumbers; -- Get order number FETCH ordernumbers INTO o; -- Close the cursor CLOSE ordernumbers;END; ¶4.2 FETCH循环检索数据 这里的FETCH在REPEAT内，因此反复执行直到done为真（ UNTIL done END REPEAT; ）。 上面这条语句定义了一个CONTINUE HANDLER，它是在条件出现时被执行的代码。指出当SQL STATE '02000'出现时，SET done = 1。 REPEAT循环语句：REPEAT ... UNTIL 变量 END REPEAT; 1234567891011121314151617181920212223242526272829CREATE PROCEDURE processorders()BEGIN -- Declare local variables DECLARE done BOOLEAN DEFAULT 0; DECLARE o INT; -- Delcare the cursor DELCARE ordernumbers CURSOR FOR SELECT order_num FROM orders; -- Declare continue handler DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1; -- Open the cursor OPEN ordernumbers; -- Loop through all rows REPEAT -- Get order number FETCH ordernumbers INTO o; -- End of loop UNTIL done END REPEAT; -- Close the cursor CLOSE ordernumbers;END; ¶4.3 定义DECLARE语句的次序 DECLARE语句定义的局部变量必须在定义任意游标或句柄(普通语句)之前定义 句柄(普通语句)必须在游标之后定义(如循环的条件等) ¶4.4 利用游标处理数据 此存储过程不返回数据，但它能够创建和填充另一个表，可以用一条简单的SELECT语句查看该表。 这是存储过程、游标、逐行处理以及存储过程调用其他存储过程的一个完整的工作样例。 1234567891011121314151617181920212223242526272829303132333435363738394041CREATE PROCEDURE processorders()BEGIN -- Declare local variables DECLARE done BOOLEAN DEFAULT 0; DECLARE o INT; DECLARE t DECIMAL(8, 2); -- Delcare the cursor DELCARE ordernumbers CURSOR FOR SELECT order_num FROM orders; -- Declare continue handler DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1; -- Create a table to store the results CREATE TABLE IF NOT EXISTS ordertotals (order_num INT, total DECIMAL(8,2)); -- Open the cursor OPEN ordernumbers; -- Loop through all rows REPEAT -- Get order number FETCH ordernumbers INTO o; -- Get the total for this order CALL ordertotal(o, 1, t); --前一章的存储过程，主要是计算带税订单的合计，存储到t -- Insert order and total into ordertotals INSERT INTO ordertotals(order_num, totals) VALUES(o, t); -- End of loop UNTIL done END REPEAT; -- Close the cursor CLOSE ordernumbers;END; ¶二、触发器 存储过程的执行是需要自己调用的，需要是进行调用！ 而触发器则是在触发某个条件自动执行！ 触发器，当然就是触发了然后自动执行。。。 触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句(或位于BEGIN和END语句之间的一组语句)： DELETE UPDATE INSERT ¶1、创建触发器 注意：保持每个数据库的触发器名唯一。在MySQL 5中，触发器名必须在每个表中唯一，但不是在每个数据库中唯一。 虽然MySQL允许同一数据库可使用相同触发器名（不同表即可），但是这样很明显不是好的做法，最好保证同一数据库触发器名唯一！ 需要的四条信息： 唯一的触发器名 触发器关联的表 触发器应该响应的活动(DELETE、INSERT、UPDATE) 触发器何时执行(处理之前后之后) 创建触发器： CREATE TRIGGER用来创建名为newproduct的新触发器。 触发器可在一个操作发生之前或之后执行，这里给出了AFTER INSERT，所以此触发器将在INSERT语句成功执行后执行。 这个触发器还指定FOR EACH ROW，因此代码对每个插入行执行。 在这个例子中，文本Product added将对每个插入的行显示一次。 12CREATE TRIGGER newproduct AFTER INSERT ON productsFOR EACH ROW SELECT 'Product added'; 注意： 只有表才支持触发器，视图不支持，临时表也不支持。 每个表的每个事件每次只允许一个触发器 每个表最多支持6个触发器（每条INSERT、UPDATE和DELETE的之前和之后） 单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。 触发器失败： 如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）。 ¶2、删除触发器 注意：触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建。 1DROP TRIGGER 触发器名字; ¶3、使用触发器 ¶3.1 INSERT触发器 INSERT触发器在INSERT语句执行之前或之后执行 。 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行 在BEFORE INSERT触发器中，NEW的值也可以被更新(允许更改被插入的值) 对于AUTO_INCREMENT列，NEW在INSERT执行前包含0，在INSERT被执行后包含新的自动生成值。 会发现下面INSERT语句的执行多了输出结果！就是因为触发了上面的neworder触发器，执行了SELECT NEW.order_num;语句！ 此代码创建一个名为neworder的触发器，它按照AFTER INSERT ON orders执行。 在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。 触发器从NEW. order_num取得这个值并返回它。 此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。 12345678910111213-- 创建触发器CREATE TRIGGER neworder AFTER INSERT ON ordersFOR EACH ROW SELECT NEW.order_num;-- 触发开始INSERT INTO orders(order_date，cust_id)VALUES (Now()，10001) ;+-----------+| order_num |+-----------+| 20010 |+-----------+ BEFORE或AFTER？ 通常，将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据）。本提示也适用于UPDATE触发器。 ¶3.2 DELETE触发器 DELETE触发器在DELETE语句执行之前或之后执行： 在DELETE触发器代码内，可以引用一个名为OLD的虚拟表，访问被删除的行 OLD中的值全部都是只能读的，不能更新 在任意订单被删除前将执行此触发器。 它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中（为实际使用这个例子，你需要用与orders相同的列创建一个名为archive_orders的表）。 使用BEFORE DELETE触发器的优点（相对于AFTER DELETE触发器 来说），如果由于某种原因，订单不能存档，DELETE本身将被放弃。 123456CREATE TRIGGER deleteorder BEFORE DELETE ON ordersFOR EACH ROWBEGIN INSERT INTO archive_orders(order_num, order_date, cust_id) VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);END; 多语句触发器： 正如所见，触发器deleteorder使用BEGIN和END语句标记触发器体。这在此例子中并不是必需的，不过也没有害处。 使用BEGIN END块的好处是触发器能容纳多条SQL语句（在BEGIN END块中一条挨着一条）。 ¶3.3 UPDATE触发器 UPDATE触发器在UPDATE语句执行之前或之后执行 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问 以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新 更新的值； 在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值） OLD中的值全都是只读的，不能更新。 显然：数据净化都需要在 UPDATE 语句之前进行，就像这个例子中一样。每次更新一个行时， NEW.vend_state 中的值（将用来更新表行的值）都用 Upper(NEW.vend_state) 替换。 此例子：保证州名缩写总是大写（不管 UPDATE 语句中给出的是大写还是小写）。 12CREATE TRIGGER updatevendor BEFORE UPDATE ON vendorsFOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state); ¶4、触发器补充知识 与其他DBMS相比，MySQL 5中支持的触发器相当初级。未来的 MySQL版本中有一些改进和增强触发器支持的计划。 创建触发器可能需要特殊的安全访问权限，但是，触发器的执行是自动的。如果INSERT、UPDATE或DELETE语句能够执行，则相关 的触发器也能执行。 应该用触发器来保证数据的一致性（大小写、格式等）。在触发器 中执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。 触发器的一种非常有意义的使用是创建审计跟踪。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易。 遗憾的是，MySQL触发器中**不支持CALL**语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"关系型数据库","slug":"数据库/关系型数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"游标","slug":"游标","permalink":"https://www.itnxd.cn/tags/%E6%B8%B8%E6%A0%87/"},{"name":"触发器","slug":"触发器","permalink":"https://www.itnxd.cn/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/"}],"author":"Mr.Niu"},{"title":"数据库教程之表.视图.存储过程","slug":"数据库教程之表-视图-存储过程","date":"2020-07-01T03:05:00.000Z","updated":"2021-09-13T07:53:52.433Z","comments":true,"path":"posts/34686.html","link":"","permalink":"https://www.itnxd.cn/posts/34686.html","excerpt":"","text":"¶一、创建表 ¶1、简单示例如下： 12345678910111213CREATE TABLE customers( cust_id int NOT NULL AUTO_INCREMENT, cust_name char(50) NOT NULL, cust_address char(50) NULL, cust_city char(50) NULL, cust_state char(50) NULL, cust_zip char(50) NULL, cust_country char(50) NULL, cust_contact char(50) NULL, cust_email char(50) NULL, PRIMARY KEY(cust_id)) ENGINE = InnoDB; 新表的名字，在关键字create table之后给出 表列的名字和定义，用逗号分隔 使用PRIMARY KEY()指出主键 使用ENGINE = InnoDB指出使用的引擎 ¶2、IF NOT EXISTS 如果你仅想在一个表不存在则创建它，应该在表名后给出IF NOT EXISTS。 这样不做检查已有表的模式是否与你打算创建的表模式相匹配。它只是查看表名是否存在，并且仅在表名不存在时创建它。 ¶3、NULL 默认为NULL，可以设定为NOT NULL 允许NULL值的列也允许在插入行时不给出该列的值。 ¶4、主键 主键值必须唯一。 主键中只能使用不允许NULL值的列。允许值为NULL的列不能作为唯一标识。 如果主键使用单个列，则它的值必须唯一， 如果使用多个列，则这些列的组合值必须唯一。 主键可以在创建表时定义，也可以在创建表之后定义。 ¶5、AUTO_INCREMENT AUTO_INCREMENT告诉MySQL，本列每当增加一行时，自动增量。 每个表只允许一个AUTO_INCREMENT列，而且它必须被索引 INSERT插入一行时若给定一个值（只要没使用过，是唯一的）该值会覆盖自动增量生成的值，后续的增量将开始使用该手工插入的值。 last_insert_id() 使用last_insert_id()获取最后一次自增的值！ 1SELECT last_insert_id()； ¶6、指定默认值 建表时可以指定默认值，使用DEFAULT 默认值只能是常量，不能是函数或其他！ 注意：一般不使用NULL值，而使用默认值！ 123456CREATE TABLE customers( cust_id int NOT NULL AUTO_INCREMENT, quantity int NOT NULL DEFAULT 1, PRIMARY KEY(cust_id)) ENGINE = InnoDB; ¶6、三种引擎 引擎类型可以混用。不同的表可以根据需要的功能使用不同的引擎. 外键不能跨引擎：混用引擎有一个大缺陷，外键不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎的表的外键。 InnoDB：可靠的事务处理引擎，不支持全文本搜索 MEMORY：功能上等同于MyISAM，但由于数据存储在内存中，速度很快 MyISAM：性能极高的引擎，支持全文本搜索，但不支持事务的处理。 ¶二、更新表 使用 ALTER TABLE语句！ ¶1、增加列 12ALTER TABLE vendorsADD vend_phone CHAR(20); ¶2、删除列 12ALTER TABLE vendorsDROP vend_phone; ¶3、定义外键 123ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_ordersFOREING KEY(order_num) REFERENCES orders(order_num); ¶4、复杂的表结构更改步骤 用新的列布局创建一个新表 使用INSERT SELECT语句从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段 检验包含所需数据的新表 重命名旧表(如果确定，可以删除它) 用旧表原来的名字重新命名新表 根据需要，重新创建触发器、存储过程、索引和外键。 ¶三、删除表 使用DROP TALBE删除一个表！ 1DROP TABLE 表名; ¶四、重命名表 使用RENAME TABLE 新表名 TO 旧表名，可以有多个重命名 12345RENAME TABLE backup_customers TO customers;RENAME TABLE backup_customers TO customers, backup_vendors TO vendors, backup_products TO products; ¶五、视图 ¶1、视图 视图是虚拟的表，视图本身不包含数据。 与包含数据的表不一样，视图只包含使用时动态检索数据的查询。 视图是个啥？ 简单来说就是针对SELECT一系列操作的集合。。。为了之后操作的简单而引入！ 注意：视图返回的数据是从其他表中检索出来的，在添加或更加这些表中的数据时，视图将返回改变过的数据。 ¶2、为什么使用视图 算是优点吧！ 重用SQL语句 简化复杂SQL的操作 使用表的组成部分而不是整个表 保护数据。可以给用户手续表的特定部分的访问权限而不是整个表的访问权限。 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图执行 SELECT 操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据！ 性能问题： 如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会造成性能下降得很厉害。 ¶3、视图的规则和限制 视图名字必须唯一(和表名一样，不能给视图取与别的视图或表名相同的名字) 对于可以创建的视图数目没有限制 为了创建视图，必须具有一足够的访问权限，这些限制通常由数据库管理人员授予。 视图可以嵌套，即可以利用从其他视图中检索出来的数据的查询来构造一个视图 ORDER BY可以用在视图中，但如果从该视图检索数据的select语句中也含有order by，那么该视图的order by会被覆盖 视图不能索引，也不能有关联的触发器或默认值 视图可以和表一起使用。例如，编写一条联结表和视图的select语句。 ¶4、使用视图 视图用CREATE VIEW语句创建 使用show create view viewname查看创建视图的语句 使用drop view viewname来删除视图 更新视图：先drop再create，也可以直接使用create or replace view。 一次编写，到处运行？！！ ¶4.1 简化复杂联结 创建可重用的视图 创建不受特定数据限制的视图是一种好办法。扩展视图的范围不仅使得它能被重用，而且甚至更有用。这样做不需要创建和维护多个类似视图。 1234567891011-- 第一步：CREATE VIEW productcustomers ASselect cust_name, cust_contact, prod_idfrom customers, orders, orderitemswhere customers.cust_id = orders.cust_idand orderitems.order_num = orders.order_num;-- 第二步：select cust_name, cust_contactfrom productcustomerswhere prod_id = 'TNT2'; ¶4.2 重新格式化检索出的数据 1234CREATE VIEW vendorlocations ASselect Contact(RTrim(vend_name)), '(', RTrim(vend_country),')')from vendorsorder by vend_name; ¶4.3 过滤不想要的数据 视图中的WHERE会和检索中的WHERE实行AND操作！ 1234CREATE VIEW customeremaillist ASSELECT cust_id, cust_name, cust_emailFROM customersWEHRE cust_email IS NOT NULL; ¶4.4 使用视图与计算字段 1234567CREATE VIEW orderitemsexpanded ASSELECT order_num, prod_id, quantity, item_price, quantity*item_price AS expanded_priceFROM orderitems; ¶4.5 更新视图 通常，视图是可更新的，即可以对它们进行INSERT、UPDATE和DELETE。 更新一个视图将更新其基表。如果你对视图增加或删除，实际上是对基表进行增加和删除。 但是，并非所有的视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新。 注意：视图主要用于数据检索，而不用于更新。 即如果视图定义中有以下操作，则不能进行视图的更新： 分组(GROUP BY 或者HAVING) 联结 子查询 并 聚集函数(Min()、Max()、Count()、Sum()等) DISTINCT 导出(计算)列 ¶六、存储过程 存储过程，简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。 类似其他语言的函数，一次声明，到处调用！ ¶1、存储过程的优缺点 优点 通过把处理封装在容易使用的单元中，简化复杂操作。 由于不要求反复建立一系列处理步骤，保证了数据的完整性。如果所有开发人员和应用程序都使用同一存储过程，则使用的代码都是相同的。(减少错误) 简化对变动的管理。如果表名、列名或业务逻辑有变化，只需要修改存储过程的代码。使用它的人员甚至不需要知道这些变化。(安全性) 提高性能。存储过程比单独的SQL语句要快。 存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写共鞥更强更灵活的代码。 缺点 存储过程比SQL语句复杂得多 并不是所有人都有创建存储过程的安全访问权限。许多数据库管理员限制存储过程的创建权限，允许用户使用存储过程，但不允许他们创建存储过程。 ¶2、执行存储过程 存储过程名可以理解为函数名，CALL表示简要调用此存储过程！ @param1、@param2.....等等为当前存储过程的参数，可以理解为函数的参数！ 12345678910CALL 存储过程名(@param1, @param2, ...);-- 实例如下：CALL productpricing(@pricelow, @pricehigh, @priceaveage); ¶3、创建存储过程 语法格式：CREATE PROCEDURE 存储过程名（@param1,@param2...） BEGIN ... END; BEGIN与END中间的就是存储过程的语句！ 12345CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END; ¶4、mysql命令行客户机的分隔符 默认的MySQL分隔符为;(和SQL语句一样)，mysql命令行实用程序也使用，作为语句分隔符。如果命令行实用程序要解释存储过程自身内；字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL语句出现句法错误。 简单来说就是;被占用了，sql语句就不会正确执行了。 解决办法： 更改默认分隔符;，使用完再进行还原！ 除\\ 符号外，任何字符都可以用作语句分隔符。 123456789-- 更改分隔符DELIMITER //CREATE PRODUCER productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END //-- 还原分隔符DELEMITER ; ¶5、删除存储过程 使用IF EXISTS，若不存在也将不会报错！ 语法格式：DROP PROCUDURE 存储过程 123DROP PROCEDURE 存储过程名;DROP PROCUDURE 存储过程名 IF EXISTS; ¶6、带参数的存储过程 一般，存储过程并不显示结果，而是把结果返回给你指定的变量（临时保存返回结果）。 参数必须有指定的类型。不能通过一个参数返回多个行和列。 格式：OUT/IN/INOUT 变量名 类型 SELECT ... INTO 参数名：即将结果传给该参数！ 12345678910111213141516CREATE PRODUCER productpricing( OUT pl DECIMAL(8, 2), OUT ph DECIMAL(8, 2), OUT pa DECIMAL(8, 2))BEGIN SELECT Min(prod_price) INTO pl FROM products; SELECT Max(prod_price) INTO ph FROM products; SELECT Avg(prod_price) INTO pa FROM products;END; 参数类型： OUT：指出相应的参数用来从存储过程传出一个值(返回给调用者) IN：传递给存储过程 INOUT：对存储过程传入和传出 开始执行存储过程： 这样调用存储过程就会将内部得到的值返回给@开头的三个参数！使用 SELECT @参数名 ...即可查询到当前结果！ 变量名：所有MySQL的变量都必须以@开始 1234567CALL productpricing(@pricelow, @pricehigh, @priceaveage);SELECT @priceaverage;SELECT @pricelow, @pricehigh, @priceaveage; 使用IN和OUT参数： 使用了IN自然就得传入一个参数，如下方的20005。 1234567891011121314151617-- 创建存储过程CREATE PRODUCER ordertotal( IN onumber INT, OUT ototal DECIMAL(8, 2))BEGIN SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num = onumber INTO ototal;END;-- 调用存储过程CALL orderitems(20005, @total);-- 查看结果select @total; ¶7、复杂存储过程 DECLARE：用于定义变量，需要指明类型！ COMMIT：不是必需的，但是如果给出，将在SHOW PROCEDURE STATUS的结果中显示。 IF：条件语句，还支持ELSEIF， ELSE语句，格式：IF THEN ELSEIF ELSE END IF; 12345678910111213141516171819202122232425262728293031323334-- Name：ordertotal-- Parameters：onumber = order number-- taxable = 0 if not taxable, 1 if taxable-- ototal = order total variableCREATE PROCEDURE ordertotal( IN onumber INT, IN taxable BOOLEAN, OUT ototal DECIMAL(8, 2)) COMMIT \"obtain order total, optionally adding tex\"BEGIN -- Declare variable for total DECLARE total DECIMAL(8, 2); -- Declare tax percentage DECLARE taxrate INT DEFAULT 6; -- Get the order total SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num = onumber INTO total; -- Is it taxable? IF taxable THEN -- Yes, so add taxrate to the total SELECT total+(total/100*taxrate) INTO total; END IF; -- And finally, save to out variable SELECT total INTO ototal;END;-- 调用存储过程CALL orderototal(20005, 0, @total);SELECT @total; ¶8、检查存储过程 可以显示用来创建一个存储过程的 CREATE 语句。 为了获得包括何时、由谁创建等详细信息的存储过程列表，使用 SHOW PROCEDURE STATUS 。 12345678-- 显示创建存储过程的语句SHOW CREATE PROCEDURE ordertotal;-- 何时、由谁创建等详细信息SHOW PROCEDURE STATUS;-- 使用过滤SHOW PROCEDURE STATUS LIKE 'ordertotal'; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"关系型数据库","slug":"数据库/关系型数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"表","slug":"表","permalink":"https://www.itnxd.cn/tags/%E8%A1%A8/"},{"name":"视图","slug":"视图","permalink":"https://www.itnxd.cn/tags/%E8%A7%86%E5%9B%BE/"},{"name":"存储过程","slug":"存储过程","permalink":"https://www.itnxd.cn/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-40.组合总和II","slug":"LeetCode刷题-40-组合总和II","date":"2020-06-27T14:09:19.000Z","updated":"2021-02-06T14:40:13.891Z","comments":true,"path":"posts/41794.html","link":"","permalink":"https://www.itnxd.cn/posts/41794.html","excerpt":"","text":"题目链接：40.组合总和II ¶题解： 和上一道类似，递归解决，多了一个限制！ ¶题目简述： 给定一个数组（可能有相同元素），每个数只能用一次，求出和为目标值的组合。组合不能重复。 ¶题解： 上一题是没有相同元素，一数可多选。本题是有相同元素，一数只能一选。 关键点：将上一道题的 dfs(candidates, target - candidates[i], i)的i改为i + 1即可，即可以保证一数一选。 第二点 ：需要进行判重，先排序，使得相同元素扎堆在一起，然后在进行同位置的选取时，进行判断跳过相同元素即可if(i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue;，这样会保证路径在同一个位置的选取不会重复，即可以保证结果不会有重复组合。 具体如何判重： 如果是同一个位置的第一次选取，是不会影响的，由于i &gt; start，第一次进去是i == start，同一个位置的多次选取，即回溯时遇到的for循环，candidates[i] == candidates[i - 1]，这个条件则可以保证同一个位置不选择重复的数。 同样使用递归解决： dfs(vector&lt;int&gt;&amp; candidates, int target, int start) start用来指向从该数组的哪一个数进行循环。 递归出口： target &lt; 0，即已经将目标值减没了，可以return了。 target == 0，恰好等于0，则说明找到了一种组合，将当前有效路径path加入答案res 从start开始循环，path添加当前选取值，进行下一轮dfs(candidates, target - candidates[i], i + 1)，start从i + 1开始即可，选下一个位置的数，超过即target &lt; 0，直接返回 一个位置选择完毕将会进入下一个位置的选取。 for循环内dfs的结束有两种情况，一是当前位置的条件下有解，二是当前位置条件下无解。然后进行回溯，取消path中的路径，找下一个位置的选取情况。 ¶AC代码： 1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(), candidates.end()); dfs(candidates, target, 0); return res; } void dfs(vector&lt;int&gt;&amp; candidates, int target, int start){ if(target &lt; 0) return; if(target == 0){ res.push_back(path); return; } for(int i = start; i &lt; candidates.size(); i++){ if(i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; path.push_back(candidates[i]); dfs(candidates, target - candidates[i], i + 1); path.pop_back(); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-39.组合总和","slug":"LeetCode刷题-39-组合总和","date":"2020-06-27T14:08:53.000Z","updated":"2021-02-06T14:40:56.666Z","comments":true,"path":"posts/34556.html","link":"","permalink":"https://www.itnxd.cn/posts/34556.html","excerpt":"","text":"题目链接：39.组合总和 ¶题解： 递归同一元素可重复选取的解决，用减法减到 0 为止！ 当然也可以加法加到目标值，都行！ ¶题目简述： 给定一个无重复元素的序列，找到符合目标值的所有组合，不重复的组合。 ¶题解： 使用深搜即可，关键点，每个数可以选不止一次。 本题可进行累加，也可以进行累减。推荐使用累减版本！ 具体解决： dfs(vector&lt;int&gt;&amp; candidates, int target, int start) start用来指向从该数组的哪一个数进行循环。 递归出口： target &lt; 0，即已经将目标值减没了，可以return了。 target == 0，恰好等于0，则说明找到了一种组合，将当前有效路径path加入答案res 从start开始循环，path添加当前选取值，进行下一轮dfs(candidates, target - candidates[i], i)，start仍然从i开始即可，选同一个数的最多次，超过即target &lt; 0，直接返回 同一个数的最多次选择完毕将会进入下一个数的选取。 for循环内dfs的结束有两种情况，一是当前数的次数已经选到了最多，二是当前次数条件下无解。然后进行回溯，取消path中的路径，找下一个数的多次选取情况。 ¶AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 累减版本class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { dfs(candidates, target, 0); return res; } void dfs(vector&lt;int&gt;&amp; candidates, int target, int start){ if(target &lt; 0) return; if(target == 0){ res.push_back(path); return; } for(int i = start; i &lt; candidates.size(); i++){ path.push_back(candidates[i]); dfs(candidates, target - candidates[i], i); path.pop_back(); } }};// 累加版本class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { dfs(candidates, target, 0, 0); return res; } void dfs(vector&lt;int&gt;&amp; candidates, int target, int start, int num){ if(target &lt; num) return; if(target == num){ res.push_back(path); return; } for(int i = start; i &lt; candidates.size(); i++){ path.push_back(candidates[i]); dfs(candidates, target, i, num + candidates[i]); path.pop_back(); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-38.外观数列","slug":"LeetCode刷题-38-外观数列","date":"2020-06-27T14:07:59.000Z","updated":"2021-02-06T14:40:36.834Z","comments":true,"path":"posts/58677.html","link":"","permalink":"https://www.itnxd.cn/posts/58677.html","excerpt":"","text":"题目链接：38.外观数列 ¶题解： 嗯，做这种题得有宏观思想，我就是被细小地方搞混乱了！ 也是双指针的思想。 ¶题目简述： 给定一个序列1，接下来每一项都是前一项的描述，详细请看官网描述！ ¶题解： 说白了，就是从前一项找到相同的字符的起始位置即可。。 例如：12233344只要能分成1、22、333、44四段即可！ 具体思路： 借助双指针思想，一个指向该段起点j，一个指向该段最后一个位置的下一个位置k即可。该段的长度就是k - j，该段的字符就是s[j]。 即最终为t += to_string(k - j) + s[j] 注意 ：使用两个变量来回切换，s指向上一个，t指向当前。以及j = k，来进行动态跳转到下一段位置起点！ 关于 to_string()： C++11支持的转换字符串函数，在这里如果不使用这个函数，也可以通过'0' + k - j，但是这样有个缺点，不能超过ASCII码的范围！ ¶AC代码： 1234567891011121314151617class Solution {public: string countAndSay(int n) { string s = \"1\"; for(int i = 0; i &lt; n - 1; i++){ string t; for(int j = 0; j &lt; s.size();){ int k = j + 1; while(k &lt; s.size() &amp;&amp; s[j] == s[k]) k++; t += to_string(k - j) + s[j]; j = k; } s = t; } return s; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-37.解数独","slug":"LeetCode刷题-37-解数独","date":"2020-06-27T12:10:59.000Z","updated":"2021-02-06T14:36:19.902Z","comments":true,"path":"posts/37046.html","link":"","permalink":"https://www.itnxd.cn/posts/37046.html","excerpt":"","text":"题目链接：37.解数独 ¶题解： 好了，来开始解数独了！ ¶题目简述： 同上一题，都是数独，此题用来解数独。 ¶题解： 这道题的第一个关键在于填数字的时候如何处理行列即九宫格是否有该数！ 同上一题的判断有效性，使用三个数组row[9][9], col[9][9], cell[3][3][9]来分别指向九行，九列，九个九宫格，的九个数来进行标记。 对于九宫格的处理： 可以对行列取除i / 3, j / 3，会发现只要是在九宫格他们得到的结果一定是每个九宫格左上角的坐标位置，这样就可以进行轻松的标记！ 递归过程： 递归出口，由于从左到右从上到下进行爆搜，所以： 若y == 9，则x ++, y = 0，即到了行末，进行换行 若x == 9，则return true ，即已经搜完了最后一行最后一个了，直接返回 若当前搜到的为.，则直接跳过，return dfs(board, x, y + 1) 否则，进行循环搜索，若行列九宫格都没有重复，则填充当前值，并将行列九宫格都标记为true 继续向后搜索，若可以搜到底，直接返回true，说明找到了一种情况。 否则，进行回溯，取消标记，将填充值恢复为. 若搜完九个数并没有可以填的数，直接返回false 注意： 将下标转换为字符，board[x][y] = '1' + i，将字符转换为数字， board[i][j] - '1' ¶AC代码： 12345678910111213141516171819202122232425262728293031class Solution {public: bool row[9][9], col[9][9], cell[3][3][9]; void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { for(int i = 0; i &lt; 9; i++){ for(int j = 0; j &lt; 9; j++){ if(board[i][j] != '.'){ int t = board[i][j] - '1'; row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true; } } } dfs(board, 0, 0); } bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y){ if(y == 9) x ++, y = 0; if(x == 9) return true; if(board[x][y] != '.') return dfs(board, x, y + 1); for(int i = 0; i &lt; 9; i++){ if(!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[x / 3][y / 3][i]){ board[x][y] = '1' + i; row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = true; if(dfs(board, x, y + 1)) return true; board[x][y] = '.'; row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = false; } } return false; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"数独","slug":"数独","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%8B%AC/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-36.有效的数独","slug":"LeetCode刷题-36-有效的数独","date":"2020-06-27T12:10:38.000Z","updated":"2021-02-06T14:36:33.874Z","comments":true,"path":"posts/63579.html","link":"","permalink":"https://www.itnxd.cn/posts/63579.html","excerpt":"","text":"题目链接：36.有效的数独 ¶题解： 数独游戏的到来，这道题判断是否有解，下一道题咱们来填数独！ ¶题目简述： 给定一个9 X 9 的数独，判断当前状态是否有解！ ¶题解： 判断是否有解，即判断行和列以及九个小九宫格是否会出现一个数多用的情况即可！ 判断行：直接遍历即可，每行进行一下数组清零 判断列：将i, j调换一下即可！每列进行一下数组清零 判断九宫格：可以使用i, j指向每个九宫格的第一个位置代表不同的九宫格，即i, j += 3 然后再在个九宫格中使用两层循环遍历九个格子即可，每个九宫格进行数组清零，指向的位置即为i + x, j + y 使用过直接返回false，全部遍历完都没问题，则返回true 注意：要将数独中的字符转变为数字进行！转换为了1 - 9 ¶AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { bool s[10]; for(int i = 0; i &lt; 9; i ++){ memset(s, 0, sizeof s); for(int j = 0; j &lt; 9; j ++){ if(board[i][j] != '.'){ int t = board[i][j] - '0'; if(s[t]) return false; s[t] = true; } } } for(int i = 0; i &lt; 9; i ++){ memset(s, 0, sizeof s); for(int j = 0; j &lt; 9; j ++){ if(board[j][i] != '.'){ int t = board[j][i] - '0'; if(s[t]) return false; s[t] = true; } } } for(int i = 0; i &lt; 9; i += 3){ for(int j = 0; j &lt; 9; j += 3){ memset(s, 0, sizeof s); for(int x = 0; x &lt; 3; x ++){ for(int y = 0; y &lt; 3; y ++){ if(board[i + x][j + y] != '.'){ int t = board[i + x][j + y] - '0'; if(s[t]) return false; s[t] = true; } } } } } return true; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数独","slug":"数独","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%8B%AC/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-35.搜索插入位置","slug":"LeetCode刷题-35-搜索插入位置","date":"2020-06-27T03:01:50.000Z","updated":"2021-02-06T14:36:52.728Z","comments":true,"path":"posts/24432.html","link":"","permalink":"https://www.itnxd.cn/posts/24432.html","excerpt":"","text":"题目链接：35.搜索插入位置 ¶题解： 同样是二分！ ¶题目简述： 给一个有序数组，查找目标值的位置，若数组中存在，返回该下标，否则返回目标值应该插入的位置！ ¶题解： 继续二分： 找到二分条件：x &gt;= target，右端满足，左端不满足！ 如果最终该目标值越界，即nums[r] &lt; target，直接返回r + 1或nums.size()。 会发现：其实直接使用右端点r = nums.size()二分即可！最后也可以不用判断是否越界！ ¶AC代码： 123456789101112131415161718192021222324252627class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int l = 0, r = nums.size() - 1; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid; else l = mid + 1; } if(nums[r] &lt; target) return r + 1; return r; }};// 或者这样：class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int l = 0, r = nums.size(); while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid; else l = mid + 1; } return r; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-34.在排序数组中查找元素的第一个和最后一个位置","slug":"LeetCode刷题-34-在排序数组中查找元素的第一个和最后一个位置","date":"2020-06-27T03:01:28.000Z","updated":"2021-02-06T14:31:25.112Z","comments":true,"path":"posts/39392.html","link":"","permalink":"https://www.itnxd.cn/posts/39392.html","excerpt":"","text":"题目链接：34.在排序数组中查找元素的第一个和最后一个位置 ¶题解： 同样是二分！ ¶题目简述： 给定一个有序数组，找到目标值出现的开始和结束位置！ ¶题解： 同样是二分：目的在于找到两个端点，如下图： 使用 x &gt;= target可以找到满足该条件的最后一个数，即左端点！ 使用x &lt;= target可以找到满足该条件的最后一个数， 即右端点！ 具体情况： 若数组为空，直接返回-1 若左端点不存在，即不存在target直接返回-1 否则，重新二分该数组找到右端点，最后返回。 注意： 二分左端点时，r的选取可以是nums.size() - 1，也可以是上次二分的结果。复杂度不影响！ ¶AC代码： 123456789101112131415161718192021class Solution {public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { if(nums.empty()) return {-1, -1}; int l = 0, r = nums.size() - 1; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid; else l = mid + 1; } if(nums[r] != target) return {-1, -1}; int L = r; l = 0, r = nums.size() - 1; while(l &lt; r){ int mid = l + r + 1 &gt;&gt; 1; if(nums[mid] &lt;= target) l = mid; else r = mid - 1; } return {L, r}; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-33.搜索旋转排序数组","slug":"LeetCode刷题-33-搜索旋转排序数组","date":"2020-06-27T03:00:58.000Z","updated":"2021-02-06T14:33:46.357Z","comments":true,"path":"posts/51598.html","link":"","permalink":"https://www.itnxd.cn/posts/51598.html","excerpt":"","text":"题目链接：33.搜索旋转排序数组 ¶题解： 开始进入二分的时代，二分模板要掌握并理解。 ¶题目简述： 一个升序序列在某一点反转形成两个升序序列，从其中找到一个目标值，不存在返回 -1，要求时间复杂度为O(log n)级别。 ¶题解： 自然而然的想到要使用二分了！ 二分的二段性：一段满足，另一段不满足，则可以将分界点二分出来！ 二分可以找到满足条件的最后一个数！最后（指的是按照区间缩小的趋势最后满足条件的数） 二分模板：点击这里！ 注意：关于mid加不加一的问题，若 l= mid就得加，否则只有两数会造成死循环；若r = mid就不能加，否则只有两数也会造成死循环。 ‘ 本题分为了两段，根据二分的二段性，当 x &gt;= nums[0]的时候，会发现左边一段都符合条件，右边一段都不符合条件，可以使用二分，二分到分界点。 如下图： 找到分界点后，判断当前目标值在哪一段，继续进行二分即可！ 0 ~ mid mid + 1 ~ nums.size() - 1 ¶AC代码： 1234567891011121314151617181920212223class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { if(nums.empty()) return -1; // 0 1 int l = 0, r = nums.size() - 1; while(l &lt; r){ int mid = l + r + 1 &gt;&gt; 1; if(nums[mid] &gt;= nums[0]) l = mid; else r = mid - 1; } if(target &gt;= nums[0]) l = 0; else l = r + 1, r = nums.size() - 1; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid; else l = mid + 1; } if(nums[r] == target) return r; else return -1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"}],"author":"Mr.Niu"},{"title":"数据库教程之事务及隔离","slug":"数据库教程之事务及隔离","date":"2020-06-26T02:51:23.000Z","updated":"2021-09-13T07:54:11.483Z","comments":true,"path":"posts/61605.html","link":"","permalink":"https://www.itnxd.cn/posts/61605.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶一、事务 把多条语句作为一个整体进行操作的功能，被称为数据库事务。 数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。 与多条语句分别执行而不使用事务的区别： 不使用事务，若某一句执行出错，则执行成功的语句将会生效 使用事务，若某一句执行出错，当我们关掉窗口再次打开则会自动触发回滚操作ROLLBACK 事务(transaction)：一组SQL语句 回退(rollback)：撤销指定SQL语句 提交(commit)：指将未存储的SQL语句结果写入数据库表 保留点(savepoint)：指事务处理中设置的临时占位符，你可以对它发布回退(与回退整个事务处理不同) ¶1、数据库事务的ACID四个特性 A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行； C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100； I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离； D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。 ¶2、隐式事务 对于单条SQL语句，数据库系统自动将其作为一个事务执行！这种事务被称为隐式事务。 1UPDATE accounts SET balance = balance - 100 WHERE id = 1; ¶3、显示事务 对于多条SQL语句，想要使用事务，必须手动启用，使用BEGIN或START TRANSACTION开启一个事务，使用COMMIT提交一个事务，这种事务被称为显式事务。 有一句执行失败，系统就会调用ROLLBACK进行回滚。 1234BEGIN;UPDATE accounts SET balance = balance - 100 WHERE id = 1;UPDATE accounts SET balance = balance + 100 WHERE id = 2;COMMIT; 做个试验： 1234567891011121314151617181920212223242526-- 原来的样子mysql&gt; SELECT * FROM accounts;+----+---------+| id | balance |+----+---------+| 1 | 134 || 2 | 123 |+----+---------+2 rows in set (0.00 sec)-- 开始测试BEGIN;UPDATE accounts SET balance = balance - 100 WHERE id = 1;-- 此时为错误语句UPDATE accounts SET balance = balance + 100 WHERE d = 2;-- 现在关闭窗口 重新打开-- 会发现没有改变，系统自动进行了ROLLBACK操作mysql&gt; SELECT * FROM accounts;+----+---------+| id | balance |+----+---------+| 1 | 134 || 2 | 123 |+----+---------+2 rows in set (0.00 sec) 那些语句可以回退？ INSERT UPDATE DELETE SELECT(无意义) CREATE、DROP(事务处理块中可以使用这个语句，但是回退后，他们不会撤销操作) ¶4、主动失败 有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务。 如下方语句，会发现并没有造成修改，其实是做了回滚。 12345678910111213141516171819202122232425262728293031mysql&gt; SELECT * FROM accounts;+----+---------+| id | balance |+----+---------+| 1 | 134 || 2 | 123 |+----+---------+2 rows in set (0.00 sec)mysql&gt; BEGIN;Query OK, 0 rows affected (0.00 sec)mysql&gt; UPDATE accounts SET balance = balance - 100 WHERE id = 1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; UPDATE accounts SET balance = balance + 100 WHERE id = 2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; ROLLBACK;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT * FROM accounts;+----+---------+| id | balance |+----+---------+| 1 | 134 || 2 | 123 |+----+---------+2 rows in set (0.00 sec) ¶5、使用保留点 简单的事务可能只需要COMMIT或ROLLBACK，但是复杂的事务可能就需要进行部分提交或回退。 保留点可以使你回退到某个位置，而不是全部都进行回退！ 保留点越多越好 释放保留点 保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。 创建保留点（占位符）： 1SAVEPOINT 保留点名字; 回退到保留点： 1ROLLBACK TO 保留点名字; ¶6、更改默认提交行为 默认的MySQL行为是自动提交的，如果要更改，需要使用以下语句： 1SET autocommit=0 autocommit标志决定是否自动提交更改，不管有没有COMMIT语句。 设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止）。 不管是平时的默认语句，还是事务，都需要commit之后才会提交，可以用两个终端来测试。 标志为连接专用: autocommit标志是针对每个连接而不是服务器的。 ¶二、隔离级别 对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。 SQL标准定义了4种隔离级别： Isolation Level 脏读（Dirty Read） 不可重复读（Non Repeatable Read） 幻读（Phantom Read） Read Uncommitted Yes Yes Yes Read Committed - Yes Yes Repeatable Read - - Yes Serializable - - - ¶1、Read Uncommitted Read Uncommitted是隔离级别最低的一种事务级别。 在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。 先创建一个表： 12345678910111213141516171819mysql&gt; CREATE TABLE student_of_dirty_read ( -&gt; id BIGINT NOT NULL AUTO_INCREMENT, -&gt; name VARCHAR(100) NOT NULL, -&gt; PRIMARY KEY (id) -&gt; );Query OK, 0 rows affected (0.03 sec)mysql&gt; INSERT INTO student_of_dirty_read (name) VALUE (\"Alice\");Query OK, 1 row affected (0.01 sec)mysql&gt; SELECT * FROM student_of_dirty_read;+----+-------+| id | name |+----+-------+| 1 | Alice |+----+-------+1 row in set (0.00 sec)mysql&gt; 然后分别开启两个MySql数据连接，按顺序执行下列命令： 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; 2 BEGIN; BEGIN; 3 UPDATE students SET name = ‘Bob’ WHERE id = 1; 4 SELECT * FROM students WHERE id = 1; 5 ROLLBACK; 6 SELECT * FROM students WHERE id = 1; 7 COMMIT; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED：意思是设置事务隔离级别为Read Uncommitted 1234567891011121314151617-- 第一次mysql&gt; SELECT * FROM student_of_dirty_read WHERE id = 1;+----+------+| id | name |+----+------+| 1 | Bob |+----+------+1 row in set (0.00 sec)-- 第二次mysql&gt; SELECT * FROM student_of_dirty_read WHERE id = 1;+----+-------+| id | name |+----+-------+| 1 | Alice |+----+-------+1 row in set (0.00 sec) 事务B两次输出不一样，读到了为提交的数据！这就是脏读！ 可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。 ¶2、Read Committed 不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。 一点区别： Read Uncommitted 隔离级别下，一个事务可以读到另一个事务更新数据后未提交的数据 Read Committed 隔离级别下，一个事务在另一个事务更新数据后，不能读取另一个事务更新数据后 **未提交 **的数据(或者说想读取更新后的数据，必须在提交事务后；在提交事务前，只能读取到更新前的数据) 仍然是上面的未修改的表： 分别开启两个MySql数据连接，按顺序执行下列命令： 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; SET TRANSACTION ISOLATION LEVEL READ COMMITTED; 2 BEGIN; BEGIN; 3 UPDATE students SET name = ‘Bob’ WHERE id = 1; 4 SELECT * FROM students WHERE id = 1; 5 COMMIT; 6 SELECT * FROM students WHERE id = 1; 7 COMMIT; SET TRANSACTION ISOLATION LEVEL READ COMMITTED：意思是设置事务隔离级别为Read Committed 1234567891011121314151617-- 第一次：mysql&gt; SELECT * FROM student_of_dirty_read;+----+-------+| id | name |+----+-------+| 1 | Alice |+----+-------+1 row in set (0.00 sec)-- 第二次mysql&gt; SELECT * FROM student_of_dirty_read;+----+------+| id | name |+----+------+| 1 | Bob |+----+------+1 row in set (0.00 sec) 会发现事务B在事务A没提交的时候，只能读到原始数据，提交后才能读到修改后的数据。由于读到的两次数据不一致，所以这样的重复读会造成问题。 ¶3、Repeatable Read 幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。 仍然是上面的未修改的表： 分别开启两个MySql数据连接，按顺序执行下列命令： 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; 2 BEGIN; BEGIN; 3 SELECT * FROM students WHERE id = 99; 4 INSERT INTO students (id, name) VALUES (99, ‘Bob’); 5 COMMIT; 6 SELECT * FROM students WHERE id = 99; 7 UPDATE students SET name = ‘ccc’ WHERE id = 99; 8 SELECT * FROM students WHERE id = 99; 9 COMMIT; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ：意思是设置事务隔离级别为Repeatable Read 12345678910111213141516-- 第一次：mysql&gt; SELECT * FROM student_of_dirty_read WHERE id = 99;Empty set (0.00 sec)-- 第二次：mysql&gt; SELECT * FROM student_of_dirty_read WHERE id = 99;Empty set (0.00 sec)-- 第三次mysql&gt; SELECT * FROM student_of_dirty_read;+----+------+| id | name |+----+------+| 1 | ccc |+----+------+1 row in set (0.00 sec) 第一次读不到，第二次仍然读不到，第三次更新却可以进行，并且查询也可以正常进行，这就是幻读。 ¶4、Serializable Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。 虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。 ¶5、默认隔离级别 如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"关系型数据库","slug":"数据库/关系型数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"事务","slug":"事务","permalink":"https://www.itnxd.cn/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"隔离","slug":"隔离","permalink":"https://www.itnxd.cn/tags/%E9%9A%94%E7%A6%BB/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-32.最长有效括号","slug":"LeetCode刷题-32-最长有效括号","date":"2020-06-25T10:37:59.000Z","updated":"2021-02-06T14:34:14.946Z","comments":true,"path":"posts/24831.html","link":"","permalink":"https://www.itnxd.cn/posts/24831.html","excerpt":"","text":"题目链接：32.最长有效括号 ¶题解： 又是动态规划的题，需要多加理解与按步骤走；同时使用栈也可以巧妙的解决！ ¶题目简述： 给定一个包含左右括号的字符串，需要求出最长的有效匹配括号的子串的长度！ ¶题解一：使用栈 首先，先回忆一下括号匹配的两个条件？ 上次的括号问题有提到的，点击这里！ 左右括号相等 任意前缀左括号数量大于等于右括号数量 接下来，我们可以将该括号序列分为若干段： 从前向后找，找到右括号大于左括号的位置，此时就是一段合法区间 从所有合法区间中找到一个最大匹配有效长度即可 参考下面的图： 具体操作： 使用start标记可匹配区间的上一个元素，即每次出现的右大于左的位置！ 遇到左括号直接进栈 遇到右括号： 若栈不空，说明没走到右大于左的位置，此时栈顶元素与之对应的左括号出栈 如果出栈后栈空，说明从起点start到当前位置i是一组有效括号序列，更新最大值 如果出栈后不空，说明栈顶到当前位置i是一组有效括号序列，更新最大值 若栈为空，说明已经走到右大于左的位置，此时更新start为当前位置i ¶AC代码一： 123456789101112131415161718class Solution {public: int longestValidParentheses(string s) { stack&lt;int&gt; stk; int res = 0; for(int i = 0, start = -1; i &lt; s.size(); i++){ if(s[i] == '(') stk.push(i); else{ if(stk.size()){ stk.pop(); if(stk.size()) res = max(res, i - stk.top()); else res = max(res, i - start); }else start = i; } } return res; }}; ¶题解二：动态规划 参考题解：点击这里！ 题目中提到了最长，可以考虑使用动态规划解题！ 同样分为两步： 状态表示：一个字符串，使用一维数组dp[i]，表示以s[i]为结尾的字符串中有效括号的最大长度（包括i） 状态计算： 若s[i]为左括号，由于左括号不可能和之前括号组合为有效括号，故 dp[i] = 0 若s[i]为右括号： 若s[i - 1]为左括号，形如：...()，此时dp[i] = 2；若相邻的之前还有匹配括号，则dp[i] += dp[i - 2]，见下方图一！ 若s[i - 1]为右括号，形如：...))，则此时只有保证当前右括号有匹配项，即dp[i - 1] &gt; 0，形如：...(...))；并且保证s[i]也有括号匹配，即s[i - dp[i - 1] - 1] == '('，形如：...((...))，这样才可完成s[i]的匹配，此时dp[i] = dp[i - 1] + 2；若与s[i]匹配的左括号相邻的之前还有匹配括号，形如：.(..)((...))，则dp[i] += dp[i -dp[i - 1] - 2]，见下方图二！ 图一： 图二： ¶AC代码二： 1234567891011121314151617181920class Solution {public: int longestValidParentheses(string s) { vector&lt;int&gt; dp(s.size()); int res = 0; for(int i = 1; i &lt; s.size(); i++){ if(s[i] == ')'){ if(s[i - 1] == '('){ dp[i] = 2; if(i - 2 &gt;= 0) dp[i] += dp[i - 2]; }else if(dp[i - 1] &gt; 0 &amp;&amp; i - dp[i - 1] - 1 &gt;= 0 &amp;&amp; s[i - dp[i - 1] - 1] == '('){ dp[i] = dp[i - 1] + 2; if(i - dp[i - 1] - 2 &gt;= 0) dp[i] += dp[i -dp[i - 1] - 2]; } res = res &lt; dp[i] ? dp[i] : res; } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-31.下一个排列","slug":"LeetCode刷题-31-下一个排列","date":"2020-06-25T10:37:25.000Z","updated":"2021-02-06T14:29:10.719Z","comments":true,"path":"posts/17783.html","link":"","permalink":"https://www.itnxd.cn/posts/17783.html","excerpt":"","text":"题目链接：31.下一个排列 ¶题解： 手动实现全排列函数，有点巧妙！ ¶题目简述： 给定一个序列，计算出按照字典序的下一组更大的排列！ ¶题解一： 直接调用algorithm头文件里的next_permutation即可！ 当然，本题意在让你自己实现，而不是调用库函数，题解二将进行手动实现。 ¶AC代码一： 123456class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { next_permutation(nums.begin(), nums.end()); }}; ¶题解二： 思路： 从后向前找一个降序序列，该序列的第一个元素为最大值，找到当前序列的上一个元素，即非降序位置。 从后面的降序序列找一个比当前非降序位置值大的最小元素，交换二者位置。 将降序序列倒序 简图如下： 我的简单理解与解释： 后面是一个降序序列，要想找到下一个字典序，必须找到降序的上一个非降序的位置，因为降序序列的位置是不能动的，该降序序列已经到了字典序的最大值，要动也是前一个位置进行变大。 变多大呢？ 当然是变一个比当前值大的，而且是大的中的最小值，然后后面从小到大排列，像是加法的进位一样！ ¶AC代码二： 123456789101112131415class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { int k = nums.size() - 1; while(k &gt; 0 &amp;&amp; nums[k - 1] &gt;= nums[k]) k--; if(k &lt;= 0){ reverse(nums.begin(), nums.end()); }else{ int t = k; while(t &lt; nums.size() &amp;&amp; nums[t] &gt; nums[k - 1]) t++; swap(nums[t - 1], nums[k - 1]); reverse(nums.begin() + k, nums.end()); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"全排列","slug":"全排列","permalink":"https://www.itnxd.cn/tags/%E5%85%A8%E6%8E%92%E5%88%97/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-30.串联所有单词的子串","slug":"LeetCode刷题-30-串联所有单词的子串","date":"2020-06-22T08:37:11.000Z","updated":"2020-06-22T10:21:00.426Z","comments":true,"path":"posts/49123.html","link":"","permalink":"https://www.itnxd.cn/posts/49123.html","excerpt":"","text":"题目链接：30.串联所有单词的子串 ¶题解： 嗯，有点难度，使用哈希表和分类的思想！ ¶题目简述： 给定一个字符串，一个字符串数组，从字符串中找出可以包含字符串数组左右元素的起始位置！ ¶题解： 暴力：不推荐 这里直接采用高效率的算法： 预先规定： n = s.size(), m = words.size(), w = words[0].size(); 使用分类思想： 本题可以划分为w类，如下图所示： 可以发现，可以把起点分为0 - w-1的w组，你会惊奇的发现，起点从w-1往后，都已经被前面的情况所包括了！ 而且，我们扫描时按单词的长度w往后走，即每个单词一定落在坑里！ 具体做法： 使用一个哈希表tot记录words数组中单词出现的数量，使用另个一个哈希表wd 动态 记录选定区间的单词数量。 当两个哈希表单词和数量对应相等时即匹配了一组，继续后续匹配。 怎样处理两个哈希表是否一致，暴力，复杂度太高，所以使用一个 动态 变量cnt，用来统计两个容器对应的个数！ 当cnt == m时，即为找到了一组合法区间。 如何动态维护wd哈希表？ 如果当前处理个数不到m，即j &lt; i + m * w，则不需要进行哈希表的左端删除，只进行有端的添加，将当前单词substr(j, w)截取出来，wd[word]++进行统计： 若统计完以后，发现当前单词个数比需要的数量&gt;= tot[word]，则说明当前单词不在tot中，不需要统计 否则，说明当前单词在tot容器中，cnt++ 如果当前处理个数大于等于m个，即j &gt;= i + m * w，则需要进行左端的删除和有端的添加，动态维护wd容器为m个单词。截取substr(j - m * w, w)第一个单词，wd[word]--进行统计： 若统计完以后，发现当前单词个数比需要的数量tot[word]要少，说明当前单词删除有效，删的在tot中，cnt-- 否则说明，删除了一个不在tot中的单词，无序处理cnt 进行有端的添加，和第一步一样操作一模一样。 匹配条件：cnt == m即两个哈希表匹配成功，找到了一组合法区间一一对应，起始下标为j - (m - 1) * w 下标图解如下： 时间复杂度： 小区间个数为n / w，一共分为了w类，哈希表的插入删除复杂度为word长度w，总时间复杂度为O(n / w * w * w) = O(n * w) 进一步优化： 使用字符串哈希，可以将哈希表的插入删除降到O(1)，总时间复杂度降为O(n)。奈何没有学到，今后再学习，进行补充！ ¶AC代码： 123456789101112131415161718192021222324252627class Solution {public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) { vector&lt;int&gt; res; if(words.empty()) return res; int n = s.size(), m = words.size(), w = words[0].size(); unordered_map&lt;string, int&gt; tot; for(auto&amp; word : words) tot[word]++; for(int i = 0; i &lt; w; i++){ unordered_map&lt;string, int&gt; wd; int cnt = 0; for(int j = i; j + w &lt;= n; j += w){ if(j &gt;= i + m * w){ auto word = s.substr(j - m * w, w); wd[word]--; if(wd[word] &lt; tot[word]) cnt--; } auto word = s.substr(j, w); wd[word]++; if(wd[word] &lt;= tot[word]) cnt++; if(cnt == m) res.push_back(j - (m - 1) * w); } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-29.两数相除","slug":"LeetCode刷题-29-两数相除","date":"2020-06-22T08:36:25.000Z","updated":"2020-06-22T10:21:00.419Z","comments":true,"path":"posts/6904.html","link":"","permalink":"https://www.itnxd.cn/posts/6904.html","excerpt":"","text":"题目链接：29.两数相除 ¶题解： 嗯，倍增思想的应用！ ¶题目简述： 给定两个int范围的数相除，要求不使用乘除法和取余计算得到结果！ ¶题解一：暴力 不能使用乘除就使用减法，一直减去除数直到减到负数即可！ 当然这样会超时，例如输入：2147483647 和 1 ，此时的数量级是10的9次方的，妥妥超时！ 超出int范围，统一返回INT_MAX 正确做法：请看题解二，使用倍增思想！ ¶TLE代码： 12345678910111213class Solution {public: int divide(int dividend, int divisor) { long long res = 0, k = 1; if((dividend &lt; 0 &amp;&amp; divisor &gt; 0) || (dividend &gt; 0 &amp;&amp; divisor &lt; 0)) k = -1; long long dividend1 = abs(dividend), divisor1 = abs(divisor); while(dividend1 - divisor1 &gt;= 0){ res ++; dividend1 -= divisor1; } return k == 1 ? (res &gt; INT_MAX ? INT_MAX : res) : (-res &lt; INT_MIN ? INT_MAX : -res); }}; ¶题解二：倍增 一个一个减岂不是有点笨？ 那么我们就每次尽可能多的去减！ a / b = k 先预处理出来，1 * b 2 * b 4 * b 8 * b...... k * b 然后倒着去减，从大到小减，直到剩下的不够减的大小，即终止！ 第一次减去 k * b，若足够大，继续向后去减！ 由于我们的答案求得是k的和，而不是k * b的和，所以我们要将每次减去的k累积起来！ k 的取值：1 2 4 8 16..... 即 2^0 2^1 2^2 2^3 2^4 ......2^k 所以每次给res累积1ll &lt;&lt; i;即可！ 注意： 1ll：防止越界，转化为ll类型。例如i = 31就会发生越界 开始时将其全部转化为正数进行计算，最后再转换回来 使用abs()也要使用LL强转，防止越界 如果res最后越界，统一返回INT_MAX ¶AC代码： 12345678910111213141516171819202122class Solution {public: int divide(int x, int y) { typedef long long LL; LL res = 0, k = 1; if(x &lt; 0 &amp;&amp; y &gt; 0 || x &gt; 0 &amp;&amp; y &lt; 0) k = -1; LL a = abs((LL)x), b = abs((LL)y); vector&lt;LL&gt; p; for(LL i = b; i &lt;= a; i += i) p.push_back(i), cout &lt;&lt; i &lt;&lt; endl; for(int i = p.size() - 1; i &gt;= 0; i--){ if(p[i] &lt;= a){ res += 1ll &lt;&lt; i; a -= p[i]; } } if(k == -1) res = -res; if(res &lt; INT_MIN || res &gt; INT_MAX) res = INT_MAX; return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"倍增","slug":"倍增","permalink":"https://www.itnxd.cn/tags/%E5%80%8D%E5%A2%9E/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-28.实现strStr()","slug":"LeetCode刷题-28-实现strStr","date":"2020-06-21T15:13:02.000Z","updated":"2021-02-06T14:28:42.332Z","comments":true,"path":"posts/45773.html","link":"","permalink":"https://www.itnxd.cn/posts/45773.html","excerpt":"","text":"题目链接：28.实现strStr() ¶题解： 嗯，使用暴力就是简单题！ 提高效率使用KMP，复杂了，好好理解，多实现，最好记住模板！本题就是一个模板。 ¶题目简述： 给定两个字符串，从第一个中找第二个串，能找到返回起始下标，找不到返回-1，第二个串为空，直接返回0。 ¶题解一：暴力 直接扫描一遍原串即可： 先判断当前位置是否够子串的长度，不够直接返回-1，因为肯定没有可以匹配的。 如果位置长度够，就从当前位置截取和子串长度相同，查看是否相等，相等直接返回当前下标i，否则继续下次循环 时间复杂度：substr(pos, m)：复杂度为O(len)，总时间复杂度为O(n*m) ¶AC代码一： 123456789101112131415161718192021222324class Solution {public: int strStr(string haystack, string needle) { if(needle.empty()) return 0; for(int i = 0; i &lt; haystack.size(); i++){ if(haystack.size() - i &lt; needle.size()) return -1; if(haystack.substr(i, needle.size()) == needle) return i; } return -1; }};// 改一下这样可能更好。class Solution {public: int strStr(string haystack, string needle) { if(needle.empty()) return 0; for(int i = 0; haystack.size() - i &gt;= needle.size(); i++) if(haystack.substr(i, needle.size()) == needle) return i; return -1; }}; ¶题解二：KMP 为了弄明白KMP算法，我也是盯着看，画着图搞了一上午！ 这也是一个模板题，需要记下来并掌握代码的实现及理解该算法的运行流程！ 时间复杂度： O(n + m) 为了方便，这里将字符串都从1开始！ 1s = \" \" + s, p = \" \" + p; KMP算法的核心就是一个next数组： next数组的作用：若没有该数组，后续匹配过程中出现不匹配的话，需要将起始位置后移一位，重新开始一一匹配，但是有了该数组，就不一定是移动一位了，而是移动尽可能多的位置，使得前j个字符和原串仍然匹配，只需判断第j + 1个字符即可！ 首先搞清楚next数组存储的东西是什么？ next[i]： 所有s[1]-s[i]中前缀等于后缀的最大长度（特指非平凡前缀和后缀） 非平凡：指的是不包括自己，eg：abc中的next[3]不能为3，应该为0。 举个例子： 举个例子：abcdefghabcd中，next[12]就应该为4，即前缀和后缀相等的最大长度，为前缀abcd和后缀abcd匹配时的值。 下一个问题，怎么求next数组？ 首先，next[0]不需要管，下标从1开始，next[1] = 0，非平凡不包括自己！ 从下标为2开始即可！ 假设当前状态如下：i - 1为原串p指向的位置，j为p的前缀后缀相等时前缀的尾。序号1和序号2是同一段，序号3是原串1 ~ (i - 1)中与前缀相等的后缀，此时序号1，2，3都是相等的。 若 i 和 j + 1可以匹配，此时next[i]就会由j变为j + 1，则效果图如下： 若 i 和 j + 1无法匹配，则说明前缀串1 ~ j无法满足当前next[i]的条件，此时j的位置就需要发生变化，将前缀缩小为1 ~ next[j]去试探此时是否可以匹配next[i]的条件，若一直无法匹配，已经到了next[1] = 0或j == 0时，仍然无法匹配，则当前next[i] = 0；若试探中，某次可以匹配，则当前next[i]的值就可以更新为当前next[j] + 1 会发现后面的next计算都在前面已经算出来的基础上进行试探的，而前面算出来的都是前后缀相等且最长的，所以这样可以求得所有next数组的值，且一定是正确的！ 下一个问题，怎么求子串与原串的匹配并计算得到起始下标？ 和求解next数组一样，求解next数组是用的两个待匹配字符串p，求下面这个问题则只需要将第一个串换成s串即可，最后只需要判断什么时候等于待匹配字符串的长度，直接计算返回该下标即可！ 什么时候就算找到了？ 当然是当j == m的时候，即说明此时已经匹配完了p串。 最终返回的长度就是i - m，即s串的匹配终点的前m个字符的位置，应该为i - m + 1，但是我们下标是从1开始，所以要减去1，i - m + 1 - 1即i - m。 注意：需要特判p串为空的情况，需要返回0。 ¶AC代码二： 123456789101112131415161718192021class Solution {public: int strStr(string s, string p) { if(p.empty()) return 0; int n = s.size(), m = p.size(); s = \" \" + s, p = \" \" + p; vector&lt;int&gt; next(m + 1); for (int i = 2, j = 0; i &lt;= m; i ++){ while(j &amp;&amp; p[i] != p[j + 1]) j = next[j]; if(p[i] == p[j + 1]) j ++; next[i] = j; } for (int i = 1, j = 0; i &lt;= n; i ++){ while(j &amp;&amp; s[i] != p[j + 1]) j = next[j]; if(s[i] == p[j + 1]) j ++; if(j == m) return i - m; } return -1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://www.itnxd.cn/tags/KMP/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-27.移除元素","slug":"LeetCode刷题-27-移除元素","date":"2020-06-21T15:11:51.000Z","updated":"2021-02-06T14:29:29.371Z","comments":true,"path":"posts/37226.html","link":"","permalink":"https://www.itnxd.cn/posts/37226.html","excerpt":"","text":"题目链接：27.移除元素 ¶题解： 简单题，两行代码！ ¶题目简述： 去除数组中值等于val的数，并返回去掉后的长度。 ¶题解： 同样使用双指针，一个指针i指向数组当前扫描位置，一个指针k指向当前新数组的下一个元素，遇到和val值相等的，直接跳过即可！ ¶AC代码： 123456789class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int k = 0; for(int i = 0; i &lt; nums.size(); i++) if (nums[i] != val) nums[k++] = nums[i]; return k; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-26.删除排序数组中的重复项","slug":"LeetCode刷题-26-删除排序数组中的重复项","date":"2020-06-21T15:11:20.000Z","updated":"2020-06-22T06:15:32.490Z","comments":true,"path":"posts/20075.html","link":"","permalink":"https://www.itnxd.cn/posts/20075.html","excerpt":"","text":"题目链接：26.删除排序数组中的重复项 ¶题解： 嗯，简单题。 ¶题目简述： 删除有序数组长度重复项，返回不重复元素的长度！ ¶题解： 用两个指针一个指针t指向不重复元素的末尾，一个指针i指向当前扫描的位置，如果当前扫描位置和不重复元素的末尾相同，则继续后移，找到不一样的插到不重复元素的下一个位置。 最后返回长度，此处t指向下标，长度为t + 1. 注意：这样写需要特判nums为空的情况！ ¶AC代码： 12345678910111213141516171819202122232425class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return 0; int t = 0; for(int i = 0; i &lt; nums.size();){ while(i &lt; nums.size() &amp;&amp; nums[i] == nums[t]) i++; if(i &lt; nums.size()) nums[++t] = nums[i]; } return t + 1; }};// 这样一写，更加简洁：class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return 0; int t = 0; for(int i = 0; i &lt; nums.size(); i++) if(nums[i] ！= nums[t]) nums[++t] = nums[i]; return t + 1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%BB%84/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-25.K个一组翻转链表","slug":"LeetCode刷题-25-K个一组翻转链表","date":"2020-06-21T13:24:47.000Z","updated":"2021-02-06T14:26:13.396Z","comments":true,"path":"posts/42577.html","link":"","permalink":"https://www.itnxd.cn/posts/42577.html","excerpt":"","text":"题目链接：25.K个一组翻转链表 ¶题解： 两两一组升级为 k 个一组！ 参考上一篇两两一组的解法，基本一致！ ¶题目简述： 给定一个链表，k个一组进行倒序反转！ ¶题解一：我的 --&gt; 乱 嗯，不推荐看这个，虽然我自己写的也AC了，但是着实有点乱，有点多，不条理。非常建议直接看题解二：更加清晰！ 接下来介绍一下我的乱乱的思路： 特判一下k为1的情况，直接返回即可 先通过pt指针循环找到第k个节点。用b指针指向第k个节点。用a指针指向第一个节点。（如果存在） 如果不够第k个节点，直接返回。 用t指向第二个节点， p指向第k个节点b 使用循环将第二个节点到第k个节点全部反向指一下。 使用s指针指向第k个节点到第二个节点。 使用b来反向连接 t-&gt;next = a：第二个指向第一个 p = a：p指向a 。。。。其实画个图还是很明白的，我懒得画了，毕竟有点乱！ 强烈建议看题解二！ ¶AC代码一：（复杂，不调理，易错） 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseKGroup(ListNode* head, int k) { if(k == 1) return head; auto dummy = new ListNode(-1), p = dummy; dummy-&gt;next = head; bool ok = true; while(1){ ListNode* a, *b; ListNode* t, *pt = p; bool ok = true; for(int i = 0; i &lt; k; i++){ if(i == 0 &amp;&amp; pt-&gt;next) a = pt-&gt;next; if(pt-&gt;next) pt = pt-&gt;next, b = pt; else{ ok = false; break; } } if(!ok) break; p-&gt;next = b; t = a-&gt;next; a-&gt;next = b-&gt;next; for(int j = 0; j &lt; k - 2; j++){ auto s = t; for(int i = 0; i &lt; k - j - 3; i++) s = s-&gt;next; b-&gt;next = s; b = s; } t-&gt;next = a; p = a; } return dummy-&gt;next; }}; ¶题解二：别人的 --&gt; 清晰 同样：和两个一组反转类似，同样使用a、b指向第一个和第二个，多了一个c指向第三个，防止找不到下一个。 使用q来判断存不存在第k个节点。 内部的for循环用来将第1个到第k个节点反转链接。a、b顺次后移，如下图的第一二步： 然后让p指向第k个节点a，让外部的c（始终指向第一个节点，即转换后的最后一个节点）指向第k个节点的下一个，即下一组的开始。然后p节点后移，指向下一组节点的上一个节点c 具体如图所示：看图更易于理解！ ¶AC代码二：（清晰） 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseKGroup(ListNode* head, int k) { auto dummy = new ListNode(-1), p = dummy; dummy-&gt;next = head; while(p){ auto q = p; for(int i = 0; i &lt; k &amp;&amp; q; i++) q = q-&gt;next; if(!q) break; auto a = p-&gt;next, b = a-&gt;next; for(int i = 0; i &lt; k - 1; i++){ auto c = b-&gt;next; b-&gt;next = a; a= b, b = c; } auto c = p-&gt;next; p-&gt;next = a, c-&gt;next = b; p = c; } return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-24.两两交换链表中的节点","slug":"LeetCode刷题-24-两两交换链表中的节点","date":"2020-06-21T13:14:13.000Z","updated":"2020-06-22T06:15:32.485Z","comments":true,"path":"posts/28774.html","link":"","permalink":"https://www.itnxd.cn/posts/28774.html","excerpt":"","text":"题目链接：24.两两交换链表中的节点 ¶题解： 链表的指针切换问题！ ¶题目简述： 给定一个链表，两两相邻的做一下交换。 ¶我的错误题解： 我的代码如下： l指向 2 再指向 1 ，此时2到3已经断了，会发现1和2已经成环了，会形成死循环！ 我看了好久，都没发现2到3已经断了，还以为head-&gt;next-&gt;next为3了，懵逼了！ 以此为戒：做链表题一定要画好图，看清哪里断了，哪里没断！ ¶错误代码： 1234567891011121314151617181920/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { auto dummy = new ListNode(-1), l = dummy; while(head){ l-&gt;next = head-&gt;next; l = head-&gt;next; l-&gt;next = head; l = head; head = head-&gt;next-&gt;next; } return dummy-&gt;next; }}; ¶题解： 使用两个指针，（类似双指针解法），一个指向带翻转的第一个，一个指向第二个。如下图： 第二步一定要在第三步之前，否则下一个节点就找不到了！ p永远指向下一组节点的上一个节点，a、b永远指向下一组节点。 要严格保证后面有两个节点或以上才可以，p-&gt;next &amp;&amp; p-&gt;next-&gt;next，即这两个节点非空！ ¶AC代码： 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { auto dummy = new ListNode(-1), p = dummy; dummy-&gt;next = head; while(p-&gt;next &amp;&amp; p-&gt;next-&gt;next){ auto a = p-&gt;next, b = a-&gt;next; p-&gt;next = b; a-&gt;next = b-&gt;next; b-&gt;next = a; p = a; } return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-23.合并K个排序链表","slug":"LeetCode刷题-23-合并K个排序链表","date":"2020-06-21T11:56:39.000Z","updated":"2020-06-22T06:15:32.477Z","comments":true,"path":"posts/57955.html","link":"","permalink":"https://www.itnxd.cn/posts/57955.html","excerpt":"","text":"题目链接：23.合并K个排序链表 ¶题解： 由二路归并变为k路归并，有优化的地方的！ ¶题目简述： k个有序链表，合并生成一个有序链表。 ¶题解一：低效率（我的） 嗯，暴力去扫描每个最小值！ 具体： mint：记录当前最小的节点。 minv：记录当前最小节点所在的链表的下标 特判一下当前链表是否为空，是的话直接跳过。 如果能找到最小值，即minv != -1，则更新当前链表即最小值所在链表！ 找不到最小值直接退出 时间复杂度：假设链表数组个数为 N，扫描每个最小值都要N次，所有链表元素为M的话，最终时间复杂度为 O(N*M) 欢迎查看题解二：使用堆优化！ ¶AC代码一： 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { auto dummy = new ListNode(-1), p = dummy; while(1){ auto mint = new ListNode(INT_MAX); int minv = -1; for(int i = 0; i &lt; lists.size(); i++){ if(!lists[i]) continue; if(mint-&gt;val &gt; lists[i]-&gt;val){ mint = lists[i]; minv = i; } } if(minv != -1) { p-&gt;next = mint; p = p-&gt;next; lists[minv] = lists[minv]-&gt;next; } else break; } return dummy-&gt;next; }}; ¶题解二：高效率（别人的） 查找最小值可以使用堆来进行优化，将查询的时间复杂度从O(N)降到O(logN)，整体时间复杂度为O(M*logN) 堆，即使用优先队列priority_queue： 先将每个序列的头结点插入堆，（如果存在） 然后去取堆顶元素，直到去完（即最小值都已查找了一遍），若当前最小值有后继结点，则将其插入堆中。 由于使用的是priority_queue&lt;ListNode*&gt;类型，所以需要重载小括号： return a-&gt;val &lt; b-&gt;val：即默认的降序 return a-&gt;val &gt; b-&gt;val：即升序 特殊之处：priority_queue的排序函数不是函数，是一个结构体，需要这样来写： 12345struct Cmp{ bool operator() (ListNode* a, ListNode* b){ return a-&gt;val &gt; b-&gt;val; }}; ¶AC代码二： 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: struct Cmp{ bool operator() (ListNode* a, ListNode* b){ return a-&gt;val &gt; b-&gt;val; } }; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Cmp&gt; heap; auto dummy = new ListNode(-1), p = dummy; for(auto l : lists) if(l) heap.push(l); while(heap.size()){ auto t = heap.top(); heap.pop(); p-&gt;next = t; p = p-&gt;next; if(t-&gt;next) heap.push(t-&gt;next); } return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://www.itnxd.cn/tags/%E5%A0%86/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"},{"name":"k路归并","slug":"k路归并","permalink":"https://www.itnxd.cn/tags/k%E8%B7%AF%E5%BD%92%E5%B9%B6/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-22.括号生成","slug":"LeetCode刷题-22-括号生成","date":"2020-06-21T11:56:10.000Z","updated":"2020-06-22T06:15:32.481Z","comments":true,"path":"posts/51962.html","link":"","permalink":"https://www.itnxd.cn/posts/51962.html","excerpt":"","text":"题目链接：22.括号生成 ¶题解： 简单的递归问题，会在题解二给出一个关于括号匹配的结论！非常重要！ ¶题目简述： 给定一个n，找到所有n组括号有效可匹配的情况。 ¶题解一：低效率（我的） 很明显：直接使用DFS即可！ void dfs(int l, int r, int n, string path) l：记录左括号使用数 r：记录右括号使用数 n：记录括号组数 path：记录当前情况的括号组合 bool isMatch(string str)：判断当前括号序列是否是有效匹配 这里我使用了dfs(1, 0, n, \"(\")作为入口，即可以排除)开头的不可能匹配序列！虽然优化了一点点，但是还是请看题解二！ 退出条件 ：l == n &amp;&amp; r == n，即左右括号都已经使用够了n个。 这样有一个麻烦：由于这样会生成一个全排列，每次都需要判断是否是合法的括号序列，浪费了许多时间。所以请查看题解二解决这个麻烦！ ¶AC代码一： 12345678910111213141516171819202122232425class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; generateParenthesis(int n) { dfs(1, 0, n, \"(\"); return res; } void dfs(int l, int r, int n, string path){ if(l == n &amp;&amp; r == n){ if(isMatch(path)) res.push_back(path); return; } if(l &lt; n) dfs(l + 1, r, n, path + '('); if(r &lt; n) dfs(l, r + 1, n, path + ')'); } bool isMatch(string str){ stack&lt;char&gt; stk; for(int i = 0; i &lt; str.size(); i++){ if(stk.empty() &amp;&amp; str[i] == ')') return false; if(str[i] == '(') stk.push('('); if(str[i] == ')' &amp;&amp; stk.top() == '(') stk.pop(); } return stk.empty(); }}; ¶题解二：高效率（别人的） 括号匹配问题的充要条件：（只有一种括号） 任意前缀中(数量大于等于)数量 左右括号数量相等 这个结论想想就知道是成立的！反证法肯定无法匹配！ 第二个条件本题默认满足（都是 n ），所以只要满足第一个条件即可！ 所以本题即变成了这样： 左括号直接使用 右括号要满足第一个条件r &lt; l，可不是r &lt;= l，即当前右括号还没有使用。 假如本题问的是匹配的数量：可以直接使用公式计算即可： n 组括号 可以构成 C 2nn / (n + 1) 个有效匹配序列！和卡特兰数有关！ ¶AC代码二： 12345678910111213141516class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; generateParenthesis(int n) { dfs(0, 0, n, \"\"); return res; } void dfs(int l, int r, int n, string path){ if(l == n &amp;&amp; r == n){ res.push_back(path); }else{ if(l &lt; n) dfs(l + 1, r, n, path + '('); if(r &lt; n &amp;&amp; r &lt; l) dfs(l, r + 1, n, path + ')'); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-21.合并两个有序链表","slug":"LeetCode刷题-21-合并两个有序链表","date":"2020-06-21T11:55:40.000Z","updated":"2020-06-22T06:15:32.473Z","comments":true,"path":"posts/12870.html","link":"","permalink":"https://www.itnxd.cn/posts/12870.html","excerpt":"","text":"题目链接：21.合并两个有序链表 ¶题解： 经典的二路归并算法，温习一下吧！ ¶题目简述： 给定两个有序链表，合并为一个有序链表！ ¶题解： 二路归并：由于原序列都是有序的，所以每次选取头部的最小值即可将所有节点按从小到大排好。 嗯，不需要做过多解释！ 和数组不一样的一点 ：最后某个链表非空时，可以直接指针指向非空链表的头结点即可，数组还需要进行循环去一个一个链接。 ¶AC代码： 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { auto dummy = new ListNode(-1), l = dummy; while(l1 &amp;&amp; l2){ if(l1-&gt;val &lt; l2-&gt;val) l-&gt;next = l1, l = l1, l1 = l1-&gt;next; else l-&gt;next = l2, l = l2, l2 = l2-&gt;next; } if(l1) l-&gt;next = l1; if(l2) l-&gt;next = l2; return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"},{"name":"二路归并","slug":"二路归并","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-20.有效的括号","slug":"LeetCode刷题-20-有效的括号","date":"2020-06-19T14:43:38.000Z","updated":"2020-06-19T15:07:27.252Z","comments":true,"path":"posts/15525.html","link":"","permalink":"https://www.itnxd.cn/posts/15525.html","excerpt":"","text":"题目链接：20.有效的括号 ¶题解： 嗯，经典的栈的应用，括号匹配！ ¶题目简述： 给定一堆大中小括号，询问是否能完整匹配！ ¶题解一： 就是经典括号匹配，具体细节自己想想就明白了！ 具体思想： 左括号直接入栈 右括号先判断是不是栈空，栈空则无法匹配返回false，不空则和当前栈顶进行匹配，匹配了直接从栈中弹出，否则直接返回false 最后判断栈是否为空，不为空这说明无法完成匹配，直接返回false，其他情况返回true ¶AC代码一： 1234567891011121314151617class Solution {public: bool isValid(string s) { stack&lt;char&gt; stk; for(int i = 0; i &lt; s.size(); i++){ if(stk.empty() &amp;&amp; (s[i] == ')' || s[i] == ']' || s[i] == '}')) return false; if(s[i] == '(') stk.push('('); else if(s[i] == ')' &amp;&amp; stk.top() == '(') stk.pop(); else if(s[i] == '[') stk.push('['); else if(s[i] == ']' &amp;&amp; stk.top() == '[') stk.pop(); else if(s[i] == '{') stk.push('{'); else if(s[i] == '}' &amp;&amp; stk.top() == '{') stk.pop(); else return false; } return stk.empty(); }}; ¶题解二： 嗯，题解一是我写的，是不是看起来有点臃肿，是的！ 所以接下来看一下 伟大的 y总这偷工减料的优质写法！ 实现原理： 判断是否匹配做了改进，由于差ASCII码表可以知道，匹配的括号的ASCII码值最多相差2， 所以匹配的写法可以简化为abs(stk.top() - c) &lt;= 2 真。。。会玩，优秀的 y总！ ¶AC代码二： 123456789101112131415class Solution {public: bool isValid(string s) { stack&lt;char&gt; stk; // y总的偷工减料做法！ for(auto c : s){ if(c == '(' || c == '[' || c == '{') stk.push(c); else{ if(!stk.empty() &amp;&amp; abs(stk.top() - c) &lt;= 2) stk.pop(); else return false; } } return stk.empty(); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-19.删除链表的倒数第N个节点","slug":"LeetCode刷题-19-删除链表的倒数第N个节点","date":"2020-06-19T14:33:24.000Z","updated":"2020-06-19T15:01:38.018Z","comments":true,"path":"posts/29380.html","link":"","permalink":"https://www.itnxd.cn/posts/29380.html","excerpt":"","text":"题目链接：19.删除链表的倒数第N个节点 ¶题解： 链表的基本操作！ ¶题目简述： 如题，删除链表倒数第n个节点！ ¶题解： 题目说，要使用一遍扫描解决？？？我想了想，这是不可能的，最起码都得两遍。。。 或许人家是说O(N)的时间复杂度。。。 具体做法： 同样使用一个虚拟节点 值为-1做头节点，便于操作 先计算节点总数，包括虚拟的节点 然后计算一下应该循环到哪里进行删除（即要找到要删元素的上一个元素进行删除） 如 1-&gt;2-&gt;3-&gt;4-&gt;5删除倒数第二个，加了一个虚拟节点，所以现在应该为 -1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5，即下标要遍历到总结点数-倒数的数-1，即k - n - 1即可，这时，p指向要删的倒数第n个节点的上一个节点 这时，直接p-&gt;next = p-&gt;next-&gt;next;，删除完毕！ 返回dummy-&gt;next ¶AC代码： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { // ListNode* dummy = new ListNode(-1); auto dummy = new ListNode(-1); dummy-&gt;next = head; int k = 0; for(auto p = dummy; p; p = p-&gt;next) k++; auto p = dummy; for(int i = 0; i &lt; k - n - 1; i++) p = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-18.四数之和","slug":"LeetCode刷题-18-四数之和","date":"2020-06-19T14:25:18.000Z","updated":"2020-06-19T15:07:20.014Z","comments":true,"path":"posts/4066.html","link":"","permalink":"https://www.itnxd.cn/posts/4066.html","excerpt":"","text":"题目链接：18.四数之和 ¶题解： 又是使用双指针的题，双指针可以将复杂度降低一维！ 这道题和LeetCode的第15题完全一样！我的第15题链接 ¶题目简述： 给定一个nums数组，需要求出所有相加为target的四元组，并且要求不包含重复四元组！ ¶题解： 当然可以使用暴力，嗯，，四重循环，没试过，可能会超时！ 使用呢双指针将四维降到三维度，固定前两个数，后两个数使用双指针移动！ 题解：参考我写的LeetCode第15题的题解。具体做法，判重，注意事项，完全一样！ 时间复杂度： 第一层循环O(N)，第二层O(N)，第三层看似O(N ^ 2)，实则l和r各最多扫描N次，所以最终复杂度为O(N ^ 3) ¶AC代码： 123456789101112131415161718192021class Solution {public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size(); i ++){ if(i &amp;&amp; nums[i] == nums[i - 1]) continue; for(int j = i + 1; j &lt; nums.size(); j ++){ if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; for(int l = j + 1, r = nums.size() - 1; l &lt; r; l ++){ if(l &gt; j + 1 &amp;&amp; nums[l] == nums[l - 1]) continue; while(l &lt; r - 1 &amp;&amp; nums[i] + nums[j] + nums[l] + nums[r] &gt; target) r --; if(nums[i] + nums[j] + nums[l] + nums[r] == target){ res.push_back({nums[i], nums[j], nums[l], nums[r]}); } } } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-17.电话号码的字母组合","slug":"LeetCode刷题-17-电话号码的字母组合","date":"2020-06-19T14:13:39.000Z","updated":"2020-06-19T15:01:38.008Z","comments":true,"path":"posts/24700.html","link":"","permalink":"https://www.itnxd.cn/posts/24700.html","excerpt":"","text":"题目链接：17.电话号码的字母组合 ¶题解： 嗯，，一道经典的递归问题，简单！ ¶题目简述： 有一个电话，九键，和手机键盘一样，都有3-4个字母，要求按了几个数字后，要将所有组合全排列输出！ ¶题解： 定义函数dfs(string digits, int u, string path) digits：输入的按键 u：表示当前处理到第几个按键 path：表示当前处理了的按键构成的组合 递归终止条件：u == digits.size()，即每个数字都已经取了一个字母 递归过程：每个u的位置去循环每一个字母，dfs(digits, u + 1, path + c); 这个最简单的递归过程会将全排列都走一遍的！ 注意： 需要特判输入为空的情况，应该直接返回，否则会返回一个带有\"\"元素的数组。 ¶AC代码： 12345678910111213141516171819class Solution {public: string str[10] = { \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" }; vector&lt;string&gt; res; vector&lt;string&gt; letterCombinations(string digits) { if(digits.empty()) return res; dfs(digits, 0, \"\"); return res; } void dfs(string digits, int u, string path){ if(u == digits.size()) res.push_back(path); else{ for(auto c : str[digits[u] - '0']) dfs(digits, u + 1, path + c); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-16.最接近的三数之和","slug":"LeetCode刷题-16-最接近的三数之和","date":"2020-06-19T13:54:22.000Z","updated":"2020-06-19T15:06:25.064Z","comments":true,"path":"posts/14896.html","link":"","permalink":"https://www.itnxd.cn/posts/14896.html","excerpt":"","text":"题目链接：16.最接近的三数之和 ¶题解： 嗯，也是双指针，和LeetCode的第15题（也就是我的上一篇文章的题解基本类似）。 ¶题目简述： 上一题求三数字和为0， 这一题求三数之和最接近！ ¶题解： 和上一题类似，求为0的三元组每次只有一种情况，即nums[i] + nums[j] + nums[k] 但是求最接近则有两种（左和右）：nums[i] + nums[j] + nums[k] - target，nums[i] + nums[j] + nums[k + 1] - target 思路是一样的，同样是双指针！思路见上一篇题解，即第15题 三数之和！ 本题此题不需要去重，最终结果也只有一个！ 同样需要排序！ 不同之处： nums[i] + nums[j] + nums[k] &gt; target时，就k--，找到最接近的位置 若k + 1没有超界，则计算一下nums[i] + nums[j] + nums[k + 1]的情况（右边） 还有左边的情况（一定不会超界） 使用minv更新与目标值相差最小的差值，即最接近值，若minv发生了更新，则更新res的值为差值较小的一方。 初始值minv，t1，t2都初始化为极大值INT_MAX。 注意： 差值计算需要使用绝对值abs()，同样while内的条件j &lt; k - 1也得保证k--不会越界。 ¶AC代码： 12345678910111213141516171819202122class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int res = 0, minv = INT_MAX; for(int i = 0; i &lt; nums.size(); i++){ for(int j = i + 1, k = nums.size() - 1; j &lt; k; j++){ while(j &lt; k - 1 &amp;&amp; nums[i] + nums[j] + nums[k] &gt; target) k--; int t1 = INT_MAX, t2 = INT_MAX; t1 = abs(nums[i] + nums[j] + nums[k] - target); if(k + 1 &lt; nums.size()) t2 = abs(nums[i] + nums[j] + nums[k + 1] - target); if(minv &gt; min(t1, t2)){ minv = t1 &lt; t2 ? t1 : t2; res = t1 &lt; t2 ? nums[i] + nums[j] + nums[k] : nums[i] + nums[j] + nums[k + 1]; } } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-15.三数之和","slug":"LeetCode刷题-15-三数之和","date":"2020-06-19T12:53:48.000Z","updated":"2020-06-19T15:01:37.997Z","comments":true,"path":"posts/55831.html","link":"","permalink":"https://www.itnxd.cn/posts/55831.html","excerpt":"","text":"题目链接：15.三数之和 ¶题解： 又是使用双指针的题，双指针可以将复杂度降低一维！ 这道题和LeetCode后面的16、18题类似。 ¶题目简述： 给定一个nums数组，需要求出所有相加为零的三元组，并且要求不包含重复三元组！ ¶题解： 当然可以使用暴力，嗯，，三重循环，没试过，可能会超时！ 咱们有好的算法，就不去暴力求解！ 使用双指针，固定第一个数，后两个数使用双指针，可以将O(N ^ 3)的复杂度降到O(N ^ 2)，即使用双指针可以将维度降低一维！ 使用双指针的前提是序列得有序： 具体做法： 固定第一个数 第二个数 j 从 i + 1开始，k从 nums.size() - 1开始向内走 nums[i] + nums[j] + nums[k] &gt; 0三数之和大于0，k就一直--，直到找到&lt;= 0的位置，或者j与k相邻（即j = k - 1） 此时判断三数之和是不是0，是则push进去！ 此时以i和j为第一二个数的情况就找完了，继续第二个数的循环。 Tips： 由于数组有序，所以我们固定第一个数，嗯，第二个数也相当于固定，去滑动第三个数，直到最接近0的位置，然后去判断是否等于0，这样一定是对的！ 关于判重： 如果第一个数和下一个数重复，那么下一个数的情况和上一个数是完全一样的，不需要进行处理，continue即可！ eg：1111111-2， 第一个1的情况和第二个1以及后面的1的情况是完全相同的，可以直接跳过！ 也就是每次循环都要判断是否和上一个数相同，相同则跳过 注意： 要保证上一个元素下标不越界得保证i &gt; 0, j &gt; i + 1 注意： while 内的j &lt; k - 1的条件，要写对，防止下标越界，此处（j 和 k 的关系）最终退出条件为j == k - 1，即后两个数相邻！ 时间复杂度： 第一层循环O(N)，第二层看似O(N ^ 2)，实则j和k各最多扫描N次，所以最终复杂度为O(N ^ 2) ¶AC代码： 123456789101112131415161718class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size(); i++){ if(i &amp;&amp; nums[i] == nums[i - 1]) continue; for(int j = i + 1, k = nums.size() - 1; j &lt; k; j++){ if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; while(j &lt; k - 1 &amp;&amp; nums[i] + nums[j] + nums[k] &gt; 0) k--; if(nums[i] + nums[j] + nums[k] == 0){ res.push_back({nums[i], nums[j], nums[k]}); } } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-14.最长公共前缀","slug":"LeetCode刷题-14-最长公共前缀","date":"2020-06-19T12:45:43.000Z","updated":"2020-06-19T15:01:37.987Z","comments":true,"path":"posts/4096.html","link":"","permalink":"https://www.itnxd.cn/posts/4096.html","excerpt":"","text":"题目链接：14.最长公共前缀 ¶题解： 嗯，直接做就行，注意一点细节即可！ ¶题目简述： 给定一个字符串数组。求最长公共前缀！ ¶题解： 首先：以第一个字符串为基准，和其他字符串一一对应比较，都相同则继续后移，累加res；不同则直接返回之前已累积的公共前缀！ 一个注意点： 若其他字符串的长度小于当前第一个字符串的位置，则直接返回即可。 ¶AC代码： 1234567891011121314151617class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { string res = \"\"; if(strs.empty()) return res; for(int i = 0; i &lt; strs[0].size(); i++){ char c = strs[0][i]; for(int j = 0; j &lt; strs.size(); j++){ if(i &gt;= strs[j].size() || strs[j][i] != c){ return res; } } res += c; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-13.罗马数字转整数","slug":"LeetCode刷题-13-罗马数字转整数","date":"2020-06-19T12:13:17.000Z","updated":"2020-06-19T15:05:10.106Z","comments":true,"path":"posts/11911.html","link":"","permalink":"https://www.itnxd.cn/posts/11911.html","excerpt":"","text":"题目链接：13.罗马数字转整数 ¶题解： 和 12.整数转罗马数字类似，就是反过来问的！处理稍有不同！ ¶题目简述： 给出罗马数字，转化为普通数字！ 例如： “MCMXCIV” ------------&gt; 1994 ¶题解： 同样适用哈希表存储，不过与上一道题反着的，存储类型反着换了一下！ 首先从左到右搜索每一位罗马字符，能找到对应的字符就给value进行累加。 应该先按两个进行搜索，因为会出现这种情况\"MCMXCIV\" ，先按照一个字符搜，遇到CM应该处理为900，但是按照一个字母先走，会变成C + M，就变成了 1100。这是不对的。 先按照两个搜索，然后 i += 2，然后按照一个进行搜索i += 1. ¶AC代码： 12345678910111213141516171819202122232425class Solution {public: int romanToInt(string s) { unordered_map&lt;string, int&gt; hash; int value = 0; hash[\"I\"] = 1; hash[\"IV\"] = 4; hash[\"V\"] = 5; hash[\"IX\"] = 9; hash[\"X\"] = 10; hash[\"XL\"] = 40; hash[\"L\"] = 50; hash[\"XC\"] = 90; hash[\"C\"] = 100; hash[\"CD\"] = 400; hash[\"D\"] = 500; hash[\"CM\"] = 900; hash[\"M\"] = 1000; for(int i = 0; i &lt; s.size();){ if(hash.count(s.substr(i, 2))) value += hash[s.substr(i, 2)], i += 2; else if(hash.count(s.substr(i, 1))) value += hash[s.substr(i, 1)], i += 1; } return value; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-12.整数转罗马数字","slug":"LeetCode刷题-12-整数转罗马数字","date":"2020-06-19T03:24:14.000Z","updated":"2020-06-19T15:01:37.980Z","comments":true,"path":"posts/61074.html","link":"","permalink":"https://www.itnxd.cn/posts/61074.html","excerpt":"","text":"题目链接：12.整数转罗马数字 ¶题解： 嗯，，这题挺简单，字符串处理，我使用了具有对应关系的哈希表！ ¶题目简述： 给定了一个正数，转化成罗马数字。 例如：1994---------&gt; “MCMXCIV” ¶题解： 罗马数字就是下面十三种字母的组合，首先使用一种数据结构将对应的数字与罗马数字对应起来！ 这里我使用了unordered_map哈希表存储！ 和每次将一个数取余取除类似，可以搞到每一位！ 所以：思路就是将普通数字，一直对高位取除，即从1000、900、500…1，取除： 如果等于0，则说明剩余部分比该数字要小，直接跳过； 不等于0，则进行处理，将str 累加一下对应的字符t次，即可 每次进行取余计算剩下的即可！ ¶AC代码： 1234567891011121314151617181920212223242526272829303132class Solution {public: string intToRoman(int num) { unordered_map&lt;int, string&gt; hash; int a[13] = {1,4,5,9,10,40,50,90,100,400,500,900,1000}; int k = 12; string str = \"\"; hash[1] = \"I\"; hash[4] = \"IV\"; hash[5] = \"V\"; hash[9] = \"IX\"; hash[10] = \"X\"; hash[40] = \"XL\"; hash[50] = \"L\"; hash[90] = \"XC\"; hash[100] = \"C\"; hash[400] = \"CD\"; hash[500] = \"D\"; hash[900] = \"CM\"; hash[1000] = \"M\"; while(num){ // 3 / 1 int t = num / a[k]; num %= a[k]; if(t != 0){ for(int i = 0; i &lt; t; i++) str += hash[a[k]]; } k--; } return str; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-11.盛最多水的容器","slug":"LeetCode刷题-11-盛最多水的容器","date":"2020-06-18T14:29:47.000Z","updated":"2020-06-19T02:39:56.664Z","comments":true,"path":"posts/22556.html","link":"","permalink":"https://www.itnxd.cn/posts/22556.html","excerpt":"","text":"题目链接：11.盛最多水的容器 ¶题解： 双指针使用，巧妙的思路！ 也是不太好理解！多看看！ ¶题目简述： 给了一堆柱子及其高度，要求选出两个柱子，使得凹槽内的面积达到最大，当然两根柱子要选较低的一根作为高，否则会发生漏水！ ¶题解一： 本题可以使用暴力，直接两层循环，但是会超时！ 所以可以使用双指针算法： 先给出具体思路：两个指针（i 和 j）一个从左走，一个从右走，若左边的比右边的高，则高的一边往内靠，即左面的往后走，右面的往前走，i++，j--，直到i == j结束。 给出证明一： 假设最优解对应的下标为i', j'（i' &lt; j'），在两指针（i, j）移动的过程中不断靠近最优解，先假设i 先走到 i'，且此时j' &lt; j。 反证：假设此时 a[i] &lt;= a[j]，用s表示i,j盛水的面积，s'表示i',j'盛水的面积，则： s = min(a[i], a[j]) * (j - i) = a[i] * (j - i) s' = min(a[i'], a[j']) * (j' - i') = min(a[i], a[j']) * (j' - i) &lt;= a[i] * (j' - i) &lt; a[i] * (j - i) = s 即如果a[i] &lt;= a[j]，则最优解 s'是小于 s的，发生矛盾！假设不成立。 结论：要想使i', j'为最优解，必须使a[i] &gt; a[j]，这样可以使得j指针可以向前移动，逐渐靠近j' 可以结合我画的图来看：s‘面积最大为s2' 给出证明二： 题解来源：LeetCode 两个指分别指向两端，假设左边的较低！ 如果固定左边的柱子，移动右边的柱子，那么水的高度一定不会增加，且宽度一定减少，所以水的面积一定减少。这个时候，左边的柱子和任意一个其他柱子的组合，其实都可以排除了（因为一定宽度变小，高度一定 &lt;= 当前最小高度，面积一定减小）。也就是我们可以排除掉左边的柱子了。（即左边的柱子存在的毫无意义，固定左边右边移动一定不会使面积变大） 总结：较低的一方固定了，较高的一方进行移动，毫无意义，不会使得面积增大！所以要想得到最大值，一定是较长的一方固定，较短的一方移动。 时间复杂度：没根柱子只扫描一遍，为 O(N) ¶AC代码一： 123456789101112class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int res = 0; for(int i = 0, j = height.size() - 1; i &lt; j;){ res = max(res, min(height[i], height[j]) * (j - i)); if(height[i] &lt; height[j]) i++; else j--; } return res; }}; ¶题解二： **这种好像更好理解！**同样是双指针！ 想让i, j指向两边，此时的构成的矩形宽度是最大的，但是面积不一定是最大的，所以两个指针要想内游走。 对于此时i, j指向的直线，宽度是最大的，向内收敛的过程中，宽度是在减小的。如果遇到高度更低的柱子，那么现在构成的矩形面积一定会比原来的要小，毕竟宽度变小，高度变小；所以只有遇到高度更高的柱子，才有可能比当前的面积要大。 所以，遇到更短的直接向后走，遇到高的则做一下比较，留下最大值即可！ 注意长短的比较是和上一次最短的比较！ 时间复杂度：同样为 O(N) 其实代码意思一样的，换了个写法！ ¶AC代码二： 123456789101112131415class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int i = 0, j = height.size() - 1; int res = 0; while (i &lt; j) { int h = min(height[i], height[j]); res = max(res, h * (j - i)); while (i &lt; j &amp;&amp; height[i] &lt;= h) i ++; while (i &lt; j &amp;&amp; height[j] &lt;= h) j --; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-10.正则表达式匹配","slug":"LeetCode刷题-10-正则表达式匹配","date":"2020-06-15T06:57:45.000Z","updated":"2021-02-06T14:25:46.137Z","comments":true,"path":"posts/6262.html","link":"","permalink":"https://www.itnxd.cn/posts/6262.html","excerpt":"","text":"题目链接：10.正则表达式匹配 ¶题解： 又是一道很难的动态规划题，或许他不难，只是我遇到动态规划的题太少了罢了！ 历时很久才将其看懂：还是 y 总牛逼！ ¶题目简述： 正则匹配：处理两个字符* 和 . *：表示0个或多个 .：任意一个字符 给一个字符串，给一个正则，检查能否匹配。 ¶题解： 使用闫式Dp分析法：（集合的方式） 再字符串前面加一个空格，使子符串从1开始！ 分为状态表示和状态计算： 转态表示：两个字符串，则使用两维数组f[i][j] ，来表示原串和正则串的 [1, i] 个 和 [1, j] 个是否匹配，存储的是bool值（表示是否存在一个合法方案，由于*的原因导致方案不唯一）。 状态计算：（分为两种情况） p[j] != '*'：则f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == .) p[j] == '*'：则f[i][j] = f[i][j-2] || f[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.') 详细解释一下： 1、p[j] != '*'：s串的前 i 个和 p串的前 j个字符f[i][j] 的情况有两个因素确定： f[i - 1][j - 1]：即去除s串的最后一个待匹配字符与p串的最后一个待匹配字符后，要保证前 i - 1和 前 j - 1 个字符匹配 (s[i] == p[j] || p[j] == ‘.’)：并且s 串和p串的最后一个字符匹配，或者s串任意字符，p串为 .（匹配任意字符） 2、p[j] == '*'：s串的前 i 个和 p串的前 j个字符f[i][j] 的情况有两个因素确定（（1）即 *表示的个数：0，1，2，3… （2）s与p串尾部的匹配工作）： 0个：f[i][j - 2] 1个：f[i - 1][j - 2] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.') 2个：f[i - 2][j - 2] &amp;&amp; (s[i] == p[j - 1] &amp;&amp; s[i - 1] == p[j - 1] || p[j - 1] == '.') … 最后是否匹配即上面有一个成立即可 合并起来看一下： f[i][j] = f[i][j - 2] || f[i - 1][j - 2]&amp;&amp;(s[i] == p[j - 1] || p[j - 1] == '.') || f[i - 2][j - 2] &amp;&amp; (s[i] == p[j - 1] &amp;&amp; s[i - 1] == p[j - 1] || p[j - 1] == '.') ......... 无穷无尽 … 所以咱们来看一下： f[i - 1][j]，同理*号可以取0，1，3，4，5… 最后合并起来就是：f[i - 1][j] = f[i - 1][j - 2] || f[i - 2][j - 2] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.') || f[i - 3][j - 2] &amp;&amp; (s[i - 1] == p[j - 1] &amp;&amp; s[i - 2] == p[j - 1] || p[j - 1] == '.') .............. 观察两个式子，会发现存在一个关系： f[i][j]包含了f[i - 1][j]：f[i][j] = f[i][j - 2] || f[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.') 这就是状态转移方程！ **注意：**相当于乘法分配律：（A || B）&amp;&amp; C == A &amp;&amp; C || B &amp;&amp; C，所以可以提出来公共项：(s[i] == p[j - 1] || p[j - 1] == '.') 将上诉关系放到代码框内方便查看： 12345678910111213- 0个：`f[i][j - 2]`- 1个：`f[i - 1][j - 2] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.')`- 2个：`f[i - 2][j - 2] &amp;&amp; (s[i] == p[j - 1] &amp;&amp; s[i - 1] == p[j - 1] || p[j - 1] == '.')`- ......// f[i][j]f[i][j] = f[i][j - 2] || f[i - 1][j - 2]&amp;&amp;(s[i] == p[j - 1] || p[j - 1] == '.') || f[i - 2][j - 2] &amp;&amp; (s[i] == p[j - 1] &amp;&amp; s[i - 1] == p[j - 1] || p[j - 1] == '.') .......// f[i - 1][j]f[i - 1][j] = f[i - 1][j - 2] || f[i - 2][j - 2] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.') || f[i - 3][j - 2] &amp;&amp; (s[i - 1] == p[j - 1] &amp;&amp; s[i - 2] == p[j - 1] || p[j - 1] == '.') .......// 最终状态转移方程：f[i][j] = f[i][j - 2] || f[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.') ¶AC代码： 这里说一下细节处理： f[0][0] = true：初始值，两个串的前0个都是空格，匹配。 j = 1开始：j从0开始无意义，从0开始的话，一个非空的串是不可能匹配一个空串 如：f[1][0]。也可以从0开始，但是得防止下标越界问题，不如直接从1开始。 i 从 0 开始：i 可以从 0 开始，s为空格，p为 .* ，即f[0][1] i == 0：需要特殊判断，i &amp;&amp; p[j] != '*'，这个条件得保证i != 0，以防下标越界 j不需要考虑越界问题：j的取值可能在else if下越界，但是，如果走到else if，j 的下标一定大于等于3，即p串至少也是a*，前面再加上初始空格，一定大于等于3，不会发生越界！ s 与 p 串都加一个空格：这样f[0][0]是可以确定的！不加空格，无法有一个初始值。可能会更加复杂！ 最后答案就是： f[n][m]即 s 整个串和 p 整个串匹配！ 注意：vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1));，初始化了一个 (n + 1 )* (m + 1)二维数组，默认为false。 详细代码如下： 12345678910111213141516171819class Solution {public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); s = ' ' + s, p = ' ' + p; vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1)); f[0][0] = true; for (int i = 0; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) { if (j + 1 &lt;= m &amp;&amp; p[j + 1] == '*') continue; if (i &amp;&amp; p[j] != '*') { f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == '.'); } else if (p[j] == '*') { f[i][j] = f[i][j - 2] || i &amp;&amp; f[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.'); } } return f[n][m]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Dp","slug":"Dp","permalink":"https://www.itnxd.cn/tags/Dp/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-9.回文数","slug":"LeetCode刷题-9-回文数","date":"2020-06-14T10:37:52.000Z","updated":"2021-02-06T14:25:14.168Z","comments":true,"path":"posts/22431.html","link":"","permalink":"https://www.itnxd.cn/posts/22431.html","excerpt":"","text":"题目链接：9. 回文数 ¶题解： 虽然简单，但是还是有可以优化的地方！ ¶题目简述： 给一个 int 类型的数，判断是不是回文数！ 注意：-121 反转后 为 121- 不是回文数。 ¶题解一：循环 嗯，太简单了，不写解释了！ 注意一点：int 正序可能没溢出，但是反转过来就不一定没有溢出，所以，要用 long long 来存储一下！ ¶AC代码： 123456789101112class Solution {public: bool isPalindrome(int x) { if(x &lt; 0) return false; long long t = 0, r = x; while(r){ t = t * 10 + r % 10; r /= 10; } return t == x; }}; ¶题解二：循环优化 由于是回文串，那么如果是的话，他的前半部分和后半部分是完全一样的，所以我们可以只处理一半即可得到答案。 如果为负数和末尾有0一定不是回文数。（除了 0） 如果后半部分等于前半部分即是回文数，否则不是： 奇数：s == x / 10 偶数：s == x 退出条件 s &lt;= x，大于就超过了中点位置！ ¶AC代码： 12345678910111213class Solution {public: bool isPalindrome(int x) { if(x &lt; 0 || (x &amp;&amp; x % 10 == 0)) return false; int t = 0; while(t &lt;= x){ t = t * 10 + x % 10; if(t == x || t == x / 10) return true; x /= 10; } return false; }}; ¶题解三：使用 string to_string：是 C++11支持的。 s.rbegin() 和 s.rend()：返回一个逆向迭代器，分别指向字符串的最后一个字符和起始位置（第一个字符前面一个字符位置） 也可以使用reverse()进行反转，不过他没有返回值，而是直接将原串都修改了，不推荐使用。 ¶AC代码： 12345678910111213class Solution {public: bool isPalindrome(int x) { if(x &lt; 0) return false; string s = to_string(x); return s == string(s.rbegin(), s.rend()); // 或者： // string t = s; // reverse(t.begin(), t.end()); // return s == t; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"回文数","slug":"回文数","permalink":"https://www.itnxd.cn/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-8.字符串转换整数(atoi)","slug":"LeetCode刷题-8-字符串转换整数","date":"2020-06-14T05:39:07.000Z","updated":"2021-02-06T14:25:27.585Z","comments":true,"path":"posts/64625.html","link":"","permalink":"https://www.itnxd.cn/posts/64625.html","excerpt":"","text":"题目链接：8.字符串转换整数(atoi) ¶题解： 细节特别多，水题！ ¶题目简述： 将字符串开头是数字的抠出来！ ¶题解： 大致有一下这五种情况： &lt;空格&gt;123：返回123 +123：返回123 -123：返回-123 +-123或-+123：返回 0 w123： 返回 0 注意：如果转换后的数字大于INT_MAX 或小于INT_MIN，返回INT_MAX 或INT_MIN。 注意：long long也不一定能存下，所以只要超过INT_MAX 或INT_MIN就返回INT_MAX 或INT_MIN。 具体解释：查看代码中注释。 ¶AC代码： 12345678910111213141516171819202122232425class Solution {public: int myAtoi(string str) { int i = 0, t = 1; long long res = 0; // 处理开头空格 while(str[i] == ' ') i++; // 处理++ -- +- -+ if((str[i] == '+' || str[i] == '-') &amp;&amp; (str[i + 1] == '+' || str[i + 1] == '-')) return 0; // 处理负数 if(str[i] == '-') t = -1, i++; // 处理正数 if(str[i] == '+') i++; for(; i &lt; str.size(); i++){ if(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9'){ res = res * 10 + str[i] - '0'; // 超过int范围 if(res * t &lt; INT_MIN) return INT_MIN; if(res * t &gt; INT_MAX) return INT_MAX; }else break; } res *= t; return res; }}; 只使用 int处理： res = res * 10 + str[i] - '0';可能会溢出，处理这里即可。 res * 10 + x &gt; INT_MAX ---&gt; res &gt; (INT_MAX - x) / 10 -res * 10 - x &lt; INT_MIN ---&gt; -res &lt; (INT_MAX + x) / 10 -2147483648：这个循环内算的是 2147483648，但是res为正数的int，最大为2147483647，会发生越界。判断条件：-res * 10 - x == INT_MIN 12345678910111213141516171819202122232425class Solution {public: int myAtoi(string str) { int i = 0, t = 1; int res = 0; while(str[i] == ' ') i++; if((str[i] == '+' || str[i] == '-') &amp;&amp; (str[i + 1] == '+' || str[i + 1] == '-')) return 0; if(str[i] == '-') t = -1, i++; if(str[i] == '+') i++; for(; i &lt; str.size(); i++){ if(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9'){ int x = str[i] - '0'; // res * 10 + x &gt; INT_MAX ---&gt; res &gt; (INT_MAX - x) / 10 if(t == 1 &amp;&amp; res &gt; (INT_MAX - x) / 10) return INT_MAX; // -res * 10 - x &lt; INT_MIN ---&gt; -res &lt; (INT_MAX + x) / 10 if(t == -1 &amp;&amp; -res &lt; (INT_MIN + x) / 10) return INT_MIN; // -2147483648 if(-res * 10 - x == INT_MIN) return INT_MIN; res = res * 10 + x; }else break; } res *= t; return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-7.整数反转","slug":"LeetCode刷题-7-整数反转","date":"2020-06-14T04:24:06.000Z","updated":"2021-02-06T14:24:57.297Z","comments":true,"path":"posts/58547.html","link":"","permalink":"https://www.itnxd.cn/posts/58547.html","excerpt":"","text":"题目链接：7.整数反转 ¶题解： 水题一个！ ¶题目简述： 正负数都倒序输出即可，负数处理完还是负数。 ¶题解： 正负数的原因，应该分开处理，但是C++取余不区分正负，和数学不一样，会区分正负。 题目有 2 ^ 31的限制，即 int的最大最小值，使用INT_MAX 和 INTMIN即可，头文件位于climits中。res定义为long long防止溢出。 注意：不要使用 2 &lt;&lt; 31，会溢出的，结果为 0。 ¶AC代码： 123456789101112class Solution {public: int reverse(int x) { long long res = 0; while(x){ res = res * 10 + x % 10; x /= 10; } if(res &gt; INT_MAX || res &lt; INT_MIN) return 0; return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"反转","slug":"反转","permalink":"https://www.itnxd.cn/tags/%E5%8F%8D%E8%BD%AC/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-6.Z字形变换","slug":"LeetCode刷题-6-Z字形变换","date":"2020-06-14T02:44:43.000Z","updated":"2021-02-06T14:22:13.493Z","comments":true,"path":"posts/60082.html","link":"","permalink":"https://www.itnxd.cn/posts/60082.html","excerpt":"","text":"题目链接：6.Z字形变换 ¶题解： 完全就是找规律，找到每行下标的规律即可，为一个等差数列！ ¶题目简述： 将字符串按倒Z型排列，然后按行读取完整字符，输出对应字符串！ ¶题解： 以一个容易发现规律的例子来解释： 以四行为例： 12340 6 121 5 7 11 13 ..2 4 8 10 14 163 9 15 第一行和最后一行公差相同，为 2 * n - 2，即从0 - 6 中间隔了1-3 和 4 - 6 即两个 n - 1. 中间其他行，看做两个等差序列的混合，分别去处理，竖线上的同样是以2 * n - 2为公差的等差数列，不在竖线上的是以2 * n - 2 - i为首项，以2 * n - 2为公差的等差数列！ 2 * n - 2 - i：会发现 1 + 5 = 6 2 + 4 = 6，即 i + x = 2 * n - 2，x = 2 * n - 2 - i 注意： n = 1时，2 * n - 2为零，循环为死循环，所以进行特判，返回原串 s。 ¶AC代码： 1234567891011121314151617181920class Solution {public: string convert(string s, int n) { string str; if(n == 1) return s; for(int i = 0; i &lt; n; i++){ if(i == 0 || i == n - 1){ for(int j = i; j &lt; s.size(); j += 2 * n - 2){ str += s[j]; } }else{ for(int j = i, k = 2 * n - 2 - i; j &lt; s.size() || k &lt; s.size(); j += 2 * n - 2, k += 2 * n - 2){ if(j &lt; s.size()) str += s[j]; if(k &lt; s.size()) str += s[k]; } } } return str; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"找规律","slug":"找规律","permalink":"https://www.itnxd.cn/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-5.最长回文子串","slug":"LeetCode刷题-5-最长回文子串","date":"2020-06-14T01:27:14.000Z","updated":"2021-02-06T14:21:47.434Z","comments":true,"path":"posts/30088.html","link":"","permalink":"https://www.itnxd.cn/posts/30088.html","excerpt":"","text":"题目链接：5.最长回文子串 ¶题解： 本题有一个将时间复杂度降到O(N)的算法：马拉车算法 Manacher‘s Algorithm 此算法专门由于求解最长回文子串问题！但是 y总说不太常用！ 还有一个O(NlogN)的算法：哈希 + 二分 有点困难，能力强了再去玩玩！ 本次：使用枚举暴力做法！时间复杂度 O(n^2) ¶题目简述： 求解最长回文子串！若不止一个最长，随便输出一个！ ¶题解： 使用暴力枚举即可： 使用两个指针 l, r, 从中间往两边扩即可！ 奇数：另 l = i - 1, r = i + 1 偶数：另 l = i, r = i + 1 条件： l &gt;= 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] == s[r]：即可以往两边移 str.size() &lt; r - l -1：即当前回文子串更长，则更新 str 时间复杂度：O(n^2) ¶AC代码： 12345678910111213141516class Solution {public: string longestPalindrome(string s) { string str; for(int i = 0; i &lt; s.size(); i++){ int l = i - 1, r = i + 1; while(l &gt;= 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] == s[r]) l--, r++; if(str.size() &lt; r - l -1) str = s.substr(l + 1, r - l - 1); l = i, r = i + 1; while(l &gt;= 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] == s[r]) l--, r++; if(str.size() &lt; r - l -1) str = s.substr(l + 1, r - l - 1); } return str; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"枚举","slug":"枚举","permalink":"https://www.itnxd.cn/tags/%E6%9E%9A%E4%B8%BE/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-4.寻找两个正序数组的中位数","slug":"LeetCode刷题-4-寻找两个正序数组的中位数","date":"2020-06-13T13:45:10.000Z","updated":"2021-02-06T14:22:46.833Z","comments":true,"path":"posts/44209.html","link":"","permalink":"https://www.itnxd.cn/posts/44209.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：4.寻找两个正序数组的中位数 ¶题解： 此题 y总 的链接！ 此题据 y总 说是LeetCode最难题目之一！ 这个题目或许又可以称为 求解第k小数问题 ¶题目简述： 两个有序序列，求中位数！ 有一个很 优秀的要求：时间复杂度要控制在 O(log(m + n)) ¶题解一： 先不看题目时间复杂度的要求：使用二路归并进行，时间复杂度O(n + m) 由于时间也不算太慢，还是可以AC的。题解二将使用更优秀的算法解决。 二路归并：思路，每次两两比较，将较小值放到新的容器。若某一个遍历完毕，则将没有遍历完的另一个一次放到新的容器。 本题奇偶两种情况处理，奇数位的中位数为 len &gt; 1， 偶数位的中位数为 len &gt; 1 和 (len &gt; 1) - 1 和的均值！ 注意点：返回值为double，所以记得乘以 1. 0 或除以 2.0 ¶AC代码1： 12345678910111213141516class Solution {public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int len = nums1.size() + nums2.size(); vector&lt;int&gt; nums3; int i = 0, j = 0; while(i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()){ if(nums1[i] &lt; nums2[j]) nums3.push_back(nums1[i++]); else nums3.push_back(nums2[j++]); } while(i &lt; nums1.size()){nums3.push_back(nums1[i++]);} while(j &lt; nums2.size()){nums3.push_back(nums2[j++]);} if(len &amp; 1) return nums3[len &gt;&gt; 1]; else return (nums3[len &gt;&gt; 1] + nums3[(len &gt;&gt; 1) - 1]) * 1.0 / 2; }}; ¶题解二： 由于题目要求时间复杂度为 O(log(n + m))，所有第一种解法不符合题意，虽然可以AC。 现在将给出第二种解法：使用递归分治 如何想到使用分治的呢？ 时间复杂度为log级别的，想到 log 就会想到 除2，除2，除2 。。。。 所以本题采用类似思想，即每递归一次就将数据量减半，达到log级别！ 具体实现： 递归函数的目的：在可选区间找到第 k 小的数 ，k &gt; 0。 递归分治的思想：即将问题子问题化，由大变小，逐个解决。 本题求解：即求k = (n + m) / 2 的位置即可，使用递归求解 k / 2, k / 2 / 2.。。。。。直到k = 1，回溯到 k = (n + m) / 2的解，即为答案！ 时间复杂度：O(log(k)) 即 O(log((n + m) / 2) 即 O(log(n + m)) 好！ 开始分解子问题：(k / 2) 先进行判断：保证函数参数 nums1为较短的数组，nums2为较长的数组。 ¶1、假设 m, n &gt;= k/ 2，即 k / 2 的位置不会越界。 这样会有三种情况： 虽然从两个数组各选了k / 2 个值，但是第k小不一定在这k个数内。 但是却可以确定，第k小的数一定不在较小的数组那 k /2 的范围，这时可以舍弃 k / 2 的数据量，转而求舍弃后的两个数组（即被截取前 k / 2个数的数组和完整的另一个数组） 若两个值相等就简单了：两个 k / 2 的序列合起来就是两个数组的前 k 小的序列，即第k 小为任意一个 nums1[k / 2 - 1]或 num2[k / 2 - 1] 注意：相等情况的特殊之处：并不能直接返回，因为可能执行到某个阶段，不一定某个序列还有 k / 2个数。所以这个边界情况会导致当前数就不是第 k 小数了！ 所以：最终只分两种情况即可： &lt; 和 &gt; 注意：k从1开始，下标从0开始！ nums1[k / 2 - 1] &lt; nums2[k / 2 - 1]： nums1[k / 2 - 1] &gt; nums2[k / 2 - 1]： nums1[k / 2 - 1] = nums2[k / 2 - 1]： ¶2、若 m &lt; k / 2，则 nums1[k / 2]会发生越界 m 对应较短数组的长度，发生越界则将其规约到他的最大长度：si = min((int)nums1.size(), i + k / 2) ¶3、具体情形 find()：i， j 为起始位置 递归出口： k == 1：nums1为空，则return nums2[j]，否则return min(nums1[i], nums2[j]) k != 1：nums1为空，则return nums2[j + k -1]（j为nums2的起始下标，k从1开始） si规约：si = min((int)nums1.size(), i + k / 2) &lt; &gt;： nums1[si - 1] &gt; nums2[sj - 1]：则return find(nums1, i, nums2, sj, k - (sj - j)); nums1[si - 1] &lt;= nums2[sj - 1]：（关于等于处理请看上面红字），则return find(nums1, si, nums2, j, k - (si - i)); 注意：si - i 和 sj - j 为砍掉的数目！ 关于 k / 2 和 k - k / 2：由于奇偶问题，k / 2，不一定和 k - k / 2相等！ 注意：vector.size()返回值为size_type，需要使用 int强转一下。 ==时间复杂度：O(log(m + n))== ¶AC代码2： 1234567891011121314151617181920212223242526272829303132class Solution {public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int len = nums1.size() + nums2.size(); if(len &amp; 1){ return find(nums1, 0, nums2, 0, (len &gt;&gt; 1) + 1); }else{ int left = find(nums1, 0, nums2, 0, len &gt;&gt; 1); int right = find(nums1, 0, nums2, 0, (len &gt;&gt; 1) + 1); return (left + right) / 2.0; } } int find(vector&lt;int&gt;&amp; nums1, int i, vector&lt;int&gt; nums2, int j, int k){ // 始终保证较小的传给参数nums1 if(nums1.size() - i &gt; nums2.size() - j) return find(nums2, j, nums1, i, k); if(k == 1){ // nums1为空 if(nums1.size() == i) return nums2[j]; return min(nums1[i], nums2[j]); } // nums1为空 if(nums1.size() == i) return nums2[j + k -1]; // si 规约 k / 2 和 k - k / 2 int si = min((int)nums1.size(), i + k / 2), sj = j + k - k / 2; // （规约）后的两种情况 if(nums1[si - 1] &gt; nums2[sj - 1]) return find(nums1, i, nums2, sj, k - (sj - j)); else return find(nums1, si, nums2, j, k - (si - i)); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"分治","slug":"分治","permalink":"https://www.itnxd.cn/tags/%E5%88%86%E6%B2%BB/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-3.无重复字符的最长子串","slug":"LeetCode刷题-3-无重复字符的最长子串","date":"2020-06-13T03:05:26.000Z","updated":"2021-02-06T14:21:12.490Z","comments":true,"path":"posts/25173.html","link":"","permalink":"https://www.itnxd.cn/posts/25173.html","excerpt":"","text":"题目链接：3.无重复字符的最长子串 ¶题解： 双指针形成的滑动窗口实现！双指针被形象表示为滑动窗口！ ¶题目简述： 两个概念： 子串：连续的 子序列：不一定连续，下标递增 找出一个字符串中最长不重复的子串，返回最大长度！ ¶题解： 使用两个指针i, j，（j &lt; i）, 区间[j, i]表示以 i 为尾的子串的区间。 使用 unordered_map&lt;char, int&gt; hash来表示 字符出现的次数。 双指针扫描时来维护该区间[j, i]，使得该区间为以 i 为底的，保证不重复的最大区间。 初始[j, i]无重复，i往后走，将其加入哈希表 若加入后，hash[s[i]] &gt; 1说明 i位置出现了和前面重复的字符，由于前面是不重复的，所以只有可能是i位置的字符重复，接下来，j开始后移，同时进行hash[s[j++]]--来j将哈希表前面的字符清零，直到找到一个新的 j使的 hash[s[i]] &gt; 1不成立，即当前 j 的位置为与 i重复字符的下一个字符，当前[j, i]为以 i为尾的最长子串。 画一个简图如下： 时间复杂度：每个点最多被i 和 j 各扫描一次，所以为 O(N) ¶AC代码： 1234567891011121314151617class Solution {public: int lengthOfLongestSubstring(string s) { int res = 0; // 字符出现的个数 unordered_map&lt;char, int&gt; hash; // [j, i] for(int i = 0, j = 0; i &lt; s.size(); i++){ hash[s[i]]++; while(hash[s[i]] &gt; 1){ hash[s[j++]]--; } res = max(res, i - j + 1); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://www.itnxd.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-2.两数相加","slug":"LeetCode刷题-2-两数相加","date":"2020-06-12T14:09:58.000Z","updated":"2021-02-06T14:20:59.186Z","comments":true,"path":"posts/1127.html","link":"","permalink":"https://www.itnxd.cn/posts/1127.html","excerpt":"","text":"题目链接：2.两数相加 ¶题解： 链表的简单操作！模拟数字相加。 ¶题目简述： 两个倒序链表：例如：234的链表为 4 -&gt; 3 -&gt; 2，给定两个倒序链表，返回两个链表正序相加后的倒序链表！ ¶题解： 由于给出的顺序是倒序，可以直接像普通加法从个位开始加起，进位即可。 初始化时可以设置一个虚节点：ListNode* l3 = new ListNode(-1);，返回时直接返回l3-&gt;next即可。 用 t表示进位，while退出后若仍有进位，则链表末尾补 1 ； ¶AC代码1： 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* l3 = new ListNode(-1); ListNode* res = l3; int t = 0; while(l1 || l2){ // 链表结束，之后全部置为0 int n1 = l1 ? l1-&gt;val : 0; int n2 = l2 ? l2-&gt;val : 0; int sum = n1 + n2 + t; // t 表示进位 t = sum / 10; res-&gt;next = new ListNode(sum % 10); res = res-&gt;next; if(l1) l1 = l1-&gt;next; if(l2) l2 = l2-&gt;next; } // 最高位有进位： if(t) res-&gt;next = new ListNode(1); // 返回除了第一个-1之外的节点 return l3-&gt;next; }}; ¶AC代码2： 写法更加简洁：直接使用 t进行累加即可！ 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* l3 = new ListNode(-1); ListNode* res = l3; int t = 0; while(l1 || l2 || t){ if(l1) t += l1-&gt;val, l1 = l1-&gt;next; if(l2) t += l2-&gt;val, l2 = l2-&gt;next; res-&gt;next = new ListNode(t % 10); res = res-&gt;next; t /= 10; } return l3-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-1.两数之和","slug":"LeetCode刷题-1-两数之和","date":"2020-06-12T12:53:28.000Z","updated":"2021-02-06T14:20:45.226Z","comments":true,"path":"posts/43672.html","link":"","permalink":"https://www.itnxd.cn/posts/43672.html","excerpt":"","text":"题目链接：1.两数之和 ¶题解： ¶1、暴力 由于答案的解唯一，可以使用两层循环，找到直接返回！ 假如：最后为{i, j}， i &lt; j，两层循环如下方代码。 时间复杂度：O(N^2) ¶AC代码： 1234567891011121314class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { for(int i = 0; i &lt; nums.size(); i++) { for(int j = i + 1; j &lt; nums.size(); j++) { if(nums[i] + nums[j] == target) return {i, j}; } } return {}; }}; ¶2、使用哈希表 本题的目标就是找一个数，target - nums[i] ，找到一个即为答案，对于快速的查找可以使用哈希表！ 这里的 下标 i 规定为 {j, i}，j &lt; i， 只需要每次从i - j 的范围找一个 target - nums[i]即可，找到即为答案，返回{hash[target - nums[i]], i}. 判断target - nums[i]是否在哈希表 不在则将当前数加到哈希表 哈希表： unordered_map： 增删改查复杂度为O(1) 两个函数： count()：统计个数，C++ unordered_map不允许有重复的 key，所以该返回值为1 或 0； find()：找到返回迭代器，找不到返回 hash.end() 时间复杂度：O(N) ¶AC代码： 12345678910111213141516171819class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; hash; for(int i = 0; i &lt; nums.size(); i++){ int r = target - nums[i]; // 使用find // if(hash.find(r) != hash.end()){ // return {hash[r], i}; // } // count if(hash.count(r)){ return {hash[r], i}; } hash[nums[i]] = i; } return {}; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%BB%84/"},{"name":"哈希表","slug":"哈希表","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"数据库教程之修改数据","slug":"数据库教程之修改数据","date":"2020-06-09T10:36:02.000Z","updated":"2021-09-13T07:54:15.160Z","comments":true,"path":"posts/26278.html","link":"","permalink":"https://www.itnxd.cn/posts/26278.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve(检索)、Update、Delete。其中，对于查询，我们已经详细讲述了SELECT语句的详细用法。 而对于增、删、改，对应的SQL语句分别是： INSERT：插入新记录； UPDATE：更新已有记录； DELETE：删除已有记录。 ¶一、INSERT ¶1、插入一条记录 语法：INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...); id字段是一个自增主键，它的值可以由数据库自己推算出来。 如果一个字段有默认值或设置为允许NULL值，那么在INSERT语句中也可以不出现。 要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。 可以不指定插入列，但必须和表的列完全匹配，这样并不安全，高度依赖于表中的定义顺序，表结构变动后，就不一定匹配了！一般不这样使用！ 12345678910111213141516171819202122232425262728293031323334INSERT INTO CustomersVALUES (NULL,'Pep E. LaPew'，'100 Main Street','LoS Ange les','CA','90046'，'USA',NULL,NULL);-- 推荐写法mysql&gt; INSERT INTO students (class_id, name, gender, score) VALUES (2, '大牛', 'M', 80);Query OK, 1 row affected (0.03 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 73 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 55 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 |+----+----------+--------+--------+-------+12 rows in set (0.00 sec) ¶2、插入多条记录 语法：INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...), VALUES (值1, 值2, ...).....; 多条语句，逗号隔开！ 1234567891011121314151617181920212223242526$ mysql&gt; INSERT INTO students (class_id, name, gender, score) VALUES -&gt; (1, '大宝', 'M', 87), -&gt; (2, '二宝', 'M', 81);Query OK, 2 rows affected (0.01 sec)Records: 2 Duplicates: 0 Warnings: 0$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 73 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 55 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) ¶3、插入检索出的数据 即使用INSERT INTO ... SELECT ... FROM ... 为简单起见，这个例子在 NSERT 和SELECT 语句中使用了相同的列名。但是，不一定要求列名匹配。事实上，MySQL甚至不关心 SELECT 返回的列名。它使用的是列的位置，因此 SELECT 中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。这对于从使用不同列名的表中导入数据是非常有用的。 这个例子导入了 cust_id （假设你能够确保 cust_id 的值不重复）。 1234567891011121314151617181920INSERT INTO customers(cust_id,cust_contact ,cust_emai 1，cust_name ，cust_address,cust_city ，cust_state,cust_zip,cust_country)SELECT cust_id,cust_contact ，cust_emai 1，cust_name , .cust_address,cust_city ，cust_state,cust_zip,cust_countryFROM custnew; ¶4、提高整体性能 INSERT 操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的 SELECT 语句的性能。 如果数据检索是最重要的（通常是这样），则你可以通过在INSERT 和 INTO 之间添加关键字 LOW_PRIORITY ，指示MySQL降低 INSERT 语句的优先级，如下所示： 1INSERT LOW_PRIORITY INTO ¶5、IGNORE 如果用 INSERT 语句插入多行，并且在插入这些行中的一行或多行时出一个现错误，则整个 INSERT 操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。 使用IGNORE即使是发生错误，也继续进行更新，如下所示： INSERT IGNORE INTO customers.... ¶二、UPDATE 在 UPDATE 语句中使用子查询 ，UPDATE 语句中可以使用子查询，使得能用 SELECT 语句检索出的数据更新列数据。 ¶1、更新一条记录 语法：UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...; 1234567891011$ mysql&gt; UPDATE students SET name='大牛', score=66 WHERE id=1;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0$ mysql&gt; SELECT * FROM students WHERE id=1;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 大牛 | M | 66 |+----+----------+--------+--------+-------+1 row in set (0.00 sec) ¶2、更新多条记录 语法：UPDATE students SET name='小牛', score=77 WHERE id&gt;=5 AND id&lt;=7; WHERE条件可与逻辑运算符结合，更新指定条件的记录。 如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。 123456789101112131415161718192021222324$ mysql&gt; UPDATE students SET score=score+10 WHERE score&lt;80;Query OK, 3 rows affected (0.01 sec)Rows matched: 3 Changed: 3 Warnings: 0$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 大牛 | M | 76 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) ¶3、不使用WHERE条件 此举动要小心，整个表的所有记录都会被更新。 eg：UPDATE students SET score=60; 效果：整个表的学生分数都变为了60. 注意：所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。 ¶4、IGNORE 如果用 UPDATE 语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个 UPDATE 操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。 使用IGNORE即使是发生错误，也继续进行更新，如下所示： UPDATE IGNORE customers... SET... ¶5、MySQL提示信息 使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。 123$ mysql&gt; UPDATE students SET name='大牛', score=66 WHERE id=1;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0 ¶三、DELETE ¶1、删除记录 语法：DELETE FROM &lt;表名&gt; WHERE ...; 同样：可以配合逻辑运算符实现多条删除！ 如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。 12345678910111213141516171819202122$ mysql&gt; DELETE FROM students WHERE id=1;Query OK, 1 row affected (0.01 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+13 rows in set (0.00 sec) ¶2、不使用WHERE条件 此举动要小心，整个表的所有记录都会被删除。 eg：DELETE FROM students; 效果：变成了一张空表。 注意：所以，在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。 ¶4、删除指定列 将某列更新为NULL值，如果表定义允许NULL值。 123UPDATE customersSET cust_email = NULLWHERE cust_id = 10005; ¶5、删除所有行 普通方法： 1DELETE FROM students; 更快的方法： 使用TRUNCATE TABLE，它完成相同的工作，但速度更快（ TRUNCATE 实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。 ¶6、MySQL提示信息 使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。 12$ mysql&gt; DELETE FROM students WHERE id=1;Query OK, 1 row affected (0.01 sec) ¶四、实用SQL语句 ¶1、插入或替换 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用REPLACE语句。 1234567891011121314151617181920212223$ mysql&gt; REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);Query OK, 1 row affected (0.01 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | F | 99 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) ¶2、插入或更新 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用INSERT INTO ... ON DUPLICATE KEY UPDATE ...语句： 1234567891011121314151617181920212223$ mysql&gt; INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, ' 小明', 'F', 99) ON DUPLICATE KEY UPDATE name='小明', gender='F', score=98;Query OK, 2 rows affected (0.00 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | F | 98 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) ¶3、插入或忽略 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用INSERT IGNORE INTO ...语句。 1234567891011121314151617181920212223$ mysql&gt; INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);Query OK, 0 rows affected, 1 warning (0.00 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | F | 98 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) ¶4、快照 如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT。 可选的复制复制了一份，和该表结构一致。 12345678910111213141516171819202122232425$ mysql&gt; CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1;Query OK, 5 rows affected (0.09 sec)Records: 5 Duplicates: 0 Warnings: 0$ mysql&gt; SHOW TABLES;+--------------------+| Tables_in_test |+--------------------+| classes || students || students_of_class1 |+--------------------+3 rows in set (0.01 sec)$ mysql&gt; SELECT * FROM students_of_class1;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | F | 98 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 13 | 1 | 大宝 | M | 87 |+----+----------+--------+--------+-------+5 rows in set (0.00 sec) ¶5、写入查询结果集 如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。 先创建满足需求的表 1234567$ mysql&gt; CREATE TABLE result ( -&gt; id BIGINT NOT NULL AUTO_INCREMENT, -&gt; class_id BIGINT NOT NULL, -&gt; average DOUBLE NOT NULL, -&gt; PRIMARY KEY (id) -&gt; );Query OK, 0 rows affected (0.03 sec) 使用INSERT INTO ... SELECT ... FROM... 1234567891011121314$ mysql&gt; INSERT INTO result (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;Query OK, 4 rows affected (0.01 sec)Records: 4 Duplicates: 0 Warnings: 0$ mysql&gt; SELECT * FROM result;+----+----------+--------------+| id | class_id | average |+----+----------+--------------+| 1 | 1 | 90.2 || 2 | 2 | 78.4 || 3 | 3 | 88.333333333 || 4 | 5 | 88 |+----+----------+--------------+4 rows in set (0.00 sec) ¶6、强制使用指定索引 在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。 指定索引前提是索引（idx_class_id）必须存在！ 1$ SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"关系型数据库","slug":"数据库/关系型数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"修改","slug":"修改","permalink":"https://www.itnxd.cn/tags/%E4%BF%AE%E6%94%B9/"},{"name":"INSERT","slug":"INSERT","permalink":"https://www.itnxd.cn/tags/INSERT/"},{"name":"UPDATE","slug":"UPDATE","permalink":"https://www.itnxd.cn/tags/UPDATE/"},{"name":"DELETE","slug":"DELETE","permalink":"https://www.itnxd.cn/tags/DELETE/"}],"author":"Mr.Niu"},{"title":"JS实战之油猴脚本编写之知乎一键转载","slug":"JS实战之油猴脚本编写之知乎一键转载","date":"2020-06-07T14:23:46.000Z","updated":"2021-03-21T12:27:07.401Z","comments":true,"path":"posts/1495.html","link":"","permalink":"https://www.itnxd.cn/posts/1495.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶一、准备工作 根据所学JS知识以及又拍云小哥直播的讲解实战开发的一个小脚本！ 所有链接： 又拍云上直播地址：点击这里！ 又拍云油猴脚本开发：点击这里！ 我的油猴知乎实战脚本，点击这里！ ¶二、实现功能 隐藏回答界面的右边侧栏，提升阅读舒适性！ 加宽回答的可视区域，让您看的更加舒服！ 增加一个一键转载按钮（一键复制），禁止转载的给出提示信息！ 实现效果如下： ¶三、完整代码 脚本地址，点击这里！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// ==UserScript==// @name 知乎一键转载// @namespace http://tampermonkey.net/// @version 0.5// @description 模仿又拍云 demo 实现并修改的知乎一件转载，可以一键复制到剪贴板！隐藏知乎右边侧栏，加宽回答可视区域，使您阅读的更加舒服！欢迎食用！// @author NXD// @match https://www.zhihu.com/question/*// @grant GM_addStyle// ==/UserScript==// Question-sideColumn 隐藏右边栏GM_addStyle('.Question-sideColumn {display: none !important}');// 回答界面加宽GM_addStyle('.Question-mainColumn {width: 1000px !important}');(function() { 'use strict'; function createElement(eleName, text, attrs){ let ele = document.createElement(eleName); ele.innerText = text; for(let k in attrs){ ele.setAttribute(k, attrs[k]); } return ele; } // 复制到剪贴板函数 function addToClipboard(text){ navigator.clipboard.writeText(text).then(function() { // 一切都没问题的话会执行 alert 操作 alert('succeed copy'); }, function(err) { // 失败时执行的函数 console.info('failed copy', err); alert('faild copy') }); } // added 是一个全局变量, 用来保存已经添加过按钮的节点. let added = []; // 按钮样式 let btnStyle = 'background-color: #0084ff; margin-top: 15px; margin-bottom: 15px; margin-left:-5px; cursor:pointer; color: #fff; border-radius: 3px; border: 1px solid; padding: 3px 6px'; // 第一个回答 Card AnswerCard function addFirstBtn(){ // 获得第一个回答 let first = document.querySelector(\"#root &gt; div &gt; main &gt; div &gt; div.Question-main &gt; div.ListShortcut &gt; div &gt; div.Card.AnswerCard\"); // 获取每个回答的头部信息位置 let meta = first.querySelector('div[class=\"ContentItem-meta\"]'); // https://www.zhihu.com/question/398927155/answer/1266562835 获取到网址拿到最后的answer Id let who = meta.querySelector('meta[itemprop=\"url\"]').getAttribute('content').split('/').pop(); // 添加过的不再添加 if(added.indexOf(who) === -1){ // 没添加的插入数组 added.push(who); // 创建按钮 let btn = createElement('button', '转载按钮', {style: btnStyle}); // 获取文章内容 let text = first.querySelector('div[class=\"RichContent-inner\"]').innerText; // 将文章内容复制到剪贴板 btn.addEventListener('click', ()=&gt;{addToClipboard(text)}); meta.append(btn); } } // 更多回答：Card MoreAnswers function addBtn(){ // 更多回答 let all = document.querySelectorAll('div[class=\"List-item\"]'); for(let item of all){ // 获取每个回答的头部信息位置 let meta = item.querySelector('div[class=\"ContentItem-meta\"]'); // https://www.zhihu.com/question/398927155/answer/1266562835 获取到网址拿到最后的answer Id let who = meta.querySelector('meta[itemprop=\"url\"]').getAttribute('content').split('/').pop(); // 添加过的不再添加 if(added.indexOf(who) !== -1){ continue; } // 没添加的插入数组 added.push(who); // 创建按钮 let btn = createElement('button', '转载按钮', {style: btnStyle}); // 获取文章内容 let text = item.querySelector('div[class=\"RichContent-inner\"]').innerText; // 将文章内容复制到剪贴板 btn.addEventListener('click', ()=&gt;{addToClipboard(text)}); meta.append(btn); } } // 点击查看全部回答调用addBtn // 点击后 window.addEventListener('load', addBtn); // 点击前 // 1. 加载完调用 处理第一个回答 window.addEventListener('load', addFirstBtn); // 2. 随着滚动条调用后续方法 window.addEventListener('scroll', addBtn);})(); ¶四、代码实现介绍 模仿又拍云小哥demo实现，由于小哥原版的有一些bug，我做了简单修复，具体内容如下： 修复回答界面点击查看全部回答后第一个回答无法加载按钮的bug 修复点进回答界面第一个回答按钮无法加载需要触发滚动事件的bug 修复来修复去，又多了一个bug，点进查看全部回答界面似乎又不进行加载脚本了，我心累了！原脚本也有这个bug。 ¶1、油猴脚本头部 123456789// ==UserScript==// @name 知乎一键转载// @namespace http://tampermonkey.net/// @version 0.5// @description 模仿又拍云 demo 实现并修改的知乎一件转载，可以一键复制到剪贴板！隐藏知乎右边侧栏，加宽回答可视区域，使您阅读的更加舒服！欢迎食用！// @author NXD// @match https://www.zhihu.com/question/*// @grant GM_addStyle// ==/UserScript== name：脚本名称 version：版本 description：脚本描述 author：作者 match：匹配生效的网址 grant：导入油猴官方的API namespace：是命名空间，可以用你的网站名称 其他关键词及API请访问油猴文档！ ¶2、相关函数介绍 ¶2.1 GM_addStyle 油猴官方实现的接口用于写更方便的写CSS！ 怎么写CSS就怎么使用该方法。 1GM_addStyle('.Question-mainColumn {width: 1000px !important}'); ¶2.2 createElement 创建元素函数！ createElement(eleName, text, attrs)：元素名，元素内的文本信息，以及属性接收一个对象（即{}参数） ¶2.3 addToClipboard 复制到剪贴板函数！ 传入text参数，为复制的文本信息。 ¶2.4 addFirstBtn 由于不点击查看全部回答第一个回答和后续回答不一样，要格外设置一个函数去处理第一个回答！ 第一个回答的 class：Card AnswerCard 点击查看全部回答后的 class：Card MoreAnswers ¶2.5 addBtn 同样：处理没点击查看全部回答的后续回答（除了第一个不一样的）以及点击查看全部回答的所有回答。 ¶3、加载事件设置 window.addEventListener('load', addFirstBtn)：处理第一个不一样的回答 window.addEventListener('load', addBtn)：主要用于处理点击查看全部回答后的回答，加载完调用。 window.addEventListener('scroll', addBtn)：同时处理点击或每点击后续流式加载出现的回答，随滚动条加载。 防止出现重复添加按钮，使用added数组来判断：added.indexOf(who) !== -1 添加按钮即push到数组 没有添加则应该为 -1 12345678// 点击查看全部回答调用addBtn// 点击后window.addEventListener('load', addBtn);// 点击前// 1. 加载完调用 处理第一个回答window.addEventListener('load', addFirstBtn);// 2. 随着滚动条调用后续方法window.addEventListener('scroll', addBtn); ¶五、总结 一个脚本的编写需要去网页找到对应的元素class，获取到位置再进行操作 需要修复好多的bug，泪目啊！ 需要有HTML CSS JS知识，最好有强硬的JS能力。 这一次脚本编写也是极大的锻炼了我的JS实战能力，掌握了一些用法。虽然本脚本实现的功能较为简单与简陋，甚至有好多bug，但是我会在后续不断改进，完善的！ 很开心的一次实战！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JS实战","slug":"JS实战","permalink":"https://www.itnxd.cn/categories/JS%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"油猴脚本","slug":"油猴脚本","permalink":"https://www.itnxd.cn/tags/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"},{"name":"知乎","slug":"知乎","permalink":"https://www.itnxd.cn/tags/%E7%9F%A5%E4%B9%8E/"}],"author":"Mr.Niu"},{"title":"数据库教程之查询数据","slug":"数据库教程之查询数据","date":"2020-06-02T09:37:39.000Z","updated":"2021-09-13T07:54:02.092Z","comments":true,"path":"posts/16928.html","link":"","permalink":"https://www.itnxd.cn/posts/16928.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶一、准备数据 廖雪峰SQL教程例子：例子代码点击这里！ 将上方链接或者下方代码保存到文本文件，改名为init-test-data.sql。然后再本地cmd运行$ mysql -u root -p &lt; init-test-data.sql即可创建一个名为test的数据库，有两张表classes和students! 注意要在cmd，不要使用powershell，powershell无法识别命令行&lt;这个符号！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-- 如果test数据库不存在，就创建test数据库：CREATE DATABASE IF NOT EXISTS test;-- 切换到test数据库USE test;-- 删除classes表和students表（如果存在）：DROP TABLE IF EXISTS classes;DROP TABLE IF EXISTS students;-- 创建classes表：CREATE TABLE classes ( id BIGINT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 创建students表：CREATE TABLE students ( id BIGINT NOT NULL AUTO_INCREMENT, class_id BIGINT NOT NULL, name VARCHAR(100) NOT NULL, gender VARCHAR(1) NOT NULL, score INT NOT NULL, PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 插入classes记录：INSERT INTO classes(id, name) VALUES (1, '一班');INSERT INTO classes(id, name) VALUES (2, '二班');INSERT INTO classes(id, name) VALUES (3, '三班');INSERT INTO classes(id, name) VALUES (4, '四班');-- 插入students记录：INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'M', 90);INSERT INTO students (id, class_id, name, gender, score) VALUES (2, 1, '小红', 'F', 95);INSERT INTO students (id, class_id, name, gender, score) VALUES (3, 1, '小军', 'M', 88);INSERT INTO students (id, class_id, name, gender, score) VALUES (4, 1, '小米', 'F', 73);INSERT INTO students (id, class_id, name, gender, score) VALUES (5, 2, '小白', 'F', 81);INSERT INTO students (id, class_id, name, gender, score) VALUES (6, 2, '小兵', 'M', 55);INSERT INTO students (id, class_id, name, gender, score) VALUES (7, 2, '小林', 'M', 85);INSERT INTO students (id, class_id, name, gender, score) VALUES (8, 3, '小新', 'F', 91);INSERT INTO students (id, class_id, name, gender, score) VALUES (9, 3, '小王', 'M', 89);INSERT INTO students (id, class_id, name, gender, score) VALUES (10, 3, '小丽', 'F', 85);-- OK:SELECT 'ok' as 'result:'; ¶二、基本查询 ¶1、SELECT语句 使用SELECT * FROM students时，SELECT是关键字，表示将要执行一个查询，*表示“所有列”，FROM表示将要从哪个表查询，本例中是students表。 该SQL将查询出students表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。 12$ USE test;$ SELECT * FROM &lt;表名&gt;; ¶2、DISTINCT只返回不同值 用于返回不同的值！ DISTINCT 关键字应用于所有列而不仅是前置它的列。如果给出 SELECT DISTINCT vend_id,prod_price ，除非指定的两个列都不同，否则所有行都将被检索出来。 1SELECT DISTINCT vend_id FROM products; ¶3、用于计算的SELECT 上述查询会直接计算出表达式的结果。虽然SELECT可以用作计算，但它并不是SQL的强项。但是，不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1;来测试数据库连接。 1234567$ mysql&gt; SELECT 200 * 3000000000;+------------------+| 200 * 3000000000 |+------------------+| 600000000000 |+------------------+1 row in set (0.00 sec) ¶三、条件查询 ¶1、WHERE 条件 使用SELECT * FROM &lt;表名&gt;可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。 格式如下： 1$ SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt; 效果如下： ¶2、逻辑运算 与其他语言不同：等于号不是==而是=！ ¶2.1 AND 就是与运算符！ 12345678910$ mysql&gt; SELECT * FROM students WHERE score &gt;= 80 AND gender = 'M';+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 3 | 1 | 小军 | M | 88 || 7 | 2 | 小林 | M | 85 || 9 | 3 | 小王 | M | 89 |+----+----------+--------+--------+-------+4 rows in set (0.00 sec) ¶2.2 OR 就是或运算符！ 123456789101112131415$ mysql&gt; SELECT * FROM students WHERE score &gt;= 80 OR gender = 'M';+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 55 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 |+----+----------+--------+--------+-------+9 rows in set (0.00 sec) ¶2.3 NOT 就是非运算符！ MySQL支持使用 NOT 对 IN 、 BETWEEN 和EXISTS子句取反，这与多数其他 DBMS允许使用 NOT 对各种条件取反有很大的差别。 12345678910111213$ mysql&gt; SELECT * FROM students WHERE NOT class_id = 2;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 73 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 |+----+----------+--------+--------+-------+7 rows in set (0.00 sec) ¶2.4 多条件使用括号 同样：加括号改变了优先级！ 12345678$ mysql&gt; SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = 'M';+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 6 | 2 | 小兵 | M | 55 |+----+----------+--------+--------+-------+1 row in set (0.00 sec) ¶3、条件表达式符号 注意：不等于可以是!=或者是&lt;&gt;！ 字符串要用单引号引起来！ %可以匹配任意字符，包括空字符且不一定是一个字符！ 条件 表达式举例1 表达式举例2 说明 使用=判断相等 score = 80 name = ‘abc’ 字符串需要用单引号括起来 使用&gt;判断大于 score &gt; 80 name &gt; ‘abc’ 字符串比较根据ASCII码，中文字符比较根据数据库设置 使用&gt;=判断大于或相等 score &gt;= 80 name &gt;= ‘abc’ 使用&lt;判断小于 score &lt; 80 name &lt;= ‘abc’ 使用&lt;=判断小于或相等 score &lt;= 80 name &lt;= ‘abc’ 使用&lt;&gt;判断不相等 score &lt;&gt; 80 name &lt;&gt; ‘abc’ 使用!=判断不相等 score!=80 name!=‘abc’ 使用LIKE判断相似 name LIKE ‘ab%’ name LIKE ‘%bc%’ %表示任意字符，例如’ab%‘将匹配’ab’，‘abc’，‘abcd’ BETWEEN a AND b BETWEEN 80 AND 90 在指定两个值之间 IS NULL score IS NULL 指的是空，不是0，空字符串，空格，可能出现在建表时设置的NOT NULL的属性列 ¶4、 其他操作符 ¶4.1 IN IN 操作符用来指定条件范围，范围中的每个条件都可以进行匹配。 IN 取合法值的由逗号分隔的清单，全都括在圆括号中。 123IN (值1，值2....);SELECT * FROM student WHERE class_id IN (1,2) ORDER BY name; IN 与 OR相比的优点： 在使用长的合法选项清单时，IN 操作符的语法更清楚且更直观。 在使用 IN 时，计算的次序更容易管理（因为使用的操作符更少）。 IN 操作符一般比 OR 操作符清单执行更快。 IN 的最大优点是可以包含其他 SELECT 语句，使得能够更动态地建立 WHERE 子句。（后续会介绍） ¶4.2 LIKE LIKE 指示MySQL后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。 ¶4.2.1 百分号（%）通配符 % 表示任何字符出现任意（0,1，…）次数！ 此搜索区分大小写， 'jet%' 与 JetPack 1000 将不匹配。 可以出现在任意位置，可以出现任意多个。 例如：s%e,%ss% 注意： 尾空格：%abc无法匹配%abc&lt;空格&gt;，要想匹配可以在最后再加一个%abc%，后面会讲到一个更好的方法，使用函数 %无法匹配NULL。 ¶4.2.2 下划线（_）通配符 _只匹配单个（只能是1个）任意字符， 1SELECT prod_id, prod_name FROM products WHERE prod_name LIKE '_ abc'; ¶4.2.3 使用通配符的优缺点 可以使用通配符完成一些不易完成的搜索 使用通配符会带来效率的降低，会比其他搜索更耗时 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 ¶四、投影查询 使用SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。 如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用SELECT 列1, 列2, 列3 FROM ...，让结果集仅包含指定列。这种操作称为投影查询。 投影查询：仅返回指定列！ ¶1、普通投影 1$ SELECT 列1, 列2, 列3 FROM ...，; 例子如下： 12345678910111213141516$ mysql&gt; SELECT id, score, name FROM students;+----+-------+--------+| id | score | name |+----+-------+--------+| 1 | 90 | 小明 || 2 | 95 | 小红 || 3 | 88 | 小军 || 4 | 73 | 小米 || 5 | 81 | 小白 || 6 | 55 | 小兵 || 7 | 85 | 小林 || 8 | 91 | 小新 || 9 | 89 | 小王 || 10 | 85 | 小丽 |+----+-------+--------+10 rows in set (0.01 sec) ¶2、别名投影 1$ SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...; 例子如下：score 一列改别名为 points ！ 12345678910111213141516$ mysql&gt; SELECT id, score points, name FROM students;+----+--------+--------+| id | points | name |+----+--------+--------+| 1 | 90 | 小明 || 2 | 95 | 小红 || 3 | 88 | 小军 || 4 | 73 | 小米 || 5 | 81 | 小白 || 6 | 55 | 小兵 || 7 | 85 | 小林 || 8 | 91 | 小新 || 9 | 89 | 小王 || 10 | 85 | 小丽 |+----+--------+--------+10 rows in set (0.00 sec) ¶3、复杂投影 将投影与别名与WHERE条件查询结合！ 1234567891011mysql&gt; SELECT id, score points, name FROM students WHERE gender = 'M';+----+--------+--------+| id | points | name |+----+--------+--------+| 1 | 90 | 小明 || 3 | 88 | 小军 || 6 | 55 | 小兵 || 7 | 85 | 小林 || 9 | 89 | 小王 |+----+--------+--------+5 rows in set (0.00 sec) ¶五、排序 我们使用SELECT查询时，细心的读者可能注意到，查询结果集通常是按照id排序的，也就是根据主键排序。这也是大部分数据库的做法。 在给出 ORDER BY 子句时，应该保证它位于 FROM 子句之后。如果使用 LIMIT ，它必须位于 ORDER BY之后。使用子句的次序不对将产生错误消息。 ¶1、升序 使用 ORDER BY ***语句；ASC：升序，可省略！ 12345678910111213141516$ mysql&gt; SELECT id, name, gender, score FROM students ORDER BY score;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 6 | 小兵 | M | 55 || 4 | 小米 | F | 73 || 5 | 小白 | F | 81 || 7 | 小林 | M | 85 || 10 | 小丽 | F | 85 || 3 | 小军 | M | 88 || 9 | 小王 | M | 89 || 1 | 小明 | M | 90 || 8 | 小新 | F | 91 || 2 | 小红 | F | 95 |+----+--------+--------+-------+10 rows in set (0.00 sec) ¶2、降序 使用 ORDER BY *** DESC，DESC表示“倒序”，不可省略！ 12345678910111213141516$ mysql&gt; SELECT id, name, gender, score FROM students ORDER BY score DESC;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 2 | 小红 | F | 95 || 8 | 小新 | F | 91 || 1 | 小明 | M | 90 || 9 | 小王 | M | 89 || 3 | 小军 | M | 88 || 7 | 小林 | M | 85 || 10 | 小丽 | F | 85 || 5 | 小白 | F | 81 || 4 | 小米 | F | 73 || 6 | 小兵 | M | 55 |+----+--------+--------+-------+10 rows in set (0.00 sec) ¶3、复杂排序 ¶3.1 多列排序 若score列有相同的数据，要进一步排序，可以继续添加列名。 即先按score降序，再按gender升序（默认为ASC升序）。 1234567891011121314151617$ mysql&gt; SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 2 | 小红 | F | 95 || 8 | 小新 | F | 91 || 1 | 小明 | M | 90 || 9 | 小王 | M | 89 || 3 | 小军 | M | 88 || 10 | 小丽 | F | 85 || 7 | 小林 | M | 85 || 5 | 小白 | F | 81 || 4 | 小米 | F | 73 || 6 | 小兵 | M | 55 |+----+--------+--------+-------+10 rows in set (0.00 sec) ¶3.2 条件排序 如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面！ 12345678910111213$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; WHERE class_id = 1 -&gt; ORDER BY score DESC;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 2 | 小红 | F | 95 || 1 | 小明 | M | 90 || 3 | 小军 | M | 88 || 4 | 小米 | F | 73 |+----+--------+--------+-------+4 rows in set (0.00 sec) ¶六、分页查询 使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。 要实现分页功能，实际上就是从结果集中显示第1 ~ 100条记录作为第1页，显示第101 ~ 200条记录作为第2页，以此类推。 因此，分页实际上就是从结果集中“截取”出第M ~ N条记录。 通过LIMIT &lt;M&gt; OFFSET &lt;N&gt;子句实现：LIMIT表示每页最多三条信息，OFFSET表示从第几条开始。（SQL索引从0开始） 可以使用LIMIT控制要输出的结果！ ¶注意： OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。 在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15。 使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;分页时，随着N越来越大，查询效率也会越来越低。 ¶规则： 分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值： LIMIT总是设定为pageSize； OFFSET计算公式为pageSize * (pageIndex - 1)。 ¶如下： 1234567891011121314151617181920212223242526272829303132333435363738$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; ORDER BY score DESC -&gt; LIMIT 3 OFFSET 0;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 2 | 小红 | F | 95 || 8 | 小新 | F | 91 || 1 | 小明 | M | 90 |+----+--------+--------+-------+3 rows in set (0.00 sec)$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; ORDER BY score DESC -&gt; LIMIT 3 OFFSET 3;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 9 | 小王 | M | 89 || 3 | 小军 | M | 88 || 10 | 小丽 | F | 85 |+----+--------+--------+-------+3 rows in set (0.00 sec)...$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; ORDER BY score DESC -&gt; LIMIT 3 OFFSET 9;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 6 | 小兵 | M | 55 |+----+--------+--------+-------+1 row in set (0.00 sec) 若OFFSET设置的越界了，并不会报错，会返回一个空集合！ 12345$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; ORDER BY score DESC -&gt; LIMIT 3 OFFSET 20;Empty set (0.00 sec) ¶七、聚合（聚集）查询 对于统计总数、平均数这类计算，SQL提供了专门的聚合(聚集)函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。 ¶1、COUNT()函数 COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)。 可以设置一个别名，便于处理结果： COUNT(*)和COUNT(id)实际上是一样的效果。 如果指定列名，则指定列的值为空的行被 COUNT()函数忽略，但如果 COUNT() 函数中用的是星号（ * ），则不忽略。 12345678910111213141516$ mysql&gt; SELECT COUNT(*) FROM students;+----------+| COUNT(*) |+----------+| 10 |+----------+1 row in set (0.00 sec)-- 取一个别名 nummysql&gt; SELECT COUNT(*) num FROM students;+-----+| num |+-----+| 10 |+-----+1 row in set (0.00 sec) 同样可以使用WHERE条件 1234567mysql&gt; SELECT COUNT(*) boys FROM students WHERE gender = 'M';+------+| boys |+------+| 5 |+------+1 row in set (0.00 sec) ¶2、其他聚集函数 注意，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。 注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL： 函数 说明 SUM 计算某一列的合计值，该列必须为数值类型，SUM() 函数忽略列值为 NULL 的行 AVG 计算某一列的平均值，该列必须为数值类型，AVG() 函数忽略列值为 NULL 的行。 MAX 计算某一列的最大值，MAX() 函数忽略列值为 NULL 的行 MIN 计算某一列的最小值，MIN() 函数忽略列值为 NULL 的行 CEILING 上取整 FLOOR 下取整 12345678910111213141516171819202122232425262728$ mysql&gt; SELECT AVG(score) average FROM students WHERE gender = 'M';+---------+| average |+---------+| 81.4000 |+---------+1 row in set (0.01 sec)-- WHERE找不到返回NULL$ mysql&gt; SELECT AVG(score) average FROM students WHERE gender = 'X';+---------+| average |+---------+| NULL |+---------+1 row in set (0.00 sec)-- 计算页数$ SELECT CEILING(COUNT(*) / 3) pageSize FROM students;mysql&gt; SELECT CEILING(COUNT(*) / 3) pageSize FROM students;+----------+| pageSize |+----------+| 4 |+----------+1 row in set (0.00 sec) ¶3、使用DISTINCT 默认为ALL，可选DISTINCT，即去掉重复值 上面的聚集（聚合）函数都可以使用DISTINCT来去重计算 对于MIN，MAX添加该参数无意义，因为去不去重结果无影响！ 下面的这个例子就是将价格不同的过滤掉，仅计算价格不同的均值。 12345678SELECT AVG(DISTINCT prod_price) avg_riceFROM productsWHERE vend_id = 1003;+-----------+| avg_price |+-----------+| 15 .998000|+-----------+ ¶4、组合聚集函数 即一条语句使用多个聚集函数。 12345SELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS price_max,AVG(prod_price) AS price_avgFROM products; ¶八、多表查询 由于多表查询的笛卡尔乘积问题，会导致每行两表的数据并没有逻辑对应关系。。。 即直接查出来的数据对应不一定正确，需要进行条件限定，如students表的class_id 与 classes表的id相同才能唯一确定一个对应关系。 一般使用主键或外键进行多表关联查询，笛卡尔乘积没太多意义，而且很容易查询量爆炸，不建议使用！ ¶1、语法： SELECT * FROM &lt;表1&gt; &lt;表2&gt;。 这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。 这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。 给表起别名，再给相同列起别名有助于查看！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$ mysql&gt; SELECT -&gt; s.id sid, -&gt; s.name, -&gt; s.gender, -&gt; s.score, -&gt; c.id cid, -&gt; c.name cname -&gt; FROM students s, classes c;+-----+--------+--------+-------+-----+--------+| sid | name | gender | score | cid | cname |+-----+--------+--------+-------+-----+--------+| 1 | 小明 | M | 90 | 1 | 一班 || 1 | 小明 | M | 90 | 2 | 二班 || 1 | 小明 | M | 90 | 3 | 三班 || 1 | 小明 | M | 90 | 4 | 四班 || 2 | 小红 | F | 95 | 1 | 一班 || 2 | 小红 | F | 95 | 2 | 二班 || 2 | 小红 | F | 95 | 3 | 三班 || 2 | 小红 | F | 95 | 4 | 四班 || 3 | 小军 | M | 88 | 1 | 一班 || 3 | 小军 | M | 88 | 2 | 二班 || 3 | 小军 | M | 88 | 3 | 三班 || 3 | 小军 | M | 88 | 4 | 四班 || 4 | 小米 | F | 73 | 1 | 一班 || 4 | 小米 | F | 73 | 2 | 二班 || 4 | 小米 | F | 73 | 3 | 三班 || 4 | 小米 | F | 73 | 4 | 四班 || 5 | 小白 | F | 81 | 1 | 一班 || 5 | 小白 | F | 81 | 2 | 二班 || 5 | 小白 | F | 81 | 3 | 三班 || 5 | 小白 | F | 81 | 4 | 四班 || 6 | 小兵 | M | 55 | 1 | 一班 || 6 | 小兵 | M | 55 | 2 | 二班 || 6 | 小兵 | M | 55 | 3 | 三班 || 6 | 小兵 | M | 55 | 4 | 四班 || 7 | 小林 | M | 85 | 1 | 一班 || 7 | 小林 | M | 85 | 2 | 二班 || 7 | 小林 | M | 85 | 3 | 三班 || 7 | 小林 | M | 85 | 4 | 四班 || 8 | 小新 | F | 91 | 1 | 一班 || 8 | 小新 | F | 91 | 2 | 二班 || 8 | 小新 | F | 91 | 3 | 三班 || 8 | 小新 | F | 91 | 4 | 四班 || 9 | 小王 | M | 89 | 1 | 一班 || 9 | 小王 | M | 89 | 2 | 二班 || 9 | 小王 | M | 89 | 3 | 三班 || 9 | 小王 | M | 89 | 4 | 四班 || 10 | 小丽 | F | 85 | 1 | 一班 || 10 | 小丽 | F | 85 | 2 | 二班 || 10 | 小丽 | F | 85 | 3 | 三班 || 10 | 小丽 | F | 85 | 4 | 四班 |+-----+--------+--------+-------+-----+--------+40 rows in set (0.00 sec) ¶2、使用WHERE 同样可以使用WHERE进行限制。 12345678910111213141516171819mysql&gt; SELECT -&gt; s.id sid, -&gt; s.name, -&gt; s.gender, -&gt; s.score, -&gt; c.id cid, -&gt; c.name cname -&gt; FROM students s, classes c -&gt; WHERE s.gender = 'M' AND c.id = 1;+-----+--------+--------+-------+-----+--------+| sid | name | gender | score | cid | cname |+-----+--------+--------+-------+-----+--------+| 1 | 小明 | M | 90 | 1 | 一班 || 3 | 小军 | M | 88 | 1 | 一班 || 6 | 小兵 | M | 55 | 1 | 一班 || 7 | 小林 | M | 85 | 1 | 一班 || 9 | 小王 | M | 89 | 1 | 一班 |+-----+--------+--------+-------+-----+--------+5 rows in set (0.01 sec) ¶九、连接（联结）查询 连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。 ¶1、INNER JOIN查询（内连接） 现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。 这时，连接查询就派上了用场。 看下方结果，就知道这是连接了classes表的name列，尽可能满足两个表情况，不会出现NULL的情况。 先确定主表，仍然使用FROM &lt;表1&gt;的语法； 再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法； 然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接； 可选：加上WHERE子句、ORDER BY等子句。 示例图如下： 代码如下： 12345678910111213141516171819$ mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; INNER JOIN classes c -&gt; ON s.class_id = c.id;+----+--------+----------+------------+--------+-------+| id | name | class_id | class_name | gender | score |+----+--------+----------+------------+--------+-------+| 1 | 小明 | 1 | 一班 | M | 90 || 2 | 小红 | 1 | 一班 | F | 95 || 3 | 小军 | 1 | 一班 | M | 88 || 4 | 小米 | 1 | 一班 | F | 73 || 5 | 小白 | 2 | 二班 | F | 81 || 6 | 小兵 | 2 | 二班 | M | 55 || 7 | 小林 | 2 | 二班 | M | 85 || 8 | 小新 | 3 | 三班 | F | 91 || 9 | 小王 | 3 | 三班 | M | 89 || 10 | 小丽 | 3 | 三班 | F | 85 |+----+--------+----------+------------+--------+-------+10 rows in set (0.01 sec) ¶2、RIGHT OUTER JOIN（右外连接） 尽量满足第二个表的情况，第一个表若没有对应的信息，会以NULL显示： 注意：左右外连接可以省略写OUTER。 示例图如下： 代码如下： 1234567891011121314151617181920$ mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; RIGHT OUTER JOIN classes c -&gt; ON s.class_id = c.id;+------+--------+----------+------------+--------+-------+| id | name | class_id | class_name | gender | score |+------+--------+----------+------------+--------+-------+| 1 | 小明 | 1 | 一班 | M | 90 || 2 | 小红 | 1 | 一班 | F | 95 || 3 | 小军 | 1 | 一班 | M | 88 || 4 | 小米 | 1 | 一班 | F | 73 || 5 | 小白 | 2 | 二班 | F | 81 || 6 | 小兵 | 2 | 二班 | M | 55 || 7 | 小林 | 2 | 二班 | M | 85 || 8 | 小新 | 3 | 三班 | F | 91 || 9 | 小王 | 3 | 三班 | M | 89 || 10 | 小丽 | 3 | 三班 | F | 85 || NULL | NULL | NULL | 四班 | NULL | NULL |+------+--------+----------+------------+--------+-------+11 rows in set (0.01 sec) ¶3、LEFT OUTER JOIN（左外连接） 尽量满足第一个表的情况，第二个表若没有对应信息，会以NULL显示： 由于students表都可以在classes表匹配，所以添加一行吧唧id为5的，来说明左外连接问题。 示例图如下： 代码如下： 123456789101112131415161718192021222324-- $ mysql&gt; INSERT INTO students (class_id, name, gender, score) values (5, '新生', 'M', 88);Query OK, 1 row affected (0.01 sec)$ mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; LEFT OUTER JOIN classes c -&gt; ON s.class_id = c.id;+----+--------+----------+------------+--------+-------+| id | name | class_id | class_name | gender | score |+----+--------+----------+------------+--------+-------+| 1 | 小明 | 1 | 一班 | M | 90 || 2 | 小红 | 1 | 一班 | F | 95 || 3 | 小军 | 1 | 一班 | M | 88 || 4 | 小米 | 1 | 一班 | F | 73 || 5 | 小白 | 2 | 二班 | F | 81 || 6 | 小兵 | 2 | 二班 | M | 55 || 7 | 小林 | 2 | 二班 | M | 85 || 8 | 小新 | 3 | 三班 | F | 91 || 9 | 小王 | 3 | 三班 | M | 89 || 10 | 小丽 | 3 | 三班 | F | 85 || 11 | 新生 | 5 | NULL | M | 88 |+----+--------+----------+------------+--------+-------+11 rows in set (0.01 sec) ¶4、FULL OUTER JOIN（全外连接） 也就是左右外连接的并集，没有的信息显示为NULL： MySQL并不支持全连接。。。 示例图如下： 代码如下： 123456$ mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; FULL OUTER JOIN classes c -&gt; ON s.class_id = c.id;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FULL OUTER JOIN classes cON s.class_id = c.id' at line 3 代替解决方案：使用UNION，左连接一次，右连接一次，再使用UNION合并。 代码如下： 123456789101112131415161718192021222324mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; RIGHT OUTER JOIN classes c ON class_id = c.id -&gt; UNION -&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; LEFT OUTER JOIN classes c ON class_id = c.id;+------+--------+----------+------------+--------+-------+| id | name | class_id | class_name | gender | score |+------+--------+----------+------------+--------+-------+| 1 | 小明 | 1 | 一班 | M | 90 || 2 | 小红 | 1 | 一班 | F | 95 || 3 | 小军 | 1 | 一班 | M | 88 || 4 | 小米 | 1 | 一班 | F | 73 || 5 | 小白 | 2 | 二班 | F | 81 || 6 | 小兵 | 2 | 二班 | M | 55 || 7 | 小林 | 2 | 二班 | M | 85 || 8 | 小新 | 3 | 三班 | F | 91 || 9 | 小王 | 3 | 三班 | M | 89 || 10 | 小丽 | 3 | 三班 | F | 85 || NULL | NULL | NULL | 四班 | NULL | NULL || 11 | 新生 | 5 | NULL | M | 88 |+------+--------+----------+------------+--------+-------+12 rows in set (0.00 sec) ¶十、正则搜索查询 可以使用正则的所有语法！ 参考我之前的Java教程的正则表达式！，以及JavaScript教程的正则表达式！，以及加强版的正则表达式! 这里只介绍一些不同点！ 12345678910111213141516mysql&gt; SELECT * FROM students WHERE score REGEXP '8\\\\d';+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 7 | 2 | 小林 | M | 85 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+10 rows in set (0.00 sec) ¶1、语法格式 与LIKE的通配符类似！ 注意： mysql的正则表达式不区分大小写，指的是这样子的 SELECT 'jack 001' REGEXP 'Jack 001'; 可以加上BINARY来区分大小写，eg：SELECT 'jack 001' REGEXP BINARY 'Jack 001'; 123SELECT * FROM students WHERE score REGEXP '8\\\\d';SELECT * FROM students WHERE score LIKE '8%'; 特殊字符格式： \\\\- \\\\. \\\\| \\\\( \\\\{ \\\\[ 以及 \\\\f \\\\r \\\\t \\\\v分别表示换页，换行，回车，制表符，纵向制表符。 \\\\\\表示\\ 匹配字符类： 存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。为更方便工作，可以使用预定义的字符集，称为字符类. 如下： 1SELECT 'HHH123' REGEXP '[[:digit:]]{3}'; ¶2、使用SELECT进行简单测试 匹配返回 1，不匹配返回 0 LIKE和REGEXP都可以！ 12345678910111213141516mysql&gt; SELECT 'habc123' LIKE 'ha%3';+-----------------------+| 'habc123' LIKE 'ha%3' |+-----------------------+| 1 |+-----------------------+1 row in set (0.00 sec)-- 如下mysql&gt; SELECT 'habc123' REGEXP '^\\\\w*\\\\d{3}$';+---------------------------------+| 'habc123' REGEXP '^\\\\w*\\\\d{3}$' |+---------------------------------+| 1 |+---------------------------------+1 row in set (0.00 sec) ¶3、REGEXP 和 LIKE 一些区别： REGEXP可以匹配子串，只要有子串匹配就可以返回真值，当然也可以匹配原串。 LIKE只能匹配原串，必须将原串全部匹配才可。 ¶十一、创建计算字段 创建计算字段主要是为了格式化输出，可以获得需要的输出结果！ 其他DBMS使用 + ，||来实现拼接来处理格式化，MySql使用Concat()函数进行拼接来处理格式化。 这类普通函数与聚集函数写法规范略有不同，聚集函数全部大写如AVG()，普通函数首字母大写Concat()。 这仅仅是一个规定，约定俗成的规矩，大小写MySql是忽略的。 ¶1、使用Concat()函数 1234567891011121314151617181920mysql&gt; SELECT Concat(name, ' ---------- ', score) name_score FROM students;+----------------------+| name_score |+----------------------+| 小明 ---------- 98 || 小红 ---------- 95 || 小军 ---------- 88 || 小米 ---------- 83 || 小白 ---------- 81 || 小兵 ---------- 65 || 小林 ---------- 85 || 小新 ---------- 91 || 小王 ---------- 89 || 小丽 ---------- 85 || 新生 ---------- 88 || 大牛 ---------- 80 || 大宝 ---------- 87 || 二宝 ---------- 81 |+----------------------+14 rows in set (0.00 sec) 同样可以使用一些其他函数来进行控制，使用别名来替换该字段： 这里用到了RTrim()，LTrim()，Trim()，来进行配合，分别为去掉右边空格，左边空格，及两边空格！ 也可以使用别名来重命名该列。 别名可以使用a AS b来表示，也可以直接空格隔开，两种写法完全一致，但一般空格隔开即可！ 123SELECT Concat(RTrim(name), ' - ', LTrim(score)) name_score FROM students;SELECT Concat(RTrim(name), ' - ', LTrim(score)) AS name_score FROM students; ¶2、执行算术计算 可以使用+-*/来进行计算得到新的一列。 1234SELECT prod_id, quantity, item_price,quantity * item_price expanded_priceFROM orderitemsWHERE order_num = 20005; 可以使用SELECT的测试功能来简单测试一下 123456789101112131415mysql&gt; SELECT Trim(' bsd ');+----------------------+| Trim(' bsd ') |+----------------------+| bsd |+----------------------+1 row in set (0.00 sec)mysql&gt; SELECT 3 * 5;+-------+| 3 * 5 |+-------+| 15 |+-------+1 row in set (0.01 sec) ¶十二、其他普通函数 ¶1、文本处理函数 SOUNDEX 是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。 SOUNDEX 考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然SOUNDEX 不是SQL概念，但MySQL（就像多数DBMS一样）都提供对SOUNDEX的支持。 可以在你拼错的时候返回正确的匹配项！有发音相似性匹配。。神奇！ 12345678910111213141516mysql&gt; SELECT Soundex('Lie') = Soundex('Lee');+---------------------------------+| Soundex('Lie') = Soundex('Lee') |+---------------------------------+| 1 |+---------------------------------+1 row in set (0.00 sec)SELECT cust_name，cust_contactFROM customersWHERE Soundex(cust_contact) = Soundex('Y Lie');+-------------+--------------+| cust_name | cust_contact || Coyote Inc. | Y Lee |+-------------+--------------+ ¶2、日期和时间处理函数 日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和有效地排序或过滤，并且节省物理存储空间。 主要是从DATETIME数据类型中截取需要的数据！ 部分示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950mysql&gt; SELECT Now();+---------------------+| Now() |+---------------------+| 2020-06-29 21:45:11 |+---------------------+1 row in set (0.01 sec)mysql&gt; SELECT Date('2020--06-29 00:00:00');+------------------------------+| Date('2020-06-29 00:00:00') |+------------------------------+| 2020-06-29 |+------------------------------+1 row in set (0.01 sec)mysql&gt; SELECT DayOfWeek('2020-06-29 00:00:00');+-----------------------------------+| DayOfWeek('2020-06-29 00:00:00') |+-----------------------------------+| 2 |+-----------------------------------+1 row in set (0.01 sec)mysql&gt; SELECT Now();+---------------------+| Now() |+---------------------+| 2020-06-29 21:56:31 |+---------------------+1 row in set (0.00 sec)mysql&gt; SELECT CurTime();+-----------+| CurTime() |+-----------+| 21:57:09 |+-----------+1 row in set (0.01 sec)-- 实际用于按日期，时间等匹配日期-- 此处的order_date为datetime类型：SEL ECT cust_id，order_numFROM ordersWHERE Date(order_date) = '2020-09-01';-- 使用 Between AndSELECT cust_id，order_numFROM ordersWHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30'; ¶3、数值处理函数 数值处理函数仅处理数值数据。这些函数一般主要用于代数、三角或几何运算，因此没有串或日期 — 时间处理函数的使用那么频繁。具有讽刺意味的是，在主要DBMS的函数中，数值函数是最一致最统一的函数。 ¶十三、分组（GROUP） 用于统计一类数据的方法：GROUP BY 某一列 HAVING 条件 GROUP BY 子句中列出的每个列都必须是检索列或有效的表达式(eg:nums * score)（但不能是聚集函数）。如果在 SELECT 中使用表达式，则必须在GROUP BY 子句中指定相同的表达式。不能使用别名。 除聚集计算语句外， SELECT 语句中的每个列都必须在 GROUP BY 子句中给出。 如果分组列中具有 NULL 值，则 NULL 将作为一个分组返回。如果列中有多行 NULL 值，它们将分为一组。 GROUP BY 子句必须出现在 WHERE 子句之后， ORDER BY 子句之前。 ¶1、单列分组 123456789$ mysql&gt; SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;+----------+-----+| class_id | num |+----------+-----+| 1 | 4 || 2 | 3 || 3 | 3 |+----------+-----+3 rows in set (0.00 sec) ¶2、多列分组 123456789101112$ mysql&gt; SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;+----------+--------+-----+| class_id | gender | num |+----------+--------+-----+| 1 | M | 2 || 1 | F | 2 || 2 | F | 1 || 2 | M | 2 || 3 | F | 2 || 3 | M | 1 |+----------+--------+-----+6 rows in set (0.00 sec) 注意：SQL引擎不能把多个name的值放入一行记录中。因此，聚合查询的列中，只能放入分组的列。 原因：class_id = 1 有 4 个人，他们班级名相同，但name不同，如果有了name列，应该显示几个名字呢？？？ 所以干脆直接报错！ 12$ mysql&gt; SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.students.name' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by ¶3、WITH ROLLUP 在GROUP BY后面加WITH ROLLUP来进行统计分组的总行数。 如下方的最后一行！ 1234567891011mysql&gt; SELECT class_id, COUNT(*) total FROM students GROUP BY class_id WITH ROLLUP;+----------+-------+| class_id | total |+----------+-------+| 1 | 5 || 2 | 5 || 3 | 3 || 5 | 1 || NULL | 14 |+----------+-------+5 rows in set (0.01 sec) ¶4、对分组的过滤 WHERE用于过滤行，HAVING用于过滤分组。 语法与WHERE一模一样。 WHERE 在数据分组前进行过滤， HAVING 在数据分组后进行过滤。 123456789mysql&gt; SELECT class_id, COUNT(*) total FROM students GROUP BY class_id HAVING COUNT(*) &gt;= 3;+----------+-------+| class_id | total |+----------+-------+| 1 | 5 || 2 | 5 || 3 | 3 |+----------+-------+3 rows in set (0.01 sec) ¶全部使用的顺序 SELECT子句顺序：SELECT (FROM) (WHERE) (GROUP BY) (ORDER BY) (LIMIT) 括号表示可选！ 12345678910111213mysql&gt; SELECT class_id, COUNT(*) total -&gt; FROM students -&gt; WHERE gender = 'M' -&gt; GROUP BY class_id HAVING COUNT(*) &gt;= 2 -&gt; ORDER BY total -&gt; LIMIT 3;+----------+-------+| class_id | total |+----------+-------+| 1 | 2 || 2 | 4 |+----------+-------+2 rows in set (0.01 sec) ¶十四、子查询 就是嵌套的多级SELECT语句。 使用连接（联结）通常比子查询要更快！ ¶1、利用子查询进行过滤 子查询总是从内向外处理，使用适当的缩进可以更易于阅读和调试。内层子查询的结果作为上层的基础进行查询，如下所示，将内层查询结果转变为IN的格式进行下一次查询。 不仅仅可以使用IN，其他的操作符都是可以的，LIKE，&gt;，，，等等都可以！ 嵌套太多会降低性能，不建议嵌套太多！ 注意：要保证WHERE的列与子查询SELECT的列相同！ 同样：使用多表连接通过WHERE也可以实现相同效果。 1234567891011121314151617181920SELECT cust_name，cust_contactFROM customersWHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2'));+----------------+--------------+| cust_name | cust_contact || Coyote InC. | Y Lee || Yosemite P1ace | Y Sam |+----------------+--------------+-- 完全相同SELECT cust_name，cust_contactFROM customers，orders，orderitemsWHERE customers.cust_id = orders.cust_idAND orderitems.order_num = orders.order_numAND prod_id = 'TNT2' ; ¶2、利用子查询处理计算字段 除了在WHERE后进行过滤，还可以在WHERE前进行计算字段的查询处理！ 这里使用了完全限定列名，即使用表.列 orders.cust_id来进行限定列的范围，当然是为了防止多表存在相同列名。 1234567891011121314151617SELECT cust_name, cust_state， (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS orders FROM customersORDER BY cust_name;+----------------+------------+--------+| cust_name |cust_state | orders |+----------------+------------+--------+| Coyote Inc. | MI | 2 || E Fudd | IL | 1 || Mouse House | 0H | 0 || Wascals | IN | 1 || Yosemite Place | AZ | 1 |+----------------+------------+--------+ ¶十五、组合查询 即使用UNION来合并多条SELECT语句。 ¶1、UNION 和 WHERE UNION 几乎总是完成与多个WHERE 条件相同的工作。 UNION ALL 为 UNION 的一种形式，它完成WHERE 子句完成不了的工作。如果确实需要每个条件的匹配行全部出现（包括重复行），则必须使用 UNION ALL 而不是 WHERE 。 UNION 中的每个查询必须包含相同的列、表达式或聚集函数！ 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。 ¶2、UNION 会过滤重复行！ 1234567SELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5UNIONSELECT vend_id，prod_id，prod_priceFROM productsWHERE vend_id IN (1001,1002); ¶3、UNION ALL 不会过滤重复行！ 1234567SELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5UNION ALLSELECT vend_id，prod_id，prod_priceFROM productsWHERE vend_id IN (1001,1002); ¶4、组合结果排序 只能在最后使用一条ORDER BY 进行排序，排序作用于UNION的结果！ 12345678SELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5UNION ALLSELECT vend_id，prod_id，prod_priceFROM productsWHERE vend_id IN (1001,1002)ORDER BY ven_id, prod_price; ¶十六、全文本搜索 ¶1、两种引擎 InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索，但支持事务处理。 MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。 性能：通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行（而且这些搜索极少使用表索引）。因此，由于被搜索行数不断增加，这些搜索可能非常耗时。 明确控制：使用通配符和正则表达式匹配，很难（而且并不总是能）明确地控制匹配什么和不匹配什么。例如，指定一个词匹配和指定一个词不匹配… 智能化的结果：虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索，但它们都不能提供一种智能化的选择结果的方法。例如：一个特殊词的搜索将会返回包含这些词的所有行，而不区分包含单个匹配的行和包含多个匹配的行（按照可能是更好地匹配来排列它们）。类似，一个特殊词的搜索将不会找出不包含该词但包含其他相关词的行。 所有这些限制以及更多的限制都可以用全文本搜索来解决，在使用全文本搜索时，MySQL不需要分别查看每个行，不需要分别分析和处理每个词。MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行。这样，MySQL可以快速有效的决定那些词分配（那些行包含它们），那些词不匹配，它们匹配的频率，等等。 ¶2、启用全文本搜索 这些列中有一个名为note_text的列，为了进行全文本搜索，MySQL根据字句FULLTEXT(note_text)的指示对它进行了索引，这里的FULLTEXT索引单个列，如果需要也可以指定多个列。 在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，索引随之自动更新。 可以在创建表时指定FULLTEXT，或者在稍后指定。但是不要在导入数据时使用FULLTEXT，因为更新索引需要时间，虽然不是很多，但毕竟要花时间。如果正在导入数据到一个新表，此时不应该启用FULLTEXT索引。应该首先导入所有数据，然后在修改表，定义FULLTEXT，这要有助于更快地导入数据（而且使索引的总时间小于在导入每行每行时分别进行索引所需的总时间）。 在建表最后指出引擎：ENGINE=MyISAM 123456789CREATE TABLE productnotes ( note_id int NOT NULL AUTO_INCREMENT, prod_id char(10) NOT NULL, note_text text NOT NULL, note_date datetime NOT NULL, PRIMARY KEY(note_id), FULLTEXT(note_text))ENGINE=MyISAM; ¶3、进行全文本搜索 全文本搜索用到的两个函数： 传递给Match的值必须与FULLTEXT()定义中的相同，如果指定多个列，则必须列出它们（而且次序相同）。 搜索不区分大小写，除非使用BINARY方式。 全文本搜索的一个重要部分就是对结果排序。具有较高等级（单词出现的位置靠前，数量多的优先级更高）的行先返回。LIKE同样可以实现，但是由于使用通配符搜索，效率低，速度慢，且输出无序！ Match()指定被搜索的列 Against()指定要使用的搜索表达式。 1234567SELECT note_textFROM productnotesWHERE Match(note_text) Against('rabbit');SELECT note_textFROM productnotesWHERE note_text LIKE '%rabbit%'; 如下：可以返回每行计算后的优先级作为RANK一列！ 等级由MySQL根据行中词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来。 123SELECT note_text Match(note_text) Against('rabbit') AS RANKFROM productnotes; ¶4、使用查询拓展 查询扩展用来设法放宽所返回的全文本搜索结果的范围。 在Against内添加WITH QUERY EXPANSION表名使用查询拓展！ 使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索： 首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有航 其次，MySQL检查这些匹配行并选择所有有用的词 再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还是用使用所有有用的词 123SELECT note_textFROM productnotesWHERE Match(note_text) Against('anvils' WITH QUERY EXPANSION) ; ¶5、布尔文本搜索 MySQL支持全文本搜索的另外一种形式，称为布尔方式（boolean mode）。 即使没有FULLTEXT索引也可以使用 布尔方式不同于迄今为止使用的全文本搜索语法的地方在于，即使没有定义fulltext索引，也可以使用它。但是这是一种非常缓慢的操作（其性能随着数据量的增加而降低）。 在Against内添加 IN BOOLEAN MODE来表名使用布尔文本搜索！ 此全文本搜索检索包含词heavy的所有行（有两行）。其中使用了关键字IN BOOLEAN MODE，但实际上没有指定布尔操作符，因此，其结果与没有指定布尔方式的结果相同： 123SELECT note_textFROM productnotesWHERE Match(note_text) Against('heavy' IN BOOLEAN MODE); 可匹配包含heavy但不包含任意以rope开始的词的所有行： 123SELECT` `note_textFROM` `productnotesWHERE` `Match(note_text) Against('heavy -rope*' IN BOOLEAN MODE); 全文本布尔操作符： 布尔操作符 说明 + 包含，词必须存在 - 排除，词必须不出现 &gt; 包含，而且增加等级值 &lt; 包含，而且减少等级制 () 把词组成表达式(允许这些子表达式作为一个组被包含、排除、排列等) ~ 取消一个词的排序值 * 词尾的通配符 “” 定义一个短语(与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语) 部分示例如下： 1234567891011121314151617181920212223242526272829SELECT note_textFROM productnotesWHERE Match(note_text) Against('+rabbit +bait' IN BOOLEAN MODE);这个搜索匹配包含词rabbit和bait的行 SELECT note_textFROM productnotesWHERE Match(note_text) Against('rabbit bait' IN BOOLEAN MODE);没有指定操作符，这个搜索匹配包含词rabbit和bait中的至少一个词的行； SELECT note_textFROM productnotesWHERE Match(note_text) Against('“rabbit bait”' IN BOOLEAN MODE);这个搜索匹配短语rabbit bait，而不是匹配两个词； SELECT note_textFROM productnotesWHERE Match(note_text) Against('&gt;rabbit &lt;carrot' IN BOOLEAN MODE);这个搜索匹配rabbit 和carrot，增加前者的等级，降低后者的等级； SELECT note_textFROM productnotesWHERE Match(note_text) Against('+safe +(&lt;combination)' IN BOOLEAN MODE);这个搜索匹配safe 和combination，降低后者的等级； 小总结： 全文本搜索数据时，短词被忽略而且从索引中删除。短词定义为那些具有3个或者3个以下字符的词（如果需要，这个数目可以修改）。 MySQL带有一个内建的非用词（``stopword`）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参阅MySQL文档以了解如何完成此工作）。 许多词出现的频率高，搜索它们没有用处（返回太多的结果），因此，MySQL定义了一条50%的规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN MODE 如果表中的行数小于3行，则全文本搜索将不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。 忽略词中的单引号 ’ 。例如， don't 索引为 dont 。 仅在MyISAM的数据库引擎中支持全文本搜索。 不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。 数据库教程之查询数据已完成！敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"关系型数据库","slug":"数据库/关系型数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SELECT","slug":"SELECT","permalink":"https://www.itnxd.cn/tags/SELECT/"},{"name":"查询","slug":"查询","permalink":"https://www.itnxd.cn/tags/%E6%9F%A5%E8%AF%A2/"}],"author":"Mr.Niu"},{"title":"数据库教程之基础知识","slug":"数据库教程之基础知识","date":"2020-05-26T10:39:46.000Z","updated":"2021-09-13T07:54:06.461Z","comments":true,"path":"posts/15411.html","link":"","permalink":"https://www.itnxd.cn/posts/15411.html","excerpt":"","text":"¶一、什么是数据库 ¶1、数据库（database） 保存有组织的数据的容器（通常是一个文件或一组文件）。 ¶2、数据库与数据库软件 数据库（database）：数据库可以是保存在硬设备上的文件，但也可以不是。 数据库软件（DBMS数据库管理系统）：数据库是通过DBMS创建和操纵的容器，使用DBMS来替你访问数据库。 ¶3、表 在你将资料放入自己的文件柜时，并不是随便将它们扔进某个抽屉就完事了，而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。 在数据库领域中，这种文件称为表。表是一种结构化的文件，可用来存储某种特定类型的数据。表可以保存顾客清单、产品目录，或者其他信息清单。 表（table）： 某种特定类型数据的结构化清单。 ¶表名 数据库中的每个表都有一个名字，用来标识自己。此名字是唯一的，这表示数据库中没有其他表具有相同的名字。 表名的唯一性取决于多个因素，如数据库名和表名等的结合。这表示，虽然在相同数据库中不能两次使用相同的表名，但在不同的数据库中却可以使用相同的表名。 ¶模式 表具有一些特性，这些特性定义了数据在表中如何存储，如可以存储什么样的数据，数据如何分解，各部分信息如何命名等等。描述表的这组信息就是所谓的模式，模式可以用来描述数据库中特定的表以及整个数据库（和其中表的关系）。 模式（schema）：关于数据库和表的布局及特性的信息。 ¶4、列 表由列组成。列中存储着表中某部分的信息。 列（字段）定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串''。 通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。 列（column） ：表中的一个字段。所有表都是由一个或多个列组成的。 ¶5、数据类型 数据类型（datatype）： 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。 ¶6、行 是记录还是行？ 你可能听到用户在提到行（row）时称其为数据库记录（record）。在很大程度上，这两个术语是可以互相替代的，但从技术上说，行才是正确的术语。 行（row）： 表中的一个记录。 ¶7、主键 唯一标识表中每行的这个列（或这组列）称为主键。主键用来表示一个特定的行。没有主键，更新或删除表中特定行很难，因为没有安全的方法保证只涉及相关的行。 关键点：对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 主键（primary key）：一列（或一组列），其值能够唯一区分表中每个行。 ¶7.1 可作为主键的条件： 任意两行都不具有相同的主键值； 每个行都必须具有一个主键值（主键列不允许NULL值）。 注意：主键通常定义在表的一列上，但这并不是必需的，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到构成主键的所有列，所有列值的组合必须是唯一的（但单个列的值可以不唯一）。 ¶7.2 使用主键的好习惯 不更新主键列中的值； 不重用主键列的值； 不在主键列中使用可能会更改的值。 不使用任何业务相关的字段作为主键。（身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。会发生变更！） ¶7.3 主键id 作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。 对于大部分应用来说，通常自增类型的主键就能满足需求。 如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。 可作为id字段的类型有： 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键； 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。 ¶7.4 联合主键 关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。 没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。 ¶8、外键 外键（FOREIGN KEY）：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。 关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。 如下面的表格，class_id就将student表与class表之间形成了关联！ 我们就可以根据class_id这个列直接定位出一个students表的记录应该对应到classes的哪条记录。 外键参考资料，点击这里！ id class_id name other columns… 1 1 小明 … 2 1 小红 … 5 2 小白 … ¶外键的实现 外键并不是通过列名实现的，而是通过定义外键约束实现的： 外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。 通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。 由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。 1234ALTER TABLE studentsADD CONSTRAINT fk_class_idFOREIGN KEY (class_id)REFERENCES classes (id); 要删除一个外键约束，也是通过ALTER TABLE实现的： 注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的。 12ALTER TABLE studentsDROP FOREIGN KEY fk_class_id; ¶两种关系 多对多 多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系！ 三个表：teachers表、classes表、teacher_class表（存放teacher ID 与 class ID对应信息） 一对一 一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。 有两个表：students表、contact表（存手机号） 实际上，一对一关系准确地说，是contacts表一对一对应students表。 因为有的学生没有手机号，如果都写道一个students表，会有空出现，写到另一个contact表则不会出现空。 还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度。 ¶9、索引 在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。 索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。 可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。 对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。 使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引有多列直接括号里继续写。 12345ALTER TABLE studentsADD INDEX idx_score (score);ALTER TABLE studentsADD INDEX idx_name_score (name, score); ¶唯一索引 在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。 但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。 例如name不能重复（通过UNIQUE关键字我们就添加了一个唯一索引。） 12ALTER TABLE studentsADD UNIQUE INDEX uni_name (name); 只对某一列添加一个唯一约束而不创建唯一索引。（name列没有索引，但仍然具有唯一性保证。） 12ALTER TABLE studentsADD CONSTRAINT uni_name UNIQUE (name); 总结：无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。 ¶二、什么是SQL ¶1、什么是SQL 什么是SQL？(Structured Query Language)，SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。 虽然SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为PL/SQL，Microsoft把自己扩展的SQL称为T-SQL。 现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。 ¶2、SQL的优点 SQL不是某个特定数据库供应商专有的语言。几乎所有重要的DBMS都支持SQL，所以，学习此语言使你几乎能与所有数据库打交道。 SQL简单易学。它的语句全都是由描述性很强的英语单词组成，而且这些单词的数目不多。 SQL尽管看上去很简单，但它实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。 ¶3、SQL语言的能力 **DDL：Data Definition Language **：DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。 **DML：Data Manipulation Language **：DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。 **DQL：Data Query Language **：DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。 ¶4、SQL语法特点 SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。 所以，本教程约定：SQL关键字总是大写，以示突出，表名和列名均使用小写。 ¶5、数据模型 数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型： 随着时间的推移和市场竞争，最终，基于关系模型的关系数据库获得了绝对市场份额。 层次模型：层次模型就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树 网状模型：网状模型把每个数据节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网 关系模型：关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，它的数据模型看起来就是一个Excel表 ¶6、数据类型 上面的表中列举了最常用的数据类型。很多数据类型还有别名，例如，REAL又可以写成FLOAT(24)。还有一些不常用的数据类型，例如，TINYINT（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如JSON。 选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，BIGINT能满足整数存储的需求，VARCHAR(N)能满足字符串存储的需求，这两种类型是使用最广泛的。 名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2020-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2020-06-22 12:20:59 ¶7、主流关系数据库 商用数据库，例如：Oracle，SQL Server，DB2等； 开源数据库，例如：MySQL，PostgreSQL等； 桌面数据库，以微软Access为代表，适合桌面应用程序使用； 嵌入式数据库，以Sqlite为代表，适合手机应用和桌面程序。 ¶三、什么是MySQL ¶1、MySQL那些事 MySQL是目前应用最广泛的开源关系数据库。MySQL最早是由瑞典的MySQL AB公司开发，该公司在2008年被SUN公司收购，紧接着，SUN公司在2009年被Oracle公司收购，所以MySQL最终就变成了Oracle旗下的产品。 MySQL是一种DBMS，即它是一种数据库软件。 ¶2、MySQL的优点 成本——MySQL是开放源代码的，一般可以免费使用（甚至可以免费修改）。 性能——MySQL执行很快（非常快）。 可信赖——某些非常重要和声望很高的公司、站点使用MySQL，这些公司和站点都用MySQL来处理自己的重要数据。 简单——MySQL很容易安装和使用。 ¶3、MySQL数据引擎 和其他关系数据库有所不同的是，MySQL本身实际上只是一个SQL接口，它的内部还包含了多种数据引擎！ MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎（IE引擎或Webkit引擎）的关系。对用户而言，切换浏览器引擎不影响浏览器界面，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。 使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择InnoDB就好了。 InnoDB：由Innobase Oy公司开发的一款支持事务的数据库引擎，2006年被Oracle收购； MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。 ¶4、MySQL衍生版本 因为MySQL一开始就是开源的，所以基于MySQL的开源版本，又衍生出了各种版本: ¶MariaDB 由MySQL的创始人创建的一个开源分支版本，使用XtraDB引擎。 ¶Aurora 由Amazon改进的一个MySQL版本，专门提供给在AWS托管MySQL用户，号称5倍的性能提升。 ¶PolarDB 由Alibaba改进的一个MySQL版本，专门提供给在阿里云托管的MySQL用户，号称6倍的性能提升。 ¶MySQL官方版本 以下版本的功能依次递增，价格也依次递增。不过，功能增加的主要是监控、集群等管理功能，对于基本的SQL功能是完全一样的。 Community Edition：社区开源版本，免费； Standard Edition：标准版； Enterprise Edition：企业版； Cluster Carrier Grade Edition：集群版。 ¶5、MySQL版本 4——InnoDB引擎，增加事务处理、并、改进全文本搜索等的支持。 4.1——对函数库、子查询、集成帮助等的重要增加。 5——存储过程、触发器、游标、视图等。 ¶6、安装MySQL 安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。 嗯。。网上找一篇教程安装即可！有时间我再写一下安装教程！ ¶MySQL Client 与 MySQL Server： MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。 在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是127.0.0.1:3306。 123┌──────────────┐ SQL ┌──────────────┐│ MySQL Client │───────&gt;│ MySQL Server │└──────────────┘ TCP └──────────────┘ ¶7、运行MySQL 管理员身份启动MySQL服务 使用命令登录MySQL 123$ net start mysql$ mysql -u root -pEnter password: ********** 如下图： -u：指定用户名 -p：输入密码 -h：主机名 ，本地默认为localhost，远程服务器为公网ip地址 -P：端口号 ¶8、注意点 命令用;或\\g结束，Enter键不执行操作。 输入help或\\h获得帮助，也可以输入help select获取关于SELECT语句的帮助 输入quit或exit退出命令行程序（并没有关闭mysql服务） ¶9、管理MySQL ¶数据库相关命令： ¶9.1 列出数据库 1$ mysql&gt; SHOW DATABASES; 其中，information_schema、mysql、performance_schema和sys是系统库，不要去改动它们。其他的是用户创建的数据库。 ¶9.2 创建数据库 12$ mysql&gt; CREATE DATABASE test;Query OK, 1 row affected (0.01 sec) ¶9.3 删除数据库 12$ mysql&gt; CREATE DATABASE mytest;Query OK, 1 row affected (0.01 sec) ¶9.4 使用数据库 对一个数据库进行操作时，要首先将其切换为当前数据库： 12$ mysql&gt; USE test;Database changed ¶表相关命令： ¶9.5 列出表 列出当前数据库的所有表: 1234567$ mysql&gt; SHOW TABLES;+------------------+| Tables_in_mytest |+------------------+| students |+------------------+1 row in set (0.00 sec) ¶9.6 创建表 123456$ mysql&gt; CREATE TABLE students -&gt; ( -&gt; id INT(11), -&gt; name VARCHAR(25) -&gt; );Query OK, 0 rows affected, 1 warning (0.05 sec) ¶9.7 查看创建表的语句 123456789101112$ mysql&gt; SHOW CREATE TABLE students;+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| students | CREATE TABLE `students` ( `id` int DEFAULT NULL, `name` varchar(25) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.01 sec) ¶9.7 查看表的结构 123456789101112$ DESCRIBE &lt;表名&gt;;或$ DESC &lt;表名&gt;;$ mysql&gt; DESC students;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int | YES | | NULL | || name | varchar(25) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.01 sec) ¶9.8 删除表 12$ mysql&gt; DROP TABLE students;Query OK, 0 rows affected (0.03 sec) ¶9.9 修改表 较为复杂，后续讲解！ ¶退出MySQL 两种，大小写都可！ 12345$ mysql&gt; EXITBye$ mysql&gt; QUITBye ¶10、SHOW语句 ¶10.1 SHOW TABLES; 1234567$ mysql&gt; SHOW TABLES;+------------------+| Tables_in_mytest |+------------------+| students |+------------------+1 row in set (0.00 sec) ¶10.2 SHOW COLUMNS FROM &lt;表名&gt;; 它对每个字段返回一行，行中包含字段名、数据类型、是否允许 NULL 、键信息、默认值以及其他信息。 DESCRIBE&lt;表名&gt; 语句 SHOW COLUMNS FROM &lt;表名&gt;;的快捷方式！ 简写：DESC &lt;表名&gt; 12345678$ SHOW COLUMNS FROM students;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int | YES | | NULL | || name | varchar(25) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec) ¶10.3 SHOW STATUS; SHOW STATUS ，用于显示广泛的服务器状态信息。 12$ SHOW STATUS;.... ¶10.4 SHOW CREATE DATABASE &lt;数据库名&gt;; 显示创建数据库的语句： 12345678$ mysql&gt; SHOW CREATE DATABASE mytest;+----------+----------------------------------------------------------------------------------------------------------------------------------+| Database | Create Database |+----------+----------------------------------------------------------------------------------------------------------------------------------+| mytest | CREATE DATABASE `mytest` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */ |+----------+----------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) ¶10.5 SHOW CREATE TABLE &lt;表名&gt;; 显示创建表的语句： 123456789101112$ mysql&gt; SHOW CREATE TABLE students;+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| students | CREATE TABLE `students` ( `id` int DEFAULT NULL, `name` varchar(25) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) ¶10.6 SHOW GRANTS; 用来显示授予用户（所有用户或特定用户）的安全权限； 12345678910111213141516171819202122mysql&gt; SHOW GRANTS;+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Grants for root@localhost |+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, SHUTDOWN, PROCESS, FILE, REFERENCES, INDEX, ALTER, SHOW DATABASES, SUPER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION SLAVE, REPLICATION CLIENT, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE TABLESPACE, CREATE ROLE, DROP ROLE ON *.* TO `root`@`localhost` WITH GRANT OPTION || GRANT APPLICATION_PASSWORD_ADMIN,AUDIT_ADMIN,BACKUP_ADMIN,BINLOG_ADMIN,BINLOG_ENCRYPTION_ADMIN,CLONE_ADMIN,CONNECTION_ADMIN,ENCRYPTION_KEY_ADMIN,GROUP_REPLICATION_ADMIN,INNODB_REDO_LOG_ARCHIVE,PERSIST_RO_VARIABLES_ADMIN,REPLICATION_APPLIER,REPLICATION_SLAVE_ADMIN,RESOURCE_GROUP_ADMIN,RESOURCE_GROUP_USER,ROLE_ADMIN,SERVICE_CONNECTION_ADMIN,SESSION_VARIABLES_ADMIN,SET_USER_ID,SYSTEM_USER,SYSTEM_VARIABLES_ADMIN,TABLE_ENCRYPTION_ADMIN,XA_RECOVER_ADMIN ON *.* TO `root`@`localhost` WITH GRANT OPTION || GRANT PROXY ON ''@'' TO 'root'@'localhost' WITH GRANT OPTION |+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+3 rows in set (0.00 sec) ¶10.7 SHOW ERRORS ; 显示服务器错误信息： 12$ mysql&gt; SHOW ERRORS;Empty set (0.00 sec) ¶SHOW WARNINGS; 显示服务器警告信息： 12$ mysql&gt; SHOW WARNINGS;Empty set (0.00 sec) ¶10.8 HELP SHOW; 用来显示允许SHOW语句的信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061mysql&gt; HELP SHOW;Name: 'SHOW'Description:SHOW has many forms that provide information about databases, tables,columns, or status information about the server. This section describesthose following:SHOW {BINARY | MASTER} LOGSSHOW BINLOG EVENTS [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]SHOW CHARACTER SET [like_or_where]SHOW COLLATION [like_or_where]SHOW [FULL] COLUMNS FROM tbl_name [FROM db_name] [like_or_where]SHOW CREATE DATABASE db_nameSHOW CREATE EVENT event_nameSHOW CREATE FUNCTION func_nameSHOW CREATE PROCEDURE proc_nameSHOW CREATE TABLE tbl_nameSHOW CREATE TRIGGER trigger_nameSHOW CREATE VIEW view_nameSHOW DATABASES [like_or_where]SHOW ENGINE engine_name {STATUS | MUTEX}SHOW [STORAGE] ENGINESSHOW ERRORS [LIMIT [offset,] row_count]SHOW EVENTSSHOW FUNCTION CODE func_nameSHOW FUNCTION STATUS [like_or_where]SHOW GRANTS FOR userSHOW INDEX FROM tbl_name [FROM db_name]SHOW MASTER STATUSSHOW OPEN TABLES [FROM db_name] [like_or_where]SHOW PLUGINSSHOW PROCEDURE CODE proc_nameSHOW PROCEDURE STATUS [like_or_where]SHOW PRIVILEGESSHOW [FULL] PROCESSLISTSHOW PROFILE [types] [FOR QUERY n] [OFFSET n] [LIMIT n]SHOW PROFILESSHOW RELAYLOG EVENTS [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]SHOW SLAVE HOSTSSHOW SLAVE STATUS [FOR CHANNEL channel]SHOW [GLOBAL | SESSION] STATUS [like_or_where]SHOW TABLE STATUS [FROM db_name] [like_or_where]SHOW [FULL] TABLES [FROM db_name] [like_or_where]SHOW TRIGGERS [FROM db_name] [like_or_where]SHOW [GLOBAL | SESSION] VARIABLES [like_or_where]SHOW WARNINGS [LIMIT [offset,] row_count]like_or_where: LIKE 'pattern' | WHERE exprIf the syntax for a given SHOW statement includes a LIKE 'pattern'part, 'pattern' is a string that can contain the SQL % and _ wildcardcharacters. The pattern is useful for restricting statement output tomatching values.Several SHOW statements also accept a WHERE clause that provides moreflexibility in specifying which rows to display. Seehttps://dev.mysql.com/doc/refman/8.0/en/extended-show.html.URL: https://dev.mysql.com/doc/refman/8.0/en/show.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"关系型数据库","slug":"数据库/关系型数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.itnxd.cn/tags/SQL/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.itnxd.cn/tags/MySQL/"}],"author":"Mr.Niu"},{"title":"Java教程系列之加密与安全","slug":"Java教程系列之加密与安全","date":"2020-04-20T12:12:43.000Z","updated":"2021-02-06T14:14:19.500Z","comments":true,"path":"posts/25096.html","link":"","permalink":"https://www.itnxd.cn/posts/25096.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 这一节你一定会懵逼，不过这都是绝对会用到知识，先简单过一遍，用到了再细过一次！点击这里，查看原文！ 看的是真的艰难啊！坚持中！！！ ¶一、URL编码 URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分。 服务器只识别ASCII字符！ URL编码是编码算法，不是加密算法！（主要用来处理文本如汉字。。） ¶1、编码规则 如果字符是A ~ Z，a ~ z，0 ~ 9以及-、_、.、*、=，则保持不变； 如果是其他字符，先转换为UTF-8编码，然后对每个字节以%XX表示。都是大写。 例如：字符中的UTF-8编码是0xe4b8ad，因此，它的URL编码是%E4%B8%AD。URL编码总是大写。 ¶2、使用URLEncoder 中的URL编码是%E4%B8%AD，文的URL编码是%E6%96%87，!虽然是ASCII字符，也要对其编码为%21。 URL编码与UTF-8编码相对应。 和标准的URL编码稍有不同，URLEncoder把空格字符编码成+，而现在的URL编码标准要求空格被编码为%20，不过，服务器都可以处理这两种情况。 浏览器加号和%20都可以处理为空格： 123456789101112131415161718package com.org;import java.net.URLDecoder;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;public class EnCode { public static void main(String[] args) { // https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87 // 编码： String encoded = URLEncoder.encode(\"中文!\", StandardCharsets.UTF_8); System.out.println(encoded); // %E4%B8%AD%E6%96%87%21 // 解码： String decoded = URLDecoder.decode(encoded, StandardCharsets.UTF_8); System.out.println(decoded); // 中文! }} ¶二、Base64编码 URL编码是对字符进行编码，表示成%xx的形式，而Base64编码是对二进制数据进行编码，表示成文本格式。 Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。 Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。（？？？不明白） 和URL编码一样，Base64编码是一种编码算法，不是加密算法。 如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。 ¶1、编码规则 将三字节的十六进制表示为二进制0和1，一共24bit，然后每6bit一组，得到四个十进制数：（6bit范围为0-63，可以用64个字符表示：） 字符A ~ Z对应索引0 ~ 25 字符a ~ z对应索引26 ~ 51 字符0 ~ 9对应索引52 ~ 61 最后两个索引62、63分别用字符+和/表示。 ¶2、使用Base64 二进制数据就是byte[]数组。Java标准库提供了Base64来对byte[]数组进行编解码： 编码：3byte转6bit，转化为四个十六进制，将对应的十六进制转化为十进制再去上面的规则中查找，返回四个字符：5Lit 解码：将编码后字符按上面规则转化为十进制再转换为二进制，得到3byte，24bit的0和1，再将其转化为十进制输出，有正负区别：[-28, -72, -83] 123456789101112131415161718package com.org;import java.util.Arrays;import java.util.Base64;public class Base64EnCode { public static void main(String[] args) { // 0xe4b8ad // 编码：(3byte -&gt; 6bit一组进行十六进制转换【39, 0b, 22, 2d】) byte[] input = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad }; String b64encoded = Base64.getEncoder().encodeToString(input); System.out.println(b64encoded); // 5Lit // 解码： byte[] output = Base64.getDecoder().decode(b64encoded); System.out.println(Arrays.toString(output)); // [-28, -72, -83] }} ¶3、Byte数组长度不为3倍数 每三个元素为一组，不为3的倍数如何处理呢？ 这种情况下，需要对输入的末尾补一个或两个0x00，编码后，在结尾加一个=表示补充了1个0x00，加两个=表示补充了2个0x00，解码的时候，去掉末尾补充的一个或两个0x00即可。 编码后的长度加上=总是4的倍数，所以即使不加=也可以计算出原始输入的byte[]。 对于下方例子：前3byte按6bit一组为5Lit，最后1byte(0x21)，前6bit为I，后两个bit补充4个0，达到六bit，即对应Q。由于不够3倍数，会多加两个0x00，所以最终结果最后会多两个=号，代表加了两个0x00。 使用withoutPadding去除末尾等号！ 解码同样，变为8bit的字节，转化为带符号的十进制输出！ 1234567891011121314151617181920package com.org;import java.util.Arrays;import java.util.Base64;public class Base64EnCode { public static void main(String[] args) { byte[] input1 = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad, (byte) 0x21 }; // 编码： // 有=号： String b64encoded1 = Base64.getEncoder().encodeToString(input1); // 去等于号： String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input1); System.out.println(b64encoded1); // 5LitIQ== System.out.println(b64encoded2); // 5LitIQ // 解码： byte[] output1 = Base64.getDecoder().decode(b64encoded2); System.out.println(Arrays.toString(output1)); // [-28, -72, -83, 33] }} ¶4、将Base64转化为URL编码 URL编码允许出现的特殊符号：-、_、.、*、= Base64编码允许出现的特殊符号：+、/、=， 标准的Base64编码会出现+、/和=，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把+变成-，/变成_： 1234567891011121314151617package com.org;import java.util.Arrays;import java.util.Base64;public class Base64EnCode { public static void main(String[] args) { byte[] input2 = new byte[] { 0x01, 0x02, 0x7f, 0x00 }; // 针对URL的Base64编码：/ -&gt; _ String b64encoded3 = Base64.getUrlEncoder().encodeToString(input2); System.out.println(b64encoded3); // AQJ_AA== // 解码： byte[] output2 = Base64.getUrlDecoder().decode(b64encoded3); System.out.println(Arrays.toString(output2)); // [1, 2, 127, 0] }} 下面就是加密算法： ¶三、哈希算法 ¶1、哈希算法简介 哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。 哈希算法的目的就是为了验证原始数据是否被篡改。 Java字符串的hashCode()就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节int整数。 同样，有一个哈希冲突问题：（字节组合是有穷的，但输入组合是无穷的，一定会出现冲突。。） 特点： 相同的输入一定得到相同的输出； 不同的输入大概率得到不同的输出。 安全哈希算法条件： 碰撞概率低； 不能猜测输出。 一个hashCode例子： 123456789package com.org;public class HashAlgorithm { public static void main(String[] args) { System.out.println(\"hello\".hashCode()); // 99162322 // 使用Ingeter实现十六进制输出 System.out.println(Integer.toString(\"hello\".hashCode(), 16)); // 5e918d2 }} ¶2、常见哈希算法 算法 输出长度（位） 输出长度（字节） MD5 128 bits 16 bytes SHA-1 160 bits 20 bytes RipeMD-160 160 bits 20 bytes SHA-256 256 bits 32 bytes SHA-512 512 bits 64 bytes ¶2.1 MD5 使用MessageDigest时，我们首先根据哈希算法获取一个MessageDigest实例，然后，反复调用update(byte[])输入数据。当输入结束后，调用digest()方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。 123456789101112131415161718package com.org;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;public class HashAlgorithm { public static void main(String[] args) throws Exception { // 创建一个MessageDigest实例: MessageDigest md = MessageDigest.getInstance(\"MD5\"); // 反复调用update输入数据: md.update(\"Hello\".getBytes(StandardCharsets.UTF_8)); md.update(\"World\".getBytes(StandardCharsets.UTF_8)); byte[] result = md.digest(); // 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6 // BigInteger的第一个signum参数表示符号位（1：正数；-1：负数） System.out.println(new BigInteger(1, result).toString(16)); }} ¶2.2 其他哈希算法 将MessageDigest.getInstance(\"MD5\");的算法模式修改即可！ SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。 注意：MD5因为输出长度较短，短时间内破解是可能的，目前已经不推荐使用。 Java标准库支持的所有哈希算法可以在**点击这里**查到。 再举一个SHA-512算法： 1234567891011121314151617package com.org;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;public class HashAlgorithm { public static void main(String[] args) throws Exception { // 创建一个MessageDigest实例: MessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // 反复调用update输入数据: md1.update(\"Hello\".getBytes(StandardCharsets.UTF_8)); md1.update(\"World\".getBytes(StandardCharsets.UTF_8)); byte[] result1 = md1.digest(); // 64 bytes: 8ae6ae71a75d3fb2e0225deeb004faf95d816a0a58093eb4cb5a3aa0f197050d7a4dc0a2d5c6fbae5fb5b0d536a0a9e6b686369fa57a027687c3630321547596 System.out.println(new BigInteger(1, result1).toString(16)); }} ¶3、哈希算法的用途 验证文件完整性及是否篡改 数据库的用户口令密码的安全性和正确性 ¶4、彩虹表 什么是彩虹表呢？上面讲到了，如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。 然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表。 这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因！ 解决方法： 如果用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）： 加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。 1digest = md5(salt+inputPassword) ¶四、BouncyCastle BouncyCastle就是一个提供了很多哈希算法和加密算法的第三方库。它提供了Java标准库没有的一些算法，例如，RipeMD160哈希算法。 首先，我们必须把BouncyCastle提供的jar包放到classpath中。这个jar包就是bcprov-jdk15on-xxx.jar，可以从**官方网站**下载。 IDEA下载下来将其移到lib目录下，然后file-&gt;project structure-&gt;dependencies中右边的加号选择导入jre即可！ 使用第三方算法前需要通过Security.addProvider()注册。（Java标准库的java.security包提供了一种标准机制，允许第三方提供商无缝接入。） 123456789101112131415161718192021package com.org;import org.bouncycastle.jce.provider.BouncyCastleProvider;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;import java.security.Security;public class BouncyCastle00 { public static void main(String[] args) throws Exception{ // 注册BouncyCastle: Security.addProvider(new BouncyCastleProvider()); // 按名称正常调用: MessageDigest md = MessageDigest.getInstance(\"RipeMD160\"); md.update(\"HelloWorld\".getBytes(StandardCharsets.UTF_8)); byte[] result = md.digest(); // ecabeaa2eb986c85e6a6ea2c22b248ab6916de35 System.out.println(new BigInteger(1, result).toString(16)); }} ¶五、Hmac算法 前面讲到哈希算法时，我们说，存储用户的哈希口令时，要加盐(salt)存储，目的就在于抵御彩虹表攻击。 这个salt可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。 Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。 Hmac算法总是和某种哈希算法配合起来用的。 HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加salt，有如下好处： HmacMD5使用的key长度是64字节，更安全； Hmac是标准算法，同样适用于SHA-1等其他哈希算法； Hmac输出和原有的哈希算法长度一致。 可见，Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。 为了保证安全，我们不会自己指定key，而是通过Java标准库的KeyGenerator生成一个安全的随机的key： ¶1、加密 一般步骤： 通过名称HmacMD5获取KeyGenerator实例； 通过KeyGenerator创建一个SecretKey实例； 通过名称HmacMD5获取Mac实例； 用SecretKey初始化Mac实例； 对Mac实例反复调用update(byte[])输入数据； 调用Mac实例的doFinal()获取最终的哈希值。 12345678910111213141516171819202122232425262728package com.org;import javax.crypto.KeyGenerator;import javax.crypto.Mac;import javax.crypto.SecretKey;import java.math.BigInteger;import java.nio.charset.StandardCharsets;public class Hmac00 { public static void main(String[] args) throws Exception{ KeyGenerator keyGen = KeyGenerator.getInstance(\"HmacMD5\"); SecretKey key = keyGen.generateKey(); // 打印随机生成的key:(64byte) byte[] skey = key.getEncoded(); // 9e62a1d17f27ca9cad816dddce959e3d819e47eb1849adc4fb9a95ee8a2720b14aa9a054acf4a6e1c4028354ce322e58b4b787bab06294f737c606ac98ad6c43 System.out.println(new BigInteger(1, skey).toString(16)); Mac mac = Mac.getInstance(\"HmacMD5\"); // 使用随机key加盐： mac.init(key); mac.update(\"HelloWorld\".getBytes(StandardCharsets.UTF_8)); // salt + HelloWorld：转化为字节 byte[] result = mac.doFinal(); // 转化为16进制：(仍然是原长16byte) // cca902c5a59b5d7ac45bd856fcfdea34 System.out.println(new BigInteger(1, result).toString(16)); }} ¶2、解密 不知道为啥，解密输出和原来并不一样。。。 先放下。。。 12345678910111213141516171819202122232425262728293031323334353637383940package com.org;import javax.crypto.KeyGenerator;import javax.crypto.Mac;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.util.Arrays;public class Hmac00 { public static void main(String[] args) throws Exception{ KeyGenerator keyGen = KeyGenerator.getInstance(\"HmacMD5\"); SecretKey key = keyGen.generateKey(); // 打印随机生成的key: byte[] skey = key.getEncoded(); System.out.println(new BigInteger(1, skey).toString(16)); System.out.println(Arrays.toString(skey)); Mac mac = Mac.getInstance(\"HmacMD5\"); // 使用随机key加盐： mac.init(key); mac.update(\"HelloWorld\".getBytes(StandardCharsets.UTF_8)); // salt + HelloWorld：转化为字节 byte[] result = mac.doFinal(); // 转化为16进制： System.out.println(new BigInteger(1, result).toString(16)); /*解密：*/ SecretKey key1 = new SecretKeySpec(skey, \"HmacMD5\"); Mac mac1 = Mac.getInstance(\"HmacMD5\"); mac1.init(key1); mac1.update(\"HelloWorld\".getBytes(StandardCharsets.UTF_8)); byte[] result1 = mac.doFinal(); System.out.println(Arrays.toString(result1)); System.out.println(new BigInteger(1, result1).toString(16)); }} ¶六、对称加密算法 对称加密算法就是传统的用一个密码进行加密和解密。例如，我们常用的WinZIP和WinRAR对压缩包的加密和解密，就是使用对称加密算法。 ¶1、常用对称加密算法 密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。Java标准库提供的算法实现并不包括所有的工作模式和所有填充模式，但是通常我们只需要挑选常用的使用就可以了。 最后注意，DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。 算法 密钥长度 工作模式 填充模式 DES 56/64 ECB/CBC/PCBC/CTR/… NoPadding/PKCS5Padding/… AES 128/192/256 ECB/CBC/PCBC/CTR/… NoPadding/PKCS5Padding/PKCS7Padding/… IDEA 128 ECB PKCS5Padding/PKCS7Padding/… ¶2、使用AES加密 AES算法是目前应用最广泛的加密算法。我们先用ECB模式加密并解密。 这鸡巴有点难搞。。。 一般步骤： 根据算法名称/工作模式/填充模式获取Cipher实例； 根据算法名称初始化一个SecretKey实例，密钥必须是指定长度； 使用SerectKey初始化Cipher实例，并设置加密或解密模式； 传入明文或密文，获得密文或明文。 ¶2.1 ECB模式 ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低！ 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.org;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.util.Base64;public class AES00 { public static void main(String[] args) throws Exception{ // 原文: String message = \"Hello, world!\"; System.out.println(\"Message: \" + message); // 128位密钥 = 16 bytes Key:（必须指定密钥长度） byte[] key = \"1234567890abcdef\".getBytes(StandardCharsets.UTF_8); // 加密: byte[] data = message.getBytes(StandardCharsets.UTF_8); byte[] encrypted = encrypt(key, data); // Encrypted: 2xiGROlFBhC57b7EGu5c3g== System.out.println(\"Encrypted: \" + Base64.getEncoder().encodeToString(encrypted)); // 解密: byte[] decrypted = decrypt(key, encrypted); // Decrypted: Hello, world! System.out.println(\"Decrypted: \" + new String(decrypted, StandardCharsets.UTF_8)); } // 加密: public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); SecretKey keySpec = new SecretKeySpec(key, \"AES\"); cipher.init(Cipher.ENCRYPT_MODE, keySpec); return cipher.doFinal(input); } // 解密: public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); SecretKey keySpec = new SecretKeySpec(key, \"AES\"); cipher.init(Cipher.DECRYPT_MODE, keySpec); return cipher.doFinal(input); }} ¶2.2 CBC模式 更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同： 在CBC模式下，需要一个随机生成的16字节IV参数，必须使用SecureRandom生成。因为多了一个IvParameterSpec实例，因此，初始化方法需要调用Cipher的一个重载方法并传入IvParameterSpec。 观察输出，可以发现每次生成的IV不同，密文也不同。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.org;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.security.SecureRandom;import java.util.Base64;public class AES_CBC { public static void main(String[] args) throws Exception{ // 原文: String message = \"Hello, world!\"; System.out.println(\"Message: \" + message); // 256位密钥 = 32 bytes Key: byte[] key = \"1234567890abcdef1234567890abcdef\".getBytes(StandardCharsets.UTF_8); // 加密: byte[] data = message.getBytes(StandardCharsets.UTF_8); byte[] encrypted = encrypt(key, data); // Encrypted: DSXvNDWdzvPhMp9nGR0lXfiTE9lPcVbKSw4gWLGpxFU= System.out.println(\"Encrypted: \" + Base64.getEncoder().encodeToString(encrypted)); // 解密: byte[] decrypted = decrypt(key, encrypted); // Decrypted: Hello, world! System.out.println(\"Decrypted: \" + new String(decrypted, StandardCharsets.UTF_8));} // 加密: public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\"); // CBC模式需要生成一个16 bytes的initialization vector: SecureRandom sr = SecureRandom.getInstanceStrong(); byte[] iv = sr.generateSeed(16); IvParameterSpec ivps = new IvParameterSpec(iv); cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps); byte[] data = cipher.doFinal(input); // IV不需要保密，把IV和密文一起返回: return join(iv, data); } // 解密: public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException { // 把input分割成IV和密文: byte[] iv = new byte[16]; byte[] data = new byte[input.length - 16]; System.arraycopy(input, 0, iv, 0, 16); System.arraycopy(input, 16, data, 0, data.length); // 解密: Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\"); IvParameterSpec ivps = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, keySpec, ivps); return cipher.doFinal(data); } public static byte[] join(byte[] bs1, byte[] bs2) { byte[] r = new byte[bs1.length + bs2.length]; System.arraycopy(bs1, 0, r, 0, bs1.length); System.arraycopy(bs2, 0, r, bs1.length, bs2.length); return r; }} ¶七、口令加密算法 上一节我们讲的AES加密，细心的童鞋可能会发现，密钥长度是固定的128/192/256位，而不是我们用WinZip/WinRAR那样，随便输入几位都可以。 这是因为对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。 但是我们平时使用的加密软件，输入6位、8位都可以，难道加密方式不一样？ 实际上用户输入的口令并不能直接作为AES的密钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。 PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.org;import org.bouncycastle.jce.provider.BouncyCastleProvider;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.PBEKeySpec;import javax.crypto.spec.PBEParameterSpec;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.security.SecureRandom;import java.security.Security;import java.util.Base64;public class PBE00 { public static void main(String[] args) throws Exception { // 把BouncyCastle作为Provider添加到java.security: Security.addProvider(new BouncyCastleProvider()); // 原文: String message = \"Hello, world!\"; // 加密口令: String password = \"hello12345\"; // 16 bytes随机Salt: byte[] salt = SecureRandom.getInstanceStrong().generateSeed(16); // salt: salt: 9ae41dc05680b0fda28be0f1d6454f3a System.out.printf(\"salt: %032x\\n\", new BigInteger(1, salt)); // 加密: byte[] data = message.getBytes(StandardCharsets.UTF_8); byte[] encrypted = encrypt(password, salt, data); // encrypted: MHVOyeWBxGM7RhpN8xy9fA== System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(encrypted)); // 解密: byte[] decrypted = decrypt(password, salt, encrypted); // decrypted: Hello, world! System.out.println(\"decrypted: \" + new String(decrypted, StandardCharsets.UTF_8)); } // 加密: public static byte[] encrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException { PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray()); SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); SecretKey skey = skeyFactory.generateSecret(keySpec); PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000); Cipher cipher = Cipher.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps); return cipher.doFinal(input); } // 解密: public static byte[] decrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException { PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray()); SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); SecretKey skey = skeyFactory.generateSecret(keySpec); PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000); Cipher cipher = Cipher.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); cipher.init(Cipher.DECRYPT_MODE, skey, pbeps); return cipher.doFinal(input); }} 使用PBE时，我们还需要引入BouncyCastle，并指定算法是PBEwithSHA1and128bitAES-CBC-BC。观察代码，实际上真正的AES密钥是调用Cipher的init()方法时同时传入SecretKey和PBEParameterSpec实现的。在创建PBEParameterSpec的时候，我们还指定了循环次数1000，循环次数越多，暴力破解需要的计算量就越大。 如果我们把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，即使用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。 ¶八、密钥交换算法 解决如何传递密钥的问题： 在不安全的信道上传递加密文件是没有问题的，因为黑客拿到加密文件没有用。但是，如何如何在不安全的信道上安全地传输密钥？ 要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。 DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。 我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做： 甲首选选择一个素数p，例如509，底数g，任选，例如5，随机数a，例如123，然后计算A=g^a mod p，结果是215，然后，甲发送p＝509，g=5，A=215给乙； 乙方收到后，也选择一个随机数b，例如，456，然后计算B=g^b mod p，结果是181，乙再同时计算s=A^b mod p，结果是121； 乙把计算的B=181发给甲，甲计算s＝B^a mod p的余数，计算结果与乙算出的结果一样，都是121。 所以最终双方协商出的密钥s是121。注意到这个密钥s并没有在网络上传输。而通过网络传输的p，g，A和B是无法推算出s的，因为实际算法选择的素数是非常大的。 所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。 如果我们把a看成甲的私钥，A看成甲的公钥，b看成乙的私钥，B看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥secretKey，DH算法通过数学定律保证了双方各自计算出的secretKey是相同的。 但是DH算法并未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。消除中间人攻击需要其他方法。 Java实现DH算法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.org;import javax.crypto.KeyAgreement;import java.math.BigInteger;import java.security.*;import java.security.spec.X509EncodedKeySpec;public class DH00 { public static void main(String[] args) {// Bob和Alice: Person bob = new Person(\"Bob\"); Person alice = new Person(\"Alice\"); // 各自生成KeyPair: bob.generateKeyPair(); alice.generateKeyPair(); // 双方交换各自的PublicKey: // Bob根据Alice的PublicKey生成自己的本地密钥: bob.generateSecretKey(alice.publicKey.getEncoded()); // Alice根据Bob的PublicKey生成自己的本地密钥: alice.generateSecretKey(bob.publicKey.getEncoded()); // 检查双方的本地密钥是否相同: bob.printKeys(); alice.printKeys(); // 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密... }}class Person { public final String name; public PublicKey publicKey; private PrivateKey privateKey; private byte[] secretKey; public Person(String name) { this.name = name; } // 生成本地KeyPair: public void generateKeyPair() { try { KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"DH\"); kpGen.initialize(512); KeyPair kp = kpGen.generateKeyPair(); this.privateKey = kp.getPrivate(); this.publicKey = kp.getPublic(); } catch (GeneralSecurityException e) { throw new RuntimeException(e); } } public void generateSecretKey(byte[] receivedPubKeyBytes) { try { // 从byte[]恢复PublicKey: X509EncodedKeySpec keySpec = new X509EncodedKeySpec(receivedPubKeyBytes); KeyFactory kf = KeyFactory.getInstance(\"DH\"); PublicKey receivedPublicKey = kf.generatePublic(keySpec); // 生成本地密钥: KeyAgreement keyAgreement = KeyAgreement.getInstance(\"DH\"); keyAgreement.init(this.privateKey); // 自己的PrivateKey keyAgreement.doPhase(receivedPublicKey, true); // 对方的PublicKey // 生成SecretKey密钥: this.secretKey = keyAgreement.generateSecret(); } catch (GeneralSecurityException e) { throw new RuntimeException(e); } } public void printKeys() { System.out.printf(\"Name: %s\\n\", this.name); System.out.printf(\"Private key: %x\\n\", new BigInteger(1, this.privateKey.getEncoded())); System.out.printf(\"Public key: %x\\n\", new BigInteger(1, this.publicKey.getEncoded())); System.out.printf(\"Secret key: %x\\n\", new BigInteger(1, this.secretKey)); }} 运行结果：（Secret key是相同的） 12345678Name: BobPrivate key: 3081d202010030819706092a864886f70d010301308189024100fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e170240678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca40202018004330231009b3e8e2cd56ae4b0501da4eeb6c2813370b5a3a73e8a1d9ccbbd6e30f27c1f1aa05d68d20da4bba167a8d141203b4d26Public key: 3081e030819706092a864886f70d010301308189024100fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e170240678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca4020201800344000241009b3b7b8ae229ff5f082b725d7f2f4f94c5cd61063e621776012d4a995df4f3ef8df2cadba6e2c54f1e639b7fa51ff84d3fbe74dd2bf55ec2f72cc7cf2a58947bSecret key: 2e516324b72d75e81da0e9c4d328d9401478a07baf667a87e39e3d7c841c892af27d1cddf4a41767a78a2799a2bbb5f3a08988c5c59f6c058cd84d3e790b9bc5Name: AlicePrivate key: 3081d202010030819706092a864886f70d010301308189024100fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e170240678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca4020201800433023100b5b2212c1d074a75eab86290b58d275252e062305ccc25a4b81e5cf96f41e053d15b8718b07cc414a2c0b800253d8df5Public key: 3081df30819706092a864886f70d010301308189024100fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e170240678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca40202018003430002404585b6c895f58eab57a3028f73d62beda35bea505b1a1ae11faafcc7c3054b61e5c4455d09fb1fd6c817147cb7ca9895620ced591183aa88d70a3fbf4b124213Secret key: 2e516324b72d75e81da0e9c4d328d9401478a07baf667a87e39e3d7c841c892af27d1cddf4a41767a78a2799a2bbb5f3a08988c5c59f6c058cd84d3e790b9bc5 ¶九、非对称加密算法 从DH算法我们可以看到，公钥-私钥组成的密钥对是非常有用的加密方式，因为公钥是可以公开的，而私钥是完全保密的，由此奠定了非对称加密的基础。 非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。 因此，如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。 非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。 非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要N*(N-1)/2个密钥，因此每个人需要管理N-1个密钥，密钥管理难度大，而且非常容易泄漏。 既然非对称加密这么好，那我们抛弃对称加密，完全使用非对称加密行不行？也不行。因为非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多。 所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后： 小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红； 小红用自己的RSA私钥解密得到AES口令； 双方使用这个共享的AES口令用AES加密通信。 可见非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。 RSA算法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.org;import javax.crypto.Cipher;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.*;public class RSA00 { public static void main(String[] args) throws Exception { // 明文: byte[] plain = \"Hello, encrypt use RSA\".getBytes(StandardCharsets.UTF_8); // 创建公钥／私钥对: Person1 alice = new Person1(\"Alice\"); // 用Alice的公钥加密: byte[] pk = alice.getPublicKey(); System.out.println(String.format(\"public key: %x\", new BigInteger(1, pk))); byte[] encrypted = alice.encrypt(plain); System.out.println(String.format(\"encrypted: %x\", new BigInteger(1, encrypted))); // 用Alice的私钥解密: byte[] sk = alice.getPrivateKey(); System.out.println(String.format(\"private key: %x\", new BigInteger(1, sk))); byte[] decrypted = alice.decrypt(encrypted); System.out.println(new String(decrypted, StandardCharsets.UTF_8)); }}class Person1 { String name; // 私钥: PrivateKey sk; // 公钥: PublicKey pk; public Person1(String name) throws GeneralSecurityException { this.name = name; // 生成公钥／私钥对: KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"RSA\"); kpGen.initialize(1024); KeyPair kp = kpGen.generateKeyPair(); this.sk = kp.getPrivate(); this.pk = kp.getPublic(); } // 把私钥导出为字节 public byte[] getPrivateKey() { return this.sk.getEncoded(); } // 把公钥导出为字节 public byte[] getPublicKey() { return this.pk.getEncoded(); } // 用公钥加密: public byte[] encrypt(byte[] message) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(Cipher.ENCRYPT_MODE, this.pk); return cipher.doFinal(message); } // 用私钥解密: public byte[] decrypt(byte[] input) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(Cipher.DECRYPT_MODE, this.sk); return cipher.doFinal(input); }} 输出结果： 12345public key: 30819f300d06092a864886f70d010101050003818d003081890281810089411cd2ceb3f44d43641d265de1ba63f752eccf739f4e33e8e4c111ce261ba378729d354797afe6991d5e530c849f42390d0ed098a47b51dd130a1f7303b2ee04f589e9f1ca78d8167c8949e619653f6361f05dec81c44427dbd21ab088ad55790eafb7afedcd03472b57cc7d1aba30656db06210b97dba15c649962df42b5b0203010001encrypted: 7762b626f22c8671049c6114dbe070f551f9a444a11c0e8e9e41a1ff270d2d4515fa0be12c51df055a1ba71cc5360a4646b35498caf69381a959f7e272ede890d7d8d0422e063570116396e2f9bdc2f705c2f6bbc88bc5bdd110026bcbd008d93235a9d27093cfe238b1110115bd2d6d606f44b271152c3f423799fb5ffdda13private key: 30820275020100300d06092a864886f70d01010105000482025f3082025b0201000281810089411cd2ceb3f44d43641d265de1ba63f752eccf739f4e33e8e4c111ce261ba378729d354797afe6991d5e530c849f42390d0ed098a47b51dd130a1f7303b2ee04f589e9f1ca78d8167c8949e619653f6361f05dec81c44427dbd21ab088ad55790eafb7afedcd03472b57cc7d1aba30656db06210b97dba15c649962df42b5b0203010001028180653eb19b533c6d4e7d12a16a06c096b45ce13fabfb771cc1afdee608534fcafd77c0dbf44c5e3933d9e84f06e5ea026c601720c180877c2c33ee727e2662291ecc0cdc56c5144b47f312cf9021c97dc6adfa9573476a99fd27666f252affe3016699d4a9e739bf7aa8d08525f64b8e9f22bdd33bae5d23125145000219e01a49024100eda89fa24ac30b6b65db6592ba570f228cbfa4a656ccbb13cd8fd2f174e3d4dbc26789aad8c5c0e56e2415e807ff00e957183a3c4de14e6d51d7ed7539f90e9f02410093d8d1ec2e6302d5ea315673b1a44ac4d00f94f5b653fa5b84ff2137eeb8a7f0d3bc0b122f274aa8d4eb08595a6524116e91abe0d0e0e4bf5d019775799b35c50240606ab4b8c6d3f26213e4ba84988c915b56f6b8f9b2e5445078690d0f6078bdf69a1c1f41ecc7edc626b5051e29804f025b8f3cb1127781b5e02a55efe52121c9024019754b6884f04dabb220fec6fb3ed41521d29d0ed66f8d7bb6e20bc14add072623ff8c547c4422ca01a7db0f2fce9cb057bec3bef998d02ad7840fa58de419150240790e8dadbfd8adc0ce6b1eebf1c03d450adcae72e686ac8d9ecc71ce32a34e12ac768cb882ece363ea2f8d6236394ac30187b345d55eb4e42597a7114406ff09Hello, encrypt use RSA RSA的公钥和私钥都可以通过getEncoded()方法获得以byte[]表示的二进制数据，并根据需要保存到文件中。要从byte[]数组恢复公钥或私钥，可以这么写： 以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。 如果修改待加密的byte[]数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。 此外，只使用非对称加密算法不能防止中间人攻击。 123456789byte[] pkData = ...byte[] skData = ...KeyFactory kf = KeyFactory.getInstance(\"RSA\");// 恢复公钥:X509EncodedKeySpec pkSpec = new X509EncodedKeySpec(pkData);PublicKey pk = kf.generatePublic(pkSpec);// 恢复私钥:PKCS8EncodedKeySpec skSpec = new PKCS8EncodedKeySpec(skData);PrivateKey sk = kf.generatePrivate(skSpec); ¶十、签名算法 我们使用非对称加密算法的时候，对于一个公钥-私钥对，通常是用公钥加密，私钥解密。 如果使用私钥加密，公钥解密是否可行呢？实际上是完全可行的。 不过我们再仔细想一想，私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密。这个加密有什么意义？ 这个加密的意义在于，如果小明用自己的私钥加密了一条消息，比如小明喜欢小红，然后他公开了加密消息，由于任何人都可以用小明的公钥解密，从而使得任何人都可以确认小明喜欢小红这条消息肯定是小明发出的，其他人不能伪造这个消息，小明也不能抵赖这条消息不是自己写的。 因此，私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。 在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名。 对签名进行验证实际上就是用公钥解密。 然后把解密后的哈希与原始消息的哈希进行对比。 因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。 ¶常用签名算法 ¶1.1 RSA签名 实际上就是指定某种哈希算法进行RSA签名的方式 MD5withRSA SHA1withRSA SHA256withRSA 使用其他公钥，或者验证签名的时候修改原始信息，都无法验证成功。 123456789101112131415161718192021222324252627282930313233package com.org;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.*;public class QianMing { public static void main(String[] args) throws Exception{ // 生成RSA公钥/私钥: KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"RSA\"); kpGen.initialize(1024); KeyPair kp = kpGen.generateKeyPair(); PrivateKey sk = kp.getPrivate(); PublicKey pk = kp.getPublic(); // 待签名的消息: byte[] message = \"Hello, I am Bob!\".getBytes(StandardCharsets.UTF_8); // 用私钥签名: Signature s = Signature.getInstance(\"SHA1withRSA\"); s.initSign(sk); s.update(message); byte[] signed = s.sign(); System.out.println(String.format(\"signature: %x\", new BigInteger(1, signed))); // 用公钥验证: Signature v = Signature.getInstance(\"SHA1withRSA\"); v.initVerify(pk); v.update(message); boolean valid = v.verify(signed); System.out.println(\"valid? \" + valid); }} 输出结果： 12signature: 7ce04446376358e2de5b5f299c780385f2e436154f6ad03df846fe4ec14f7de8d1a4acdade4a0951f99c02f4305c6ddb1327321ac4086737690b2bf2b9297050cba1a30451c989ef1512ec453625e289525e492ab707ec110b2928c13faa154b1ebd21f001cb0c61a273a8c74ac51ee6a2bdef5161a05f4e1997b364f5dfc889valid? true ¶1.2 DSA签名 除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。 和RSA数字签名相比，DSA的优点是更快。 DSA只能配合SHA使用，常用的算法有： SHA1withDSA SHA256withDSA SHA512withDSA ¶1.3 ECDSA签名 椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。 ¶十一、数字证书 我们知道，摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。 因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。 数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。 我们在上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性。 要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用自签名的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。 在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。我们用下面的命令创建一个key store，并设定口令123456： 1$ keytool -storepass 123456 -genkeypair -keyalg RSA -keysize 1024 -sigalg SHA1withRSA -validity 3650 -alias mycert -keystore my.keystore -dname \"CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN\" 几个主要的参数是： keyalg：指定RSA加密算法； sigalg：指定SHA1withRSA签名算法； validity：指定证书有效期3650天； alias：指定证书在程序中引用的名称； dname：最重要的CN=www.sample.com指定了Common Name，如果证书用在HTTPS中，这个名称必须与域名完全一致。 执行上述命令，JDK会在当前目录创建一个my.keystore文件，并存储创建成功的一个私钥和一个证书，它的别名是mycert。 通过数字证书进行加解密和签名： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.org;import com.sun.tools.javac.Main;import javax.crypto.Cipher;import java.io.InputStream;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.security.KeyStore;import java.security.PrivateKey;import java.security.Signature;import java.security.cert.X509Certificate;public class NumberZhengShu { public static void main(String[] args) throws Exception { byte[] message = \"Hello, use X.509 cert!\".getBytes(StandardCharsets.UTF_8); // 读取KeyStore: KeyStore ks = loadKeyStore(\"my.keystore\", \"123456\"); // 读取私钥: PrivateKey privateKey = (PrivateKey) ks.getKey(\"mycert\", \"123456\".toCharArray()); // 读取证书: X509Certificate certificate = (X509Certificate) ks.getCertificate(\"mycert\"); // 加密: byte[] encrypted = encrypt(certificate, message); System.out.println(String.format(\"encrypted: %x\", new BigInteger(1, encrypted))); // 解密: byte[] decrypted = decrypt(privateKey, encrypted); System.out.println(\"decrypted: \" + new String(decrypted, StandardCharsets.UTF_8)); // 签名: byte[] sign = sign(privateKey, certificate, message); System.out.println(String.format(\"signature: %x\", new BigInteger(1, sign))); // 验证签名: boolean verified = verify(certificate, message, sign); System.out.println(\"verify: \" + verified); } static KeyStore loadKeyStore(String keyStoreFile, String password) { try (InputStream input = NumberZhengShu.class.getResourceAsStream(keyStoreFile)) { if (input == null) { throw new RuntimeException(\"file not found in classpath: \" + keyStoreFile); } KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType()); ks.load(input, password.toCharArray()); return ks; } catch (Exception e) { throw new RuntimeException(e); } } static byte[] encrypt(X509Certificate certificate, byte[] message) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(certificate.getPublicKey().getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, certificate.getPublicKey()); return cipher.doFinal(message); } static byte[] decrypt(PrivateKey privateKey, byte[] data) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateKey); return cipher.doFinal(data); } static byte[] sign(PrivateKey privateKey, X509Certificate certificate, byte[] message) throws GeneralSecurityException { Signature signature = Signature.getInstance(certificate.getSigAlgName()); signature.initSign(privateKey); signature.update(message); return signature.sign(); } static boolean verify(X509Certificate certificate, byte[] message, byte[] sig) throws GeneralSecurityException { Signature signature = Signature.getInstance(certificate.getSigAlgName()); signature.initVerify(certificate); signature.update(message); return signature.verify(sig); }} 输出结果： 1234encrypted: 7f88754e3e31ab5f6aa80d6a2f4610095bc0057b05fab78e5e9e14839103e8648d219a9bb43189d4896b5c5f95c82a85c94e242b6afdc54303650ce7513fa5877e3adb91afb38cbf036e419ade2406ea563bf7a7520454b689ea81281fdc999b58550178403094b44df047c188918b2743b98c5e46f7bcc8f50c3aa2bd8fb11cdecrypted: Hello, use X.509 cert!signature: 1d13d65d2a8928ccb6639f5d325f77e4b211b5cb3a120f6a182a05c4ddedde29cc8a3af1ee02473015514a8b65e743f6f58997aa5f00e464a68136f8b680682af5107bda5d4de925f3699f7d7327fee21c4b9e5c90641b91a6cb8be93a6f008006eb4052749a6cffa43a7e4749e4afc55293097baebc5a72e3a05b21dbba8a34verify: true 在上述代码中，我们从key store直接读取了私钥-公钥对，私钥以PrivateKey实例表示，公钥以X509Certificate表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。 以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下： 浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书； 浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器； 服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。 上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。 注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商DigiNotar就发生过私钥泄漏导致公司破产的事故。 这艰难的一节终于简单过了一遍，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"加密","slug":"加密","permalink":"https://www.itnxd.cn/tags/%E5%8A%A0%E5%AF%86/"},{"name":"安全","slug":"安全","permalink":"https://www.itnxd.cn/tags/%E5%AE%89%E5%85%A8/"}],"author":"Mr.Niu"},{"title":"Java教程系列之正则表达式","slug":"Java教程系列之正则表达式","date":"2020-04-18T10:06:42.000Z","updated":"2021-02-06T14:16:53.668Z","comments":true,"path":"posts/53926.html","link":"","permalink":"https://www.itnxd.cn/posts/53926.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 由于学JavaScript时就已经学过了正则的规则，所以本文只介绍与其不同支出，大概的一个框架及用法！ ¶一、正则匹配规则 \\d ：一个数字 \\D：一个非数字 \\w ：一个数字或一个字母（大小写） \\W：与\\w相对。。。匹配其不能匹配的 \\s ：一个空格 \\S：与\\s相对，匹配其不能匹配的 \\u548c：匹配一个指定Unicode字符 . ：一个任意字符 \\. ：一个小数点 * ：任意个（包括0个） + ：至少一个 ？ ：0个或1个 {n,}：至少n个 {n} ：n个 {n, m} ：n 到 m 个 \\- ：一个- \\\\ ：一个\\ [abc]：匹配其中一个 [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串 [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就JavaScript允许的变量名 [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符） [^0-9]：不匹配数字，匹配其他任意字符一个 A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 ()：相当于提取公因式。。 ^和$写在正则表达式前后可以精确控制字符串，保证开头和结尾的规则，在JavaScript中，js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了；而在Java中，js不可以匹配'jsp'。 ¶二、Java中使用String正则不同之处 Java没有专门的正则对象，所以用String字符串来表示一个正则表达式： 这样就会使得与正则表达式不一样了： 格式：标准正则 - - - - - - - -&gt; Java中字符串表示的正则 \\d -&gt; \\\\d \\\\ -&gt; \\\\\\\\ \\- -&gt; - \\_ -&gt; _ \\$ -&gt; $ \\\" -&gt; \\\" \\' -&gt; ' / -&gt; / 总结：java中的特殊字符可以直接用，双引号特殊得用斜杠转义： 标准正则两个斜杠代表一个斜杠，Java字符串则是四个斜杠代表一个斜杠，即前两个转义为1个，后两个转义为1个，前面再将后面的转义为斜杠。。。 大概就是这些。。。 1234567891011121314package com.org;public class Regex01 { public static void main(String[] args) { // /\\d\\\\\\-\\_\\$\\\"\\' String re = \"/\\\\d\\\\\\\\-_&amp;\\\"'\"; System.out.println(\"/3\\\\-_&amp;\\\"'\".matches(re));// true String re1 = \"[^1-9]*\"; System.out.println(\"h)fkd-+d\".matches(re1)); // true // 与JavaScript不同，特别的地方。。 String re3 = \"js\"; System.out.println(\"jsp\".matches(re3)); // false JavaScript可以匹配。。。 }} ¶三、分组匹配（引入regex包） ()的一个重要作用，用来分组： 使用String.matches()方法只能判断，要想获得匹配子串需要使用regex包的对象。 还有：Java的正则匹配和JavaScript有点不一样：（参考第一小节最后的内容！） 引入java.util.regex包，用Pattern对象匹配，匹配后获得一个Matcher对象，如果匹配成功，就可以直接从Matcher.group(index)返回子串： 下标为0返回原串，下标为1以后的则返回匹配的字串！ ¶1、一个例子 12345678910111213141516171819package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex02 { public static void main(String[] args) { Pattern p = Pattern.compile(\"(\\\\d{3,4})-(\\\\d{7,8})\"); Matcher m = p.matcher(\"010-12345678\"); if (m.matches()) { System.out.println(m.group(0)); // 010-12345678 System.out.println(m.group(1)); // 010 System.out.println(m.group(2)); // 12345678 } else { System.out.println(\"匹配失败!\"); } }} ¶2、Pattern 使用String和regex包，实际上这两种代码本质上是一样的，因为String.matches()方法内部调用的就是Pattern和Matcher类的方法。 反复使用String.matches()对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的Pattern对象。 完全可以先创建出一个Pattern对象，然后反复使用，就可以实现编译一次，多次匹配： 使用Matcher时，必须首先调用matches()判断是否匹配成功，匹配成功后，才能调用group()提取子串。 代码见上面例子： ¶四、贪婪匹配 ¶1、贪婪匹配 看下方例子，这就是贪婪匹配，\\d+将后面的所有数字都给匹配了，所以0*就无法匹配了！ 贪婪匹配：任何一个规则，它总是尽可能多地向后匹配，因此，\\d+总是会把后面的0包含进来。 123456789101112131415package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex04 { public static void main(String[] args) { Pattern pattern = Pattern.compile(\"(\\\\d+)(0*)\"); Matcher matcher = pattern.matcher(\"1230000\"); if (matcher.matches()) { System.out.println(matcher.group(1)); // \"1230000\" System.out.println(matcher.group(2)); // \"\" } }} ¶2、解决方法：（非贪婪匹配） 使用?，使其尽可能先去满足后面的规则，完事了在满足自己规则； 123456789101112131415package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex04 { public static void main(String[] args) { Pattern pattern = Pattern.compile(\"(\\\\d+?)(0*)\"); Matcher matcher = pattern.matcher(\"1230000\"); if (matcher.matches()) { System.out.println(matcher.group(1)); // \"123\" System.out.println(matcher.group(2)); // \"0000\" } }} ¶3、?? 连续两个问号：(针对没有+*的时候使用) 第一个：表示基础意思，匹配0个或1个。。 第二个：非贪婪匹配 只有一个问号：（+*符号后面） 默认就是：非贪婪匹配 只有一个问号：（没有+*符号） 默认就是：表示基础意思，匹配0个或1个。。 123456789101112131415package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex04 { public static void main(String[] args) { Pattern pattern = Pattern.compile(\"(\\\\d??)(0*)\"); Matcher matcher = pattern.matcher(\"10000\"); if (matcher.matches()) { System.out.println(matcher.group(1)); // \"1\" System.out.println(matcher.group(2)); // \"0000\" } }} ¶五、分割 使用split()方法，返回一个String数组。 ¶1、使用Pattern的split方法 12345678910111213package com.org;import java.util.regex.Pattern;public class Regex05 { public static void main(String[] args) { Pattern pattern = Pattern.compile(\"[\\s,\\\\\\\\*;]+\"); String[] str = pattern.split(\"2 ;;,43\\\\ 5* ,7\"); for (String s : str) { System.out.print(s + \" \"); // 2 43 5 7 } }} ¶2、使用String 的split方法 直接使用String的split方法更简单！ 1234567891011package com.org;public class Regex06 { public static void main(String[] args) { String[] str = \"2 ;;,43\\\\ 5* ,7\".split(\"[\\s,\\\\\\\\*;]+\"); for (String s : str) { System.out.print(s + \" \"); //2 43 5 7 } }} ¶六、搜索和替换 ¶1、搜索 使用Matcher.find()判断有没有匹配子串了。 使用Matcher.start()和Matcher.end()方法返回子串的起始下标位置，类似于迭代器，找完一个找下一个，直到找完。Matcher.find()方法也是，找过一个就不回去找了，直到找不到返回false！ 使用String.substring()来切割输出！ 12345678910111213141516package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex07 { public static void main(String[] args) { String s = \"the quick brown fox jumps over the lazy dog.\"; Pattern p = Pattern.compile(\"\\\\wo\\\\w\"); Matcher m = p.matcher(s); while (m.find()) { String sub = s.substring(m.start(), m.end()); System.out.println(sub); // row fox dog } }} ¶2、替换 使用正则表达式替换字符串可以直接调用String.replaceAll()，它的第一个参数是正则表达式，第二个参数是待替换的字符串： 如下例子：将多个空格替换为一个空格 123456789package com.org;public class Regex08 { public static void main(String[] args) { String s = \"The quick\\t\\t brown fox jumps over the lazy dog.\"; String r = s.replaceAll(\"\\\\s+\", \" \"); System.out.println(r); // \"The quick brown fox jumps over the lazy dog.\" }} ¶3、反向引用 第二个参数可以使用$1、$2来反向引用匹配到的子串。 $1指的是前面括号的一组内容，$2只第二个括号的内容，以此类推。。 一个例子：将四字母单词加上&lt;b&gt;&lt;/b&gt;，即HTML的加粗标签！ 即([a-z]{4})替换了$1。 123456789package com.org;public class Regex08 { public static void main(String[] args) { String ss = \"the quick brown fox jumps over the lazy dog.\"; String rr = ss.replaceAll(\"\\\\s([a-z]{4})\\\\s\", \" &lt;b&gt;$1&lt;/b&gt; \"); System.out.println(rr); // the quick brown fox jumps &lt;b&gt;over&lt;/b&gt; the &lt;b&gt;lazy&lt;/b&gt; dog. }} 正则表达式已完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Regex","slug":"Regex","permalink":"https://www.itnxd.cn/tags/Regex/"}],"author":"Mr.Niu"},{"title":"Java教程系列之单元测试","slug":"Java教程系列之单元测试","date":"2020-04-16T10:05:18.000Z","updated":"2021-02-06T14:07:29.549Z","comments":true,"path":"posts/44270.html","link":"","permalink":"https://www.itnxd.cn/posts/44270.html","excerpt":"","text":"¶一、编写Junit测试 单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。 实现测试与主程序分离，实现打印测试结果，可编写通用测试代码！ ¶1、Junit JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试。 使用JUnit编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。 JUnit目前最新版本是5。 ¶2、步骤： 首先在src同级下建立test目录 设置为测试专用文件夹，右键test目录找到Mark Directory as 选择子选项的Test Sources Root 回到src，找到需要测试的方法，右键选择Go To的子选项Test，出现的选项中点击Creat new Test 后面用到的Junit等相关库，Idea会自动去导包，并加入classpath! 写好主程序和测试程序后，去测试程序运行即可： ¶3、编写举例 核心测试方法testFact()加上了@Test注解，这是JUnit要求的，它会把带有@Test的方法识别为测试方法。 习惯上将Test文件的名字命名为需测试类名+Test.java： eg：主程序：Factory.java 测试程序：FactoryTest.java 以计算阶乘的方法为例： ¶测试成功情况： Factory： 1234567891011package com.org;public class Factory { public static long fact(long n) { long r = 1; for (long i = 1; i &lt;= n; i++) { r = r * i; } return r; }} FactoryTest： 1234567891011121314151617package com.org;import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.*;public class FactoryTest { @Test void fact() { assertEquals(1, Factory.fact(1)); assertEquals(2, Factory.fact(2)); assertEquals(6, Factory.fact(3)); assertEquals(3628800, Factory.fact(10)); assertEquals(2432902008176640000L, Factory.fact(20)); }} 没有问题不会输出东西： 1Process finished with exit code 0 ¶测试失败情况： 将测试程序认为改一下： assertEquals(1, Factory.fact(1)) -&gt; assertEquals(2, Factory.fact(1))： 输出结果： 会显示不一致的地方： 123456789org.opentest4j.AssertionFailedError: Expected :2Actual :1&lt;Click to see difference&gt; at org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:55) at org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:195) at ..... ¶浮点数的处理 由于浮点数运算会有误差，所以需要设置一个误差值来限定： 使用assertEquals()的重载方法，第三个参数指定误差范围即可： 1234567891011121314151617package com.org;import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.*;public class Double01Test { @Test void calc() { //assertEquals(0.1, Math.abs(1 - 9 / 10.0)); // 0.09999999999999998 assertEquals(0.1, Math.abs(1 - 9 / 10.0), 0.000001); assertEquals(0.2, Math.abs(1 - 8 / 10.0), 0.000001); //assertEquals(0.1, Math.abs(1 - 0.9)); // 0.09999999999999998 assertEquals(0.1, Math.abs(1 - 0.9), 0.0000001); }} ¶4、Assertion（断言） 在测试方法内部，我们用assertEquals(1, Factorial.fact(1))表示，期望Factorial.fact(1)返回1。assertEquals(expected, actual)是最常用的测试方法，它在Assertion类中定义。 在异常处理一节第六点提到过断言，点击这里！ Assertion还定义了其他断言方法，例如： assertTrue(): 期待结果为true assertFalse(): 期待结果为false assertNotNull(): 期待结果为非null assertArrayEquals(): 期待结果为数组并与期望数组每个元素的值均相等 … ¶5、单元测试总结 单元测试可以确保单个方法按照正确预期运行，如果修改了某个方法的代码，只需确保其对应的单元测试通过，即可认为改动正确。此外，测试代码本身就可以作为示例代码，用来演示如何调用该方法。 使用JUnit进行单元测试，我们可以使用断言（Assertion）来测试期望结果，可以方便地组织和运行测试，并方便地查看测试结果。此外，JUnit既可以直接在IDE中运行，也可以方便地集成到Maven这些自动化工具中运行。 在编写单元测试的时候，我们要遵循一定的规范： 一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试； 二是每个单元测试应当互相独立，不依赖运行的顺序； 三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为0，null，空字符串\"\"等情况。 ¶二、使用Fixture 在一个单元测试中，我们经常编写多个@Test方法，来分组、分类对目标代码进行测试。 在测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个@Test方法都写一遍这样的重复代码，显然比较麻烦。 JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。 ¶1、@BeforeEach 和 @AfterEach 在CalculatorTest测试中，有两个标记为@BeforeEach和@AfterEach的方法，它们会在运行每个@Test方法前后自动运行： 通过@BeforeEach来初始化，通过@AfterEach来清理资源： 试了一下，不用Fixture，也可以正常测试成功，所以我觉得Java默认是有这两个方法在每个test方法前后去执行的，不过自己加上更加明显，修改之类的都可以更加方便，所以还是自己写上为好：（Idea可以在go to 后直接选择添加，并不需要手写：） 举一个例子： Calculator类： 123456789101112131415package com.org;public class Calculator { private long n = 0; public long add(long x) { n = n + x; return n; } public long sub(long x) { n = n - x; return n; }} CalculatorTest类： 123456789101112131415161718192021222324252627282930313233343536package com.org;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.*;public class CalculatorTest { Calculator calculator; @BeforeEach void setUp() { this.calculator = new Calculator(); } @AfterEach void tearDown() { this.calculator = null; } @Test void add() { assertEquals(100, this.calculator.add(100)); assertEquals(150, this.calculator.add(50)); assertEquals(130, this.calculator.add(-20)); } @Test void sub() { assertEquals(-100, this.calculator.sub(100)); assertEquals(-150, this.calculator.sub(50)); assertEquals(-130, this.calculator.sub(-20)); }} ¶2、@BeforeAll 和 @AfterAll 它们在运行所有@Test前后运行： 因为@BeforeAll和@AfterAll在所有@Test方法运行前后仅运行一次，因此，它们只能初始化静态方法的静态变量： 有一些资源初始化和清理可能更加繁琐，而且会耗费较长的时间：（例如初始化数据库） 一般不会用到这两个！ 不举例子了，点击这里： ¶3、小结 大多数情况下，使用@BeforeEach和@AfterEach就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到@BeforeAll和@AfterAll。 注意到每次运行一个@Test方法前，JUnit首先创建一个XxxTest实例，因此，每个@Test方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个@Test方法带到另一个@Test方法。 这样说来就解释了第一点不使用Fixture仍然可以测试成功的原因： 对于实例变量，在@BeforeEach中初始化，在@AfterEach中清理，它们在各个@Test方法中互不影响，因为是不同的实例； 对于静态变量，在@BeforeAll中初始化，在@AfterAll中清理，它们在各个@Test方法中均是唯一实例，会影响各个@Test方法。 ¶三、异常测试 在Java程序中，异常处理是非常重要的。 我们自己编写的方法，也经常抛出各种异常。对于可能抛出的异常进行测试，本身就是测试的重要环节。 因此，在编写JUnit测试的时候，除了正常的输入输出，我们还要特别针对可能导致异常的情况进行测试： 还是以Factory()方法举例： Factory类： 在方法入口，我们增加了对参数n的检查，如果为负数，则直接抛出IllegalArgumentException。 1234567891011121314package com.org;public class Factory { public static long fact(long n) { if(n &lt; 0){ throw new IllegalArgumentException(); } long r = 1; for (long i = 1; i &lt;= n; i++) { r = r * i; } return r; }} FactoryTest类： 我们希望对异常进行测试。在JUnit测试中，我们可以编写一个@Test方法专门测试异常testNegative()方法： JUnit提供assertThrows()来期望捕获一个指定的异常。第二个参数Executable封装了我们要执行的会产生异常的代码。当我们执行Factorial.fact(-1)时，必定抛出IllegalArgumentException。assertThrows()在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。 编写一个Executable的匿名类实在是太繁琐了。实际上，Java 8开始引入了函数式编程，所有单方法接口都可以简写如下testNegative1()方法： 1234567891011121314151617181920212223242526272829303132333435package com.org;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.function.Executable;import static org.junit.jupiter.api.Assertions.*;public class FactoryTest { @Test void fact() { assertEquals(1, Factory.fact(1)); assertEquals(2, Factory.fact(2)); assertEquals(6, Factory.fact(3)); assertEquals(3628800, Factory.fact(10)); assertEquals(2432902008176640000L, Factory.fact(20)); } // 普通写法： @Test void testNegative(){ assertThrows(IllegalArgumentException.class, new Executable() { @Override public void execute() throws Throwable { Factory.fact(-1); } }); } // 使用函数式编程简化： @Test void testNegative1(){ assertThrows(IllegalArgumentException.class, ()-&gt;{Factory.fact(-1);}); }} ¶四、条件测试 简单来说就是控制@test在什么条件下才执行： 在@test后面再加一些条件注解： 一些常用的条件注解： @Disabled(“bug-101”)：此测试不会执行，括号参数可选，为输出提示信息。 @EnabledOnOs(OS.WINDOWS)：在什么系统测试。 @DisabledOnOs(OS.WINDOWS)：不在什么系统测试。 @DisabledOnJre(JRE.JAVA_8)：不在Java8test。 @EnabledIfSystemProperty(named = “os.arch”, matches = “.64.”)：只能在六十四位系统测试。 @EnabledIfEnvironmentVariable(named = “DEBUG”, matches = “true”)：需要传入环境变量DEBUG=true才能执行的测试，即控制台里面传入该参数才可以。 @EnabledIf(“java.time.LocalDate.now().getDayOfWeek()==java.time.DayOfWeek.SUNDAY”)：万能判断语句，当前是星期日才会执行测试。 万能的@EnableIf可以执行任意Java语句并根据返回的boolean决定是否执行测试。 Config类： 1234567891011121314package com.org;public class Config { public String getConfigFile(String filename) { String os = System.getProperty(\"os.name\").toLowerCase(); if (os.contains(\"win\")) { return \"C:\\\\\" + filename; } if (os.contains(\"mac\") || os.contains(\"linux\") || os.contains(\"unix\")) { return \"/usr/local/\" + filename; } throw new UnsupportedOperationException(); }} ConfigTest类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.org;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.condition.*;import static org.junit.jupiter.api.Assertions.assertEquals;public class ConfigTest { Config config; @BeforeEach public void setUp() { this.config = new Config(); } @Test @EnabledOnOs(OS.WINDOWS) void testWindows() { assertEquals(\"C:\\\\test.ini\", config.getConfigFile(\"test.ini\")); } @Test @EnabledOnOs({ OS.LINUX, OS.MAC }) void testLinuxAndMac() { assertEquals(\"/usr/local/test.cfg\", config.getConfigFile(\"test.cfg\")); } @Test @Disabled(\"bug-101\") void testBug101() { // TODO: this test is disabled for bug fixing } @Test @DisabledOnOs(OS.WINDOWS) void testOnNonWindowsOs() { // TODO: this test is disabled on windows } @Test @DisabledOnJre(JRE.JAVA_8) void testOnJava9OrAbove() { // TODO: this test is disabled on java 8 } @Test @EnabledIfSystemProperty(named = \"os.arch\", matches = \".*64.*\") void testOnlyOn64bitSystem() { // TODO: this test is only run on 64 bit system } @Test @EnabledIfEnvironmentVariable(named = \"DEBUG\", matches = \"true\") void testOnlyOnDebugMode() { // TODO: this test is only run on DEBUG=true } @Test @EnabledIf(\"java.time.LocalDate.now().getDayOfWeek()==java.time.DayOfWeek.SUNDAY\") void testOnlyOnSunday() { // TODO: this test is only run on Sunday }} 测试输出结果及提示信息： 1234567891011Environment variable [DEBUG] does not existWarning: Nashorn engine is planned to be removed from a future JDK releaseScript `java.time.LocalDate.now().getDayOfWeek()==java.time.DayOfWeek.SUNDAY` evaluated to: falsebug-101Disabled on operating system: Windows 10Disabled on operating system: Windows 10 ¶五、参数化测试 如果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法 参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。 JUnit提供了一个@ParameterizedTest注解，用来进行参数化测试。 与之前的测试不同，不再使用@test了！ 以下方例子进行测试：将字符串转化为第一个字母大写，后面小写的形式： 12345678910package com.org;public class ArgumentsN { public static String capitalize(String s) { if (s.length() == 0) { return s; } return Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase(); }} ¶1、使用@MethodSource 编写一个同名的静态方法来提供测试参数： 返回一个List&lt;Arguments&gt;，方法内使用Arguments.arguments()方法，指定输入和输出参数。 如果静态方法和测试方法的名称不同，@MethodSource也允许指定方法名。但使用默认同名方法最方便。 12345678910111213141516171819202122232425262728293031323334353637383940package com.org;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.Arguments;import org.junit.jupiter.params.provider.CsvFileSource;import org.junit.jupiter.params.provider.MethodSource;import java.util.List;import static org.junit.jupiter.api.Assertions.assertEquals;public class ArgumentsNTest { @ParameterizedTest @MethodSource void testCapitalize(String input, String result) { assertEquals(result, ArgumentsN.capitalize(input)); } static List&lt;Arguments&gt; testCapitalize() { return List.of( // arguments: Arguments.arguments(\"abc\", \"Abc\"), // Arguments.arguments(\"APPLE\", \"Apple\"), // Arguments.arguments(\"gooD\", \"Good\")); } // 静态方法名字不一致时：指定静态方法名：（一般不这样写） @ParameterizedTest @MethodSource(\"testCapitalize1\") void testCapitalize(String input, String result) { assertEquals(result, ArgumentsN.capitalize(input)); } static List&lt;Arguments&gt; testCapitalize1() { return List.of( // arguments: Arguments.arguments(\"abc\", \"Abc\"), // Arguments.arguments(\"APPLE\", \"Apple\"), // Arguments.arguments(\"gooD\", \"Good\")); }} ¶2、使用@CsvSource 它的每一个字符串表示一行，一行包含的若干参数用,分隔，如下： 12345678910111213141516171819package com.org;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.Arguments;import org.junit.jupiter.params.provider.CsvFileSource;import org.junit.jupiter.params.provider.MethodSource;import java.util.List;import static org.junit.jupiter.api.Assertions.assertEquals;public class ArgumentsNTest { @ParameterizedTest @CsvSource({ \"abc, Abc\", \"APPLE, Apple\", \"gooD, Good\" }) void testCapitalize(String input, String result) { assertEquals(result, ArgumentsN.capitalize(input)); }} ¶3、使用@CsvFileSource 如果有成百上千的测试输入，那么，直接写@CsvSource就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上@CsvFileSource：(使用参数指定csv的路径名) JUnit只在classpath中查找指定的CSV文件，因此，test-capitalize.csv这个文件要放到test目录下：（Idea可以写好路径，快捷进行创建文件：） CSV文件的内容：（逗号分隔，一行一个） 1234apple, AppleHELLO, HelloJUnit, JunitreSource, Resource 12345678910111213141516171819package com.org;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.Arguments;import org.junit.jupiter.params.provider.CsvFileSource;import org.junit.jupiter.params.provider.MethodSource;import java.util.List;import static org.junit.jupiter.api.Assertions.assertEquals;public class ArgumentsNTest { @ParameterizedTest @CsvFileSource(resources = { \"/test-capitalize.csv\" }) void testCapitalizeUsingCsvFile(String input, String result) { assertEquals(result, ArgumentsN.capitalize(input)); }} 单元测试一节已然完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JUnit","slug":"JUnit","permalink":"https://www.itnxd.cn/tags/JUnit/"}],"author":"Mr.Niu"},{"title":"Java教程系列之日期与时间","slug":"Java教程系列之日期与时间","date":"2020-04-13T08:26:06.000Z","updated":"2021-02-06T14:14:53.349Z","comments":true,"path":"posts/51490.html","link":"","permalink":"https://www.itnxd.cn/posts/51490.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶一、一些概念 ¶1、本地时间 当我们说当前时刻是2019年11月20日早上8:15的时候，我们说的实际上是本地时间。在国内就是北京时间。在这个时刻，如果地球上不同地方的人们同时看一眼手表，他们各自的本地时间是不同的！ 所以，不同的时区，在同一时刻，本地时间是不同的。全球一共分为24个时区，伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区！ eg：2020-1-1 20:21:59 ¶2、时区 光靠本地时间还无法唯一确定一个准确的时刻，所以我们还需要给本地时间加上一个时区： 以GMT或者UTC加时区偏移表示，例如：GMT+08:00或者UTC+08:00表示东八区。（GMT和UTC可以认为基本是等价的，只是UTC使用更精确的原子钟计时，每隔几年会有一个闰秒，我们在开发程序的时候可以忽略两者的误差，因为计算机的时钟在联网的时候会自动与时间服务器同步时间。） 另一种是缩写，例如，CST表示China Standard Time，也就是中国标准时间。但是CST也可以表示美国中部时间Central Standard Time USA，因此，缩写容易产生混淆，我们尽量不要使用缩写。 最后一种是以洲／城市表示，例如，Asia/Shanghai，表示上海所在地的时区。特别注意城市名称不是任意的城市，而是由国际标准组织规定的城市。 ¶3、夏令时 所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。我们国家实行过一段时间夏令时，1992年就废除了，但是矫情的美国人到现在还在使用，所以时间换算更加复杂。 实行夏令时的不同地区，进入和退出夏令时的时间很可能是不同的。同一个地区，根据历史上是否实行过夏令时，标准时间在不同年份换算成当地时间也是不同的。因此，计算夏令时，没有统一的公式，必须按照一组给定的规则来算，并且，该规则要定期更新。 计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。 时区 2019-11-20 2019-6-20 GMT-05:00 19:00 19:00 UTC-05:00 19:00 19:00 America/New_York 19:00 20:00 ¶4、本地化 在计算机中，通常使用Locale表示一个国家或地区的日期、时间、数字、货币等格式。Locale由语言_国家的字母缩写构成，例如，zh_CN表示中文+中国，en_US表示英文+美国。语言使用小写，国家使用大写。 计算机用Locale在日期、时间、货币和字符串之间进行转换！ 对于日期来说，不同的Locale，例如，中国和美国的表示方式如下： zh_CN：2016-11-30 en_US：11/30/2016 ¶二、Date和Calendar ¶1、Epoch Time Epoch Time是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数！ Epoch Time又称为时间戳！ 1231574208900 = 北京时间2019-11-20 8:15:00 = 伦敦时间2019-11-20 0:15:00 = 纽约时间2019-11-19 19:15:00 因此，在计算机中，只需要存储一个整数1574208900表示某一时刻。当需要显示为某一地区的当地时间时，我们就把它格式化为一个字符串 时间戳在不同的编程语言中，会有几种存储方式： 以秒为单位的整数：1574208900，缺点是精度只能到秒； 以毫秒为单位的整数：1574208900123，最后3位表示毫秒数； 以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。 它们之间转换非常简单。而在Java程序中，时间戳通常是用long表示的毫秒数 1long t = 1574208900123L; 转换成北京时间就是2019-11-20T8:15:00.123。要获取当前时间戳，可以使用System.currentTimeMillis()，这是Java程序获取时间戳最常用的方法。 ¶2、标准库API Java标准库有两套处理日期和时间的API： 一套定义在java.util这个包里面，主要包括Date、Calendar和TimeZone这几个类； 一套新的API是在Java 8引入的，定义在java.time这个包里面，主要包括LocalDateTime、ZonedDateTime、ZoneId等。 为什么会有新旧两套API呢？因为历史遗留原因，旧的API存在很多问题，所以引入了新的API。 那么我们能不能跳过旧的API直接用新的API呢？如果涉及到遗留代码就不行，因为很多遗留代码仍然使用旧的API，所以目前仍然需要对旧的API有一定了解，很多时候还需要在新旧两种对象之间进行转换。 ¶3、Date Date对象有几个严重的问题：它不能转换时区，除了toGMTString()可以按GMT+0:00输出外，Date总是以当前计算机系统的默认时区为基础进行输出。此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。 java.util.Date是用于表示一个日期和时间的对象，注意与java.sql.Date区分，后者用在数据库中。如果观察Date的源码，可以发现它实际上存储了一个long类型的以毫秒表示的时间戳： 123456public class Date implements Serializable, Cloneable, Comparable&lt;Date&gt; { private transient long fastTime; ...} ¶常用方法： 注意getYear()返回的年份必须加上1900，getMonth()返回的月份是0~11分别表示1~12月，所以要加1，而getDate()返回的日期范围是1~31，又不能加1。 1234567891011121314151617181920212223package com.learn.file;import java.util.Date;public class DateTest { public static void main(String[] args) { // 获取当前时间戳： long time = System.currentTimeMillis(); System.out.println(time); // 1586770437800 最后三位表示毫秒数，即0.xxx秒 // 获取当前时间: Date date = new Date(); System.out.println(date.getYear() + 1900); // 必须加上1900 System.out.println(date.getMonth() + 1); // 0~11，必须加上1 System.out.println(date.getDate()); // 1~31，不能加1 // 转换为String: 输出为CST格式（即China Standard Time缩写） System.out.println(date.toString()); // Mon Apr 13 17:43:12 CST 2020 // 转换为GMT时区: System.out.println(date.toGMTString()); // 13 Apr 2020 09:43:12 GMT // 转换为本地时区: System.out.println(date.toLocaleString()); // 2020年4月13日 下午5:43:12 }} ¶使用SimpleDateFormat进行格式化 有如下格式： yyyy：年 MM：月 dd: 日 HH: 小时 mm: 分钟 ss: 秒 E: 周几 123456789101112package com.learn.file;import java.text.SimpleDateFormat;import java.util.Date;public class DateTest { public static void main(String[] args) { Date date1 = new Date(); var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(sdf.format(date1)); // 2020-04-13 17:48:42 }} Java的格式化预定义了许多不同的格式，我们以MMM和E为例： M：输出9 MM：输出09 MMM：输出Sep MMMM：输出September 12345678910111213141516171819package com.learn.file;import java.text.SimpleDateFormat;import java.util.Date;public class DateTest { public static void main(String[] args) { Date date2 = new Date(); var sdf2 = new SimpleDateFormat(\"E M dd, yyyy\"); var sdf3 = new SimpleDateFormat(\"E MM dd, yyyy\"); var sdf4 = new SimpleDateFormat(\"E MMM dd, yyyy\"); var sdf5 = new SimpleDateFormat(\"E MMMM dd, yyyy\"); System.out.println(sdf2.format(date2)); //周一 4 13, 2020 System.out.println(sdf3.format(date2)); //周一 04 13, 2020 System.out.println(sdf4.format(date2)); //周一 4月 13, 2020 System.out.println(sdf5.format(date2)); //周一 四月 13, 2020 }} ¶4、Calendar Calendar可以用于获取并设置年、月、日、时、分、秒，它和Date比，主要多了一个可以做简单的日期和时间运算的功能。 Calendar获取年月日这些信息变成了get(int field)，返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，1~7分别表示周日，周一，……，周六。 Calendar只有一种方式获取，即Calendar.getInstance()： 1234567891011121314151617181920package com.learn.file;import java.util.Calendar;public class CalendarTest { public static void main(String[] args) { // 获取当前时间: Calendar c = Calendar.getInstance(); int y = c.get(Calendar.YEAR); int m = 1 + c.get(Calendar.MONTH); int d = c.get(Calendar.DAY_OF_MONTH); int w = c.get(Calendar.DAY_OF_WEEK); int hh = c.get(Calendar.HOUR_OF_DAY); int mm = c.get(Calendar.MINUTE); int ss = c.get(Calendar.SECOND); int ms = c.get(Calendar.MILLISECOND); System.out.println(y + \"-\" + m + \"-\" + d + \" \" + w + \" \" + hh + \":\" + mm + \":\" + ss + \".\" + ms); // 2020-4-13 2 18:1:7.601 }} ¶设置成特定的一个日期和时间 必须先清除所有字段： 利用Calendar.getTime()可以将一个Calendar对象转换成Date对象，然后就可以用SimpleDateFormat进行格式化了。 1234567891011121314151617181920212223242526package com.learn.file;import java.text.SimpleDateFormat;import java.util.Calendar;public class CalendarTest { public static void main(String[] args) { // 获取当前时间: Calendar c = Calendar.getInstance(); // 清除所有: c.clear(); // 设置2020年: c.set(Calendar.YEAR, 2020); // 设置4月:注意3表示4月: c.set(Calendar.MONTH, 3); // 设置2日: c.set(Calendar.DATE, 13); // 设置时间: c.set(Calendar.HOUR_OF_DAY, 18); c.set(Calendar.MINUTE, 20); c.set(Calendar.SECOND, 23); // 使用getTime转化为Date对象，再使用SimpleDateFormat格式化输出： System.out.println(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(c.getTime())); // 2019-09-02 21:22:23 }} ¶5、TimeZone Calendar和Date相比，它提供了时区转换的功能。时区用TimeZone对象表示 1234567891011121314package com.learn.file;import java.util.TimeZone;public class TimeZoneTest { public static void main(String[] args) { TimeZone tzDefault = TimeZone.getDefault(); // 当前时区 TimeZone tzGMT9 = TimeZone.getTimeZone(\"GMT+09:00\"); // GMT+9:00时区 TimeZone tzNY = TimeZone.getTimeZone(\"America/New_York\"); // 纽约时区 System.out.println(tzDefault.getID()); // Asia/Shanghai System.out.println(tzGMT9.getID()); // GMT+09:00 System.out.println(tzNY.getID()); // America/New_York }} 时区的唯一标识是以字符串表示的ID，我们获取指定TimeZone对象也是以这个ID为参数获取，GMT+09:00、Asia/Shanghai都是有效的时区ID。 可使用TimeZone.getAvailableIDs()方法来列出系统支持的所有时区ID： 1System.out.println(Arrays.toString(TimeZone.getAvailableIDs())); ¶对指定时间进行转换 利用Calendar进行时区转换的步骤是： 清除所有字段； 设定指定时区； 设定日期和时间； 创建SimpleDateFormat并设定目标时区； 格式化获取的Date对象（注意Date对象无时区信息，时区信息存储在SimpleDateFormat中）。 本质上时区转换只能通过SimpleDateFormat在显示的时候完成 将北京时间转换为纽约时间： 1234567891011121314151617181920212223242526272829package com.learn.file;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.TimeZone;public class TimeZoneTest { public static void main(String[] args) { // 当前时间: Calendar c = Calendar.getInstance(); // 清除所有: c.clear(); // 设置为北京时区: c.setTimeZone(TimeZone.getTimeZone(\"Asia/Shanghai\")); // 设置年月日时分秒: c.set(2020, 3 /* 4月 */, 13, 18, 15, 0); // 或者这样： c.set(2020, Calendar.APRIL /* 11月 */, 13, 18, 15, 0); // 显示时间: System.out.println(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(c.getTime())); // 2020-04-13 18:15:00 var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); sdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\")); System.out.println(sdf.format(c.getTime())); // 2020-04-13 06:15:00 }} ¶对日期和时间进行简单加减 123456789101112131415161718192021222324package com.learn.file;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.TimeZone;public class TimeZoneTest { public static void main(String[] args) { // 当前时间: Calendar c1 = Calendar.getInstance(); // 清除所有: c1.clear(); // 设置年月日时分秒: c1.set(2020, 3 /* 4月 */, 13, 18, 15, 0); var sdf1 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(sdf1.format(c1.getTime())); // 2020-04-13 18:15:00 // 加5天并减去2小时: c1.add(Calendar.DAY_OF_MONTH, 5); c1.add(Calendar.HOUR_OF_DAY, -2); // 显示时间: System.out.println(sdf1.format(c1.getTime())); // 2020-04-18 16:15:00 }} ¶三、LocalDateTime 从Java 8开始，java.time包提供了新的日期和时间API： 和旧的API相比，新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便。 此外，新API修正了旧API不合理的常量设计： Month的范围用1~12表示1月到12月； Week的范围用1~7表示周一到周日。 最后，新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。 LocalDateTime无法与时间戳进行转换，因为LocalDateTime没有时区，无法确定某一时刻。后面我们要介绍的ZonedDateTime相当于LocalDateTime加时区的组合，它具有时区，可以与long表示的时间戳进行转换。 主要涉及的类型有： 本地日期和时间：LocalDateTime，LocalDate，LocalTime； 带时区的日期和时间：ZonedDateTime； 时刻：Instant； 时区：ZoneId，ZoneOffset； 时间间隔：Duration。 以及一套新的用于取代SimpleDateFormat的格式化类型DateTimeFormatter。 ¶1、LocalDateTime 本地日期和时间通过now()获取到的总是以当前默认时区返回的，和旧API不同，LocalDateTime、LocalDate和LocalTime默认严格按照ISO 8601规定的日期和时间格式进行打印。 LocalTime的精度是纳秒！ 12345678910111213141516package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;public class LocalDateTimeTest { public static void main(String[] args) { LocalDate d = LocalDate.now(); // 当前日期 LocalTime t = LocalTime.now(); // 当前时间 LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间 System.out.println(d); // 严格按照ISO 8601格式打印 2020-04-13 System.out.println(t); // 严格按照ISO 8601格式打印 19:34:03.468952 System.out.println(dt); // 严格按照ISO 8601格式打印 2020-04-13T19:34:03.468952 }} ¶LocalDate和LocalTime与LocalDateTime互转 下面代码其实有一个小问题，在获取3个类型的时候，由于执行一行代码总会消耗一点时间，因此，3个类型的日期和时间很可能对不上（时间的毫秒数基本上不同）。为了保证获取到同一时刻的日期和时间，可以改写如下： 123456789101112131415161718192021package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;public class LocalDateTimeTest { public static void main(String[] args) { // LocalDateTime -&gt; LocalDate/LocalTime LocalDateTime dt1 = LocalDateTime.now(); // 当前日期和时间 LocalDate d1 = dt1.toLocalDate(); // 转换到当前日期 LocalTime t1 = dt1.toLocalTime(); // 转换到当前时间 // // LocalDate/LocalTime -&gt; LocalDateTime // 指定日期和时间: LocalDate d2 = LocalDate.of(2019, 11, 30); // 2019-11-30, 注意11=11月 LocalTime t2 = LocalTime.of(15, 16, 17); // 15:16:17 LocalDateTime dt2 = LocalDateTime.of(2019, 11, 30, 15, 16, 17); LocalDateTime dt3 = LocalDateTime.of(d2, t2); }} ¶字符串转换为LocalDateTime 12345678910111213package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;public class LocalDateTimeTest { public static void main(String[] args) { LocalDateTime dt4 = LocalDateTime.parse(\"2019-11-19T15:16:17\"); LocalDate d4 = LocalDate.parse(\"2019-11-19\"); LocalTime t4 = LocalTime.parse(\"15:16:17\"); }} ¶日期和时间之间的 ‘T’ 注意ISO 8601规定的日期和时间分隔符是T。标准格式如下： 日期：yyyy-MM-dd 时间：HH:mm:ss 带毫秒的时间：HH:mm:ss.SSS 日期和时间：yyyy-MM-dd’T’HH:mm:ss 带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS ¶2、DateTimeFormatter 自定义输出的格式，或者要把一个非ISO 8601格式的字符串解析成LocalDateTime： 123456789101112131415161718package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;public class LocalDateTimeTest { public static void main(String[] args) { // 自定义格式化: DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\"); System.out.println(dtf.format(LocalDateTime.now())); // 用自定义格式解析: LocalDateTime dt5 = LocalDateTime.parse(\"2019/11/30 15:16:17\", dtf); System.out.println(dt5); // 2019-11-30T15:16:17 }} ¶3、对日期和时间进行简单加减 注意到月份加减会自动调整日期，例如从2019-10-31减去1个月得到的结果是2019-09-30，因为9月没有31日： 12345678910111213141516171819package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;public class LocalDateTimeTest { public static void main(String[] args) { LocalDateTime dt6 = LocalDateTime.of(2019, 10, 26, 20, 30, 59); System.out.println(dt6); // 2019-10-26T20:30:59 // 加5天减3小时: LocalDateTime dt7 = dt6.plusDays(5).minusHours(3); System.out.println(dt7); // 2019-10-31T17:30:59 // 减1月: LocalDateTime dt8 = dt7.minusMonths(1); System.out.println(dt8); // 2019-09-30T17:30:59 }} ¶4、对日期和时间进行调整 常用方法： 调整年：withYear() 调整月：withMonth() 调整日：withDayOfMonth() 调整时：withHour() 调整分：withMinute() 调整秒：withSecond() 同样注意到调整月份时，会相应地调整日期，即把2019-10-31的月份调整为9时，日期也自动变为30。 12345678910111213141516171819package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;public class LocalDateTimeTest { public static void main(String[] args) { LocalDateTime dt9 = LocalDateTime.of(2019, 10, 26, 20, 30, 59); System.out.println(dt9); // 2019-10-26T20:30:59 // 日期变为31日: LocalDateTime dt10 = dt9.withDayOfMonth(31); System.out.println(dt2); // 2019-10-31T20:30:59 // 月份变为9: LocalDateTime dt11 = dt10.withMonth(9); System.out.println(dt11); // 2019-09-30T20:30:59 }} ¶5、使用with()方法做更复杂的运算 对于计算某个月第1个周日这样的问题，新的API可以轻松完成。 基本就是first和last的组合吧！ 1234567891011121314151617181920212223242526package com.learn.file;import java.time.DayOfWeek;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.temporal.TemporalAdjusters;public class LocalTest { public static void main(String[] args) { // 本月第一天0:00时刻: LocalDateTime firstDay = LocalDate.now().withDayOfMonth(1).atStartOfDay(); System.out.println(firstDay); // 2020-04-01T00:00 // 本月最后1天: LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth()); System.out.println(lastDay); // 2020-04-30 // 下月第1天: LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth()); System.out.println(nextMonthFirstDay); // 2020-05-01 // 本月第1个周一: LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)); System.out.println(firstWeekday); // 2020-04-06 }} ¶6、判断时间先后 要判断两个LocalDateTime的先后，可以使用isBefore()、isAfter()方法，对于LocalDate和LocalTime类似： 1234567891011121314151617package com.learn.file;import java.time.DayOfWeek;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.temporal.TemporalAdjusters;public class LocalTest { public static void main(String[] args) { LocalDateTime now = LocalDateTime.now(); LocalDateTime target = LocalDateTime.of(2019, 11, 19, 8, 15, 0); System.out.println(now.isBefore(target)); // false System.out.println(LocalDate.now().isBefore(LocalDate.of(2019, 11, 19))); // false System.out.println(LocalTime.now().isAfter(LocalTime.parse(\"08:15:00\"))); // true }} ¶6、Duration和Period Duration表示两个时刻之间的时间间隔。 另一个类似的Period表示两个日期之间的天数： Duration和Period的表示方法也符合ISO 8601的格式，它以P...T...的形式表示，P...T之间表示日期间隔，T后面表示时间间隔。如果是PT...的格式表示仅有时间间隔： 123456789101112131415161718package com.learn;import java.time.Duration;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.Period;public class DurationAndPeriod { public static void main(String[] args) { LocalDateTime start = LocalDateTime.of(2019, 11, 19, 8, 15, 0); LocalDateTime end = LocalDateTime.of(2020, 1, 9, 19, 25, 30); Duration d = Duration.between(start, end); System.out.println(d); // PT1235H10M30S 表示1235小时10分钟30秒 Period p = LocalDate.of(2019, 11, 19).until(LocalDate.of(2020, 1, 9)); System.out.println(p); // P1M21D 表示1个月21天 }} 利用ofXxx()或者parse()方法也可以直接创建Duration： 1234567891011121314package com.learn;import java.time.Duration;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.Period;public class DurationAndPeriod { public static void main(String[] args) { Duration d1 = Duration.ofHours(10); // 10 hours Duration d2 = Duration.parse(\"P1DT2H3M\"); // 1 day, 2 hours, 3 minutes }} ¶四、ZonedDateTime LocalDateTime总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要ZonedDateTime。 可以简单地把ZonedDateTime理解成LocalDateTime加ZoneId。ZoneId是java.time引入的新的时区类，注意和旧的java.util.TimeZone区别。 ¶1、创建ZonedDateTime对象 ¶1.1 一种是通过now()方法返回当前时间： 下面时区不同，但表示的时间都是同一时刻（毫秒数不同是执行语句时的时间差）： 时间相不同，时区不同，时刻相同： 12345678910111213package com.learn.file;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区 ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(\"America/New_York\")); // 用指定时区获取当前时间 System.out.println(zbj); // 2020-04-13T20:49:45.964482300+08:00[Asia/Shanghai] System.out.println(zny); // 2020-04-13T08:49:45.971487100-04:00[America/New_York] }} ¶1.2 通过给一个LocalDateTime附加一个ZoneId 以这种方式创建的ZonedDateTime，它的日期和时间与LocalDateTime相同，但附加的时区不同，因此是两个不同的时刻： 时间相同，时区不同，时刻不同： 123456789101112131415package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { LocalDateTime ldt = LocalDateTime.of(2019, 9, 15, 15, 16, 17); ZonedDateTime zbj1 = ldt.atZone(ZoneId.systemDefault()); ZonedDateTime zny1 = ldt.atZone(ZoneId.of(\"America/New_York\")); System.out.println(zbj1); // 2019-09-15T15:16:17+08:00[Asia/Shanghai] System.out.println(zny1); // 2019-09-15T15:16:17-04:00[America/New_York] }} ¶2、时区转换 通过withZoneSameInstant()将关联时区转换到另一个时区，转换后日期和时间都会相应调整： 时刻相同，时间改变，日期改变，时区改变： 12345678910111213141516package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { // 以中国时区获取当前时间: ZonedDateTime zbj2 = ZonedDateTime.now(ZoneId.of(\"Asia/Shanghai\")); // 转换为纽约时间: ZonedDateTime zny2 = zbj2.withZoneSameInstant(ZoneId.of(\"America/New_York\")); System.out.println(zbj2); // 2020-04-13T20:58:58.227352600+08:00[Asia/Shanghai] System.out.println(zny2); // 2020-04-13T08:58:58.227352600-04:00[America/New_York] }} ¶3、夏令时处理 时区转换的时候，由于夏令时的存在，不同的日期转换的结果很可能是不同的。 涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。 如下：有一个小时的夏令时时差： 123452019-09-15T21:05:50.187697+08:00[Asia/Shanghai]2019-09-15T09:05:50.187697-04:00[America/New_York]2019-11-15T21:05:50.187697+08:00[Asia/Shanghai]2019-11-15T08:05:50.187697-05:00[America/New_York] ¶使用ZonedDateTime处理 将一个未知时区转换为本地时间，转换为本地时间时，内部使用的就是ZonedDateTime的时区信息： 1234567891011121314package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(\"America/New_York\")); LocalDateTime ldt1 = zdt.toLocalDateTime(); System.out.println(zdt); // 2020-04-13T09:15:56.939055400-04:00[America/New_York] System.out.println(ldt1); // 2020-04-13T09:15:56.939055400 }} ¶4、对日期和时间进行简单加减 ZonedDateTime仍然提供了plusDays()等加减操作。 12345678910111213package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { ZonedDateTime zdt1 = ZonedDateTime.now(); System.out.println(zdt1); // 2020-04-13T21:21:24.013394800+08:00[Asia/Shanghai] System.out.println(zdt1.plusDays(5).minusHours(3)); // 2020-04-18T18:21:24.013394800+08:00[Asia/Shanghai] }} ¶5、一个时间转换例子 某航线从北京飞到纽约需要13小时20分钟，请根据北京起飞日期和时间计算到达纽约的当地日期和时间。 123456789101112131415161718192021222324252627282930313233343536package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { // 一个例子： LocalDateTime departureAtBeijing = LocalDateTime.of(2019, 9, 15, 13, 0, 0); int hours = 13; int minutes = 20; LocalDateTime arrivalAtNewYork = calculateArrivalAtNY(departureAtBeijing, hours, minutes); System.out.println(departureAtBeijing + \" -&gt; \" + arrivalAtNewYork); // 2019-09-15T13:00 -&gt; 2019-09-15T14:20 // test: if (!LocalDateTime.of(2019, 10, 15, 14, 20, 0) .equals(calculateArrivalAtNY(LocalDateTime.of(2019, 10, 15, 13, 0, 0), 13, 20))) { System.err.println(\"测试失败!\"); } else if (!LocalDateTime.of(2019, 11, 15, 13, 20, 0) .equals(calculateArrivalAtNY(LocalDateTime.of(2019, 11, 15, 13, 0, 0), 13, 20))) { System.err.println(\"测试失败!\"); } } static LocalDateTime calculateArrivalAtNY(LocalDateTime bj, int h, int m) { // 加上用时后转化为不带时区的LocalDateTime： bj = bj.plusHours(h).plusMinutes(m); // lbj和lbj1都可以：将时区转化为上海 ZonedDateTime lbj = ZonedDateTime.of(bj, ZoneId.of(\"Asia/Shanghai\")); ZonedDateTime lbj1 = bj.atZone(ZoneId.of(\"Asia/Shanghai\")); // 将时区转化为纽约： ZonedDateTime zdt = lbj1.withZoneSameInstant(ZoneId.of(\"America/New_York\")); // 返回LocalDateTime类型的时间： return zdt.toLocalDateTime(); }} ¶五、DateTimeFormatter 使用旧的Date对象时，我们用SimpleDateFormat进行格式化显示。使用新的LocalDateTime或ZonedLocalDateTime时，我们要进行格式化显示，就要使用DateTimeFormatter。 和SimpleDateFormat不同的是，DateTimeFormatter不但是不变对象，它还是线程安全的（后面会学到！）。 因为SimpleDateFormat不是线程安全的，使用的时候，只能在方法内部创建新的局部变量。而DateTimeFormatter可以只创建一个实例，到处引用。 ¶1、创建DateTimeFormatter 传入字符串 123456789101112package com.learn.file;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;public class DateTimeFormatterTest { public static void main(String[] args) { DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\"); ZonedDateTime zonedDateTime = ZonedDateTime.now(); System.out.println(formatter.format(zonedDateTime)); // 2020-04-13 22:25 }} 同时传入Local 12345678910111213package com.learn.file;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.util.Locale;public class DateTimeFormatterTest { public static void main(String[] args) { DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern(\"E,yyyy-MMMM-dd HH:mm\", Locale.US); ZonedDateTime zonedDateTime1 = ZonedDateTime.now(); System.out.println(formatter1.format(zonedDateTime1)); // Mon,2020-April-13 22:30 }} ¶2、一些格式化例子 分别以默认方式、中国地区和美国地区对当前时间进行显示： 12345678910111213141516171819package com.learn.file;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.util.Locale;public class DateTimeFormatterTest { public static void main(String[] args) { ZonedDateTime zdt = ZonedDateTime.now(); var formatter2 = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm ZZZZ\"); System.out.println(formatter2.format(zdt)); // 2020-04-13T22:32 GMT+08:00 var zhFormatter = DateTimeFormatter.ofPattern(\"yyyy MMM dd EE HH:mm\", Locale.CHINA); System.out.println(zhFormatter.format(zdt)); // 2020 4月 13 周一 22:32 var usFormatter = DateTimeFormatter.ofPattern(\"E, MMMM/dd/yyyy HH:mm\", Locale.US); System.out.println(usFormatter.format(zdt)); // Mon, April/13/2020 22:32 }} 当我们直接调用System.out.println()对一个ZonedDateTime或者LocalDateTime实例进行打印的时候，实际上，调用的是它们的toString()方法，默认的toString()方法显示的字符串就是按照ISO 8601格式显示的，我们可以通过DateTimeFormatter预定义的几个静态变量来引用： 123456789101112131415package com.learn.file;import java.time.LocalDateTime;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.util.Locale;public class DateTimeFormatterTest { public static void main(String[] args) { var ldt = LocalDateTime.now(); System.out.println(DateTimeFormatter.ISO_DATE.format(ldt)); // 2020-04-13 System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt)); // 2020-04-13T22:36:25.9843329 }} ¶六、Instant 计算机存储的当前时间，本质上只是一个不断递增的整数。Java提供的System.currentTimeMillis()返回的就是以毫秒表示的当前时间戳。 这个当前时间戳在java.time中以Instant类型表示，我们用Instant.now()获取当前时间戳： Instant内部只有两个核心字段： 一个是以秒为单位的时间戳， 一个是更精确的纳秒精度。 它和System.currentTimeMillis()返回的long相比，只是多了更高精度的纳秒。 ¶1、Instant的创建 直接输出Instant默认是伦敦的标准时区，和我们东八区差半个小时： 1234567891011121314151617package com.learn.file;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;public class InstantTest { public static void main(String[] args) { System.out.println(System.currentTimeMillis()); // 1586855486387 Instant instant = Instant.now(); System.out.println(instant); // 2020-04-14T09:55:19.411338900Z // 按秒表示： System.out.println(instant.getEpochSecond()); // 1586855486 // 按毫秒表示： System.out.println(instant.toEpochMilli()); // 1586855486388 }} ¶2、Instant +ZonedId = ZonedDateTime 既然Instant就是时间戳，那么，给它附加上一个时区，就可以创建出ZonedDateTime： 对于某一个时间戳，给它关联上指定的ZoneId，就得到了ZonedDateTime，继而可以获得了对应时区的LocalDateTime。 1234567891011121314151617package com.learn.file;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;public class InstantTest { public static void main(String[] args) { // 以指定时间戳创建Instant: Instant ins = Instant.now(); Instant ins1 = Instant.ofEpochSecond(1586855486); ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault()); ZonedDateTime zdt1 = ins1.atZone(ZoneId.of(\"Asia/Shanghai\")); System.out.println(zdt); // 2020-04-14T17:13:51.251631400+08:00[Asia/Shanghai] System.out.println(zdt1); // 2020-04-14T17:11:26+08:00[Asia/Shanghai] }} ¶3、类之间的相互转换 long指的是以long表示的一个时间戳： 123456789101112┌─────────────┐│LocalDateTime│────┐└─────────────┘ │ ┌─────────────┐ ├───&gt;│ZonedDateTime│┌─────────────┐ │ └─────────────┘│ ZoneId │────┘ ▲└─────────────┘ ┌─────────┴─────────┐ │ │ ▼ ▼ ┌─────────────┐ ┌─────────────┐ │ Instant │&lt;───&gt;│ long │ └─────────────┘ └─────────────┘ ¶七、新旧API的互相转换 由于Java提供了新旧两套日期和时间的API，除非涉及到遗留代码，否则我们应该坚持使用新的API。 如果需要与遗留代码打交道，则需要在新旧API之间进行互相转换！ 处理日期和时间时，尽量使用新的java.time包； ¶1、旧API转新API 把旧式的Date或Calendar转换为新API对象，可以通过toInstant()方法转换为Instant对象，再继续转换为ZonedDateTime： Calendar -&gt; ZonedDateTime时：应该使用本身自带的时区信息，calendar.getTimeZone().toZoneId()，即将旧的TimeZone转化为新的ZoneId。或者可以直接使用atZone()来指定时区： 123456789101112131415161718192021222324252627package com.learn;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;import java.util.Calendar;import java.util.Date;public class NewOldAPI { public static void main(String[] args) { // Date -&gt; Instant：（无时区） System.out.println(new Date()); // Tue Apr 14 18:12:07 CST 2020 Instant instant = new Date().toInstant(); System.out.println(instant); // Calendar -&gt; Instant -&gt; ZonedDateTime Calendar calendar = Calendar.getInstance(); Instant instant1 = calendar.toInstant(); ZonedDateTime zonedDateTime = instant1.atZone(ZoneId.systemDefault()); System.out.println(zonedDateTime); // 2020-04-14T18:19:18.108+08:00[Asia/Shanghai] ZonedDateTime zdt = instant1.atZone(calendar.getTimeZone().toZoneId()); System.out.println(zdt); // 2020-04-14T18:19:18.108+08:00[Asia/Shanghai] System.out.println(calendar.getTimeZone().toZoneId()); // Asia/Shanghai }} ¶2、新API转旧API 把新的ZonedDateTime转换为旧的API对象，只能借助long型时间戳做一个“中转”： 使用ZonedDateTime.toEpochSecond()方法，获得时间戳的秒数，乘以1000获得毫秒数，然后用Date创建即可：（Date接收的参数为毫秒，不是秒！） 123456789101112131415161718192021222324252627282930313233343536package com.learn;import java.text.SimpleDateFormat;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;import java.util.Calendar;import java.util.Date;import java.util.TimeZone;public class NewOldAPI { public static void main(String[] args) { // ZonedDateTime -&gt; long -&gt; Date ZonedDateTime zonedDateTime1 = ZonedDateTime.now(); long l = zonedDateTime1.toEpochSecond() * 1000; Date date = new Date(l); System.out.println(date); // Tue Apr 14 18:35:52 CST 2020 // ZonedDateTime -&gt; long -&gt; Calendar: ZonedDateTime zonedDateTime2 = ZonedDateTime.now(); // 创建Calender： Calendar calendar1 = Calendar.getInstance(); // 清空： calendar1.clear(); //设置时区TimeZone: (两者都可) calendar1.setTimeZone(TimeZone.getTimeZone(zonedDateTime2.getZone())); calendar1.setTimeZone(TimeZone.getTimeZone(zonedDateTime2.getZone().getId())); System.out.println(zonedDateTime2.getZone()); // Asia/Shanghai System.out.println(zonedDateTime2.getZone().getId()); // Asia/Shanghai // 设置时间戳：（传入毫秒，需要将秒*1000） calendar1.setTimeInMillis(zonedDateTime2.toEpochSecond() * 1000); // 将Calender转化为Date再使用SimpleDateFormat进行格式化： System.out.println(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(calendar1.getTime())); // 2020-04-14 18:45:59 }} ¶3、数据库中存储日期时间 除了旧式的java.util.Date，我们还可以找到另一个java.sql.Date，它继承自java.util.Date，但会自动忽略所有时间相关信息。这个奇葩的设计原因要追溯到数据库的日期与时间类型。 在数据库中，我们需要存储的最常用的是时刻（Instant），因为有了时刻信息，就可以根据用户自己选择的时区，显示出正确的本地时间。所以，最好的方法是直接用长整数long表示，在数据库中存储为BIGINT类型。 在数据库中存储时间戳时，尽量使用long型时间戳，它具有省空间，效率高，不依赖数据库的优点。 在数据库中，也存在几种日期和时间类型： DATETIME：表示日期和时间； DATE：仅表示日期； TIME：仅表示时间； TIMESTAMP：和DATETIME类似，但是数据库会在创建或者更新记录的时候同时修改TIMESTAMP。 ¶数据库类型与Java新旧API的映射关系 数据库 对应Java类（旧） 对应Java类（新） DATETIME java.util.Date LocalDateTime DATE java.sql.Date LocalDate TIME java.sql.Time LocalTime TIMESTAMP java.sql.Timestamp LocalDateTime ¶4、为不同用户以不同的偏好来显示不同的本地时间 DateTimeFormatter：其中的ofLocalizedDateTime()方法，传入两个参数，一个日期格式，一个时间格式，具体的参数可以查看JDK源码，Idea直接按住Ctrl+左键即可跳转到源码对应位置： 123456789101112131415161718192021222324252627282930package com.learn;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.time.format.FormatStyle;import java.util.Locale;public class DateTimeWork { public static void main(String[] args) { Instant instant = Instant.now(); long l = instant.toEpochMilli(); System.out.println(instant.toEpochMilli()); System.out.println(timestampToString(l, Locale.CHINA, \"Asia/Shanghai\")); // 2020年4月14日 下午7:21 System.out.println(timestampToString(l, Locale.US, \"America/New_York\")); //Apr 14, 2020, 7:21 AM } static String timestampToString(long epochMilli, Locale lo, String zoneId) { // 将long转化为Instant： Instant ins = Instant.ofEpochMilli(epochMilli); // 创建格式化方法： DateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT); // 将Instant按照当前ZoneId转化为ZonedDateTime再使用DateTimeFormatter进行格式化： // 方式一：不传Local则会默认以中国格式输出： //return f.format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId))); // 2020年4月14日 上午7:28 // 方式二：传Local会以当前国家格式输出： return f.withLocale(lo).format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId))); // Apr 14, 2020, 7:28 AM }} 本节已经完结！敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Date","slug":"Date","permalink":"https://www.itnxd.cn/tags/Date/"},{"name":"Time","slug":"Time","permalink":"https://www.itnxd.cn/tags/Time/"}],"author":"Mr.Niu"},{"title":"Java教程系列之IO流","slug":"Java教程系列之IO流","date":"2020-04-10T14:12:52.000Z","updated":"2021-02-06T14:18:12.441Z","comments":true,"path":"posts/61053.html","link":"","permalink":"https://www.itnxd.cn/posts/61053.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶一、IO介绍 IO是指Input/Output，即输入和输出。以内存为中心： Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。 Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。 IO流是一种流式的数据输入/输出模型： 二进制数据以byte为最小单位在InputStream/OutputStream中单向流动； 字符数据以char为最小单位在Reader/Writer中单向流动。 Java标准库的java.io包提供了同步IO功能： 字节流接口：InputStream/OutputStream； 字符流接口：Reader/Writer。 注意：UTF-8编码下，英文字符占一个字节，中文字符占三个字节！ Java的读写数据在传输时都是byte[]，String这两种方式！ ¶1、Reader 和 Writer 如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照char来读写显然更方便，这种流称为字符流。 Reader和Writer本质上是一个能自动编解码的InputStream和OutputStream。 使用Reader，数据源虽然是字节，但我们读入的数据都是char类型的字符，原因是Reader内部把读入的byte做了解码，转换成了char。使用InputStream，我们读入的数据和原始二进制数据一模一样，是byte[]数组，但是我们可以自己把二进制byte[]数组按照某种编码转换为字符串。究竟使用Reader还是InputStream，要取决于具体的使用场景。如果数据源不是文本，就只能使用InputStream，如果数据源是文本，使用Reader更方便一些。Writer和OutputStream是类似的。 ¶2、同步和异步 同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。 而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。 Java标准库的包java.io提供了同步IO，而java.nio则是异步IO。上面我们讨论的InputStream、OutputStream、Reader和Writer都是同步IO的抽象类，对应的具体实现类，以文件为例，有FileInputStream、FileOutputStream、FileReader和FileWriter。 ¶二、File对象 ¶1、创建File对象 File file = new File(\"路径\"); ¶1.1 路径的写法 注意Windows平台使用\\作为路径分隔符，在Java字符串中需要用\\\\表示一个\\。Linux平台使用/作为路径分隔符： 用.表示当前目录，..表示上级目录。 12345678910111213141516171819202122package com.learn.file;import java.io.File;import java.io.FilenameFilter;import java.io.IOException;public class FileTest { public static void main(String[] args) throws IOException { File file = new File(\".\"); File file01 = new File(\".\\\\\"); File file02 = new File(\"..\\\\\"); File file1 = new File(\"..\"); File file2 = new File(\"Settings\\\\setting.properties\"); File file3 = new File(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\"); // 打印系统当前分隔符： System.out.println(File.separator); // / // Linux 下路径写法，斜杠换一下即可！ File f = new File(\"/usr/bin/javac\"); }} ¶1.2 获取路径 getPath()：返回构造方法传入的路径，直接输出File对象名效果一样！ getAbsolutePath()：返回绝对路径，若传入参数有.，则该方法也会出现.; getCanonicalPath()：返回的是规范路径，若传入参数有.，则该方法会将点翻译为正确路径; 路径如下： 12345678910111213141516171819202122232425262728293031323334353637383940package com.learn.file;import java.io.File;import java.io.FilenameFilter;import java.io.IOException;public class FileTest { public static void main(String[] args) throws IOException { File file = new File(\".\"); System.out.println(file); // . System.out.println(file.getPath()); // . System.out.println(file.getAbsolutePath()); // E:\\MyJavaProgram\\. System.out.println(file.getCanonicalPath()); // E:\\MyJavaProgram\\ System.out.println(\"---------------------------------------------\"); File file01 = new File(\".\\\\\"); System.out.println(file01.getCanonicalPath()); // E:\\MyJavaProgram System.out.println(\"---------------------------------------------\"); File file02 = new File(\"..\\\\\"); System.out.println(file02.getCanonicalPath()); // E:\\ System.out.println(\"---------------------------------------------\"); File file1 = new File(\"..\"); System.out.println(file1.getPath()); // .. System.out.println(file1.getAbsolutePath()); // E:\\MyJavaProgram\\.. System.out.println(file1.getCanonicalPath()); // E:\\ System.out.println(\"---------------------------------------------\"); File file2 = new File(\"Settings\\\\setting.properties\"); System.out.println(file2.getPath()); // Settings\\setting.properties System.out.println(file2.getAbsolutePath()); // E:\\MyJavaProgram\\Settings\\setting.properties System.out.println(file2.getCanonicalPath()); // E:\\MyJavaProgram\\Settings\\setting.properties System.out.println(\"---------------------------------------------\"); File file3 = new File(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\"); System.out.println(file3.getPath()); // E:\\MyJavaProgram\\Settings\\setting.properties System.out.println(file3.getAbsolutePath()); // E:\\MyJavaProgram\\Settings\\setting.properties System.out.println(file3.getCanonicalPath()); // E:\\MyJavaProgram\\Settings\\setting.properties } ¶2、文件目录判断 File对象既可以表示文件，也可以表示目录。 特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。 isFile()：判断是否是已存在文件 isDirectory()：判断是否是已存在目录 isAbsolute()：判断是否是完整路径 isHidden()：判断是否是隐藏文件 1234567891011121314File file1 = new File(\"..\");File file2 = new File(\"Settings\\\\setting.properties\");File file3 = new File(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\");System.out.println(file3.isAbsolute()); // trueSystem.out.println(file3.isDirectory()); // falseSystem.out.println(file3.isFile()); // trueSystem.out.println(file3.isHidden()); // falseSystem.out.println(\"---------------------------------------------\");System.out.println(file2.isAbsolute()); // falseSystem.out.println(file1.isAbsolute()); // falseSystem.out.println(file1.isFile()); // falseSystem.out.println(file1.isDirectory()); // true ¶3、File权限判断 用File对象获取到一个文件时，还可以进一步判断文件的权限和大小： boolean canRead()：是否可读； boolean canWrite()：是否可写； boolean canExecute()：是否可执行； long length()：文件字节大小。 对目录而言，是否可执行表示能否列出它包含的文件和子目录。 123456System.out.println(\"---------------------------------------------\");File fileExe = new File(\"E:\\\\MyJavaProgram\\\\Settings\\\\test.exe\");System.out.println(fileExe.canRead()); // trueSystem.out.println(fileExe.canWrite()); // trueSystem.out.println(fileExe.canExecute()); // true ¶4、创建和删除文件 先将需要创建的文件test.txt传入File对象，再调用creatNewFile()方法来创建！ 可通过createTempFile()创建临时文件，以及deleteOnExit()在JVM退出时自动删除该文件。 createNewFile()：返回boolean值，若文件已存在返回false！ delete()：返回boolean值，若文件已不存在返回false！ createTempFile()：创建临时文件，创建位置为C盘某个位置，需要传入两个参数，一个前缀，一个后缀！ deleteOnExit()：JVM退出时自动删除，删除后仍然可获得File对象路径！ 12345678910111213141516// 创建文件：File file4 = new File(\"Settings\\\\test.txt\");if(file4.createNewFile()){ System.out.println(\"test.txt创建成功！\");}// 删除文件：if(file4.delete()){ System.out.println(\"test.txt删除成功！\");}// 创建临时文件，使用后删除File file5 = File.createTempFile(\"temp\",\".cpp\");System.out.println(file5.getCanonicalPath()); // C:\\Users\\15890\\AppData\\Local\\Temp\\temp10279290225517315464.cppfile5.deleteOnExit();// 删除后仍然可以获得路径：System.out.println(file5.getCanonicalPath()); // C:\\Users\\15890\\AppData\\Local\\Temp\\temp10279290225517315464.cpp ¶5、创建和删除目录 boolean mkdir()：创建当前File对象表示的目录； boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来； boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功，是能删除最内部的目录，并且只有目录为空才可删除！ 创建目录使用mkdirs()即可，mkdir()可以做到的，mkdirs()都可以做到！ 12345678910111213141516File file7 = new File(\".\\\\test\");//File file8 = new File(\".\");if(file7.mkdir()){ System.out.println(\"test目录创建成功！\");}if(file7.delete()){ System.out.println(\"test目录删除成功！\");}File file8 = new File(\".\\\\test\\\\test02\\\\test03\");if(file8.mkdirs()){ System.out.println(\"嵌套目录创建成功！\"); if(file8.delete()){ System.out.println(\"test03目录删除成功！\"); }} ¶6、遍历文件和目录 使用listFiles()获取当前目录层次关系，用File对象数组接收，可以传入FilenameFilter()方法来过滤不需要的文件或目录！ 1234567891011121314151617181920212223242526272829303132package com.learn.file;import java.io.File;import java.io.FilenameFilter;import java.io.IOException;public class FileTest { public static void main(String[] args) throws IOException { System.out.println(\"-----------------------------------------------\"); File file6 = new File(\".\"); File[] files = file6.listFiles(); printFiles(files); File[] files1 = file6.listFiles(new FilenameFilter() { @Override public boolean accept(File dir, String name) { return name.endsWith(\".idea\"); } }); printFiles(files1); } static void printFiles(File[] files){ System.out.println(\"-----------------------------------------------\"); if(files != null){ for(var file : files){ System.out.println(file); } } }} ¶7、Path对象 Java标准库还提供了一个Path对象，它位于java.nio.file包。Path对象和File对象类似，但操作更加简单： Paths.get()：参数可以有多个，表示路径，后面的一定得是前面路径的子路径！ toAbsolutePath()：转化为带.的绝对路径 normalize()：将构造路径的点去掉 toAbsolutePath().normalize()：将带点的绝对路径去掉点，转化为完整的路径！ toFile()：转化为File对象！ 1234567891011121314151617181920212223242526272829package com.learn.file;import java.io.File;import java.io.IOException;import java.nio.file.Path;import java.nio.file.Paths;public class PathTest { public static void main(String[] args) throws IOException { Path path = Paths.get(\".\\\\Path\",\"PathTest\\\\test01\", \"test02\"); System.out.println(path); // .\\Path\\PathTest\\test01\\test02 System.out.println(path.toAbsolutePath()); // E:\\MyJavaProgram\\.\\Path\\PathTest\\test01\\test02 System.out.println(path.normalize()); // Path\\PathTest\\test01\\test02 System.out.println(path.toAbsolutePath().normalize()); // E:\\MyJavaProgram\\Path\\PathTest\\test01\\test02 File file = path.toFile(); System.out.println(file); // 嵌套目录遍历： for(var p : path){ System.out.println(p); } System.out.println(); for(var p : path.toAbsolutePath()){ System.out.println(p); } }} ¶8、遍历目录例子 为了有层次关系，可进行空格的控制输出，使用getName()方法获取目录或文件名！ 使用递归去进行层次遍历！ 12345678910111213141516171819202122232425262728293031323334package com.learn.file;import java.io.File;import java.io.IOException;/** @:实现打印当前目录的层次关系！* */public class FileWork { public static void main(String[] args) throws IOException { File file = new File(\".\"); ListDir(file, 0); } static void ListDir(File file, int level) { File[] files = file.listFiles(); if (files != null) { for (var ls : files) { for(int i = 0; i &lt; level; i++){ System.out.print(\" \"); } if (ls.isFile()) { System.out.println(ls.getName()); } else { System.out.println(ls.getName() + \"\\\\\"); } ListDir(ls, level + 1); } } }} ¶三、InputStream InputStream就是Java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步IO的功能。 要特别注意的一点是，InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()。 这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。 FileInputStream是InputStream的一个子类 ¶1、读取和关闭FileInputStream 在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。 InputStream和OutputStream都是通过close()方法来关闭流。关闭流就会释放对应的底层资源。 我们还要注意到在读取或写入IO流的过程中，可能会发生错误，例如，文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成IOException异常并抛出。因此，所有与IO操作相关的代码都必须正确处理IOException。 ¶1.1 手动关闭 + 未处理异常 如果读取过程中发生了IO错误，InputStream就没法正确地关闭，资源也就没法及时释放。 1234567891011121314151617181920package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ InputStream input = new FileInputStream(\"Settings\\\\readme.txt\"); int n; while((n = input.read()) != -1){ System.out.print(n + \" \"); } input.close(); }} ¶1.2 使用 try finally 来处理异常 无论是否异常，总会执行finally来关闭文件！ 注意：关闭流时要保证流不为null，否则会抛出NullPointerException 12345678910111213141516171819202122232425262728package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ System.out.println(); InputStream input1 = null; //input1.close(); // throws NullPointerException try{ input1 = new FileInputStream(\"Settings\\\\readme.txt\"); int n1; while((n1 = input1.read()) != -1){ System.out.print(n1 + \" \"); } }finally { if(input1 != null){ input1.close(); } } }} ¶1.3 使用 try(resource) 实现自动关闭流（推荐） 编译器自动为我们关闭资源 实际上，编译器并不会特别地为InputStream加上自动关闭。编译器只看try(resource = ...)中的对象是否实现了java.lang.AutoCloseable接口，如果实现了，就自动加上finally语句并调用close()方法。InputStream和OutputStream都实现了这个接口，因此，都可以用在try(resource)中。 只有实现了上述接口使用该语法才会进行自动关闭！ 123456789101112131415161718192021package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ System.out.println(); try(InputStream input2 = new FileInputStream(\"Settings\\\\readme.txt\")) { int n2; while((n2 = input2.read()) != -1){ System.out.print(n2 + \" \"); } } }} ¶2、读到缓存中 在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。 一次读取多个字节时，需要先定义一个byte[]数组作为缓冲区，read()方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。 read()方法的返回值不再是字节的int值，而是返回实际读取了多少个字节。如果返回-1，表示没有更多的数据了。 InputStream提供了两个重载方法来支持读取多个字节： int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数 int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数 12345678910111213141516171819202122package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ System.out.println(); try(InputStream input3 = new FileInputStream(\"Settings\\\\readme.txt\")) { int n2; byte[] buffer = new byte[10]; while((n2 = input3.read(buffer)) != -1){ System.out.println(\"读取了\" + n2 + \"个字节\"); } } }} 如下： 1234读取了10个字节读取了10个字节读取了10个字节读取了2个字节 ¶3、阻塞 在调用InputStream的read()方法读取数据时，我们说read()方法是阻塞（Blocking）的！ 执行到第二行代码时，必须等read()方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定read()方法调用到底要花费多长时间。 123int n;n = input.read(); // 必须等待read()方法返回才能执行下一行代码int m = n; ¶4、InputStream实现类 除了FileInputStream可以从文件获取输入流，还有ByteArrayInputStream可以在内存中模拟一个InputStream： ByteArrayInputStream实际上是把一个byte[]数组在内存中变成一个InputStream，虽然实际应用不多，但测试的时候，可以用它来构造一个InputStream。 ¶4.1 使用ByteArrayInputStream模拟InputStream 12345678910111213141516171819package com.learn.file;import java.io.ByteArrayInputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { byte[] data = { 72, 101, 108, 108, 111, 33 }; try(InputStream input4 = new ByteArrayInputStream(data)){ int n3; while((n3 = input4.read()) != -1){ System.out.print((char)n3 + \" \"); // H e l l o ! } } }} ¶4.2 封装为函数进行测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.learn.file;import java.io.ByteArrayInputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ byte[] data = { 72, 101, 108, 108, 111, 33 }; try(InputStream input4 = new ByteArrayInputStream(data)){ int n3; while((n3 = input4.read()) != -1){ System.out.print((char)n3 + \" \"); // H e l l o ! } } System.out.println(); String s; try(InputStream input5 = new FileInputStream(\"Settings\\\\readme.txt\")) { int n5; StringBuilder sb = new StringBuilder(); while((n5 = input5.read()) != -1){ sb.append((char)n5); } s = sb.toString(); } System.out.println(s); // 输出结果： /* æµè¯è¾å¥æµï¼ hello world! */ // 使用封装函数来输出： String s1; try (InputStream input6 = new FileInputStream(\"Settings\\\\readme.txt\")) { s1 = readAsString(input6); } System.out.println(s1); // 直接通过ByteArrayInputStream的模拟来输出： try(InputStream input7 = new ByteArrayInputStream(data)){ String s2 = readAsString(input7); System.out.println(s2); // Hello! } } // 封装一个函数： public static String readAsString(InputStream input) throws IOException { int n; StringBuilder sb = new StringBuilder(); while ((n = input.read()) != -1) { sb.append((char) n); } return sb.toString(); }} ¶四、OutputStream 和InputStream相反，OutputStream是Java标准库提供的最基本的输出流。 和InputStream类似，OutputStream也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是void write(int b) 这个方法会写入一个字节到输出流。要注意的是，虽然传入的是int参数，但只会写入一个字节，即只写入int最低8位表示字节的部分： OutputStream也提供了close()方法关闭输出流，以便释放系统资源！ 1public abstract void write(int b) throws IOException; ¶1、flush方法 它的目的是将缓冲区的内容强制输出到目的地。 向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以OutputStream有个flush()方法，能强制把缓冲区内容输出。 通常情况下，我们不需要调用这个flush()方法，因为缓冲区写满了OutputStream会自动调用它，并且，在调用close()方法关闭OutputStream之前，也会自动调用flush()方法。 需要手动调用该方法的例子：实时聊天软件，不能等缓冲区满了在进行输出吧！ ¶2、写入和关闭FileOutStream 如下方，只有当append参数为true时才不会进行覆盖，默认为false！ 123new FileOutputStream(File file, boolean append); //append = falsenew FileWriter(File file, boolean append); //append = false ¶2.1 一个字节的去读 1234567891011121314151617181920package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class OutputStreamTest { public static void main(String[] args) throws IOException { File file = new File(\"Settings\\\\input.txt\"); if(file.createNewFile()){ System.out.println(\"input.txt创建成功！\"); } OutputStream output = new FileOutputStream(\"Settings\\\\input.txt\"); output.write(72); // H output.write(101); // e output.write(108); // l output.write(108); // l output.write(111); // o output.close(); }} ¶2.2 一次性读入若干字节 12345678910111213141516package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class OutputStreamTest { public static void main(String[] args) throws IOException { File file = new File(\"Settings\\\\input.txt\"); if(file.createNewFile()){ System.out.println(\"input.txt创建成功！\"); } OutputStream output = new FileOutputStream(\"Settings\\\\input.txt\"); output.write(\"world\".getBytes(StandardCharsets.UTF_8)); output.close(); }} ¶2.3 使用try(resourse)自动关闭（推荐） 123456789101112131415161718192021222324package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class OutputStreamTest { public static void main(String[] args) throws IOException { File file = new File(\"Settings\\\\input.txt\"); if(file.createNewFile()){ System.out.println(\"input.txt创建成功！\"); } try(OutputStream output1 = new FileOutputStream(\"Settings\\\\input.txt\")){ output1.write(\"hello world!\".getBytes(StandardCharsets.UTF_8)); }// 编译器在此自动为我们写入finally并调用close() try(InputStream input = new FileInputStream(\"Settings\\\\input.txt\")){ int n; while((n = input.read()) != -1){ System.out.print((char) n); } } }} ¶3、阻塞 同样，只有等write方法执行完毕才能执行下一行！ 所以write方法也是阻塞的！ 123int n;n = output.write(); // 必须等待write()方法返回才能执行下一行代码int m = n; ¶4、OutputStream实现类 用FileOutputStream可以从文件获取输出流，这是OutputStream常用的一个实现类。此外，ByteArrayOutputStream可以在内存中模拟一个OutputStream ByteArrayOutputStream实际上是把一个byte[]数组在内存中变成一个OutputStream，虽然实际应用不多，但测试的时候，可以用它来构造一个OutputStream。 使用ByteArrayOutputStream模拟OutputStream 123456789101112131415package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class OutputStreamTest { public static void main(String[] args) throws IOException { byte[] data; try(ByteArrayOutputStream output1 = new ByteArrayOutputStream()){ output1.write(\"Hello world!\".getBytes(StandardCharsets.UTF_8)); data = output1.toByteArray(); } System.out.println(new String(data));//Hello world! }} ¶5、一个小例子 实现文件的复制！ 在命令行进行运行带有参数的运行，即将source.txt 复制到copy.txt； 当然要在源文件下，或者使用相对路径绝对路径都可以！ 前提是两个文件都已经存在了！ 1$ java CopyTest.java source.txt copy.txt main函数的args参数就是用来接收命令行参数的，直接将第一个参数给了输入流，第二个参数给了输出流，即可实现将输入流复制到输出流的copy文件里！ 123456789101112131415package com.learn.file;import java.io.*;public class CopyTest { public static void main(String[] args) throws IOException { try(InputStream source = new FileInputStream(args[0]); OutputStream copyfile = new FileOutputStream(args[1])){ int n; while((n = source.read()) != -1){ copyfile.write(n); } } }} 效果： 之前： 1234source.txt：I am a source file!copy.txt：（空） 之后： 1234source.txt：I am a source file!copy.txt：I am a source file! ¶五、Filter模式 InputStream，OutputStream都是以这种Filter模式来提供各种功能： 下面仅以InputStream举例！ ¶1、InputStream来源 FileInputStream：从文件读取数据，是最终数据源； ServletInputStream：从HTTP请求读取数据，是最终数据源； Socket.getInputStream()：从TCP连接读取数据，是最终数据源； … ¶2、引入FilterInputStream原因 如果要给FileInputStream添加各种功能： 1234567// 添加缓冲功能：BufferedFileInputStream extends FileInputStream// 添加计算签名功能：DigestFileInputStream extends FileInputStream// 添加加密解密功能：CipherFileInputStream extends FileInputStream// 以及其他类之间的相互组合.....等等 这还只是针对FileInputStream设计，如果针对另一种InputStream设计，很快会出现子类爆炸的情况。 因此，直接使用继承，为各种InputStream附加更多的功能，根本无法控制代码的复杂度，很快就会失控。 ¶3、FilterInputStream简介 为了解决依赖继承会导致子类数量失控的问题，JDK首先将InputStream分为两大类： 无论我们包装多少次，得到的对象始终是InputStream，我们直接用InputStream来引用它！ 通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。它可以让我们通过少量的类来实现各种功能的组合！ FilterInputStream是其他各钟功能的父类！ 一类是直接提供数据的基础InputStream，例如： FileInputStream ByteArrayInputStream ServletInputStream … 一类是提供额外附加功能的InputStream，例如： BufferedInputStream DigestInputStream CipherInputStream … 123456InputStream file = new FileInputStream(\"test.gz\");// 使用BufferedInputStream包装InputStream,添加缓冲功能：InputStream buffered = new BufferedInputStream(file);// 使用GZIPInputStream包装InputStream,添加解压功能：InputStream gzip = new GZIPInputStream(buffered); ¶结构图像这样： OutputStream也一样！ 12345678910111213141516 ┌─────────────┐ │ InputStream │ └─────────────┘ ▲ ▲┌────────────────────┐ │ │ ┌─────────────────┐│ FileInputStream │─┤ └─│FilterInputStream│└────────────────────┘ │ └─────────────────┘┌────────────────────┐ │ ▲ ┌───────────────────┐│ByteArrayInputStream│─┤ ├─│BufferedInputStream│└────────────────────┘ │ │ └───────────────────┘┌────────────────────┐ │ │ ┌───────────────────┐│ ServletInputStream │─┘ ├─│ DataInputStream │└────────────────────┘ │ └───────────────────┘ │ ┌───────────────────┐ └─│CheckedInputStream │ └───────────────────┘ ¶4、编写FilterInputStream 下面编写一个自定义的FilterInputStream来实现需要实现的功能，同时还可以使得所有InputStream都可以使用该功能： CountInputStream实现了计数功能； 所有的功能都必须得继承自FilterInputStream！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.learn.file;import java.io.ByteArrayInputStream;import java.io.FilterInputStream;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;public class FilterWork { public static void main(String[] args) throws IOException{ byte[] data = \"hello world!\".getBytes(StandardCharsets.UTF_8); // 使用ByteArrayInputStream将byte数组封装为InputStream; try(CountInputStream inputStream = new CountInputStream(new ByteArrayInputStream(data))){ int n; while ((n = inputStream.read()) != -1){ System.out.print((char)n); // hello world! } System.out.println(\"\\nTotal read \" + inputStream.getBytesRead() + \" bytes!\"); // Total read 12 bytes! } }}class CountInputStream extends FilterInputStream{ private int count; // Idea自动生成的注释： /** * Creates a {@code FilterInputStream} * by assigning the argument {@code in} * to the field {@code this.in} so as * to remember it for later use. * * @param in the underlying input stream, or {@code null} if * this instance is to be created without an underlying stream. */ protected CountInputStream(InputStream in) { super(in); } public int getBytesRead() { return this.count; } public int read() throws IOException { int n = in.read(); if (n != -1) { this.count ++; } return n; } public int read(byte[] b, int off, int len) throws IOException { int n = in.read(b, off, len); this.count += n; return n; }} ¶六、操作Zip ¶1、ZipInputStream ZipInputStream是一种FilterInputStream，它可以直接读取zip包的内容： 另一个JarInputStream是从ZipInputStream派生，它增加的主要功能是直接读取jar文件里面的MANIFEST.MF文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。 继承的结构关系： 1234567891011121314151617181920212223┌───────────────────┐│ InputStream │└───────────────────┘ ▲ │┌───────────────────┐│ FilterInputStream │└───────────────────┘ ▲ │┌───────────────────┐│InflaterInputStream│└───────────────────┘ ▲ │┌───────────────────┐│ ZipInputStream │└───────────────────┘ ▲ │┌───────────────────┐│ JarInputStream │└───────────────────┘ ¶2、读取Zip包 创建一个ZipInputStream，通常是传入一个FileInputStream作为数据源，然后，循环调用getNextEntry()，直到返回null，表示zip流结束。 一个ZipEntry表示一个压缩文件或目录，如果是压缩文件，我们就用read()方法不断读取，直到返回-1： 1234567891011121314151617181920212223242526package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.util.zip.ZipEntry;import java.util.zip.ZipInputStream;public class ZipTest { public static void main(String[] args) throws IOException { try (ZipInputStream zip = new ZipInputStream(new FileInputStream(\".\\\\zip.zip\"))) { ZipEntry entry = null; while ((entry = zip.getNextEntry()) != null) { System.out.println(\"文件或目录名：\" + entry.getName()); if (!entry.isDirectory()) { int n; System.out.print(\"内容：\"); while ((n = zip.read()) != -1) { System.out.print((char) n); } System.out.println(); } } } }} 结果如下： 12345文件或目录名：niub/文件或目录名：test.txt内容：I am a Test file!文件或目录名：zip.txt内容：hello world! ¶3、写入Zip包 ZipOutputStream是一种FilterOutputStream，它可以直接写入内容到zip包。我们要先创建一个ZipOutputStream，通常是包装一个FileOutputStream，然后，每写入一个文件前，先调用putNextEntry()，然后用write()写入byte[]数据，写入完毕后调用closeEntry()结束这个文件的打包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.learn.file;import java.io.*;import java.util.zip.ZipEntry;import java.util.zip.ZipInputStream;import java.util.zip.ZipOutputStream;public class ZipTest { public static void main(String[] args) throws IOException { try (ZipInputStream zip = new ZipInputStream(new FileInputStream(\".\\\\zip.zip\"))) { ZipEntry entry = null; while ((entry = zip.getNextEntry()) != null) { System.out.println(\"文件或目录名：\" + entry.getName()); if (!entry.isDirectory()) { int n; System.out.print(\"内容：\"); while ((n = zip.read()) != -1) { System.out.print((char) n); } System.out.println(); } } } File file1 = new File(\".\\\\Settings\"); try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(\".\\\\zip.zip\"))) { File[] files = file1.listFiles(); if(files != null){ for (File file : files) { // 在Zip中创建文件 zip.putNextEntry(new ZipEntry(file.getName())); // 将内容写入 zip.write(getFileDataAsBytes(file)); // 关闭外部文件 zip.closeEntry(); } } } } private static byte[] getFileDataAsBytes(File file) throws IOException{ byte[] data = new byte[1024]; try(InputStream file1 = new FileInputStream(file)){ int n; while((n = file1.read(data)) != -1){ System.out.println(\"read \" + n + \" byte\"); } } return data; }} ¶七、读取classpath资源 是一种与路径无关的读取文件的方式： 从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把default.properties文件放到classpath中，就不用关心它的实际存放路径。 在classpath中的资源文件，路径总是以／开头，我们先获取当前的Class对象，然后调用getResourceAsStream()就可以直接从classpath读取任意的资源文件！ 关于classpath目前还不太清楚，后续再进行学习！ Java存放.class的目录或jar包也可以包含任意其他类型的文件，例如： 配置文件，例如.properties； 图片文件，例如.jpg； 文本文件，例如.txt，.csv； …… 1234567891011121314151617package com.learn.file;import java.io.IOException;import java.io.InputStream;public class ClassPathTest { public static void main(String[] args) throws IOException { try (InputStream input = ClassPathTest.class.getResourceAsStream(\"/default.properties\")) { if (input != null) { int n; while((n = input.read()) != -1){ System.out.print((char) n); } } } }} 如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置： 123Properties props = new Properties();props.load(inputStreamFromClassPath(\"/default.properties\"));props.load(inputStreamFromFile(\"./conf.properties\")); ¶八、序列化 序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。 为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。 有序列化，就有反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。 一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口： Serializable接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。 这节有点云里雾里，后续再看！ ¶1、序列化 把一个Java对象变为byte[]数组，需要使用ObjectOutputStream。它负责把一个Java对象写入一个字节流。 ObjectOutputStream既可以写入基本类型，如int，boolean，也可以写入String（以UTF-8编码），还可以写入实现了Serializable接口的Object。 因为写入Object时需要大量的类型信息，所以写入的内容很大。 123456789101112131415161718192021package com.learn.file;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.util.Arrays;public class SerializableTest { public static void main(String[] args) throws IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); try (ObjectOutputStream output = new ObjectOutputStream(buffer)) { // 写入int: output.writeInt(12345); // 写入String: output.writeUTF(\"Hello\"); // 写入Object: output.writeObject(123.456); } System.out.println(Arrays.toString(buffer.toByteArray())); }} ¶2、反序列化 和ObjectOutputStream相反，ObjectInputStream负责从一个字节流读取Java对象 除了能读取基本类型和String类型外，调用readObject()可以直接返回一个Object对象。要把它变成一个特定类型，必须强制转型。 要特别注意反序列化的几个重要特点： 反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。 readObject()可能抛出的异常有： ClassNotFoundException：没有找到对应的Class； InvalidClassException：Class不匹配。 对于ClassNotFoundException，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，Person对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义Person类，所以无法反序列化。 对于InvalidClassException，这种情况常见于序列化的Person对象定义了一个int类型的age字段，但是反序列化时，Person类定义的age字段被改成了long类型，所以导致class不兼容。 123456789101112131415161718package com.learn.file;import java.io.*;import java.util.Arrays;public class SerializableTest { public static void main(String[] args) throws Exception { ByteArrayInputStream bufferin = new ByteArrayInputStream(buffer.toByteArray()); try (ObjectInputStream input = new ObjectInputStream(bufferin)) { int n = input.readInt(); String s = input.readUTF(); Double d = (Double) input.readObject(); System.out.println(n); System.out.println(s); System.out.println(d); } }} 为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的serialVersionUID静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变serialVersionUID的值，这样就能自动阻止不匹配的class版本： 123public class Person implements Serializable { private static final long serialVersionUID = 2709425275741743919L;} ¶3、安全性 因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 ¶九、Reader Reader是Java的IO库提供的另一个输入流接口。和InputStream的区别是，InputStream是一个字节流，即以byte为单位读取，而Reader是一个字符流，即以char为单位读取： java.io.Reader是所有字符输入流的超类！ read()方法读取字符流的下一个字符，并返回字符表示的int，范围是0~65535。如果已读到末尾，返回-1。 ¶1、Reader和InputStream对比 InputStream Reader 字节流，以byte为单位 字符流，以char为单位 读取字节（-1，0~255）：int read() 读取字符（-1，0~65535）：int read() 读到字节数组：int read(byte[] b) 读到字符数组：int read(char[] c) ¶2、FileReader FileReader是Reader的一个子类，它可以打开文件并获取`Reader： FileReader()可以接收一个编码参数！ ¶2.1 直接创建FileReader 12345678910111213141516package com.learn.file;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class ReaderTest { public static void main(String[] args) throws IOException { Reader reader = new FileReader(\"Settings\\\\readme.txt\"); int n; while((n = reader.read()) != -1){ System.out.print((char) n); } reader.close(); }} ¶2.2 使用try(resourse)实现自动关闭资源 1234567891011121314151617package com.learn.file;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class ReaderTest { public static void main(String[] args) throws IOException { try(Reader reader = new FileReader(\"Settings\\\\readme.txt\")){ int n; while((n = reader.read()) != -1){ System.out.print((char) n); } } }} ¶2.3 填充字符到char数组 read(char[] c)返回实际读入的字符个数，最大不超过char[]数组的长度。返回-1表示流结束。 123456789101112131415161718package com.learn.file;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class ReaderTest { public static void main(String[] args) throws IOException { try(Reader reader = new FileReader(\"Settings\\\\readme.txt\")){ int n; char[] buffer = new char[100]; while((n = reader.read(buffer)) != -1){ System.out.println(\"read \" + n + \"chars\"); } } }} ¶3、CharArrayReader CharArrayReader可以在内存中模拟一个Reader，它的作用实际上是把一个char[]数组变成一个Reader： 123456try (Reader reader = new CharArrayReader(\"Hello\".toCharArray())) { int n; while((n = reader.read()) != -1){System.out.print((char) n); }} ¶4、StringReader StringReader可以直接把String作为数据源，它和CharArrayReader几乎一样： 123456try (Reader reader = new StringReader(\"Hello\")) { int n; while((n = reader.read()) != -1){ System.out.print((char) n); }} ¶5、InputStreamReader 除了特殊的CharArrayReader和StringReader，普通的Reader实际上是基于InputStream构造的。 因为Reader需要从InputStream中读入字节流（byte），然后，根据编码设置，再转换为char就可以实现字符流。 InputStreamReader就是一个转换器，它可以把任何InputStream转换为Reader： 两个参数，一个InputStream，一个可选的编码方式参数！ 使用try (resource)结构时，当我们关闭Reader时，它会在内部自动调用InputStream的close()方法，所以，只需要关闭最外层的Reader对象即可 12345678910// 持有InputStream:InputStream input = new FileInputStream(\"src/readme.txt\");// 变换为Reader:Reader reader = new InputStreamReader(input, StandardCharsets.UTF_8);// 使用try(resourse)：try (Reader reader1 = new InputStreamReader(new FileInputStream(\"src/readme.txt\"),StandardCharsets.UTF_8)) { // TODO: System.out.println(reader1);} ¶十、Writer Reader是带编码转换器的InputStream，它把byte转换为char，而Writer就是带编码转换器的OutputStream，它把char转换为byte并输出： ¶1、Reader和InputStream对比 OutputStream Writer 字节流，以byte为单位 字符流，以char为单位 写入字节（0~255）：void write(int b) 写入字符（0~65535）：void write(int c) 写入字节数组：void write(byte[] b) 写入字符数组：void write(char[] c) 无对应方法 写入String：void write(String s) Writer是所有字符输出流的超类，它提供的方法主要有： 写入一个字符（0~65535）：void write(int c)； 写入字符数组的所有字符：void write(char[] c)； 写入String表示的所有字符：void write(String s)。 ¶2、FileWriter 同样可以设置第三个参数，使其不进行覆盖写入： 123456789101112131415161718192021package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class WriterTest { public static void main(String[] args) throws IOException { try (Writer writer = new FileWriter(\"readme.txt\", StandardCharsets.UTF_8, true)) { writer.write('H'); // 写入单个字符 writer.write(\"Hello\".toCharArray()); // 写入char[] writer.write(\"Hello\"); // 写入String } try (Reader reader = new FileReader(\"readme.txt\")){ int n; while((n = reader.read()) != -1){ System.out.print((char) n); } } }} ¶3、CharArrayWriter CharArrayWriter可以在内存中创建一个Writer，它的作用实际上是构造一个缓冲区，可以写入char，最后得到写入的char[]数组： 12345678910111213141516package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class WriterTest { public static void main(String[] args) throws IOException { try (CharArrayWriter writer = new CharArrayWriter()) { writer.write(65); writer.write(66); writer.write(67); char[] data = writer.toCharArray(); System.out.print(data); // ABC } }} ¶4、StringWriter StringWriter也是一个基于内存的Writer，它和CharArrayWriter类似。实际上，StringWriter在内部维护了一个StringBuffer，并对外提供了Writer接口： 可以使用StringBuffer的所有方法，只是实现了一个writer接口： 1234567891011121314package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class WriterTest { public static void main(String[] args) throws IOException { try (StringWriter writer = new StringWriter()) { writer.write(\"hello world nxd\"); writer.append(\" last!\"); System.out.print(writer); } }} ¶5、OutputStreamWriter 除了CharArrayWriter和StringWriter外，普通的Writer实际上是基于OutputStream构造的，它接收char，然后在内部自动转换成一个或多个byte，并写入OutputStream。因此，OutputStreamWriter就是一个将任意的OutputStream转换为Writer的转换器： 12345try (Writer writer = new OutputStreamWriter(new FileOutputStream(\"readme.txt\"), StandardCharsets.UTF_8)) { // TODO: int n; writer.write(\"hello\");} ¶十一、PrintStream和PrintWriter ¶1、PrintStream PrintStream和OutputStream相比，除了添加了一组print()/println()方法，可以打印各种数据类型，比较方便外，它还有一个额外的优点，就是不会抛出IOException，这样我们在编写代码的时候，就不必捕获IOException。 以及对应的一组println()方法，它会自动加上换行符。 我们经常使用的System.out.println()实际上就是使用PrintStream打印各种数据。其中，System.out是系统默认提供的PrintStream，表示标准输出. System.err是系统默认提供的标准错误输出。 PrintStream是一种FilterOutputStream，它在OutputStream的接口上，额外提供了一些写入各种数据类型的方法： 写入int：print(int) 写入boolean：print(boolean) 写入String：print(String) 写入Object：print(Object)，实际上相当于print(object.toString()) … 1234567891011package com.learn.file;public class PrintStreamTest { public static void main(String[] args) { System.out.print(12345); // 输出12345 System.out.print(new Object()); // 输出类似java.lang.Object@3c7a835a System.out.println(\"Hello\"); // 输出Hello并换行 System.err.println(\"hhh\"); }} ¶2、PrintWriter PrintStream最终输出的总是byte数据，而PrintWriter则是扩展了Writer接口，它的print()/println()方法最终输出的是char数据。两者的使用方法几乎是一模一样的： 12345678910111213141516package com.learn.file;import java.io.PrintWriter;import java.io.StringWriter;public class PrintWriterTest { public static void main(String[] args) { StringWriter buffer = new StringWriter(); try (PrintWriter pw = new PrintWriter(buffer)) { pw.println(\"Hello\"); pw.println(12345); pw.println(true); } System.out.println(buffer.toString()); }} 本章终于完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://www.itnxd.cn/tags/IO/"},{"name":"File","slug":"File","permalink":"https://www.itnxd.cn/tags/File/"}],"author":"Mr.Niu"},{"title":"Java教程系列之集合","slug":"Java教程系列之集合","date":"2020-04-07T08:23:56.000Z","updated":"2021-02-06T14:12:51.589Z","comments":true,"path":"posts/46100.html","link":"","permalink":"https://www.itnxd.cn/posts/46100.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶一、Java集合介绍 在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合！ 数组就是一种集合： 123String[] ss = new String[10]; // 可以持有10个String对象ss[0] = \"Hello\"; // 可以放入String对象String first = ss[0]; // 可以获取String对象 ¶1、数组的不足 数组初始化后大小不可变； 数组只能按索引顺序存取。 ¶2、需要各种类型的集合 可变大小的顺序链表； 保证无重复元素的集合； … ¶3、Collection Collection，它是除Map外所有其他集合类的根接口，来自于java.util包！ ¶3.1 三种主要集合： List：一种有序列表的集合 Set：一种保证没有重复元素的集合 Map：一种通过键值（key-value）查找的映射表集合 ¶3.2 Java集合的特点： 一是实现了接口和实现类相分离，例如，有序表的接口是List，具体的实现类有ArrayList，LinkedList等. 二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素. 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 只能放入String类型 ¶3.3 集合访问（Iterator） Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。 Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。 ¶3.4 不建议继续使用的集合 由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用： Hashtable：一种线程安全的Map实现； Vector：一种线程安全的List实现； Stack：基于Vector实现的LIFO的栈。 还有一小部分接口是遗留接口，也不应该继续使用： Enumeration：已被Iterator取代。 ¶二、使用List List是最基础的一种集合：它是一种有序链表。 ¶1、数组的删除和添加 删除：删掉指定索引位置后将后面元素整体前移一位； 添加：将指定索引位置及之后元素后移一位，将新元素插入该位置； 可见：操作增删是很复杂的，需要人为介入去处理！ ¶2、ArrayList 把添加和删除的操作封装起来，让我们操作List类似于操作数组，却不用关心内部元素如何移动。 变成了自动操作！ 增删可以直接使用，已经封装为函数！ 数组已满时的操作： 先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组 ¶3、List&lt;E&gt;接口 主要的接口方法： 在末尾添加一个元素：void add(E e) 在指定索引添加一个元素：void add(int index, E e) 删除指定索引的元素：int remove(int index)：返回索引+1，从1开始计数！ 删除某个元素：int remove(Object e) 获取指定索引的元素：E get(int index) 获取链表大小（包含元素的个数）：int size() ¶4、ArrayList与LinkedList 都是List接口实现的实例类！ LinkedList相当于单链表，有前后的指针关系！ 通常情况下，我们总是优先使用ArrayList。 区别： ArrayList LinkedList 获取指定元素 速度很快 需要从头开始查找元素 添加元素到末尾 速度很快 速度很快 在指定位置添加/删除 需要移动元素 不需要移动元素 内存占用 少 较大 ¶5、List的特点 元素可重复 允许添加null 123456789101112131415package com.learn.java;import java.util.ArrayList;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"hello\"); list.add(\"hello\"); list.add(null); System.out.println(list.size()); // 3 System.out.println(list.toString()); // [hello, hello, null] }} ¶6、创建List 通过List接口提供的of()方法，根据给定元素快速创建List： 但是List.of()方法不接受null值，如果传入null，会抛出NullPointerException异常。 123List&lt;String&gt; list1 = List.of(\"hello\", \"hello\", \"world\");// 无法传入null:List&lt;String&gt; list2 = List.of(null); ¶7、遍历List ¶7.1 通过get方法遍历（不推荐） 缺点： 一是代码复杂； 二是因为get(int)方法只有ArrayList的实现是高效的，换成LinkedList后，索引越大，访问速度越慢。 12345678910111213141516package com.learn.java;import java.util.ArrayList;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"hello\"); list.add(\"hello\"); list.add(null); for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); } }} ¶7.2 通过Iterator遍历 使用迭代器Iterator来访问List。 Iterator本身也是一个对象，但它是由List的实例调用iterator()方法的时候创建的。 Iterator对象知道如何遍历一个List，并且不同的List类型，返回的Iterator对象实现也是不同的，但总是具有最高的访问效率。 两个方法： boolean hasNext()：判断是否有下一个元素 E next()：返回下一个元素 1234567891011121314151617package com.learn.java;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"hello\"); list.add(\"hello\"); list.add(null); for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ){ System.out.println(it.next()); } }} ¶7.3 通过for each遍历（推荐） 编译器内部其实会通过Iterator来实现遍历，达到最高效！ 和7.2的实现是一样的，但是更加简单使用，推荐使用！ 只要实现了Iterable接口的集合类都可以直接用for each循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把for each循环变成Iterator的调用，原因就在于Iterable接口定义了一个Iterator iterator()方法，强迫集合类必须返回一个Iterator实例。 12345678910111213141516package com.learn.java;import java.util.ArrayList;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"hello\"); list.add(\"hello\"); list.add(null); for (String s : list) { System.out.println(s); } }} ¶8、List转换为Array ¶8.1 使用toArray()方法 调用toArray()方法直接返回一个Object[]数组： 这种方法会丢失类型信息，所以实际应用很少。 12List&lt;String&gt; list = List.of(\"apple\", \"pear\", \"banana\");Object[] array = list.toArray(); ¶8.2 使用toArray(T[])方法 给toArray(T[])传入一个类型相同的Array，List内部自动把元素复制到传入的Array中： 该方法的泛型参数&lt;T&gt;并不是List接口定义的泛型参数&lt;E&gt;！ 参数可传入实际类型及其父类： 12345678910111213141516171819package com.learn.java;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;Integer&gt; list = List.of(1, 3, 5); Number[] arr = list.toArray(new Number[3]); Object[] arr1 = list.toArray(new Object[3]); for (Number number : arr) { System.out.print(number + \" \"); } System.out.println(); for (Object o : arr1) { System.out.print(o + \" \"); } }} 如果传入的数组不够大，那么List内部会创建一个新的刚好够大的数组，填充后返回； 如果传入的数组比List元素还要多，那么填充完元素后，剩下的数组元素一律填充null。 ¶8.3 传入恰好大小的数组 12List&lt;Integer&gt; list = List.of(1, 3, 5);Integer[] array = list.toArray(new Integer[list.size()]); ¶8.4 使用函数式写法 更简洁的写法是通过List接口定义的T[] toArray(IntFunction generator)方法： 函数式写法后面会讲到： 1Integer[] array = list.toArray(Integer[]::new); ¶9、Array转换为List 直接借助List.of()方法： 12345Integer[] array = { 1, 2, 3 };List&lt;Integer&gt; list = List.of(array);// jdk11之前可以这样用：List&lt;Integer&gt; list = Arrays.asList(array); 使用List.of()方法返回的是一个只读的List，无法调用add和remove等方法！ 会抛出UnsupportedOperationException。 1234567// 正确：List&lt;Integer&gt; lis = new ArrayList&lt;&gt;();lis.add(3);// 抛出错误：List&lt;Integer&gt; list = List.of(1, 3, 5);list.add(5); ¶三、编写equals方法 ¶1、contains 和 indexOf方法 List还提供了boolean contains(Object o)方法来判断List是否包含某个指定元素. int indexOf(Object o)方法可以返回某个元素的索引，如果元素不存在，就返回-1。 12345678910111213package com.learn.java;import java.util.List;public class Equals { public static void main(String[] args) { List&lt;String&gt; list = List.of(\"A\", \"B\", \"C\"); System.out.println(list.contains(\"C\")); // true System.out.println(list.contains(\"X\")); // false System.out.println(list.indexOf(\"C\")); // 2 System.out.println(list.indexOf(\"X\")); // -1 }} ¶2、判断两个元素相等 传入不同的实例，仍然可以通过下面两个函数比较得到结果： 因为List内部并不是通过==判断两个元素是否相等，而是使用equals()方法判断两个元素是否相等： Java标准中的引用类型定义的类已经正确实现了equals方法！ 所以自定义的类需要手动覆写equals方法； 12System.out.println(list.contains(new String(\"C\"))); // trueSystem.out.println(list.indexOf(new String(\"C\"))); // 2 ¶3、编写equals方法 ¶3.1 equals方法需要满足的条件 自反性（Reflexive）：对于非null的x来说，x.equals(x)必须返回true； 对称性（Symmetric）：对于非null的x和y来说，如果x.equals(y)为true，则y.equals(x)也必须为true； 传递性（Transitive）：对于非null的x、y和z来说，如果x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)也必须为true； 一致性（Consistent）：对于非null的x和y来说，只要x和y状态不变，则x.equals(y)总是一致地返回true或者false； 对null的比较：即x.equals(null)永远返回false。 ¶3.2 equals方法编写步骤 先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等； 用instanceof判断传入的待比较的Object是不是当前类型，如果是，继续比较，否则，返回false； 对引用类型用Objects.equals()比较，对基本类型直接用==比较。 对于引用字段比较，我们使用equals()，对于基本类型字段的比较，我们使用==。 使用instanceof来判断两个对象类型是否一致！当然参数为当前对象子类时也可以进入判断！ 普通方法编写： 要判断null的特殊情况！ 123456789101112131415161718192021public class Person { public String name; public int age; public boolean equals(Object o) { if (o instanceof Person) { Person p = (Person) o; boolean nameEquals = false; // 都是null返回true if (this.name == null &amp;&amp; p.name == null) { nameEquals = true; } if (this.name != null) { nameEquals = this.name.equals(p.name); } return nameEquals &amp;&amp; this.age == p.age; } return false; } } 借助Objects.equals()方法判断 使用Objects.equals()比较两个引用类型是否相等的目的是省去了判断null的麻烦。两个引用类型都是null时它们也是相等的。 12345678910111213public class Person { public String name; public int age; public boolean equals(Object o) { if (o instanceof Person) { Person p = (Person) o; return Objects.equals(this.name, p.name) &amp;&amp; this.age == p.age; } return false; } } ¶4、什么时候需要编写equals方法 如果不调用List的contains()、indexOf()这些方法，那么放入的元素就不需要实现equals()方法。 总而言之：不需要进行元素的比较就不需要编写！ ¶四、使用Map Map是一种键值（key-value）映射表的数据结构，作用就是能高效通过key快速查找value（元素）。 Map和List一样也是一个接口，最常用的实现类是HashMap。 ¶1、常用方法 V put(K key, V value)：存储键值对，没有键时返回null，有键时返回旧的value，新的覆盖旧的！ V get(K key)：获取键对应的值！ boolean containsKey(K key)：查询键是否存在！ 123456789101112131415161718import java.util.HashMap;import java.util.Map;public class Main { public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"apple\", 123); map.put(\"pear\", 456); System.out.println(map.get(\"apple\")); // 123 map.put(\"apple\", 789); // 再次放入apple作为key，但value变为789 System.out.println(map.get(\"apple\")); // 789 // 当然：value可重复 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"apple\", 123); map.put(\"pear\", 123); // ok }} ¶2、Map遍历 Map存储的是key-value的映射关系，并且，它不保证顺序，即遍历的顺序是不确定的！ 三种遍历如下： 1234567891011121314151617181920212223242526package com.learn.java;import java.util.HashMap;import java.util.Map;public class MapTest { public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"niu\", 20); map.put(\"ge\", 30); map.put(\"hello\", 30); // 遍历key for(String key : map.keySet()){ System.out.println(key); } // 遍历value for(Integer value : map.values()){ System.out.println(value); } // 遍历key-value for(Map.Entry&lt;String, Integer&gt; entry : map.entrySet()){ System.out.println(entry.getKey() + \" \" + entry.getValue()); } }} ¶3、高效查找例子 List来存储所有信息，Map来存储经常需要查询的信息！提高查找效率！ 现在Map中找，找到直接返回，找不到再从List中找，找到将这组信息放入Map，并返回该信息！ Map永远存储最常用的信息，极大提高效率！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.learn.java;import java.util.HashMap;import java.util.List;import java.util.Map;public class MapWork { public static void main(String[] args) { List&lt;Student&gt; list = List.of( new Student(\"Bob\", 78), new Student(\"Alice\", 85), new Student(\"Brush\", 66), new Student(\"Newton\", 99)); var holder = new Students(list); System.out.println(holder.getScore(\"Bob\") == 78 ? \"测试成功!\" : \"测试失败!\"); System.out.println(holder.getScore(\"Alice\") == 85 ? \"测试成功!\" : \"测试失败!\"); System.out.println(holder.getScore(\"Tom\") == -1 ? \"测试成功!\" : \"测试失败!\"); }}class Students { List&lt;Student&gt; list; Map&lt;String, Integer&gt; cache; Students(List&lt;Student&gt; list) { this.list = list; cache = new HashMap&lt;&gt;(); } /** * 根据name查找score，找到返回score，未找到返回-1 */ Integer getScore(String name) { // 先在Map中查找: Integer score = this.cache.get(name); if (score == null) { // TODO: score = findInList(name); if(score != null){ cache.put(name, score); } } return score == null ? -1 : score; } Integer findInList(String name) { for (var ss : this.list) { if (ss.name.equals(name)) { return ss.score; } } return null; }}class Student { String name; int score; Student(String name, int score) { this.name = name; this.score = score; }} ¶五、编写hashCode和equals方法 当然是针对HashMap的，get方法查找的时候HashMap内部要进行比对，通过equals方法，编写方法同第三大节的编写equals方法，当自定义的类出现时，就需要去覆写equals方法。 在Map的内部，对key做比较是通过equals()实现的，这一点和List查找元素需要正确覆写equals()是一样的，即正确使用Map必须保证：作为key的对象必须正确覆写equals()方法。 Map内部是通过hashCode()方法来计算key对应的value的索引， 正确使用Map必须保证： 作为key的对象必须正确覆写equals()方法，相等的两个key实例调用equals()必须返回true； 作为key的对象还必须正确覆写hashCode()方法，且hashCode()方法要严格遵循以下规范： 如果两个对象相等，则两个对象的hashCode()必须相等； 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。 第一条规范是正确性，必须保证实现，否则HashMap不能正常工作。 而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的hashCode()，会造成Map内部存储冲突，使存取的效率下降。 ¶1、equals方法覆写 同第三节的编写equals方法！ ¶2、编写hashCode方法 当然还是针对自定义类的覆写，标准库的类，java内部已经实现！ ¶2.1 实现原理 此方法并没有处理参数为null的问题，要想写完整需要加上关于null的判断！ 在计算Person的hashCode()时，反复使用31*h，这样做的目的是为了尽量把不同的Person实例的hashCode()均匀分布到整个int范围。 1234567891011121314public class Person { String firstName; String lastName; int age; @Override int hashCode() { int h = 0; h = 31 * h + firstName.hashCode(); h = 31 * h + lastName.hashCode(); h = 31 * h + age; return h; }} ¶2.2 使用Objects.hash方法 直接借助Objects.hash()方法，自动实现null的处理； 123int hashCode() { return Objects.hash(firstName, lastName, age);} ¶2.3 编写原则 equals()用到的用于比较的每一个字段，都必须在hashCode()中用于计算； equals()中没有使用到的字段，绝不可放在hashCode()中计算。 另外注意，对于放入HashMap的value对象，没有任何要求。 ¶2.4 完整示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.learn.java;import java.util.HashMap;import java.util.Map;import java.util.Objects;public class HashCode { public static void main(String[] args) { Map&lt;Persons, String&gt; map = new HashMap&lt;&gt;(); map.put(new Persons(\"hello1\", \"world1\", 20), \"first\"); map.put(new Persons(\"hello2\", \"world2\", 21), \"second\"); map.put(new Persons(\"hello3\", \"world3\", 22), \"three\"); String str = map.get(new Persons(\"hello2\", \"world2\", 21)); System.out.println(str); // second Persons key = new Persons(\"hello2\", \"world2\", 21); int index = key.hashCode() &amp; 0xf; System.out.println(index); // 4 }}class Persons { String firstName; String lastName; int age; Persons(String firstName, String lastName, int age){ this.firstName = firstName; this.lastName = lastName; this.age = age; } @Override public boolean equals(Object o){ if(o instanceof Persons){ Persons p = (Persons) o; return Objects.equals(this.firstName, p.firstName) &amp;&amp; Objects.equals(this.lastName, p.lastName) &amp;&amp; this.age == p.age; } return false; } /*@Override // 普通方法： public int hashCode() { int h = 0; h = 31 * h + firstName.hashCode(); h = 31 * h + lastName.hashCode(); h = 31 * h + age; return h; }*/ @Override public int hashCode(){ return Objects.hash(firstName, lastName, age); }} ¶3、hashCode延伸 HashMap内部使用了数组，通过计算key的hashCode()直接定位value所在的索引！ ¶3.1 HashMap的数组变化 HashMap初始化时默认的数组大小只有16，索引为在0～15，超过范围，自动扩容为原来的二倍，即长度为16的数组扩展为长度32，相应地，需要重新确定hashCode()计算的索引位置。 扩容会导致重新分布已有的key-value，所以，频繁扩容对HashMap的性能影响很大，所以在创建时就指定容量！ 虽然指定容量是10000，但HashMap内部的数组长度总是2n，因此，实际数组长度被初始化为比10000大的16384（214）。 1234567Persons key = new Persons(\"hello2\", \"world2\", 21);// 调用hashCode方法与容量做按位与获取value下标：int index = key.hashCode() &amp; 0xf;System.out.println(index);// 在创建时指定容量：Map&lt;String, Integer&gt; maps = new HashMap&lt;&gt;(10000); ¶3.2 hashCode计算得到的索引相同 若计算出的数组索引相同，并不会发生覆盖现象，只要key不相同，它们映射的value就互不干扰！ 假设\"a\"和\"b\"这两个key最终计算出的索引都是5，那么，在HashMap的数组中，实际存储的不是一个Person实例，而是一个List，它包含两个Entry，一个是\"a\"的映射，一个是\"b\"的映射！ HashMap内部通过\"a\"找到的实际上是List&gt;，它还需要遍历这个List，并找到一个Entry，它的key字段是\"a\"，才能返回对应的Person实例！ 我们把不同的key具有相同的hashCode()的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用List存储hashCode()相同的key-value。显然，如果冲突的概率越大，这个List就越长，Map的get()方法效率就越低，这就是为什么要尽量满足条件二： 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。 12map.put(\"a\", new Person(\"Xiao Ming\"));map.put(\"b\", new Person(\"Xiao Hong\")); ¶六、使用EnumMap HashMap是一种通过对key计算hashCode()，通过空间换时间的方式，直接定位到value所在的内部数组的索引，因此，查找效率非常高。 如果作为key的对象是enum类型，那么，还可以使用Java集合库提供的一种EnumMap，它在内部以一个非常紧凑的数组存储value，并且根据enum类型的key直接定位到内部数组的索引，并不需要计算hashCode()，不但效率最高，而且没有额外的空间浪费。 使用EnumMap的时候，我们总是用Map接口来引用它，因此，实际上把HashMap和EnumMap互换，在客户端看来没有任何区别。 12345678910111213141516171819202122232425package com.learn.java;import java.time.DayOfWeek;import java.util.EnumMap;import java.util.Map;public class EnumMapTest { public static void main(String[] args) { // 参数作用：泛型擦除，方法内部从T拿不到class Map&lt;DayOfWeek, String&gt; map = new EnumMap&lt;&gt;(DayOfWeek.class); map.put(DayOfWeek.MONDAY, \"星期一\"); map.put(DayOfWeek.TUESDAY, \"星期二\"); map.put(DayOfWeek.WEDNESDAY, \"星期三\"); map.put(DayOfWeek.THURSDAY, \"星期四\"); map.put(DayOfWeek.FRIDAY, \"星期五\"); map.put(DayOfWeek.SATURDAY, \"星期六\"); map.put(DayOfWeek.SUNDAY, \"星期日\"); System.out.println(map); System.out.println(map.get(DayOfWeek.MONDAY)); /* {MONDAY=星期一, TUESDAY=星期二, WEDNESDAY=星期三, THURSDAY=星期四, FRIDAY=星期五, SATURDAY=星期六, SUNDAY=星期日} 星期一 */ }} ¶七、使用TreeMap HashMap是一种以空间换时间的映射表，它的实现原理决定了内部的Key是无序的，即遍历HashMap的Key时，其顺序是不可预测的（但每个Key都会遍历一次且仅遍历一次）。 还有一种Map，它在内部会对Key进行排序，这种Map就是SortedMap。 注意到SortedMap是接口，它的实现类是TreeMap。 ¶1、Map的继承关系： 1234567891011121314 ┌───┐ │Map│ └───┘ ▲ ┌────┴─────┐ │ │┌───────┐ ┌─────────┐│HashMap│ │SortedMap│└───────┘ └─────────┘ ▲ │ ┌─────────┐ │ TreeMap │ └─────────┘ ¶2、普通排序 使用TreeMap时，放入的Key必须实现Comparable接口。String、Integer这些类已经实现了Comparable接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。 123456789101112public class Main { public static void main(String[] args) { Map&lt;String, Integer&gt; map = new TreeMap&lt;&gt;(); map.put(\"orange\", 1); map.put(\"apple\", 2); map.put(\"pear\", 3); for (String key : map.keySet()) { System.out.println(key); } // apple, orange, pear }} ¶3、自定义类的排序 通过Comparable接口实现一个自定义排序算法： String类型通过compareTo()方法比较，int通过-比较！ 不需要覆写equals()和hashCode()，因为TreeMap不使用equals()和hashCode()。 在创建TreeMap时的参数中传入排序算法： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.learn.java;import java.util.Comparator;import java.util.Map;import java.util.TreeMap;public class TreeMapTest { public static void main(String[] args) { Map&lt;Person1, Integer&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Person1&gt;() { @Override public int compare(Person1 o1, Person1 o2) { return o1.name.compareTo(o2.name); } }); map.put(new Person1(\"Tom\"), 1); map.put(new Person1(\"Bob\"), 2); map.put(new Person1(\"Lily\"), 3); for(var key : map.keySet()){ System.out.println(key); } for(var entry : map.entrySet()){ System.out.println(entry.getKey() + \" \" + entry.getValue()); } System.out.println(map.get(new Person1(\"Lily\"))); // 3 }}class Person1{ public String name; Person1(String name){ this.name = name; } public String toString(){ return \"name: \" + name; }} ¶八、使用Properties 在编写应用程序的时候，经常需要读写配置文件！ 配置文件的特点是，它的Key-Value一般都是String-String类型的，因此我们完全可以用Map来表示它。 因为配置文件非常常用，所以Java集合库提供了一个Properties来表示一组“配置”。由于历史遗留原因，Properties内部本质上是一个Hashtable，但我们只需要用到Properties自身关于读写配置的接口。 ¶1、读取配置文件 用Properties读取配置文件非常简单。Java默认配置文件以.properties为扩展名，每行以key=value表示，以#课开头的是注释。以下是一个典型的配置文件： 配置文件实例： 1234# setting.propertieslast_open_file=/data/hello.txtauto_save_interval=60 读取步骤： Properties读取配置文件，一共有三步： 创建Properties实例； 调用load()读取文件； 调用getProperty()获取配置。（如果key不存在，将返回null。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。） 也可以从classpath读取.properties文件，因为load(InputStream)方法接收一个InputStream实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流！ 1234567891011// 读取步骤：String f = \"setting.properties\";Properties props = new Properties();props.load(new java.io.FileInputStream(f));// 获取属性值：String filepath = props.getProperty(\"last_open_file\");String interval = props.getProperty(\"auto_save_interval\", \"120\");// 从classpath读取配置文件：Properties props = new Properties();props.load(getClass().getResourceAsStream(\"/common/setting.properties\")); ¶2、配置读取实例 从内存读取一个字节流： 123456789101112131415161718package com.learn.java;import java.io.ByteArrayInputStream;import java.util.Properties;public class PropertiesTest { public static void main(String[] args) throws Exception{ String settings = \"# test\" + \"\\n\" + \"course=Java\" + \"\\n\" + \"last_open_date=2019-08-07T12:35:01\"; ByteArrayInputStream input = new ByteArrayInputStream(settings.getBytes(\"UTF-8\")); Properties props = new Properties(); props.load(input); System.out.println(\"course: \" + props.getProperty(\"course\")); System.out.println(\"last_open_date: \" + props.getProperty(\"last_open_date\")); System.out.println(\"last_open_file: \" + props.getProperty(\"last_open_file\")); System.out.println(\"auto_save: \" + props.getProperty(\"auto_save\", \"60\")); }} 输出结果： 1234course: Javalast_open_date: 2019-08-07T12:35:01last_open_file: nullauto_save: 60 ¶3、多配置文件 可以反复调用load()读取，后读取的key-value会覆盖已读取的key-value： 下面的代码演示了Properties的一个常用用法：可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。 123Properties props = new Properties();props.load(getClass().getResourceAsStream(\"/common/setting.properties\"));props.load(new FileInputStream(\"C:\\\\conf\\\\setting.properties\")); Properties设计的目的是存储String类型的key－value，但Properties实际上是从Hashtable派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了getProperty()和setProperty()方法外，还有从Hashtable继承下来的get()和put()方法，这些方法的参数签名是Object，我们在使用Properties的时候，不要去调用这些从Hashtable继承下来的方法。 ¶4、写入配置文件 使用setProperty()方法修改Properties实例； 可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用store()方法！ 123456Properties props2 = new Properties();props2.setProperty(\"url\", \"https://niuxvdong.top/\");props2.setProperty(\"language\", \"Java\");//E:\\MyJavaProgram\\Settings 已写入我的E盘props2.store(new FileOutputStream(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\"), \"这是写入的properties注释\"); 结果如下： 第一行是“这是写入的properties注释”的Unicode编码！ 第二行是生成的时间： 后面是你设置的属性！ 1234#\\u8FD9\\u662F\\u5199\\u5165\\u7684properties\\u6CE8\\u91CA#Wed Apr 08 21:58:45 CST 2020url=https\\://niuxvdong.top/language=Java ¶5、编码 早期版本的Java规定.properties文件编码是ASCII编码（ISO8859-1），如果涉及到中文就必须用name=\\u4e2d\\u6587来表示，非常别扭。从JDK9开始，Java的.properties文件可以使用UTF-8编码了。 不过，需要注意的是，由于load(InputStream)默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法load(Reader)读取！ 就可以正常读取中文。InputStream和Reader的区别是一个是字节流，一个是字符流。字符流在内存中已经以char类型表示了，不涉及编码问题。 1234Properties props3 = new Properties();props3.load(new FileReader(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\", StandardCharsets.UTF_8));System.out.println(props3.getProperty(\"language\")); // JavaSystem.out.println(props3.getProperty(\"url\")); // https://niuxvdong.top/ ¶九、使用Set Map用于存储key-value的映射，对于充当key的对象，是不能重复的，并且，不但需要正确覆写equals()方法，还要正确覆写hashCode()方法。 如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用Set。 Set实际上相当于只存储key、不存储value的Map。我们经常用Set用于去除重复元素。 因为放入Set的元素和Map的key类似，都要正确实现equals()和hashCode()方法，否则该元素无法正确地放入Set。 ¶1、常用方法 将元素添加进Set：boolean add(E e) 将元素从Set删除：boolean remove(Object e) 判断是否包含元素：boolean contains(Object e) 1234567891011121314151617package com.learn.java;import java.util.HashSet;import java.util.Set;public class SetTest { public static void main(String[] args) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); System.out.println(set.add(\"abc\")); // true System.out.println(set.add(\"xyz\")); // true System.out.println(set.add(\"xyz\")); // false，添加失败，因为元素已存在 System.out.println(set.contains(\"xyz\")); // true，元素存在 System.out.println(set.contains(\"XYZ\")); // false，元素不存在 System.out.println(set.remove(\"hello\")); // false，删除失败，因为元素不存在 System.out.println(set.size()); // 2，一共两个元素 }} ¶2、Set实现代码简化版 最常用的Set实现类是HashSet，实际上，HashSet仅仅是对HashMap的一个简单封装，它的核心代码如下： 123456789101112131415161718192021public class HashSet&lt;E&gt; implements Set&lt;E&gt; { // 持有一个HashMap: private HashMap&lt;E, Object&gt; map = new HashMap&lt;&gt;(); // 放入HashMap的value: private static final Object PRESENT = new Object(); public boolean add(E e) { // 放入成功会返回null，失败返回旧value return map.put(e, PRESENT) == null; } public boolean contains(Object o) { return map.containsKey(o); } public boolean remove(Object o) { // 删除成功返回value,失败返回null return map.remove(o) == PRESENT; }} ¶3、两种Set实现类 HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口； TreeSet是有序的，因为它实现了SortedSet接口。 继承关系如下： 1234567891011121314 ┌───┐ │Set│ └───┘ ▲ ┌────┴─────┐ │ │┌───────┐ ┌─────────┐│HashSet│ │SortedSet│└───────┘ └─────────┘ ▲ │ ┌─────────┐ │ TreeSet │ └─────────┘ ¶3.1 HashSet 是无序的，类似HashMap！ 自定义类同样需要实现equals() 和 hashCode()方法！ ¶3.2 TreeSet 实现了SortedSet接口！ 自定义类必须正确实现Comparable接口！ TreeSet不需要覆写equals()和hashCode()方法： 关于TreeSet不需要覆写两个方法！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.learn.java;import java.util.Comparator;import java.util.Set;import java.util.TreeSet;public class TreeSetTest { public static void main(String[] args) { Set&lt;Person2&gt; set = new TreeSet&lt;&gt;(new Comparator&lt;Person2&gt;() { @Override public int compare(Person2 o1, Person2 o2) { if(o1.age != o2.age) return o1.age - o2.age; else return o1.name.compareTo(o2.name); } }); set.add(new Person2(\"hello\", 25)); set.add(new Person2(\"world\", 25)); set.add(new Person2(\"abc\", 30)); set.add(new Person2(\"abc\", 30)); for (var p : set){ System.out.println(p.toString()); } }}class Person2{ public String name; public int age; Person2(String name, int age){ this.age = age; this.name = name; } @Override public String toString(){ return this.name + \" \" + this.age; } /* 不需要覆写： @Override public boolean equals(Object o){ if(o instanceof Person2){ Person2 p = (Person2) o; return Objects.equals(this.name, p.name) &amp;&amp; this.age == p.age; } return false; } @Override public int hashCode(){ return Objects.hash(name, age); }*/} ¶4、一个去重例子 在聊天软件中，发送方发送消息时，遇到网络超时后就会自动重发，因此，接收方可能会收到重复的消息，在显示给用户看的时候，需要首先去重，使用Set去重！ 注释中的两种方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.learn.java;import java.util.*;public class TreeSetTest02 { public static void main(String[] args){ List&lt;Message&gt; received = List.of( new Message(1, \"Hello!\"), new Message(2, \"发工资了吗？\"), new Message(2, \"发工资了吗？\"), new Message(3, \"去哪吃饭？\"), new Message(3, \"去哪吃饭？\"), new Message(4, \"Bye\") ); List&lt;Message&gt; displayMessages = process(received); for (Message message : displayMessages) { System.out.println(message.text); } } static List&lt;Message&gt; process(List&lt;Message&gt; received) { // TODO: 按sequence去除重复消息 // 方法一：通过覆写equals和hashCode方法，来使用Set去重 /*Set&lt;Message&gt; set = new HashSet&lt;&gt;(); List&lt;Message&gt; ls = new ArrayList&lt;&gt;(); for(var list : received) { if (set.add(list)) ls.add(list); } return ls;*/ // 方法二：使用TreeSet进行去重，不需要覆写那两个方法：当然必须实现一个Comparator方法 Set&lt;Message&gt; set = new TreeSet&lt;&gt;(new Comparator&lt;Message&gt;() { @Override public int compare(Message o1, Message o2) { // 这里随便，按照sequence从小到大排 return o1.sequence - o2.sequence; } }); // 将原List放入TreeSet自动实现去重 set.addAll(received); // 返回一个由Set构造的List return new ArrayList&lt;Message&gt;(set); }}class Message { public final int sequence; public final String text; public Message(int sequence, String text) { this.sequence = sequence; this.text = text; } /* 方法一的覆写： @Override public boolean equals(Object o){ if(o instanceof Message){ Message m = (Message) o; return Objects.equals(this.text, m.text) &amp;&amp; this.sequence == m.sequence; } return false; } @Override public int hashCode(){ return Objects.hash(sequence, text); }*/} ¶十、使用Queue 队列（Queue）是一种经常使用的集合。Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作： 把元素添加到队列末尾； 从队列头部取出元素。 ¶1、常用方法 int size()：获取队列长度； boolean add(E)/boolean offer(E)：添加元素到队尾； E remove()/E poll()：获取队首元素并从队列中删除； E element()/E peek()：获取队首元素但并不从队列中删除。 关于上面方法的区别： THROW EXCEPTION 返回false或null 添加元素到队尾 add(E e) boolean offer(E e) 取队首元素并删除 E remove() E poll() 取队首元素但不删除 E element() E peek() add方法超过队列容量会抛出异常，offer方法超过队列容量会返回false； remove方法删除空队列会抛出异常，poll方法删除空队列会返回null; … 123456789101112131415161718192021222324252627package com.learn.java;import java.util.LinkedList;import java.util.Queue;public class QueueTest { public static void main(String[] args) { Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); System.out.println(queue.peek()); // null //System.out.println(queue.element()); // throws NoSuchElementException System.out.println(queue.poll()); // null //System.out.println(queue.remove()); // throws NoSuchElementException queue.offer(\"hello\"); queue.offer(\"world\"); queue.add(\"add\"); System.out.println(queue.size()); // 3 // 获取队首并删除 System.out.println(queue.remove()); // hello System.out.println(queue.poll()); // world // 获取队首不删除 System.out.println(queue.element()); // add System.out.println(queue.peek()); // add }} ¶2、注意点 注意：不要把null添加到队列中，否则poll()方法返回null时，很难确定是取到了null元素还是队列为空。 LinkedList即实现了List接口，又实现了Queue接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用： 1234// 这是一个List:List&lt;String&gt; list = new LinkedList&lt;&gt;();// 这是一个Queue:Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); ¶十一、使用PriorityQueue 用来实现“VIP插队”的业务！ PriorityQueue和Queue的区别在于，它的出队顺序与元素的优先级有关，对PriorityQueue调用remove()或poll()方法，返回的总是优先级最高的元素。 ¶1、标准类的优先队列 所谓不需要实现Comparable接口，因为Java已经实现了这些标准类了！ String当然是按照字母顺序来排列的！ 12345678910111213141516package com.learn.java;import java.util.PriorityQueue;public class PriorityQueueTest01 { public static void main(String[] args) { PriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;(); pq.offer(\"hello\"); pq.offer(\"world\"); pq.offer(\"ababa\"); for(var s : pq){ System.out.println(s); } }} ¶2、自定义类的优先队列 和TreeSet一样，实现一个Comparator对象即可！ 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.learn.java;import java.util.Comparator;import java.util.PriorityQueue;public class PriorityQueueTest02 { public static void main(String[] args) { PriorityQueue&lt;User&gt; pq = new PriorityQueue&lt;User&gt;(new Comparator&lt;User&gt;() { @Override public int compare(User o1, User o2) { if(o1.age == o2.age){ return o1.name .compareTo(o2.name); } return o1.age - o2.age; } }); pq.offer(new User(\"hello\", 25)); pq.offer(new User(\"world\", 10)); pq.offer(new User(\"abcde\", 25)); pq.offer(new User(\"cfgeg\", 30)); while (!pq.isEmpty()){ System.out.println(pq.poll()); } }}class User{ public String name; public int age; User(String name, int age) { this.name = name; this.age = age; } @Override public String toString(){ return name + \" \" + age; }} 也可以这样写 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.learn.java;import java.util.Comparator;import java.util.PriorityQueue;import java.util.Queue;public class PriorityQueueTest03 { public static void main(String[] args) { Queue&lt;Users&gt; pq = new PriorityQueue&lt;Users&gt;(new UsersComparator()); pq.offer(new Users(\"hello\", 25)); pq.offer(new Users(\"world\", 10)); pq.offer(new Users(\"abcde\", 25)); pq.offer(new Users(\"cfgeg\", 30)); while (!pq.isEmpty()){ System.out.println(pq.poll()); } }}class UsersComparator implements Comparator&lt;Users&gt; { public int compare(Users o1, Users o2) { if(o1.age == o2.age){ return o1.name .compareTo(o2.name); } return o1.age - o2.age; }}class Users{ public String name; public int age; public Users(String name, int age) { this.name = name; this.age = age; } @Override public String toString(){ return name + \" \" + age; }} ¶十二、使用Deque Deque是一个接口，它的实现类有ArrayDeque和LinkedList。 LinkedList真是一个全能选手，它即是List，又是Queue，还是Deque的接口！ 两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名Deque。 ¶1、常用方法 queue Deque 添加元素到队尾 add(E e) / offer(E e) addLast(E e) / offerLast(E e) 取队首元素并删除 E remove() / E poll() E removeFirst() / E pollFirst() 取队首元素但不删除 E element() / E peek() E getFirst() / E peekFirst() 添加元素到队首 无 addFirst(E e) / offerFirst(E e) 取队尾元素并删除 无 E removeLast() / E pollLast() 取队尾元素但不删除 无 E getLast() / E peekLast() 1234567891011121314151617package com.learn.java;import java.util.Deque;import java.util.LinkedList;public class DequeTest01 { public static void main(String[] args) { Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); deque.offerLast(\"A\"); // A deque.offerLast(\"B\"); // B -&gt; A deque.offerFirst(\"C\"); // B -&gt; A -&gt; C System.out.println(deque.pollFirst()); // C, 剩下B -&gt; A System.out.println(deque.pollLast()); // B System.out.println(deque.pollFirst()); // A System.out.println(deque.pollFirst()); // null }} ¶2、一些建议 Deque接口实际上扩展自Queue！Queue提供的add()/offer()方法在Deque中也可以使用，但是，使用Deque，最好不要调用offer()，而是调用offerLast()： 123public interface Deque&lt;E&gt; extends Queue&lt;E&gt; { ...} 不要使用接口去实例化 尽量持有接口，而不是具体的实现类。 123456// 不推荐的写法:LinkedList&lt;String&gt; d1 = new LinkedList&lt;&gt;();d1.offerLast(\"z\");// 推荐的写法：Deque&lt;String&gt; d2 = new LinkedList&lt;&gt;();d2.offerLast(\"z\"); ¶十三、使用Stack 栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。 Stack只有入栈和出栈的操作： 把元素压栈：push(E)； 把栈顶的元素“弹出”：pop(E)； 取栈顶元素但不弹出：peek(E)。 在Java中，我们用Deque可以实现Stack的功能： 把元素压栈：push(E)/addFirst(E)； 把栈顶的元素“弹出”：pop(E)/removeFirst()； 取栈顶元素但不弹出：peek(E)/peekFirst()。 Java的集合类没有单独的Stack接口呢？因为有个遗留类名字就叫Stack，出于兼容性考虑，所以没办法创建Stack接口，只能用Deque接口来“模拟”一个Stack了。 当我们把Deque作为Stack使用时，注意只调用push()/pop()/peek()方法，不要调用addFirst()/removeFirst()/peekFirst()方法，这样代码更加清晰。 不要使用遗留类Stack。使用Deque来实现Stack即可！ ¶1、一个例子 使用Stack实现十进制转化为十六进制： 1234567891011121314151617181920212223242526272829303132package com.learn.java;import java.util.Deque;import java.util.LinkedList;public class StackTest { public static void main(String[] args) { String hex = toHex(12500); if (hex.equalsIgnoreCase(\"30D4\")) { System.out.println(\"测试通过\"); } else { System.out.println(\"测试失败\"); } } static String toHex(int n) { Deque&lt;String&gt; stack = new LinkedList&lt;&gt;(); String[] str = {\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"}; while(n != 0){ int t = n % 16; n /= 16; stack.push(str[t]); } StringBuilder s = new StringBuilder(); while(!stack.isEmpty()) { s.append(stack.pop()); } return s.toString(); }} ¶十四、使用Iterator ¶1、for each遍历的实现 Java编译器并不知道如何遍历List。上述代码能够编译通过，只是因为编译器把for each循环通过Iterator改写为了普通的for循环： 12345678910List&lt;String&gt; list = List.of(\"Apple\", \"Orange\", \"Pear\");for (String s : list) { System.out.println(s);}// 编译器编译为如下：for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) { String s = it.next(); System.out.println(s);} ¶2、迭代器 我们把这种通过Iterator对象遍历集合的模式称为迭代器。 使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。 这样一来，调用方就必须知道集合的内部存储结构。并且，如果把ArrayList换成LinkedList，get(int)方法耗时会随着index的增加而增加。如果把ArrayList换成Set，上述代码就无法编译，因为Set内部没有索引。 用Iterator遍历就没有上述问题，因为Iterator对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的for each循环自动转换为Iterator遍历。 ¶3、编写Iterator 我们自己编写了一个集合类，想要使用for each循环，只需满足以下条件： 集合类实现Iterable接口，该接口要求返回一个Iterator对象； 用Iterator对象迭代集合内部数据。 这里的关键在于，集合类通过调用iterator()方法，返回一个Iterator对象，这个对象必须自己知道如何遍历该集合。 一个例子：实现List逆序的迭代器！ 稍有点复杂，要记得多看多练多查资料！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.learn.java;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class IteratorTest { public static void main(String[] args) { ReverseList&lt;String&gt; rlist = new ReverseList&lt;&gt;(); rlist.add(\"Apple\"); rlist.add(\"Orange\"); rlist.add(\"Pear\"); for (String s : rlist) { System.out.println(s); } }}class ReverseList&lt;T&gt; implements Iterable&lt;T&gt; { // 内部使用List存储 private List&lt;T&gt; list = new ArrayList&lt;&gt;(); public void add(T t) { list.add(t); } @Override // 覆写Iterator方法： public Iterator&lt;T&gt; iterator() { return new ReverseIterator(list.size()); } // 实现迭代器：内部类： class ReverseIterator implements Iterator&lt;T&gt; { int index; // 内部类构造方法： ReverseIterator(int index) { this.index = index; } @Override // 覆写hasNext public boolean hasNext() { return index &gt; 0; } @Override // 覆写next public T next() { index--; // 从index输出，即从后向前，访问外部类ReverseList的list的get方法来获取元素： return ReverseList.this.list.get(index); } }} ¶十五、使用Collections Collection，它是除Map外所有其他集合类的根接口，来自于java.util包！ Collections是JDK提供的工具类，同样位于java.util包中。它提供了一系列静态方法，能更方便地操作各种集合。 注意Collections结尾多了一个s，不是Collection！ ¶1、addAll方法 方法可以给一个Collection类型的集合添加若干元素。因为方法签名是Collection，所以我们可以传入List，Set等各种集合类型。 1public static boolean addAll(Collection&lt;? super T&gt; c, T... elements) { ... } 1234567891011121314151617package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; list2 = List.of(\"hello\", \"world\", \"hello\"); // 1. 分开写 /*Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.addAll(list2);*/ // 2.直接可以合并 Set&lt;String&gt; set1 = new HashSet&lt;&gt;(list2); for(var s : set1){ System.out.println(s); } }} ¶2、创建空集合 创建空List：List emptyList() 创建空Map：Map emptyMap() 创建空Set：Set emptySet() 要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。 其他类还可以用类.of()方法来创建空集合！ 12345678910111213package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; list = Collections.emptyList(); List&lt;String&gt; list1 = List.of(); list.add(\"hello\"); // throws UnsupportedOperationException list1.add(\"hello\"); // throws UnsupportedOperationException Map&lt;String, Integer&gt; map = Collections.emptyMap(); }} ¶3、创建单元素集合 创建一个元素的List：List singletonList(T o) 创建一个元素的Map：Map singletonMap(K key, V value) 创建一个元素的Set：Set singleton(T o) 要注意到返回的单元素集合也是不可变集合，无法向其中添加或删除元素。 也可以用各个集合接口提供的of(T...)方法创建单元素集合 使用of()方法创建的都是不变集合，无法进行增删！ 使用of()方法可以实现任意大小的不变集合，比Collections更加方便！ 12345678910List&lt;String&gt; list5 = List.of(\"apple\");List&lt;String&gt; list6 = Collections.singletonList(\"apple\");list5.add(\"hhh\"); // UnsupportedOperationExceptionList&lt;String&gt; list7 = List.of(); // empty list List&lt;String&gt; list8 = List.of(\"apple\"); // 1 elementList&lt;String&gt; list3 = List.of(\"apple\", \"pear\"); // 2 elementsList&lt;String&gt; list4 = List.of(\"apple\", \"pear\", \"orange\"); // 3 elementslist3.add(\"hello\"); // UnsupportedOperationException ¶4、排序 Collections可以对List进行排序。因为排序会直接修改List元素的位置，因此必须传入可变List： 只能对List排序！ 1234567891011121314151617package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; list01 = new ArrayList&lt;&gt;(); list01.add(\"apple\"); list01.add(\"pear\"); list01.add(\"orange\"); // 排序前: System.out.println(list01); // [apple, pear, orange] Collections.sort(list01); // 排序后: System.out.println(list01); // [apple, orange, pear] }} ¶5、洗牌算法 Collections提供了洗牌算法，即传入一个有序的List，可以随机打乱List内部元素的顺序，效果相当于让计算机洗牌： 只针对List！ 1234567891011121314151617package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;Integer&gt; list02 = new ArrayList&lt;&gt;(); for (int i=0; i&lt;10; i++) { list02.add(i); } // 洗牌前: System.out.println(list02); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Collections.shuffle(list02); // 洗牌后: System.out.println(list02); // [5, 7, 1, 4, 9, 2, 6, 0, 8, 3] }} ¶6、不可变集合 Collections还提供了一组方法把可变集合封装成不可变集合： 封装成不可变List：List unmodifiableList(List list) 封装成不可变Set：Set unmodifiableSet(Set set) 封装成不可变Map：Map unmodifiableMap(Map m) 下面这种情况可以用of()方法代替，不过其他情况就不一定了，必须使用该方法了！ 123456789101112131415package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; mutable = new ArrayList&lt;&gt;(); mutable.add(\"apple\"); mutable.add(\"pear\"); // 变为不可变集合: List&lt;String&gt; immutable = Collections.unmodifiableList(mutable); List&lt;String&gt; immutable = List.of(\"apple\", \"pear\"); immutable.add(\"orange\"); // UnsupportedOperationException! }} 继续对原始的可变List进行增删是可以的，并且，会直接影响到封装后的“不可变”List： 原List可修改，会影响到封装后的List！所以需要将原List扔掉！ 123456789101112131415161718package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; mutable = new ArrayList&lt;&gt;(); mutable.add(\"apple\"); mutable.add(\"pear\"); // 变为不可变集合: List&lt;String&gt; immutable = Collections.unmodifiableList(mutable); List&lt;String&gt; immutable = List.of(\"apple\", \"pear\"); immutable.add(\"orange\"); // UnsupportedOperationException! System.out.println(immutable); //[apple, pear] mutable.add(\"orange\"); System.out.println(immutable); //[apple, pear, orange] }} 扔掉原List 操作：将原List置为null即可！ 12345678910111213141516package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; mutable = new ArrayList&lt;&gt;(); mutable.add(\"apple\"); mutable.add(\"pear\"); // 变为不可变集合: List&lt;String&gt; immutable = Collections.unmodifiableList(mutable); // 立刻扔掉mutable的引用: mutable = null; System.out.println(immutable); //[apple, pear] }} ¶7、线程安全集合 Collections还提供了一组方法，可以把线程不安全的集合变为线程安全的集合： 变为线程安全的List：List synchronizedList(List list) 变为线程安全的Set：Set synchronizedSet(Set s) 变为线程安全的Map：Map synchronizedMap(Map m) 多线程的概念我们会在后面讲。因为从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。 集合这一章完结，敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"集合","slug":"集合","permalink":"https://www.itnxd.cn/tags/%E9%9B%86%E5%90%88/"}],"author":"Mr.Niu"},{"title":"Java教程系列之泛型","slug":"Java教程系列之泛型","date":"2020-04-04T10:27:50.000Z","updated":"2021-02-06T14:08:45.303Z","comments":true,"path":"posts/16438.html","link":"","permalink":"https://www.itnxd.cn/posts/16438.html","excerpt":"","text":"¶一、泛型是什么 泛型就是编写模板代码来适应任意类型； 泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查； ¶1、以ArrayList举例 例如将其模板化： T可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的ArrayList： 编译器会针对定义类型进行检查： 12345678910111213141516171819public class ArrayList&lt;T&gt; { private T[] array; private int size; public void add(T e) {...} public void remove(int index) {...} public T get(int index) {...}}// 创建可以存储String的ArrayList:ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;();// 创建可以存储Float的ArrayList:ArrayList&lt;Float&gt; floatList = new ArrayList&lt;Float&gt;();// 创建可以存储Person的ArrayList:ArrayList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();strList.add(\"hello\"); // OKString s = strList.get(0); // OKstrList.add(new Integer(123)); // compile error!Integer n = strList.get(0); // compile error! ¶2、向上转型 Java标准库中的ArrayList实现了List接口，它可以向上转型为List： 12345public class ArrayList&lt;T&gt; implements List&lt;T&gt; { ...}List&lt;String&gt; list = new ArrayList&lt;String&gt;(); ¶3、特别注意 不能把ArrayList&lt;Integer&gt;向上转型为ArrayList&lt;Number&gt;或List&lt;Number&gt;。 我们把一个ArrayList转型为ArrayList类型后，这个ArrayList就可以接受Float类型，因为Float是Number的子类。但是，ArrayList实际上和ArrayList是同一个对象，也就是ArrayList类型，它不可能接受Float类型， 所以在获取Integer的时候将产生ClassCastException。 实际上，编译器为了避免这种错误，根本就不允许把ArrayList转型为ArrayList。 但是java14似乎连转型的第六行赋值都会报错。。。 12345678910// 创建ArrayList&lt;Integer&gt;类型：ArrayList&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;();// 添加一个Integer：integerList.add(new Integer(123));// “向上转型”为ArrayList&lt;Number&gt;：ArrayList&lt;Number&gt; numberList = integerList;// 添加一个Float，因为Float也是Number：numberList.add(new Float(12.34));// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：Integer n = integerList.get(1); // ClassCastException! ¶二、使用泛型 ¶1、泛型接口 接口定义： 12345678public interface Comparable&lt;T&gt; { /** * 返回-1: 当前实例比参数o小 * 返回0: 当前实例与参数o相等 * 返回1: 当前实例比参数o大 */ int compareTo(T o);} 具体用法： 对Person0数组按年龄升序排列，年龄相同，按照姓名字典序排序！ 如果使用了泛型Comparable&lt;Person0&gt;则类内部必须进行compareTo的覆写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.hello;import java.util.Arrays;public class TYPE { public static void main(String[] args) { Person0[] list = new Person0[]{ new Person0(\"B\", 2), new Person0(\"A\", 3), new Person0(\"G\", 0), new Person0(\"A\", 2), new Person0(\"L\", 4) }; Arrays.sort(list); System.out.println(Arrays.toString(list)); // String 类型的排序，本身已经实现了Comparable接口： String[] str = {\"hello\", \"world\", \"hhhh\", \"wor\", \"adv\"}; Arrays.sort(str); System.out.println(Arrays.toString(str)); }}// 使用泛型覆写compareTo方法进行比较：class Person0 implements Comparable&lt;Person0&gt; { public String name; public int age; Person0(String name, int age){ this.name = name; this.age = age; } // 重构toString方法： public String toString(){ return this.name + \"-\" + this.age; } // 覆写compareTo方法： @Override public int compareTo(Person0 o) { if(this.age != o.age) return this.age - o.age; else return this.name.compareTo(o.name); }} 结果如下： 12[G-0, A-2, B-2, A-3, L-4][adv, hello, hhhh, wor, world] ¶三、编写泛型 ¶1、编写泛型 像这样，将需要的写类型的地方全部替换为T，类名称后面加一个&lt;T&gt;即可： 1234567891011121314public class Pair&lt;T&gt; { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { return first; } public T getLast() { return last; }} ¶2、静态方法 普通的方法是通过类的实例来调用的，创建实例的过程调用了构造方法，也就是说对象已经知道这个时候类上面定义的的具体类型了； 而静态方法不需要对象实例来调用，是直接通过类名调用的，两者必须得区分开来写：并且在static后面再加一个&lt;K&gt;： 123456789101112131415public class Pair&lt;T&gt; { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { ... } public T getLast() { ... } // 静态泛型方法应该使用其他类型区分: public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) { return new Pair&lt;K&gt;(first, last); }} ¶3、多参数泛型 同样的操作方法： Java标准库的Map就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。 123456789101112public class Pair&lt;T, K&gt; { private T first; private K last; public Pair(T first, K last) { this.first = first; this.last = last; } public T getFirst() { ... } public K getLast() { ... }}Pair&lt;String, Integer&gt; p = new Pair&lt;&gt;(\"test\", 123); ¶四、擦拭法 Java语言的泛型实现方式是擦拭法（Type Erasure）。 擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。 Java使用擦拭法实现泛型，导致了： 编译器把类型&lt;T&gt;视为Object； 编译器根据&lt;T&gt;实现安全的强制转型。 ¶1、擦拭法过程 编译器看到的代码： 123Pair&lt;String&gt; p = new Pair&lt;&gt;(\"Hello\", \"world\");String first = p.getFirst();String last = p.getLast(); 虚拟机看到的代码： 123Pair p = new Pair(\"Hello\", \"world\");String first = (String) p.getFirst();String last = (String) p.getLast(); ¶2、擦拭法实现泛型的局限 &lt;T&gt;不能是基本类型（必须是引用类型，因为会被编译器处理为Object） 无法取得带泛型的Class（获取到的Class是类的Class） 无法使用instanceof判断类型关系（同上一点原因） 不能实例化T类型 12345678910111213141516// 第一点：int和Object矛盾Pair&lt;int&gt; p = new Pair&lt;&gt;(1, 2); // compile error!// 第二点：都是Pair.class...Pair&lt;String&gt; p1 = new Pair&lt;&gt;(\"Hello\", \"world\");Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(123, 456);Class c1 = p1.getClass();Class c2 = p2.getClass();System.out.println(c1==c2); // trueSystem.out.println(c1==Pair.class); // true// 第三点：同第二点:Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);// Compile error:if (p instanceof Pair&lt;String&gt;.class) {} 第四点：创建new Pair&lt;String&gt;()和创建new Pair&lt;Integer&gt;()就全部成了Object，显然编译器要阻止这种类型不对的代码。 要实例化T类型，我们必须借助额外的Class&lt;T&gt;参数： 上述代码借助Class&lt;T&gt;参数并通过反射来实例化T类型，使用的时候，也必须传入Class&lt;T&gt; 1234567891011121314151617181920212223242526272829// 第四点：无法实例化public class Pair&lt;T&gt; { private T first; private T last; public Pair() { // Compile error: first = new T(); last = new T(); }}// 借助Class实例化：package com.hello;public class ClassInstance { public static void main(String[] args) throws Exception { PairOne&lt;String&gt; p = new PairOne&lt;&gt;(String.class); }}class PairOne &lt;T&gt; { public T first; public T second; PairOne(Class&lt;T&gt; clazz) throws Exception { first = clazz.newInstance(); second = clazz.newInstance(); }} ¶3、无法覆写 定义的equals(T t)方法实际上会被擦拭成equals(Object t)，而这个方法是继承自Object的，编译器会阻止一个实际上会变成覆写的泛型方法定义。 12345678910class PairOne &lt;T&gt; { // 无法覆写Object的方法:编译报错 public boolean equals(T t){ return this == t; } // 改名即可： public boolean equal(T t){ return this == t; }} ¶4、泛型继承 无法获取Pair&lt;T&gt;的T类型，即给定一个变量Pair&lt;String&gt; p，无法从p中获取到String类型。 但是，在父类是泛型类型的情况下，编译器就必须把类型T（对PairOne来说，也就是String类型）保存到子类的class文件中，不然编译器就不知道PairOne只能存取String这种类型。 在继承了泛型类型的情况下，子类可以获取父类的泛型类型。 实现方法如下； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.hello;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;public class ClassInstance { public static void main(String[] args) throws Exception { PairOne&lt;String&gt; p = new PairOne&lt;&gt;(String.class); // 获取父类的T类型： Class&lt;PairTwo&gt; cls = PairTwo.class; Type t = cls.getGenericSuperclass(); if(t instanceof ParameterizedType){ ParameterizedType pt = (ParameterizedType) t; Type[] types = pt.getActualTypeArguments(); Type firstType = types[0]; Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType; System.out.println(typeClass); } }}class PairOne &lt;T&gt; { public T first; public T second; PairOne(T first, T second){ this.first = first; this.second = second; } PairOne(Class&lt;T&gt; clazz) throws Exception { first = clazz.newInstance(); second = clazz.newInstance(); } // 无法覆写Object的方法 /*public boolean equals(T t){ return this == t; }*/ // 改名即可： public boolean equal(T t){ return this == t; }}class PairTwo extends PairOne&lt;String&gt;{ PairTwo(String first, String second) { super(first, second); }} Java 类型的结构图： 12345678910 ┌────┐ │Type│ └────┘ ▲ │ ┌────────────┬────────┴─────────┬───────────────┐ │ │ │ │┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐│Class││ParameterizedType││GenericArrayType││WildcardType│└─────┘└─────────────────┘└────────────────┘└────────────┘ ¶五、extends通配符 PairThree&lt;Number&gt;不是PairThree&lt;Ingeter&gt;的子类。 因为PairThree&lt;Number&gt;不是PairThree&lt;Ingeter&gt;的子类，因此，add(PairThree&lt;Number&gt;)不接受参数类型PairThree&lt;Integer&gt;。 ¶1、无继承关系无法传参 1234567891011121314151617181920212223242526272829303132333435package com.hello;public class Extends { public static void main(String[] args) { PairThree&lt;Number&gt; p = new PairThree&lt;&gt;(23, 89); System.out.println(add(p)); PairThree&lt;Integer&gt; i = new PairThree&lt;&gt;(23, 89); System.out.println(add(i));// 编程错误 } static int add(PairThree&lt;Number&gt; p){ Number first = p.getA(); Number second = p.getB(); return first.intValue() + second.intValue(); }}class PairThree &lt;T&gt; { private T a; private T b; public PairThree(T a, T b){ this.a = a; this.b = b; } public T getA() { return a; } public T getB() { return b; }} 很明显这里没什么毛病，属于向上转型，因为Integer向上转型为Number! 但是问题在add方法的参数上，PairThree&lt;Number&gt;是不可能接受PairThree&lt;Integer&gt; 的，毕竟没有继承关系。。。 12Number first = p.getA();Number last = p.getB(); ¶2、通过extends通配符传继承子类 Java中的通配符：? 只要是Number的子类就可以进行传参： 使用&lt;? extends Number&gt;的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number了。 12345static int add(PairThree&lt;? extends Number&gt; p){ Number first = p.getA(); Number second = p.getB(); return first.intValue() + second.intValue();} 下面的赋值是无法通过的！ 编译器只是知道传入的是Number或其子类，并不知道到底是谁，具体类型无法确定！无法完成赋值！ 1Integer x = p.getFirst(); ¶3、extends通配符处理set方法 如此效果，也就是你只能对其进行获取，不能进行修改，极大保证了数据安全性！ 1234567891011static int addOne(PairThree&lt;? extends Number&gt; p){ Number first = p.getA(); Number second = p.getB(); // 当前p类型为PairThree&lt;? extends Number&gt; 无法传入除null之外的其他类型 // 报错 //p.setA(new Integer(123)); //p.setB(new Integer(345)); p.setA(null);// ok, 但是后面会抛出NullPointerException p.getA().intValue(); // NullPointerException return p.getA().intValue()+ p.getB().intValue();} ¶4、extends通配符作用 当然和上一点的安全性脱不了关系： 方法使用了通配符参数，有什么用呢？ 优点： 允许调用get()方法获取Integer的引用； 不允许调用set(? extends Integer)方法并传入任何Integer的引用（null除外）。 即通过通配符参数实现了List类的只读效果，保证了安全！ 123456789101112131415public interface List&lt;T&gt; { int size(); // 获取个数 T get(int index); // 根据索引获取指定元素 void add(T t); // 添加一个新元素 void remove(T t); // 删除一个已有元素}int sumOfList(List&lt;? extends Integer&gt; list) { int sum = 0; for (int i=0; i&lt;list.size(); i++) { Integer n = list.get(i); sum = sum + n; } return sum;} ¶5、使用extends通配符限定T类型 则在定义时只能是Number及其子类！ 其他类型将无法通过编译： 1public class Pair&lt;T extends Number&gt; { ... } ¶六、super通配符 和extends相反，extends通配符可以接收当前类以及子类，super通配符可以接收当前类及其父类： 但是无法通过当前类或其他类来接收当前获取到的值，除了Object对象： 很好理解：当前类型p是Integer本身或其父类，编译器无法确定到底是和类型，无法用一个Integer来接收Number，当然Object是可以接收的，所有类型都可以向上转型为Object对象！ ¶1、只能写不能读 使用&lt;? super Integer&gt;通配符表示： 允许调用set(? super Integer)方法传入Integer的引用； 不允许调用get()方法获得Integer的引用。 唯一例外是可以获取Object的引用：Object o = p.getFirst()。 换句话说，使用&lt;? super Integer&gt;通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.hello;public class Super { public static void main(String[] args) { PairFive&lt;Integer&gt; p1 = new PairFive&lt;&gt;(123, 567); PairFive&lt;Number&gt; p2 = new PairFive&lt;&gt;(34, 69); setName(p1, 100); setName(p2, 200); System.out.println(p1.getA()); // 100 System.out.println(p2.getA()); // 200 } static void setName(PairFive&lt;? super Integer&gt; p, Integer n){ // 唯一可接受get方法的是Object Object oc = p.getA(); // 这样无法接收： Number nc = p.getA(); Integer ic = p.getA(); p.setA(n); p.setB(n); }}class PairFive &lt;T&gt; { private T a; private T b; public PairFive(T a, T b){ this.a = a; this.b = b; } public void setA(T a) { this.a = a; } public void setB(T b) { this.b = b; } public T getA() { return a; } public T getB() { return b; }} ¶2、extends 与 super 区别 作为方法参数，&lt;? super T&gt;类型和&lt;? extends T&gt;类型的区别在于： &lt;? extends T&gt;允许调用读方法T get()获取T的引用，但不允许调用写方法set(T)传入T的引用（传入null除外）； &lt;? super T&gt;允许调用写方法set(T)传入T的引用，但不允许调用读方法T get()获取T的引用（获取Object除外）。 一个是允许读不允许写，另一个是允许写不允许读。 ¶一个很好的例子： 作用：将src的元素全部添加到dest中： 这个copy()方法的定义就完美地展示了extends和super的意图： copy()方法内部不会读取dest，因为不能调用dest.get()来获取T的引用； copy()方法内部也不会修改src，因为不能调用src.add(T)。 倘若意外修改了src，或者意外读取了dest，就会导致一个编译错误： 12345678910111213141516171819202122232425package com.hello;import java.util.List;public class CollectionsTest { public static void main(String[] args) { }}class CollectionsDemo { // 把src的每个元素复制到dest中: public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { // 下面的循环可以用这句话替代： // dest.addAll(src); for (int i=0; i&lt;src.size(); i++) { T t = src.get(i); dest.add(t); } // 无法实现： T t = dest.get(0); // compile error! src.add(t); // compile error! }} 当然，也无法反过来添加： 这些都是通过super和extends通配符，并由编译器强制检查来实现的。 1234567// copy List&lt;Integer&gt; to List&lt;Number&gt; ok:List&lt;Number&gt; numList = ...;List&lt;Integer&gt; intList = ...;CollectionDemo.copy(numList, intList);// ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;:CollectionDemo.copy(intList, numList); ¶3、PECS 原则 何时使用extends，何时使用super？ 为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。 如果需要返回T，它是生产者（Producer），要使用extends通配符；如果需要写入T，它是消费者（Consumer），要使用super通配符。 任然使用这个例子： 12345678public class Collections { public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { for (int i=0; i&lt;src.size(); i++) { T t = src.get(i); // src是producer dest.add(t); // dest是consumer } }} ¶4、无界定通配符 即只定义一个&lt;?&gt;： 因为&lt;?&gt;通配符既没有extends，也没有super，因此： 不允许调用set(T)方法并传入引用（null除外）； 不允许调用T get()方法并获取T引用（只能获取Object引用）。 换句话说，既不能读，也不能写，那只能做一些null判断： 123static boolean isNull(Pair&lt;?&gt; p){ return p.getFirst() == null || p.getSecond() == null;} 大多数情况下，可以引入泛型参数&lt;T&gt;消除&lt;?&gt;通配符：(一般这样使用) 123static &lt;T&gt; boolean isNull(Pair&lt;T&gt; p) { return p.getFirst() == null || p.getSecond() == null;} &lt;?&gt;通配符有一个独特的特点，就是：Pair&lt;?&gt;是所有Pair&lt;T&gt;的超类(即父类)： ¶5、super通配符不能用于class 无法这样写： extends可以！ 123class demo &lt;T super Number&gt; {} ¶七、泛型与反射 ¶1、Class&lt;T&gt;是泛型 123456789// 编译警告：可运行Class cls = String.class;String str0 = (String)cls.newInstance();// 无问题：Class&lt;String&gt; cl = String.class;String str = cl.newInstance();Class&lt;? super String&gt; sup = String.class.getSuperclass(); ¶2、Constructor&lt;T&gt;是泛型 1234Class&lt;Integer&gt; clazz = Integer.class;Constructor&lt;Integer&gt; cons = clazz.getConstructor(int.class);Integer i = cons.newInstance(123);System.out.println(i); // 123 ¶3、泛型数组创建 不能用new操作符创建带泛型的数组： 必须通过强制转型实现带泛型的数组： 可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型： 123456Pair&lt;String&gt;[] ps = null; // okPair&lt;String&gt;[] ps1 = new Pair&lt;String&gt;[2]; // compile error!// 正确使用：@SuppressWarnings(\"unchecked\")Pair&lt;String&gt;[] ps2 = (Pair&lt;String&gt;[]) new Pair[2]; 可以通过Array.newInstance(Class, int)创建T[]数组，需要强制转型： 廖雪峰教程，有点没看懂，以后再看！。。。 ¶4、谨慎使用泛型可变参数 如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。 直接调用asArray(T...)似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生ClassCastException，原因还是因为擦拭法，在pickTwo()方法内部，编译器无法检测K[]的正确类型，因此返回了Object[]。 如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用@SafeVarargs消除警告。 12345678910111213141516171819202122package com.learn.java;import java.util.Arrays;public class Main01 { public static void main(String[] args) { String[] arr = asArray(\"one\", \"two\", \"three\"); System.out.println(Arrays.toString(arr)); // ClassCastException: String[] firstTwo = pickTwo(\"one\", \"two\", \"three\"); System.out.println(Arrays.toString(firstTwo)); } static &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) { return asArray(k1, k2); } @SafeVarargs static &lt;T&gt; T[] asArray(T... objs) { return objs; }} 输出结果： 123[one, two, three]Exception in thread \"main\" java.lang.ClassCastException: class [Ljava.lang.Object; cannot be cast to class [Ljava.lang.String; ([Ljava.lang.Object; and [Ljava.lang.String; are in module java.base of loader 'bootstrap') at com.learn.java.Main01.main(Main01.java:10) 泛型章节终于结束，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"泛型","slug":"泛型","permalink":"https://www.itnxd.cn/tags/%E6%B3%9B%E5%9E%8B/"}],"author":"Mr.Niu"},{"title":"Java教程系列之注解","slug":"Java教程系列之注解","date":"2020-04-02T09:50:48.000Z","updated":"2020-05-19T02:01:30.333Z","comments":true,"path":"posts/35258.html","link":"","permalink":"https://www.itnxd.cn/posts/35258.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶一、什么是注解 注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释” 注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。 ¶注解的作用 从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定： Java的注解可以分为三类： 由编译器使用的注解 由工具处理.class文件使用的注解 在程序运行期能够读取的注解 第一类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。 第二类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。 第三类加载后一直存在于JVM中，这也是最常用的注解 注解的参数： 所有基本类型； String； 枚举类型； 基本类型、String以及枚举的数组。 因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。 注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。 此外，大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。 如果只写注解，相当于全部使用默认值。 ¶二、定义注解 ¶1、如何定义注解（Annotation） 用@interface定义注解 添加参数、默认值 用元注解配置注解 必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。 注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。 12345678910// 第三步：@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)// 第一步：public @interface Report { // 第二步： int type() default 0; String level() default \"info\"; String value() default \"\";} ¶2、元注解 有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。 ¶target 使用@Target可以定义Annotation能够被应用于源码的哪些位置： 实际上@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法。 类或接口：ElementType.TYPE； 字段：ElementType.FIELD； 方法：ElementType.METHOD； 构造方法：ElementType.CONSTRUCTOR； 方法参数：ElementType.PARAMETER。 123456789// 一个参数：@Target(ElementType.METHOD)// 多个参数：@Target({ElementType.TYPE, ElementType.METHOD})public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\";} ¶Retention 定义了Annotation的生命周期： 如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解 仅编译期：RetentionPolicy.SOURCE； 仅class文件：RetentionPolicy.CLASS； 运行期：RetentionPolicy.RUNTIME。 123456@Retention(RetentionPolicy.RUNTIME)public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\";} ¶Repeatable 可以定义Annotation是否可重复。这个注解应用不是特别广泛。 123456789101112131415161718192021222324// 参数为重复类的Class@Repeatable(Hellos.class)//@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE, ElementType.METHOD})@interface Hello { int type() default 0; String level() default \"info\"; String value() default \"\";}@Target(ElementType.TYPE)@interface Hellos{ Hello[] value();}// 重复注解：@Hello(type = 1, level = \"debug\", value = \"test\")@Hello(type = 2, level = \"warning\", value = \"warn\")@Hello(type = 3, value = \"niu\")class Test{} ¶Inherited 使用@Inherited定义子类是否可继承父类定义的Annotation。 @Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效 123456789101112131415161718@Inherited@Target(ElementType.TYPE)@interface Hello { int type() default 0; String level() default \"info\"; String value() default \"\";}@Hello(type = 1, level = \"debug\", value = \"test\")class Test{}class TestSon extends Test{} ¶三、处理注解 根据@Retention的配置 如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。 只有RUNTIME类型的注解不但要使用，还经常需要编写。 因此，我们只讨论如何读取RUNTIME类型的注解。 注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。 ¶1、使用反射读取注解 Java提供的使用反射API读取Annotation的方法包括： 判断某个注解是否存在于Class、Field、Method或Constructor： Class.isAnnotationPresent(Class) Field.isAnnotationPresent(Class) Method.isAnnotationPresent(Class) Constructor.isAnnotationPresent(Class) 使用反射API读取Annotation： Class.getAnnotation(Class) Field.getAnnotation(Class) Method.getAnnotation(Class) Constructor.getAnnotation(Class) ¶先判断Annotation是否存在再读取 注解及类的定义： 12345678910111213141516171819@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@interface Hello { int type() default 0; String level() default \"info\"; String value() default \"\";}@Target(ElementType.TYPE)@interface Hellos{ Hello[] value();}@Hello(type = 1, level = \"debug\", value = \"test\")class Test{} 1234567Class cls = Test.class;if(cls.isAnnotationPresent(Hello.class)){ Hello hello = (Hello) cls.getAnnotation(Hello.class); System.out.println(hello.level()); // debug System.out.println(hello.type()); // 1 System.out.println(hello.value()); // test} ¶直接读取Annotation，不存在返回null 1234567Class cls1 = Test.class;Hello hello = (Hello) cls1.getAnnotation(Hello.class);if(hello != null){ System.out.println(hello.level()); // debug System.out.println(hello.type()); // 1 System.out.println(hello.value()); // test} ¶读取方法参数的注解 有点没看懂。。先搁这里！点击这里查看！ ¶2、注解的使用 注解好处：再需要检查的字段或方法前加上再写一个Check方法即可实现所有检查！ 提高了效率： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.hello;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Field;public class Annotation1 { public static void main(String[] args){ Person p1 = new Person(\"niuge\", \"xinzhou\"); Person p2 = new Person(\"niuge\", \"shanxixinzhou\"); for(Person p : new Person[]{p1, p2}){ try{ Check(p); System.out.println(\"String 参数无误！\"); }catch (IllegalAccessException e){ System.out.println(\"String 参数有误！\" + e.toString()); } } } static void Check(Person p) throws IllegalAccessException { // 获取Person实例p的每个字段field for(Field field : p.getClass().getFields()){ // 获取每个字段的注解 Range range = field.getAnnotation(Range.class); // 注解存在时 if(range != null){ // 获取当前字段的值 Object value = field.get(p); // 是String类型时： if(value instanceof String){ String s = (String) value; // 判断是否符合范围Range if(s.length() &lt; range.min() || s.length() &gt; range.max()){ throw new IllegalAccessException(\"String 有误！(Check函数抛出)\"); } } } } }}@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)@interface Range{ int min() default 0; int max() default 0x3f;}class Person{ @Range(min = 1, max = 20) public String name; @Range(max = 10) public String city; public Person(String name, String city){ this.name = name; this.city = city; }} 输出结果： 12String 参数无误！String 参数有误！java.lang.IllegalAccessException: String 有误！(Check函数抛出) 注解已经完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://www.itnxd.cn/tags/%E6%B3%A8%E8%A7%A3/"}],"author":"Mr.Niu"},{"title":"Java教程系列之反射","slug":"Java教程系列之反射","date":"2020-04-01T10:05:20.000Z","updated":"2021-02-06T14:07:49.347Z","comments":true,"path":"posts/39487.html","link":"","permalink":"https://www.itnxd.cn/posts/39487.html","excerpt":"","text":"¶一、什么是反射 反射：Reflection 反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。 通过Class实例获取class信息的方法称为反射（Reflection）。 ¶二、Class类 class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。 每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来！ 这里的Class类型是一个名叫Class的class。。。。 1、以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来 2、Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。 3、此处为JVM自动创建，是一个私有类！ 1Class cls = new Class(String); 一个Class实例包含了该class的所有完整信息！ 由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。 这种通过Class实例获取class信息的方法称为反射（Reflection）。 ¶1、创建CLass 直接通过一个class的静态变量class获取： 通过该实例变量提供的getClass()方法获取： 通过静态方法Class.forName()获取，参数为完整类名： 因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。可以用==比较两个Class实例： 12345String s = \"\";Class cls = String.class;Class cls1 = s.getClass();Class cls2 = Class.forName(\"java.lang.String\");System.out.println(cls == cls1); ¶2、== 和 instanceof() instanceof可以判断子类及继承关系！ ==可以用来精确判断类的类型！ 通常情况下，我们应该用instanceof判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个class的时候，我们才使用==判断class实例。 1234567Integer n = new Integer(123);boolean b1 = n instanceof Integer; // true，因为n是Integer类型boolean b2 = n instanceof Number; // true，因为n是Number类型的子类boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.classboolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class ¶3、通过Class来获取相关信息 1234567891011121314151617181920212223242526package com.test;public class reflection { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException { printClassInfo(\"\".getClass()); printClassInfo(Runnable.class); printClassInfo(java.time.Month.class); printClassInfo(String[].class); printClassInfo(int.class); System.out.println(\"end\"); } static void printClassInfo(Class cls) { System.out.println(\"Class name: \" + cls.getName()); System.out.println(\"Simple name: \" + cls.getSimpleName()); if (cls.getPackage() != null) { System.out.println(\"Package name: \" + cls.getPackage().getName()); } System.out.println(\"is interface: \" + cls.isInterface()); System.out.println(\"is enum: \" + cls.isEnum()); System.out.println(\"is array: \" + cls.isArray()); System.out.println(\"is primitive: \" + cls.isPrimitive()); }} 输出结果： 数组（例如String[]）也是一种Class，而且不同于String.class，它的类名是[Ljava.lang.String 1234567891011121314151617181920212223242526272829303132333435Class name: java.lang.StringSimple name: StringPackage name: java.langis interface: falseis enum: falseis array: falseis primitive: falseClass name: java.lang.RunnableSimple name: RunnablePackage name: java.langis interface: trueis enum: falseis array: falseis primitive: falseClass name: java.time.MonthSimple name: MonthPackage name: java.timeis interface: falseis enum: trueis array: falseis primitive: false// 特殊：String 类型的数组Class name: [Ljava.lang.String;Simple name: String[]is interface: falseis enum: falseis array: trueis primitive: falseClass name: intSimple name: intis interface: falseis enum: falseis array: falseis primitive: trueend ¶4、动态加载 JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载： 当执行Main.java时，由于用到了Main，因此，JVM首先会把Main.class加载到内存。然而，并不会加载Person.class，除非程序执行到create()方法，JVM发现需要加载Person类时，才会首次加载Person.class。如果没有执行create()方法，那么Person.class根本就不会被加载。 1234567891011121314151617181920package com.test;public class reflectionTest { public static void main(String[] args) { if(args.length &gt; 0){ create(args[0]); } } static void create(String name){ Person1 p = new Person1(name); }}class Person1{ public String name; public Person1(String name){ this.name = name; }} ¶5、Log的动态加载 动态加载class的特性对于Java程序非常重要。利用JVM动态加载class的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下： 所以我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。 12345678910111213141516// Commons Logging优先使用Log4j:LogFactory factory = null;if (isClassPresent(\"org.apache.logging.log4j.Logger\")) { factory = createLog4j();} else { factory = createJdkLog();}boolean isClassPresent(String name) { try { Class.forName(name); return true; } catch (Exception e) { return false; }} ¶三、访问字段 ¶1、访问字段 Field getField(name)：根据字段名获取某个public的field（包括父类） Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类） Field[] getFields()：获取所有public的field（包括父类） Field[] getDeclaredFields()：获取当前类的所有field（不包括父类） 1234567891011121314151617181920public class Main { public static void main(String[] args) throws Exception { Class stdClass = Student.class; // 获取public字段\"score\": System.out.println(stdClass.getField(\"score\")); // 获取继承的public字段\"name\": System.out.println(stdClass.getField(\"name\")); // 获取private字段\"grade\": System.out.println(stdClass.getDeclaredField(\"grade\")); }}class Student extends Person { public int score; private int grade;}class Person { public String name;} 123public int Student.scorepublic java.lang.String Person.nameprivate int Student.grade ¶2、field对象方法 一个Field对象包含了一个字段的所有信息： getName()：返回字段名称，例如，\"name\"； getType()：返回字段类型，也是一个Class实例，例如，String.class； getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。 String类的value字段如下定义： 123public final class String { private final byte[] value;} 获取所有信息： 12345678910111213141516171819package com.test;import java.lang.reflect.Field;import java.lang.reflect.Modifier;public class field { public static void main(String[] args) throws Exception { Field f = String.class.getDeclaredField(\"value\"); System.out.println(f.getName()); // \"value\" System.out.println(f.getType()); // class [B 表示byte[]类型 int m = f.getModifiers(); System.out.println(m); // 18 System.out.println(Modifier.isFinal(m)); // true System.out.println(Modifier.isPublic(m)); // false System.out.println(Modifier.isProtected(m)); // false System.out.println(Modifier.isPrivate(m)); // true System.out.println(Modifier.isStatic(m)); // false }} ¶3、获取字段值 先获取Class实例： 再获取Field实例： 然后，用Field.get(Object)获取指定实例的指定字段的值。 123456789101112131415161718192021package com.test;import java.lang.reflect.Field;public class getField { public static void main(String[] args) throws Exception { Object p = new Person3(\"Xiao Ming\"); Class c = p.getClass(); Field f = c.getDeclaredField(\"name\"); Object value = f.get(p); System.out.println(value); // \"Xiao Ming\" }}class Person3{ // public字段 public String name; public Person3(String name){ this.name = name; }} private字段main类是无法访问的： 直接访问会得到一个IllegalAccessException！ 解决方法： 在调用Object value = f.get(p);前，先写一句： 1f.setAccessible(true); 调用Field.setAccessible(true)的意思是，别管这个字段是不是public，一律允许访问。 如果使用反射可以获取private字段的值，那么类的封装还有什么意义？ 答案是正常情况下，我们总是通过p.name来访问Person的name字段，编译器会根据public、protected和private决定是否允许访问字段，这样就达到了数据封装的目的。 而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。 此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 修改如下： 123456789101112131415161718192021package com.test;import java.lang.reflect.Field;public class getField { public static void main(String[] args) throws Exception { Object p = new Person3(\"Xiao Ming\"); Class c = p.getClass(); Field f = c.getDeclaredField(\"name\"); f.setAccessible(true); Object value = f.get(p); System.out.println(value); // \"Xiao Ming\" }}class Person3{ private String name; public Person3(String name){ this.name = name; }} ¶4、设置字段值 设置字段值是通过Field.set(Object, Object)实现的，其中第一个Object参数是指定的实例，第二个Object参数是待修改的值： 修改非public字段，需要首先调用setAccessible(true)。 123456789101112131415161718192021222324252627package com.test;import java.lang.reflect.Field;public class getField { public static void main(String[] args) throws Exception { Person3 p = new Person3(\"Xiao Ming\"); System.out.println(p.getName()); Class c = p.getClass(); Field f = c.getDeclaredField(\"name\"); f.setAccessible(true); //Object value = f.get(p); f.set(p, \"Xiao Hong\"); System.out.println(p.getName()); // \"Xiao Hong\" }}class Person3{ private String name; public Person3(String name){ this.name = name; } public String getName() { return name; }} ¶四、调用方法 ¶1、调用方法 我们已经能通过Class实例获取所有Field对象，同样的，可以通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method： Method getMethod(name, Class...)：获取某个public的Method（包括父类） Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类） Method[] getMethods()：获取所有public的Method（包括父类） Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类） 12345678910111213141516171819202122232425262728package com.test;public class method { public static void main(String[] args) throws Exception { Class stdClass = Students.class; // 获取public方法getScore，参数为String: System.out.println(stdClass.getMethod(\"getScore\", String.class)); // 获取继承的public方法getName，无参数: System.out.println(stdClass.getMethod(\"getName\")); // 获取private方法getGrade，参数为int: System.out.println(stdClass.getDeclaredMethod(\"getGrade\", int.class)); }}class Students extends Person4 { public int getScore(String type) { return 99; } private int getGrade(int year) { return 1; }}class Person4 { public String getName() { return \"Person\"; }} 输出结果： 123public int com.test.Students.getScore(java.lang.String)public java.lang.String com.test.Person4.getName()private int com.test.Students.getGrade(int) ¶2、method对象方法 一个Method对象包含一个方法的所有信息： getName()：返回方法名称，例如：\"getScore\"； getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class； getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}； getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。 ¶3、调用方法 用反射来调用substring方法： 对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。 1234567891011121314151617package com.test;import java.lang.reflect.Method;public class getMethod { public static void main(String[] args) throws Exception{ // String对象: String s = \"Hello world\"; // 获取String substring(int)方法，参数为int: Method m = String.class.getMethod(\"substring\", int.class); System.out.println(m); // 在s对象上调用该方法并获取结果: String r = (String) m.invoke(s, 6); // 打印调用结果: System.out.println(r); }} 输出结果如下： 12public java.lang.String java.lang.String.substring(int)world ¶4、调用静态方法 如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null。 1234567891011121314package com.test;import java.lang.reflect.Method;public class Main { public static void main(String[] args) throws Exception { // 获取Integer.parseInt(String)方法，参数为String: Method m = Integer.class.getMethod(\"parseInt\", String.class); // 调用该静态方法并获取结果: Integer n = (Integer) m.invoke(null, \"12345\"); // 打印调用结果: System.out.println(n); // 12345 }} ¶5、调用非public方法 和Field类似，对于非public方法，我们虽然可以通过Class.getDeclaredMethod()获取该方法实例，但直接对其调用将得到一个IllegalAccessException。为了调用非public方法，我们通过Method.setAccessible(true)允许其调用： 此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 12345678910111213141516171819202122package com.test;import java.lang.reflect.Method;public class Main { public static void main(String[] args) throws Exception { Person p = new Person(); Method m = p.getClass().getDeclaredMethod(\"setName\", String.class); // 关键点： m.setAccessible(true); m.invoke(p, \"Bob\"); System.out.println(p.name); }}class Person { String name; private void setName(String name) { this.name = name; }} ¶6、多态 我们来考察这样一种情况：一个Person类定义了hello()方法，并且它的子类Student也覆写了hello()方法，那么，从Person.class获取的Method，作用于Student实例时，调用的方法到底是哪个？ 12345678910111213141516171819202122232425package com.test;import java.lang.reflect.Method;public class Main { public static void main(String[] args) throws Exception { // 获取Person的hello方法: Method h = Person.class.getMethod(\"hello\"); // 对Student实例调用hello方法: h.invoke(new Student()); //Student:hello }}class Person { public void hello() { System.out.println(\"Person:hello\"); }}class Student extends Person { public void hello() { System.out.println(\"Student:hello\"); }} 使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在） 123456Method m = Person.class.getMethod(\"hello\");m.invoke(new Student());// 相当于：Person p = new Student();p.hello(); ¶7、链式编程 123456789// 普通方法：Method m1 = Integer.class.getMethod(\"parseInt\", String.class);Integer n = (Integer) m1.invoke(null, \"12345\");System.out.println(n);// 链式编程：Integer n = (Integer) Integer.class.getMethod(\"parseInt\", String.class).invoke(null, \"123456\");// 打印调用结果:System.out.println(n); ¶五、调用构造方法 ¶1、通过调用Class提供的newInstance()方法来创建构造方法实例 调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。 1Person p = Person.class.newInstance(); ¶2、通过调用Java的反射API提供了Constructor对象来创建构造方法实例 通过Class实例获取Constructor的方法如下： getConstructor(Class...)：获取某个public的Constructor； getDeclaredConstructor(Class...)：获取某个Constructor； getConstructors()：获取所有public的Constructor； getDeclaredConstructors()：获取所有Constructor。 注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。 调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。 Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例： 12345678910111213141516import java.lang.reflect.Constructor;public class Main { public static void main(String[] args) throws Exception { // 获取构造方法Integer(int): Constructor cons1 = Integer.class.getConstructor(int.class); // 调用构造方法: Integer n1 = (Integer) cons1.newInstance(123); System.out.println(n1); // 123 // 获取构造方法Integer(String) Constructor cons2 = Integer.class.getConstructor(String.class); Integer n2 = (Integer) cons2.newInstance(\"456\"); System.out.println(n2); // 456 }} ¶六、获取继承关系 ¶1、获取父类Class 使用getSuperclass()方法： 12345678910public class Main { public static void main(String[] args) throws Exception { Class i = Integer.class; Class n = i.getSuperclass(); System.out.println(n); Class o = n.getSuperclass(); System.out.println(o); System.out.println(o.getSuperclass()); }} 输出结果： Integer的父类类型是Number，Number的父类是Object，Object的父类是null。 除Object外，其他任何非interface的Class都必定存在一个父类类型。 123class java.lang.Numberclass java.lang.Objectnull ¶2、获取接口Interface 使用getInterfaces()方法： 如果一个类没有实现任何interface，那么getInterfaces()返回空数组。 12345678910public class Main { public static void main(String[] args) throws Exception { Class s = Integer.class; Class[] is = s.getInterfaces(); for (Class i : is) { System.out.println(i); } }} 输出结果： 可知Integer有以下三个接口： 123interface java.lang.Comparableinterface java.lang.constant.Constableinterface java.lang.constant.ConstantDesc 要特别注意：getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型： 12345678910public class Main { public static void main(String[] args) throws Exception { Class s = Integer.class.getSuperclass(); System.out.println(s); Class[] is = s.getInterfaces(); for (Class i : is) { System.out.println(i); } }} 输出结果如下： 可知Number的接口只有下面这一个： 12class java.lang.Numberinterface java.io.Serializable 接口使用getSuperclass()方法永远返回null： ¶3、Class的继承关系 判断普通实例使用instanceof ()方法： 判断Class实例使用isAssignableFrom()方法： 可以这样简单理解：括号内的是否继承自外面的！ 12345678// Integer i = ?Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer// Number n = ?Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number// Object o = ?Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object// Integer i = ?Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer ¶七、动态代理（Dynamic Proxy） ¶1、class 和 interface class和interface的区别： 可以实例化class（非abstract）； 不能实例化interface。 ¶2、静态代理实现 定义接口 编写实现类 创建实例转型为接口并调用 123456789101112131415161718package com.test;public class DynamicProxy { public static void main(String[] args) { Hello hello = new HelloWorlds(); hello.morning(\"Bob\"); }}class HelloWorlds implements Hello { public void morning(String name) { System.out.println(\"Good morning, \" + name); }}interface Hello { void morning(String name);} ¶3、动态代理实现 在运行期动态创建一个interface实例的方法如下： 定义一个InvocationHandler实例，它负责实现接口的方法调用； 通过Proxy.newProxyInstance() 创建interface实例，它需要3个参数： 使用的ClassLoader，通常就是接口类的ClassLoader； 需要实现的接口数组，至少需要传入一个接口进去； 用来处理接口方法调用的InvocationHandler实例。 将返回的Object强制转型为接口。 ClassLoader，它是类加载器，用来将.class字节码加载转换成class类对象的！ InvocationHandler相当于：第一个参数传入了创建的实例hello，第二个参数传入了Hello的抽象方法morning，第三个参数传入了抽象方法morning的参数BOb。 1234567891011121314151617181920212223242526272829package com.test;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class DynamicProxy { public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); if (method.getName().equals(\"morning\")) { System.out.println(\"Good morning, \" + args[0]); } return null; } }; Hello1 hello = (Hello1) Proxy.newProxyInstance( Hello1.class.getClassLoader(), // 传入ClassLoader new Class[] { Hello1.class }, // 传入要实现的接口 handler); // 传入处理调用方法的InvocationHandler hello.morning(\"Bob\"); }}interface Hello1 { void morning(String name);} 输出结果： 12public abstract void com.test.Hello1.morning(java.lang.String)Good morning, Bob ¶4、动态代理实际实现方法 动态代理实际上是JDK在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样： 其实就是JDK帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。 目前我还不太会调用。。。 123456789101112public class HelloDynamicProxy implements Hello { InvocationHandler handler; public HelloDynamicProxy(InvocationHandler handler) { this.handler = handler; } public void morning(String name) { handler.invoke( this, Hello.class.getMethod(\"morning\"), new Object[] { name }); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"反射","slug":"反射","permalink":"https://www.itnxd.cn/tags/%E5%8F%8D%E5%B0%84/"}],"author":"Mr.Niu"},{"title":"Java教程系列之异常处理","slug":"Java教程系列之异常处理","date":"2020-03-30T11:55:07.000Z","updated":"2021-02-06T14:19:01.514Z","comments":true,"path":"posts/19314.html","link":"","permalink":"https://www.itnxd.cn/posts/19314.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶一、Java的异常 ¶1、异常的来源 ¶1.1 来源 用户输入造成 随机出现的错误 网络突然断了，连接不到远程服务器； 内存耗尽，程序崩溃了； 用户点“打印”，但根本没有打印机； …… ¶1.2 处理错误的方法 方法一：约定返回错误码。 例如，处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码： 因为使用int类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。 一般不这样处理！ 1234567891011121314int code = processFile(\"C:\\\\test.txt\");if (code == 0) { // ok:} else { // error: switch (code) { case 1: // file not found: case 2: // no read permission: default: // unknown error: }} 方法二：在语言层面上提供一个异常处理机制。 Java内置了一套异常处理机制，总是使用异常来表示错误。 异常是一种class，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了！ 使用的是try...catch...语句： 123456789101112try { String s = processFile(“C:\\\\test.txt”); // ok:} catch (FileNotFoundException e) { // file not found:} catch (SecurityException e) { // no read permission:} catch (IOException e) { // io error:} catch (Exception e) { // other error:} ¶1.3 异常的继承关系 1234567891011121314151617181920212223242526 ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Throwable │ └───────────┘ ▲ ┌─────────┴─────────┐ │ │ ┌───────────┐ ┌───────────┐ │ Error │ │ Exception │ └───────────┘ └───────────┘ ▲ ▲ ┌───────┘ ┌────┴──────────┐ │ │ │┌─────────────────┐ ┌─────────────────┐┌───────────┐│OutOfMemoryError │... │RuntimeException ││IOException│...└─────────────────┘ └─────────────────┘└───────────┘ ▲ ┌───────────┴─────────────┐ │ │ ┌─────────────────────┐ ┌─────────────────────────┐ │NullPointerException │ │IllegalArgumentException │... └─────────────────────┘ └─────────────────────────┘ Throwable是异常体系的根，它继承自Object。Throwable有两个体系：Error和Exception，Error表示严重的错误，程序对此一般无能为力： OutOfMemoryError：内存耗尽 NoClassDefFoundError：无法加载某个Class StackOverflowError：栈溢出 而Exception则是运行时的错误，它可以被捕获并处理！ 某些异常是应用程序逻辑处理的一部分，应该捕获并处理！ 还有一些异常是程序逻辑编写不对造成的，应该修复程序本身！ NumberFormatException：数值类型的格式错误 FileNotFoundException：未找到文件 SocketException：读取网络失败 NullPointerException：对某个null的对象调用方法或字段 IndexOutOfBoundsException：数组索引越界 Exception分为两大类： RuntimeException以及它的子类； 非RuntimeException（包括IOException、ReflectiveOperationException等等） ¶1.4 哪些异常需要处理 Java规定： 必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。 不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。 ¶2、捕获异常（catch） 捕获异常使用try...catch语句，把可能发生异常的代码放到try {...}中，然后使用catch捕获对应的Exception及其子类！ ¶2.1 方法内部使用try catch捕获 不去捕获错误会发生编译错误： 12345Main.java:15: 错误: 未报告的异常错误UnsupportedEncodingException; 必须对其进行捕获或声明以便抛出 return s.getBytes(\"GBK\"); ^1 个错误错误: 编译失败 1234567891011121314151617181920212223package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); } public static byte[] toGBK(String s) { try { // 用指定编码转换String为byte[]: return s.getBytes(\"GBK\"); } catch (UnsupportedEncodingException e) { // 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException: System.out.println(e);// 打印错误信息 e.printStackTrace(); return s.getBytes();// 尝试使用用默认编码 } }} 来看一下String.getBytes(String)方法的定义： 在方法定义的时候，使用throws Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。 123public byte[] getBytes(String charsetName) throws UnsupportedEncodingException { ...} ¶2.2 方法定义处使用throws 在方法定义处用throws表示toGBK()方法可能会抛出UnsupportedEncodingException，就可以让toGBK()方法通过编译器检查： 告诉编译器可能会抛出错误，编译器会跳过检查该方法，但是会在main方法里面抛出异常： 12345Main.java:8: 错误: 未报告的异常错误UnsupportedEncodingException; 必须对其进行捕获或声明以便抛出 byte[] bs = toGBK(\"中文\"); ^1 个错误错误: 编译失败 123456789101112131415package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); } public static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); }} 做出修改如下： 修改一：在main方法内捕获异常： 12345678910111213141516171819package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) { try { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); }catch (UnsupportedEncodingException e) { System.out.println(e); } } public static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); }} 修改二：将main方法定义为throws Exception main()方法声明了可能抛出Exception，也就声明了可能抛出所有的Exception，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。 123456789101112131415package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) throws Exception { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); } public static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); }} ¶2.3 使用printStackTrace()打印异常栈 没有弄明白这样写为什么不会执行catch内部的语句。。。 1234567891011121314151617181920package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) { try { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); }catch (UnsupportedEncodingException e) { System.out.println(e); e.printStackTrace(); } } public static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); }} ¶二、捕获异常 ¶1、多条catch语句 可以使用多个catch语句，每个catch分别捕获对应的Exception及其子类。JVM在捕获到异常后，会从上到下匹配catch语句，匹配到某个catch后，执行catch代码块，然后不再继续匹配。 多条catch语句只执行一个！ 由于从上到下匹配，所以catch语句要从子类开始写起，防止被一个父类直接截断！ 若将下方两个catch互换，则UnsupportedEncodingException根本无法执行，会被其父类IOException给截断！ 1234567891011public static void main(String[] args) { try { process1(); process2(); process3(); } catch (UnsupportedEncodingException e) { System.out.println(\"Bad encoding\"); } catch (IOException e) { System.out.println(\"IO error\"); }} ¶2、finally语句 无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？ 当然可以在每个catch语句都写一遍，显然这样很麻烦！ 所以引入一个finally语句，有无错误都会执行！ 可见，finally是用来保证一些代码必须执行的。 如果捕获异常跳转执行 catch 里面的语句块，return 先执行。finally 里面的代码总是最后执行。 注意finally的两个特点： finally语句不是必须的，可写可不写； finally总是最后执行。 执行流程： 如果没有发生异常，就正常执行try { ... }语句块，然后执行finally。如果发生了异常，就中断执行try { ... }语句块，然后跳转执行匹配的catch语句块，最后执行finally。 12345678910111213public static void main(String[] args) { try { process1(); process2(); process3(); } catch (UnsupportedEncodingException e) { System.out.println(\"Bad encoding\"); } catch (IOException e) { System.out.println(\"IO error\"); } finally { System.out.println(\"END\"); }} try...finally语句： 某些情况下，可以没有catch，只使用try ... finally结构！ 1234567void process(String file) throws IOException { try { ... } finally { System.out.println(\"END\"); }} ¶3、异常逻辑相同则合并 处理IOException和NumberFormatException的代码是相同的，所以我们可以把它两用|合并到一起： 1234567891011public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException | NumberFormatException e) { // IOException或NumberFormatException System.out.println(\"Bad input\"); } catch (Exception e) { System.out.println(\"Unknown error\"); }} ¶三、抛出异常 目的：是为了在代码执行发生错误的时候，停止，或者进行处理，以及抛出信息帮助程序员定位出现bug的位置！ 所以，需要在可能发生异常的地方，使用 throw 语句抛出异常！ 异常抛出之后，需要对异常进行捕获！ ¶1、异常的传播 当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try ... catch被捕获为止： 12345678910111213141516171819package com.test;public class codeTest { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { process2(); } static void process2() { Integer.parseInt(null); // 会抛出NumberFormatException }} 使用printStackTrace()方法打印方法的调用栈： printStackTrace()对于调试错误非常有用，下面信息表示：NumberFormatException是在java.lang.Integer.parseInt方法中被抛出的！ 123456789java.lang.NumberFormatException: null at java.base/java.lang.Integer.parseInt(Integer.java:614) at java.base/java.lang.Integer.parseInt(Integer.java:770) at com.test.codeTest.process2(codeTest.java:17) at com.test.codeTest.process1(codeTest.java:13) at com.test.codeTest.main(codeTest.java:6)Process finished with exit code 0 打印的是异常栈，是栈，所以从下往上看： main()调用process1()； process1()调用process2()； process2()调用Integer.parseInt(String)； Integer.parseInt(String)调用Integer.parseInt(String, int)。 ¶2、抛出异常 ¶2.1 创建并抛出 创建某个Exception的实例； 用throw语句抛出。 通常会合并到一起来写： 12345678910111213void process2(String s) { if (s==null) { NullPointerException e = new NullPointerException(); throw e; }}// 合并写法：void process2(String s) { if (s==null) { throw new NullPointerException(); }} ¶2.2 异常转换 如果一个方法捕获了某个异常后，又在catch子句中抛出新的异常，就相当于把抛出的异常类型“转换”了： 后者覆盖前者： 当process2()抛出NullPointerException后，被process1()捕获，然后抛出IllegalArgumentException()。 123456789101112131415161718192021public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(); } } static void process2() { throw new NullPointerException(); }} ¶2.3 传入原始Exception来保留原始Exception 捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！ 12345678910111213141516171819202122public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { try { process2(); } catch (NullPointerException e) { // 关键点，传入原始Exception e throw new IllegalArgumentException(e); } } static void process2() { throw new NullPointerException(); }} 抛出信息的异常栈信息如下： 注意到Caused by: Xxx，说明捕获的IllegalArgumentException并不是造成问题的根源，根源在于NullPointerException，是在Main.process2()方法抛出的。 1234567java.lang.IllegalArgumentException: java.lang.NullPointerException at com.test.codeTest.process1(codeTest.java:16) at com.test.codeTest.main(codeTest.java:6)// 关键点：Caused by: java.lang.NullPointerException at com.test.codeTest.process2(codeTest.java:23) at com.test.codeTest.process1(codeTest.java:14) ¶3、finally语句是否执行 在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。 123456789101112public class Main { public static void main(String[] args) { try { Integer.parseInt(\"abc\"); } catch (Exception e) { System.out.println(\"catched\"); throw new RuntimeException(e); } finally { System.out.println(\"finally\"); } }} 1234catchedfinallyException in thread \"main\" java.lang.IllegalArgumentException at Main.main(Main.java:11) ¶4、异常屏蔽 在执行finally语句时抛出异常,catch语句的异常会被屏蔽！ finally抛出异常后，原来在catch中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception） Suppressed ：屏蔽 绝大多数情况下，在finally中不要抛出异常。因此，我们通常不需要关心Suppressed Exception。 12345678910111213public class Main { public static void main(String[] args) { try { Integer.parseInt(\"abc\"); } catch (Exception e) { System.out.println(\"catched\"); throw new RuntimeException(e); } finally { System.out.println(\"finally\"); throw new IllegalArgumentException(); } }} 抛出异常如下： 1234catchedfinallyException in thread \"main\" java.lang.IllegalArgumentException at Main.main(Main.java:11) 解决方法： 如果需要获知所有的异常，方法是先用origin变量保存原始异常，然后调用Throwable.addSuppressed()，把原始异常添加进来，最后在finally抛出： Suppressed ：屏蔽 1234567891011121314151617public class Main { public static void main(String[] args) throws Exception { Exception origin = null; try { System.out.println(Integer.parseInt(\"abc\")); } catch (Exception e) { origin = e; throw e; } finally { Exception e = new IllegalArgumentException(); if (origin != null) { e.addSuppressed(origin); } throw e; } }} 抛出异常信息如下： 1234567Exception in thread \"main\" java.lang.IllegalArgumentException at Main.main(Main.java:11) // 关键点：屏蔽异常信息：NumberFormatException Suppressed: java.lang.NumberFormatException: For input string: \"abc\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) ¶四、自定义异常 ¶1、Java标准库定义的 常用异常： 1234567891011121314151617181920212223242526272829Exception│├─ RuntimeException│ ││ ├─ NullPointerException│ ││ ├─ IndexOutOfBoundsException│ ││ ├─ SecurityException│ ││ └─ IllegalArgumentException│ ││ └─ NumberFormatException│├─ IOException│ ││ ├─ UnsupportedCharsetException│ ││ ├─ FileNotFoundException│ ││ └─ SocketException│├─ ParseException│├─ GeneralSecurityException│├─ SQLException│└─ TimeoutException ¶2、自定义异常 在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。 一个常见的做法是自定义一个BaseException作为“根异常”，然后，派生出各种业务类型的异常。 BaseException需要从一个适合的Exception派生，通常建议从RuntimeException派生： BaseException构造方法实际上都是原样照抄RuntimeException。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。 12345678910111213141516171819202122232425public class BaseException extends RuntimeException { public BaseException() { super(); } public BaseException(String message, Throwable cause) { super(message, cause); } public BaseException(String message) { super(message); } public BaseException(Throwable cause) { super(cause); }}public class UserNotFoundException extends BaseException {}public class LoginFailedException extends BaseException {}... ¶五、NullPointerException 所有的RuntimeException异常中，最常见的就是NullPointerException了！ NullPointerException即空指针异常，俗称NPE。如果一个对象为null，调用其方法或访问其字段就会产生NullPointerException，这个异常通常是由JVM抛出的！ ¶1、处理NullPointerException NullPointerException是一种代码逻辑错误，遇到NullPointerException，遵循原则是早暴露，早修复，严禁使用catch来隐藏这种编码错误： ¶1.1 变量定义时尽量不使用null 使用空字符串\"\"而不是默认的null可避免很多NullPointerException，编写业务逻辑时，用空字符串\"\"表示未填写比null安全得多。 123public class Person { private String name = \"\";} ¶1.2 返回时尽量不返回null 12345678910111213package com.test;public class codeTest { public static void main(String[] args) { String name = getName(); System.out.println(name.toString()); } public static String getName() { //return null; return \"\"; }} ¶1.3 必须返回null时使用Optional&lt;T&gt; 使用Optional.isPresent()来判断是不是null 使用Optional.of()返回T类型的值： 1234567891011121314151617181920package com.test;import java.util.Optional;public class codeTest { public static void main(String[] args) { Optional&lt;String&gt; name = getName(); if(name.isPresent()) { System.out.println(name); }else{ System.out.println(\"NULL\"); } } public static Optional&lt;String&gt; getName() { //return null; //return Optional.of(\"hhh\"); return Optional.empty(); }} ¶2、定位NullPointerException 这种增强的NullPointerException详细信息是Java 14新增的功能，但默认是关闭的，我们可以给JVM添加一个-XX:+ShowCodeDetailsInExceptionMessages参数启用它： 1java -XX:+ShowCodeDetailsInExceptionMessages Main.java 12345678910111213141516171819package com.test;public class codeTest { public static void main(String[] args) { Persons p = new Persons(); System.out.println(p.address.city.toLowerCase()); }}class Persons { String[] name = new String[2]; Address address = new Address();}class Address { String city; String street; String zipcode;} 定位信息如下：city是空的！ 12345java -XX:+ShowCodeDetailsInExceptionMessages Main.java// 信息如下：Exception in thread \"main\" java.lang.NullPointerException: Cannot invoke \"String.toLowerCase()\" because \"&lt;local1&gt;.address.city\" is null at com.test.codeTest.main(codeTest.java:6) ¶六、使用断言 实际开发中，很少使用断言。更好的方法是编写单元测试！ 断言条件预期为true，则正常执行。断言条件为false，抛出AssertionError。 后面可加参数来打印提示信息，更加便于调试！ Java断言的特点是：断言失败时会抛出AssertionError，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。 对可恢复的错误不能使用断言，而应该抛出异常； 1assert x &gt;= 0 : \"x must &gt;= 0\"; 1234567public class Main { public static void main(String[] args) { int x = -1; assert x &gt; 0; System.out.println(x); }} JVM默认关闭断言指令，即遇到assert语句就自动忽略了，不执行。 要执行assert语句，必须给Java虚拟机传递-enableassertions（可简写为-ea）参数启用断言。所以，上述程序必须在命令行下运行才有效果： 123$ java -ea Main.javaException in thread \"main\" java.lang.AssertionError at Main.main(Main.java:5) ¶七、使用JDK Loging 编写程序的过程中，发现程序运行结果与预期不符，使用System.out.println()打印变量信息！异常麻烦！ 所以使用Loging，日志就是Logging，它的目的是为了取代System.out.println()。 使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。 ¶几点好处： 可以设置输出样式，避免自己每次都写\"ERROR: \" + var； 可以设置输出级别，禁止某些级别输出。例如，只输出错误日志； 可以被重定向到文件，这样可以在程序运行结束后查看日志； 可以按包名控制日志级别，只输出某些包打的日志； 可以…… 12345678910111213package com.test;import java.util.logging.Logger;public class codeTest { public static void main(String[] args) { Logger logger = Logger.getGlobal(); logger.info(\"start process...\"); logger.warning(\"memory is running out...\"); logger.fine(\"ignored.\"); logger.severe(\"process will be terminated...\"); }} 输出信息如下： 1234563月 31, 2020 6:12:33 下午 com.test.codeTest main信息: start process...3月 31, 2020 6:12:33 下午 com.test.codeTest main警告: memory is running out...3月 31, 2020 6:12:33 下午 com.test.codeTest main严重: process will be terminated... ¶Logger日志的七个级别： 默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。 SEVERE WARNING INFO CONFIG FINE FINER FINEST Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行main()方法，就无法修改配置； 配置不太方便，需要在JVM启动时传递参数-Djava.util.logging.config.file=。 因此，Java标准库内置的Logging使用并不是非常广泛。 一个例子： 1234567891011121314151617181920package com.test;import com.sun.tools.javac.Main;import java.io.UnsupportedEncodingException;import java.util.logging.Logger;public class codeTest { public static void main(String[] args) { Logger logger = Logger.getLogger(Main.class.getName()); logger.info(\"Start process...\"); try { \"\".getBytes(\"invalidCharsetName\"); } catch (UnsupportedEncodingException e) { // TODO: 使用logger.severe()打印异常 logger.severe(e.toString()); } logger.info(\"Process end.\"); }} 日志如下： 1234567893月 31, 2020 6:18:43 下午 com.test.codeTest main信息: Start process...3月 31, 2020 6:18:43 下午 com.test.codeTest main严重: java.io.UnsupportedEncodingException: invalidCharsetName3月 31, 2020 6:18:43 下午 com.test.codeTest main信息: Process end.Process finished with exit code 0 ¶八、使用Commons Logging 和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。 Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。 Commons Logging是一个第三方提供的库，所以，必须先把它下载下来。下载后，解压，找到commons-logging-1.2.jar这个文件，再把Java源码Main.java放到一个目录下 ¶1、idea 导入方式： 1.打开 File -&gt; Project Structure 2.单击 Modules -&gt; Dependencies -&gt; “+” -&gt; “Jars or directories” 3.选择硬盘上的jar包 4.Apply -&gt; OK 然后将鼠标放到导入的包上，点击提示信息的add classspath…即可成功导入！ 12345678910111213package com.test;import com.sun.tools.javac.Main;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class codeTest { public static void main(String[] args) { Log log = LogFactory.getLog(Main.class); log.info(\"start...\"); log.warn(\"end.\"); }} 信息如下： 12343月 31, 2020 6:51:39 下午 com.sun.tools.javac.Main main信息: start...3月 31, 2020 6:51:39 下午 com.sun.tools.javac.Main main警告: end. ¶2、Commons Logging定义了6个日志级别： FATAL ERROR WARNING INFO DEBUG TRACE 默认级别是INFO。 ¶3、静态方法中引用log定义静态类型变量： 12345678/ 在静态方法中引用Log:public class Main { static final Log log = LogFactory.getLog(Main.class); static void foo() { log.info(\"foo\"); }} ¶4、实例方法中引用log定义实例类型变量： 注意到实例变量log的获取方式是LogFactory.getLog(getClass())，虽然也可以用LogFactory.getLog(Person.class)，但是前一种方式有个非常大的好处，就是子类可以直接使用该log实例： 由于Java类的动态特性，子类获取的log字段实际上相当于LogFactory.getLog(Student.class)，但却是从父类继承而来，并且无需改动代码： 12345678910111213141516// 在实例方法中引用Log:public class Person { protected final Log log = LogFactory.getLog(getClass()); void foo() { log.info(\"foo\"); }}// 在子类中使用父类实例化的log:public class Student extends Person { void bar() { log.info(\"bar\"); }} ¶5、可抛出异常： Commons Logging的日志方法，例如info()，除了标准的info(String)外，还提供了一个非常有用的重载方法：info(String, Throwable)，这使得记录异常更加简单： 本例子使用了： 实例方法引用log定义实例变量 使用LogFactory.getLog(getClass())来是子类直接继承log 使用log的两个参数，第二个参数来抛出异常： 12345678910111213141516171819202122232425262728293031package com.test;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class codeTest { public static void main(String[] args) { var s = new Persons(); s.foo(); var t = new Tests(); t.bar(); }}class Persons{ protected final Log log = LogFactory.getLog(getClass()); void foo(){ try { Integer n = Integer.parseInt(\"abs\"); }catch (NumberFormatException e){ log.error(\"foo\", e); } }}class Tests extends Persons{ void bar(){ log.info(\"bar\"); }} 结果如下： 12345678910113月 31, 2020 7:09:22 下午 com.test.Persons foo严重: foojava.lang.NumberFormatException: For input string: \"abs\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) at com.test.Persons.foo(codeTest.java:20) at com.test.codeTest.main(codeTest.java:9)3月 31, 2020 7:09:22 下午 com.test.Tests bar信息: bar ¶九、使用Log4j 前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。 Log4j是一种非常流行的日志框架，最新版本是2.x。 在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入classpath，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。 ¶1、Log4j架构： Log4j是一个组件化设计的日志系统，它的架构大致如下： 12345678910111213log.info(\"User signed in.\"); │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ Console │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ File │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ └──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ Socket │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ 当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如： console：输出到屏幕； file：输出到文件； socket：通过网络输出到远程计算机； jdbc：输出到数据库 在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出ERROR级别的日志。 最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。 ¶2、配置XML文件 上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。 将下面保存到文件并命名为：log4j2.xml放到src目录下即可： 虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是INFO级别的日志，会自动输出到屏幕，而ERROR级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Configuration&gt; &lt;Properties&gt; &lt;!-- 定义日志格式 --&gt; &lt;Property name=\"log.pattern\"&gt;%d{MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36}%n%msg%n%n&lt;/Property&gt; &lt;!-- 定义文件名变量 --&gt; &lt;Property name=\"file.err.filename\"&gt;log/err.log&lt;/Property&gt; &lt;Property name=\"file.err.pattern\"&gt;log/err.%i.log.gz&lt;/Property&gt; &lt;/Properties&gt; &lt;!-- 定义Appender，即目的地 --&gt; &lt;Appenders&gt; &lt;!-- 定义输出到屏幕 --&gt; &lt;Console name=\"console\" target=\"SYSTEM_OUT\"&gt; &lt;!-- 日志格式引用上面定义的log.pattern --&gt; &lt;PatternLayout pattern=\"${log.pattern}\" /&gt; &lt;/Console&gt; &lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt; &lt;RollingFile name=\"err\" bufferedIO=\"true\" fileName=\"${file.err.filename}\" filePattern=\"${file.err.pattern}\"&gt; &lt;PatternLayout pattern=\"${log.pattern}\" /&gt; &lt;Policies&gt; &lt;!-- 根据文件大小自动切割日志 --&gt; &lt;SizeBasedTriggeringPolicy size=\"1 MB\" /&gt; &lt;/Policies&gt; &lt;!-- 保留最近10份 --&gt; &lt;DefaultRolloverStrategy max=\"10\" /&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=\"info\"&gt; &lt;!-- 对info级别的日志，输出到console --&gt; &lt;AppenderRef ref=\"console\" level=\"info\" /&gt; &lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt; &lt;AppenderRef ref=\"err\" level=\"error\" /&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是INFO级别的日志，会自动输出到屏幕，而ERROR级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。 ¶3、下载并配置Log4j 有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从这里下载Log4j，解压后，把以下3个jar包放到classpath中： log4j-api-2.x.jar log4j-core-2.x.jar log4j-jcl-2.x.jar 因为Commons Logging会自动发现并使用Log4j，所以，把上一节下载的commons-logging-1.2.jar也放到classpath中。 要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出，类似： 第八节第五点的输出信息变为如下： 123456789101103-31 19:35:03.119 [main] ERROR com.test.Personsfoojava.lang.NumberFormatException: For input string: \"abs\" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) ~[?:?] at java.lang.Integer.parseInt(Integer.java:652) ~[?:?] at java.lang.Integer.parseInt(Integer.java:770) ~[?:?] at com.test.Persons.foo(codeTest.java:20) [java-base/:?] at com.test.codeTest.main(codeTest.java:9) [java-base/:?]03-31 19:35:03.146 [main] INFO com.test.Testsbar ¶4、小结 通过Commons Logging实现日志，不需要修改代码即可使用Log4j； 使用Log4j只需要把log4j2.xml和相关jar放入classpath； 如果要更换Log4j，只需要移除log4j2.xml和相关jar； 只有扩展Log4j时，才需要引用Log4j的接口（例如，将日志加密写入数据库的功能，需要自己开发）。 ¶十、使用SLF4J和Logback 前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。 有的童鞋可能还听说过SLF4J和Logback。这两个东东看上去也像日志，它们又是啥？ 其实SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。 为什么有了Commons Logging和Log4j，又会蹦出来SLF4J和Logback？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。 因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。 来看看SLF4J对Commons Logging的接口有何改进： SLF4J的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。 12345678910int score = 99;p.setScore(score);// Commons Logging 的拼接字符串：log.info(\"Set score \" + score + \" for Person \" + p.getName() + \" ok.\");// SLF4Jint score = 99;p.setScore(score);// 改进后的拼接字符串：logger.info(\"Set score {} for Person {} ok.\", score, p.getName()); 如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样！ ¶配置相关： 使用SLF4J和Logback和前面讲到的使用Commons Logging加Log4j是类似的，先分别下载SLF4J和Logback，然后把以下jar包放到classpath下： slf4j-api-1.7.x.jar logback-classic-1.2.x.jar logback-core-1.2.x.jar 在src目录下新建一个logback.xml文件，写入下面内容： 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;charset&gt;utf-8&lt;/charset&gt; &lt;/encoder&gt; &lt;file&gt;log/output.log&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.FixedWindowRollingPolicy\"&gt; &lt;fileNamePattern&gt;log/output.log.%i&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;1MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt;&lt;/configuration&gt; ¶代码修改如下： 123456789101112131415161718192021222324252627282930313233343536package com.test;import org.slf4j.LoggerFactory;import org.slf4j.Logger;public class codeTest { public static void main(String[] args) { var s = new Persons(); s.foo(); var t = new Tests(); t.bar(); }}class Persons{ //protected final Logger log = LoggerFactory.getLogger(getClass()); final Logger logger = LoggerFactory.getLogger(getClass()); void foo(){ try { Integer n = Integer.parseInt(\"abs\"); }catch (NumberFormatException e){ logger.error(\"foo\", e); } }}class Tests extends Persons{ String name = \"Mr.Niu\"; int age = 100; void bar(){ logger.info(\"bar\"); // 拼接字符串新方法： logger.info(\"name:{}, age:{}\",name, age); }} 输出信息如下： 12345678920:14:19.679 [main] ERROR com.test.Persons - foojava.lang.NumberFormatException: For input string: \"abs\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) at com.test.Persons.foo(codeTest.java:21) at com.test.codeTest.main(codeTest.java:9)20:14:19.693 [main] INFO com.test.Tests - bar20:14:19.697 [main] INFO com.test.Tests - name:Mr.Niu, age:100 ¶小结 SLF4J和Logback可以取代Commons Logging和Log4j； 始终使用SLF4J的接口写入日志，使用Logback只需要配置，不需要修改代码。 异常处理已完结，敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://www.itnxd.cn/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}],"author":"Mr.Niu"},{"title":"Java教程系列之Java核心类","slug":"Java教程系列之Java核心类","date":"2020-03-27T09:56:43.000Z","updated":"2021-02-06T14:18:28.333Z","comments":true,"path":"posts/22799.html","link":"","permalink":"https://www.itnxd.cn/posts/22799.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶一、字符串和编码 ¶1、字符串（String） 在Java中，String是一个引用类型，它本身也是一个class。但是，Java编译器对String有特殊处理，即可以直接用\"...\"来表示一个字符串！ 实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的！ 因为String太常用了，所以Java提供了\"...\"这种字符串字面量表示方法。 Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。 12String s1 = \"hello!\";String s2 = new String(new char[] {'H', 'e', 'l', 'l', 'o', '!'}); 下面这个输出结果不一样，因为不可变性，所以其实就是指向变了！原来的字符串仍然在内存中！ 12345678public class Main { public static void main(String[] args) { String s = \"Hello\"; System.out.println(s); //Hello s = s.toUpperCase(); //HELLO System.out.println(s); }} ¶1.1 字符串比较（equal） 必须使用equals()方法而不能用==！ equal()方法比较的是实实在在指向的内容！ ==则比较的指向的对象或实例是否相同！ 一般情况下我们只需要比较内容，所以一定要射用equal方法！ 从表面上看，两个字符串用==和equals()比较都为true，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然s1和s2的引用就是相同的。 1234567891011121314public class Main { public static void main(String[] args) { String s1 = \"hello\"; String s2 = \"hello\"; System.out.println(s1 == s2);//true System.out.println(s1.equals(s2));//true // 上面纯属巧合！ String s3 = \"hello\"; String s4 = \"HELLO\".toLowerCase(); System.out.println(s3 == s4);//false System.out.println(s3.equals(s4));//true }} 要忽略大小写比较，使用equalsIgnoreCase()方法。 12345678910package com.test;public class codeTest { public static void main(String[] args) { String s = \"hello\"; String t = s.toUpperCase(); System.out.println(s.equals(t));//false System.out.println(s.equalsIgnoreCase(t));//true }} ¶1.2 字符串搜索 contains()：参数是CharSequence而不是String，因为CharSequence是String的父类。查找子串，返回bool型！ indexof()：返回查找第一次出现子串的下标位置！ lastIndexOf()：返回最后一次出现子串的下标位置！ startsWith()：返回是否以子串开头的bool型值！ endwith()：返回是否以子串结尾的bool型值！ substring()：截取子串！ substring(a)：返回下标a开始到最后！ substring(a, b)：返回下标a开始到b为止，左闭右开！ 1234567891011// 是否包含子串:\"Hello\".contains(\"ll\"); // true\"Hello\".indexOf(\"l\"); // 2\"Hello\".lastIndexOf(\"l\"); // 3\"Hello\".startsWith(\"He\"); // true\"Hello\".endsWith(\"lo\"); // true\"Hello\".substring(2); // \"llo\"\"Hello\".substring(2, 4); \"ll\" ¶1.3 取出首尾空白字符 trim()：移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n!并没有改变字符串的内容，而是返回了一个新字符串。 strip()：移除字符串首尾空白字符。它和trim()不同的是，类似中文的空格字符\\u3000也会被移除！ stripLeading()：移除首部！ stripTrailing()：移除尾部！ isEmpty()：潘福安字符串是否为空！ isBlank()：判断字符串是否为空白字符（空格）！ 1234567891011\" \\tHello\\r\\n \".trim(); // \"Hello\"\"\\u3000Hello\\u3000\".strip(); // \"Hello\"\" Hello \".stripLeading(); // \"Hello \"\" Hello \".stripTrailing(); // \" Hello\"\"\".isEmpty(); // true，因为字符串长度为0\" \".isEmpty(); // false，因为字符串长度不为0\" \\n\".isBlank(); // true，因为只包含空白字符\" Hello \".isBlank(); // false，因为包含非空白字符 ¶1.4 子串替换（replace） 使用replace()方法： 123String s = \"hello\";s.replace('l', 'w'); // \"hewwo\"，所有字符'l'被替换为'w's.replace(\"ll\", \"~~\"); // \"he~~o\"，所有子串\"ll\"被替换为\"~~\" 使用正则表达式： 参考我之前在JavaScript教程的RegExp：点击这里! 当然语法不太相同，后面的java教程会讲到Re！ 12String s = \"A,,B;C ,D\";String tt = s.replaceAll(\"[,;\\\\s]+\", \",\"); // \"A,B,C,D\" ¶1.5 字符串分割 split()：参数为正则表达式！ 12String s = \"A,B,C,D\";String[] ss = s.split(\",\"); // {\"A\", \"B\", \"C\", \"D\"} ¶1.6 字符串拼接 join()：用指定的字符串连接字符串数组! 12String[] arr = {\"A\", \"B\", \"C\"};String s = String.join(\"***\", arr); // \"A***B***C\" ¶1.7 类型转换 其他类型转换为字符串： valueof()：把任意基本类型或引用类型转换为字符串，这是一个重载方法，编译器会根据参数自动选择合适的方法！ 1234String.valueOf(123); // \"123\"String.valueOf(45.67); // \"45.67\"String.valueOf(true); // \"true\"String.valueOf(new Object()); // 输出java.lang.Object@636be97c 字符串转换为其他类型： Integer.parseInt()：int转换为String！ Boolean.parseBoolean()：boolean转换为String！ 12345int n1 = Integer.parseInt(\"123\"); // 123int n2 = Integer.parseInt(\"ff\", 16); // 按十六进制转换，255boolean b1 = Boolean.parseBoolean(\"true\"); // trueboolean b2 = Boolean.parseBoolean(\"FALSE\"); // false Integer的getInteger(String)方法，它不是将字符串转换为int，而是把该字符串对应的系统变量转换为Integer： 1System.out.println(\"java版本：\" + Integer.getInteger(\"java.version\"));// java版本：14 ¶1.8 String与char[]互转 String转char[]：使用toCharArray()方法！ char[]转String：使用new String()方法！ 12char[] cs = \"Hello\".toCharArray(); // String -&gt; char[]String s = new String(cs); // char[] -&gt; String 通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份，所以，修改外部的char[]数组不会影响String实例内部的char[]数组，因为这是两个不同的数组。 new String()时：传入的是一个复制！ 123456789public class Main { public static void main(String[] args) { char[] cs = \"Hello\".toCharArray(); String s = new String(cs); System.out.println(s); cs[0] = 'X'; System.out.println(s); }} 当向类中传入引用时，外部改变会影响类的改变！ 由于Score内部直接引用了外部传入的int[]数组，这会造成外部代码对int[]数组的修改，影响到Score类的字段。如果外部代码不可信，这就会造成安全隐患。 可以使用数组的clone()方法， 123456789101112131415161718192021222324import java.util.Arrays;public class Main { public static void main(String[] args) { int[] scores = new int[] { 88, 77, 51, 66 }; Score s = new Score(scores); s.printScores();//[88, 77, 51, 66] scores[2] = 99; s.printScores();//[88, 77, 99, 66]修改后[88, 77, 51, 66] }}class Score { private int[] scores; public Score(int[] scores) { this.scores = scores; // 修改为使用克隆方法！ this.scores = scores.clone(); } public void printScores() { System.out.println(Arrays.toString(scores)); }} ¶2、字符编码 可参考廖雪峰的字符编码教程：点击这里！ 始终牢记：Java的String和char在内存中总是以Unicode编码表示。 ¶2.1 ASCII编码 在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从0到127，最高位始终为0，称为ASCII编码。例如，字符'A'的编码是0x41，字符'1'的编码是0x31。 ¶2.2 GB2312和GBK编码 如果要把汉字也纳入计算机编码，很显然一个字节是不够的。GB2312标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为1，以便和ASCII编码区分开。例如，汉字'中'的GB2312编码是0xd6d0。 1、收录不同：GB2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；GBK共收入21886个汉字和图形符号。 2、表示不同：GB2312对任意一个图形字符都采用两个字节表示，并对所收汉字进行了“分区”处理，每区含有94个汉字／符号，分别对应第一字节和第二字节。GBK采用双字节表示，总体编码范围为8140-FEFE之间，首字节在81-FE之间，尾字节在40-FE之间。 3、处理功能不同：对于人名、古汉语等方面出现的罕用字，GB2312不能处理，这导致了后来GBK 及GB18030 汉字字符集的出现。 GBK: 汉字国标扩展码,基本上采用了原来GB2312-80所有的汉字及码位，并涵盖了原Unicode中所有的汉字20902，总共收录了883个符号， 21003个汉字及提供了1894个造字码位。 Microsoft简体版中文Windows 95就是以GBK为内码，又由于GBK同时也涵盖了Unicode所有CJK汉字，所以也可以和Unicode做一一对应。 GB码，全称是GB2312-80《信息交换用汉字编码字符集 基本集》，1980年发布，是中文信息处理的国家标准，在大陆及海外使用简体中文的地区（如新加坡等）是强制使用的唯一中文编码。P-Windows3.2和苹果OS就是以GB2312为基本汉字编码， Windows 95/98则以GBK为基本汉字编码、但兼容支持GB2312。GB码共收录6763个简体汉字、682个符号，其中汉字部分：一级字3755，以拼音排序，二级字3008，以偏旁排序。该标准的制定和应用为规范、推动中文信息化进程起了很大作用。 GBK编码是中国大陆制订的、等同于UCS的新的中文编码扩展国家标准。GBK工作小组于1995年10月，同年12月完成GBK规范。该编码标准兼容GB2312，共收录汉字21003个、符号883个，并提供1894个造字码位，简、繁体字融于一库。 ¶2.3 Unicode编码 为了统一全球所有语言的编码，全球统一码联盟发布了Unicode编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。 Unicode编码需要两个或者更多字节表示！ ¶2.4 UTF-8编码 因为英文字符的Unicode编码高字节总是00，包含大量英文的文本会浪费空间，所以，出现了UTF-8编码，它是一种变长编码，用来把固定长度的Unicode编码变成1～4字节的变长编码。通过UTF-8编码，英文字符'A'的UTF-8编码变为0x41，正好和ASCII码一致，而中文'中'的UTF-8编码为3字节0xe4b8ad。 UTF-8编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为UTF-8编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。 在Java中，char类型实际上就是两个字节的Unicode编码。如果我们要手动把字符串转换成其他编码，可以这样做： getBytes(\"UTF-8\")：这个编译通不过。。 使用getBytes(StandardCharsets.UTF_8)才可以！ 了解一下就好！ 转换编码后，就不再是char类型，而是byte类型表示的数组。 1234byte[] b1 = \"Hello\".getBytes(); // 按系统默认编码转换，不推荐byte[] b2 = \"Hello\".getBytes(\"UTF-8\"); // 按UTF-8编码转换byte[] b2 = \"Hello\".getBytes(\"GBK\"); // 按GBK编码转换byte[] b3 = \"Hello\".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换 将byte[]转换为String，可以这样做： 123byte[] b = ...String s1 = new String(b, \"GBK\"); // 按GBK转换String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换 ¶3、String存储方式 早期JDK版本的String总是以char[]存储： 12345public final class String { private final char[] value; private final int offset; private final int count;} 较新的JDK版本的String则以byte[]存储： 如果String仅包含ASCII字符，则每个byte存储一个字符，否则，每两个byte存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的String通常仅包含ASCII字符： 对于使用者来说，String内部的优化不影响任何已有代码，因为它的public方法签名是不变的。 123public final class String { private final byte[] value; private final byte coder; // 0 = LATIN1, 1 = UTF16 ¶二、StringBuilder 使用String拼接字符串时，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC(垃圾回收)效率。 为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象： 其他许多方法去编译器就可以看到！ 你可能还听说过StringBuffer，这是Java早期的一个StringBuilder的线程安全版本，它通过同步来保证多个线程操作StringBuffer也是安全的，但是同步会带来执行速度的下降。 StringBuilder和StringBuffer接口完全相同，现在完全没有必要使用StringBuffer。 也就是说StringBuffer已经是一个淘汰品了，不需要使用了！ 最大作用：高效拼接字符串！ 可以进行链式操作： 进行链式操作的关键是，定义的append()方法会返回this，这样，就可以不断调用自身的其他方法！ 参数capacity为初始容量，不够时，自动扩大为当前的二倍！ 也可以不写该参数！ 12345678910public class Main { public static void main(String[] args) { var sb = new StringBuilder(1024); sb.append(\"Mr \") .append(\"Bob\") .append(\"!\") .insert(0, \"Hello, \"); System.out.println(sb.toString()); }} 来设计一个支持链式操作的类！关键当然是可以返回this即可！ 1234567891011121314151617181920212223242526272829public class Main { public static void main(String[] args) { Adder adder = new Adder(); adder.add(3) .add(5) .inc() .add(10); System.out.println(adder.value()); }}class Adder { private int sum = 0; public Adder add(int n) { sum += n; return this; } public Adder inc() { sum ++; return this; } public int value() { return sum; }} 对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作。 ¶三、StringJoiner 最大作用：可以用分隔符拼接字符串，也可以指定开始和结束！ StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的！！ 123456789101112131415import java.util.StringJoiner;public class Main { public static void main(String[] args) { String[] names = {\"Bob\", \"Alice\", \"Grace\"}; // 按逗号分隔 var sj = new StringJoiner(\", \"); // 指定开头和结尾 var sj = new StringJoiner(\", \", \"Hello \", \"!\"); for (String name : names) { sj.add(name); } System.out.println(sj.toString()); }} 不需要开头结尾时，可以使用更方便的String.join() 12String[] names = {\"Bob\", \"Alice\", \"Grace\"};var s = String.join(\", \", names); ¶四、包装类型 Java的两种数据类型： 基本类型：byte，short，int，long，boolean，float，double，char 引用类型：所有class和interface类型 引用类型可以赋值为null，表示空，但基本类型不能赋值为null： 12String s = null;int n = null; // compile error! 将基本类型转换为引用类型就是包装类型！ ¶1、int转Integer 12345678Integer n = null;Integer n2 = new Integer(99);Integer n3 = 98;Integer n4 = Integer.valueOf(99);// 通过静态方法valueOf(String)创建Integer实例:Integer n5 = Integer.valueOf(\"100\");int n6 = n2.intValue();int n7 = n3; Java对应的基本类型的包装类型： 基本类型 对应的引用类型 boolean java.lang.Boolean byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double char java.lang.Character ¶2、Auto Boxing 由于可以自动互转，所以可以直接简化的写，编译器自动完成转换加上相应语句！ 这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。 注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。 装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException： 123456Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue()// 这样拆箱会报错的：Integer n = null;int i = n; ¶3、不变类（final class） 所有的包装类型都是不变类，如Integer的源码： 两个Integer比较大小，不能使用==, 一定要用equal()方法! ，==比较，较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);，为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。 1234567891011121314151617public final class Integer { private final int value;}// 比较：public class Main { public static void main(String[] args) { Integer x = 127; Integer y = 127; Integer m = 99999; Integer n = 99999; System.out.println(\"x == y: \" + (x==y)); // true System.out.println(\"m == n: \" + (m==n)); // false System.out.println(\"x.equals(y): \" + x.equals(y)); // true System.out.println(\"m.equals(n): \" + m.equals(n)); // true }} 因为Integer.valueOf()可能始终返回同一个Integer实例，因此，在我们自己创建Integer的时候，以下两种方法： 方法1：Integer n = new Integer(100); 方法2：Integer n = Integer.valueOf(100); 方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。 我们把能创建“新”对象的静态方法称为静态工厂方法。Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。 创建新对象时，优先选用静态工厂方法而不是new操作符。 如果我们考察Byte.valueOf()方法的源码，可以看到，标准库返回的Byte实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例！ ¶4、Integer的进制转换 使用Integer.parseInt()方法或者是toString()....等等！ 输出结果都是String类型！ 12345678910111213public class Main { public static void main(String[] args) { // 将字符串解析成一个整数： int x1 = Integer.parseInt(\"100\"); // 100 int x2 = Integer.parseInt(\"100\", 16); // 256,因为按16进制解析 System.out.println(Integer.toString(100)); // \"100\",表示为10进制 System.out.println(Integer.toString(100, 36)); // \"2s\",表示为36进制 System.out.println(Integer.toHexString(100)); // \"64\",表示为16进制 System.out.println(Integer.toOctalString(100)); // \"144\",表示为8进制 System.out.println(Integer.toBinaryString(100)); // \"1100100\",表示为2进制 }} ¶5、静态变量 一些静态变量： 123456789// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:Boolean t = Boolean.TRUE;Boolean f = Boolean.FALSE;// int可表示的最大/最小值:int max = Integer.MAX_VALUE; // 2147483647int min = Integer.MIN_VALUE; // -2147483648// long类型占用的bit和byte数量:int sizeOfLong = Long.SIZE; // 64 (bits)int bytesOfLong = Long.BYTES; // 8 (bytes) 所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型： 12345678// 向上转型为Number:Number num = new Integer(999);// 获取byte, int, long, float, double:byte b = num.byteValue();int n = num.intValue();long ln = num.longValue();float f = num.floatValue();double d = num.doubleValue(); ¶5、无符号处理 在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。 因为byte的-1的二进制表示是11111111，以无符号整型转换后的int就是255。 类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。 12345678910111213public class Main { public static void main(String[] args) { byte x = -1; byte y = 1; short r = -1; int t = -1; System.out.println(Byte.toUnsignedInt(x)); // 255 System.out.println(Byte.toUnsignedInt(y)); // 127 System.out.println(Short.toUnsignedInt(r));//65535 System.out.println(Integer.toUnsignedLong(t));//4294967295 }} ¶无、JavaBean 在Java中，有很多class的定义都符合这样的规范： 若干private实例字段； 通过public方法来读写实例字段。 ¶1、JavaBean规范 如果读写方法符合以下这种命名规范： 12345678910// 读方法:public Type getXyz()// 写方法:public void setXyz(Type value)// boolean特殊：读方法一般命名为isXyz()：// 读方法:public boolean isChild()// 写方法:public void setChild(boolean value) 那么这种class被称为JavaBean： 上面的字段是xyz，那么读写方法名分别以get和set开头，并且后接大写字母开头的字段名Xyz，因此两个读写方法名分别是getXyz()和setXyz() 我们通常把一组对应的读方法（getter）和写方法（setter）称为属性（property）。例如，name属性： 对应的读方法是String getName() 对应的写方法是setName(String) 只有getter的属性称为只读属性（read-only），例如，定义一个age只读属性： 对应的读方法是int getAge() 无对应的写方法setAge(int) 类似的，只有setter的属性称为只写属性（write-only）。 很明显，只读属性很常见，只写属性不常见。 getter和setter就实现了一种数据封装的方法！ 1234567891011121314public class Person { private String name; private int age; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public int getAge() { return this.age; } public void setAge(int age) { this.age = age; } public boolean isChild() { return age &lt;= 6; }} ¶2、JavaBean作用 JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。 通过IDE，可以快速生成getter和setter！ ¶3、枚举JavaBean属性 了解即可！ 使用Introspector.getBeanInfo()可以获取属性列表。 123456789101112131415161718192021222324252627282930313233343536373839package com.test;import java.beans.BeanInfo;import java.beans.IntrospectionException;import java.beans.Introspector;import java.beans.PropertyDescriptor;public class codeTest { public static void main(String[] args) throws IntrospectionException { BeanInfo info = Introspector.getBeanInfo(Person.class); for (PropertyDescriptor pd : info.getPropertyDescriptors()) { System.out.println(pd.getName()); System.out.println(\" \" + pd.getReadMethod()); System.out.println(\" \" + pd.getWriteMethod()); } }}class Persons { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 输出结果： 123456789101112age public int com.test.Person.getAge() public void com.test.Person.setAge(int)birth public int com.test.Person.getBirth() public void com.test.Person.setBirth(int)class public final native java.lang.Class java.lang.Object.getClass() nullname public java.lang.String com.test.Person.getName() public void com.test.Person.setName(java.lang.String) ¶六、枚举类（enum） 为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类！ 注意到定义枚举类是通过关键字enum实现的，我们只需依次列出枚举的常量名。 和int定义的常量相比，使用enum定义枚举有如下好处： 首先，enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误。 其次，不可能引用到非枚举的值，因为无法通过编译。 最后，不同类型的枚举不能互相比较或者赋值，因为类型不符！ 使用enum定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用equals()方法，如果使用==比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用equals()方法，但enum类型可以例外。 因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较： 12345678910111213141516171819public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day == Weekday.SAT || day == Weekday.SUN) { System.out.println(\"Work at home!\"); } else { System.out.println(\"Work at office!\"); } // 这样是编译不会通过的： int day = 1; if (day == Weekday.SUN) { // Compile error: bad operand types for binary operator '==' } }}enum Weekday { SUN, MON, TUE, WED, THU, FRI, SAT;} ¶1、enum类型 通过enum定义的枚举类，和其他的class有什么区别？ 答案是没有任何区别。enum定义的类型就是class，只不过它有以下几个特点： 定义的enum类型总是继承自java.lang.Enum，且无法被继承； 只能定义出enum的实例，而无法通过new操作符创建enum的实例； 定义的每个实例都是引用类型的唯一实例； 可以将enum类型用于switch语句。 12345678910111213public enum Color { RED, GREEN, BLUE;}// 编译后大概长这样：public final class Color extends Enum { // 继承自Enum，标记为final class // 每个实例均为全局唯一: public static final Color RED = new Color(); public static final Color GREEN = new Color(); public static final Color BLUE = new Color(); // private构造方法，确保外部无法调用new操作符: private Color() {}} 编译后的enum类和普通class并没有任何区别。但是我们自己无法按定义普通class那样来定义enum，必须使用enum关键字，这是Java语法规定的。 因为enum是一个class，每个枚举的值都是class实例！ ¶2、常用方法 name()：返回常量名！ ordinal()：返回定义常量的顺序（从0开始）！ 12String s = Weekday.SUN.name(); // \"SUN\"int n = Weekday.MON.ordinal(); // 1 注意：当枚举类Weekday内部的顺序发生变化时，通过ordinal()方法获取到的值也会相应改变！ 想要不受影响，新增的变量值一定要放到最后！ 解决方法： 要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段： 默认情况下，对枚举常量调用toString()会返回和name()一样的字符串。但是，toString()可以被覆写，而name()则不行。我们可以给Weekday添加toString()方法： 覆写toString()的目的是在输出时更有可读性。 注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！ 默认调用day的toString()方法！ toString()覆写后则调用覆写后的方法！ 1234567891011121314151617181920212223242526272829public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day.dayValue == 6 || day.dayValue == 0) { // 默认调用day的toString()方法： System.out.println(\"Today is \" + day + \". Work at home!\"); } else { System.out.println(\"Today is \" + day + \". Work at office!\"); } }}enum Weekday { MON(1, \"星期一\"), TUE(2, \"星期二\"), WED(3, \"星期三\"), THU(4, \"星期四\"), FRI(5, \"星期五\"), SAT(6, \"星期六\"), SUN(0, \"星期日\"); public final int dayValue; private final String chinese; private Weekday(int dayValue, String chinese) { this.dayValue = dayValue; this.chinese = chinese; } @Override public String toString() { return this.chinese; }} ¶3、使用switch语句 12345678910111213141516171819202122public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; switch(day) { case MON: case TUE: case WED: case THU: case FRI: System.out.println(\"Today is \" + day + \". Work at office!\"); break; case SAT: case SUN: System.out.println(\"Today is \" + day + \". Work at home!\"); break; } }}enum Weekday { MON, TUE, WED, THU, FRI, SAT, SUN;} ¶七、记录类（record） 使用String、Integer等类型的时候，这些类型都是不变类，一个不变类具有以下特点： 定义class时使用final，无法派生子类； 每个字段使用final，保证创建实例后无法修改任何字段。 为了保证不变类的比较，还需要正确覆写equals()和hashCode()方法，这样才能在集合类中正常使用。 从Java 14开始，引入了新的Record类。我们定义Record类时，使用关键字record， ¶1、record类 除了用final修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写toString()、equals()和hashCode()方法。 换句话说，使用record关键字，可以一行写出一个不变类。 和enum类似，我们自己不能直接从Record派生，只能通过record关键字由编译器实现继承。 12345678910public class Main { public static void main(String[] args) { Point p = new Point(123, 456); System.out.println(p.x()); System.out.println(p.y()); System.out.println(p); }}public record Point(int x, int y) {} 编译时编译器自动完成所需要的代码以及需要覆写的代码： 12345678910111213141516171819202122232425262728public final class Point extends Record { private final int x; private final int y; public Point(int x, int y) { this.x = x; this.y = y; } public int x() { return this.x; } public int y() { return this.y; } public String toString() { return String.format(\"Point[x=%s, y=%s]\", x, y); } public boolean equals(Object o) { ... } public int hashCode() { ... }} ¶2、record的构造方法 编译器默认按照record声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？ 假设Point类的x、y不允许负数，我们就得给Point的构造方法加上检查逻辑： 123456789101112131415161718192021public record Point(int x, int y) { public Point { if (x &lt; 0 || y &lt; 0) { throw new IllegalArgumentException(); } }}// 编译后的代码长这样：public final class Point extends Record { public Point(int x, int y) { // 这是我们编写的Compact Constructor: if (x &lt; 0 || y &lt; 0) { throw new IllegalArgumentException(); } // 这是编译器继续生成的赋值代码: this.x = x; this.y = y; } ...} ¶3、可以编写静态方法 1234567891011public record Point(int x, int y) { public static Point of() { return new Point(0, 0); } public static Point of(int x, int y) { return new Point(x, y); }}var z = Point.of();var p = Point.of(123, 456); ¶4、小结： 从Java 14开始，提供新的record关键字，可以非常方便地定义Data Class： 使用record定义的是不变类； 可以编写Compact Constructor（构造方法）对参数进行验证； 可以定义静态方法。 ¶八、BigInteger 超出long的范围时可以使用java.math.BigInteger，来模拟大整数！ BigInteger内部用一个int[]数组来模拟一个非常大的整数！ 做运算时，只能通过实例方法来进行！ 和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢！ 可以使用longVanlue()方法来将其转化为long类型，前提当然是没有超过long的范围！超过会把报错！ 1234567891011121314151617181920BigInteger bi = new BigInteger(\"1234567890\");System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000// 加法BigInteger i1 = new BigInteger(\"1234567890\");BigInteger i2 = new BigInteger(\"12345678901234567890\");BigInteger sum = i1.add(i2); // 12345678902469135780// 转换为longBigInteger i = new BigInteger(\"123456789000\");System.out.println(i.longValue()); // 123456789000System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range// + - * /BigInteger s1 = s.add(new BigInteger(\"328423\"));BigInteger s3 = s.subtract(new BigInteger(\"89789797\"));BigInteger s2 = s.multiply(new BigInteger(\"328423\"));BigInteger s4 = s.divide(new BigInteger(\"2379743489\"));// s的5次方BigInteger s5 = s.pow(5); BigInteger和Integer、Long一样，也是不可变类，并且也继承自Number类。因为Number定义了转换为基本类型的几个方法： 转换为byte：byteValue() 转换为short：shortValue() 转换为int：intValue() 转换为long：longValue() 转换为float：floatValue() 转换为double：doubleValue() 因此，通过上述方法，可以把BigInteger转换成基本类型。如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。 float没有floatValueExact()方法，超出范围会输出Infintity； 123456789101112131415import java.math.BigInteger;public class Main { public static void main(String[] args) { BigInteger n = new BigInteger(\"999999\").pow(99); float f = n.floatValue(); System.out.println(f);//Infinity int s = n.intValueExact(); System.out.println(s);//报错 int s = n.intValue(); System.out.println(s);//结果会丢失，不准确！ }} ¶九、BigDecimal 和BigInteger类似，BigDecimal可以表示一个任意大小且精度完全准确的浮点数。 BigDecimal也是从Number继承的，也是不可变对象。 当然也有和BigInteger一样的方法！ BigDecimal用于表示精确的小数，常用于财务计算； 12BigDecimal bd = new BigDecimal(\"123.4567\");System.out.println(bd.multiply(bd)); // 15241.55677489 scale()：可以计算小数位数！ stripTrailingZeros()：去掉小数末尾的0！ 若为整数，则返回整数末尾的0的个数，为负值！ 12345678910111213141516BigDecimal d1 = new BigDecimal(\"123.45\");BigDecimal d2 = new BigDecimal(\"123.4500\");BigDecimal d3 = new BigDecimal(\"1234500\");System.out.println(d1.scale()); // 2,两位小数System.out.println(d2.scale()); // 4System.out.println(d3.scale()); // 0BigDecimal d1 = new BigDecimal(\"123.4500\");BigDecimal d2 = d1.stripTrailingZeros();System.out.println(d1.scale()); // 4System.out.println(d2.scale()); // 2,因为去掉了00BigDecimal d3 = new BigDecimal(\"1234500\");BigDecimal d4 = d3.stripTrailingZeros();System.out.println(d3.scale()); // 0System.out.println(d4.scale()); // -2 setScale()：设置精度，小数位数。两种截断方法： RoundingMode.HALF_UP：四舍五入截断 RoundingMode.DOWN：直接截断 123456789101112import java.math.BigDecimal;import java.math.RoundingMode;public class Main { public static void main(String[] args) { BigDecimal d1 = new BigDecimal(\"123.456789\"); BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568 BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567 System.out.println(d2); System.out.println(d3); }} 对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断： 1234BigDecimal d1 = new BigDecimal(\"123.456\");BigDecimal d2 = new BigDecimal(\"23.456789\");BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽 divideAndRemainder()：返回除数和余数！ signum()：有余数返回1，余数为0返回0！ 调用divideAndRemainder()方法时，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个BigDecimal是否是整数倍数： 123456789101112BigDecimal n = new BigDecimal(\"12.345\");BigDecimal m = new BigDecimal(\"0.12\");BigDecimal[] dr = n.divideAndRemainder(m);System.out.println(dr[0]); // 102System.out.println(dr[1]); // 0.105BigDecimal n = new BigDecimal(\"12.75\");BigDecimal m = new BigDecimal(\"0.15\");BigDecimal[] dr = n.divideAndRemainder(m);if (dr[1].signum() == 0) { // n是m的整数倍} BigDecimal比较 equal()方法，不但要求两个BigDecimal的值相等，还要求它们的scale()相等！ 可以使用stripTrailingZeros()去掉末尾0再比较！ 也可以使用compareTo()方法：它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。 比较必须使用compareTo()方法！ 12345BigDecimal d1 = new BigDecimal(\"123.456\");BigDecimal d2 = new BigDecimal(\"123.45600\");System.out.println(d1.equals(d2)); // false,因为scale不同System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2System.out.println(d1.compareTo(d2)); // 0 ¶十、其他常用类 ¶1、Math类 Java标准库还提供了一个StrictMath，它提供了和Math几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，StrictMath保证所有平台计算结果都是完全相同的，而Math会尽量针对平台优化计算速度，所以，绝大多数情况下，使用Math就足够了。 abs()：绝对值 max()：最大 min()：最小 sqrt()：开方 exp()：e的x次方 log()：以e为底对数 log10()：以10为底对数 sin()、cos()、tan()、asin()、acos()：三角函数 PI：pai(3.14…) E：e(2.718…) 1234567891011121314151617Math.abs(-100); // 100Math.max(100, 99); // 100Math.min(1.2, 2.3); // 1.2Math.pow(2, 10); // 2的10次方=1024Math.sqrt(2); // 1.414...Math.exp(2); // 7.389...Math.log(4); // 1.386...Math.log10(100); // 2Math.sin(3.14); // 0.00159...Math.cos(3.14); // -0.9999...Math.tan(3.14); // -0.0015...Math.asin(1.0); // 1.57079...Math.acos(1.0); // 0.0double pi = Math.PI; // 3.14159...double e = Math.E; // 2.7182818...Math.sin(Math.PI / 6); // sin(π/6) = 0.5 ¶2、Random类 Random用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。 要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()： 123456Random r = new Random();r.nextInt(); // 2071575453,每次都不一样r.nextInt(10); // 5,生成一个[0,10)之间的intr.nextLong(); // 8811649292570369305,每次都不一样r.nextFloat(); // 0.54335...生成一个[0,1)之间的floatr.nextDouble(); // 0.3716...生成一个[0,1)之间的double 倘若在创建实例时给定一个种子，则随机生成的数都是一定的，不会改变，不给种子是按照当前的时间戳自动确定种子，由于每时每刻时间不同，所以生成的数不同： 12Random r = new Random(3);System.out.println(r.nextInt());//-1155099828 ¶3、SecureRandom类 有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的！ SecureRandom无法指定种子，它使用RNG（random number generator）算法。JDK的SecureRandom实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器： SecureRandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。 在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用SecureRandom来产生安全的随机数。 需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！ 虽然有点没看懂！以后回来再看！ 12345678910111213141516171819202122package com.test;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.util.Arrays;public class codeTest { public static void main(String[] args) { SecureRandom s = new SecureRandom(); System.out.println(s.nextInt()); SecureRandom sr = null; try { sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器 } catch (NoSuchAlgorithmException e) { sr = new SecureRandom(); // 获取普通的安全随机数生成器 } byte[] buffer = new byte[16]; sr.nextBytes(buffer); // 用安全随机数填充buffer System.out.println(Arrays.toString(buffer)); }} 常用Java核心类终于完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"String","slug":"String","permalink":"https://www.itnxd.cn/tags/String/"},{"name":"JavaBean","slug":"JavaBean","permalink":"https://www.itnxd.cn/tags/JavaBean/"},{"name":"包装类型","slug":"包装类型","permalink":"https://www.itnxd.cn/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"}],"author":"Mr.Niu"},{"title":"Java教程系列之面向对象编程","slug":"Java教程系列之面向对象编程","date":"2020-03-25T10:11:00.000Z","updated":"2021-02-06T14:14:42.095Z","comments":true,"path":"posts/40947.html","link":"","permalink":"https://www.itnxd.cn/posts/40947.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶一、class 和 instance 就是常说的类和实例！ ¶1、定义class 一个class可以包含多个字段（field），字段用来描述一个类的特征。 上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。因此，通过class，把一组数据汇集到一个对象上，实现了数据封装。 public是用来修饰字段的，它表示这个字段可以被外部访问。 123456789101112package com.test;public class codeTest { public static void main(String[] args) { }}class Person { public String name; public int age;} ¶2、创建instance 定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。 new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例： 访问实例变量可以用变量.字段 ! 小贴士：new出来的东西都在堆区，其他在栈区！ 123456789101112131415package com.test;public class codeTest { public static void main(String[] args) { Person ming = new Person(); ming.name = \"Xiao Ming\"; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = \"Xiao Hong\"; hong.age = 15; }} 上面创建的两个实例分别指向两块内存，存放在堆中！ ¶二、普通方法 通过在类的内部定义方法可以实现数据的封装，由于private的特性可以保证外部无法访问到私有成员field！ 一般使用set和get函数来进行赋值和获取，而字段field是private的，可以保证不被外部所修改！保证数据的安全性！ 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) { Person ming = new Person(); ming.setName(\"Xiao Ming\"); // 设置name ming.setAge(12); // 设置age System.out.println(ming.getName() + \", \" + ming.getAge()); }}class Person { private String name; private int age; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public int getAge() { return this.age; } public void setAge(int age) { if (age &lt; 0 || age &gt; 100) { throw new IllegalArgumentException(\"invalid age value\"); } this.age = age; }} ¶1、定义方法 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。 1234修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值;} ¶2、private方法 和private字段一样，private方法不允许外部调用，那我们定义private方法有什么用？ 定义private方法的理由是内部方法是可以调用private方法的。例如： 12345678910111213141516171819202122232425public class Main { public static void main(String[] args) { Person ming = new Person(); ming.setBirth(2008); System.out.println(ming.getAge()); }}class Person { private String name; private int birth; public void setBirth(int birth) { this.birth = birth; } public int getAge() { return calcAge(2019); // 调用private方法 } // private方法: private int calcAge(int currentYear) { return currentYear - this.birth; }} 观察上述代码，calcAge()是一个private方法，外部代码无法调用，但是，内部方法getAge()可以调用它。 此外，我们还注意到，这个Person类只定义了birth字段，没有定义age字段，获取age时，通过方法getAge()返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心Person实例在内部到底有没有age字段。 ¶3、this变量 在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。因此，通过this.field就可以访问当前实例的字段。 ¶3.1 没有命名冲突，直接return 1234567class Person { private String name; public String getName() { return name; // 相当于this.name }} ¶3.2 有冲突，使用this.field 1234567class Person { private String name; public void setName(String name) { this.name = name; // 前面的this不可少，少了就变成局部变量name了 }} ¶4、方法参数 方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递，对应位置对应相等！ ¶4.1 不可变参数 123456class Person { ... public void setNameAndAge(String name, int age) { ... }} ¶4.2 可变参数 可变参数用类型...定义，可变参数相当于数组类型： 1234567class Group { private String[] names; public void setNames(String... names) { this.names = names; }} 也可以直接接收数组 1234567class Group { private String[] names; public void setNames(String[] names) { this.names = names; }} 二者的区别： 第一种可以直接方便的传参，而第二种只能使用new来传参，相比之下，第一种更加方便！ 123456789101112131415public class Main { public static void main(String[] args) { // 第一种： Group g = new Group(); g.setNames(\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"); // 传入3个String g.setNames(\"Xiao Ming\"); // 传入1个String g.setNames(); // 传入0个String // 第二种： Group g = new Group(); g.setNames(new String[] {\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"}); // 传入1个String[] }} 可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null。 ¶5、参数绑定 基本类型参数的传递：是调用外部方法值的复制。双方各自的后续修改，互不影响。 引用类型参数的绑定：调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。 下面就是引用型参数例子，main中的修改会影响到类的field，因为指向的是同一块内存地址！ 12345678910111213141516171819202122public class Main { public static void main(String[] args) { Person p = new Person(); String[] fullname = new String[] { \"Homer\", \"Simpson\" }; p.setName(fullname); // 传入fullname数组 System.out.println(p.getName()); // \"Homer Simpson\" fullname[0] = \"Bart\"; // fullname数组的第一个元素修改为\"Bart\" System.out.println(p.getName()); // \"Homer Simpson\"还是\"Bart Simpson\"? }}class Person { private String[] name; public String getName() { return this.name[0] + \" \" + this.name[1]; } public void setName(String[] name) { this.name = name; }} ¶三、构造方法 在创建对象实例时就把内部字段进行初始化的操作！ ¶1、构造方法 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false： 默认任何class都有构造方法！ 编译器自动生成：它没有参数，也没有执行语句，类似这样： 1234class Person { public Person() { }} 如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法： 如下方：无法找到默认构造函数Person()！ 1234567891011121314151617181920212223public class Main { public static void main(String[] args) { Person p = new Person(); // 编译错误:找不到这个构造方法 }}class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; }} 当然可以将原来的默认方法与自定义的构造方法通过重载都写出来！ ¶2、构造方法重载 默认的构造方法依然可以使用！ 在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分 1234567891011121314151617class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this.name = name; this.age = 12; } public Person() { }} ¶3、构造方法自我调用 一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)： 1234567891011121314151617class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this(name, 18); // 调用另一个构造方法Person(String, int) } public Person() { this(\"Unnamed\"); // 调用另一个构造方法Person(String) }} ¶四、继承 继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让Student从Person继承时，Student就获得了Person的所有功能，我们只需要为Student编写新增的功能。 ¶1、使用extends实现继承 在OOP的术语中，我们把Person称为超类（super class），父类（parent class），基类（base class），把Student称为子类（subclass），扩展类（extended class）。 123456789101112131415161718class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...}}class Student extends Person { // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() { … } public void setScore(int score) { … }} 注意到我们在定义Person的时候，没有写extends。在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类。 Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。 ¶2、使用protected 子类无法访问父类的private的字段field，可以使用protected来修饰字段，使得该字段可以在一个继承树中被访问！ protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问 12345678910class Person { protected String name; protected int age;}class Student extends Person { public String hello() { return \"Hello, \" + name; // OK! }} ¶3、super super关键字表示父类（超类）。子类引用父类的字段时，可以用s uper.fieldName! 12345class Student extends Person { public String hello() { return \"Hello, \" + super.name; }} 使用super.name，或者this.name，或者name，效果都是一样的。编译器会自动定位到父类的name字段。 在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super(); 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。 小贴士：子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。 若父类是默认构造方法，则子类使用时会自动调用，不需要写；若是自定义构造方法，需要调用super并加上参数！ 12345678910111213141516171819202122232425public class Main { public static void main(String[] args) { Student s = new Student(\"Xiao Ming\", 12, 89); }}class Person { protected String name; protected int age; public Person(String name, int age) { this.name = name; this.age = age; }}class Student extends Person { protected int score; public Student(String name, int age, int score) { super(name, age); // 自动调用父类的构造方法 this.score = score; }} ¶4、向上转型 把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。 Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！ 继承树是Student &gt; Person &gt; Object ，所以可以把Student类型转型为Person，或者更高层次的Object。 老子可以拓展到儿子级别扩大功能！！！。。 1234Student s = new Student();Person p = new Person();Person p = new Student(); // ??? ¶5、向下转型 和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting） 1234Person p1 = new Student(); // upcasting, okPerson p2 = new Person();Student s1 = (Student) p1; // okStudent s2 = (Student) p2; // runtime error! ClassCastException! Person类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。在向下转型的时候，把p1转型为Student会成功，因为p1确实指向Student实例，把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。 向下转型错误时候，Java虚拟机会报ClassCastException。 总而言之：就是少的可以拓展为多的，多的无法删减为少的（从左到右说）！ ¶使用instanceof instanceof实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false。 如果实里原来就是子类，则将其向下转型时是可以正确转型的！ 可以使用instaceof 来判断原来是不是子类，使得话则可以向下转型，这样就可以避免转型错误的发生！ 12345Person p = new Student();if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功} 从Java 14开始，判断instanceof后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码： 直接使用obj instanceof String s 即可在判断可以向下转型的条件下直接进行转型到变量 s！ 使用instanceof variable这种判断并转型为指定类型变量的语法时，必须打开编译器开关--source 14和--enable-preview。 这是java14的语法！ 1234567891011Object obj = \"hello\";if (obj instanceof String) { String s = (String) obj; System.out.println(s.toUpperCase());}Object obj = \"hello\";if (obj instanceof String s) { // 可以直接使用变量s: System.out.println(s.toUpperCase());} ¶五、多态 ¶1、覆写（Override） 在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。 Override和Overload不同的是，如果方法签名不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是Override。 就和重载一样，全部一样才是才叫覆写！ 123456789101112class Person { public void run() { System.out.println(\"Person.run\"); }}class Student extends Person { @Override public void run() { System.out.println(\"Student.run\"); }} ¶2、关于@Override 加上@Override可以让编译器来判断你是不是进行覆写时参数或类型写错了，若不同则会直接编译错误！ 倘若不加的话，是不会去检查的，编译器认为这是你新写的方法，编译通过！ 如下方：加上，编译错误，不加，编译通过！ 1234567891011121314public class Main { public static void main(String[] args) { }}class Person { public void run() {}}public class Student extends Person { //@Override // Compile error! public void run(String s) {}} ¶3、多态（Polymorphic） 多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法 1234public void runTwice(Person p) { p.run(); p.run();} 它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。 所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？ ¶举个例子: 三种收税情况，覆写三种getTax函数，利用多态自动调用需要的覆写方法！ 观察totalTax()方法：利用多态，totalTax()方法只需要和Income打交道，它完全不需要知道Salary和StateCouncilSpecialAllowance的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从Income派生，然后正确覆写getTax()方法就可以。把新的类型传入totalTax()，不需要修改任何代码。 可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Main { public static void main(String[] args) { // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes = new Income[] { new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) }; System.out.println(totalTax(incomes)); } public static double totalTax(Income... incomes) { double total = 0; for (Income income: incomes) { total = total + income.getTax(); } return total; }}class Income { protected double income; public Income(double income) { this.income = income; } public double getTax() { return income * 0.1; // 税率10% }}class Salary extends Income { public Salary(double income) { super(income); } @Override public double getTax() { if (income &lt;= 5000) { return 0; } return (income - 5000) * 0.2; }}class StateCouncilSpecialAllowance extends Income { public StateCouncilSpecialAllowance(double income) { super(income); } @Override public double getTax() { return 0; }} ¶覆写object方法 因为所有的class最终都继承自Object，而Object定义了几个重要的方法： toString()：把instance输出为String； equals()：判断两个instance是否逻辑相等； hashCode()：计算一个instance的哈希值。 1234567891011121314151617181920212223242526class Person { ... // 显示更有意义的字符串: @Override public String toString() { return \"Person:name=\" + name; } // 比较是否相等: @Override public boolean equals(Object o) { // 当且仅当o为Person类型: if (o instanceof Person) { Person p = (Person) o; // 并且name字段相同时，返回true: return this.name.equals(p.name); } return false; } // 计算hash: @Override public int hashCode() { return this.name.hashCode(); }} ¶调用super 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。 1234567891011121314class Person { protected String name; public String hello() { return \"Hello, \" + name; }}Student extends Person { @Override public String hello() { // 调用父类的hello()方法: return super.hello() + \"!\"; }} ¶使用final 继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override： 12345678910111213class Person { protected String name; public final String hello() { return \"Hello, \" + name; }}Student extends Person { // compile error: 不允许覆写 @Override public String hello() { }} 如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承： 1234567final class Person { protected String name;}// compile error: 不允许继承自PersonStudent extends Person {} 对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改 可使用构造方法来进行给final字段赋值，赋值完毕，值将不可修改！ 1234567891011121314class Person { public final String name = \"Unamed\";}Person p = new Person();p.name = \"New Name\"; // compile error!// 定义构造函数赋值final字段class Person { public final String name; public Person(String name) { this.name = name; }} ¶4、一句话总结多态： JAVA变量在调用类方法时，以实际指向的实例类型为准，而不是声明类型 ¶六、抽象类 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法： 把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person类也无法被实例化。编译器会告诉我们，无法编译Person类，因为它包含抽象方法。 必须把Person类本身也声明为abstract，才能正确编译它： 抽象方法不需要写大括号！ 123abstract class Person { public abstract void run();} ¶1、抽象类 如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。 因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。 使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类： 无法实例化的抽象类有什么用？ 因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。 例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法： 1234567891011121314151617public class Main { public static void main(String[] args) { Person p = new Student(); p.run(); }}abstract class Person { public abstract void run();}class Student extends Person { @Override public void run() { System.out.println(\"Student.run\"); }} 倘若不进行覆写run方法，则会直接编译错误！ ¶2、面向抽象编程 当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例： 这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型： 同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型： 这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。 12345678910Person s = new Student();Person t = new Teacher();// 不关心Person变量的具体子类型:s.run();t.run();// 同样不关心新的子类是如何实现run()方法的：Person e = new Employee();e.run(); 面向抽象编程的本质就是： 上层代码只定义规范（例如：abstract class Person）； 不需要子类就可以实现业务逻辑（正常编译）； 具体的业务逻辑由不同的子类实现，调用者并不关心。 ¶七、接口 在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。 如果一个抽象类没有字段，所有方法全部都是抽象方法： 1234abstract class Person { public abstract void run(); public abstract String getName();} ¶1、接口（interface） 就可以把该抽象类改写为接口：interface。 在Java中，使用interface可以声明一个接口： 所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。 Java的接口特指interface的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。 1234interface Person { void run(); String getName();} ¶2、implements 当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子： 1234567891011121314151617class Student implements Person { private String name; public Student(String name) { this.name = name; } @Override public void run() { System.out.println(this.name + \" run\"); } @Override public String getName() { return this.name; }} 我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，例如： 123class Student implements Person, Hello { // 实现了两个interface ...} ¶3、接口继承 一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如： 此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口。 12345678interface Hello { void hello();}interface Person extends Hello { void run(); String getName();} ¶4、抽象类与接口 合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度。 在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象! ¶5、default方法 在接口中，可以定义default方法。例如，把Person接口的run()方法改为default方法： 实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。 default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。 12345678910111213141516171819202122232425public class Main { public static void main(String[] args) { Person p = new Student(\"Xiao Ming\"); p.run(); }}interface Person { String getName(); default void run() { System.out.println(getName() + \" run\"); }}class Student implements Person { private String name; public Student(String name) { this.name = name; } public String getName() { return this.name; }} ¶6、一些接口的笔记 ¶为什么要有接口 因为java中为了避免多重继承可能带来的继承关系混乱所以只允许单一继承，java为了 满足多重继承的需要，采用了规格的多重继承即接口,如果使用，即使没有继承关系的不同种类的对象也可以做共通的处理（我们可以在接口中定义一个方法，然后在两个没有继承关系的对象的不同父类中写一个相同方法签名和返回类型的方法） ¶接口和抽象类的区别 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实例是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。 ¶类实现两个接口有同名方法时会发生的几种情况： 两个接口方法签名相同返回类型相同时 不会编译出错，可以直接override 两个接口方法签名相同返回类型不同，会编译出错。 两个接口方法名相同,在实现类里这两个同名方法签名符合overload条件的话可以同时实现不会报错，只要符合overload那方法返回类型就不重要了，一样不会报错。 ¶类实现两个接口有同名default方法时会发生的几种情况 如果两个方法的方法签名相同方法返回类型相同那么需要在实现类override这个同名方法。 如果两个方法方法签名相同，返回类型不同会编译出错。 如果两个方法符合overload条件可以正常实现。 ¶关于接口中的静态方法，静态变量 静态变量： 可直接通过实现类或者实现类的实例直接访问到接口的静态变量,但如果多继承时这样调用会编译出错。 静态方法 无法通过实现类和它的实例访问到接口的静态方法 ¶八、静态字段和静态方法 ¶1、静态字段 在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。 还有一种字段，是用static修饰的字段，称为静态字段：static field。 实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段 1234567891011121314151617181920212223public class Main { public static void main(String[] args) { Person ming = new Person(\"Xiao Ming\", 12); Person hong = new Person(\"Xiao Hong\", 15); ming.number = 88; System.out.println(hong.number); hong.number = 99; System.out.println(ming.number); }}class Person { public String name; public int age; public static int number; public Person(String name, int age) { this.name = name; this.age = age; }} 如下图： 12345678910111213141516 ┌──────────────────┐ming ──&gt;│Person instance │ ├──────────────────┤ │name = \"Xiao Ming\"│ │age = 12 │ │number ───────────┼──┐ ┌─────────────┐ └──────────────────┘ │ │Person class │ │ ├─────────────┤ ├───&gt;│number = 99 │ ┌──────────────────┐ │ └─────────────┘hong ──&gt;│Person instance │ │ ├──────────────────┤ │ │name = \"Xiao Hong\"│ │ │age = 15 │ │ │number ───────────┼──┘ └──────────────────┘ 虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。 因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。 推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。对于上面的代码，更好的写法是： 12Person.number = 99;System.out.println(Person.number); ¶2、静态方法 有静态字段，就有静态方法。用static修饰的方法称为静态方法。 调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数! 因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。 通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。 通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。 1234567891011121314public class Main { public static void main(String[] args) { Person.setNumber(99); System.out.println(Person.number); }}class Person { public static int number; public static void setNumber(int value) { number = value; }} ¶3、接口静态字段 因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型。 实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉！ 编译器会自动把该字段变为public static final类型。 记得一个java文件只能有一个public类哦！ 1234567891011public interface Person { public static final int MALE = 1; public static final int FEMALE = 2;}// 改进写法！public interface Person { // 编译器会自动加上public statc final: int MALE = 1; int FEMALE = 2;} ¶九、包（package） ¶1、package 在Java中，我们使用package来解决名字冲突。 Java定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是包名.类名。 包可以是多层结构，用.隔开。例如：java.util。 没有定义包名的class，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。 要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。 123456789101112package ming; // 申明包名mingpublic class Person { }// 第二个包package mr.jun; // 申明包名mr.junpublic class Arrays { } 我们还需要按照包结构把上面的Java文件组织起来。假设以package_sample作为根目录，src作为源码目录，那么所有文件结构就是： 123456789package_sample└─ src ├─ hong │ └─ Person.java │ ming │ └─ Person.java └─ mr └─ jun └─ Arrays.java 编译后的.class文件也需要按照包结构存放。如果使用IDE，把编译后的.class文件放到bin目录下，那么，编译的文件结构就是： 123456789package_sample└─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class ¶2、包作用域 位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。 123456789101112131415161718package hello;public class Person { // 包作用域: void hello() { System.out.println(\"Hello!\"); }}// 同包调用package hello;public class Main { public static void main(String[] args) { Person p = new Person(); p.hello(); // 可以调用，因为Main和Person在同一个包 }} ¶3、import 为了引用其他包的类可以使用import导入包名！ 导入也可以直接写完整路径，很明显，不这样做！ 1234567891011121314151617181920// Person.javapackage ming;public class Person { public void run() { mr.jun.Arrays arrays = new mr.jun.Arrays(); }}// Person.javapackage ming;// 导入完整类名:import mr.jun.Arrays;public class Person { public void run() { Arrays arrays = new Arrays(); }} 在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）： 我们一般不推荐这种写法，因为在导入了多个包后，很难看出Arrays类属于哪个包。 1234567891011// Person.javapackage ming;// 导入mr.jun包的所有class:import mr.jun.*;public class Person { public void run() { Arrays arrays = new Arrays(); }} 还有一种import static的语法，它可以导入可以导入一个类的静态字段和静态方法： import static很少使用。 1234567891011package main;// 导入System类的所有静态字段和静态方法:import static java.lang.System.*;public class Main { public static void main(String[] args) { // 相当于调用System.out.println(…) out.println(\"Hello, world!\"); }} ¶4、包命名 为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如： org.apache org.apache.commons.log com.niuge.sample 子包就可以根据功能自行命名。 ¶5、class查找顺序 Java编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时： 如果是完整类名，就直接根据完整类名查找这个class； 如果是简单类名，按下面的顺序依次查找： 查找当前package是否存在这个class； 查找import的包是否包含这个class； 查找java.lang包是否包含这个class。 如果按照上面的规则还无法确定类名，则编译报错。 因此，编写class的时候，编译器会自动帮我们做两个import动作： 默认自动import当前package的其他class； 默认自动import java.lang.*。 注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。 如果有两个class名称相同，例如，mr.jun.Arrays和java.util.Arrays，那么只能import其中一个，另一个必须写完整类名。 ¶十、作用域 在Java中，我们经常看到public、protected、private这些修饰符。在Java中，这些修饰符可以用来限定访问作用域。 ¶1、public 定义为public的class、interface可以被其他任何类访问： 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限： 导入包，只可以访问public类型的class等等！ ¶2、private 定义为private的field、method无法被其他类访问： 实际上，确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面，因为public方法定义了类对外提供的功能，阅读代码的时候，应该先关注public方法： 12345678910package abc;public class Hello { public void hello() { this.hi(); } private void hi() { }} ¶嵌套类 Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限： 定义在一个class内部的class称为嵌套类（nested class），Java支持好几种嵌套类。 内部嵌套类必须使用static修饰！ 123456789101112131415161718public class Main { public static void main(String[] args) { Inner i = new Inner(); i.hi(); } // private方法: private static void hello() { System.out.println(\"private hello!\"); } // 静态内部类: static class Inner { public void hi() { Main.hello(); } }} ¶3、protected protected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类： ¶4、包作用域 详见第九点的小2！ ¶5、局部变量 在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。 ¶6、final 请查看第五点的小3的final！ ¶7、tips 如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法。 把方法定义为package权限有助于测试，因为测试类和被测试类只要位于同一个package，测试代码就可以访问被测试类的package权限方法。 一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。 ¶十一、classpath和jar 廖雪峰本节教程参考！点击这里！ ¶1、classpath classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。 因为Java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。 一般不需要设置，IDE编译时会自动引入当前bin目录的参数！。。。。 所以，classpath就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用;分隔，带空格的目录用\"\"括起来，可能长这样： 1C:\\work\\project1\\bin;C:\\shared;\"D:\\My Documents\\project1\\bin\" 在Linux系统上，用:分隔，可能长这样： 1/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin 现在我们假设classpath是.;C:\\work\\project1\\bin;C:\\shared，当JVM在加载abc.xyz.Hello这个类时，会依次查找： &lt;当前目录&gt;\\abc\\xyz\\Hello.class C:\\work\\project1\\bin\\abc\\xyz\\Hello.class C:\\shared\\abc\\xyz\\Hello.class 注意到.代表当前目录。如果JVM在某个路径下找到了对应的class文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。 classpath的设定方法有两种： 在系统环境变量中设置classpath环境变量，不推荐； 在启动JVM时设置classpath变量，推荐。 我们强烈不推荐在系统环境变量中设置classpath，那样会污染整个系统环境。在启动JVM时设置classpath才是推荐的做法。实际上就是给java命令传入-classpath或-cp参数： 1java -classpath .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello 或者使用-cp的简写： 1java -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello 没有设置系统环境变量，也没有传入-cp参数，那么JVM默认的classpath为.，即当前目录： 1java abc.xyz.Hello 上述命令告诉JVM只在当前目录搜索Hello.class。 在IDE中运行Java程序，IDE自动传入的-cp参数是当前工程的bin目录和引入的jar包。 通常，我们在自己编写的class中，会引用Java核心库的class，例如，String、ArrayList等。这些class应该上哪去找？ 有很多“如何设置classpath”的文章会告诉你把JVM自带的rt.jar放入classpath，但事实上，根本不需要告诉JVM如何去Java核心库查找class，JVM怎么可能笨到连自己的核心库在哪都不知道？ 不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！ 更好的做法是，不要设置classpath！默认的当前目录.对于绝大多数情况都够用了。 ¶2、jar 如果有很多.class文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。 jar包就是用来干这个事的，它可以把package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。 jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的class，就可以把jar包放到classpath中： 就是用来打包class的文件！ 1java -cp ./hello.jar abc.xyz.Hello 这样JVM会自动在hello.jar文件里去搜索某个类。 那么问题来了：如何创建jar包？ 因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从.zip改为.jar，一个jar包就创建成功。 假设编译输出的目录结构是这样： 123456789package_sample└─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class 这里需要特别注意的是，jar包里的第一层目录，不能是bin，而应该是hong、ming、mr。 打包位置应该是bin目录进去之后，或者是IDEA的out目录进去之后！ jar包还可以包含一个特殊的/META-INF/MANIFEST.MF文件，MANIFEST.MF是纯文本，可以指定Main-Class和其它信息。JVM会自动读取这个MANIFEST.MF文件，如果存在Main-Class，我们就不必在命令行指定启动的类名，而是用更方便的命令： 1java -jar hello.jar jar包还可以包含其它jar包，这个时候，就需要在MANIFEST.MF文件里配置classpath了。 在大型项目中，不可能手动编写MANIFEST.MF文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如Maven，可以非常方便地创建jar包。 ¶十二、模块 廖雪峰模块教程，点击这里！ 从Java 9开始，JDK又引入了模块（Module）。 我们知道，.class文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆.class文件，很不便于管理，所以，jar文件就是class文件的容器。 在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫rt.jar，一共有60多M。 如果是自己开发的程序，除了一个自己的app.jar以外，还需要一堆第三方的jar包 此节有点复杂以后回来再看！。。。 ¶1、模块 运行一个Java程序，一般来说，命令行写这样： 1java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main 注意：JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。 如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出ClassNotFoundException。 所以，jar只是用于存放class的容器，它并不关心class之间的依赖。 从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果a.jar必须依赖另一个b.jar才能运行，那我们应该给a.jar加点说明啥的，让程序在编译和运行的时候能自动定位到b.jar，这种自带“依赖关系”的class容器就是模块。 为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的rt.jar分拆成了几十个模块，这些模块以.jmod扩展名标识，可以在$JAVA_HOME/jmods目录下找到它们： java.base.jmod java.compiler.jmod java.datatransfer.jmod java.desktop.jmod … 这些.jmod文件每一个都是一个模块，模块名就是文件名。例如：模块java.base对应的文件就是java.base.jmod。模块之间的依赖关系已经被写入到模块内的module-info.class文件了。所有的模块都直接或间接地依赖java.base模块，只有java.base模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从Object直接或间接继承而来。 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。 ¶2、编写模块 那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以oop-module工程为例，它的目录结构如下： 12345678910oop-module├── bin├── build.sh└── src ├── com │ └── itranswarp │ └── sample │ ├── Greeting.java │ └── Main.java └── module-info.java 其中，bin目录存放编译后的class文件，src目录存放源码，按包名的目录结构存放，仅仅在src目录下多了一个module-info.java这个文件，这就是模块的描述文件。在这个模块中，它长这样： 1234module hello.world { requires java.base; // 可不写，任何模块都会自动引入java.base requires java.xml;} 其中，module是关键字，后面的hello.world是模块的名称，它的命名规范与包一致。花括号的requires xxx;表示这个模块需要引用的其他模块名。除了java.base可以被自动引入外，这里我们引入了一个java.xml的模块。 当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，Main.java代码如下： 1234567891011package com.itranswarp.sample;// 必须引入java.xml模块后才能使用其中的类:import javax.xml.XMLConstants;public class Main { public static void main(String[] args) { Greeting g = new Greeting(); System.out.println(g.hello(XMLConstants.XML_NS_PREFIX)); }} 如果把requires java.xml;从module-info.java中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。 下面，我们用JDK提供的命令行工具来编译并创建模块。 首先，我们把工作目录切换到oop-module，在当前目录下编译所有的.java文件，并存放到bin目录下，命令如下： 1$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java 如果编译成功，现在项目结构如下： 123456789101112131415oop-module├── bin│ ├── com│ │ └── itranswarp│ │ └── sample│ │ ├── Greeting.class│ │ └── Main.class│ └── module-info.class└── src ├── com │ └── itranswarp │ └── sample │ ├── Greeting.java │ └── Main.java └── module-info.java 注意到src目录下的module-info.java被编译到bin目录下的module-info.class。 下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入--main-class参数，让这个jar包能自己定位main方法所在的类： 1$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin . 现在我们就在当前目录下得到了hello.jar这个jar包，它和普通jar包并无区别，可以直接使用命令java -jar hello.jar来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的jmod命令把一个jar包转换成模块： 1$ jmod create --class-path hello.jar hello.jmod 于是，在当前目录下我们又得到了hello.jmod这个模块文件，这就是最后打包出来的传说中的模块！ ¶3、运行模块 要运行一个jar，我们使用java -jar xxx.jar命令。要运行一个模块，我们只需要指定模块名。试试： 1$ java --module-path hello.jmod --module hello.world 结果是一个错误： 12Error occurred during initialization of boot layerjava.lang.module.FindException: JMOD format not supported at execution time: hello.jmod 原因是.jmod不能被放入--module-path中。换成.jar就没问题了： 12$ java --module-path hello.jar --module hello.worldHello, xml! 那我们辛辛苦苦创建的hello.jmod有什么用？答案是我们可以用它来打包JRE。 ¶4、打包JRE 前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的rt.jar拆成了几十个.jmod模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。 过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？ 现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了jlink命令来干这件事。命令如下： 1$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/ 我们在--module-path参数指定了我们自己的模块hello.jmod，然后，在--add-modules参数中指定了我们用到的3个模块java.base、java.xml和hello.world，用,分隔。最后，在--output参数指定输出目录。 现在，在当前目录下，我们可以找到jre目录，这是一个完整的并且带有我们自己hello.jmod模块的JRE。试试直接运行这个JRE： 12$ jre/bin/java --module hello.worldHello, xml! 要分发我们自己的Java应用程序，只需要把这个jre目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。 ¶5、访问权限 前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。 确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。 举个例子：我们编写的模块hello.world用到了模块java.xml的一个类javax.xml.XMLConstants，我们之所以能直接使用这个类，是因为模块java.xml的module-info.java中声明了若干导出： 123456module java.xml { exports java.xml; exports javax.xml.catalog; exports javax.xml.datatype; ...} 只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的hello.world模块中的com.itranswarp.sample.Greeting类，我们必须将其导出： 123456module hello.world { exports com.itranswarp.sample; requires java.base; requires java.xml;} 因此，模块进一步隔离了代码的访问权限。 Java面向对象告一段落了，敬请期待后序内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://www.itnxd.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"author":"Mr.Niu"},{"title":"AcWing-41.包含min函数的栈","slug":"AcWing-41-包含min函数的栈","date":"2020-03-23T12:11:57.000Z","updated":"2021-02-06T13:56:26.287Z","comments":true,"path":"posts/50257.html","link":"","permalink":"https://www.itnxd.cn/posts/50257.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：41. 包含min函数的栈 ¶题目背景： 来源：剑指Offer,《算法竞赛进阶指南》, 美国 Hulu公式 面试题！ 两种做法：详细见下文！ ¶题目描述 设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。 push(x)–将元素x插入栈中 pop()–移除栈顶元素 top()–得到栈顶元素 getMin()–得到栈中最小元素 ¶样例 12345678MinStack minStack = new MinStack();minStack.push(-1);minStack.push(3);minStack.push(-4);minStack.getMin(); --&gt; Returns -4.minStack.pop();minStack.top(); --&gt; Returns 3.minStack.getMin(); --&gt; Returns -1. ¶题目分析： ¶题目要求： 在普通栈的基础上实现一个可以实时获得最小值的 最小栈 ，而且使得复杂度达到O(1)的效果！ ¶解题思路： 第一想法：暴力即可，其他操作都是O(1)的，只有获得最小值的操作不好弄，暴力的话直接扫描一遍，复杂度为O(N)，很明显不合题意！ 好了，正确解法开始！ 解法一：维护两个栈，一个为普通栈，一个为保存前i个数最小值的栈！ 最小栈的第i个位置永远保存前i个位置的最小值！ 最小栈的实现： push时：为空直接压入，不为空只需要判断当前栈顶与当前值得大小取一下min放入栈中即可！ pop时：直接删除即可！ top时：返回普通栈栈顶！ getMin时：直接返回栈顶即可！ 解法二：维护两个栈，一个为普通栈，一个为单调栈！ 单调栈就是：简而言之：就是具有单调性的栈！ 单调栈的实现： 当我们向栈中压入一个数时，如果该数 &lt;= 单调栈的栈顶元素，则将该数同时压入单调栈中； 否则，不压入，这是由于栈具有先进后出性质，所以在该数被弹出之前，栈中一直存在一个数比该数小，所以该数一定不会被当做最小数输出。 当我们从栈中弹出一个数时，如果该数等于单调栈的栈顶元素，则同时将单调栈的栈顶元素弹出。 单调栈由于其具有单调性，所以它的栈顶元素，就是当前栈中的最小数。 其实两种做法很类似的，但解法二用来单调栈的思想！ 可以参考一下的讲解或许会更加清楚！ yxc大神的题解，点击这里！ yxc大神的视频讲解，点击这里！ ¶题解： ¶解法一：维护前i个数的最小值栈 123456789101112131415161718192021222324252627282930313233343536class MinStack {public: /** initialize your data structure here. */ stack&lt;int&gt; stk, stk_min; MinStack() { } void push(int x) { stk.push(x); if(stk_min.size()) x = min(x, stk_min.top()); stk_min.push(x); } void pop() { stk.pop(); stk_min.pop(); } int top() { return stk.top(); } int getMin() { return stk_min.top(); }};/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ ¶解法二：维护一个单调栈 12345678910111213141516171819202122232425262728293031323334353637class MinStack {public: /** initialize your data structure here. */ stack&lt;int&gt; stk, stk_min; MinStack() { } void push(int x) { stk.push(x); if(stk_min.empty() || x &lt;= stk_min.top()) stk_min.push(x); } void pop() { if(stk_min.top() == stk.top()) stk_min.pop(); stk.pop(); } int top() { return stk.top(); } int getMin() { return stk_min.top(); }};/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://www.itnxd.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"author":"Mr.Niu"},{"title":"AcWing-114.国王游戏","slug":"AcWing-114-国王游戏","date":"2020-03-18T13:12:46.000Z","updated":"2021-02-06T14:10:53.366Z","comments":true,"path":"posts/55540.html","link":"","permalink":"https://www.itnxd.cn/posts/55540.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：114. 国王游戏 ¶题目背景： 贪心 + 高精度 以前好像在牛客做过一次。。。 以前的题解链接：点击这里！ 可以再一次温习一下高精度写法以及本题的贪心思路！ ¶题目描述 恰逢 H 国国庆,国王邀请 n 位大臣来玩一个有奖游戏。 首先,他让每个大臣在左、右手上面分别写下一个整数,国王自己也在左、右手上各写一个整数。 然后,让这 n 位大臣排成一排,国王站在队伍的最前面。 排好队后,所有的大臣都会获得国王奖赏的若干金币,每位大臣获得的金币数分别是: 排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数,然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏,所以他想请你帮他重新安排一下队伍的顺序,使得获得奖赏最多的大臣,所获奖赏尽可能的少。 注意,国王的位置始终在队伍的最前面。 ¶输入格式 第一行包含一个整数 n,表示大臣的人数。 第二行包含两个整数 a 和 b,之间用一个空格隔开,分别表示国王左手和右手上的整数。 接下来 n 行,每行包含两个整数 a 和 b,之间用一个空格隔开,分别表示每个大臣左手和右手上的整数。 ¶输出格式 输出只有一行,包含一个整数,表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 ¶数据范围 1≤n≤1000 0&lt;a,b&lt;10000 ¶输入样例： 1234531 12 37 44 6 ¶输出样例： 12 ¶题目分析： ¶题目要求： 一个国王，n个大臣，排成一排，国王在最前边，发一些金币，大臣得到的金币数计算方法为，大臣前面的所有人的左手上的数字乘积除以自己右手的数下取整的到的数。 通过一定的排序，想要达到一个得到金币最多的大臣得到的金币尽可能少！ 最后输出这个大臣的金币数！ ¶解题思路： 贪心思路：（猜想。。） 按照大臣的左右手乘积从小到大排序，然后找出最大值！ 证明过程： 由于是累乘，而且每个数最大为10000，则必须使用高精度来存储： 涉及到高精度乘法，除法，比较大小的操作。 这里不做介绍了，参考下面高精度模板： 我的傻瓜解释版高精度模板！ yxc官网高精度模板！ 相关题解如下： 以前做过一次的题解：点击这里！ yxc大神的题解及证明过程！ yxc视频讲解，点击这里！ ¶题解： 这里涉及到的计算都是高精度乘除一个小的数！ 比较简单！ 可以使用pair来存储 a*b 和 a ，另一个没有存储的数可以直接由二者计算得到！同时也可以借助pair默认排序安装第一个参数排序。。 同时比较两个vector的大小可以借助vector的自动按照字典序比较，当然我们得从高位到低位进行字典序比较，所以需要将vector反转一下，变成下标为0存储最高位即可！ 反转方法：可以使用vector构造函数： 1vector&lt;int&gt;(a.rbegin(), a.rend()) 也可以使用： 1reverse(c.begin(), c.end()); 注意：后者会修改原vector！ 参考具体代码进行理解！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;const int N = 1010;int n;PII T[N];LL S[N], maxn;// 692// i=2、1、0vector&lt;int&gt; mul(vector&lt;int&gt; a, int b){ int t = 0; vector&lt;int&gt; c; for(int i = 0; i &lt; a.size(); i++) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while(t) c.push_back(t % 10), t /= 10; return c;}vector&lt;int&gt; div(vector&lt;int&gt; a, int b){ int t = 0; vector&lt;int&gt; c; bool is_0 = false; for(int i = a.size() - 1; i &gt;= 0; i--) { t = t * 10 + a[i]; int x = t / b; // x 不为0 或前导不是0 if(x || is_0) { is_0 = true; c.push_back(x); } t %= b; } reverse(c.begin(), c.end()); return c;}vector&lt;int&gt; max_vec(vector&lt;int&gt; a, vector&lt;int&gt; b){ if(a.size() &gt; b.size()) return a; if(a.size() &lt; b.size()) return b; if(vector&lt;int&gt;(a.rbegin(), a.rend()) &lt; vector&lt;int&gt;(b.rbegin(), b.rend())) return b; else return a; }void print(vector&lt;int&gt; res){ for(int i = res.size() - 1; i &gt;= 0; i --) cout &lt;&lt; res[i];}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt;= n; i++) { int l, r; cin &gt;&gt; l &gt;&gt; r; T[i] = {l * r, l}; } sort(T + 1, T + n + 1); vector&lt;int&gt; p(1, T[0].second); // 记录累乘 vector&lt;int&gt; res(1, 0); // 记录最大结果 for(int i = 1; i &lt;= n; i++) { res = max_vec(res, div(p, T[i].first/T[i].second)); p = mul(p, T[i].second); } print(res); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"高精度","slug":"高精度","permalink":"https://www.itnxd.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}],"author":"Mr.Niu"},{"title":"蓝桥杯第十一届软件类校内模拟赛","slug":"蓝桥杯第十一届软件类校内模拟赛","date":"2020-03-17T10:53:00.000Z","updated":"2021-02-06T13:34:28.551Z","comments":true,"path":"posts/43446.html","link":"","permalink":"https://www.itnxd.cn/posts/43446.html","excerpt":"","text":"¶非编程题就不看了，都是水题！ ¶5、递增三元组 ¶问题描述 在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。 给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。 ¶输入格式 输入的第一行包含一个整数 n。 第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。 ¶输出格式 输出一行包含一个整数，表示答案。 ¶样例输入 1251 2 5 3 5 ¶样例输出 12 ¶样例说明 a[2] 和 a[4] 可能是三元组的中心。 ¶评测用例规模与约定 对于 50% 的评测用例，2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。 对于所有评测用例，2 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。 ¶题解一：暴力题解（或许超时） 可以跨元素，并不是只能是挨着的三个！ 前面可以用最小值来找，后面直接循环一遍即可！ 我竟然没发现后面也可以存到数组去实现当前位置到最后元素的最大值！ 参考题解二！ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int a[N], n;int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int mina = a[1], res = 0; for(int j = 2; j &lt;= n - 1; j++) { bool flag1 = false, flag2 = false; mina = min(mina, a[j]); if(mina &lt; a[j]) flag1 = true; for(int k = j + 1; k &lt;= n; k++) if(a[j] &lt; a[k]) { flag2 = true; break; } if(flag1 &amp;&amp; flag2) res ++; } cout &lt;&lt; res &lt;&lt; endl; return 0;} ¶题解二：维护两个最大最小值数组 先线性扫描维护两个数组！ 最小值数组，起点到当前位置的最小值； 最大值数组，终点到当前位置的最大值。 从前往后维护一个最小值数组 从后往前维护一个最大值数组 时间复杂度: O(N) 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N = 1010;int a[N], n, small[N], big[N];int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; small[1] = a[1], big[n] = a[n]; for (int i = 2; i &lt;= n; i++) if (a[i] &lt; small[i - 1]) small[i] = a[i]; else small[i] = small[i - 1]; for (int i = n - 1; i &gt;= 1; i--) if (a[i] &gt; big[i + 1]) big[i] = a[i]; else big[i] = big[i + 1]; int res = 0; for (int i = 2; i &lt;= n - 1; i++) if (small[i - 1] &lt; a[i] &amp;&amp; a[i] &lt; big[i + 1]) res++; cout &lt;&lt; res &lt;&lt; endl; return 0;} ¶6、数位递增逆序数 ¶问题描述 一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。 给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？ ¶输入格式 输入的第一行包含一个整数 n。 ¶输出格式 输出一行包含一个整数，表示答案。 ¶样例输入 130 ¶样例输出 126 ¶评测用例规模与约定 对于 40% 的评测用例，1 &lt;= n &lt;= 1000。 对于 80% 的评测用例，1 &lt;= n &lt;= 100000。 对于所有评测用例，1 &lt;= n &lt;= 1000000。 ¶题解：直接扫描一遍即可 判断时可以用两个指针指向一前一后，进行判断即可！ 具体看代码实现！ 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, sum;void solve(int x){ int next = 0x3f, pre; bool flag = true; while(x) { int pre = x % 10; x /= 10; if(pre &gt; next) { flag = false; break; } next = pre; } if(flag) sum ++;}int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) solve(i); cout &lt;&lt; sum &lt;&lt; endl; return 0;} ¶7、元音辅音 ¶问题描述 小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。 给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。 元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。 ¶输入格式 输入一行，包含一个单词，单词中只包含小写英文字母。 ¶输出格式 输出答案，或者为yes，或者为no。 ¶样例输入 1lanqiao ¶样例输出 1yes ¶样例输入 1world ¶样例输出 1no ¶评测用例规模与约定 对于所有评测用例，单词中的字母个数不超过100。 ¶题解：扫描一遍即可！ 保证是辅音、元音、辅音、元音的顺序即可，并且只出现这四段，顺序也一样，多一段都不行！ 直接while去循环直到元辅音出现变化结束即可！ 使用flag可以控制他进入的顺序。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, sum;string str;int fuyin, yuanyin, flag;int main(){ cin &gt;&gt; str; for(int i = 0; i &lt; str.size();) { if(!flag)//辅音 { flag = 1; bool flag1 = false; while(str[i] != 'a' &amp;&amp; str[i] != 'e' &amp;&amp; str[i] != 'i' &amp;&amp; str[i] != 'o' &amp;&amp; str[i] != 'u') { flag1 = true; i ++; } if(!flag1) { cout &lt;&lt; \"no\" &lt;&lt; endl; return 0; } fuyin ++; } else//元音 { flag = 0; bool flag2 = false; while(str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' || str[i] == 'u') { flag2 = true; i ++; } if(!flag2) { cout &lt;&lt; \"no\" &lt;&lt; endl; return 0; } yuanyin ++; } } if(fuyin == 2 &amp;&amp; yuanyin == 2) cout &lt;&lt; \"yes\" &lt;&lt; endl; else cout &lt;&lt; \"no\" &lt;&lt; endl; return 0;} ¶8、长草 ¶问题描述 小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。 小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。 这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。 请告诉小明，k 个月后空地上哪些地方有草。 ¶输入格式 输入的第一行包含两个整数 n, m。 接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。 接下来包含一个整数 k。 ¶输出格式 输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。 ¶样例输入 12345678910114 5.g..........g.......2 ¶样例输出 1234567gggg.gggg.ggggg.ggg. ¶评测用例规模与约定 对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。 对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。 对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= k &lt;= 1000。 ¶题解一：直接循环k个月 先将有草的地方存起来，再去循环k个月，每次循环都将起点置为上一次的终点，可以有效减少扫描次数，每个月都去扫描上一次新增加的地方！ 貌似不会超时！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;typedef pair&lt;int, int&gt; PII;int n, m, k, r;string str[N];PII T[N * N];int dx[4] = {-1, 1, 0, 0};int dy[4] = {0, 0, -1, 1};bool in(int x, int y){ return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;}int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; str[i]; for(int j = 0; j &lt; m; j++) if(str[i][j] == 'g') T[r++] = {i, j}; } cin &gt;&gt; k; int t = 0, s; while(k--) { s = t, t = r; for(int i = s; i &lt; t; i++) { for(int j = 0; j &lt; 4; j++) { int tx = T[i].first + dx[j], ty = T[i].second + dy[j]; if(in(tx, ty) &amp;&amp; str[tx][ty] != 'g') str[tx][ty] = 'g', T[r++] = {tx, ty}; } } } for(int i = 0; i &lt; n; i++) cout &lt;&lt; str[i] &lt;&lt; endl; return 0;} ¶题解二：使用BFS 貌似和上面解法没区别，复杂度我认为也没什么区别。。。 第二层while循环循环上一次新增加的地方，即队列的大小，内循环结束一次，上一次队列存储的值就会清空一次，然后当前队列存储的就是本月新增的地方，外循环循环月份即可！ 可能会发生某个月份长草时，已经全部长满了，则直接退出即可，即外循环增加一个非空判断条件即可！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 使用BFS#include &lt;queue&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;typedef pair&lt;int, int&gt; PII;int n, m, k, r;string str[N];int dx[4] = {-1, 1, 0, 0};int dy[4] = {0, 0, -1, 1};bool in(int x, int y){ return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;}queue&lt;PII&gt; q;int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; str[i]; for(int j = 0; j &lt; m; j++) if(str[i][j] == 'g') q.push({i, j}); } cin &gt;&gt; k; while(!q.empty() &amp;&amp; k--) { int len = q.size(); while(len--) { PII now = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) { int tx = now.first + dx[i], ty = now.second + dy[i]; if(in(tx, ty) &amp;&amp; str[tx][ty] != 'g') { str[tx][ty] = 'g'; q.push({tx, ty}); } } } } for(int i = 0; i &lt; n; i++) cout &lt;&lt; str[i] &lt;&lt; endl; return 0;} ¶9、序列数 ¶问题描述 小明想知道，满足以下条件的正整数序列的数量： 1. 第一项为 n； 2. 第二项不超过 n； 3. 从第三项开始，每一项小于前两项的差的绝对值。 请计算，对于给定的 n，有多少种满足条件的序列。 ¶输入格式 输入一行包含一个整数 n。 ¶输出格式 输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。 ¶样例输入 14 ¶样例输出 17 ¶样例说明 以下是满足条件的序列： 4 1 4 1 1 4 1 2 4 2 4 2 1 4 3 4 4 ¶评测用例规模与约定 对于 20% 的评测用例，1 &lt;= n &lt;= 5； 对于 50% 的评测用例，1 &lt;= n &lt;= 10； 对于 80% 的评测用例，1 &lt;= n &lt;= 100； 对于所有评测用例，1 &lt;= n &lt;= 1000。 ¶题解：DFS(暴力TLE) 直接DFS最多只能算到20几的数字，但本题数据范围为1000。。。 可以暴力跑一遍所有数组，存储起来，打表输出O(1)即可。。。 正确做法或许是记忆化搜索，动态规划之类。。。 就这样吧，打表或许是最好的选择！ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;#define mod 10000using namespace std;int n, ans;void dfs(int pre, int next){ ans = (ans + 1) % mod; if(abs(pre - next) &lt;= 1) return; for (int i = 1; i &lt; abs(pre - next); i++) dfs(next, i);}int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) dfs(n, i); cout &lt;&lt; ans &lt;&lt; endl; return 0;} ¶10、选节目 ¶问题描述 小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。 这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。 小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。 小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。 ¶输入格式 输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。 第二行包含 n 个整数，依次为每个节目的好看值。 ¶输出格式 输出一行包含 m 个整数，为选出的节目的好看值。 ¶样例输入 1235 33 1 2 5 4 ¶样例输出 13 5 4 ¶样例说明 选择了第1, 4, 5个节目。 ¶评测用例规模与约定 对于 30% 的评测用例，1 &lt;= n &lt;= 20； 对于 60% 的评测用例，1 &lt;= n &lt;= 100； 对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。 ¶题解：似乎不太对 简单的觉得先按好看值从大到小排序，再按序号从小到大排序即可！ 似乎不是这么简单！ 听说用到了好多算法。。。 放过，再说吧！ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100000;struct Node{ int point, pos;};bool cmp(Node x, Node y){ return x.point &gt; y.point;}bool cmp1(Node x, Node y){ return x.pos &lt; y.pos;}int n, m;Node a[N];int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i].point, a[i].pos = i; sort(a, a + n, cmp); sort(a, a + m, cmp1); for(int i = 0; i &lt; m; i++) cout &lt;&lt; a[i].point &lt;&lt; \" \"; return 0;} ¶记录一下这垃圾的蓝桥杯校赛！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://www.itnxd.cn/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://www.itnxd.cn/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"author":"Mr.Niu"},{"title":"AcWing-112.雷达设备","slug":"AcWing-112-雷达设备","date":"2020-03-12T12:59:56.000Z","updated":"2021-02-06T14:10:17.446Z","comments":true,"path":"posts/27200.html","link":"","permalink":"https://www.itnxd.cn/posts/27200.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：112. 雷达设备 ¶题目背景： 同样是贪心问题！ ¶题目描述 假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。 每个小岛都位于海洋一侧的某个点上。 雷达装置均位于海岸线上，且雷达的监测范围为d，当小岛与某雷达的距离不超过d时，该小岛可以被雷达覆盖。 我们使用笛卡尔坐标系，定义海岸线为x轴，海的一侧在x轴上方，陆地一侧在x轴下方。 现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。 ¶输入格式 第一行输入两个整数n和d，分别代表小岛数目和雷达检测范围。 接下来n行，每行输入两个整数，分别代表小岛的x，y轴坐标。 同一行数据之间用空格隔开。 ¶输出格式 输出一个整数，代表所需的最小雷达数目，若没有解决方案则所需数目输出“-1”。 ¶数据范围 1≤n≤1000 ¶输入样例： 12343 21 2-3 12 1 ¶输出样例： 12 ¶题目分析： ¶题目要求： 简单来说，就是给一条数轴，在数轴上方有一些点（小岛），要在数轴上放置雷达，使得可以使每个点都被覆盖住！ 求达到目的的最小雷达数目！ ¶解题思路： 雷达有一个半径值，当然处于半径内则可以覆盖！ 首先先考虑一个点（x，y）,要想使得数轴上的雷达可以探测到，必须处于半径范围内，左右可以拓展的距离最大就是以点（x，y）往出拉一条雷达的半径d，与数轴的交点就是可以拓展的最大距离，即只要在[a，b] 范围内就可以保证当前点处于雷达可探测范围！ 如下图： 若发现无交点，即当前点太高，即使雷达放在正下方都够不着，超过了雷达的范围，则直接返回-1即可！ 判断条件：y &gt; d 时！够不着！ 计算区间a，b值可以利用勾股定理即可！ 这样我们可以得到每一个点的雷达取值区间，现在问题就从二维变为了一维的区间问题！ 具体解法： 我们可以给每个区间按照右端点从小到大排序！ 扫描每一个区间，看这个区间内是否有雷达？ 若没有雷达，则在当前区间右端点放置一颗雷达 若有雷达，则跳过即可 具体解释一下： 排好序后，如果前面有一个雷达则去看一下雷达有没有在当前点的区间，要知道：只有在当前点的区间内才能够得着这个点！ 为了尽可能的使放一个雷达可以最好，最大的服务后面的的点的区间，可以将每个雷达放到该点区间的右端点即可！ 既可以保证当前点被覆盖，又可以保证距离下一个点最近，达到最优的效果！ 最后的最少的雷达数就是区间上可以放置的雷达数，即进去if条件的次数！ 证明可以看一下下方yxc大神的证明！ yxc视频讲解，点击这里！ ¶题解： 下一个区间要想判断是否在雷达的左或右边，可以简单的用一个last指针来动态指向雷达的位置，若区间没有雷达，则将last置为当前区间的右端点，否则跳过即可！ 注意：因为勾股定理需要开方，所以区间使用double来存储！ 数轴是正无穷到负无穷级别的，所以将last初值赋为负无穷大！ 具体参考代码理解！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;const double INF = 1e10;struct Node{ double l, r;};bool cmp(Node a, Node b){ return a.r &lt; b.r;}int n, d;Node a[N];int main(){ cin &gt;&gt; n &gt;&gt; d; for(int i = 0, x, y; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; if(y &gt; d) { cout &lt;&lt; -1 &lt;&lt; endl; return 0; } double l = x - sqrt(d * d - y * y), r = x + sqrt(d * d - y * y); a[i] = {l, r}; } sort(a, a + n, cmp); int res = 0; double last = -INF; for(int i = 0; i &lt; n; i++) { if(a[i].l &gt; last) { res ++; last = a[i].r; } } cout &lt;&lt; res &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"AcWing-111.畜栏预定","slug":"AcWing-111-畜栏预定","date":"2020-03-10T13:22:43.000Z","updated":"2021-02-06T14:05:09.276Z","comments":true,"path":"posts/23513.html","link":"","permalink":"https://www.itnxd.cn/posts/23513.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：111. 畜栏预定 ¶题目背景： 贪心证明略过。。。 本题我在出列排序后的第一头牛时出现了问题，粗心了。。。 ¶题目描述 有N头牛在畜栏中吃草。 每个畜栏在同一时间段只能提供给一头牛吃草，所以可能会需要多个畜栏。 给定N头牛和每头牛开始吃草的时间A以及结束吃草的时间B，每头牛在[A,B]这一时间段内都会一直吃草。 当两头牛的吃草区间存在交集时（包括端点），这两头牛不能被安排在同一个畜栏吃草。 求需要的最小畜栏数目和每头牛对应的畜栏方案。 ¶输入格式 第1行：输入一个整数N。 第2…N+1行：第i+1行输入第i头牛的开始吃草时间A以及结束吃草时间B，数之间用空格隔开。 ¶输出格式 第1行：输入一个整数，代表所需最小畜栏数。 第2…N+1行：第i+1行输入第i头牛被安排到的畜栏编号，编号是从1开始的 连续 整数，只要方案合法即可。 ¶数据范围 1≤N≤50000 1≤A,B≤1000000 ¶输入样例： 12345651 102 43 65 84 7 ¶输出样例： 123456412324 ¶题目分析： ¶题目要求： 给出n头牛吃草的时间区间，问最少可以划分几个容器，使得每个容器牛吃草时间不会冲突，端点相同也算冲突！ ¶解题思路： 根据时间区间的起点排序 用小根堆维护当前容器最后一头牛吃草的结束时间 若当前牛的起始值比堆顶结束的值都大，则更新堆顶，否则，新建一个节点，存入堆！ 至于为什么这样做是对的，那就是数学问题了，我就不细说了，证明请看下方的视频讲解！ 先默认排好序后的第一头牛为第一个容器，后面的牛则从2开始循环！ 具体看题解下方的解释！ yxc大神参考题解：点击这里！ yxc视频讲解 ¶题解： ¶题解一：暴力超时TLE代码 结构体的三个变量：时间区间的开始结束和标号！ S数组存储两个值，当前容器的右端点和容器的编号，第一个变量不需要，随便写个0！ 内部for循环来找有没有可以放到同一个容器的区间，若能放到一起，则更新容器的右端点！并记录牛的容器编号！ 若没有找到可以放到一起的，则新建容器，编号++，右端点为当前牛的右端点，记录牛的编号！ 时间复杂度：O(n2) TLE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Node{ int start, end, pos;};bool cmp(Node x, Node y){ return x.start &lt; y.start;}const int N = 50010;int n, id[N];Node T[N], S[N];int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; T[i].start &gt;&gt; T[i].end, T[i].pos = i; sort(T + 1, T + 1 + n, cmp); S[1] = {0, T[1].end, 1}; int k = 1, r = 1; id[T[1].pos] = 1; for(int i = 2; i &lt;= n; i++) { bool flag = false; for(int j = 1; j &lt;= k; j++) { if(T[i].start &gt; S[j].end) { S[j].end = T[i].end; id[T[i].pos] = S[j].pos; flag = true; break; } } if(!flag) { S[++k] = {0, T[i].end, ++r}; id[T[i].pos] = r; } } cout &lt;&lt; k &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; id[i] &lt;&lt; endl; return 0;} ¶题解二：使用堆优化的AC代码 想要从已知的容器中找一个比当前牛起始端点还小的容器，则可以简化为找一个最小的即可！ 然后比较容器右端点最小的容器和当前牛的左端点比较即可！ 则变成了动态变化的容器求最小值，这不就是堆的性质吗！ 可以建立一个优先队列，即小根堆！ 每次取堆顶即可，取出来再和当前牛比较！ 同样：排好序的第一头牛初始编号为1，先放入堆，for循环从2开始！ 堆中存储两个值，第一个为右端点（动态）第二个值为容器编号！ 比堆顶还小则新建一个节点，节点编号++，压入堆中！ 否则：取出堆顶，更新右端点，压入堆中！ 最后容器个数就是堆的大小！ 时间复杂度：O(NlogN) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;struct Node{ int start, end, pos;};bool cmp(Node x, Node y){ return x.start &lt; y.start;}const int N = 50010;int n, id[N];Node T[N], S[N];priority_queue &lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; T[i].start &gt;&gt; T[i].end, T[i].pos = i; sort(T + 1, T + 1 + n, cmp); // first -&gt; end , second -&gt; pos heap.push({T[1].end, 1}); id[T[1].pos] = 1; for(int i = 2; i &lt;= n; i++) { if(T[i].start &lt;= heap.top().first) { int s = heap.size() + 1; PII t = {T[i].end, s}; id[T[i].pos] = s; heap.push(t); } else { auto t = heap.top(); heap.pop(); t.first = T[i].end; id[T[i].pos] = t.second; heap.push(t); } } cout &lt;&lt; heap.size() &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; id[i] &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"堆","slug":"堆","permalink":"https://www.itnxd.cn/tags/%E5%A0%86/"}],"author":"Mr.Niu"},{"title":"AcWing-110.防晒","slug":"AcWing-110-防晒","date":"2020-03-07T11:36:56.000Z","updated":"2021-02-06T14:11:24.220Z","comments":true,"path":"posts/10715.html","link":"","permalink":"https://www.itnxd.cn/posts/10715.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：110. 防晒 ¶题目背景： 贪心的证明就略过了，运用了大量数学知识，二分图。。。。 ¶题目描述 有C头奶牛进行日光浴，第i头奶牛需要minSPF[i]到maxSPF[i]单位强度之间的阳光。 每头奶牛在日光浴前必须涂防晒霜，防晒霜有L种，涂上第i种之后，身体接收到的阳光强度就会稳定为SPF[i]，第i种防晒霜有cover[i]瓶。 求最多可以满足多少头奶牛进行日光浴。 ¶输入格式 第一行输入整数C和L。 接下来的C行，按次序每行输入一头牛的minSPF和maxSPF值,即第i行输入minSPF[i]和maxSPF[i]。 再接下来的L行，按次序每行输入一种防晒霜的SPF和cover值,即第i行输入SPF[i]和cover[i]。 每行的数据之间用空格隔开。 ¶输出格式 输出一个整数，代表最多可以满足奶牛日光浴的奶牛数目。 ¶数据范围 1≤C,L≤2500 1≤minSPF≤maxSPF≤1000 1≤SPF≤1000 ¶输入样例： 1234563 23 102 51 56 24 1 ¶输出样例： 12 ¶题目分析： ¶题目要求： 有一些奶牛，一些防晒霜，最大可能的使更多的牛涂了防晒霜后处于需求范围内！ ¶解题思路： 将牛的区间按照左端点从大到小排序，如下图； 从上向下处理每一头牛，扫描当前区间的最大强度的防晒霜即可！ 简单解释： 第一头牛从右端点开始找起，找到的一定是在牛的区间范围内最少的，而左边的则可以满足多头牛！ 最终答案就是区间上使用了防晒霜的个数！ 用完一个就将防晒霜个数–，减到0从容器中删除！ 为了方便，使用map来存储防晒霜，由于防晒霜类型有重复，sp[spf] += cover;这里变为+=即可！ 找满足牛区间的最大值，可以使用upper_bound(x)函数 lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 找到大于右端点值时，直接–就找到了一个可能存在的防晒霜！ 若当前防晒霜在区间内，则当前牛可以满足条件，计数器++； 可参考下面题解： yxc大神参考题解：点击这里！ yxc视频讲解 ¶题解： 在这里map确实好用！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2510;struct Cow{ int first, second;};bool cmp(Cow x, Cow y){ if(x.first != y.first) return x.first &gt; y.first;}int n, m;Cow cows[N];map &lt;int, int&gt; sp;int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; cows[i].first &gt;&gt; cows[i].second; for(int i = 0; i &lt; m; i++) { int spf, cover; cin &gt;&gt; spf &gt;&gt; cover; sp[spf] += cover; } sort(cows, cows + n, cmp); int res = 0; sp[0] = sp[1001] = n; for(int i = 0; i &lt; n; i++) { // it是一个迭代器！ auto it = sp.upper_bound(cows[i].second); it --; if(it-&gt;first &gt;= cows[i].first) { res ++; it-&gt;second --; if(it-&gt;second == 0) sp.erase(it); } } cout &lt;&lt; res &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"AcWing-109.天才ACM","slug":"AcWing-109-天才ACM","date":"2020-03-07T08:44:34.000Z","updated":"2021-02-06T14:02:10.361Z","comments":true,"path":"posts/45606.html","link":"","permalink":"https://www.itnxd.cn/posts/45606.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：109. 天才ACM ¶题目背景： 又是一道好题，参考了许多题解，明白后，有因为粗心，debug了好久才AC了！ ¶题目描述 给定一个整数 M，对于任意一个整数集合 S，定义“校验值”如下: 从集合 S 中取出 M 对数(即 2∗M 个数，不能重复使用集合中的数，如果 S 中的整数不够 M 对，则取到不能取为止)，使得“每对数的差的平方”之和最大，这个最大值就称为集合 S 的“校验值”。 现在给定一个长度为 N 的数列 A 以及一个整数 T。 我们要把 A 分成若干段，使得每一段的“校验值”都不超过 T。 求最少需要分成几段。 ¶输入格式 第一行输入整数 K，代表有 K 组测试数据。 对于每组测试数据，第一行包含三个整数 N,M,T 。 第二行包含 N 个整数，表示数列A1,A2…AN。 ¶输出格式 对于每组测试数据，输出其答案，每个答案占一行。 ¶数据范围 1≤K≤12 1≤N,M≤500000 0≤T≤1018 0≤Ai≤220 ¶输入样例： 1234525 1 498 2 1 7 95 1 648 2 1 7 9 ¶输出样例： 1221 ¶题目分析： ¶题目要求： 校验值：就是每对数的差的平方之和 将一个序列分成若干段，使得每一段的校验值都不超过T，求可分成的最小段数！ 每一段要取出M对数，即2 * M 个数，取到不能取为止！ ¶解题思路： 贪心 + 归并(只用到合并) + 倍增 首先一段的校验值最大，很简单，直接排序后，取一个最大值和一个最小值，每次都去最大最小即可，这样贪心得到的校验值就是这一段的最大值！（当然不能重复取！） 如何可以使得段数尽可能的小了？ 那么一段要取多长？ 我们可以进行二分，每次都将二分得到的区间计算的到的校验值和T比较即可，然后动态的改变右端点！ 但是这样得到的区间要想计算校验值，得进行该序列的排序，用到sort，复杂度石灰超时的！ 这是可以用倍增来解决这个问题！ 要想使段数尽可能少，则要保证每一段在不超过T的情况下，尽可能的长！ 用 l 和 r 指向区间的左右端点，若区间不超过T，就进行倍增拓展长度（p），p 成倍增加，r 也要一直后移；若某次成倍增加是校验值超过T，则当前p就得成倍减少，直到p为0，此时就是说明找到了不超过T的最大长度！ 第一段开始，已排序序列b数组需要和那段倍增的长度进行拓展，需要进行排序，但是 b 数组已经有序，根本不需要去整段去排序，将倍增长度排序后，直接使用归并进行两个序列的合并，得到一个新数组即可！ 其后的每一段合并时，b数组都是排好序的，这样可以大大减少时间消耗！ b数组用来保存处理过的序列，c数组来保存每次倍增多出来的序列，temp数组来保存b和c合并后的序列！ 若当前序列不超过T，则将合并后的序列temp归还给b数组（表示处理过且当前是有序序列），返回true，右端点右移到倍增后的位置，p继续倍增！ 若当前序列超过了T，则直接返回false，此时b数组的存储没有被改变，然后p倍减！ 为什么会比二分更优化呢？ 因为每次的b数组都是有序的，不需要排序，省了很多时间！ 可以参考代码中的注释进行详细了解！ 也可以参考如下的一篇题解！ 参考题解：点击这里！ ¶题解： 注意： 校验值可能会溢出，要使用long long！ 以防倍增后使右端点溢出，使用t = min(r + p, n - 1) 来进行约束！ 每一段找到右端点后，当前段在b数组就是有序的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 5e5 + 10;int K, n, m;LL a[N], b[N], c[N], temp[N], T;// 合并 l1~r1 和 l2~r2int merge(int l1, int r1, int l2, int r2){ int i = l1, j = l2, k = 0; while(i &lt;= r1 &amp;&amp; j &lt;= r2) { if(b[i] &lt;= c[j]) temp[k++] = b[i++]; else temp[k++] = c[j++]; } while(i &lt;= r1) temp[k++] = b[i++]; while(j &lt;= r2) temp[k++] = c[j++]; return k;}// 当前l ~ r1 是有序的 bool check(int l, int r1, int r2){ // 将 r1 + 1 ~ r2(倍增序列)存储起来 for(int i = r1 + 1; i &lt;= r2; i++) c[i] = a[i]; // 排序倍增序列 sort(c + r1 + 1, c + r2 + 1); // 合并倍增序列与已排好序的序列 int len = merge(l, r1, r1 + 1, r2); // 合并后的有序序列 计算校验值 LL cnt = 0, head = 0, tail = len - 1, sum = 0; while(cnt &lt; m &amp;&amp; head &lt; tail) { sum += (temp[head] - temp[tail]) * (temp[head] - temp[tail]); head ++, tail --, cnt ++; } if(sum &gt; T) return false; else { // 小于T 将临时temp存回到b数组，此时b数组是一个有序序列 int k = 0; for(int i = l; i &lt;= r2; i++) b[i] = temp[k++]; return true; }}int main(){ cin &gt;&gt; K; while(K--) { cin &gt;&gt; n &gt;&gt; m &gt;&gt; T; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; int l = 0, r = 0, p, nes = 0, t; // 若 r 到了最后就退出 while(r &lt; n - 1) { // b 在这里每次存储一段序列的头部！r 初始指向 l, p初始倍增为1 nes统计序列段数 b[l] = a[l], r = l, p = 1, nes++; // p 为0时，即找到了序列的最大长度 while(p) { // 倍增后的右端点 t = min(r + p, n - 1); // 若此时的合并后的序列的校验值 &lt;= T 则p倍增 合并完成的右端点r后移 否则：p倍减 if(check(l, r, t)) r = t, p &lt;&lt;= 1; else p &gt;&gt;= 1; // 保证r 不超过 n - 1 说明走到了序列末 是切割的最后一段 if(r == n - 1) break; } // 下一段开始的位置 l = r + 1; } cout &lt;&lt; nes &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"归并排序","slug":"归并排序","permalink":"https://www.itnxd.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"倍增","slug":"倍增","permalink":"https://www.itnxd.cn/tags/%E5%80%8D%E5%A2%9E/"}],"author":"Mr.Niu"},{"title":"AcWing-108.奇数码问题","slug":"AcWing-108-奇数码问题","date":"2020-03-06T08:12:44.000Z","updated":"2021-02-06T13:58:45.105Z","comments":true,"path":"posts/12934.html","link":"","permalink":"https://www.itnxd.cn/posts/12934.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：108.奇数码问题 ¶题目背景： 同样是归并排序求逆序对的问题！ 参考我关于这类问题的一篇题解：AcWing-788.逆序对的数量 奇偶性很神奇，对于一类问题，如果属于同种性质（奇偶性相同），那么它们就是完全相同（这个在某种意义上说）的，一些特殊的情况又例外！ ¶题目描述 你一定玩过八数码游戏，它实际上是在一个3×3的网格中进行的,1个空格和1~8这8个数字恰好不重不漏地分布在这3×3的网格中。 例如： 1235 2 81 3 _4 6 7 在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。 例如在上例中，空格可与左、上、下面的数字交换，分别变成： 1235 2 8 5 2 _ 5 2 81 _ 3 1 3 8 1 3 74 6 7 4 6 7 4 6 _ 奇数码游戏是它的一个扩展，在一个n×n的网格中进行，其中n为奇数，1个空格和1~n2−1这n2−1个数恰好不重不漏地分布在n×n的网格中。 空格移动的规则与八数码游戏相同，实际上，八数码就是一个n=3的奇数码游戏。 现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。 ¶输入格式 多组数据，对于每组数据： 第1行输入一个整数n，n为奇数。 接下来n行每行n个整数，表示第一个局面。 再接下来n行每行n个整数，表示第二个局面。 局面中每个整数都是0~n2−1之一，其中用0代表空格，其余数值与奇数码游戏中的意义相同，保证这些整数的分布不重不漏。 ¶输出格式 对于每组数据，若两个局面可达，输出TAK，否则输出NIE。 ¶数据范围 1≤n&lt;500 ¶输入样例： 1234567891031 2 30 4 67 5 81 2 34 5 67 8 0100 ¶输出样例： 12TAKTAK ¶题目分析： ¶题目要求： 询问是不是可以将一个矩阵中的空位 _ 通过上下左右交换变成另一个矩阵！ ¶解题思路： 先来一个结论： 奇数码游戏两个局面可达，当且仅当两个局面下网格中的数依次写成1行n*n-1个元素的序列后(不考虑空格)，逆序对个数的奇偶性相同！ 空格左右移动时，写成的序列显然不变; 空格向上(下)移动时，相当于某个数与它后(前)边的n-1个数交换了位置，因为n-1是偶数，所以逆序对数的变化也只能是偶数。 该结论的充分性证明较为复杂，我们将不在此大篇幅讨论这样一个 数学问题。 可以参考下面这位同学的简单证明！ 我之前的题解：归并求逆序对！点击这里！ 参考题解：点击这里！ ¶题解： 同样：使用long long，以防溢出！ 判断同奇同偶性，可以直接相减的绝对值对2取余即可，若为0，则是同类，若不为0则是一奇一偶！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 510;int a[N * N], temp[N * N], n, k;LL sum, suma, sumb;void merge_sort(int l, int r){ if(l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(l, mid), merge_sort(mid + 1, r); int i = l, j = mid + 1, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else { temp[k++] = a[j++]; sum += mid - i + 1; } } while(i &lt;= mid) temp[k++] = a[i++]; while(j &lt;= r) temp[k++] = a[j++]; for(int i = l, j= 0; i &lt;= r; i++, j++) a[i] = temp[j];}int main(){ while(cin &gt;&gt; n) { sum = 0, k = 0; for(int i = 0, x; i &lt; n * n; i++) { cin &gt;&gt; x; if(x) a[k++] = x; } merge_sort(0, n * n - 1); suma = sum; sum = 0, k = 0; for(int i = 0, x; i &lt; n * n; i++) { cin &gt;&gt; x; if(x) a[k++] = x; } merge_sort(0, n * n - 1); sumb = sum; if(abs(suma - sumb) % 2) cout &lt;&lt; \"NIE\" &lt;&lt; endl; else cout &lt;&lt; \"TAK\" &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"归并排序","slug":"归并排序","permalink":"https://www.itnxd.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"逆序对","slug":"逆序对","permalink":"https://www.itnxd.cn/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"奇偶性","slug":"奇偶性","permalink":"https://www.itnxd.cn/tags/%E5%A5%87%E5%81%B6%E6%80%A7/"}],"author":"Mr.Niu"},{"title":"AcWing-107.超快速排序","slug":"AcWing-107-超快速排序","date":"2020-03-06T03:58:14.000Z","updated":"2020-05-19T02:24:12.351Z","comments":true,"path":"posts/8382.html","link":"","permalink":"https://www.itnxd.cn/posts/8382.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：107. 超快速排序 ¶题目背景： 又是归并排序求逆序对的问题！ 参考我关于这类问题的一篇题解：AcWing-788.逆序对的数量 ¶题目描述 在这个问题中，您必须分析特定的排序算法----超快速排序。 该算法通过交换两个相邻的序列元素来处理n个不同整数的序列，直到序列按升序排序。 对于输入序列9 1 0 5 4，超快速排序生成输出0 1 4 5 9。 您的任务是确定超快速排序需要执行多少交换操作才能对给定的输入序列进行排序。 ¶输入格式 输入包括一些测试用例。 每个测试用例的第一行输入整数n，代表该用例中输入序列的长度。 接下来n行每行输入一个整数ai,代表用例中输入序列的具体数据，第i行的数据代表序列中第i个数。 当输入用例中包含的输入序列长度为0时，输入终止，该序列无需处理。 ¶输出格式 对于每个需要处理的输入序列，输出一个整数op，代表对给定输入序列进行排序所需的最小交换操作数，每个整数占一行。 ¶数据范围 0≤N&lt;500000 0≤ai≤999999999 ¶输入样例： 123456789101159105431230 ¶输出样例： 1260 ¶题目分析： ¶题目要求： 就是求逆序对的数目，遇到0结束输入！ ¶解题思路： 同样是归并排序再求逆序对的数目： sum += mid - i + 1; 详细题解看类似的题目下面这篇我之前写的题解！ AcWing-788.逆序对的数量 ¶题解： 注意：以防越界，全部改为long long！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 500010;LL a[N], temp[N];LL n, sum;void merge_sort(int l, int r){ if(l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(l, mid), merge_sort(mid + 1, r); int i = l, j = mid + 1, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else { temp[k++] = a[j++]; sum += mid - i + 1; } } while(i &lt;= mid) temp[k++] = a[i++]; while(j &lt;= r) temp[k++] = a[j++]; for(int i = l, j= 0; i &lt;= r; i++, j++) a[i] = temp[j];}int main(){ while(cin &gt;&gt; n &amp;&amp; n) { sum = 0; for(int i = 0, x; i &lt; n; i++) cin &gt;&gt; a[i]; merge_sort(0, n - 1); cout &lt;&lt; sum &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"归并排序","slug":"归并排序","permalink":"https://www.itnxd.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"逆序对","slug":"逆序对","permalink":"https://www.itnxd.cn/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"}],"author":"Mr.Niu"},{"title":"AcWing-106.动态中位数","slug":"AcWing-106-动态中位数","date":"2020-03-05T10:38:26.000Z","updated":"2021-02-15T05:21:21.415Z","comments":true,"path":"posts/3455.html","link":"","permalink":"https://www.itnxd.cn/posts/3455.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：106. 动态中位数 ¶题目背景： 让两个堆来构建一个有序序列，找到中位数，优先队列的优先就是用堆结构实现的！ ¶题目描述 依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数。 ¶输入格式 第一行输入一个整数P，代表后面数据集的个数，接下来若干行输入各个数据集。 每个数据集的第一行首先输入一个代表数据集的编号的整数。 然后输入一个整数M，代表数据集中包含数据的个数，M一定为奇数，数据之间用空格隔开。 数据集的剩余行由数据集的数据构成，每行包含10个数据，最后一行数据量可能少于10个，数据之间用空格隔开。 ¶输出格式 对于每个数据集，第一行输出两个整数，分别代表数据集的编号以及输出中位数的个数（应为数据个数加一的二分之一），数据之间用空格隔开。 数据集的剩余行由输出的中位数构成，每行包含10个数据，最后一行数据量可能少于10个，数据之间用空格隔开。 输出中不应该存在空行。 ¶数据范围 1≤P≤1000 1≤M≤9999 ¶输入样例： 1234567893 1 9 1 2 3 4 5 6 7 8 9 2 9 9 8 7 6 5 4 3 2 1 3 23 23 41 13 22 -3 24 -31 -11 -8 -7 3 5 103 211 -311 -45 -67 -73 -81 -99 -33 24 56 ¶输出样例： ¶12345671 51 2 3 4 52 59 8 7 6 53 1223 23 22 22 13 3 5 5 3 -3 -7 -3 ¶题目分析： ¶题目要求： 输入一串数，在输入奇数位时，输出当前序列的中位数！ ¶解题思路： 本人的暴力做法： 每次输入一个数，就使用sort来拍一下序，为奇数位时，输出当前的中位数！ 看看时间复杂度：1e3 * 1e4 * NlogN 大概已经1e11 绝对TLE！ 更优的做法：使用对顶堆 时间复杂度：1e3 * 1e4 * logN 似乎是这样！不太会分析复杂度。。。 使用两个堆结构：大根堆和小根堆，且必须时刻满足这两个条件！ 大根堆：序列中从小到大排序为 1 ~ M / 2 个数存储到大根堆 小根堆：序列中从小到大排序为 M + 1~ M 个数存储到大根堆 始终保证大根堆元素小于小于等于小根堆，小根堆元素大于等于大根堆元素个数！ 输入一个数先进行存储，若比中位数小，存储到大根堆，比中位数大存储到小根堆！ 倘若不符合上面两个条件： 需要进行多的给少的，达到上面的限制条件即可！ 为什么要这样限制了？ 看一下这张图： 会发现每次插入结束后，只要保证右边大于等于左边，就可以轻而易举得到中位数，就是小根堆的堆顶！ 如果是偶数个数，则左右是相等个数，若为奇数，则右边一定会多一个！ 以这几个数举例：没有9时，则中位数为5？不对吧，没关系，题目要求在奇数个数时去找中位数，所以右边一定比左边多1，这时，也就是有9的时候，中位数就是5，没毛病！ 大根堆的堆顶为4，小根堆的堆顶为5 ! 具体实现请看下方代码！ 李煜东的视频讲解，大概在45分钟的时候！ ¶题解： ¶题解一：本人的纯暴力做法！（TLE） 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int a[N], b[N];int p, q, n;int main(){ cin &gt;&gt; p; while(p --) { cin &gt;&gt; q &gt;&gt; n; int k = 0; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; sort(a + 1, a + 1 + i); if(i &amp; 1) b[k++] = a[i + 1 &gt;&gt; 1]; } cout &lt;&lt; q &lt;&lt; \" \" &lt;&lt; k &lt;&lt; endl; for(int i = 0; i &lt; k; i++) { if(i % 10 == 0 &amp;&amp; i) cout &lt;&lt; endl; cout &lt;&lt; b[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } return 0;} ¶题解二：使用对顶堆（大根堆和小根堆）（AC） 注意：将第一个数直接插入小根堆，毕竟要保证右边大于等于左边！ 在清空堆的时候，由于没有clear函数，只能使用循环去删除达到空容器效果，或者直接赋值一个空容器，建议使用赋值方法！简单明了，vector可以直接使用clear函数清空！ 关于优先队列： 默认为大根堆，要使用小根堆得如代码这样写，很明显第三个参数为排序函数！ 12priority_queue &lt;int&gt; big, kong1; // 大根堆priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; small, kong2; // 小根堆 ¶具体代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int p, q, n;vector &lt;int&gt; v, kongV;priority_queue &lt;int&gt; big, kong1; // 大根堆priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; small, kong2; // 小根堆int main(){ cin &gt;&gt; p; while(p --) { cin &gt;&gt; q &gt;&gt; n; int k = 0; big = kong1, small = kong2, v.clear(); for(int i = 1, x; i &lt;= n; i++) { cin &gt;&gt; x; if(small.empty()) { small.push(x); v.push_back(x); continue; } if(x &gt;= small.top()) small.push(x); else big.push(x); if(big.size() &gt; small.size()) { small.push(big.top()); big.pop(); } else if(small.size() - big.size() &gt; 1) { big.push(small.top()); small.pop(); } if(i &amp; 1) v.push_back(small.top()); } cout &lt;&lt; q &lt;&lt; \" \" &lt;&lt; v.size() &lt;&lt; endl; for(int i = 0; i &lt; v.size(); i++) { if(i % 10 == 0 &amp;&amp; i) cout &lt;&lt; endl; cout &lt;&lt; v[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"中位数","slug":"中位数","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"name":"priority_queue","slug":"priority-queue","permalink":"https://www.itnxd.cn/tags/priority-queue/"},{"name":"堆","slug":"堆","permalink":"https://www.itnxd.cn/tags/%E5%A0%86/"}],"author":"Mr.Niu"},{"title":"AcWing-122.糖果传递","slug":"AcWing-122-糖果传递","date":"2020-03-05T10:37:38.000Z","updated":"2020-05-19T02:33:51.181Z","comments":true,"path":"posts/58067.html","link":"","permalink":"https://www.itnxd.cn/posts/58067.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：122. 糖果传递 ¶题目背景： 又是一道环形的均分纸牌问题，这也是这类题的一个基础的经典的例题了！ 我先做的 七夕祭 这道题，一个二维的环形均分纸牌问题，比这个复杂一点。。 ¶题目描述 有n个小朋友坐成一圈，每人有a[i]个糖果。 每人只能给左右两人传递糖果。 每人每次传递一个糖果代价为1。 求使所有人获得均等糖果的最小代价。 ¶输入格式 第一行输入一个正整数n，表示小朋友的个数。 接下来n行，每行一个整数a[i]，表示第i个小朋友初始得到的糖果的颗数。 ¶输出格式 输出一个整数，表示最小代价。 ¶数据范围 1≤n≤1000000 数据保证一定有解。 ¶输入样例： 1234541254 ¶输出样例： 14 ¶题目分析： ¶题目要求： n个人围成一圈，没人有一些糖果，问最少交换多少次会达到均等时的最小步数！ 传递一个糖果代价为1！ ¶解题思路： 同样是环形均分纸牌问题，里面的公式推导就不再推了，请看我的上一篇题解： AcWing-105.七夕祭 接下来总结一下环形纸牌问题： 第一步：将原值减去平均值 第二步：求当前的前缀和 第三步：将前缀和排序 此时转化为了货仓问题 第四部：求中位数 第五步：求 abs(b[i] - mid) 的和 ¶题解： 小技巧：求前缀和时，输入从下标为1开始，方便后序求前缀和等等！ 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1e6 + 10;LL a[N], b[N];int main(){ int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], a[0] += a[i]; for(int i = 1; i &lt;= n; i++) b[i] = b[i - 1] + a[i] - a[0]/n; sort(b + 1, b + 1 + n); LL sum = 0, mid = b[n + 1 &gt;&gt; 1]; for(int i = 1; i &lt;= n; i++) sum += abs(b[i] - mid); cout &lt;&lt; sum &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"前缀和","slug":"前缀和","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"中位数","slug":"中位数","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"AcWing-105.七夕祭","slug":"AcWing-105-七夕祭","date":"2020-03-04T10:51:43.000Z","updated":"2021-02-06T13:59:26.982Z","comments":true,"path":"posts/47007.html","link":"","permalink":"https://www.itnxd.cn/posts/47007.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：105. 七夕祭 此题为了理解折腾了一下午，写题解又写了一晚上！终于完整的记录了下来 ¶题目背景： 本题运用了大量的数学公式化简，以及中位数性质等等，我会在题目分析当中进行详细介绍和解释！ ¶题目描述 七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。 于是TYVJ今年举办了一次线下七夕祭。 Vani同学今年成功邀请到了cl同学陪他来共度七夕，于是他们决定去TYVJ七夕祭游玩。 TYVJ七夕祭和11区的夏祭的形式很像。 矩形的祭典会场由N排M列共计N×M个摊点组成。 虽然摊点种类繁多，不过cl只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。 Vani预先联系了七夕祭的负责人zhq，希望能够通过恰当地布置会场，使得各行中cl感兴趣的摊点数一样多，并且各列中cl感兴趣的摊点数也一样多。 不过zhq告诉Vani，摊点已经随意布置完毕了，如果想满足cl的要求，唯一的调整方式就是交换两个相邻的摊点。 两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。 由于zhq率领的TYVJ开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。 现在Vani想知道他的两个要求最多能满足多少个。 在此前提下，至少需要交换多少次摊点。 ¶输入格式 第一行包含三个整数N和M和T，T表示cl对多少个摊点感兴趣。 接下来T行，每行两个整数x, y，表示cl对处在第x行第y列的摊点感兴趣。 ¶输出格式 首先输出一个字符串。 如果能满足Vani的全部两个要求，输出both； 如果通过调整只能使得各行中cl感兴趣的摊点数一样多，输出row； 如果只能使各列中cl感兴趣的摊点数一样多，输出column； 如果均不能满足，输出impossible。 如果输出的字符串不是impossible， 接下来输出最小交换次数，与字符串之间用一个空格隔开。 ¶数据范围 1≤N,M≤100000 0≤T≤min(N∗M,100000) 1≤x≤N 1≤y≤M ¶输入样例： 123452 3 41 32 12 22 3 ¶输出样例： 1row 1 ¶题目分析： ¶题目要求： 就是 n 行 m 列的构成的 n * m 个交叉点，输入 t 个点的坐标，询问是否能使得每行的点数相同，每列的点数相同，若能相同，输出最小交换步数！ 交换方法：上下左右交换，还有一个特殊的交换：每一行或每一列的第一个可以和每一行或每一列的最后一个交换，即可以看成环形的状态！ ¶解题思路： 首先：想一个问题：什么情况才能让行或列所占点数相同？ 很明显，行或列点数和只有是行或列的倍数时才可以。这样才可以平分，对吧！ 答案前半部分很好判断，后半部分最小步数不太好判断！ 接着：在想一个问题，在做行与行间点的交换时，即上下交换，会发现，上下交换是不会影响列的数目变化，毕竟上下交换，一定在那一列，那一列总和不会变！ 同理：在做列与列的点的交换时，即左右交换，会发现，左右交换是不会影响行的数目变化，毕竟左右交换，一定在那一行，那一行总和不会变！ 所以本题可以分为两个部分，一个行，一个列，分别取处理！毕竟不会互相影响！ 这个题和均分纸牌问题类似： 读者可能已经想到了一个与此类似的经典问题“均分纸牌”。“均分. 纸牌”问题是说，有M个人排成一行，他们手中分别有C[1]~C[M]张纸牌，在每一 步操作中，可以让某个人把自己手中的一张纸牌交给他旁边的一个人，求至少需要多少步操作才能让每个人手中持有的纸牌数相等。 显然，“ 均分纸牌”问题当所有人手中持有的纸牌总数T能被M整除时有解。 我们这样想：假如可以均分，即最后牌数一样多时： 第一个人为了达到目标平均值 T/M ,要将多出来的 C[1] - T/M 给了第二个人，第二个人此时有 C[2] + C[1] - T/M张牌。 假如第一个人不够 T/M 张牌需要去第二个人处借 T/M - C[1]张牌，此时第二个人有C[2] + T/M - C[1]张牌。 终上：第一个人要想达到T/M张牌，必须去和下一个人借或给！结束之后第一个人变成了T/M张牌，发生的交换次数为|C[1] - T/M|次 第二个人当前的牌数为： C[2] + (C[1] - T/M) 为了达到T/M张牌，必须去和下一个人借或给！则要做 |C[2] + (C[1] - T/M) - T/M|次交换！ 化简一下可以得到：第i个人需要交换次数为 |C[i] + C[i - 1] +…C[1] - i * T/M| 次交换！ 最终交换次数就是将其求和即可！ 会发现每一项都有一个前缀和：令G[i] 为C[i] 的前缀和，即最终次数变成了： |G[i] - i* T/M| ：i 从 1到M求和即可！ 注意：不用考虑某个人变为负数啥的，因为最终他都会去想后面的人来补齐！这就是拆东墙补西墙，但是不一样的是，这个最终会都补好！ 继续：将每个人的初始牌数都减去T/M，得到相对于平均值的一些正负数，要想使得最终相等，那么每个人都得相对于平均值为0，即都是平均值才可以！ 假设：令 A[i] = C[i] - T/M 此时第一个人需要交换次数为|A[1]| 第二个人为|A[2] + A[1]| 第i个人为|A[i] + A[i - 1] … + A[1]| 令S[i] 为A[i] 的前缀和，则： 第i个人交换次数为：|S[i]| 所以最终次数变为了：|S[i]| ，i从1到M求和！ 到了这里，题目就简单多了！普通均分纸牌就结束了！ 回归本题：这道题就是在均分纸牌的条件上，多了一个首和尾可以交换！成为了环形均分纸牌： 首先给出一个结论： 最优解下，一定存在两个人没有进行交换 如下图： 图：2号标错了，标在紧挨3号的位置才对。。。懒得换了！ 假如发生了这样的交换，1号和2后都在给三号，我们要的是交换次数最少，最优！那么为什么不把2号到3号的直接砍断，让1号给三号多一点，给另一方少一点，这样不就可以减少交换次数吗？ 没毛病，这样就反证了刚刚的结论！ 现在我们只需要枚举在哪里有两个人没有发生交换即可！ 假设发生在k处！ 上面的那个求和公式则是在1号和M号之间断开了！即：|S[i]| ，i从1到M求和！ 发生在K处的话，前缀和S[i]会发生什么变化： 如图： 我们可以将1~M的长条进行多条拼接，即可得到在任意处砍断的完整长条，假设在K处砍断：前缀和发什么什么变化？ S[k + 1] -----------&gt; S[k + 1] +( S[M] - S[k]) （可以在左边再延长一条线看出来） S[k] ---------------&gt; 0 S[1] ---------------&gt; S[1] + (S[M] - S[k]) S[i] ---------------&gt; S[i] + (S[M] - S[k]) 然后又因为S[i] 是A[i] = C[i] - T/M 的前缀和，叨叨S[M]时，前面的都已经变为0了，即达到T/M了，最后一个人则自动达成最终的T/M，所以最后一项一定是0，不需要发生交换！ 所以原式子：|S[i]| ，i从1到M求和！ 有了砍断部分的加入则变成了|S[i] - S[M]| - S[k]| 因为S[M]为0，则最终变为：|S[i] - S[k]| 最终交换次数为：|S[i] - S[k]| i从1到M求和 现在就是要找到砍断的地方，使得，这个式子求和和值最小！ 看这个式子的几何意义：就是k到各个前缀和的距离，此时，没有什么点数，牌数，已经转变为了一个个前缀和，就像一个个条形的柱子，想统计学的柱形图一样，在中间找一个地方，使得到左右柱子的距离和最短！ 眼熟吗？ 这不就是刚刚做过的AcWing-104. 货仓选址 吗？ 砍断处 k 相当于货仓位置，s[i] 相当于各个商店位置！ 什么时候距离最小呢？ 参考货仓选址的中位数证明！ 所以只要将 砍断处选在 中位数的位置即可达到最优解！ 本题解完毕！ 可以看《算法竞赛进阶指南》的作者李煜东的讲解视频：大概在29分钟的时候！ ¶题解： 注意：要用long long，数据很大！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;int n, m, t;int a[N], b[N], f[N];LL calc(int c[], int n){ // c[i]--&gt;A[i] = C[i] - T/M // f[i]--&gt;S[i] 为A[i]前缀和 for(int i = 1; i &lt;= n; i++) c[i] -= c[0]/n, f[i] = f[i - 1] + c[i]; sort(f + 1, f + 1 + n); LL mid = f[n + 1 &gt;&gt; 1]; LL res = 0; //求 |S[i] - S[k]| 的和 for(int i = 1; i &lt;= n; i++) res += abs(f[i] - mid); return res;}int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for(int i = 1, x, y; i &lt;= t; i++) { cin &gt;&gt; x &gt;&gt; y; a[x] ++, b[y] ++; } for(int i = 1; i &lt;= n; i++) a[0] += a[i]; for(int i = 1; i &lt;= m; i++) b[0] += b[i]; int row = a[0] % n, col = b[0] % m; if(!row &amp;&amp; !col) cout &lt;&lt; \"both \" &lt;&lt; calc(a, n) + calc(b, m) &lt;&lt; endl; else if(!row) cout &lt;&lt; \"row \" &lt;&lt; calc(a, n) &lt;&lt; endl; else if(!col) cout &lt;&lt; \"column \" &lt;&lt; calc(b, m) &lt;&lt; endl; else cout &lt;&lt; \"impossible\"; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"前缀和","slug":"前缀和","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"中位数","slug":"中位数","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"字符串-字典序问题","slug":"字符串-字典序问题","date":"2020-03-04T09:36:10.000Z","updated":"2020-05-19T02:35:41.191Z","comments":true,"path":"posts/65259.html","link":"","permalink":"https://www.itnxd.cn/posts/65259.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶题目背景： ¶题目描述 在数据加密和数据压缩中常需要对特殊的字符串进行编码。给定的字母表A由26个小写英文字母组成A={a,b,…,z}。该字母表产生的升序字符串是指字符串中字母按照从左到右出现的次序与字母在字母表中出现的次序相同，且每个字符最多出现1次。例如，a,b,ab,bc,xyz等字符串都是升序字符串。现在对字母表A产生的所有长度不超过6的升序字符串按照字典序排列并编码如下。 1 2 … 26 27 28 … a b … z ab ac … 对于任意长度不超过6的升序字符串，迅速计算出它在上述字典中的编码。 ¶算法设计： 对于给定的长度不超过6的升序字符串，计算出它在上述字典中的编码。 ¶输入格式 第一行是一个正整数k，表示接下来共有k行。 接下来的k行中，每行给出一个字符串。 ¶输出格式 输出共有k行，每行对应于一个字符串的编码。 ¶数据范围 1≤n≤100000 ¶输入样例： 1232aab ¶输出样例： 12127 ¶题目分析： ¶题目要求： 输入一个字典序字符串，输出对应的编号，注意没有aa，abccd，后面的一定比前面的大！ ¶解题思路： 先举一个例子：假如输入 cdfg ，要怎么计算了？ 先看长度为字符串长度的处理： c开头的一定排在a和b开头的后面，我们可以先算出a打头的长度为4的字符串有多少个，用C(26 - 1, 4 - 1) 表示从25个字符中组合3长度的组合种类！这句话是不是相当于C 325 了，即数学中的排列组合的组合，这样既可保证不重不漏，还可以保证字典序正确！ a完了，还有b开头的长度为4的字符串种类，即C(26 - 2, 4 - 1) ab完了，到了c，很明显，c不需要处理 往后移动，到了d的位置，c的下一个就是d，不需要处理 下一个f，会发现f一定在e开头的长度为2的字符串之后，所以需要继续统计,即C(26 - 5 , 4 - 3) 继续发现下一个是g，这也是最后一个，就简单了，不需要用到组合，g一定在a之后，最后直接累加一下a ~ g的编号即可！ 再看长度小于字符串长度的处理： 很明显：我们处理完毕了字符串本身长度的排序，还没有处理，在自身长度之下，长度为1 ~ len - 1 的长度，不过这就更加简单了！ 长度为1：C(26, 1) 长度为2：C(26, 2) 长度为len - 1：C(26, len - 1); 参考一篇题解：点击这里！ ¶题解： ¶注意： for循环处理到长度-1位置即可，最后需要单独处理字符串长度为len时的最后一位与a的差值！ 这个是关系式，可以好好看看！ sum += C(26 - 1 - (ch - 'a'), len - i - 1); 注意：while 退出去后：ch还得继续++ ！ 最后一位与a的编号差值： sum += str[len - 1] - ch + 1; ¶具体代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;int N;// 计算组合数LL C(LL num, LL len){ LL res = 1, t = 1; for(int i = 0; i &lt; len; i++) res *= num, num --; for(int i = len; i &gt;= 1; i--) t *= i; return res / t;} int main(){ cin &gt;&gt; N; string str; while(N--) { cin &gt;&gt; str; LL sum = 0; int len = str.size(); char ch = 'a'; for(int i = 0; i &lt; len - 1; i++) { sum += C(26, i + 1);// 累计字符串长度为1~len-1序号 while(str[i] &gt; ch) // 累计字符串长度为len时的每一位字符 { sum += C(26 - 1 - (ch - 'a'), len - i - 1); ch ++; } ch ++; } // 累计字符串长度为len时最后一位 sum += str[len - 1] - ch + 1; cout &lt;&lt; sum &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"字典序","slug":"字典序","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E5%85%B8%E5%BA%8F/"},{"name":"组合数","slug":"组合数","permalink":"https://www.itnxd.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"AcWing-104.货仓选址","slug":"AcWing-104-货仓选址","date":"2020-03-03T04:19:38.000Z","updated":"2021-02-06T13:55:51.642Z","comments":true,"path":"posts/57916.html","link":"","permalink":"https://www.itnxd.cn/posts/57916.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：104. 货仓选址 ¶题目背景： 贪心，贪的我很服。。。 ¶题目描述 在一条数轴上有 N 家商店，它们的坐标分别为 A1~AN。 现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。 为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。 ¶输入格式 第一行输入整数N。 第二行N个整数A1~AN。 ¶输出格式 输出一个整数，表示距离之和的最小值。 ¶数据范围 1≤N≤100000 ¶输入样例： 1246 2 9 1 ¶输出样例： 112 ¶题目分析： ¶题目要求： 有N个商店，要求放一个仓库使得到所有商店的距离和最小，输出最小值！ ¶解题思路： 第一想法就是暴力扫描一遍，选出最小值即可！但是超时了，数据范围为1e5，平方就是1e10，肯定超时，详见题解一的代码： 正确思路： 先排序，使其变成一条链状的情况！ 把a[0] ~ a[N-1]排序，设货仓在X坐标处，X左侧的商店有P家，右侧的商店有Q家。若P &lt; Q，则每把仓库的选址向右移动1单位距离，距离之和就会变少Q - P.同理，若P &gt; Q，则仓库的选址向左移动会使距离之和变小。当P==Q时为最优解。 结合图片，红色的圈表示商店，蓝色的箭头表示仓库的所在地： 第一种情况：左边的商店数目小于右边时，往右移动，则左边的都要加一，右边的都要减一，而右边的多，所以最终距离和会变小！ 第二种情况：左边的商店数目大于右边时，往左移动，则左边的都要减一，右边的都要加一，而左边的多，所以最终距离和会变小！ 第三种情况：第一种情况左移，和第二种情况右移，会发现最终都是变大的！ 总结：仓库的位置一定不在靠左，也不在靠右，因为，如果在两边，都会有更优的地方，可以取到最小值！所以中间一定是最优的地方； 也就是上图的红色箭头处，五个仓库取中间即可！ 分一下奇偶数情况，都进行取中位数即可，即仓库从N个商店中找一个中间商店，若为偶数则随便即可！我们统一选择偶数时编号小的那个：即res = n- 1 &gt;&gt; 1 一篇好理解一点的题解：点击这里！ ¶题解： ¶题解一：（TLE）超时代码 时间复杂度：O(N2) 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int a[N], b[N], k;int main(){ int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); int res = 0x3f; for(int i = a[0]; i &lt; a[n - 1]; i++) { int sum = 0; for(int j = 0; j &lt; n; j++) { sum += abs(i - a[j]); } b[k++] = sum; } sort(b, b + k); cout &lt;&lt; b[0] &lt;&lt; endl; return 0;} ¶题解二：选取中位数为仓库处 时间复杂度：O(N) 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int a[N];int main(){ int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); int int sum = 0; for(int i = 0; i &lt; n; i++) sum += abs(a[res] - a[i]); cout &lt;&lt; sum &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"AcWing-102.最佳牛围栏","slug":"AcWing-102-最佳牛围栏","date":"2020-03-01T14:36:13.000Z","updated":"2020-05-18T13:54:01.940Z","comments":true,"path":"posts/35910.html","link":"","permalink":"https://www.itnxd.cn/posts/35910.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：102. 最佳牛围栏 ¶题目背景： 一道难题，前缀和，差分，双指针的叠加应用！ ¶题目描述 农夫约翰的农场由 N 块田地组成，每块地里都有一定数量的牛,其数量不会少于1头，也不会超过2000头。 约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。 围起区域内至少需要包含 F 块地，其中 F 会在输入中给出。 在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。 ¶输入格式 第一行输入整数 N 和 F ，数据间用空格隔开。 接下来 N 行，每行输出一个整数，第i+1行输出的整数代表，第i片区域内包含的牛的数目。 ¶输出格式 输出一个整数，表示平均值的最大值乘以1000再 向下取整 之后得到的结果。 ¶数据范围 1≤N≤100000 1≤F≤N ¶输入样例： 123456789101110 66 4210385941 ¶输出样例： 16500 ¶题目分析： ¶题目要求： 给了N块地，每块地有一些牛，现在想让你在1 ~ N 块地里，连续的选取大于 f 块地，使得得到的平均数最大！ 输出最大的平均值！ ¶解题思路： 首先说一下我的思路：（TLE） 因为数据是10的五次方，我用的是O(N)的做法，那就是10的10次方了，远远大于C++一秒可以计算的次数了！ 我就是暴力找一遍！ 先计算前缀和，为了以后用的时候方便！然后用两重for循环去找，一个在区间左端点，一个在右端点，为了保证区间长度大于f，如解法一的两重for 循环的循环变量设置！每次取一个最大值即可，当然，它超时了！ 现在开始正确的O(NlogN)的做法： 二分思想： 那么我们判断是否存在一个平均值大于等于mid，如果最优解是x，那么mid &lt;= x的时候，必然可以找到一段，其平均值≥mid， 否则 一定找不到！ 就是说最终的答案那个平均值，一定在1 ~ 2000头牛之间，我们用二分，从mid开始，如果发现mid是可以合法的，那么一定有大于mid的平均值可以作为最后答案，也就是一定有一个从mid开始的一个长度&gt;=f的区间可以达到更大的平均值！所以区间开始一步步缩小，为了达到乘1000向下取值，精度就得达到1e-4左右，为了保险将精度压到1e-5！ 在平均值check时，可以将原值都减去传入的二分平均值mid，最后再进行前缀和！这时看一个区间平均值就可以直接看前缀和是不是大于0，大于0则平均值大于mid，反之，小于mid！ 如果可选区间有一个大于mid的区间，那么，最终答案一定大于mid，在主函数内部进行二分区间的缩小，往后移动即可！ 此处有一个即可，有一个，只要有就行，只要有就可以使得mid成立，即最终结果一定比mid大，区间要后移！有就行，那么当然要选择最小的，sum[j] - minv &gt;= 0 要想使这个式子成立，只要使得minv为可选区间最小即可，只要成立一种就行，用最小的岂不是更方便！ 接下来就是区间的变化，i,j始终保持f的距离！然后sum[j] - minv &gt;= 0 可以看到这个区间的长度一定是大于f的，可以画个图去理解！ 可以结合下面某位大神的题解： 我们要找的是 有没有一段不小于F的区间，使这段区间的平均数尽可能的大，**如果我们找到了一段连续的区间且区间长度不小于F且平均数大于我们二分的平均数 ，**那么大于这个数的区间也一定满足了， 我们直接返回true！ 因为我们要找一段区间的平均数，根据平均数的一个基本应用，显而易见，对于一段序列，每个数减去我们所算的平均数，如果大于0 那么他本身就大于平均数，如果小于0 那么它本身就小于平均数， 此时我们就能算出哪些数大于0 哪些数小于0 ，之后我们再使用前缀和，就能判断一个区间内的平均值是否大于或小于我们二分的平均数了！ 我们还可以继续优化，因为我们不仅需要找F大小区间内，我们还要找＞F大小区间内的，我们如果用二次for太费时间了，我们这里可以使用双指针的做法，我们设i=0,j=F ，每次使两个数++ ，因为i,j始终满足相距F的距离，所以我们用一个变量minv来存储i所遍历到的最小值，这样我们比较的距离一定是≥F的，并且如果我们用j位的前缀和数减去minv的话，就能得到我们的最优解，如果这个最优解＞= 0 那么就满足我们的指定条件，即可以得到平均值大于min的取值，返回true！ yxc大神的视频讲解：点击这里！ 一篇好理解一点的题解：点击这里！ ¶题解： ¶解法一：本人的暴力超时做法！（TLE） 时间复杂度：O(N2) 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N = 100010;int g[N], n, f;int main(){ cin &gt;&gt; n &gt;&gt; f; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; g[i]; g[i] += g[i - 1]; } double res = 0; for(int r = f; r &lt;= n; r++) { for(int l = 1; l &lt;= r - f + 1; l++) { double t = (g[r] - g[l - 1])/(r - l + 1.0); res = max(res, t); } } res *= 1000; printf(\"%.0lf\\n\", res); return 0;} ¶解法二：使用二分，前缀和，双指针的yxc大神的AC做法！ 好好看看代码，可以结合上面的题解与上面附出的大神的视频！ 注意：r 要取最大牛，输入时用来max函数，其实不取最大值，直接带入2000也可以，但取最大值更加精准！ 可能的最大值 ：题目最后这样写的！即要输出极大值，很明显r 最终一定比l大，所以最后要输出 r , 而不是 l ，输出 l 的话，其值一定会比 r 小！ 这里sum数组的变化是不需要处理的，数组每次其实都是重新复制去覆盖的，不用担心上一下会影响到下一次！ cow[i] - avg：可以看成整体，将每一位数都减去平均值！ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;const int N = 100010;int cow[N];double sum[N]; int n, f;bool check(double avg){ for(int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + cow[i] - avg; double minv = 0; for(int i = 0, j = f; j &lt;= n; i++, j++) { minv = min(minv, sum[i]); if(sum[j] - minv &gt;= 0) return true; } return false;}int main(){ cin &gt;&gt; n &gt;&gt; f; double l = 0, r = 0; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; cow[i], r = max(r, (double)cow[i]); while(r - l &gt; 1e-5) { double mid = (l + r) / 2; if(check(mid)) l = mid; else r = mid; } cout &lt;&lt; int(r * 1000) &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"前缀和","slug":"前缀和","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"},{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"AcWing-101.最高的牛","slug":"AcWing-101-最高的牛","date":"2020-03-01T08:44:34.000Z","updated":"2020-05-18T13:54:01.937Z","comments":true,"path":"posts/63414.html","link":"","permalink":"https://www.itnxd.cn/posts/63414.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：101. 最高的牛 ¶题目背景： 差分应用！ ¶题目描述 有 N 头牛站成一行，被编队为1、2、3…N，每头牛的身高都为整数。 当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。 现在，我们只知道其中最高的牛是第 P 头，它的身高是 H ，剩余牛的身高未知。 但是，我们还知道这群牛之中存在着 M 对关系，每对关系都指明了某两头牛 A 和 B 可以相互看见。 求每头牛的身高的最大可能值是多少。 ¶输入格式 第一行输入整数N,P,H,M，数据用空格隔开。 接下来M行，每行输出两个整数 A 和 B ，代表牛 A 和牛 B 可以相互看见，数据用空格隔开。 ¶输出格式 一共输出 NN 行数据，每行输出一个整数。 第 ii 行输出的整数代表第 ii 头牛可能的最大身高。 ¶数据范围 1≤N≤10000 1≤H≤1000000 1≤A,B≤10000 0≤M≤10000 ¶输入样例： 1234569 3 5 51 35 34 33 79 8 ¶输出样例： 123456789545344555 ¶注意： 此题中给出的关系对可能存在重复 ¶题目分析： ¶题目要求： n头牛，给出多组互相可以看见的牛，求所有牛的最大高度是多少？ 并且，如果两头牛可以互相看到，则两头牛中间的牛的高度一定小于两端的高度！ ¶解题思路： 了解一个性质： 可不可能有两组可看到的牛发生重合，例如：（3, 8），（5, 11），很明显不可能，5要比8小，才能使得3和8看见；5还要比8大，才能使得5和11看见，很明显，已经矛盾了！ 所以所有的组数，都不会有覆盖，只可能是嵌套，所以假设原高度都是h，如果当前牛在区间内则必须得减一，才能保证互相看到，假如另一组数据正好包围当前数据，那么由于传递性，最外面要比中间的高，所以中间得减一，最内部还得减一！ 这是就可以用到差分序列了，如果假设原数组高度都是h，则差分序列： g[1] = h；剩下的都是0。即可！ 给区间-1操作： g[a + 1] --, g[b] ++; 可以画一下看看！ 最后为了得到牛的高度，即将差分序列再转回前缀和序列即可！ yxc大神的视频讲解：点击这里！ ¶题解： 注意：a，b大小，逆序时交换一下，方便！ 注意：可能有重复数据，则判断一下，防止多减一操作！ 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;const int N = 10010;int g[N];bool visit[N][N];int main(){ int n, p, h, m; cin &gt;&gt; n &gt;&gt; p &gt;&gt; h &gt;&gt; m; g[1] = h; for(int i = 0, a, b; i &lt; m; i++) { cin &gt;&gt; a &gt;&gt; b; if(a &gt; b) swap(a, b); if(!visit[a][b]) { visit[a][b] = true; g[a + 1] --; g[b] ++; } } for(int i = 1; i &lt;= n; i++) { g[i] += g[i - 1]; cout &lt;&lt; g[i] &lt;&lt; endl; } return 0;} 更好一点的话：可以使用set集合来代替数组，毕竟set具有极快的查找速度！ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int N = 10010;int g[N];int main(){ int n, p, h, m; cin &gt;&gt; n &gt;&gt; p &gt;&gt; h &gt;&gt; m; g[1] = h; set&lt;pair&lt;int, int&gt;&gt; s; for(int i = 0, a, b; i &lt; m; i++) { cin &gt;&gt; a &gt;&gt; b; if(a &gt; b) swap(a, b); if(!s.count({a, b})) { s.insert({a, b}); g[a + 1] --; g[b] ++; } } for(int i = 1; i &lt;= n; i++) { g[i] += g[i - 1]; cout &lt;&lt; g[i] &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"差分序列","slug":"差分序列","permalink":"https://www.itnxd.cn/tags/%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97/"}],"author":"Mr.Niu"},{"title":"AcWing-100.增减序列","slug":"AcWing-100-增减序列","date":"2020-03-01T06:24:16.000Z","updated":"2020-05-18T13:54:01.937Z","comments":true,"path":"posts/41483.html","link":"","permalink":"https://www.itnxd.cn/posts/41483.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：100. 增减序列 ¶题目背景： 前缀和和差分序列是互逆的！ 题目分析处详细解释！ ¶题目描述 给定一个长度为 n 的数列 a1,a2,…,an，每次可以选择一个区间 [l,r]，使下标在这个区间内的数都加一或者都减一。 求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。 ¶输入格式 第一行输入正整数n。 接下来n行，每行输入一个整数，第i+1行的整数代表ai。 ¶输出格式 第一行输出最少操作次数。 第二行输出最终能得到多少种结果。 ¶数据范围 0&lt;n≤105 0≤ai&lt;2147483648 ¶输入样例： 1234541122 ¶输出样例： 1212 ¶题目分析： ¶题目要求： 在一个序列内任意选择区间，将区间内的数都进行加一或减一操作，使得最后的序列数字都一样，问对少步数和达到最少步数的方法总数！ ¶解题思路： 先引入差分： a数组是普通序列，b数组是a数组的差分序列！ 差分序列定义：b[i] = a[i] - a[i-1], b[1] = a[1] 然后就是两个定理： b 序列是 a 序列的差分序列（定义就是这样定义的！） a 序列是 b 序列的前缀和序列（开始证明！） a[i] 可以写为 b[1] + b[i]：如下： 123456a[1],a[2],.…a[n]b[i] = a[i] - a[i-1], b[1] = a[1]a[i] = b[1] + b[2] +.…+ b[i] = a[1] + a[2] - a[1] + a[3] - a[2] +.…+ a[i] - a[i-1] = a[i] 证明成立！ 接下来开始看题！ 在一个(L，R)序列上加一个常数 C，相当于： 1b[L] += C b[R + 1] -= C; 这个可以稍微想一下：或者那笔画一下！ 假设序列从下标为1开始存储！ 再想一下：要想全部数变成同样的数，可以让b数组变成什么样？ 当然是让 b[1] ~ b[n] 都为0，也就是整个序列此时都是 a[1] ，即 n 个 a[1]！ 首先先将差分序列处理出来，我们可以想，既然是区间的端点出进行加一或减一，那么，让一个正数去–，一个负数去++是不是可以更快的达到为0的目的！ 所以可以将差分序列的正数和负数都累加一下计算出来！得到两个值！ 这样的话：选取一个区间就会使累积的正数（假如是40）和一个负数（假如是34）减一，这样直到其中一方为0，这样正负数匹配就结束了，可能剩下的多出来的一方（不为0的）就需要和b[0]或b[n + 1]来处理。 正负匹配需要最少为 34次，即min(34, 40) 多出来的最少需要 40 - 34 次，即abs(34 - 40) 或者直接这样想，一次就需要正负减1，全部处理完，自然就是最大的数了！就是40次，直接max(34, 40) 所以最少次数为：min(34, 40) + abs(34 - 40) = max(34, 40) 以及最后的方案数： min(34, 40)是死的，最后不一样的就是多出来的（不为0的）的数的方案，即 abs(40- 34) + 1 ！ yxc大神的视频讲解：点击这里！ ¶题解： 讲解是下标从1开始，我是从0开始，都一样的！ 防止溢出，使用 long long！ 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;int n;int a[N], b[N];int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt; n; i++) b[i] = a[i] - a[i - 1]; // positive number, negative number LL pos = 0, neg = 0; for(int i = 0; i &lt; n; i++) if(b[i] &gt; 0) pos += b[i]; else neg -= b[i]; cout &lt;&lt; max(pos, neg) &lt;&lt; endl &lt;&lt; abs(pos - neg) + 1 &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"差分序列","slug":"差分序列","permalink":"https://www.itnxd.cn/tags/%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97/"}],"author":"Mr.Niu"},{"title":"AcWing-99.激光炸弹","slug":"AcWing-99-激光炸弹","date":"2020-02-29T14:07:26.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/26178.html","link":"","permalink":"https://www.itnxd.cn/posts/26178.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：99. 激光炸弹 ¶题目背景： ¶题目描述 地图上有 N 个目标，用整数Xi,Yi表示目标在地图上的位置，每个目标都有一个价值Wi。 注意：不同目标可能在同一位置。 现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有的目标。 激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和x，y轴平行。 若目标位于爆破正方形的边上，该目标不会被摧毁！ 求一颗炸弹最多能炸掉地图上总价值为多少的目标。 ¶输入格式 第一行输入正整数 N 和 R ,分别代表地图上的目标数目和正方形的边长，数据用空格隔开。 接下来N行，每行输入一组数据，每组数据包括三个整数Xi,Yi,Wi,分别代表目标的x坐标，y坐标和价值，数据用空格隔开。 ¶输出格式 输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。 ¶数据范围 0≤ R ≤109 0&lt; N ≤10000 0≤ Xi,Yi ≤5000 0≤ Wi ≤1000 ¶输入样例： 1232 10 0 11 1 1 ¶输出样例： 11 ¶题目分析： ¶题目要求： 就是在一个地图上放一个边长为 r 正方形，最后要输出这个正方形扣住的区域权值最大的值！ 注意：正方形的边上的不算！ ¶解题思路： 首先引入一维前缀和： 作用：可以在O(1)的时间内求出某一段区间的和！ 举个例子： a[1]、a[2] … a[n] 引入s[i]前缀和： s[i] = s[0]…+s[i] 加入求a[7] ~ a[40] 那么就等于s[40] - s[6]！ 接着引入二维前缀和： 就是变成了一个坐标： 首先给出递归式：s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; 画个图：紫色的自己加上红色和绿色构成的矩形，再加上另一个红色和绿色构成的矩形，在减去多加的绿色部分！ 接下来开始预处理前缀和，在输入是让x和y都加了1，这样在预处理时，不会出现负数下标，免得处理边界问题！ 由于每个点不止一个目标：所以数组要进行累加：g[x][y] += w; 接下来开始划分边长为R的矩形，要保证边长足够，所以i和j 最小也得从R开始，此时的(i, j) 指向的是矩形的右下角，这样可以保证不越界！ 递推式：g[i][j] - g[i - r][j] - g[i][j - r] + g[i - r][j - r] 很好理解的：此时的(i , j)表示的行和列，即第i行第j列！ 如下图： 假如：r = 2,要计算 g[3][3]为右下角时，需要减去画那两道红线所构成的两个矩形，再加上多减掉的交叉部分，这样剩下的就是从青绿色右下角开始的四个蓝色的圈，这样看来，得到的结果就不是R 边长了，而是R- 1的边长，这样也就可以保证边上的不被计算！ 为什么不把右边和下边两条边也删掉了？ 我看了好久！才发现： 不能删，删掉上和左就够了！ 你可以在脑袋里想一下，将那个矩形在图上飘起来，会发现盖住的部分最多就是那四个蓝色的圈！而R - 1 就可以实现边上的不记录效果！ 好好理解一下，可能有点绕！ yxc大神视频讲解：点击这里！ ¶题解： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;const int N = 5010;int g[N][N];int main(){ int s, r; cin &gt;&gt; s &gt;&gt; r; // 题目R的数据有点问题，怎么可能比坐标最大还打，所以约束一下 r = min(r, 5010); int n = 5010; for(int i = 0, x, y, w; i &lt; s; i++) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; x ++, y ++; g[x][y] += w; } // 预处理前缀和 for(int i = 1; i &lt; n; i++) for(int j = 1; j &lt; n; j++) g[i][j] += g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1]; // 找到（i，j）为矩形右下角 int res = 0; for(int i = r; i &lt; n; i++) for(int j = r; j &lt; n; j++) res = max(res, g[i][j] - g[i - r][j] - g[i][j - r] + g[i - r][j - r]); cout &lt;&lt; res &lt;&lt; endl; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"二维前缀和","slug":"二维前缀和","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"}],"author":"Mr.Niu"},{"title":"AcWing-96.奇怪的汉诺塔","slug":"AcWing-96-奇怪的汉诺塔","date":"2020-02-29T09:44:12.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/34850.html","link":"","permalink":"https://www.itnxd.cn/posts/34850.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：96. 奇怪的汉诺塔 ¶题目背景： ¶题目描述 汉诺塔问题，条件如下： 1、这里有A、B、C和D四座塔。 2、这里有n个圆盘，n的数量是恒定的。 3、每个圆盘的尺寸都不相同。 4、所有的圆盘在开始时都堆叠在塔A上，且圆盘尺寸从塔顶到塔底逐渐增大。 5、我们需要将所有的圆盘都从塔A转移到塔D上。 6、每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。 请你求出将所有圆盘从塔A移动到塔D，所需的最小移动次数是多少。 汉诺塔塔参考模型 ¶输入格式 没有输入 ¶输出格式 对于每一个整数n(1≤n≤121≤n≤12),输出一个满足条件的最小移动次数，每个结果占一行。 ¶输入样例： 1没有输入 ¶输出样例： 1参考输出格式 ¶题目分析： ¶题目要求： 此题是三根柱子汉诺塔的变形，现在有四根棍子，需要输出n 为1 到12的最小移动次数即可！ ¶解题思路： 先介绍一下三根棍子情况：不论有多少个碟子，都可看为这几步： 将前n - 1 个盘子移到第二个棍子 再将最底下的1个盘子移到第三个棍子 再将n - 1个盘子移到第三个棍子 所以得到递推式：d[n] = d[n - 1] + 1 + d[n - 1]; 初始值为d[1] = 1; 再看一下四根棍子的情况：不论多少个盘子，都可以看为这几步： 将前 i 个盘子移到第二个棍子 再将剩下的n - i 个盘子移到第三个棍子 再将 前 i 个盘子移到第四根棍子 所以得到递归式：f[n] = f[i] + d[n - i] + f[i]; 初始值为f[0] = 0； 前i 个盘子有 j种情况！每次取一个min函数即可！ 至于为什么是d[n - 1]，可以这样想，将前 i 个移走后，第二根柱子就死了，不能再用了，所以可以看做是三根棍子，第二步就变为了三根棍子的情况！ yxc大神的视频讲解：点击这里！ ¶题解： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int d[20], f[20];int main(){ d[1] = 1; for(int i = 2; i &lt;= 12; i++) d[i] = d[i - 1] + 1 + d[i - 1]; memset(f, 0x3f, sizeof f); f[0] = 0; for(int i = 1; i &lt;= 12; i++) for(int j = 0; j &lt; i; j++) f[i] = min(f[i], f[j] + d[i - j] + f[j]); for(int i = 1; i &lt;= 12; i++) cout &lt;&lt; f[i] &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"Dp","slug":"Dp","permalink":"https://www.itnxd.cn/tags/Dp/"},{"name":"递推","slug":"递推","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E6%8E%A8/"}],"author":"Mr.Niu"},{"title":"AcWing-95.费解的开关","slug":"AcWing-95-费解的开关","date":"2020-02-29T08:39:12.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/18232.html","link":"","permalink":"https://www.itnxd.cn/posts/18232.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：95.费解的开关 ¶题目背景： ¶题目描述 你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态 123451011101101101111000011011 在改变了最左上角的灯的状态后将变成： 123450111111101101111000011011 再改变它正中间的灯后状态将变成： 123450111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。 ¶输入格式 第一行输入正整数n，代表数据中共有n个待解决的游戏初始状态。 以下若干行数据分为nn组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。 ¶输出格式 一共输出n行数据，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。 对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。 ¶数据范围 0&lt;n≤500 ¶输入样例： 1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 ¶输出样例： 12332-1 ¶题目分析： ¶题目要求： 给定一个 5 x 5 的矩阵，想要全部变成1，求最少的步数，并且改变一个上下左右都换变化！ ¶解题思路： 我们可以一层一层去想，先看第一层，如果第一层有 0， 我们需要在下一层的正下方的那个点作为中心改变状态即可，使上面的0变为1,；同样，第一层结束，要想使第二层也全变为1，做法一样，使有0 的正下方作为中心改变即可；最终只需要判断改变了前四行后，第五行有没有全部变为1即可，若没有变为1，则此种情况并不合法。 第一层的变化自然是有2的五次方，仍然想成二进制来表示，只需枚举这些所有情况即可，将可达到最终状态的最小值找出来即可！ 也就是说，如果只考虑第一层，他的开关方法有2的五次方，最终可以使最后一层全部变为1的就是一组解！ 注意：本题输入是没有空格的，我以为有空格，用int来存储的，结果出了问题，可以使用char数组来存储即可！ 为了方便的复制一份g数组，使用的cstring头文件的memcpy函数！ memcpy()函数： 第一个参数：备份数组 第二个参数：原数组 第三个参数：用sizeof计算的大小 在进行0,1取反时，直接和1异或即可！ char类型的 0 和 1 也可以：对应的ASCII码分别为48和49，二进制如下： 110000 110001 异或后结果没有问题！ yxc大神的视频讲解：点击这里！ ¶题解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;char g[10][10];char backup[10][10];int dx[5] = {0, -1, 1, 0, 0}, dy[5] = {0, 0, 0, -1, 1};bool in(int x, int y){ return x &gt;= 0 &amp;&amp; x &lt; 5 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 5;}// 改变五个值void turn(int x, int y){ for(int i = 0; i &lt; 5; i++) { int a = x + dx[i], b = y + dy[i]; if(in(a, b)) g[a][b] ^= 1; }}int solve(){ int ans = 0x3f; //二进制的1来表示按那个灯 for(int i = 0; i &lt; 1 &lt;&lt; 5; i++) { int res = 0; // 扫描第一层按过的开关，并进行修改 for(int j = 0; j &lt; 5; j++) { if(i &gt;&gt; j &amp; 1) { res ++; turn(0, j); } } // 扫描前四层 for(int j = 0; j &lt; 4; j++) { for(int k = 0; k &lt; 5; k++) { if(g[j][k] == '0') { res ++; turn(j + 1, k); } } } // 扫描最后一层 bool flag = true; for(int j = 0; j &lt; 5; j++) if(g[4][j] == '0') { flag = false; break; } // 还原g数组的状态 memcpy(g, backup, sizeof g); if(flag) ans = min(ans, res); } if(ans &gt; 6) return -1; return ans;}int main(){ cin &gt;&gt; n; while(n --) { for(int i = 0; i &lt; 5; i++) cin &gt;&gt; g[i]; memcpy(backup, g, sizeof g); cout &lt;&lt; solve() &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"递推","slug":"递推","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E6%8E%A8/"},{"name":"位运算","slug":"位运算","permalink":"https://www.itnxd.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"author":"Mr.Niu"},{"title":"AcWing-94.递归实现排列型枚举","slug":"AcWing-94-递归实现排列型枚举","date":"2020-02-28T13:10:57.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/45388.html","link":"","permalink":"https://www.itnxd.cn/posts/45388.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：94. 递归实现排列型枚举 ¶题目背景： ¶题目描述 把 1~n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。 ¶输入格式 一个整数n。 ¶输出格式 按照从小到大的顺序输出所有方案，每行1个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。 ¶数据范围 1≤n≤9 ¶输入样例： 13 ¶输出样例： ¶1234561 2 31 3 22 1 32 3 13 1 23 2 1 ¶题目分析： ¶题目要求： 全排列，字典序小的在前！ ¶解题思路： 具体看代码以及注释和介绍！ ¶题解： ¶题解一：最普通的递归： 不解释了！没什么说的，极易理解！ 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; using namespace std;int n;int a[10];bool visit[10];void dfs(int u){ if(u == n) { for(int i = 0; i &lt; n ; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = 1; i&lt;= n; i++) { if(!visit[i]) { a[u] = i; visit[i] = true; dfs(u + 1); visit[i] = false; } }}int main(){ cin &gt;&gt; n; dfs(0); return 0;} ¶题解二：yxc大神的使用vector的版本 auto 是C++ 11 的新特性，要想编译通过，需要在编译器设置好！具体百度！ 和上面注释掉的for循环是一样的！ 用state存储二进制状态，u表示当前枚举到的数，退出条件：u == n 时！ dfs结束后记得还原vector的状态！ 12345678910111213141516171819202122232425262728293031323334#include &lt;vector&gt;#include &lt;iostream&gt; using namespace std;int n;vector&lt;int&gt; v;void dfs(int u, int state){ if(u == n) { //for(int i = 0; i &lt; v.size() ; i++) cout &lt;&lt; v[i] &lt;&lt; \" \"; for(auto x : v) cout &lt;&lt; x &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = 1; i&lt;= n; i++) { if(!(state &gt;&gt; i &amp; 1)) { v.push_back(i); dfs(u + 1, state | 1 &lt;&lt; i); v.pop_back(); } }}int main(){ cin &gt;&gt; n; dfs(0, 0); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"}],"author":"Mr.Niu"},{"title":"AcWing-93.递归实现组合型枚举","slug":"AcWing-93-递归实现组合型枚举","date":"2020-02-28T11:17:32.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/53888.html","link":"","permalink":"https://www.itnxd.cn/posts/53888.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：93. 递归实现组合型枚举 ¶题目背景： 递归实现，看完本篇你大概将知道递归转化为非递归方法！ ¶题目描述 从 1~n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。 ¶输入格式 两个整数 n,m ,在同一行用空格隔开。 ¶输出格式 按照从小到大的顺序输出所有方案，每行1个。 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。 ¶数据范围 n&gt;0 0≤m≤n n+(n−m)≤25 ¶输入样例： 15 3 ¶输出样例： 123456789101 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5 思考题：如果要求使用非递归方法，该怎么做呢？ ¶题目分析： ¶题目要求： ¶解题思路： 一篇好理解的题解，点击这里！ ¶题解： ¶题解一：最普通的递归： 不解释了！ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt; using namespace std;const int N = 30;int n, m;int a[N];bool visit[N];void dfs(int k, int t, int m){ if(k == m) { for(int i = 0; i &lt; k; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = t + 1; i &lt;= n; i++) { if(!visit[i]) { a[k] = i; visit[i] = true; dfs(k + 1, i, m); visit[i] = false; } }}int main(){ cin &gt;&gt; n &gt;&gt; m; dfs(0, 0, m); return 0;} ¶题解二：这是错误的。。 题目要求最后要按字典序输出，如果用上次的二进制表示，结果没问题，但是顺序是乱的！没有规律的！ Go Out！ 123456789101112131415161718192021222324#include &lt;iostream&gt; using namespace std;int n, m;int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; 1 &lt;&lt; n; i++) { int k = 0; for(int j = 0; j &lt; n; j++) if(i &gt;&gt; j &amp; 1) k++; if(k == m) { for(int t = 0; t &lt; n; t++) if(i &gt;&gt; t &amp; 1) cout &lt;&lt; t + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; } } return 0;} ¶题解三：yxc大神的递归，以及递归转非递归： 递归容易爆栈，有时候需要使用非递归！ 递归仍然和上一题一样，稍微修改一下，多一个计数器，如果sum + 后面可以取到的数的最大位数 n - u， 还达不到 要求的m为，直接return；后面为了输出按照字典序，要换一下dfs选与不选的顺序，至于为什么（自己大脑稍微模拟一下过程即可）。 接下来就是，转化为非递归的做法，将递归的过程分为三部分，如图上所标示的： pos 为0，为1，为2，三种状态！ 使用State结构体存储状态，多一个pos来标识当前处于的状态： 将初状态鸭压入栈中：stk.push({0, 0, 0, 0}); 进入while循环来判断三种状态： pos = 0，将递归的那一段写进去，改一下变量，将return改为continue，然后将当前状态改为1，压入栈中，将状态0的最后一句dfs也压入栈中。 pos = 1，将当前状态改为2，压入栈中，将状态1的那一句dfs也压入栈中。 pos = 2， 直接continue。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stack&gt;#include &lt;iostream&gt; using namespace std;struct State{ int pos, u, sum, state; };int n, m;void dfs(int u, int sum, int state){ // pos = 0 if(sum + n - u &lt; m) return; if(sum == m) { for(int i = 0; i &lt; n; i++) if(state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt;\" \"; cout &lt;&lt; endl; return; } dfs(u + 1, sum + 1, state | 1 &lt;&lt; u); // pos = 1 dfs(u + 1, sum, state); // pos = 2}int main(){ cin &gt;&gt; n &gt;&gt; m; //dfs(0, 0, 0); stack&lt;State&gt; stk; stk.push({0, 0, 0, 0}); while(stk.size()) { State t = stk.top(); stk.pop(); if(t.pos == 0) { if(t.sum + n - t.u &lt; m) continue; if(t.sum == m) { for(int i = 0; i &lt; n; i++) if(t.state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; continue; } t.pos = 1; stk.push(t); stk.push({0, t.u + 1, t.sum + 1, t.state | 1 &lt;&lt; t.u}); } else if(t.pos == 1) { t.pos = 2; stk.push(t); stk.push({0, t.u + 1, t.sum, t.state}); } else continue; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"},{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"}],"author":"Mr.Niu"},{"title":"AcWing-92.递归实现指数型枚举","slug":"AcWing-92-递归实现指数型枚举","date":"2020-02-28T09:02:35.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/14886.html","link":"","permalink":"https://www.itnxd.cn/posts/14886.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：92. 递归实现指数型枚举 ¶题目背景： 多种做法！ ¶题目描述 从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。 ¶输入格式 输入一个整数n。 ¶输出格式 每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。 ¶数据范围 1≤n≤15 ¶输入样例： 13 ¶输出样例： 12345678322 311 31 21 2 3 ¶题目分析： ¶题目要求： 输出任任意位的组合（从小到大），包括0位组合（即输出空行），不限制输出顺序！ ¶解题思路： 详见下方四种解法： 一篇好理解的题解，点击这里！ ¶题解： 注意：选择0位也是一种情况，千万别忘记！要输出一个空行！ ¶解法一：本人能想到的最粗糙的做法： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt; using namespace std;const int N = 15;int n, b[N];bool flag[N];void dfs(int k, int cnt, int pos){ if(cnt &gt;= k) { for(int i = 0; i &lt; k; i++) cout &lt;&lt; b[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = pos + 1; i &lt;= n; i++) { if(!flag[i]) { b[cnt] = i; flag[i] = true; dfs(k, cnt + 1, i); flag[i] = false; } }}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt;= n; i++) dfs(i, 0, 0); return 0;} ¶解法二：使用二进制优化： 和之前做过的类似：将每一位的选择变成0和1的二进制即可，和直接使用数组存储（解法一）不一样的点： 添加第 i 位时：state |= 1 &lt;&lt;(i - 1); 最后还要恢复原状态：state ^= 1 &lt;&lt; (i - 1); 用到了异或和按位或，不懂的去学习一下！ 为何数组不需要恢复状态，而二进制需要恢复状态？ 因为数组存储时时从下标为0开始存储，一次dfs结束后，会进入下一次for循环，此时，数组存储的下标仍然是cnt，没有变化，即进行了覆盖，不会影响； 然而：使用二进制就不一样了，二进制存储的是每一位的状态，没有下标的关系，如果不进行恢复状态，下一次for循环可不是数组的原位覆盖，而是在新的地方置为了1，这样state状态就会多一位被选择的数，造成错误答案！ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; using namespace std;const int N = 15;int n, b[N];bool flag[N];void dfs(int state, int k, int cnt, int pos){ if(cnt &gt;= k) { for(int i = 0; i &lt; n; i++) if(state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = pos + 1; i &lt;= n; i++) { if(!flag[i]) { state |= 1 &lt;&lt;(i - 1); flag[i] = true; dfs(state, k, cnt + 1, i); flag[i] = false; state ^= 1 &lt;&lt; (i - 1); } }}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt;= n; i++) dfs(0, i, 0, 0); return 0;} ¶解法三：状态压缩非递归 类似于第二种解法：用state来存储二进制集合，当然共有 2 n种，然后第二层for循环直接去从第0位开始扫描即可，遇到1 就输出，遇到0就跳过即可！ 本人最喜欢这种做法，既好理解又简洁！推荐！！！ 1234567891011121314151617181920#include &lt;iostream&gt; using namespace std;const int N = 15;int n, state[N];bool flag[N];int main(){ cin &gt;&gt; n; for(int state = 0; state &lt; 1 &lt;&lt; n; state++) { for(int j = 0; j &lt; n; j++) if(state &gt;&gt; j &amp; 1) cout &lt;&lt; j + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; } return 0;} ¶解法四：状态压缩递归形式（来自yxc大神） 也就是第三种解法的递归写法，仍然是每一位数都有两种选择，选与不选，所以，此处的dfs的两个参数，第一个代表当前扫描到了哪一位，state表示当前状态的二进制为情况！ 两种状态： dfs(u + 1, state); ：不选，state 没有进行改变！ dfs(u + 1, state | (1 &lt;&lt; u)); ：选择，state 已经将 u + 1加入到了state中！ 退出条件，扫描到最后一项时进行输出和判断！ 总而言之：就像是一个二叉搜索树，都有选与不选两种情况，答案则在最后的叶子节点上！ 1234567891011121314151617181920212223242526#include &lt;iostream&gt; using namespace std;const int N = 15;int n;void dfs(int u, int state){ if(u == n) { for(int i = 0; i &lt; n; i++) if(state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; return; } dfs(u + 1, state); dfs(u + 1, state | (1 &lt;&lt; u));} int main(){ cin &gt;&gt; n; dfs(0, 0); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"二进制","slug":"二进制","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://www.itnxd.cn/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}],"author":"Mr.Niu"},{"title":"AcWing-91.最短Hamilton路径","slug":"AcWing-91-最短Hamilton路径","date":"2020-02-27T11:19:09.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/30496.html","link":"","permalink":"https://www.itnxd.cn/posts/30496.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：91. 最短Hamilton路径 ¶题目背景： 这对我来说是一道难题，经过我一直理解，看题解，看yxc大神视频，反复多次，一点点的，终于明白了这个思想并且可以自己独立写出来！ 坚持！反复！终将成功！ 此题，时间限制为 3s ！ ¶题目描述 给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。 ¶输入格式 第一行输入整数n。 接下来n行每行n个整数，其中第ii行第jj个整数表示点ii到jj的距离（记为a[i,j]）。 对于任意的x,y,z 数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]&gt;=a[x,z]。 ¶输出格式 输出一个整数，表示最短Hamilton路径的长度。 ¶数据范围 1 ≤ n ≤ 20 0 ≤ a[i,j] ≤ 10 7 ¶输入样例： 12345650 2 4 5 12 0 6 5 34 6 0 8 35 5 8 0 51 3 3 5 0 ¶输出样例： ¶118 ¶题目分析： ¶题目要求： 给了n个点，以及n个点之间的权，要求出从起点到终点的最短路径，并且要不重不漏的走一遍！ ¶解题思路： 当然最容易想到的就是直接暴力枚举，但是，n的范围为20，暴力的话会达到20的阶乘，这绝对超过了C++一秒计算可达到的次数，虽然题目是三秒，但是和常数相比，还是远远不够的！ 所以要用到状态压缩： 即所有点都有两种状态，选或不选，可以用0,1来表示（二进制），这样，所有的情况就是最大就是220 , 这远比阶乘要小。 举个例子：假如有8个点，选择 0,1,5,6 时，当前状态可以表示为：01100011。 状态转移方程为：dp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; j)][k] + weight[k][j]); i 不是一个数，它表示的是二进制，即2的n次方中的一种情况； j 表示的是，当前的终点； 首先：当前状态的终点为 j 为，要想计算当前值，需要拿当前值 和 刨去 第 j 位后的状态中找一个走过的点 k,即 dp[i - (1 &lt;&lt; j)][k] 在加上要到j 的终点 weight[k][j]) ,就是一个完整的路径，然后将当前状态的所有情况（即k 的取值情况）与 已知dp[i][j] 取一个min即可！ 最终答案当然就是求：dp[(1 &lt;&lt; n) - 1][n - 1] 即 dp[111..共n个1..111] 表示n个点全部走过来，第二维的 n - 1则是说终点是 最后一个点！ 要想保住是从第0个点开始，就要保证二进制的第0位永远为1，即保证他是个奇数； j 的取值当然要保证在 当前 i 的状态内，即 i &gt;&gt; j &amp; 1 用这个来判断！ k 作为中间量，当然要保证当前状态 i 刨去 j 后 k 仍然在 i 的状态内，才能进行与第三者的连接！即 i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1 ！ 最终进行状态转移方程：dp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; j)][k] + weight[k][j]); 位运算不太清楚可以百度一下学习！ yxc大神的视频讲解，点击这里！ 一篇好理解的题解，点击这里！ ¶题解： 加快速度的办法：使用二进制，并且转态压缩本就是用二级制来存储转态的，所以可以提高速度！ 注意：要将dp数组初始化为极大值！ 12345678910111213141516171819202122232425262728293031#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1 &lt;&lt; 20;int n, weight[21][21];int dp[N][21];int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) cin &gt;&gt; weight[i][j]; memset(dp, 0x3f, sizeof dp); dp[1][0] = 0; for(int i = 0; i &lt; 1 &lt;&lt; n; i++) if(i &amp; 1) for(int j = 0; j &lt; n; j++) if(i &gt;&gt; j &amp; 1) for(int k = 0; k &lt; n; k++) if(i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) dp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; j)][k] + weight[k][j]); cout &lt;&lt; dp[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"二进制","slug":"二进制","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"状压Dp","slug":"状压Dp","permalink":"https://www.itnxd.cn/tags/%E7%8A%B6%E5%8E%8BDp/"},{"name":"最短路","slug":"最短路","permalink":"https://www.itnxd.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"author":"Mr.Niu"},{"title":"AcWing-90.64位整数乘法","slug":"AcWing-90-64位整数乘法","date":"2020-02-27T06:00:36.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/39845.html","link":"","permalink":"https://www.itnxd.cn/posts/39845.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：90. 64位整数乘法 ¶题目背景： ¶题目描述 求 a 乘 b 对 p 取模的值。 ¶输入格式 第一行输入整数a，第二行输入整数b，第三行输入整数p。 ¶输出格式 输出一个整数，表示a*b mod p的值。 ¶数据范围 1≤a,b,p≤1018 ¶输入样例： 123345 ¶输出样例： 12 ¶题目分析： ¶题目要求： 两个十八位数相乘，然后模十八位数！ ¶解题思路： 直接算肯定会超出数据类型的最大范围，所以不能直接算！ 使用高精度乘法去算，显然可以，但是没必要，本题不需要最后结果，需要的是模p 的结果，所以可以借助快速幂思想： 参考这里：AcWing-89.a ^ b 类似的：十八位数乘法会溢出，那么加法肯定不会溢出，所以就是要将乘法转化为加法： a * b a + a + a + a + a + a + a … + a a * 1 = 1a a * 2 = 2a a * 4 = 4a a * 8 = 8a … 和之前一样同样是倍增思想！ 快速幂是一个平方，这个就是一直乘2即可！ yxc大神的视频讲解：点击这里！ ¶题解： 注意：unsigned long long 的范围是C++最大的 unsigned int 0～4294967295 int -2147483648～2147483647 unsigned long 0～4294967295 long -2147483648～2147483647 long long的最大值：9223372036854775807（19位） long long的最小值：-9223372036854775808 unsigned long long的最大值：18446744073709551615 （20位） 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;typedef unsigned long long ULL;ULL a, b, p;ULL res;int main(){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; while(b) { if(b&amp;1) res = (res + a) % p; b &gt;&gt;= 1; a = a * 2 % p; } cout &lt;&lt; res &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"快速幂","slug":"快速幂","permalink":"https://www.itnxd.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}],"author":"Mr.Niu"},{"title":"AcWing-89.a ^ b","slug":"AcWing-89-a^b","date":"2020-02-27T04:34:36.000Z","updated":"2020-06-14T01:05:01.986Z","comments":true,"path":"posts/2286.html","link":"","permalink":"https://www.itnxd.cn/posts/2286.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：89. a^b ¶题目背景： ¶题目描述 求 a 的 b 次方对 p 取模的值。 ¶输入格式 三个整数 a,b,在同一行用空格隔开。 ¶输出格式 输出一个整数，表示a^b mod p的值。 ¶数据范围 0≤a,b,p≤109 ¶输入样例： 13 2 7 ¶输出样例： 12 ¶题目分析： ¶题目要求： 求a 的 b 次方 模 p 的值。 ¶解题思路： 直接循环求a 的 b 次幂，很明显会超时，C++ 一秒大概能运行10的7次方到10的8次方次之间，本题数据为10的9次方，肯定超时！ 所以需要用到快速幂来计算： 快速幂思想如图： 假如计算3 的 7 次方，7的二进制为111，如图，3的7次相当于3的1次，2次，4次，即3的2的0次+1次+2次，而3的2次是3的1次的平方，4次是2次的平方，所以这样看来，7次本来要算7回，这样只需要算三次即可，当然这里数据较小，假如是3的1000000次，只需要计算20次左右！可见提高了多少速度。 具体思想：对次数取最后一位，如果是奇数（即对应二进制位为1），就去累乘，如果是偶数（即二进制位为0），就跳过；当然每次都要存储好下一次需要计算的数据，即将当前值平方即可！ yxc大神的快速幂模板，点击这里！ yxc大神的视频讲解，点击这里！ ¶题解： 注意点： 如果数据是这样：9 0 1 ，此时while进不去，最后会输出初始值1，但结果要对1取余，所以应该是0！所以要在开始时就对res 取余，次数取余不会影响到后面计算，只要p 比1大，此处相当于没有变化，只有1的时候会变化！或者也可以用if 来判断一下即可！ b&amp;1 ：就是判断是不是奇数，或者说对应的二进制位是不是1 1ll ：可以简单的将数据转化为long long类型，以防溢出！ b &gt;&gt; 1 ：即二进制位右移，相当于除2，转化为二进制位就是将最后一位扔掉！ 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int a, b, p;long long res = 1;int main(){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; res %= p; while(b) { if(b&amp;1) res = res * 1ll * a % p; a = a * 1ll * a % p; b &gt;&gt;= 1; } cout &lt;&lt; res &lt;&lt; endl; return 0;} ¶每天学习一点点！每天进步一点点！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"快速幂","slug":"快速幂","permalink":"https://www.itnxd.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}],"author":"Mr.Niu"},{"title":"AcWing-788.逆序对的数量","slug":"AcWing-788-逆序对的数量","date":"2020-02-26T13:19:28.000Z","updated":"2020-05-18T13:54:01.938Z","comments":true,"path":"posts/25834.html","link":"","permalink":"https://www.itnxd.cn/posts/25834.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：788. 逆序对的数量 ¶题目背景： ¶题目描述 给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。 逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。 ¶输入格式 第一行包含整数n，表示数列的长度。 第二行包含 n 个整数，表示整个数列。 ¶输出格式 输出一个整数，表示逆序对的个数。 ¶数据范围 1≤n≤100000 ¶输入样例： 1262 3 4 5 6 1 ¶输出样例： 15 ¶题目分析： ¶题目要求： 题目要求求出逆序对的数目，所谓逆序对就是后面的数小于前面的数就是一组！ ¶解题思路： 首先，应该想到逆序对不就是从小大大排序时，需要交换的两者吗？所以可以使用冒泡排序，在进行交换时就进行++记录。 但是：很明显冒泡排序复杂度太大，是O(N) 的，一定超时。 所以又想到归并排序，归并排序也有逆序对的交换，所以也可以进行记录。时间复杂度为O(NlogN)！ 归并排序模板！点击这里！ 稍微解释一下归并排序，先分后合的思想： 分：将原来的一条链一直从中间切开，直到切到当前只有一个元素，这时，它是有序的。 合：将当前两个有序序列排好序用中间变量存储起来，最后再将中间序列还给原序列。 直到序列全部有序！ 本题就是要在归并排序的过程中，产生逆序对的时候，进行记录： 其中res 就是用来记录的，res = mid - i + 1; 关于这里，要详细解释一下： 123456789while(i &lt;= mid &amp;&amp; j &lt;= r){ if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else { res += mid - i + 1; temp[k++] = a[j++]; }} 首先：相邻的这两个序列，对序列本身自己来说，它是内部有序的，假如左边的序列大于右边的序列，由于左右都是有序的，那么左边的序列从当前位置 i 到 mid 结束时，都是要大于右边当前值的，所以逆序对不是1，而是 res += mid - i + 1; ， 至于为什么要这样算，因为等到右边的较小值被存储了之后，左边当前值以后真的值就没有机会和右边的被存储值进行比较了！ 如图： ¶题解： 注意：最好使用long long 或许数据很大！ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;const int N = 100050;int a[N], temp[N];long long n, res;void merge_sort(int a[], int l, int r){ if(l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(a, l, mid), merge_sort(a, mid + 1, r); int k = 0, i = l, j = mid + 1; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else { res += mid - i + 1; temp[k++] = a[j++]; } } while(i &lt;= mid) temp[k++] = a[i++]; while(j &lt;= r) temp[k++] = a[j++]; for(i = l, j = 0; i &lt;= r; i++, j++) a[i] = temp[j];}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; merge_sort(a, 0, n - 1); cout &lt;&lt; res &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"归并排序","slug":"归并排序","permalink":"https://www.itnxd.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"逆序对","slug":"逆序对","permalink":"https://www.itnxd.cn/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"}],"author":"Mr.Niu"},{"title":"AcWing-1326.军训队列","slug":"AcWing-1326-军训队列","date":"2020-02-25T11:08:02.000Z","updated":"2020-05-18T13:54:01.940Z","comments":true,"path":"posts/13968.html","link":"","permalink":"https://www.itnxd.cn/posts/13968.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：1326. 军训队列 ¶题目背景： ¶题目描述 有 n 名学生参加军训，军训的一大重要内容就是走队列，而一个队列的不整齐程度是该队中最高的学生的身高与最矮的学生的身高差值的平方。 现在要将 n 名参加军训的学生分成 k 个队列，每个队列的人数可以是任意非负整数。 在安排队列时希望所有队列的不整齐度之和尽量小，请问不整齐度之和最小可以是多少？ ¶输入格式 第一行两个整数 n,k，表示学生人数和队列数。 第二行 n 个整数，依次表示每名学生的身高。 ¶输出格式 一个整数表示答案。 ¶数据范围 对于10%的数据，k=1； 对于另外10%的数据，k=2； 对于另外10%的数据，k=3； 对于另外10%的数据，k=4； 对于另外10%的数据，1≤n,k≤5； 对于另外10%的数据，1≤n,k≤10； 对于另外20%的数据，1≤n,k≤100； 对于另外5%的数据，n=k=500; 对于所有的数据，1≤n,k≤500，0≤ 学生身高 ≤200 ¶输入样例： 123 2170 180 168 ¶输出样例： ¶14 ¶题目分析： 这对我来说是一道难题，用到了贪心和动态规划： 我也是第一次接触Dp。 我的理解动态规划就是从小集合算到大集合，找大的集合和小的集合的关系，即可实现后面用到的前面已经算出来的效果！ 尽我的能力写了一篇足够详细的题解： ¶题目要求： n 个人，分成 k 组，求 k 组的最大最小值差的平方的最小值，也就是在所有分法中找一个最优解！ ¶解题思路： 贪心 + Dp 首先，分成 k 组，一定要让 k 组不空，因为如果分成k - 1组，和从k - 1组里拿出一个人给了第k 组，后者得到的结果一定不会比前者更坏，最优解一定不会变大，也就是说，全部分成k组得到的结果会更优，自己好好想想！ 用二维数组 f[i][j] 表示将前 i 个人分成 j 组！ 前提：当然是从小到大排好序了！ 探讨 f[i][j] 的情况： 将 i 个人 划分为 j 组，考虑一下最后一组的情况，也就是要保证最后一组之前要有j - 1组，每组至少一个人，所以 最后一组的起始点最小值也得是 j , 而总共i 个人，那么最后一组的起始值的范围是 j &lt;= k &lt;= i ，也就是f[i][j] 的划分集合共有i - j 种，而最优解一定为其中一种，如下图： 继续看图：最终f[i][j] 的值当然就是前面的 j - 1 组的结果加上最后一组的和了： 前面j - 1 组，相当于从 k - 1 个人中划分 j - 1组，即f[k - 1][j - 1] : 所以：最终结果： f[i][j] = min(f[i][j], f[k - 1][j - 1] + (a[i] - a[k]) * (a[i] - a[k])); 计算最小值，当然要将f数组初始化为较大值：0x3f 。 划分组数 j 要保证不大于人数 i，不大于划分数 m 。 边界：当然是f[1][1] , 要想的到该值，当然需要有 f[0][0] 。将0个人划分为 0 组，结果当然为0；处理好边界值：f[0][0] = 0; k 的取值范围正如上面所讲，j 到 i 。 最后输出f[n][m] 即可！ ¶官方题解视频： yxc大神官方讲解 ¶题解： 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m;int a[510];int f[510][510];int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; if(m &gt;= n) { cout &lt;&lt; 0 &lt;&lt; endl; return 0; } sort(a + 1, a + n + 1); memset(f, 0x3f, sizeof f); f[0][0] = 0; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= i &amp;&amp; j &lt;= m; j++) { for(int k = j; k &lt;= i; k++) { f[i][j] = min(f[i][j], f[k - 1][j - 1] + (a[i] - a[k]) * (a[i] - a[k])); } } } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} 历经千辛万苦，终于折腾完毕！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"Dp","slug":"Dp","permalink":"https://www.itnxd.cn/tags/Dp/"}],"author":"Mr.Niu"},{"title":"AcWing-1324.五子棋","slug":"AcWing-1324-五子棋","date":"2020-02-25T07:29:54.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/44380.html","link":"","permalink":"https://www.itnxd.cn/posts/44380.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 题目链接：1324. 五子棋 ¶题目背景： ¶题目描述 小 A 和小 B 在下五子棋。 五子棋是在一个由网格构成的棋盘内进行的。 网格有 15 行 15 列，共有 225 个交叉点。 小 A 先手执黑棋，小 B 后手执白棋。 两人轮流下棋，每次下棋都将一个自己的棋子放在棋盘上一个空白的交叉点上。 然而，由于小 A 和小 B 都不知道五子棋的胜利条件，所以即使有一方已经胜利了，他们仍然会继续下棋。 现在想请你帮忙分析一下，所下的棋局是在第几步结束的。 当然，也有可能他们最终仍然没有分出胜负，这时请判定他们平局。 五子棋的胜利条件是这样的：当同一行或同一列或同一斜线（即与网格线成 45° 角的直线）上连续的五个或五个以上交叉点放有同色棋子的时候，立即判定使用该颜色棋子的玩家获得胜利，游戏结束。 ¶输入格式 第一行输入一个正整数 n，表示双方总共下了多少步棋。 接下来 n 行，每行两个正整数。其中，第 i 行的两个数 x,y 表示第 i 步的棋子下在了第 x 条横线和第 y 条竖线的交叉点上。若 i 为奇数，则这个棋子是黑棋，否则是白棋。 ¶输出格式 若没有人获得胜利，你需要输出“Tie”（不含引号）。 否则，若小 A 获胜，输出 “A”（不含引号），若小 B 获胜，输出 “B”（不含引号）；并输出一个正整数 w 表示第 w 步下完后游戏应当结束，字母与整数间用一个空格隔开。 ¶数据范围 对于 20% 的数据，游戏结果是平局。 对于 30% 的数据，游戏在最后一手结束。 对于 100% 的数据，0≤n≤225，1≤x,y≤150≤n≤225，1≤x,y≤15。 ¶输入样例： 1234567891091 12 11 22 21 32 31 42 41 5 ¶输出样例： ¶1A 9 ¶题目分析： ¶题目要求： 题目意思就是在一个15 x 15 的棋盘下棋，要你求出谁最后赢了，并且是在下第几课棋子时赢的！ ¶解题思路： 当然还是要下一步棋子，就判断一下是否有人胜利！ 方法就是要在下棋子的地方展开，如果下了这步棋子，胜利了，那么最后的结果必有这一个棋子，所以从这里展开！ 有四个方向可能五子连珠：横向，竖向，以及两个斜向！ 所以直接扫描四个方向即可！ 五子连珠条件：一个方向的正反向相加再加1大于等于5即可！ ¶题解： 由于一个方向的正反完全可以由正或反乘以-1得到，所以只需记录八个方向的相连的四个方向即可。本人用dx 和 dy数组记录。 先后手判断奇偶数即可。 arr 为 0 表示空，为1表示先手，为2表示后手。 win 为 0 表示平局，1表示先手赢，2表示后手赢。 flag 标记是否五子连珠，step 表示胜利时的步数。 需注意越界条件和下一个棋子是否是本方棋色。 一个方向的正向就是+该变量，反向就是-该变量！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;iostream&gt; #include &lt;algorithm&gt;using namespace std;int n;int arr[20][20];// 1 先手 2 后手 int main(){ cin &gt;&gt; n; // 四个方向：下、右下、右、右上 int dx[4] = {1, 1, 0, -1}; int dy[4] = {0, 1, 1, 1}; int step, win = 0;//先手为1，后手为2 for(int i = 1; i &lt;= n; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; if(i % 2) arr[x][y] = 1; else arr[x][y] = 2; bool flag = false; // 判断四个方向 for(int j = 0; j &lt; 4; j++) { int a = 0, b = 0;//一个方向的正反 记录该方向可走的步数 // 正向 while(true) { int tx = x + (a + 1) * dx[j]; int ty = y + (a + 1) * dy[j]; if(tx &lt; 1 || tx &gt; 15 || ty &lt; 1 || ty &gt; 15) break;//越界 if(arr[x][y] != arr[tx][ty]) break;//棋子颜色不同 a++;//正方向++ } // 反向 while(true) { int tx = x - (b + 1) * dx[j]; int ty = y - (b + 1) * dy[j]; if(tx &lt; 1 || tx &gt; 15 || ty &lt; 1 || ty &gt; 15) break;//越界 if(arr[x][y] != arr[tx][ty]) break;//棋子颜色不同 b++;//反方向++ } if(a + b + 1 &gt;= 5) { flag = true; break; } } if(flag) { win = arr[x][y]; step = i; break; } } if(win == 0) cout &lt;&lt; \"Tie\" &lt;&lt; endl; else if(win == 1) printf(\"A %d\\n\", step); else printf(\"B %d\\n\", step); return 0;} 欢迎访问！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"人一生需要花多少钱","slug":"人一生需要花多少钱","date":"2020-02-24T03:25:05.000Z","updated":"2020-05-18T13:54:01.941Z","comments":true,"path":"posts/42468.html","link":"","permalink":"https://www.itnxd.cn/posts/42468.html","excerpt":"","text":"¶一首歌曲送上 我们都是语言的巨人，行动的矮子！ ¶分享偶然看到的四张图： 看到图后，我想了很多，当然是乐观的想，本人并不是那种悲观的人！ 人一生花费的钱有这么多，现在不努力更待何时！ 每天努力一点点，不要管于你无关的事情！ 又想到了自己博客首页的座右铭： 你现在的努力，是为了以后有更多的选择！ ¶一则启示： 俄罗斯方块告诉我们，合群跟随大众，随波逐流，我们就会消失，变得没有自我 。贪吃蛇告诉我们，不断的吸收负能量，不断的懒惰，害死我们的终究是自己 。愤怒的小鸟告诉我们，嘲笑我们的终究没有我们具有选择性，他们只有嘲笑的能力而我们具有打败别人的能力，变成猪的人类也只会嘲笑努力的人。 ¶其实自律很简单： 其实自律很简单，需要认清自己，再朝一个方向去行动。刚开始要给自己时间去适应，慢慢的慢慢的你就会习惯成自然。也不要刻意的强求自己定要做什么什么然后没做成而感到懊恼，在努力的过程中需要付出很多心血和汗水不要放弃、不要悲伤。终有一天你的目标会开花结果。不要每天看一些励志视频就为自己打一针鸡血，努力一下又开始堕落、迷茫。加油陌生人，一起朝着梦想努力[打call][打call][打call] ¶成为自己想成为的人： 我一点也不聪明 我必须很努力的学才能达到和同龄人同样的成绩 优秀的人太多 很多人轻轻松松就能获得我努力了很久才能换来的成果 甚至我拼尽全力也得不来的成果 心里当然不是滋味 但我不羡慕 没有人的成功是空穴来风的 他们能做到轻而易举 那是因为他们已经默默付出了很多 而我只看到了表面 我要做的就是做好我自己 我慢慢来 一步一步来 总是可以的 因为我喜欢的 想干的事太多了 我想成为自己喜欢的人 ¶一则视频送给努力的你们！ ¶最后送上四十句话： 第一：我有我要赶去的远方，哪怕风雨兼程披星戴月。 第二：一棵树的树冠越是向往高处的太阳，它的跟越是得深入黑暗的地底。 第三：你不能要求一个没有风暴的海洋。那不是海，是泥塘。 第四：没有一个冬天不可跨越，也没有一个春天不会来临。 第五：先努力让自己发光，对的人才能迎着光而来。 第六：你那么憎恨的人，和他们斗了那么久。最终却要变得和他们一样。人世间没有任何理想值得以这样的沉沦作为代价。 第七：觉得为时已晚的时候恰恰是最早的时候。 第八：你走的每一步，都藏着未来的影子。 第九：要变优秀，堵住那悠悠众口。 第十：那一天，我也曾看到花团锦簇。那一夜，我也曾梦见百万雄兵。 第十一：你背单词时，阿拉斯加的鳕鱼正跃出水面；你算数学时，太平洋彼岸的海鸥振翅掠过城市上空；你晚自习时，极图中的夜空散漫了五彩斑斓。但是少年你别着急，在你为自己未来踏踏实实地努力时，那些你感觉从来不会看到的景色，那些你觉得终身不会遇到的人，正一步步向你走来。 第十二：我要和生活再死磕几年，要么我就毁灭，要么我就注定铸就辉煌。 第十三：在隆冬，我终于知道，在我身上有一个不可战胜的夏天。 第十四：他们试图把你埋了，但你要记得，你是种子。 第十五：要偷偷努力，希望自己也能成为别人的梦想。 第十六：一生中总会遇到这样的时候，你的内心已经兵荒马乱天翻地覆了，可是在别人看来你只是比平时沉默了一点，没人会觉得奇怪，这种战争，注定单枪匹马。 第十七：既然我找不到你，只好站在显眼的地方让你找到了。 第十八：这是个第一人称的世界，现在开始有我来论证这一切。 第十九：即使身在井隅，也仍然有仰望星空的权利。况且，我们生而闪耀，又何必活在别人的阴影里。 第二十：天行健，君子以自强不息。 第二十一：人世间有一种庸俗势力的大合唱。谁一旦对它屈服，就永远沉沦了。 第二十二：谁将声震人间，必长久深自缄默。谁将点燃闪电，必长久如云漂泊。 第二十三：所谓无底深渊，下去，也是前程万里。 第二十四：从来不是让你把一次考试当成人生的赌注，只是想让你在足够年轻的时候体会一次全力以赴。 第二十五：但凡不能杀死你的，最终都会使你更强大。 第二十六：生前何必久睡，死后自会长眠。 第二十七：你终究会成为你正在成为的人。 第二十八：我要悄悄拔尖，然后惊艳所有人。 第二十九：因为，我喜欢的东西很贵，想去的地方很远，喜欢的人很优秀。 第三十：不恨古人吾不见，恨古人不见吾狂尔。 等三十一：待到秋来九月八，我花开后百花杀。 第三十二：春来我不先张口，哪个虫儿干作声。 第三十三：大鹏一日同风起，扶摇直上九万里。 第三十四：想当年，金戈铁马，气吞万里如虎。 第三十五：仙路尽头谁为峰，一见无始道成空。 第三十六：海到无边天做岸，山登绝顶我为峰。 第三十七：窥尽阴阳理，易掌定乾坤。 第三十八：春风得意马蹄疾，一夜看尽长安花。 第三十九：他年若有凌云日，敢笑黄巢不丈夫。 第四十：俱往矣，数风流人物，还看今朝。 ¶现在根本不晚，站起来奋斗吧！ 加油吧！骚年们！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"随笔","slug":"随笔","permalink":"https://www.itnxd.cn/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"努力","slug":"努力","permalink":"https://www.itnxd.cn/tags/%E5%8A%AA%E5%8A%9B/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之面向浏览器","slug":"JavaScript教程系列之面向浏览器","date":"2020-02-19T11:20:35.000Z","updated":"2020-05-19T02:37:44.326Z","comments":true,"path":"posts/57030.html","link":"","permalink":"https://www.itnxd.cn/posts/57030.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶一、浏览器对象(BOM) BOM是一套操作浏览器的API（接口/方法/属性） 常见的BOM对象： window：代表整个浏览器窗口（window是BOM中的一个对象，并且是顶级的对象） Navigator ：代表浏览器当前的信息，通过Navigator我们可以获取用户当前使用的是什么浏览器 Location： 代表浏览器当前的地址信息，通过Location我们可以获取或者设置当前的地址信息 History：代表浏览器的历史信息，通过History我们可以实现上一步/刷新/下一步操作（出于 对用户的隐私考虑，我们只能拿到当前的浏览记录，不能拿到所有的历史记录） Screen：代表用户的屏幕信息 ¶1、window对象 window对象不但充当全局作用域，而且表示浏览器窗口。 还记得之前的什么alert，console啥的没，那都是全局对象window的属性或者成员！ window对象的成员加不加window都一样，不加默认就是window！ ¶innerWidth 和 innerHeight 获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。(当然：包括滚动条) 简而言之就是网页部分的尺寸！ 当然他会随网页大小而改变： 123console.log('window inner size: ' + innerWidth + ' x ' + innerHeight);// 一样的效果：console.log('window inner size: ' + window.innerWidth + ' x ' + window.innerHeight); 效果如下： ¶outerWidth 和 outerHeight 获取浏览器窗口的整个宽高。 计算的是浏览器，而不是网页。 也是随浏览器大小而改变的！ 12console.log('window outersize: ' + window.outerWidth+ ' x ' + window.outerHeight);// window outersize: 1536 x 864 ¶2、navigator对象 navigator对象表示浏览器的信息，获取浏览器信息 常见属性： navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型；（不是你的电脑系统！） navigator.userAgent：浏览器设定的User-Agent字符串。 12345console.log('appName = ' + navigator.appName);console.log('appVersion = ' + navigator.appVersion);console.log('language = ' + navigator.language);console.log('platform = ' + navigator.platform);console.log('userAgent = ' + navigator.userAgent); 效果如下： ¶3、screen对象 screen对象用来获取屏幕的信息！ 常用属性： screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。 1234console.log('Screen size = ' + screen.width + ' x ' + screen.height);console.log('colorDepth = ' + screen.colorDepth );// Screen size = 1536 x 864// colorDepth = 24 ¶4、location对象 location对象表示当前页面的URL信息！ 常用属性： 123456789101112http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOPlocation.href;//http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOPlocation.protocol; // 'http'location.host; // 'www.example.com'location.port; // '8080'location.pathname; // '/path/index.html'location.search; // '?a=1&amp;b=2'location.hash; // 'TOP'window.location.href; //获取当前地址栏的地址window.location.href = “http://www.baidu.com”; // 设置当前地址栏的地址 刷新和强制刷新（Ctrl + F5）: 123window.location.reload(); //刷新window.location.reload(true); //强制刷新window.location.assign('/'); // 设置一个新的URL地址 ¶5、document对象 document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。 其独特之处是唯一一个既属于BOM又属于DOM的对象！ document.title：改变title标签的属性 1document.title = '努力学习JavaScript!'; getElementById()和getElementsByTagName() 通过id获取和通过标签获取！ 12var menu = document.getElementById('drink-menu');var drinks = document.getElementsByTagName('dt'); document.cookie document对象还有一个cookie属性，可以获取当前页面的Cookie。 1document.cookie; // 'v=123; remember=true; prefer=zh' ¶6、history对象 history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。 这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。 新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。 任何情况，你都不应该使用history这个对象了。 12345window.history.forword(); //上一步 window.history.back(); //下一步 window.history.go(0); //接收参数 0 表示刷新当前页面 window.history.go(2); //接收正整数 表示前进2个页面 window.history.go(-2); //接收负整数 表示后退2个页面 ¶二、操作DOM DOM是一套操作标签的API（接口/方法/属性） 由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。 始终记住DOM是一个树形结构。 DOM的基本操作： 更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容； 遍历：遍历该DOM节点下的子节点，以便进行进一步操作； 添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点； 删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。 ¶1、获取DOM节点 document.getElementById()：通过id获取 document.getElementsByTagName()：通过标签获取 document.getElementsByClassName()：通过class获取 注意：通过id获取是唯一的，通过标签和class获取的是一组DOM节点 ¶1.1 可以通过先定位父节点再来定位子节点来进行唯一确定！ 123456789101112131415// 返回ID为'test'的节点：var test = document.getElementById('test');// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：var trs = document.getElementById('test-table').getElementsByTagName('tr');// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：var reds = document.getElementById('test-div').getElementsByClassName('red');// 获取节点test下的所有直属子节点:var cs = test.children;// 获取节点test下第一个、最后一个子节点：var first = test.firstElementChild;var last = test.lastElementChild; ¶1.2 通过 querySelector() 和 querySelectorAll() 获取 12345// 通过querySelector获取ID为q1的节点：var q1 = document.querySelector('#q1');// 通过querySelectorAll获取q1节点内的符合条件的所有节点：var ps = q1.querySelectorAll('div.highlighted &gt; p'); ¶1.3 一道简单测试题： 题目背景： 12345678910111213141516&lt;!-- HTML结构 --&gt;&lt;div id=\"test-div\"&gt; &lt;div class=\"c-red\"&gt; &lt;p id=\"test-p\"&gt;JavaScript&lt;/p&gt; &lt;p&gt;Java&lt;/p&gt; &lt;/div&gt; &lt;div class=\"c-red c-green\"&gt; &lt;p&gt;Python&lt;/p&gt; &lt;p&gt;Ruby&lt;/p&gt; &lt;p&gt;Swift&lt;/p&gt; &lt;/div&gt; &lt;div class=\"c-green\"&gt; &lt;p&gt;Scheme&lt;/p&gt; &lt;p&gt;Haskell&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 选择指定项： 1234567891011121314151617181920212223242526272829// 1、选择&lt;p&gt;JavaScript&lt;/p&gt;:var js = document.getElementById('test-p');// 2、选择&lt;p&gt;Python&lt;/p&gt;,&lt;p&gt;Ruby&lt;/p&gt;,&lt;p&gt;Swift&lt;/p&gt;:// 2.1 分开写：var arr = document.querySelector('div[class = \"c-red c-green\"]').querySelectorAll('p');// 2.2 合并写：var arr = document.querySelectorAll('div[class = \"c-red c-green\"] &gt; p');// 2.3 另一种写法：var arr = document.querySelectorAll('.c-red.c-green p');// 2.4 另一种：var arr = document.getElementsByClassName('c-red')[1].children;// 3、选择&lt;p&gt;Haskell&lt;/p&gt;:// 3.1 用数组序号获取元素：var haskell = document.querySelectorAll('div[class = \"c-green\"] &gt; p')[1];// 3.2 另一种写法：var haskell = document.querySelector('.c-green:not(.c-red)').lastElementChild;// 测试:if (!js || js.innerText !== 'JavaScript') { alert('选择JavaScript失败!');} else if (!arr || arr.length !== 3 || !arr[0] || !arr[1] || !arr[2] || arr[0].innerText !== 'Python' || arr[1].innerText !== 'Ruby' || arr[2].innerText !== 'Swift') { console.log('选择Python,Ruby,Swift失败!');} else if (!haskell || haskell.innerText !== 'Haskell') { console.log('选择Haskell失败!');} else { console.log('测试通过!');} ¶2、更新DOM节点 用来直接修改节点的文本！ ¶2.1 innerHTML属性 可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树： 通过innerHTML属性，原内容已经被覆盖！ 1、可以传入普通内容 2、也可以传入标签，标签会直接被解析为HTML内容！ 1234567891011&lt;p id=\"my-p\"&gt;...&lt;/p&gt;&lt;script&gt; // 获取&lt;p id=\"p-id\"&gt;...&lt;/p&gt; let p1 = document.getElementById('my-p'); // 设置文本为abc: p1.innerHTML = 'cde'; // &lt;p id=\"p-id\"&gt;ABC&lt;/p&gt; // 设置HTML: p1.innerHTML = 'ABC &lt;span style=\"color:red\"&gt;RED&lt;/span&gt; XYZ'; // &lt;p&gt;...&lt;/p&gt;的内部结构已修改&lt;/script&gt; ¶2.2 innerText属性 属性中无法传入html标签，若传入，则会直接被解析为文本显示！不是解析为HTML标签！ 123456789&lt;p id=\"my-p\"&gt;...&lt;/p&gt;&lt;script&gt; // 获取&lt;p id=\"p-id\"&gt;...&lt;/p&gt; var p = document.getElementById('my-p'); // 设置文本: p.innerText = '&lt;span&gt;hhhhh&lt;/span&gt;';&lt;/script&gt; 特殊点： 无法正常显示script标签： 12345678910&lt;p id=\"p-id\"&gt;hello&lt;/p&gt;&lt;script&gt; var p = document.getElementById('p-id'); // 设置文本:此句无法正常显示 p.innerText = '&lt;script&gt;alert(\"Hi\")&lt;/script&gt;'; // HTML被自动编码，无法设置一个&lt;script&gt;节点:&lt;/script&gt;// 正常显示方法：&lt;p id=\"p-id\"&gt;&amp;lt;script&amp;gt;alert(\"Hi\")&amp;lt;/script&amp;gt;&lt;/p&gt; ¶2.3 textContent属性 两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本 作用和 innerText 一样！ 123456789&lt;p id=\"my-p\"&gt;...&lt;/p&gt;&lt;script&gt; // 获取&lt;p id=\"p-id\"&gt;...&lt;/p&gt; var p = document.getElementById('my-p'); // 设置文本: p.textContent = '&lt;span&gt;hhhhh&lt;/span&gt;';&lt;/script&gt; ¶2.4 style属性 DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize： CSS 的属性带有- 的都变为驼峰命名法！ 123456// 获取&lt;p id=\"p-id\"&gt;...&lt;/p&gt;var p = document.getElementById('p-id');// 设置CSS:p.style.color = '#ff0000';p.style.fontSize = '20px';p.style.paddingTop = '2em'; ¶3、插入DOM节点 如果这个DOM节点是空的，例如，&lt;div&gt;&lt;/div&gt;，那么，直接使用innerHTML = 'child'就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。 如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点。 ¶方法一：使用 appendChild 把一个子节点添加到父节点的最后一个子节点 首先会从原先的位置删除，再插入到新的位置。 123456789101112&lt;!-- HTML结构 --&gt;&lt;p id=\"js\"&gt;JavaScript&lt;/p&gt;&lt;div id=\"list\"&gt; &lt;p id=\"java\"&gt;Java&lt;/p&gt; &lt;p id=\"python\"&gt;Python&lt;/p&gt; &lt;p id=\"scheme\"&gt;Scheme&lt;/p&gt;&lt;/div&gt;// JavaScript代码var js = document.getElementById('js'), list = document.getElementById('list');list.appendChild(js); 最终结果： 1234567&lt;!-- HTML结构 --&gt;&lt;div id=\"list\"&gt; &lt;p id=\"java\"&gt;Java&lt;/p&gt; &lt;p id=\"python\"&gt;Python&lt;/p&gt; &lt;p id=\"scheme\"&gt;Scheme&lt;/p&gt; &lt;p id=\"js\"&gt;JavaScript&lt;/p&gt;&lt;/div&gt; 一个例子：打开谷歌控制台，将下面代码复制到任意个网页，观看网页CSS变化！ 1234var d = document.createElement('style');d.setAttribute('type', 'text/css');d.innerHTML = 'p { color: red }';document.getElementsByTagName('head')[0].appendChild(d); 如下，会发现多了一行CSS，而网页只要是p标签都会被修改颜色！ ¶方法二：使用 insertBefore 可将子节点插入到指定位置！ 可以使用parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前。 123456789101112131415&lt;!-- HTML结构 --&gt;&lt;div id=\"list\"&gt; &lt;p id=\"java\"&gt;Java&lt;/p&gt; &lt;p id=\"python\"&gt;Python&lt;/p&gt; &lt;p id=\"scheme\"&gt;Scheme&lt;/p&gt;&lt;/div&gt;var list = document.getElementById('list'), ref = document.getElementById('python'), haskell = document.createElement('p');haskell.id = 'haskell';haskell.innerText = 'Haskell';// 将新建的p标签（haskell）插入到ref的前面list.insertBefore(haskell, ref); 效果如下： 1234567&lt;!-- HTML结构 --&gt;&lt;div id=\"list\"&gt; &lt;p id=\"java\"&gt;Java&lt;/p&gt; &lt;p id=\"haskell\"&gt;Haskell&lt;/p&gt; &lt;p id=\"python\"&gt;Python&lt;/p&gt; &lt;p id=\"scheme\"&gt;Scheme&lt;/p&gt;&lt;/div&gt; ¶使用 children 属性来遍历 遍历一个父节点的所有子节点！ 123456var i, c, list = document.getElementById('list');for (i = 0; i &lt; list.children.length; i++) { c = list.children[i]; // 拿到第i个子节点} ¶4、删除DOM 要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉： 注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 1234567// 拿到待删除节点:var self = document.getElementById('to-be-removed');// 拿到父节点:var parent = self.parentElement;// 删除:var removed = parent.removeChild(self);removed === self; // true 当你遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。 12345678&lt;div id=\"parent\"&gt; &lt;p&gt;First&lt;/p&gt; &lt;p&gt;Second&lt;/p&gt;&lt;/div&gt;var parent = document.getElementById('parent');parent.removeChild(parent.children[0]);parent.removeChild(parent.children[1]); // &lt;-- 浏览器报错 ¶三、操作表单 表单类型主要有以下几种： 文本框，对应的&lt;input type=\"text\"&gt;，用于输入文本； 口令框，对应的&lt;input type=\"password\"&gt;，用于输入口令； 单选框，对应的&lt;input type=\"radio\"&gt;，用于选择一项； 复选框，对应的&lt;input type=\"checkbox\"&gt;，用于选择多项； 下拉框，对应的&lt;input type=\"select\"&gt;，用于选择一项； 隐藏文本，对应的&lt;input type=\"hidden\"&gt;，用户不可见，但表单提交时会把隐藏文本发送到服务器。 ¶1、获取值 如果我们获得了一个&lt;input&gt;节点的引用，就可以直接调用value获得对应的用户输入值： 123// &lt;input type=\"text\" id=\"email\"&gt;var input = document.getElementById('email');input.value; // '用户输入的值' 这种方式可以应用于text、password、hidden以及select。 但是，对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断： 12345678// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"monday\" value=\"1\"&gt; Monday&lt;/label&gt;// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"tuesday\" value=\"2\"&gt; Tuesday&lt;/label&gt;var mon = document.getElementById('monday');var tue = document.getElementById('tuesday');mon.value; // '1'tue.value; // '2'mon.checked; // true或者falsetue.checked; // true或者false ¶2、设置值 设置值和获取值类似，对于text、password、hidden以及select，直接设置value就可以： 123// &lt;input type=\"text\" id=\"email\"&gt;var input = document.getElementById('email');input.value = 'test@example.com'; // 文本框的内容已更新 对于单选框和复选框，设置checked为true或false即可。 123456// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"monday\" value=\"1\"&gt; Monday&lt;/label&gt;// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"tuesday\" value=\"2\"&gt; Tuesday&lt;/label&gt;var mon = document.getElementById('monday');var tue = document.getElementById('tuesday');mon.checked = true; // true或者falsetue.checked = false; // true或者false ¶3、HTML5控件 HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用``标签： 具体效果自己试一下！ 123&lt;input type=\"date\" value=\"2015-07-01\"&gt;&lt;input type=\"datetime-local\" value=\"2015-07-01T02:03:04\"&gt;&lt;input type=\"color\" value=\"#ff0000\"&gt; ¶3、提交表单 JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。 ¶通过绑定submit()方法实现： 这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击``时提交表单，或者用户在最后一个输入框按回车键！ 1234567891011121314&lt;!-- HTML --&gt;&lt;form id=\"test-form\"&gt; &lt;input type=\"text\" name=\"test\"&gt; &lt;button type=\"button\" onclick=\"doSubmitForm()\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function doSubmitForm() { var form = document.getElementById('test-form'); // 可以在此修改form的input... // 提交form: form.submit();}&lt;/script&gt; ¶通过form本身的onsubmit事件 注意要return true来告诉浏览器继续提交，如果return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。 在检查和修改时，要充分利用来传递数据。 1234567891011121314&lt;!-- HTML --&gt;&lt;form id=\"test-form\" onsubmit=\"return checkForm()\"&gt; &lt;input type=\"text\" name=\"test\"&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() { var form = document.getElementById('test-form'); // 可以在此修改form的input... // 继续下一步: return true;}&lt;/script&gt; ¶关于MD5 安全考虑，提交表单时不传输明文口令，而是口令的MD5 这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个*变成32个*（因为MD5有32个字符）。 12345678910111213141516&lt;!-- HTML --&gt;&lt;form id=\"login-form\" method=\"post\" onsubmit=\"return checkForm()\"&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;input type=\"password\" id=\"password\" name=\"password\"&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() { var pwd = document.getElementById('password'); // 把用户输入的明文变为MD5: pwd.value = toMD5(pwd.value); // 继续下一步: return true;}&lt;/script&gt; ¶利用&lt;input type=\"hidden\"&gt;实现： 可以实现不改变用户的输入！ 注意到id为md5-password的标记了`name=\"password\"`，而用户输入的`id`为`input-password`的没有name属性。没有name属性的``的数据不会被提交。 123456789101112131415161718&lt;!-- HTML --&gt;&lt;form id=\"login-form\" method=\"post\" onsubmit=\"return checkForm()\"&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;input type=\"password\" id=\"input-password\"&gt; &lt;input type=\"hidden\" id=\"md5-password\" name=\"password\"&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() { var input_pwd = document.getElementById('input-password'); var md5_pwd = document.getElementById('md5-password'); // 把用户输入的明文变为MD5: md5_pwd.value = toMD5(input_pwd.value); // 继续下一步: return true;}&lt;/script&gt; ¶4、一个例子 利用JavaScript检查用户注册信息是否正确，在以下情况不满足时报错并阻止提交表单： 用户名必须是3-10位英文字母或数字； 口令必须是6-20位； 两次输入口令必须一致。 12345678910111213141516&lt;!-- HTML结构 --&gt;&lt;form id=\"test-register\" action=\"#\" target=\"_blank\" onsubmit=\"return checkRegisterForm()\"&gt; &lt;p id=\"test-error\" style=\"color:red\"&gt;&lt;/p&gt; &lt;p&gt; 用户名: &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;/p&gt; &lt;p&gt; 口令: &lt;input type=\"password\" id=\"password\" name=\"password\"&gt; &lt;/p&gt; &lt;p&gt; 重复口令: &lt;input type=\"password\" id=\"password-2\"&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt; &lt;button type=\"reset\"&gt;重置&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233&lt;script&gt; var checkRegisterForm = function () { let re1 = /^\\w{3,10}$/; re2 = /^.{6,20}$/; user = document.getElementById('username'); pwd = document.getElementById('password'); pwd2 = document.getElementById('password-2'); if ( re1.test(user.value) &amp;&amp; re2.test(pwd.value) &amp;&amp; pwd.value === pwd2.value ) { return true; } else { return false; } return false; } // 测试: ;(function () { window.testFormHandler = checkRegisterForm; var form = document.getElementById('test-register'); if (form.dispatchEvent) { var event = new Event('submit', { bubbles: true, cancelable: true }); form.dispatchEvent(event); } else { form.fireEvent('onsubmit'); } })();&lt;/script&gt; ¶四、操作文件 在HTML表单中，可以上传文件的唯一控件就是&lt;input type=\"file\"&gt;。 注意：当一个表单包含&lt;input type=\"file\"&gt;时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。 出于安全考虑，浏览器只允许用户点击&lt;input type=\"file\"&gt;来选择本地文件，用JavaScript对&lt;input type=\"file\"&gt;的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径： 通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件： 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022494381696#0 补充教程：https://www.w3school.com.cn/jsref/event_onchange.asp 目前一脸懵逼，以后再细看把！ 123456var f = document.getElementById('test-file-upload');var filename = f.value; // 'C:\\fakepath\\test.png'if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) { alert('Can only upload image file.'); return false;} ¶File API 由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。 随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。 HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。 下面的例子演示了如何读取用户选取的图片文件，并在一个``中预览图像： 可以自己编一下看看效果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt; &lt;title&gt;文件api&lt;/title&gt; &lt;style&gt; #test-image-preview { width:500px; height:500px; border:1px solid #ff0000; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; &lt;div id=\"test-file-info\"&gt;&lt;/div&gt; &lt;div id=\"test-image-preview\"&gt;&lt;/div&gt; &lt;input id=\"test-image-file\" type=\"file\"&gt;&lt;/form&gt;&lt;script &gt; window.onload=function(){ var fileInput = document.getElementById('test-image-file'); var info = document.getElementById('test-file-info'); var preview = document.getElementById('test-image-preview'); fileInput.addEventListener('change',function(){ console.log('change...'); preview.style.backgroundImage=''; if (!fileInput.value){ info.innerHTML = '没有选择文件'; return ; } var file = fileInput.files[0]; info.innerHTML = '文件:' + file.name + '&lt;br&gt;'+'大小:'+file.size+'&lt;br&gt;'+'修改:'+file.lastModifiedDate; if(file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif'){ alert('不是有效的图片文件!'); return; } var reader = new FileReader(); reader.onload=function(e){ console.log('reader.onload'); var data = e.target.result;// 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage='url('+ data +')'; }; reader.readAsDataURL(file); }); };&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...，常用于设置图像。如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。 ¶五、AJAX ¶1、AJAX 的起源 AJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。 如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。 这就是Web的运作原理：一次HTTP请求对应一个页面。 如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。 最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。 用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 ¶2、编写AJAX 通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest。注意，不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性，一是因为这个字符串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。 当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。 XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。 注意，千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。 最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象： 123456789101112131415161718192021222324252627282930313233function success(text) { var textarea = document.getElementById('test-response-text'); textarea.value = text;}function fail(code) { var textarea = document.getElementById('test-response-text'); textarea.value = 'Error code: ' + code;}var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象request.onreadystatechange = function () { // 状态发生变化时，函数被回调 if (request.readyState === 4) { // 成功完成 // 判断响应结果: if (request.status === 200) { // 成功，通过responseText拿到响应的文本: return success(request.responseText); } else { // 失败，根据响应码判断失败原因: return fail(request.status); } } else { // HTTP请求还在继续... }}// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); 对于低版本的IE，需要换一个ActiveXObject对象： 123456789101112131415161718192021222324252627282930313233function success(text) { var textarea = document.getElementById('test-ie-response-text'); textarea.value = text;}function fail(code) { var textarea = document.getElementById('test-ie-response-text'); textarea.value = 'Error code: ' + code;}var request = new ActiveXObject('Microsoft.XMLHTTP'); // 新建Microsoft.XMLHTTP对象request.onreadystatechange = function () { // 状态发生变化时，函数被回调 if (request.readyState === 4) { // 成功完成 // 判断响应结果: if (request.status === 200) { // 成功，通过responseText拿到响应的文本: return success(request.responseText); } else { // 失败，根据响应码判断失败原因: return fail(request.status); } } else { // HTTP请求还在继续... }}// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); ¶3、安全限制 有点看不懂了！ 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400#0 ¶4、CORS 有点看不懂了！ 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400#0 ¶六、Promise 有点看不懂了！ 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544 ¶七、Canvas 以后再看吧！ 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022423592576 ¶目前告一段落了！以后有机会再进行 JavaScript 的学习！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://www.itnxd.cn/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.itnxd.cn/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://www.itnxd.cn/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"https://www.itnxd.cn/tags/DOM/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之面向对象编程","slug":"JavaScript教程系列之面向对象编程","date":"2020-02-17T14:17:37.000Z","updated":"2020-05-19T02:08:32.173Z","comments":true,"path":"posts/55519.html","link":"","permalink":"https://www.itnxd.cn/posts/55519.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 有人这样说：这种高大上的东西都是造火箭才用得上的，平时干的都是拧螺丝的活当然用不上咯！ 但还是得知道并掌握。。。。！ class继承需要掌握，原型继承知道就好了… ¶一、面向对象编程概述 JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。 ¶1、通过__proto__ 来指向Student，并且继承Student的所有属性！ JavaScript它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。 12345678910111213141516var Student = { name: 'Robot', height: 1.2, run: function () { console.log(this.name + ' is running...'); }};var xiaoming = { name: '小明'};xiaoming.__proto__ = Student;xiaoming.name; // '小明'xiaoming.run(); // 小明 is running... ¶2、指向（原型）是可以改变的！ 在指向一个类后，可以直接修改他的指向（原型）！ 123456789101112var Bird = { fly: function () { console.log(this.name + ' is flying...'); }};var xiaoming = { name: '小明'};xiaoming.__proto__ = Bird;xiaoming.fly(); // 小明 is flying... 注意：不建议使用`__proto__`来改变指向 ¶3、要使用Object.create()方法 该方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有 为了方便，可以创建一个函数来接收姓名参数，在函数内部做一下赋值的过程即可！ 12345678910111213141516171819202122// 原型对象:var Student = { name: 'Robot', height: 1.2, run: function () { console.log(this.name + ' is running...'); }};function createStudent(name) { // 基于Student原型创建一个新对象: var s = Object.create(Student); // 初始化新对象: s.name = name; return s;}//直接创建是没有属性“小明”的：let xiaoming = Object.create(Student);//通过新建函数，传入名字，即可：var xiaoming = createStudent('小明');xiaoming.run(); // 小明 is running...xiaoming.__proto__ === Student; // true ¶二、关于proto和prototype prototype是函数的一个属性（每个函数都有一个prototype属性），这个属性是一个指针，指向一个对象。它是显示修改对象的原型的属性。 __proto__是一个对象拥有的内置属性（请注意：prototype是函数的内置属性，__proto__是对象的内置属性），是JS内部使用寻找原型链的属性。 区别参考链接：https://www.cnblogs.com/yangjinjin/archive/2013/02/01/2889103.html ¶三、创建对象 为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写. 这样，一些语法检查工具如jslint将可以帮你检测到漏写的new。 本节参考：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022043494624 ¶1、原型链 当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。 ¶数组原型链 Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。 12var arr = [1, 2, 3];arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null ¶函数原型链 Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。 1234function foo() { return 0;}foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null ¶2、构造函数 用new来调用函数，返回一个对象！ 函数内部的this指向新创建的对象！并默认返回this!不需要写return了！ 必须写new，不写new，函数返回的是undefined！ 12345678910function Student(name) { this.name = name; this.hello = function () { alert('Hello, ' + this.name + '!'); }}var xiaoming = new Student('小明');xiaoming.name; // '小明'xiaoming.hello(); // Hello, 小明! 此时小明的原型链： 1xiaoming ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null ¶3、constructor 用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身： 123456xiaoming.constructor === Student.prototype.constructor; // trueStudent.prototype.constructor === Student; // trueObject.getPrototypeOf(xiaoming) === Student.prototype; // truexiaoming instanceof Student; // true ¶4、公用函数（共享方法） 如果我们通过new Student()创建了很多对象，这些对象的hello函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。 通过够着函数.prototype.函数名来创建公用函数，节省内存！ 1234567function Student(name) { this.name = name;}Student.prototype.hello = function () { alert('Hello, ' + this.name + '!');}; ¶5、解决忘写new的方法 我们还可以编写一个createStudent()函数，在内部封装所有的new操作。 || ：用或符号来实现默认值，毕竟是就近原则的！ 将new封装后，即可不用写new了，以防忘写！ 123456789101112function Student(props) { this.name = props.name || '匿名'; // 默认值为'匿名' this.grade = props.grade || 1; // 默认值为1}Student.prototype.hello = function () { alert('Hello, ' + this.name + '!');};function createStudent(props) { return new Student(props || {})} 不传参都行 也可以这样定义 这样传参传的是一个对象，是不需要顺序的！ 12345var xiaoming = createStudent({ name: '小明'});xiaoming.grade; // 1 ¶四、原型继承 本节参考：https://www.liaoxuefeng.com/wiki/1022910821149312/1023021997355072 原型链： 1new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null 我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： F空函数起到一个桥接的作用！ 123456789101112131415161718192021222324252627282930313233343536373839// PrimaryStudent构造函数:function PrimaryStudent(props) { Student.call(this, props); this.grade = props.grade || 1;}// 空函数F:function F() {}// 把F的原型指向Student.prototype:F.prototype = Student.prototype;// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:PrimaryStudent.prototype = new F();// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:PrimaryStudent.prototype.constructor = PrimaryStudent;// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：PrimaryStudent.prototype.getGrade = function () { return this.grade;};// 创建xiaoming:var xiaoming = new PrimaryStudent({ name: '小明', grade: 2});xiaoming.name; // '小明'xiaoming.grade; // 2// 验证原型:xiaoming.__proto__ === PrimaryStudent.prototype; // truexiaoming.__proto__.__proto__ === Student.prototype; // true// 验证继承关系:xiaoming instanceof PrimaryStudent; // truexiaoming instanceof Student; // true 关于call()函数：https://www.runoob.com/w3cnote/js-call-apply-bind.html 是用来重定义 this 这个对象的! ¶五、class继承 在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。 有没有更简单的写法？有！ 新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。 用class来写，上面章节中的继承和对象编程就简单多了！ constructor很明显是够着函数！ 注意没有function关键字！ 1234567891011class Student { constructor(name) { this.name = name; } hello() { alert('Hello, ' + this.name + '!'); }}var xiaoming = new Student('小明');xiaoming.hello(); ¶class继承 用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现： extends表示原型链对象来自Student！ 使用super()函数来调用父类的（即Student）的构造方法！ class继承和原型继承没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。 12345678910class PrimaryStudent extends Student { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert('I am at grade ' + this.grade); }} ¶本章节到此结束，敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://www.itnxd.cn/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.itnxd.cn/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"https://www.itnxd.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之标准对象","slug":"JavaScript教程系列之标准对象","date":"2020-02-17T07:31:19.000Z","updated":"2020-05-18T13:54:01.940Z","comments":true,"path":"posts/15769.html","link":"","permalink":"https://www.itnxd.cn/posts/15769.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 在 JavaScript 的世界里，一切皆对象！ ¶一、包装对象 ¶1、用typeof来识别身份 number、string、boolean、function和undefined有别于其他类型。特别注意null的类型是object，Array的类型也是object，如果我们用typeof将无法区分出null、Array和通常意义上的object——{}。 123456789typeof 123; // 'number'typeof NaN; // 'number'typeof 'str'; // 'string'typeof true; // 'boolean'typeof undefined; // 'undefined'typeof Math.abs; // 'function'typeof null; // 'object'typeof []; // 'object'typeof {}; // 'object' ¶2、通过new来包装对象 number、boolean和string都有包装对象。没错，在JavaScript中，字符串也区分string类型和它的包装类型。包装对象用new创建： 经过new包装的元素类型已经变为了对象！ 注意：闲的蛋疼也不要使用包装对象！尤其是针对`string`类型！！！ 123var n = new Number(123); // 123,生成了新的包装类型var b = new Boolean(true); // true,生成了新的包装类型var s = new String('str'); // 'str',生成了新的包装类型 12345678typeof new Number(123); // 'object'new Number(123) === 123; // falsetypeof new Boolean(true); // 'object'new Boolean(true) === true; // falsetypeof new String('str'); // 'object'new String('str') === 'str'; // false 注意：创建包装对象后的与原始值不同！！！ ¶3、不使用new的结果 Number()、Boolean和String()被当做普通函数，把任何类型的数据转换为number、boolean和string类型（注意不是其包装类型）： 1234567891011var n = Number('123'); // 123，相当于parseInt()或parseFloat()typeof n; // 'number'var b = Boolean('true'); // truetypeof b; // 'boolean'var b2 = Boolean('false'); // true! 'false'字符串转换结果为true！因为它是非空字符串！var b3 = Boolean(''); // falsevar s = String(123.45); // '123.45'typeof s; // 'string' ¶4、简单总结 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === 'undefined'； ¶toString()方法 除了null 和 undefined ,其他对象都有此方法！ 用来将一个对象转换为字符串类型！ 注意，数字调用toString方法时，会报错，因为程序会认为.不是调用方法而是看成了小数； 所以要使用两个点，或者加一个括号，将他变成整体！ 1234123.toString(); // SyntaxError123..toString(); // '123', 注意是两个点！(123).toString(); // '123' ¶二、Data对象 ¶1、获取对象 通过new Data()来构建一个时间对象 可以获得，年月日，星期，时分秒，毫秒，以及时间戳！ 注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。 1234567891011var now = new Date();now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)now.getFullYear(); // 2015, 年份now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月now.getDate(); // 24, 表示24号now.getDay(); // 3, 表示星期三now.getHours(); // 19, 24小时制now.getMinutes(); // 49, 分钟now.getSeconds(); // 22, 秒now.getMilliseconds(); // 875, 毫秒数now.getTime(); // 1435146562875, 以number形式表示的时间戳 ¶2、创建对象 ¶创建指定日期的Data对象: 12var d = new Date(2015, 5, 19, 20, 15, 30, 123);d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST) 注意：JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。！ 注意：JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 ¶通过解析ISO 8601格式的字符串 返回值为时间戳！ 使用Date.parse()时传入的字符串使用实际月份01 ~ 12，转换为Date对象后getMonth()获取的月份值为0 ~ 11。 要获取具体内容，得通过传入时间戳创建对象，再调用函数获得具体信息！ 123456var d = Date.parse('2015-06-24T19:49:22.875+08:00');d; // 1435146562875var d = new Date(1435146562875);d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)d.getMonth(); // 5 ¶时间戳 时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。 我们只需要传递时间戳，或者把时间戳从数据库里读出来，再让JavaScript自动转换为当地时间就可以了。 获取当前时间戳： 两种方法： Data的now方法 Data的getTime方法 12console.log(Date.now()); console.log(new Date().getTime()); ¶时区 Date对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间： 只要我们传递的是一个number类型的时间戳，我们就不用关心时区转换。任何浏览器都可以把一个时间戳正确转换为本地时间。 123var d = new Date(1435146562875);d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时 ¶三、RegExp对象 就是正则表达式！ ¶1、基础匹配 \\d ：一个数字 \\w ：一个数字或一个字母（大小写） \\s ：一个空格 . ：一个任意字符 \\. ：一个小数点 * ：任意个（包括0个） + ：至少一个 ？ ：0个或1个 {n} ：n个 {n, m} ：n 到 m 个 \\- ：一个- \\\\ ：一个\\ 123js. //可以表示js! js1 jsp\\d{3}\\s+\\d{3,8} //即三个数字一个空格然后是三到八个数字eg:010-12345 ¶2、做到更精确的匹配，用方括号表示范围： [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串 [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就JavaScript允许的变量名 [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符） A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 你可能注意到了，js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了。 ¶3、创建正则表达式 ¶通过/正则表达式/ 创建 ¶通过new RegExp('正则表达式')创建 注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个\\\\实际上是一个\\。 12345var re1 = /ABC\\-001/;var re2 = new RegExp('ABC\\\\-001');re1; // /ABC\\-001/re2; // /ABC\\-001/ ¶4、正则表达式匹配 使用re.test(待测字符串) 1234var re = /^\\d{3}\\-\\d{3,8}$/;re.test('010-12345'); // truere.test('010-1234x'); // falsere.test('010 12345'); // false ¶5、切分字符串 使用字符串.split(正则表达式) 来切割： 第一个：按一个空格分隔 第二个：按一个或多个空格分隔 第三个：按按空格和逗号大于等于一个的任意组合分隔 第四个：按空格和逗号和分号的大于等于一个的任意组合分隔 1234'a b c'.split(' '); // ['a', 'b', '', '', 'c']'a b c'.split(/\\s+/); // ['a', 'b', 'c']'a,b, c d'.split(/[\\s\\,]+/); // ['a', 'b', 'c', 'd']'a,b;; c d'.split(/[\\s\\,\\;]+/); // ['a', 'b', 'c', 'd'] ¶6、字符串分组 将需要分组的部分用()括起来即可 使用：正则表达式.exec(待测字符串) 进行分组 结果返回一个Array，[原字符串， 分组1， 分组2，....] 若无法匹配字符串，则返回null 123var re = /^(\\d{3})-(\\d{3,8})$/;re.exec('010-12345'); // ['010-12345', '010', '12345']re.exec('010 12345'); // null 看一个凶残的例子： 12var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;re.exec('19:05:30'); // ['19:05:30', '19', '05', '30'] | 表示或者，首先看冒号前的，从前往后表示00-09、10-19、20-29…最后一个是1-9，因为有时候01不写01，而写1，所以加一个[0-9]更合适。后面类似。。。 ¶7、贪婪匹配 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： 12var re = /^(\\d+)(0*)$/;re.exec('102300'); // ['102300', '102300', ''] 由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配： ? ：即先满足后方的条件，再考虑前方！ 12var re = /^(\\d+?)(0*)$/;re.exec('102300'); // ['102300', '1023', '00'] ¶8、全局搜索 JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配： 即在正则表达式的最后加一个g 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引： 全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。 拓展：正则表达式还可以指定i标志，表示忽略大小写；m标志，表示执行多行匹配。 123var r1 = /test/g;// 等价于:var r2 = new RegExp('test', 'g'); 如下： 1234567891011121314151617var s = 'JavaScript, VBScript, JScript and ECMAScript';var re=/[a-zA-Z]+Script/g;// 使用全局匹配:re.exec(s); // ['JavaScript']re.lastIndex; // 10re.exec(s); // ['VBScript']re.lastIndex; // 20re.exec(s); // ['JScript']re.lastIndex; // 29re.exec(s); // ['ECMAScript']re.lastIndex; // 44re.exec(s); // null，直到结束仍没有匹配到 ¶9、小栗子 ¶实现验证邮箱的正则表达式： 邮箱组成： 数字字母、下划线、小数点、- ,并且不以-开头 @符号 域名前缀：字母数字以及·-的任意组合，且不能以-开头 . 域名后缀： 1、只有一组字符：eg ：.com, .cn 2、有两组：eg: edu.cn、.com.cn eg：9zdfsk7sdf-hsdf7sdf88dsf.sdfhi.sjiodf99sdf@bbsdkf-88sdf-sgd.com.cn 例子有点夸张，哈哈哈哈哈！ 123let re = /^\\w+\\.?\\w+@\\w+\\.\\w+$/;let re = /^[0-9a-zA-Z]+\\.?[0-9a-zA-Z]+\\@[0-9a-zA-Z]+\\.[0-9a-zA-Z]+$/;let re = /^[a-zA-Z0-9]+([._-]?[a-zA-Z0-9]+)*@([a-zA-Z0-9]+[_-]?[a-zA-Z0-9]+)([_-][a-zA-Z0-9]+)*\\.[a-zA-Z]{2,3}(\\.[a-zA-Z]{2})?$/; ¶四、JSON对象 JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。 ¶1、JSON的故事 在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。 终于，在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。 ¶2、JSON的数据类型 number：和JavaScript的number完全一致； boolean：就是JavaScript的true或false； string：就是JavaScript的string； null：就是JavaScript的null； array：就是JavaScript的Array表示方式——[]； object：就是JavaScript的{ ... }表示方式。 JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。 为了统一解析，JSON的字符串规定必须用双引号\"\"，Object的键也必须用双引号\"\"。 由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。 ¶3、JSON序列化 通过JSON的stringfy()方法来进行序列化： 123456789101112var xiaoming = { name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\\\"W3C\\\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp']};var s = JSON.stringify(xiaoming);console.log(s);//{\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]} 为了好看一点：按照缩进输出： 12345678910111213141516JSON.stringify(xiaoming, null, ' ');//结果：{ \"name\": \"小明\", \"age\": 14, \"gender\": true, \"height\": 1.65, \"grade\": null, \"middle-school\": \"\\\"W3C\\\" Middle School\", \"skills\": [ \"JavaScript\", \"Java\", \"Python\", \"Lisp\" ]} 123456789101112131415161718192021222324252627282930313233343536JSON.stringify(xiaoming, ['name', 'skills'], ' ');//结果：只输出name和skills的结果：{ \"name\": \"小明\", \"skills\": [ \"JavaScript\", \"Java\", \"Python\", \"Lisp\" ]}function convert(key, value) { if (typeof value === 'string') { return value.toUpperCase(); } return value;}JSON.stringify(xiaoming, convert, ' ');//结果：将值为String类型的都大写输出：{ \"name\": \"小明\", \"age\": 14, \"gender\": true, \"height\": 1.65, \"grade\": null, \"middle-school\": \"\\\"W3C\\\" MIDDLE SCHOOL\", \"skills\": [ \"JAVASCRIPT\", \"JAVA\", \"PYTHON\", \"LISP\" ]} 更精确控制： 可以在对象内部定义一个toJSON()的方法： 1234567891011121314151617var xiaoming = { name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\\\"W3C\\\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp'], toJSON: function () { return { // 只输出name和age，并且改变了key： 'Name': this.name, 'Age': this.age }; }};JSON.stringify(xiaoming); // '{\"Name\":\"小明\",\"Age\":14}' ¶4、反序列化 将JSON格式化后的字符串变为JavaScript对象 格式：JSON.parse(格式化的字符串)； 1234JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]JSON.parse('{\"name\":\"小明\",\"age\":14}'); // Object {name: '小明', age: 14}JSON.parse('true'); // trueJSON.parse('123.45'); // 123.45 parse()还可以跟一个函数来控制： 如果属性是name，则在对应的值上加同学两个字： 1234567var obj = JSON.parse('{\"name\":\"小明\",\"age\":14}', function (key, value) { if (key === 'name') { return value + '同学'; } return value;});console.log(JSON.stringify(obj)); // {\"name\": \"小明同学\", \"age\": 14} ¶本节到此结束，欢迎阅读，敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://www.itnxd.cn/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.itnxd.cn/tags/JavaScript/"},{"name":"Data","slug":"Data","permalink":"https://www.itnxd.cn/tags/Data/"},{"name":"RegExp","slug":"RegExp","permalink":"https://www.itnxd.cn/tags/RegExp/"},{"name":"JSON","slug":"JSON","permalink":"https://www.itnxd.cn/tags/JSON/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之函数","slug":"JavaScript教程系列之函数","date":"2020-02-11T08:29:20.000Z","updated":"2020-05-19T02:38:30.339Z","comments":true,"path":"posts/52313.html","link":"","permalink":"https://www.itnxd.cn/posts/52313.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶一、函数的定义与调用 ¶定义 1234567function abs(x) { if (x &gt;= 0) return x; else return -x;}abs(-9);// 9 JavaScript用function来指出这是一个函数 JavaScript不写return语句自动返回undefined ¶调用 调用时参数可以有多个，即使定义时参数为1个 12abs(10, 'blablabla'); // 返回10abs(-9, 'haha', 'hehe', null); // 返回9 传入参数比定义还少也可以，返回NaN 此时参数 x 将收到undefined，为了避免参数收到undefined，可以进行一下判断： 这样，若没有参数，或参数传错即可输出一条提示语句。 typedef 来返回值得类型，可以用括号将参数括起来，也可以直接以空格隔开。 throw 语句：语句允许您创建自定义错误。从技术上讲能够抛出异常（抛出错误）。异常可以是 JavaScript 字符串、数字、布尔或对象： 12345678910abs(); // 返回NaN x 收到参数为undefinedfunction abs(x) { if (typeof x !== 'number') throw 'Not a number'; if (x &gt;= 0) return x; else return -x;} ¶arguments JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array： 可以接收传入的所有参数 123456789function foo(x) { console.log('x = ' + x); // 10 for (var i=0; i&lt;arguments.length; i++) { console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30 }}foo(10, 20, 30); 关键字在可以用来解决没有参数，但却传参无法接收参数的问题 1234567891011function abs() { if (arguments.length === 0) return 0; var x = arguments[0]; return x &gt;= 0 ? x : -x;}abs(); // 0abs(10); // 10abs(-9); // 9 解决可选参数问题 此函数可以用来解决可选参数与函数内部实际参数的对应关系，以免造成混乱 调用时是将a给了a，c给了b，所以为了保证对应，用if来判断，并作出修改 123456789101112// foo(a[, b], c)// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：function foo(a, b, c) { if (arguments.length === 2) { // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 } // ...} ¶rest参数 rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。 123456789101112131415161718function foo(a, b, ...rest) { console.log('a = ' + a); console.log('b = ' + b); console.log(rest);}foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] ¶return 语句 注意：与C++不同，JavaScript引擎有一个在行末自动添加分号的机制，所以要保证你的句子不要写错。 12345678910111213141516171819function foo1() { return //这就是错的 { name: 'foo' };}function foo2() { return { name: 'foo' };}function foo3() { return { name: 'foo' };}foo3(); // { name: 'foo' } 如上：1是错的，2、3是对的。 ¶二、变量作用域 ¶1、变量作用域同其他语言一样，从内到外 ¶2、变量提升 ¶变量提升介绍 只针对var声明的变量，let没有这些奇怪的用法 1234567891011121314151617function foo(){ var x = 'Hello, ' + y; console.log(x); var y = 'Bob';}foo();//Hello, undefined//上面的写法相当于下面的写法function foo(){ var y; // 提升变量y的申明，此时y为undefined var x = 'Hello, ' + y; console.log(x); y = 'Bob';} 不会报错，原因是变量y在稍后申明了。但是console.log显示Hello, undefined，说明变量y的值为undefined。 这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。 So 用到的变量最好提前声明。。。以防 不必要麻烦。。。 ¶var 声明变量 一次声明所有需要的变量。。 1234567function foo() { var x = 1, // x初始化为1 y = x + 1, // y初始化为2 z, i; // z和i为undefined} ¶全局作用域 不在任何函数内定义的变量就具有全局作用域。 实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性. 1234567891011121314var course = 'Learn JavaScript';alert(course); // 'Learn JavaScript'alert(window.course); // 'Learn JavaScript'function foo() { alert('foo');}foo(); // 直接调用foo()window.foo(); // 通过window.foo()调用alert(\"hhhhh\");window.alert('调用window.alert()'); ¶名字空间 全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中 著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。 其实就是用一个自定义的对象绑定了。。。 123456789101112// 唯一的全局变量MYAPP:var MYAPP = {};// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () { return 'foo';}; ¶局部作用域 ¶var 无法实现for循环的局部范围 12345678function foo() { for (var i=0; i&lt;100; i++) { // } i += 100; // 仍然可以引用变量i} ¶let let没有这个问题 12345678910function foo() { var sum = 0; for (let i=0; i&lt;100; i++) { sum += i; } // SyntaxError: i += 1;} 所以定义变量建议全部使用let，而不使用var; ¶const 用来定义常量，定义的常量不会被修改值 123const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14 ¶3、解构赋值 ¶具体使用 使用解构赋值，直接对多个变量同时赋值 数组结构多个变量要使用[]来解构 数组若是嵌套，要保证对应层次相同 可以省略不想解构的值，逗号隔开即可 对对象解构要使用{} 对象的嵌套也要保证解构的层次对应清楚，属性后面根冒号再写大括号，eg：,address: {city, zip}, 找不到的属性会报错undefined 12345678910111213141516171819202122232425262728293031let [x, y, z] = ['hello', 'JavaScript', 'ES6'];console.log(x,y,z);//hello JavaScript ES6let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素let person ={ name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'};let {name, age, passport} = person;let person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: { city: 'Beijing', street: 'No.1 Road', zipcode: '100001' }};let {name, address: {city, zip}} = person;let {name, single=true} = person; 声明过的变量要想赋值，不能直接使用，要使用圆括号括起来 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来： 1234567// 声明变量:let x, y;// 解构赋值:{x, y} = { name: '小明', x: 100, y: 200};// 语法错误: Uncaught SyntaxError: Unexpected token =//正确写法:({x, y} = { name: '小明', x: 100, y: 200}); 如果想给对象中的属性换个名字，解构的时候可以在变量名后面加一个冒号，加上想要改的别名即可。。 1234567891011121314let person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'};// 把passport属性赋值给变量id:let {name, passport:id} = person;name; // '小明'id; // 'G-12345678'// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined 添加默认值，直接用等号赋值即可， 可以解决找不到属性，返回undefined的错误 1234567891011let person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678'};// 如果person对象没有single属性，默认赋值为true:let {name, single=true} = person;name; // '小明'single; // true ¶用处 用来交换两个值！ 12let x=1, y=2;[x, y] = [y, x] 快速获取当前页面域名和路径 1var {hostname:domain, pathname:path} = location; 创建Date对象 123456789101112131415161718function buildDate({year, month, day, hour=0, minute=0, second=0}){ return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);}let t = buildDate({ year: 2020, month: 2, day: 12, hour: 20, minute: 15 });console.log(t);//Wed Feb 12 2020 20:15:00 GMT+0800 (中国标准时间)//或者这样进行解构var time = {};time.year = 2018;time.month = 1;time.day = 1;time.hour = 23;time.minute = 45;time.second = 18;console.log(buildDate(time)); ¶三、对象内的函数 ¶1、定义及使用 调用时加上括号是调用函数 不加括号是调用函数内容，直接打印函数体 ¶合着来写： 1234567891011var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; }};console.log(xiaoming.age); // function xiaoming.age()console.log(xiaoming.age()); // 今年调用是25,明年调用就变成26了 浏览器返回的结果： 123456ƒ (){ var y = new Date().getFullYear(); return y - this.birth;}30 ¶分开来写： 1234567891011121314function getAge() { var y = new Date().getFullYear(); return y - this.birth;}var xiaoming = { name: '小明', birth: 1990, age: getAge};console.log(xiaoming.age()); // 25, 正常结果console.log(getAge()); // NaN 直接调用函数，由于this的指向就变成了全局对象windows，而windows并没有birth这个属性，所以最后会返回一个NaN; ¶错误写法 12var fn = xiaoming.age; // 先拿到xiaoming的age函数fn(); // NaN 这种写法也是错的，必须直接用对象加点加属性来调用 1xiaoming.age(); ¶重构函数 第一种，this指向是windows，结果为NaN 第二种：this指向that,that指向xiaoming，结果正确 1234567891011121314151617181920212223242526272829303132333435//第一种，this指向是windowsvar xiaoming = { name: '小明', birth: 1990, age: function () { function getAgeFromBirth() { var y = new Date().getFullYear(); return y - this.birth; } return getAgeFromBirth(); }};xiaoming.age(); // NaN//第二种：this指向that,that指向xiaomingvar xiaoming = { name: '小明', birth: 1990, age: function () { var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() { var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this } return getAgeFromBirth(); }};xiaoming.age(); // 25 ¶2、this 在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。 而直接在函数内部使用this，则指向的是windows全局对象 ¶apply()方法 用来改变this 指向 它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 123456789101112131415function getAge() { var y = new Date().getFullYear(); return y - this.birth;}var xiaoming = { name: '小明', birth: 1990, age: getAge};xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 ¶call()方法 apply()把参数打包成Array再传入； call()把参数按顺序传入。 对于一般函数，通常把this绑定为 null 即可 12Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5 ¶3、装饰器 通过apply()方法我们可以动态改变函数作用 可以实现在原函数不变的情况下增加功能的效果 先保留原函数 再改变原函数，最后通过apply()方法传入this指向和参数，return回去原函数的作用 达到增加功能的效果 arguments即当前函数接收到的所有参数，再次传给保留的旧函数，进行作用 ¶而apply最大的作用就是可以将改造函数传入的一堆参数再原封不动的传给旧函数！！！ 1234567891011121314var count = 0;var oldParseInt = parseInt; // 保存原函数window.parseInt = function () { count += 1; return oldParseInt.apply(null, arguments); // 调用原函数};// 测试:parseInt('10');parseInt('20');parseInt('30');console.log('count = ' + count); // 3 ¶四、高阶函数 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 简单的例子： 123456function add(x, y, f){ return f(x) + f(y);}let x = add(-5, 8, Math.abs);console.log(x);//13 ¶1、map()函数 此方法是专门针对数组的 由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果 map参数为函数名 1234567891011function pow(x){ return x * x;}var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]console.log(results);var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] ¶2、reduce()函数 Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上 这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： 1[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) 就是一个迭代过程！ ¶利用reduce求乘积 12345function product(arr){ return arr.reduce((x,y)=&gt;x*y);}console.log(product([1,5,2,7,9]));//630 ¶利用reduce 将数字数组转化为整数 12345let arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) { return x * 10 + y;}); // 13579 ¶将字符串变为数字 1234567891011121314151617181920212223function stringToint(s) { let ss = []; for(let i = 0; i &lt; s.length; i++) ss.push(s[i]); let arr = ss.map(x =&gt; x -= '0'); let res = arr.reduce((x,y) =&gt; x * 10 + y); return res; //或者合并一下操作，这样也可以： return ss.map((x) =&gt; x -= '0').reduce((x, y) =&gt; (x*10+y)); //用split函数来得到一个副本为单个字符的数组 return s.split('').map(x =&gt; x * 1).reduce((x, y) =&gt; x * 10 + y) //或者直接使用下面的语句： return s* 1; //使用自带的parseInt函数 r = ss.map(function(x){ return parseInt(x)});}stringToint('43859843');//43859843 注意： return s* 1 ：隐式类型转换 ，会将操作数转换成数字类型，如运算符-, *, /,% ¶首字母大写，其他小写 输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']。 12345678910111213141516171819202122232425262728293031323334353637function normalize(arr) { let arrs = []; arrs = arr.map(function(x){ let s = x[0].toUpperCase(); for(let i = 1; i &lt; x.length; i++) s += x[i].toLowerCase(); return s; }); return arrs; //或者这样 return arr.map((x) =&gt; { let a = ''; for (let v of x) { if (!a) a += v.toUpperCase(); else a += v.toLowerCase(); } return a; })； //或者使用split函数分割再使用reduce进行拼接 return arr.map(function(s){ var c=s.toLowerCase().split(''); c[0]=c[0].toUpperCase(); return c.reduce((x,y)=&gt;x+y); });} //或者这样，比较精巧，使用字符串的substr函数 return arr.map(function(arr){ return arr[0].toUpperCase()+arr.substr(1).toLowerCase(); }); //或者这样，使用数组的slice函数 return arr.map(s =&gt; s[0].toUpperCase() + s.slice(1).toLowerCase());console.log(normalize(['adam', 'LISA', 'barT'])); ¶3、filter()函数 filter同样是作用于数组Array的函数！ filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。 简而言之：就是一个按条件过滤函数； 返回新数组！ 过滤掉偶数： 12345let arr = [1, 2, 4, 5, 6, 9, 10, 15];let r = arr.filter(function (x){ return x % 2 !== 0;});r; // [1, 5, 9, 15] 过滤掉空字符串： 字符串的trim函数用来删除字符串的头尾空格。 12345var arr = ['A', '', 'B', null, undefined, 'C', ' '];var r = arr.filter(function (s) { return s &amp;&amp; s.trim();});r; // ['A', 'B', 'C'] filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身： 1234567var arr = ['A', 'B', 'C'];var r = arr.filter(function (element, index, self) { console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // ['A', 'B', 'C'] return true;}); 过滤掉相同的元素 过滤掉数组找到的当前元素下标和当前元素的真正下标不相等的 indexOf函数总是返回数组中找到的第一个匹配的下标，所以后面有相同字符串不同下标的时候就会自动过滤。 12345678910var r, arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry']; r = arr.filter(function (element, index, self) { return self.indexOf(element) === index;});console.log(r); ¶4、sort()函数 通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1 sort函数会直接修改当前Array，注意！ sort 返回修改后的数组！ 12345678// 看上去正常的结果:['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];// apple排在了最后:['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft\", 'apple']// 无法理解的结果:[10, 20, 1, 2].sort(); // [1, 10, 2, 20] 第一个正常 第二个不正常，都是按照ASKII码排序的 第三个不正常，虽然是数字，但Array的sort()方法默认把所有元素先转换为String再排序 作为高阶函数sort自然可以穿函数参数： 与其他语言不同，比较函数得写全，不能只写一个if 返回的1可以理解为需要交换 返回-1表示不需要交换 返回0表示。。。 数字比价 12345678910111213arr.sort(function (x, y) { if (x &lt; y) return -1; if (x &gt; y) return 1; return 0;});console.log(arr); // [1, 2, 10, 20]arr.sort(function (x, y) { if (x &lt; y) return 1; if (x &gt; y) return -1; return 0;});console.log(arr); // [20,10,2,1] 字符串比较 既有大写又有小写，则统一一下进行比较 123456789101112var arr = ['Google', 'apple', 'Microsoft'];arr.sort(function (s1, s2) { x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) { return -1; } if (x1 &gt; x2) { return 1; } return 0;}); // ['apple', 'Google', 'Microsoft'] ¶5、every()函数 every()方法可以判断数组的所有元素是否满足测试条件。 返回值为 true 或 false 123456789var arr = ['Apple', 'pear', 'orange'];console.log(arr.every(function (s) { return s.length &gt; 0;})); // true, 因为每个元素都满足s.length&gt;0console.log(arr.every(function (s) { return s.toLowerCase() === s;})); // false, 因为不是每个元素都全部是小写 ¶6、find()函数 find()方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined： 返回元素 123456789var arr = ['Apple', 'pear', 'orange'];console.log(arr.find(function (s) { return s.toLowerCase() === s;})); // 'pear', 因为pear全部是小写console.log(arr.find(function (s) { return s.toUpperCase() === s;})); // undefined, 因为没有全部是大写的元素 ¶7、findIndex()函数 findIndex()和find()类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，如果没有找到，返回-1： 返回索引 123456789var arr = ['Apple', 'pear', 'orange'];console.log(arr.findIndex(function (s) { return s.toLowerCase() === s;})); // 1, 因为'pear'的索引是1console.log(arr.findIndex(function (s) { return s.toUpperCase() === s;})); // -1 ¶8、forEach forEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。forEach()常用于遍历数组，因此，传入的函数不需要返回值： 12var arr = ['Apple', 'pear', 'orange'];arr.forEach(console.log); // 依次打印每个元素 ¶五、闭包 ¶1、函数作为返回值 12345678function sum(arr) { return arr.reduce(function (x, y) { return x + y; });}sum([1, 2, 3, 4, 5]); // 15 ¶2、延迟执行函数 对上一个进行包装，写成一个函数套函数即可实现 f1()和f2()的调用结果互不影响，返回的都是一个新的独立的函数！ 1234567891011121314151617function lazy_sum(arr) { var sum = function () { return arr.reduce(function (x, y) { return x + y; }); } return sum;}var f = lazy_sum([1, 2, 3, 4, 5]); // f接收sum用来求和的函数f(); // 15 调用f指向的sum函数var f1 = lazy_sum([1, 2, 3, 4, 5]);var f2 = lazy_sum([1, 2, 3, 4, 5]);f1 === f2; // false ¶3、闭包 闭包参考，加深理解： JavaScript之闭包 在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。 在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。 函数内部的函数不进行函数的函数调用是不会执行的！ 简而言之：就是为了让外部的人访问不到内部的东西，外部的人看不到内部存在的闭包 ¶最简单的闭包： 123456789101112function makeFunc() { var name = \"Mozilla\"; function displayName() { alert(name); } return displayName;}var myFunc = makeFunc();myFunc(); 在一些编程语言中，函数中的局部变量仅在函数的执行期间可用。 一旦 makeFunc() 执行完毕，我们会认为 name 变量将不能被访问。然而，因为代码运行得没问题，所以很显然在 JavaScript 中并不是这样的。 JavaScript这样的原因是：JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成，这个环境包括了这个闭包创建时所能访问的所有局部变量。在上面的例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用，而 displayName 实例仍可访问其词法作用域中的变量，即可以访问到 name 。由此，当 myFunc 被调用时，name 仍可被访问，其值 Mozilla 就被传递到alert中。 ¶函数生产工厂 12345678910111213function makeAdder(x) { return function(y) { return x + y; };}var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7 实现参数和5加的函数console.log(add10(2)); // 12 实现参数和10加的函数 ¶闭包问题来源 本例子引用廖雪峰JavaScript之闭包 12345678910111213141516function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push(function () { return i * i; }); } return arr;}var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2]; 在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是： 123f1(); // 16f2(); // 16f3(); // 16 问题解析： 首先我们弄懂上面代码的运行流程： 首先var results = count();之后，函数count已经被调用了，所以一次执行函数内的各段代码：var arr = [];，for (var i=1; i&lt;=3; i++)，这个for循环尤其值得注意。 因为此时循环体执行了push方法，将一个个函数function () { return i * i;}添加到数组内，但是这个函数并没有被调用，还只是一个变量，所以for循环依次执行，直到i = 4。因为闭包，内部函数function () { return i * i;}引用的i就是外部变量，for循环中的i = 4。所以，之后数组arr内的函数的i都是4。 调用函数count后，变量results已经是数组arr了。数组里面元素依次是function f1() { return i * i;} function f2() { return i * i;} function f3() { return i * i;}。但是三个函数都没有被调用，直到var f1 = results[0];，此时function f1() { return i * i;}开始执行，如上段所写，此时的i = 4，所以，返回值就是16了。后面两个调用也是类似情况。 简而言之：就是因为函数内部的函数不会直接执行，会等到调用了外部函数之后，在调用 到内部的函数时，才会执行，也就是说，var results = count();这里还没有调用到内部的函数，直到var f1 = results[0];被调用时，才会调用到内部的函数！ 然而：在count()函数被调用时，i的值就已经变为了4，所以在result()调用时，i 其实是4,； 同理：后面的所有i 就都变为了4！ 解决办法 为了实现我们理想的结果，1，4，9；可以这样做： 注意这里用了一个“创建一个匿名函数并立刻执行”的语法： 123456789101112131415161718192021222324252627282930313233343536373839404142function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push((function (n) { return function () { return n * n; } })(i)); } return arr;}var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9//或者这样：function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push((function (n) { return n * n; })(i)); } return arr;}var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];console.log(f1); // 1console.log(results[1]);//4 “创建一个匿名函数并立刻执行” 最后小括号内引用的参数是用来保存值的，也是为了传递到函数的 x 参数使用的，同时做到了即刻执行的效果！ 注意：函数要用小括号括起来： 123(function (x) { return x * x;})(3); // 9 ¶4、对象作为返回值 此时return 后面跟的是一个大括号，即是一个对象： 12345678910111213141516171819function create_counter(initial) { var x = initial || 0; return { inc: function () { x += 1; return x; } }}var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2c1.inc(); // 3var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12c2.inc(); // 13 解析： 在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。 函数内部的x += 1;实际上他已经改变了函数内部的x，也就是对当前函数来说的局部变量x,由于闭包的出现，导致c2这个函数不会终止，即第一次的调用对后续是有累积效应的！ 而c1和c2则是完全独立的！ ¶六、箭头函数 最简单的例子：二者一样： ¶一条语句 123456x =&gt; x * xfunction (x){ return x * x;} 箭头函数相当于匿名函数(即没有函数名！)，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ ... }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ ... }和return： ¶多条语句 1234x =&gt; { if (x &gt; 0) return x * x; else return - x * x;} ¶多个参数： 需要用小括号括起来：无参数也需要括起来； 1234567891011121314// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; { var i, sum = x + y; for (i=0; i&lt;rest.length; i++) { sum += rest[i]; } return sum;} ¶返回对象 本来要用大括号，但是对象也是大括号，所以用小括号来括住了！ 1x =&gt; ({ foo: x }) ¶this 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 箭头函数this的指向永远是作用域内的那个指向！ 而不是普通函数的指向；要想实现真正指向，如以前教程，可以var that = this; 如下：普通函数this指向windows会undefined 12345678910var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = function () { return new Date().getFullYear() - this.birth; // this指向window或undefined }; return fn(); }}; 改用箭头函数后：this始终指向obj对象！ 123456789var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); }};obj.getAge(); // 25 使用了箭头函数后，无法通过参数来改变this指向 this指向还是obj，而不是此时的year！ 由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略： 123456789var obj = { birth: 1990, getAge: function (year) { var b = this.birth; // 1990 var fn = (y) =&gt; y - this.birth; // this.birth仍是1990 return fn.call({birth:2000}, year); }};obj.getAge(2015); // 25 ¶七、generator 一个generator看上去像一个函数，但可以返回多次。 可以实现多次return的作用 ¶1、普通的 实现斐波那契数列的算法 只有返回一个数组才能得到最终结果 1234567891011121314151617function fib(max) { var t, a = 0, b = 1, arr = [0, 1]; while (arr.length &lt; max) { [a, b] = [b, a + b]; arr.push(b); } return arr;}// 测试:fib(5); // [0, 1, 1, 2, 3]fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ¶2、使用generator generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。 直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。 调用方法一：调用generator对象的next()方法： next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}， 然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。 当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。 12345678910111213141516171819202122function* fib(max) { var t, a = 0, b = 1, n = 0; while (n &lt; max) { yield a; [a, b] = [b, a + b]; n ++; } return;}var f = fib(5);// fib {[[GeneratorStatus]]: \"suspended\", [[GeneratorReceiver]]: Window}f.next(); // {value: 0, done: false}f.next(); // {value: 1, done: false}f.next(); // {value: 1, done: false}f.next(); // {value: 2, done: false}f.next(); // {value: 3, done: false}f.next(); // {value: undefined, done: true} 调用方法二：使用for of语句 此调用不需要我们来判断done,for of 可以自动判断！ 1234567891011121314151617181920function* fib(max) { var t, a = 0, b = 1, n = 0; while (n &lt; max) { yield a; [a, b] = [b, a + b]; n ++; } return;}for (var x of fib(10)){ console.log(x); // 依次输出0, 1, 1, 2, 3, ...} ¶3、一个小栗子 实现打印下一个id: 12345678910111213function* next_id() { var x=0; while(true) { yield ++x; }}// 测试:let x g = next_id();for (x = 1; x &lt; 100; x ++) console.log(g.next().value);//[1,2,3....99] 函数这节有点难度，也是看了好久，需要经常看！经过艰难险阻，终于完结了！敬请期待下一节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://www.itnxd.cn/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.itnxd.cn/tags/JavaScript/"},{"name":"函数","slug":"函数","permalink":"https://www.itnxd.cn/tags/%E5%87%BD%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"Java教程系列之快速入门","slug":"Java教程系列之快速入门","date":"2020-02-09T11:50:45.000Z","updated":"2020-05-18T13:54:01.940Z","comments":true,"path":"posts/12025.html","link":"","permalink":"https://www.itnxd.cn/posts/12025.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ ¶为什么Java应用最广泛？ ¶从互联网到企业平台，Java是应用最广泛的编程语言，原因在于： Java是基于JVM虚拟机的跨平台语言，一次编写，到处运行； Java程序易于编写，而且有内置垃圾收集，不必考虑内存管理； Java虚拟机拥有工业级的稳定性和高度优化的性能，且经过了长时期的考验； Java拥有最广泛的开源社区支持，各种高质量组件随时可用。 ¶Java语言常年霸占着三大市场： 互联网和企业应用，这是Java EE的长期优势和市场地位； 大数据平台，主要有Hadoop、Spark、Flink等，他们都是Java或Scala（一种运行于JVM的编程语言）开发的； Android移动平台。 这意味着Java拥有最广泛的就业市场。 ¶一、Java 的诞生 ¶Java的出现 Java最早是由SUN公司（已被Oracle收购）的詹姆斯·高斯林（高司令，人称Java之父）在上个世纪90年代初开发的一种编程语言，最初被命名为Oak，目标是针对小型家电设备的嵌入式应用，结果市场没啥反响。谁料到互联网的崛起，让Oak重新焕发了生机，于是SUN公司改造了Oak，在1995年以Java的名称正式发布，原因是Oak已经被人注册了，因此SUN注册了Java这个商标。随着互联网的高速发展，Java逐渐成为最重要的网络编程语言。 ¶Java语言类型 Java介于编译型语言和解释型语言之间。 编译型语言如C、C++，代码是直接编译成机器码执行，但是不同的平台（x86、ARM等）CPU的指令集不同，因此，需要编译出每一种平台的对应机器码。 解释型语言如Python、Ruby没有这个问题，可以由解释器直接加载源码然后运行，代价是运行效率太低。 而Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。当然，这是针对Java开发者而言。对于虚拟机，需要为每个平台分别开发。为了保证不同平台、不同公司开发的虚拟机都能正确执行Java字节码，SUN公司制定了一系列的Java虚拟机规范。从实践的角度看，JVM的兼容性做得非常好，低版本的Java字节码完全可以正常运行在高版本的JVM上。 ¶Java三个版本 Java SE：Standard Edition Java EE：Enterprise Edition Java ME：Micro Edition Java SE就是标准版，包含标准的JVM和标准库 而Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。 Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。 ¶Java学习路线 首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用； 如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的； 如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发； 如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。 无论怎么选择，Java SE的核心技术是基础 ¶Java版本 1995年发布，目前已经到了 Java13 ¶名次解释 ¶JDK 和 JRE JDK：Java Development Kit JRE：Java Runtime Environment JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。 ¶JSR 和JCP JSR规范：Java Specification Request JCP组织：Java Community Process ¶RI 和 TCK 比如有人提议要搞一个基于Java开发的消息服务器，这个提议很好啊，但是光有提议还不行，得贴出真正能跑的代码，这就是RI。如果有其他人也想开发这样一个消息服务器，如何保证这些消息服务器对开发者来说接口、功能都是相同的？所以还得提供TCK。 通常来说，RI只是一个“能跑”的正确的代码，它不追求速度，所以，如果真正要选择一个Java的消息服务器，一般是没人用RI的，大家都会选择一个有竞争力的商用或开源产品。 RI：Reference Implementation 参考实现 TCK：Technology Compatibility Kit 兼容性测试套件 ¶二、JDK的安装 ¶环境变量配置 都在系统变量里设置： ¶1、新建JAVA_HOME变量，变量值为安装JDK的路径 ¶2、新建CLASSPATH变量，变量值为.;%JAVA_HOME%\\lib。 3、新增CLASSPATH变量，变量值为%JAVA_HOME%\\bin。 找到PATH点击编辑-&gt;新建 ¶测试 win + R键打开cmd: 输入java -version，若显示如下，则说明配置正确，否则需要检查路径问题，重新配置。 ¶三、Java编程规范 1234567public class Hello { public static void main(String[] args) { System.out.println(\"Hello, world!\"); }} ¶大小写敏感 Java规定，某个类定义的public static void main(String[] args)是Java程序的固定入口方法，因此，Java程序总是从main方法开始执行。 当我们把代码保存为文件时，文件名必须是Hello.java，而且文件名也要注意大小写，因为要和我们定义的类名Hello完全保持一致。 注意：文件名，必须和类名一致。 ¶运行程序 Java源码本质上是一个文本文件，我们需要先用javac把Hello.java编译成字节码文件Hello.class，然后，用java命令执行这个字节码文件： 因此，可执行文件javac是编译器，而可执行文件java就是虚拟机。 或者直接使用java hello.java 一次性完成两个过程 1234$ javac hello.java //生成hello.class$ java hello$ java hello.java 第一种，javac 后跟文件名.java , java后跟 类名，无后缀。 第二种，直接java 后跟文件名.java 需要注意的是，在实际项目中，单个不依赖第三方库的Java源码是非常罕见的，所以，绝大多数情况下，我们无法直接运行一个Java源码文件，原因是它需要依赖其他的库。 1.Java保存的文件名必须与类名一致； 2.如果文件中只有一个类，文件名必须与类名一致； 3.一个Java文件中只能有一个public类； 4.如果文件中不止一个类，文件名必须与public类名一致； 5.如果文件中不止一个类，而且没有public类，文件名可与任一类名一致。 ¶四、java 程序基础 ¶1、类 Java是面向对象的语言，一个程序的基本单位就是class，class是关键字 类名要求： 类名必须以英文字母开头，后接字母，数字和下划线的组合 习惯以大写字母开头 注意： Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。 在class内部，可以定义若干方法（method） 句子以分号结束 ¶2、注释 // ：单行注释 /* */：多行注释 /** */：如果有多行，每行通常以星号开头，可以用来自动创建文档的注释 123456789101112/** * 可以用来自动创建文档的注释 * * @auther Mr.Niu */public class Hello { public static void main(String[] args) { System.out.println(\"Hello, world!\"); }} ¶3、数据类型 计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从00000000~11111111，换算成十进制是0~255，换算成十六进制是00~ff。 整数类型： byte 一个字节 short 两个字节 int 四个字节 long 八个字节 浮点数类型： float 四个字节 double 八个字节 字符类型： char 两个字节 布尔类型： boolean 两个字节 So…范围如下： byte：-128 ~ 127 short: -32768 ~ 32767 int: -2147483648 ~ 2147483647 long: -9223372036854775808 ~ 9223372036854775807 注意：long型数据结尾需要加L，否则会报错。不加L默认为int型。 123456789101112public class Main{ public static void main(String[] args) { int i = 2147483647; int i2 = -2147483648; int i3 = 2_000_000_000; // 加下划线更容易识别 int i4 = 0xff0000; // 十六进制表示的16711680 int i5 = 0b1000000000; // 二进制表示的512 long l = 9000000000000000000L; // long型的结尾需要加L }} 注意：float型数据末尾必须加f，否则会报错，不加f默认为double类型。 12345float f1 = 3.14f;float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38double d = 1.79e308;double d2 = -1.79e308;double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324 浮点数可表示的范围非常大，float类型可最大表示3.4x1038，而double类型可最大表示1.79x10308。 注意：boolean类型只有flase 和 true两个值 12345boolean b1 = true;boolean b2 = false;boolean isGreater = 5 &gt; 3; // 计算结果为trueint age = 12;boolean isAdult = age &gt;= 18; // 计算结果为false 注意：char类型既可以表示ASCII码也可以表示Unicode字符 单引号表示字符，双引号表示字符串 1234567891011public class Main{ public static void main(String[] args) { char a = 'A'; char zh = '中'; System.out.println(a); System.out.println(zh); }} ¶4、常量 定义变量的时候，如果加上final修饰符，这个变量就变成了常量： 1234final double PI = 3.14; // PI是一个常量double r = 5.0;double area = PI * r * r;PI = 300; // compile error! ¶5、var关键字 编译器会根据赋值语句自动推断出变量类型，省时，省力 123StringBuilder sb = new StringBuilder();var sb = new StringBuilder(); ¶6、数据运算 ¶除0编译可以通过，但运行会报错 ¶可以使用+=等等 ¶可以使用++、-- 运算符 ¶移位运算 带符号位移动： 左移 &lt;&lt; ：相当于乘2 右移 &gt;&gt; ：相当于除2 不带符号位移动： 右移 &gt;&gt;&gt; ：相当于除2 12345int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &lt;&lt; 1; // 00000000 00000000 00000000 00001110 = 14int b = n &lt;&lt; 2; // 00000000 00000000 00000000 00011100 = 28int c = n &gt;&gt; 1; // 00000000 00000000 00000000 00000011 = 3int d = n &gt;&gt; 2; // 00000000 00000000 00000000 00000001 = 1 注意：对一个负数进行右移，最高位的1不动，结果仍然是一个负数： 12345int n = -536870912;int a = n &gt;&gt; 1; // 11110000 00000000 00000000 00000000 = -268435456int b = n &gt;&gt; 2; // 10111000 00000000 00000000 00000000 = -134217728int c = n &gt;&gt; 28; // 11111111 11111111 11111111 11111110 = -2int d = n &gt;&gt; 29; // 11111111 11111111 11111111 11111111 = -1 注意：使用不带符号右移，负数右移，会将最高位符号位也右移，变为正数 12345int n = -536870912;int a = n &gt;&gt;&gt; 1; // 01110000 00000000 00000000 00000000 = 1879048192int b = n &gt;&gt;&gt; 2; // 00111000 00000000 00000000 00000000 = 939524096int c = n &gt;&gt;&gt; 29; // 00000000 00000000 00000000 00000111 = 7int d = n &gt;&gt;&gt; 31; // 00000000 00000000 00000000 00000001 = 1 注意：对byte和short类型进行移位时，会首先转换为int再进行位移。 ¶7、位运算 位运算是按位进行与、或、非和异或的运算。 &amp;：按位与 | ：按位或 ~ ：按位非 ^ ： 按位异或 :不同为1，相同为0 ¶8、运算符优先级 从高到低： () ! ~ ++ -- * / % + - &lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | += -= *= /= ¶9、类型提升和强转类型转换 略，太简单了！ ¶10、浮点数 由于计算机二进制表示，判断浮点数相等仍得通过阀值和绝对值函数来实现。 12345678// 比较x和y是否相等，先计算其差的绝对值:double r = Math.abs(x - y);// 再判断绝对值是否足够小:if (r &lt; 0.00001) { // 可以认为相等} else { // 不相等} ¶11、溢出 NaN表示Not a Number Infinity表示无穷大 -Infinity表示负无穷大 123double d1 = 0.0 / 0; // NaNdouble d2 = 1.0 / 0; // Infinitydouble d3 = -1.0 / 0; // -Infinity ¶12、boolean运算 比较运算符：&gt;，&gt;=，&lt;，&lt;=，==，!= 与运算 &amp;&amp; 或运算 || 非运算 ! 123456boolean isGreater = 5 &gt; 3; // trueint age = 12;boolean isZero = age == 0; // falseboolean isNonZero = !isZero; // trueboolean isAdult = age &gt;= 18; // falseboolean isTeenager = age &gt;6 &amp;&amp; age &lt;18; // true 注意：若boolean运算可以判断最终结果为真或假，则不会进行后续无意义计算，即便后面有除0运算 1boolean result = true || (5 / 0 &gt; 0); // true ¶13、三目运算符 ？： …不介绍了。 ¶14、字符和字符串 ¶char char类型既可以表示ASCII码也可以表示Unicode字符 用转义字符\\u+Unicode编码来表示一个字符： 123// 注意是十六进制:char c3 = '\\u0041'; // 'A'，因为十六进制0041 = 十进制65char c4 = '\\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013 ¶String 用双引号表示 用\\表示转义 ¶字符串连接 用+号连接 12345678910public class Main{ public static void main(String[] args) { String s1 = \"Hello\"; String s2 = \"world\"; String s = s1 + \" \" + s2 + \"!\"; System.out.println(s); }} ¶多行字符串 笨办法： 123String s = \"first line \\n\" + \"second line \\n\" + \"end\"; 新办法： 12345678910111213141516String s = \"\"\" SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC \"\"\"String s = \"\"\" SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC\"\"\";String s = \"\"\" SELECT * FROMusersWHERE id &gt; 100ORDER BY name DESC\"\"\"; 注意：上面表示五行还有一个换行符\\n 注意：下面表示四行，没有换行符 注意：最终格式总是以最靠左边的为基准。 第三种可以避免空格问题出现。。 若要使用cmd： 1$ javac --source 13 --enable-preview Main.java ¶String的不可变特性 12345678910public class Main { public static void main(String[] args) { String s = \"hello\"; System.out.println(s); // 显示 hello s = \"world\"; System.out.println(s); // 显示 world }} 原来的字符串\"hello\"还在，只是我们无法通过变量s访问它而已。因此，字符串的不可变是指字符串内容不可变。 相当于指针指向换了， ¶空值null 1234String s1 = null; // s1是nullString s2; // 没有赋初值值，s2也是nullString s3 = s1; // s3也是nullString s4 = \"\"; // s4指向空字符串，不是null ¶15、数组类型 ¶数组定义 定义一个数组类型的变量，使用数组类型“类型[]”，例如，int[]。和单个基本类型变量不同，数组变量初始化必须使用new int[5]表示创建一个可容纳5个int元素的数组 Java的数组有几个特点： 数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false； 数组一旦创建后，大小就不可改变。 可以使用.length来获取数组长度 ¶第一种 12345678public class Main { public static void main(String[] args) { int[] ns = new int[5]; System.out.println(ns.length); // 5 }} ¶第二种 可以用{}来初始化，自动推算数组大小： 12345678910public class Main { public static void main(String[] args) { // 5位同学的成绩: int[] ns = new int[] { 68, 79, 91, 85, 62 }; System.out.println(ns.length); // 编译器自动推算数组大小为5 }} ¶第三种：简略版 1int[] ns = { 68, 79, 91, 85, 62 }; ¶数组大小不可变 如下： 123456789101112public class Main { public static void main(String[] args) { // 5位同学的成绩: int[] ns; ns = new int[] { 68, 79, 91, 85, 62 }; System.out.println(ns.length); // 5 ns = new int[] { 1, 2, 3 }; System.out.println(ns.length); // 3 }} 看似大小变了，实际是数组指向变了，由原来指向五个数据的地方，指向了三个数据地方，而原来五个数组没有指向他的，所以无法访问了。 原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。 String类型数组，一样，改变一个值，值并没有消失，只是指向改变了，原来的值无法通过下标为1的数组来访问。 12345678910public class Main{ public static void main(String[] args) { String[] names = {\"ABC\", \"XYZ\", \"zoo\"}; String s = names[1]; names[1] = \"cat\"; System.out.println(s); // XYZ }} ¶五、流程控制 ¶1、输出 ¶System.out.println() println是print line的缩写，表示输出并换行 ¶System.out.print() print：不换行 1234567891011public class Main { public static void main(String[] args) { System.out.print(\"A,\"); System.out.print(\"B,\"); System.out.print(\"C.\"); System.out.println();//可以用来换行 System.out.println(\"END\"); }} ¶System.out.printf() 格式化输出，和C语言printf类似 可以%08.3f来控制小数与宽度与补位数 占位符： %d 格式化输出整数 %x 格式化输出十六进制整数 %f 格式化输出浮点数 %e 格式化输出科学计数法表示的浮点数 %s 格式化字符串 注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身 12345678910public class Main{ public static void main(String[] args) { int n = 12345000; System.out.printf(\"n=%d, hex=%08x\\n\", n, n); double d = 239.3839; System.out.printf(\"%09.2f\", d);//000239.38 }} ¶2、输入 首先，我们通过import语句导入java.util.Scanner，import是导入某个类的语句，必须放到Java源代码的开头 然后，创建Scanner对象并传入System.in。System.out代表标准输出流，而System.in代表标准输入流。直接使用System.in读取用户输入虽然是可以的，但需要更复杂的代码，而通过Scanner就可以简化后续的代码。 有了Scanner对象后，要读取用户输入的字符串，使用scanner.nextLine()，要读取用户输入的整数，使用scanner.nextInt()。Scanner会自动转换数据类型，因此不必手动转换。 1234567891011121314import java.util.Scanner;public class Main{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.out.print(\"Input your name: \"); // 打印提示 String name = scanner.nextLine(); // 读取一行输入并获取字符串 System.out.print(\"Input your age: \"); // 打印提示 int age = scanner.nextInt(); // 读取一行输入并获取整数 System.out.printf(\"Hi, %s, you are %d\\n\", name, age); // 格式化输出 }} ¶3、if语句 ¶判断引用类型相等 在Java中，判断值类型的变量是否相等，可以使用==运算符。 但是，判断引用类型的变量是否相等，==表示“引用是否相等”，或者说，是否指向同一个对象。 例如，下面的两个String类型，它们的内容是相同的，但是，分别指向不同的对象，用==判断，结果为false： 123456789101112131415public class Main { public static void main(String[] args) { String s1 = \"hello\"; String s2 = \"HELLO\".toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1 == s2) System.out.println(\"s1 == s2\"); else System.out.println(\"s1 != s2\"); }} 要判断引用类型的变量内容是否相等，必须使用equals()方法： 1234567891011121314public class Main { public static void main(String[] args) { String s1 = \"hello\"; String s2 = \"HELLO\".toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1.equals(s2)) System.out.println(\"s1 equals s2\"); else System.out.println(\"s1 not equals s2\"); }} 注意： 执行语句s1.equals(s2)时，如果变量s1为null，会报NullPointerException： ¶4、switch语句 switch case break default 与C++一样，不介绍 ¶switch表达式 使用switch时，如果遗漏了break，就会造成严重的逻辑错误，而且不易在源代码中发现错误。 从Java 12开始，switch语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要break语句： 注意新语法使用-&gt;，如果有多条语句，需要用{}括起来。不要写break语句，因为新语法只会执行匹配的语句，没有穿透效应。 123456789101112131415161718public class Main{ public static void main(String[] args) { String fruit = \"apple\"; switch (fruit) { case \"apple\" -&gt; System.out.println(\"Selected apple\"); case \"pear\" -&gt; System.out.println(\"Selected pear\"); case \"mango\" -&gt; { System.out.println(\"Selected mango\"); System.out.println(\"Good choice!\"); } default -&gt; System.out.println(\"No fruit selected\"); } }} 1234567891011121314public class Main { public static void main(String[] args) { String fruit = \"apple\"; int opt = switch (fruit) { case \"apple\" -&gt; 1; case \"pear\", \"mango\" -&gt; 2; default -&gt; 0; }; // 注意赋值语句要以;结束 System.out.println(\"opt = \" + opt); }} ¶5、yield 大多数时候，在switch表达式内部，我们会返回简单的值。 但是，如果需要复杂的语句，我们也可以写很多语句，放到{...}里，然后，用yield返回一个值作为switch语句的返回值： 123456789101112131415161718public class Main{ public static void main(String[] args) { String fruit = \"orange\"; int opt = switch (fruit) { case \"apple\" -&gt; 1; case \"pear\", \"mango\" -&gt; 2; default -&gt; { int code = fruit.hashCode(); yield code; // switch语句返回值 } }; System.out.println(\"opt = \" + opt); }} 运行结果： 注: Main.java 使用预览语言功能。 注: 有关详细信息，请使用 -Xlint:preview 重新编译。 opt = -1008851410 ¶6、while和do while 略。。。与C++一样。。。 ¶7、for循环 略。。。与C++一样。。。 ¶for each 和for循环相比，for each循环的变量n不再是计数器，而是直接对应到数组的每个元素。for each循环的写法也更简洁。但是，for each循环无法指定遍历顺序，也无法获取数组的索引。 除了数组外，for each循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的List、Map等。 1234567891011public class Main{ public static void main(String[] args) { int[] ns = { 1, 4, 9, 16, 25 }; for (int n : ns) { System.out.println(n); } }} ¶8、break 和 continue 略。。。与C++一样。。。 ¶六、 数组操作 ¶1、for each 遍历 参考第五个的for each ¶2、直接打印数组名 得到的是在JVM中的地址。。。 ¶3、Arrays.toString() 需引入java.util.Arrays库，可以用来遍历数组 1234567891011import java.util.Arrays;public class Main { public static void main(String[] args) { int[] ns = { 1, 1, 2, 3, 5, 8 }; System.out.println(Arrays.toString(ns));//[1, 1, 2, 3, 5, 8] }} ¶4、Arrays.sort() 排序 对int排序，数组内存存储顺序已经改变 对String类型排序，数组内存存储顺序没有改变，只是指向的改变 123456789101112import java.util.Arrays;public class Main { public static void main(String[] args) { int[] ns = { 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 }; Arrays.sort(ns); System.out.println(Arrays.toString(ns)); }} ¶5、多维数组 ¶多维数组定义： 123456789101112131415public class Main { public static void main(String[] args) { int[][] arr = new int[100][100]; int[][] ns = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }; System.out.println(ns.length); // 3 }} ¶多维数组遍历 普通遍历 使用for each遍历 12345678910111213141516171819202122public class Main { public static void main(String[] args) { int[][] arr = new int[100][100]; int[][] ns = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }; for (int[] t : ns) { for (int n : t) { System.out.print(n); System.out.print(\", \"); } System.out.println(); }} ¶6、命令行参数 命令行参数类型是String[]数组； 命令行参数由JVM接收用户输入并传给main方法； 我们可以利用接收到的命令行参数，根据不同的参数执行不同的代码。例如，实现一个-version参数，打印程序版本号 123456789101112131415161718public class Main { public static void main(String[] args) { for (String arg : args) { System.out.println(arg); } for (String arg : args) { if (\"-version\".equals(arg)) { System.out.println(\"v 1.0\"); break; } } }} 123$ javac Main.java$ java Main -version # 传一个参数v 1.0 ¶快速入门结束，敬请期待后续内容，to be continued. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"入门","slug":"入门","permalink":"https://www.itnxd.cn/tags/%E5%85%A5%E9%97%A8/"},{"name":"基础","slug":"基础","permalink":"https://www.itnxd.cn/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"https://www.itnxd.cn/tags/Java/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之基础语法入门","slug":"JavaScript教程系列之基础语法入门","date":"2020-02-09T05:53:06.000Z","updated":"2020-05-19T02:39:04.128Z","comments":true,"path":"posts/41103.html","link":"","permalink":"https://www.itnxd.cn/posts/41103.html","excerpt":"","text":"¶首先来首歌曲来放松一下吧！ 在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。 新兴的Node.js把JavaScript引入到了服务器端，JavaScript已经变成了全能型选手。 JavaScript确实很容易上手，但其精髓却不为大多数开发人员所熟知。编写高质量的JavaScript代码更是难上加难。 教程参考：JavaScript全栈教程 ¶一、JavaScript的诞生 在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。 由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在两周之内设计出了JavaScript语言。你没看错，这哥们只用了10天时间。 为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。 ¶二、JavaScript引入 JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到head中 第一种 123&lt;script&gt; alert('hello world!');&lt;/script&gt; 第二种 1&lt;script src=\"/static/js/abc.js\"&gt;&lt;/script&gt; 第三种 默认的type就是JavaScript，所以不必显式地把type指定为JavaScript。 123&lt;script type=\"text/javascript\"&gt; ...&lt;/script&gt; ¶三、基本语法 ¶句子以分号结束 ¶'Hello, world'; 也是完整语句 ¶注释 //：单行注释 /**/：多行注释 ¶四、数据类型 ¶Number类型 123; // 整数123 0.456; // 浮点数0.456 1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5 -99; // 负数 NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示 Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity ¶字符串类型 使用单引号或双引号引起来的内容 同样，要输出无法输出的字符，仍然可以使用\\来转义 ¶字符串转义： 123'I\\'m \\\"OK\\\"!'; //I'm \"OK\"!'\\x41'; // 完全等同于 'A'---\\x表示ASCII编码字符'\\u4e2d\\u6587'; // 完全等同于 '中文' ----\\u表示一个Unicode字符 ¶多行字符串： 由于多行字符串用\\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 \"``\"表示： 反引号位于数字1的左边 123`这是一个多行字符串`; ¶模板字符串： 将多个字符串连接起来 使用 + 号 123var name = '小明';var age = 20;var message = '你好, ' + name + ', 你今年' + age + '岁了!'; 使用${变量}来表示，得用反引号引起来 1234var name = '小明';var age = 20;var message = `你好, ${name}, 你今年${age}岁了!`;alert(message); 显示结果都是： 你好, 小明, 你今年20岁了! ¶str.length 12var s = 'Hello, world!';s.length; // 13 ¶索引操作 略。 对索引赋值，无返回结果，不影响原值，并且字符串类型无法进行修改，是不可变类型 123var s = 'Test';s[0] = 'X';alert(s); // s仍然为'Test' ¶toUpperCase()函数 小写变大写 12var s = 'Hello';s.toUpperCase(); // 返回'HELLO' ¶toLowerCase()函数 大写边小写 123var s = 'Hello';var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lowerlower; // 'hello' ¶indexOf()函数 返回字串出现位置，没有找到返回-1 123var s = 'hello, world';s.indexOf('world'); // 返回7s.indexOf('World'); // 没有找到指定的子串，返回-1 ¶substring()函数 返回索引区间字串 123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' ¶split()函数 split() 方法用于把一个字符串分割成字符串数组。 如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。 split() 方法不改变原始字符串。 *string*.split(*separator*,*limit*) 第一个参数：分隔符；第二个参数：限制返回字符数组的最大长度，不指定则不限制； 1234567891011var str=\"How are you doing today?\";var n=str.split(\" \");//[\"How\", \"are\", \"you\", \"doing\", \"today?\"]var nn = str.split();console.log(nn);//[\"How are you doing today?\"]var nnn = str.split(\"\");console.log(nnn);//[\"H\", \"o\", \"w\", \" \", \"a\", \"r\", \"e\", \" \", \"y\", \"o\", \"u\", \" \", \"d\", \"o\", \"i\", \"n\", \"g\", \" \", \"t\", \"o\", \"d\", \"a\", \"y\", \"?\"]var nnnn = str.split(\" \", 3);console.log(nnnn);//[\"How\", \"are\", \"you\"] ¶布尔类型 true 和 false 12false == 0; // truefalse === 0; // false ¶注意： ==：它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果 ===：它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 所以： 尽量不要使用 ==来进行比较，要使用===来比较！ ¶特例1：NaN 与自己比较也会返回false 1NaN === NaN; // false 判断方法：使用isNaN()函数比较 1isNaN(NaN); // true ¶特例2：浮点数比较 浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值.（二级制无法表示0.1 。。。。。。） 11 / 3 === (1 - 2 / 3); // false 解决方法：使用Math.abs()函数 1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true ¶null 和 undefined JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义. ¶数组 数组可以包括任意数据类型 ¶中括号创建数组 1[1, 2, 3.14, 'Hello', null, true]; ¶使用Array()函数创建数组： 1new Array(1, 2, 3); // 创建了数组[1, 2, 3] ¶建议直接使用[]来创建数组 与其他语言一样，可以只用下标访问，超出下标范围返回undeifined 1234var arr = [1, 2, 3.14, 'Hello', null, true];arr[0]; // 返回索引为0的元素，即1arr[5]; // 返回索引为5的元素，即truearr[6]; // 索引超出了范围，返回undefined ¶for循环遍历 12var arr2 = [1,2,3,'', \"jdsoa\", null];for(var n in arr) console.log(arr[n]); ¶s.length 注意点：直接给Array的length赋一个新的值会导致Array大小的变化： 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] ¶可通过索引修改值 切记不可超出下标范围 ¶indexOf()函数 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置：没有找到返回-1 12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 ¶slice()函数 slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： 注意到slice()的起止参数包括开始索引，不包括结束索引。 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： 1234567var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G'] ¶push()和pop()函数 push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] ¶unshift()和shift()函数 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： 123456789var arr = [1, 2];arr.unshift('A', 'B'); // 返回Array新的长度: 4arr; // ['A', 'B', 1, 2]arr.shift(); // 'A'arr; // ['B', 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // [] ¶sort()函数 sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序： 可自定义参数实现自定义排序 123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] ¶reverse()函数 reverse()把整个Array的元素给掉个个，也就是反转： 123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] ¶splice()函数 splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： 12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] ¶concat()函数 concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： 1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] 实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里： 12var arr = ['A', 'B', 'C'];arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] ¶join()函数 join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' ¶多维数组 如果数组的某个元素又是一个Array，则可以形成多维数组 1var arr = [[1, 2, 3], [400, 500, 600], '-']; ¶对象 JavaScript的对象是一组由键-值组成的无序集合 JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。 JavaScript对象的键都是字符串类型，值可以是任意数据类型。person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为'Bob'，zipcode属性为null。 属性名若包括特殊字符，需用引号引起来。eg：middle-school 123456789var person = { name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, 'middle-school': 'No.1 Middle School', zipcode: null}; 对象访问方法： 12person.name; // 'Bob'person.zipcode; // null 注意：属性若有-等特殊字符，需要用引号引起来使用，并且访问时只能使用[]来访问，不能通过.访问。否则显示xxxx is not defined for循环遍历对象：用 in 来遍历，变量访问的是属性，通过[]来访问值。 若用.访问的属性不存在会自动创建一个，使用deletek可以进行删除，删除后再次访问会显示undefined。 用 in来判断属性名是否是对象的属性，但是无法判断由于继承得到的属性 使用hasOwnProperty()函数来判断解决继承问题得到的属性 12345678910111213141516171819202122232425var xiaoming = { name : \"小明\", age : 24, height : 9999, score : null, ps : undefined, str : '', hr : NaN, 'n-x' : 89, }; console.log(xiaoming.n-x);//报错，x is not defined console.log(xiaoming['n-x']); console.log(xiaoming['name']); for(var i in xiaoming) console.log(i + ':' + xiaoming[i]); xiaoming.zdf = '增加'; console.log(xiaoming.zdf); delete xiaoming.zdf; console.log(xiaoming.zdf); //undefined console.log('name' in xiaoming); //true console.log('toString' in xiaoming); //true console.log(xiaoming.hasOwnProperty('toString')); //false ¶变量 变量名是大小写英文、数字、$和_的组合，且不能用数字开头 申明一个变量用var语句 12345var a; // 申明了变量a，此时a的值为undefinedvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 = '007'; // s_007是一个字符串var Answer = true; // Answer是一个布尔值truevar t = null; // t的值是null 在JavaScript中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值， JavaScript是动态语言，弱类型语言 12var a = 123; // a的值是整数123a = 'ABC'; // a变为字符串 ¶console.log()函数 可以在控制台打印需要的东西 ¶无、条件判断 和C++一模一样，不做介绍 ¶六、循环 ¶break和continue 和C++一模一样，不做介绍 ¶for循环 ¶普通循环 ¶for in 循环 可以遍历对象，得到对象的属性名 要过滤掉对象继承的属性，用hasOwnProperty()来实现： 123456789101112var o = { name: 'Jack', age: 20, city: 'Beijing'};for (var key in o) { if (o.hasOwnProperty(key)) { console.log(key); // 'name', 'age', 'city' }} 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引： 请注意，for ... in对Array的循环得到的是String而不是Number。 12345var a = ['A', 'B', 'C'];for (var i in a) { console.log(i); // '0', '1', '2' console.log(a[i]); // 'A', 'B', 'C'} ¶while循环和do while循环 和C++一模一样，不做介绍 ¶七、Map Map是一组键值对的结构，具有极快的查找速度。 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 ¶set()添加，get()查找，delete()删除，has()查询 set是一组key,value,后三个参数都为key 1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined set()添加时，后添加的会覆盖前面添加的。 1234var m = new Map();m.set('Adam', 67);m.set('Adam', 88);m.get('Adam'); // 88 ¶for of 遍历Map对象 1for(var j of m) console.log(j[0]+':'+j[1]); ¶八、Set Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 ¶Set创建 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 ¶重复元素自动过滤 12var s = new Set([1, 2, 3, 3, '3']);s; // Set {1, 2, 3, \"3\"} ¶add()添加，delete()删除 参数都是key 123456789s.add(4);s; // Set {1, 2, 3, 4}s.add(4);s; // 仍然是 Set {1, 2, 3, 4}var s = new Set([1, 2, 3]);s; // Set {1, 2, 3}s.delete(3);s; // Set {1, 2} ¶for of 遍历Set对象 1for(var j of s) console.log(j); ¶九、iterable 遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for ... of循环来遍历。 for in ：遍历属性名 for of：遍历值 123456789101112131415161718192021222324var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) { // 遍历Array console.log(x);}for (var x of s) { // 遍历Set console.log(x);}for (var x of m) { // 遍历Map console.log(x[0] + '=' + x[1]);}//for in 会将所以属性名都遍历var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x in a) { console.log(x); // '0', '1', '2', 'name'}//for of 只遍历该遍历的var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x of a) { console.log(x); // 'A', 'B', 'C'} ¶使用forEach()函数 它接收一个函数，每次迭代就自动回调该函数 结构： 参数可以有多个，可以只有一个。 参数1：对应值 参数2：对应键 参数3：对应类型 123456789101112a.forEach(function(参数1,参数2,参数3){ 语句块})；var a = [3,4,5,6,7];var sum = 0;// 第一种a.forEach(function(item){sum += item;});// 第二种a.forEach(item =&gt; sum += item);console.log(sum); ¶遍历Array 123456789101112var a = ['A', 'B', 'C'];//访问值和键a.forEach(function (element, index, array){ console.log(element + ', index = ' + index);});//只访问值a.forEach(function (element) { console.log(element);}); ¶遍历Set 12345var s = new Set(['A', 'B', 'C']);s.forEach(function (element, set) { console.log(element);}); ¶遍历Map 12345var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map){ console.log(value);}); ¶JavaScript教程系列一完美结束，敬请期待后续教程！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://www.itnxd.cn/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.itnxd.cn/tags/JavaScript/"},{"name":"入门","slug":"入门","permalink":"https://www.itnxd.cn/tags/%E5%85%A5%E9%97%A8/"}],"author":"Mr.Niu"},{"title":"自学Git记录及用法总结","slug":"自学Git记录及用法总结","date":"2020-02-06T13:02:25.000Z","updated":"2021-05-01T02:05:42.776Z","comments":true,"path":"posts/50207.html","link":"","permalink":"https://www.itnxd.cn/posts/50207.html","excerpt":"","text":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 本文资料参考： 廖雪峰Git教程 菜鸟Git教程 相关文章推荐： Git五分钟教程 Github简明教程 Git命令文档参考： Git官方文档参考 菜鸟Git文档PDF 国外友人制作Git文档 ¶一、 Git的诞生 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 ¶二、 Git与 Svn 的区别 1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。 **2、Git 把内容按元数据方式存储，而 SVN 是按文件：**所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。 **3、Git 分支和 SVN 的分支不同：**分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。 **4、Git 没有一个全局的版本号，而 SVN 有：**目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。 **5、Git 的内容完整性要优于 SVN：**Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 ¶三、Git的安装及配置 直接去**Git官网**下载对应的安装程序，安装即可. 安装完成配置一下全局用户名和邮箱！ 12$ git config --global user.name \"xxxx\"$ git config --global user.email \"xxxx\" 查看用户名： 12$ git config user.name$ git config user.email 效果如下： 查看配置信息： 1$ git config --list 效果如下： 清空Git Bash的代码记录：输入reset回车即可 1$ reset ¶四、工作区，暂存区，版本库的区别 **工作区：**就是你在电脑里能看到的目录。 **暂存区：**英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 **版本库：**工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下图来解释三者的关系： 图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。 图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个\"游标\"。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 ¶五、Git 创建版本库 ¶git init 命令 首先本地新建一个文件夹名为test，然后cd 进去，打开Git Bash，输入初始化命令： 1$ git init 然后你会发现test文件夹多了一个.git目录： 这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了 但是你会发现你看不到，因为它为了防止被人改动，自动隐藏了，可以使用如下命令查看： 1$ ls -ah 效果如下： 会发现路径后面多了一个master，是说当前库是被git托管的，并且是在master的默认分支上。 接下来在本地目录新建一个README.md文档，用文本编辑器打开写上“我的Git自学记录！” 然后用Git命令将其提交到暂存区，再提交到版本库： 12$ git add README.md$ git commit -m \"增加README文件\" 效果如下： ¶git add 与 git commit 命令 git add 命令：将文件从工作区提交到暂存区 后面可以跟文件名，或者多个文件名以空格分隔 也可以跟 .来表示所有文件 git commit 命令：将文件从暂存区提交到版本库 -m 参数：后面写本次提交的备注 -a 参数： 可以跳过备注，但会进入编辑备注模式，按shift键+ZZ可以退出。 ¶git status 命令 用来查看状态：可以让我们时刻掌握仓库当前的状态，即工作区有没有提交到暂存区，暂存区有没有提交到版本库 接下来修改文件内容，增加一行“修改文件test1”。 如下： 然后再git bash 中使用 git status命令查看状态： 如下： 会提示\"change not staged for commit\"也就是改变还没有提交到版本库 会提示\"modifiled : README.md\"即，提示这个文件被修改了 会提示\"git add &lt;file&gt;\"，即使用此命令可以将当前改变提交到暂存区 会提示git restore &lt;file&gt;，即使用此命令可以将当前改变撤销，即本地文件会恢复到修改之前。 接下来使用git add .将文件提交到暂存区，在使用git status 来查看状态： 会发现红字变为了绿字，即当前修改已经提交成功到了暂存区。 会提示git restore --staged &lt;file&gt;来撤销暂存区修改，即暂存区还是原来的样子，而本地文件还是修改后的状态 想要恢复文件未被修改之前，参考上面提到的撤销命令git restore &lt;file&gt; 接下来使用git commit来将修改提交到版本库，然后使用git status查看状态： 会发现git status 的返回状态为\"working tree clean\"，即工作区很干净。 ¶ls 命令 可以查看当前目录下的文件 -a ：查看隐藏目录 cd到.git目录可以看到HEAD(版本库)和index(暂存区)文件： ¶cd 命令 cd d: ：即切换到d 盘 cd &lt;目录&gt;：即进入那个目录 cd ..：即退到上一目录 ¶touch 命令 创建文件命令，后跟文件名。 ¶mkdir命令 创建目录命令，后跟目录名 ¶pwd 命令 用于显示当前路径 ¶cat 命令 查看文件内容，后跟文件名 ¶vim 或vi 命令 编辑文件命令，后跟文件名 进入编辑状态后： 按 i进入编辑模式 按 Esc键结束编辑 按shift + Z + Z 键退出编辑状态 若没有要打开的文件，则会自动新建一个文件，只有在新建文件中输入了东西，按下shift +Z + Z才能保存，若没有进行修改，文件也不会创建成功，所以也可以用此命令来代替touch命令，效果一样。 ¶git diff命令 git diff：查看工作区和暂存区差异， git diff -cached：查看暂存区和版本库差异， git diff HEAD/master：查看工作区和版本库差异， 若没有差异，则不会有返回信息。 ¶git rm 命令 rm file：删除工作区文件 git rm file：删除暂存区和工作区文件 git rm --cached file：只删除暂存区，保留工作区 git rm -r *：递归删除该目录下所有文件 只在工作区的文件，通过rm删除，无法恢复 提交到暂存区的文件，在工作区进行rm删除后，可以通过git checkout – file来撤销删除。新版命令：git restore file 提交到版本库的文件，在工作区进行rm删除后，也可以通过 git checkout – file 来撤销删除。新版命令：git restore file 提交到版本库的文件，通过git rm 进行删除后，其实已经将删除提交到了暂存区，所以应该用git reset HEAD file将版本库给了暂存区，再用git checkout – file将暂存区拉回工作区，即恢复原状。新版命令：git restore --staged file 再使用：git restore file. 若想彻底删除版本库文件，先git rm ，再commit 即可，若想恢复就得晋城版本回退操作，后序再讲。 提交到暂存区或版本库，用rm删除后恢复操作： 提交到版本库文件，用git rm删除恢复操作： 彻底删除版本库文件： ¶新版命令变化 新版： 12$ git restore --staged file$ git restore file. 旧版： 12$ git reset HEAD file$ git checkout -- file ¶六、版本回退 版本回退即时空穿梭，只要提交到了版本库，你可以穿梭到任意一次版本库的提交记录。 ¶git log 命令 git log命令显示从最近到最远的提交日志，会显示提交id,作者，邮箱，日期，以及提交备注。 ¶可以使用git log --oneline来显示简略版的历史 ¶可以使用 git log --pretty=oneline来显示在一行 只显示commit id ,以及提交备注 ¶可以使用git log --graph查看拓扑图 具体自己操作查看！ ¶可以使用 git log --reverse --oneline逆向显示记录 ¶可以使用git log --author=niuxvdong --oneline -5来指定作者名字 ¶更多log 参数命令前往官网查看 https://git-scm.com/docs/git-log ¶git用HEAD表示当前版本 ¶git reset 命令 回退命令！ ¶git reset --hard HEAD^ 回退上一个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 此时再使用git log会发现未来的记录没了，只能查看当前记录。 So… ¶往上翻找到commitId再使用git reset --hard HEAD commitId ¶git reflog 记录你的命令 可以找到commitId，然后git reset --hard HEAD commitId即可回到未来 ¶七、远程仓库（远程库） ¶创建密钥： 1$ ssh-keygen -t rsa -C \"youremail@example.com\" 密钥相当于个人电脑的指纹，托管平台通过密钥来识别身份。 在C盘用户目录下的.ssh文件夹下的id_rsa和id_rsa.pub两个文件，一个私钥，一个公钥。 ¶链接远程库： 将公钥复制到代码托管平台的SSH管理页面，名称随便填即可。 ¶创建仓库： 名字起的像样点，相当于你的项目名。 ¶如图所示，安照提示走： $ git remote add origin git@github.com:niuxvdong/test.git 123- ```bash $ git push -u origin master 以后即可直接git push 了，不需要那么多参数。 ¶删除远程库 以便于连接另一个托管平台 1$ git remote rm origin ¶同时连接多个托管平台 因为远程库名字都叫origin，所以只需先删除已绑定的远程库，然后进行关联时候，将名字更改即可！ 1234$ git remote rm origin$ git remote add github git@github.com:niuxvdong/test.git$ git remote add gitee git@gitee.com:niuxvdong/test.git$ git remote -v so 现在的仓库名字不叫 origin 了，一个叫 github ，一个叫 gitee。用到origin的命令时，就要对应仓库名字进行修改了。 push 命令修改如下： 12$ git push github master$ git push gitee master ¶克隆仓库： git clone + ssh链接 git clone + ssh链接 + 路径 ¶git remote命令 12$ git remote $ git remote -v 远程库名称和详细信息 有push信息说明你有推送权限： ¶推送分支 1$ git push origin master 推送其他分支即将master改为其他分支名 ¶多人协作 参考教程：https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320 ¶git rabase 参考教程：https://www.liaoxuefeng.com/wiki/896043488029600/1216289527823648 ¶八、分支管理 ¶查看分支 1$ git branch ¶创建分支 1$ git branch &lt;name&gt; ¶切换分支 1$ git switch &lt;name&gt; 或 git checkout &lt;name&gt; ¶创建并切换 1$ git switch -c &lt;name&gt; 或 git checkout -b &lt;name&gt; ¶合并分支 1$ git merge &lt;name&gt; ¶默认合并方式为Fast forward模式 此种合并方法看不到合并历史，对于开发来说不太好 ¶尽量使用 --no-ff 参数来合并使用普通合并 此方法可以看到合并历史记录，便于开发和操作 ¶可以追加上-m参数 1$ git merge --no-ff -m \"merge with --no-ff\" ¶删除分支 1$ git branch -d &lt;name&gt; 强制删除分支： 1$ git branch -D &lt;name&gt; ¶合并冲突解决 ¶创建dev分支 1$ git branch dev ¶在master分支将文件修改后，add并且commit 123$ vi new.c$ git add .$ git commit -m \"add hhhhhhhhhh\" ¶切换到dev分支 1$ git switch dev ¶在dev分支将文件修改后，add 并 commit 123$ vi new.c$ git add .$ git commit -m \"add ssssssssss\" ¶切换到master分支 1$ git branch dev ¶合并dev分支 1$ git merge dev ¶出现冲突 ¶vi 编辑冲突文件 1$ vi new.c ¶add 并commit 12$ git add .git commit -m \"merge confilt\" ¶删除dev分支 1$ git branch -d dev ¶九、存储现场 ¶git stash 命令 用来存储当前工作状态，一遍先去处理遇到的问题或其他bug 12$ git stashSaved working directory and index state WIP on dev: f52c633 add merge ¶git stash list 12$ git stash liststash@{0}: WIP on dev: f52c633 add merge ¶恢复现场 ¶一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； ¶另一种方式是用git stash pop，恢复的同时把stash内容也删了 ¶在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 ¶十、标签管理 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 ¶创建标签 1$ git tag v1.0 ¶查看标签 1$ git tag ¶通过commitId打标签 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了 12$ git log --oneline$ git tag v1.1 f52c633 ¶查看具体标签信息 标签不是按时间顺序列出，而是按字母排序的。可以用git show 查看标签信息： 12$ git tag$ git show v1.1 ¶创建带有说明的标签 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m \"version 0.1 released\" 1094adb 注意： 标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 ¶删除本地标签 当前本地标签未推送到远程库 1$ git tag -d v0.1 ¶推送标签 ¶推送指定标签 1$ git push origin v1.0 ¶一次性推送全部尚未推送到远程的本地标签 1$ git push origin --tags ¶删除已推送到远程库的标签 ¶先删除本地标签 1$ git tag -d v0.9 ¶再删除远程库 1$ git push origin :refs/tags/v0.9 ¶另一种删除方式 1$ git push origin :&lt;branch&gt;/&lt;tag&gt; 注意冒号 : 必不可少, 后面跟远程库的分支名/标签名 ¶十一、自定义 ¶忽略特殊文件 参考文档：https://www.liaoxuefeng.com/wiki/896043488029600/900004590234208 ¶给命令配置简短的别名 参考文档： https://www.liaoxuefeng.com/wiki/896043488029600/898732837407424 ¶完美结束，历时好久终于写完，感谢观看！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Git","slug":"Git","permalink":"https://www.itnxd.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.itnxd.cn/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://www.itnxd.cn/tags/Github/"}],"author":"Mr.Niu"},{"title":"hexo-theme-matery主题配置详解","slug":"hexo-theme-matery主题配置详解","date":"2020-02-05T04:24:09.000Z","updated":"2020-02-05T04:24:09.000Z","comments":true,"path":"posts/57378.html","link":"","permalink":"https://www.itnxd.cn/posts/57378.html","excerpt":"","text":"¶hexo-theme-matery 这是一个采用 Material Design 和响应式设计的 Hexo 博客主题。 ¶特性 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 首页轮播文章及每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。 支持 DaoVoice、Tidio 在线聊天功能。 ¶贡献者 感谢下面列出的贡献者，没有他们，hexo-theme-matery 不会这么完美。 @HarborZeng @shw2018 @L1cardo @Five-great ¶下载 当你看到这里的时候，应该已经有一个自己的 Hexo 博客了。如果还没有的话，不妨使用 Hexo 和 Markdown 来写博客和文章。 点击 这里 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。 当然你也可以在你的 themes 文件夹下使用 Git clone 命令来下载: 1git clone https://github.com/blinkfox/hexo-theme-matery.git ¶配置 ¶切换主题 修改 Hexo 根目录下的 _config.yml 的 theme 的值：theme: hexo-theme-matery ¶_config.yml 文件的其它修改建议: 请修改 _config.yml 的 url 的值为你的网站主 URL（如：http://xxx.github.io）。 建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。 如果你是中文用户，则建议修改 language 的值为 zh-CN。 ¶新建分类 categories 页 categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"categories\" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： 123456---title: categoriesdate: 2018-09-30 17:25:30type: \"categories\"layout: \"categories\"--- ¶新建标签 tags 页 tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"tags\" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： 123456---title: tagsdate: 2018-09-30 18:23:38type: \"tags\"layout: \"tags\"--- ¶新建关于我 about 页 about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"about\" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： 123456---title: aboutdate: 2018-09-30 17:25:30type: \"about\"layout: \"about\"--- ¶新建留言板 contact 页（可选的） contact 页是用来展示留言板信息的页面，如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"contact\" 编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容： 123456---title: contactdate: 2018-09-30 17:25:30type: \"contact\"layout: \"contact\"--- 注：本留言板功能依赖于第三方评论系统，请激活你的评论系统才有效果。并且在主题的 _config.yml 文件中，第 19 至 21 行的“菜单”配置，取消关于留言板的注释即可。 ¶新建友情连接 friends 页（可选的） friends 页是用来展示友情连接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"friends\" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： 123456---title: friendsdate: 2018-12-12 21:25:30type: \"friends\"layout: \"friends\"--- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： 12345678910111213141516171819[{ \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\", \"name\": \"码酱\", \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\", \"url\": \"http://luokangyuan.com/\", \"title\": \"前去学习\"}, { \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\", \"name\": \"闪烁之狐\", \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\", \"url\": \"https://blinkfox.github.io/\", \"title\": \"前去学习\"}, { \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\", \"name\": \"ja_rome\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://me.csdn.net/jlh912008548\", \"title\": \"前去学习\"}] ¶菜单导航配置 ¶配置基本菜单导航的名称、路径url和图标icon. 1.菜单导航名称可以是中文也可以是英文(如：Index或主页) 2.图标icon 可以在Font Awesome 中查找 12345678910111213141516171819menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book ¶二级菜单配置方法 如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作 1.在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children) 2.在children下创建二级菜单的 名称name,路径url和图标icon. 3.注意每个二级菜单模块前要加 -. 4.注意缩进格式 12345678910111213141516171819202122232425262728293031323334menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后就可以在文章中对应位置看到你用emoji语法写的表情了。 ¶代码高亮 由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下： 1npm i -S hexo-prism-plugin 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下： 12345678highlight: enable: falseprism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: ¶搜索 本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： 1npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123search: path: search.xml field: post ¶中文链接转拼音（建议安装） 如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。 安装命令如下： 1npm i hexo-permalink-pinyin --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123permalink_pinyin: enable: true separator: '-' # default: '-' 注：除了此插件外，hexo-abbrlink 插件也可以生成非中文的链接。 ¶文章字数统计插件（建议安装） 如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。 安装命令如下： 1npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可： 1234567postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数. ¶添加emoji表情支持（可选的） 本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下： 1npm install hexo-filter-github-emojis --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: ¶添加 RSS 订阅支持（可选的） 本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下： 1npm install hexo-generator-feed --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456789feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。 ¶添加 DaoVoice 在线聊天功能（可选的） 前往 DaoVoice 官网注册并且获取 app_id，并将 app_id 填入主题的 _config.yml 文件中。 ¶添加 Tidio 在线聊天功能（可选的） 前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 ¶修改页脚 页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。 ¶修改社交链接 在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： 12345&lt;% if (theme.socialLink.github) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.github %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-github\"&gt;&lt;/i&gt; &lt;/a&gt;&lt;% } %&gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0。 ¶修改打赏的二维码图片 在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 ¶配置音乐播放器（可选的） 要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。 首先，在你的博客 source 目录下的 _data 目录（没有的话就新建一个）中新建 musics.json 文件，文件内容如下所示： 12345678910111213141516[{ \"name\": \"五月雨变奏电音\", \"artist\": \"AnimeVibe\", \"url\": \"http://xxx.com/music1.mp3\", \"cover\": \"http://xxx.com/music-cover1.png\"}, { \"name\": \"Take me hand\", \"artist\": \"DAISHI DANCE,Cecile Corbel\", \"url\": \"/medias/music/music2.mp3\", \"cover\": \"/medias/music/cover2.png\"}, { \"name\": \"Shape of You\", \"artist\": \"J.Fla\", \"url\": \"http://xxx.com/music3.mp3\", \"cover\": \"http://xxx.com/music-cover3.png\"}] 注：以上 JSON 中的属性：name、artist、url、cover 分别表示音乐的名称、作者、音乐文件地址、音乐封面。 然后，在主题的 _config.yml 配置文件中激活配置即可： 1234567891011121314# 是否在首页显示音乐.music: enable: true showTitle: false title: 听听音乐 fixed: false # 是否开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'list' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: false # 列表默认折叠 listMaxHeight: # 列表最大高度 ¶文章 Front-matter 介绍 ¶Front-matter 选项详解 Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。 ¶最简示例 1234---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00--- ¶最全示例 1234567891011121314151617---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags: - Typora - Markdown--- ¶效果截图 ¶自定制修改 在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分： 菜单 我的梦想 首页的音乐播放器和视频播放器配置 是否显示推荐文章名称和按钮配置 favicon 和 Logo 个人信息 TOC 目录 文章打赏信息 复制文章内容时追加版权信息 MathJax 文章字数统计、阅读时长 点击页面的’爱心’效果 我的项目 我的技能 我的相册 Gitalk、Gitment、Valine 和 disqus 评论配置 不蒜子统计和谷歌分析（Google Analytics） 默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图 我认为个人博客应该都有自己的风格和特色。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方： ¶修改主题颜色 在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： 123456789101112/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}@-webkit-keyframes rainbow { /* 动态切换背景颜色. */}@keyframes rainbow { /* 动态切换背景颜色. */} ¶修改 banner 图和文章特色图 你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 &lt;script&gt;&lt;/script&gt; 代码中： 1$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); 在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。 ¶版本记录 v1.2.2 新增了自定义文章 keywords 的功能； 新增静态彩带点击切换的功能和配置； 将文章字数统计、彩带和站点运行时间等功能默认设置为 false； 修改了文章的 description 的 meta 属性优先读取文章的 summary 属性； 修改了文章标题的 HTML 标签，从 div 改成了 h1 标题； 修改了页脚年份显示不正确的问题； 去掉了站点运行时间中多余的 setTimeout 代码； v1.2.1 新增了 TOC 的展开目录层级设置和滚动条功能，防止目录较多的时候目录溢出； 修改了首页的展示方式为以前的模式； 修复首页按钮没有边框的问题； 修复了音乐及吸底模式、视频、推荐文章等不激活时仍然生成首页卡片的问题； 修复 wordCount 插件未安装的问题，修改了部分配置； 修复音乐的 JSON 配置中有单引号的情况页面不显示的音乐的问题 修复标签云在Hexo4.0下链接失效的问题； v1.2.0 新增了 DaoVoice、Tidio 的在线聊天功能； 新增了两级菜单的功能； 新增了打字效果的副标题； 新增了网页内容预加载的功能； 新增了首页 banner 是否每日切换的配置功能； 新增了显示 ICP 备案信息的功能，默认未开启； 新增了百度分析的配置； 新增了代码块的语言显示、一键复制、显示行号等功能； 新增了首页轮播图和推荐文章可自定义配置的功能； 新增了文章页面显示更新日期； 新增了转载规则的图标； 修改了分享的布局和显示方式； 升级更新了部分依赖库的版本； 其他细节修改和优化； v1.1.0 新增了 emoji 的支持； 新增了站点运行时间统计及配置； 新增了留言板的功能,默认未开启； 新增了 Twitter、Facebook、知乎的社交链接； 更新了 Valine 的版本为最新版； 其他小细节的修改； v1.0.4 新增了能为每篇文章都自定义转载规则的功能； 修复上一页、下一页的自定义 summary 不显示的问题； 修复了友情链接显示错位的问题，改为了瀑布流的布局方式； 其他小细节 bug 的修改； v1.0.3 新增了TOC展开、收缩的按钮和相关配置，默认显示此按钮； v1.0.2 升级了 Materialize 框架版本为1.0.0，重构和修改了升级过程中的部分文件或问题； 新增了首页封面的全屏轮播特效，可以将更重要的文章设置到首页轮播中； 修复首页第一个按钮是中文的问题 修复了 iPhone 上点击搜索输入获取焦点的问题； 修复了 iPhone 上输入框获取焦点后页面放大的问题； 修复一些文章或 UI 显示问题； v1.0.1 调整 css、js 的文件请求路径在主题的_config.yml中配置，便于你更快捷的配置自己的 CDN； 新增代码是否折行为可配置，默认为折行； 默认激活 TOC 功能，并新增为某篇文章关闭 TOC 的 Front-matter 配置选项； 修复文章滚动时，高亮的目录选项不准确的问题； IOS下移除搜索框自动获得焦点属性，防止自动获得焦点后导致视图上移； v1.0.0 新增了所有基础功能； document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo主题","slug":"Hexo主题","permalink":"https://www.itnxd.cn/categories/Hexo%E4%B8%BB%E9%A2%98/"}],"tags":[{"name":"matery","slug":"matery","permalink":"https://www.itnxd.cn/tags/matery/"}],"author":"Mr.Niu"},{"title":"Hexo中引入音乐和视频","slug":"Hexo中引入音乐和视频","date":"2020-02-03T13:06:43.000Z","updated":"2020-08-01T13:07:44.601Z","comments":true,"path":"posts/14163.html","link":"","permalink":"https://www.itnxd.cn/posts/14163.html","excerpt":"","text":"¶1、通过网易云网站引入外链HTML代码: ¶如图所示，复制当中的HTML代码即可。 效果如下: 1&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=100% height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=1346281717&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt; ¶2、通过B站来引入外链HTML代码: ¶如图所示，复制当中的HTML代码即可。 效果如下: ¶3、通过Hexo的插件来引用音乐: hexo-tag-aplayer： 点击这里！ hexo-tag-dplayer： 点击这里！ 通过npm来安装两个插件： 1234$ npm install hexo-tag-aplayer --save$ npm install hexo-tag-dplayer --save ¶第一种：meting后面根歌单id。 例如 :https://music.163.com/playlist?id=523845661&amp;userid=46562117 ，这个歌 单的id就是523845661，公司名可以是tencent、netease或是其他公司。 最新版的 hexo-tag-aplayer 已经支持了MetingJS的使用，可以直接解析网络平台的歌曲，在站点配置文件_config.yml中将aplayer的meting属性开启。 123aplayer: meting: true 参考文章：点击这里！ 有关细节及参数，点击这里！ 1{% meting \"523845661\" \"netease\" \"playlist\" \"theme:#FF4081\" \"mode:circulation\" \"mutex:true\" \"listmaxheight:340px\" \"preload:auto\" %} ¶第二种：写上名字，歌手，链接地址即可。 参考文章：点击这里！ 1{% aplayer \"她的睫毛\" \"周杰伦\" \"https://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3\" \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\" \"autoplay=false\" %} var ap = new APlayer({ element: document.getElementById(\"aplayer-jVXNCIlT\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"她的睫毛\", author: \"周杰伦\", url: \"https://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3\", pic: \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); ¶通过meting 和 aplayer 的引用，无法同时使用，都在的时候，只能加载meting! ¶4、通过Hexo的插件来引用视频: 效果如下: 12{% dplayer \"url=http://home.ustc.edu.cn/~mmmwhy/GEM.mp4\" \"pic=http://home.ustc.edu.cn/~mmmwhy/GEM.jpg\" \"loop=yes\" \"theme=#FADFA3\" \"autoplay=false\" \"token=tokendemo\" %} (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"http://home.ustc.edu.cn/~mmmwhy/GEM.mp4\",\"pic\":\"http://home.ustc.edu.cn/~mmmwhy/GEM.jpg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.itnxd.cn/categories/Hexo/"}],"tags":[{"name":"aplayer","slug":"aplayer","permalink":"https://www.itnxd.cn/tags/aplayer/"},{"name":"dplayer","slug":"dplayer","permalink":"https://www.itnxd.cn/tags/dplayer/"}],"author":"Mr.Niu"},{"title":"用法总结之Markdown","slug":"用法总结之Markdown","date":"2020-02-03T11:36:46.000Z","updated":"2021-05-01T02:05:58.850Z","comments":true,"path":"posts/25708.html","link":"","permalink":"https://www.itnxd.cn/posts/25708.html","excerpt":"","text":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。Markdown 编写的文档后缀为 .md, .markdown。 技术支持：Markdown教程|菜鸟教程 注意：Markdown可以使用Html语法及标签 ¶一、编写 Markdown 好用软件 ¶1、Typora 优点：可视化很强，写了后回车即可见到真实效果。 ¶2、VS Code 最强大的编辑器，只要安装了对应的插件，即可实现所有的编辑即代码运行调试！ ¶二、Markdown 语法 ¶1、标题 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 显示效果： ¶2、段落 Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 12这是段落！ 下一段落... 显示效果： 这是段落！ 下一段落… ¶3、字体 ¶3.1 粗体 1**粗体** 显示效果： 粗体 ¶3.2 斜体 1*斜体* 显示效果： 斜体 ¶3.3 粗斜体 1___粗斜___ 显示效果： 粗斜体 ¶4、分割线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。下面每种写法都可以建立分隔线： 1234567********------------- 显示效果： ¶5、列表 ¶5.1 有序列表 有序列表使用数字并加上 . 号来表示 1231. 第一项2. 第二项3. 第三项 显示效果： 第一项 第二项 第三项 ¶5、2 无序列表 无序列表用 * + -来表示 123456789- 第一项- 第二项- 第三项+ 第一项+ 第二项+ 第三项* 第一项* 第二项* 第三项 显示效果： 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 ¶5.3 列表嵌套 1234561. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 显示效果： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 ¶6、区块 Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号. ¶6.1 普通区块 123&gt; 普通区块&gt; hello&gt; 床前明月光 显示效果： 普通区块 hello 床前明月光 ¶6.2 列表中使用区块 1234- 第一层 &gt; 我是Mr.Niu- 第二层 &gt; 你好，世界！ 显示效果： 第一层 我是Mr.Niu 第二层 你好，世界！ ¶6.3 区块中使用列表 123&gt; 第一层 - 我是Mr.Niu - 你好世界！ 显示效果： 第一层 我是Mr.Niu 你好世界！ ¶6.4 区块嵌套 123&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套 显示效果： 最外层 第一层嵌套 第二层嵌套 ¶7、代码 ¶7.1 段落内代码 1这是`printf()`函数 显示效果： 这是printf()函数！ ¶7.2 代码块 用 ``` 包裹一段代码，并指定一种语言（也可以不指定）： 123456789101112```c++#include &lt;iostream&gt;using namesapce std;int main(){ cout &lt;&lt; \"hello world!\" &lt;&lt; endl; return 0;}``` 显示效果： 123456789#include &lt;iostream&gt;using namesapce std;int main(){ cout &lt;&lt; \"hello world!\" &lt;&lt; endl; return 0;} ¶8、链接 ¶8.1 普通用法 1234567[链接名称](链接地址)[Mr.Niu's Blog](https://niuxvdong.top)或者&lt;https://niuxvdong.top&gt; 显示效果： Mr.Niu’s Blog https://niuxvdong.top ¶8.2 高级用法： 1234567链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 [Baidu][1]这个链接用 niu 作为网址变量 [Blog][niu]然后在文档的结尾为变量赋值（网址） [1]: https://www.baidu.com [niu]: https://niuxvdong.top 显示效果： 链接也可以用变量来代替，文档末尾附带变量地址： 这个链接用 1 作为网址变量 Baidu 这个链接用 niu 作为网址变量 Blog 然后在文档的结尾为变量赋值（网址）： ¶9、图片 格式如下： 123![alt 属性文本](图片地址)![alt 属性文本](图片地址 \"可选标题\") 1![](https://cdn.jsdelivr.net/gh/niuxvdong/images/img/e%20(2).jpg) 显示效果： ¶10、表格 Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 格式如下： 1234| 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 显示效果： 表头 表头 单元格 单元格 单元格 单元格 对齐方式： 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 1234|左对齐|右对齐|居中对齐||:----- | -----:|:------:||单元格|单元格|单元格||单元格|单元格|单元格| 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 ¶11、高级技巧（使用HTML） ¶11.1 使用html标签实现键盘按键图标 1使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 显示效果： 使用 Ctrl+Alt+Del 重启电脑 ¶11.2 用 \\ 来实现转义 Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： 12**文本加粗** \\*\\* 正常显示星号 \\*\\* 显示效果： 文本加粗 ** 正常显示星号 ** 可实现的转义字符如下： 123456789101112\\ 反斜线` 反引号* 星号_ 下划线{} 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号 ¶11.3 更多高级用法参考菜鸟教程 1234567​```mermaidgraph LRA[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 12345678​```mermaidgraph LRA[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://www.itnxd.cn/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://www.itnxd.cn/tags/Markdown/"}],"author":"Mr.Niu"},{"title":"Hello World","slug":"hello-world","date":"2020-01-31T04:21:55.000Z","updated":"2020-05-19T02:40:28.268Z","comments":true,"path":"posts/16107.html","link":"","permalink":"https://www.itnxd.cn/posts/16107.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ¶Quick Start ¶Create a new post 1$ hexo new \"My New Post\" More info: Writing ¶Run server 1$ hexo server More info: Server ¶Generate static files 1$ hexo generate More info: Generating ¶Deploy to remote sites 1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.itnxd.cn/categories/Hexo/"}],"tags":[{"name":"Doc","slug":"Doc","permalink":"https://www.itnxd.cn/tags/Doc/"}]}],"categories":[{"name":"中间件","slug":"中间件","permalink":"https://www.itnxd.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"索引","slug":"数据库/索引","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/"},{"name":"关系型数据库","slug":"数据库/关系型数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"非关系型数据库","slug":"数据库/非关系型数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Shell","slug":"Shell","permalink":"https://www.itnxd.cn/categories/Shell/"},{"name":"Linux","slug":"Linux","permalink":"https://www.itnxd.cn/categories/Linux/"},{"name":"Git","slug":"Git","permalink":"https://www.itnxd.cn/categories/Git/"},{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"},{"name":"数据库框架","slug":"数据库框架","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A1%86%E6%9E%B6/"},{"name":"Spring全家桶","slug":"Spring全家桶","permalink":"https://www.itnxd.cn/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"},{"name":"构建工具","slug":"构建工具","permalink":"https://www.itnxd.cn/categories/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://www.itnxd.cn/categories/JavaWeb/"},{"name":"JDBC","slug":"JDBC","permalink":"https://www.itnxd.cn/categories/JDBC/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.itnxd.cn/categories/MySQL/"},{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://www.itnxd.cn/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"JS实战","slug":"JS实战","permalink":"https://www.itnxd.cn/categories/JS%E5%AE%9E%E6%88%98/"},{"name":"随笔","slug":"随笔","permalink":"https://www.itnxd.cn/categories/%E9%9A%8F%E7%AC%94/"},{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://www.itnxd.cn/categories/JavaScript%E6%95%99%E7%A8%8B/"},{"name":"Hexo主题","slug":"Hexo主题","permalink":"https://www.itnxd.cn/categories/Hexo%E4%B8%BB%E9%A2%98/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.itnxd.cn/categories/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.itnxd.cn/categories/Markdown/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.itnxd.cn/tags/Nginx/"},{"name":"Lua","slug":"Lua","permalink":"https://www.itnxd.cn/tags/Lua/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://www.itnxd.cn/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"反向代理","slug":"反向代理","permalink":"https://www.itnxd.cn/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"},{"name":"B树","slug":"B树","permalink":"https://www.itnxd.cn/tags/B%E6%A0%91/"},{"name":"B+树","slug":"B-树","permalink":"https://www.itnxd.cn/tags/B-%E6%A0%91/"},{"name":"索引","slug":"索引","permalink":"https://www.itnxd.cn/tags/%E7%B4%A2%E5%BC%95/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.itnxd.cn/tags/MySQL/"},{"name":"索引优化","slug":"索引优化","permalink":"https://www.itnxd.cn/tags/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"},{"name":"性能分析","slug":"性能分析","permalink":"https://www.itnxd.cn/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"Redis","slug":"Redis","permalink":"https://www.itnxd.cn/tags/Redis/"},{"name":"RDB","slug":"RDB","permalink":"https://www.itnxd.cn/tags/RDB/"},{"name":"AOF","slug":"AOF","permalink":"https://www.itnxd.cn/tags/AOF/"},{"name":"集群","slug":"集群","permalink":"https://www.itnxd.cn/tags/%E9%9B%86%E7%BE%A4/"},{"name":"Shell","slug":"Shell","permalink":"https://www.itnxd.cn/tags/Shell/"},{"name":"Linux","slug":"Linux","permalink":"https://www.itnxd.cn/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"https://www.itnxd.cn/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://www.itnxd.cn/tags/GitHub/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"树的遍历","slug":"树的遍历","permalink":"https://www.itnxd.cn/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"多路归并","slug":"多路归并","permalink":"https://www.itnxd.cn/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://www.itnxd.cn/tags/MyBatis/"},{"name":"PageHelper","slug":"PageHelper","permalink":"https://www.itnxd.cn/tags/PageHelper/"},{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"},{"name":"SpringMvc","slug":"SpringMvc","permalink":"https://www.itnxd.cn/tags/SpringMvc/"},{"name":"思维题","slug":"思维题","permalink":"https://www.itnxd.cn/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"},{"name":"数学","slug":"数学","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E5%AD%A6/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间DP","slug":"区间DP","permalink":"https://www.itnxd.cn/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"DP","slug":"DP","permalink":"https://www.itnxd.cn/tags/DP/"},{"name":"数论","slug":"数论","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"因式分解","slug":"因式分解","permalink":"https://www.itnxd.cn/tags/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/"},{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"},{"name":"找规律","slug":"找规律","permalink":"https://www.itnxd.cn/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"},{"name":"思维","slug":"思维","permalink":"https://www.itnxd.cn/tags/%E6%80%9D%E7%BB%B4/"},{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"二进制","slug":"二进制","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"},{"name":"Maven","slug":"Maven","permalink":"https://www.itnxd.cn/tags/Maven/"},{"name":"Spring5","slug":"Spring5","permalink":"https://www.itnxd.cn/tags/Spring5/"},{"name":"Log4j2","slug":"Log4j2","permalink":"https://www.itnxd.cn/tags/Log4j2/"},{"name":"Junit5","slug":"Junit5","permalink":"https://www.itnxd.cn/tags/Junit5/"},{"name":"Nullable","slug":"Nullable","permalink":"https://www.itnxd.cn/tags/Nullable/"},{"name":"JdbcTemplate","slug":"JdbcTemplate","permalink":"https://www.itnxd.cn/tags/JdbcTemplate/"},{"name":"声明式事务","slug":"声明式事务","permalink":"https://www.itnxd.cn/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"name":"AOP","slug":"AOP","permalink":"https://www.itnxd.cn/tags/AOP/"},{"name":"IOC","slug":"IOC","permalink":"https://www.itnxd.cn/tags/IOC/"},{"name":"单调栈","slug":"单调栈","permalink":"https://www.itnxd.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"位运算","slug":"位运算","permalink":"https://www.itnxd.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"全加器","slug":"全加器","permalink":"https://www.itnxd.cn/tags/%E5%85%A8%E5%8A%A0%E5%99%A8/"},{"name":"模板","slug":"模板","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"JSON","slug":"JSON","permalink":"https://www.itnxd.cn/tags/JSON/"},{"name":"Ajax","slug":"Ajax","permalink":"https://www.itnxd.cn/tags/Ajax/"},{"name":"i18n","slug":"i18n","permalink":"https://www.itnxd.cn/tags/i18n/"},{"name":"Filter","slug":"Filter","permalink":"https://www.itnxd.cn/tags/Filter/"},{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"https://www.itnxd.cn/tags/ThreadLocal/"},{"name":"Kaptcha","slug":"Kaptcha","permalink":"https://www.itnxd.cn/tags/Kaptcha/"},{"name":"验证码","slug":"验证码","permalink":"https://www.itnxd.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"name":"Cookie","slug":"Cookie","permalink":"https://www.itnxd.cn/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"https://www.itnxd.cn/tags/Session/"},{"name":"文件上传下载","slug":"文件上传下载","permalink":"https://www.itnxd.cn/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"},{"name":"EL","slug":"EL","permalink":"https://www.itnxd.cn/tags/EL/"},{"name":"JSTL","slug":"JSTL","permalink":"https://www.itnxd.cn/tags/JSTL/"},{"name":"JSP","slug":"JSP","permalink":"https://www.itnxd.cn/tags/JSP/"},{"name":"Listener","slug":"Listener","permalink":"https://www.itnxd.cn/tags/Listener/"},{"name":"Servlet","slug":"Servlet","permalink":"https://www.itnxd.cn/tags/Servlet/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://www.itnxd.cn/tags/Tomcat/"},{"name":"jQuery","slug":"jQuery","permalink":"https://www.itnxd.cn/tags/jQuery/"},{"name":"JDBC","slug":"JDBC","permalink":"https://www.itnxd.cn/tags/JDBC/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.itnxd.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"注解","slug":"注解","permalink":"https://www.itnxd.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"泛型","slug":"泛型","permalink":"https://www.itnxd.cn/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"StringBuilder","slug":"StringBuilder","permalink":"https://www.itnxd.cn/tags/StringBuilder/"},{"name":"StringBuffer","slug":"StringBuffer","permalink":"https://www.itnxd.cn/tags/StringBuffer/"},{"name":"枚举类","slug":"枚举类","permalink":"https://www.itnxd.cn/tags/%E6%9E%9A%E4%B8%BE%E7%B1%BB/"},{"name":"集合","slug":"集合","permalink":"https://www.itnxd.cn/tags/%E9%9B%86%E5%90%88/"},{"name":"面向对象","slug":"面向对象","permalink":"https://www.itnxd.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"Flood Fill","slug":"Flood-Fill","permalink":"https://www.itnxd.cn/tags/Flood-Fill/"},{"name":"哈希","slug":"哈希","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C/"},{"name":"最短路","slug":"最短路","permalink":"https://www.itnxd.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"},{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"前后缀分解","slug":"前后缀分解","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E5%90%8E%E7%BC%80%E5%88%86%E8%A7%A3/"},{"name":"递推","slug":"递推","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E6%8E%A8/"},{"name":"滚动数组","slug":"滚动数组","permalink":"https://www.itnxd.cn/tags/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"},{"name":"平衡二叉树","slug":"平衡二叉树","permalink":"https://www.itnxd.cn/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"二叉树搜索树","slug":"二叉树搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://www.itnxd.cn/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"后序遍历","slug":"后序遍历","permalink":"https://www.itnxd.cn/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"前序遍历","slug":"前序遍历","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"Morris-traversal","slug":"Morris-traversal","permalink":"https://www.itnxd.cn/tags/Morris-traversal/"},{"name":"卡特兰数","slug":"卡特兰数","permalink":"https://www.itnxd.cn/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"},{"name":"搜索","slug":"搜索","permalink":"https://www.itnxd.cn/tags/%E6%90%9C%E7%B4%A2/"},{"name":"格雷编码","slug":"格雷编码","permalink":"https://www.itnxd.cn/tags/%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/"},{"name":"数组","slug":"数组","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%BB%84/"},{"name":"线性扫描","slug":"线性扫描","permalink":"https://www.itnxd.cn/tags/%E7%BA%BF%E6%80%A7%E6%89%AB%E6%8F%8F/"},{"name":"哈希表","slug":"哈希表","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://www.itnxd.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"三指针","slug":"三指针","permalink":"https://www.itnxd.cn/tags/%E4%B8%89%E6%8C%87%E9%92%88/"},{"name":"二维二分","slug":"二维二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E7%BB%B4%E4%BA%8C%E5%88%86/"},{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"取巧算法","slug":"取巧算法","permalink":"https://www.itnxd.cn/tags/%E5%8F%96%E5%B7%A7%E7%AE%97%E6%B3%95/"},{"name":"树的直径","slug":"树的直径","permalink":"https://www.itnxd.cn/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"两次搜索","slug":"两次搜索","permalink":"https://www.itnxd.cn/tags/%E4%B8%A4%E6%AC%A1%E6%90%9C%E7%B4%A2/"},{"name":"树形DP","slug":"树形DP","permalink":"https://www.itnxd.cn/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"链式前向星","slug":"链式前向星","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"},{"name":"高精度","slug":"高精度","permalink":"https://www.itnxd.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"全排列","slug":"全排列","permalink":"https://www.itnxd.cn/tags/%E5%85%A8%E6%8E%92%E5%88%97/"},{"name":"快速幂","slug":"快速幂","permalink":"https://www.itnxd.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"旋转","slug":"旋转","permalink":"https://www.itnxd.cn/tags/%E6%97%8B%E8%BD%AC/"},{"name":"字符集","slug":"字符集","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"name":"安全管理","slug":"安全管理","permalink":"https://www.itnxd.cn/tags/%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/"},{"name":"数据库维护","slug":"数据库维护","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/"},{"name":"改善性能","slug":"改善性能","permalink":"https://www.itnxd.cn/tags/%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD/"},{"name":"游标","slug":"游标","permalink":"https://www.itnxd.cn/tags/%E6%B8%B8%E6%A0%87/"},{"name":"触发器","slug":"触发器","permalink":"https://www.itnxd.cn/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/"},{"name":"表","slug":"表","permalink":"https://www.itnxd.cn/tags/%E8%A1%A8/"},{"name":"视图","slug":"视图","permalink":"https://www.itnxd.cn/tags/%E8%A7%86%E5%9B%BE/"},{"name":"存储过程","slug":"存储过程","permalink":"https://www.itnxd.cn/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"},{"name":"数独","slug":"数独","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%8B%AC/"},{"name":"事务","slug":"事务","permalink":"https://www.itnxd.cn/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"隔离","slug":"隔离","permalink":"https://www.itnxd.cn/tags/%E9%9A%94%E7%A6%BB/"},{"name":"倍增","slug":"倍增","permalink":"https://www.itnxd.cn/tags/%E5%80%8D%E5%A2%9E/"},{"name":"KMP","slug":"KMP","permalink":"https://www.itnxd.cn/tags/KMP/"},{"name":"堆","slug":"堆","permalink":"https://www.itnxd.cn/tags/%E5%A0%86/"},{"name":"k路归并","slug":"k路归并","permalink":"https://www.itnxd.cn/tags/k%E8%B7%AF%E5%BD%92%E5%B9%B6/"},{"name":"二路归并","slug":"二路归并","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6/"},{"name":"Dp","slug":"Dp","permalink":"https://www.itnxd.cn/tags/Dp/"},{"name":"回文数","slug":"回文数","permalink":"https://www.itnxd.cn/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"},{"name":"反转","slug":"反转","permalink":"https://www.itnxd.cn/tags/%E5%8F%8D%E8%BD%AC/"},{"name":"枚举","slug":"枚举","permalink":"https://www.itnxd.cn/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"分治","slug":"分治","permalink":"https://www.itnxd.cn/tags/%E5%88%86%E6%B2%BB/"},{"name":"修改","slug":"修改","permalink":"https://www.itnxd.cn/tags/%E4%BF%AE%E6%94%B9/"},{"name":"INSERT","slug":"INSERT","permalink":"https://www.itnxd.cn/tags/INSERT/"},{"name":"UPDATE","slug":"UPDATE","permalink":"https://www.itnxd.cn/tags/UPDATE/"},{"name":"DELETE","slug":"DELETE","permalink":"https://www.itnxd.cn/tags/DELETE/"},{"name":"油猴脚本","slug":"油猴脚本","permalink":"https://www.itnxd.cn/tags/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"},{"name":"知乎","slug":"知乎","permalink":"https://www.itnxd.cn/tags/%E7%9F%A5%E4%B9%8E/"},{"name":"SELECT","slug":"SELECT","permalink":"https://www.itnxd.cn/tags/SELECT/"},{"name":"查询","slug":"查询","permalink":"https://www.itnxd.cn/tags/%E6%9F%A5%E8%AF%A2/"},{"name":"SQL","slug":"SQL","permalink":"https://www.itnxd.cn/tags/SQL/"},{"name":"加密","slug":"加密","permalink":"https://www.itnxd.cn/tags/%E5%8A%A0%E5%AF%86/"},{"name":"安全","slug":"安全","permalink":"https://www.itnxd.cn/tags/%E5%AE%89%E5%85%A8/"},{"name":"Regex","slug":"Regex","permalink":"https://www.itnxd.cn/tags/Regex/"},{"name":"JUnit","slug":"JUnit","permalink":"https://www.itnxd.cn/tags/JUnit/"},{"name":"Date","slug":"Date","permalink":"https://www.itnxd.cn/tags/Date/"},{"name":"Time","slug":"Time","permalink":"https://www.itnxd.cn/tags/Time/"},{"name":"IO","slug":"IO","permalink":"https://www.itnxd.cn/tags/IO/"},{"name":"File","slug":"File","permalink":"https://www.itnxd.cn/tags/File/"},{"name":"反射","slug":"反射","permalink":"https://www.itnxd.cn/tags/%E5%8F%8D%E5%B0%84/"},{"name":"异常处理","slug":"异常处理","permalink":"https://www.itnxd.cn/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"String","slug":"String","permalink":"https://www.itnxd.cn/tags/String/"},{"name":"JavaBean","slug":"JavaBean","permalink":"https://www.itnxd.cn/tags/JavaBean/"},{"name":"包装类型","slug":"包装类型","permalink":"https://www.itnxd.cn/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"},{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://www.itnxd.cn/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"归并排序","slug":"归并排序","permalink":"https://www.itnxd.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"逆序对","slug":"逆序对","permalink":"https://www.itnxd.cn/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"奇偶性","slug":"奇偶性","permalink":"https://www.itnxd.cn/tags/%E5%A5%87%E5%81%B6%E6%80%A7/"},{"name":"中位数","slug":"中位数","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"name":"priority_queue","slug":"priority-queue","permalink":"https://www.itnxd.cn/tags/priority-queue/"},{"name":"前缀和","slug":"前缀和","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"字典序","slug":"字典序","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E5%85%B8%E5%BA%8F/"},{"name":"组合数","slug":"组合数","permalink":"https://www.itnxd.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0/"},{"name":"差分序列","slug":"差分序列","permalink":"https://www.itnxd.cn/tags/%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97/"},{"name":"二维前缀和","slug":"二维前缀和","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://www.itnxd.cn/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"状压Dp","slug":"状压Dp","permalink":"https://www.itnxd.cn/tags/%E7%8A%B6%E5%8E%8BDp/"},{"name":"努力","slug":"努力","permalink":"https://www.itnxd.cn/tags/%E5%8A%AA%E5%8A%9B/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.itnxd.cn/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://www.itnxd.cn/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"https://www.itnxd.cn/tags/DOM/"},{"name":"Data","slug":"Data","permalink":"https://www.itnxd.cn/tags/Data/"},{"name":"RegExp","slug":"RegExp","permalink":"https://www.itnxd.cn/tags/RegExp/"},{"name":"函数","slug":"函数","permalink":"https://www.itnxd.cn/tags/%E5%87%BD%E6%95%B0/"},{"name":"入门","slug":"入门","permalink":"https://www.itnxd.cn/tags/%E5%85%A5%E9%97%A8/"},{"name":"基础","slug":"基础","permalink":"https://www.itnxd.cn/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"https://www.itnxd.cn/tags/Java/"},{"name":"Github","slug":"Github","permalink":"https://www.itnxd.cn/tags/Github/"},{"name":"matery","slug":"matery","permalink":"https://www.itnxd.cn/tags/matery/"},{"name":"aplayer","slug":"aplayer","permalink":"https://www.itnxd.cn/tags/aplayer/"},{"name":"dplayer","slug":"dplayer","permalink":"https://www.itnxd.cn/tags/dplayer/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.itnxd.cn/tags/Markdown/"},{"name":"Doc","slug":"Doc","permalink":"https://www.itnxd.cn/tags/Doc/"}]}