{"meta":{"title":"小牛博客","subtitle":"每天进步一点点!","description":"一个大学生的博客，记录学习，记录成长，分享生活！","author":"ITNXD","url":"https://www.itnxd.cn","root":"/"},"pages":[{"title":"404","date":"2020-02-05T05:33:10.000Z","updated":"2020-05-09T02:54:08.714Z","comments":true,"path":"404.html","permalink":"https://www.itnxd.cn/404.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2020-02-02T04:27:52.000Z","updated":"2020-05-09T02:54:08.764Z","comments":true,"path":"about/index.html","permalink":"https://www.itnxd.cn/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"books","date":"2020-02-05T03:09:36.000Z","updated":"2020-05-09T02:54:08.765Z","comments":true,"path":"books/index.html","permalink":"https://www.itnxd.cn/books/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-02-02T04:31:45.000Z","updated":"2020-05-09T02:54:08.768Z","comments":true,"path":"contact/index.html","permalink":"https://www.itnxd.cn/contact/index.html","excerpt":"","text":"有什么想说的，可以在下面留言哦，欢迎大家来讨论！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-02-02T04:26:28.000Z","updated":"2020-05-09T02:54:08.766Z","comments":true,"path":"categories/index.html","permalink":"https://www.itnxd.cn/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2020-02-02T04:29:49.000Z","updated":"2020-05-09T02:54:08.769Z","comments":true,"path":"friends/index.html","permalink":"https://www.itnxd.cn/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"galleries","date":"2020-02-05T03:27:33.000Z","updated":"2020-05-09T02:54:08.769Z","comments":true,"path":"galleries/index.html","permalink":"https://www.itnxd.cn/galleries/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"movies","date":"2020-02-05T03:09:13.000Z","updated":"2020-05-09T02:54:08.770Z","comments":true,"path":"movies/index.html","permalink":"https://www.itnxd.cn/movies/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"友情链接","date":"2020-05-18T14:17:49.000Z","updated":"2020-05-18T12:35:28.370Z","comments":true,"path":"link/index.html","permalink":"https://www.itnxd.cn/link/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"musics","date":"2020-02-05T03:08:51.000Z","updated":"2020-05-09T02:54:08.771Z","comments":true,"path":"musics/index.html","permalink":"https://www.itnxd.cn/musics/index.html","excerpt":"","text":"我的歌单 欢迎下方留言自己喜欢的歌单链接！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-06-17T01:49:04.748Z","updated":"2020-06-17T01:49:04.748Z","comments":true,"path":"self/atom-one-dark-reasonable.css","permalink":"https://www.itnxd.cn/self/atom-one-dark-reasonable.css","excerpt":"","text":"/* Atom One Dark With support for ReasonML by Gidi Morris, based off work by Daniel Gamage Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax */ /* 新添加的内容 */ /* ------------------------------------- */ /* 代码框背景色和字体顔色,与hljs一样就行 */ /* 必须配置(把下面.hljs的color和background复製到这里来) */ #article-container pre, #article-container figure.highlight { background: #282c34; color: #abb2bf } /* 代码框工具栏 (如果你关掉了copy、lang和shrink,可不用配置这个 */ #article-container figure.highlight .highlight-tools { color: #fff; background: #321a0f } /* 代码框行数(如果已经关掉line_number,可以不用配置这个) */ #article-container figure.highlight .gutter pre { background-color: #221a0f; color: #fff } /* 代码块figcaption配置(hexo自带标签https://hexo.io/zh-tw/docs/tag-plugins.html#Code-Block) */ /* 不需要可以不用配置这个 */ #article-container figure.highlight figcaption a { color: #d3af86 !important } /* ------------------------------------- */ /* 更改的内容 把.hljs改为 #article-container figure.highlight .hljs *、 /* ------------------------------------- */ #article-container figure.highlight .hljs { /* .hljs { */ display: block; overflow-x: auto; padding: 0.5em; color: #abb2bf; background: #282c34; } .hljs-keyword, .hljs-operator { color: #F92672; } .hljs-pattern-match { color: #F92672; } .hljs-pattern-match .hljs-constructor { color: #61aeee; } .hljs-function { color: #61aeee; } .hljs-function .hljs-params { color: #A6E22E; } .hljs-function .hljs-params .hljs-typing { color: #FD971F; } .hljs-module-access .hljs-module { color: #7e57c2; } .hljs-constructor { color: #e2b93d; } .hljs-constructor .hljs-string { color: #9CCC65; } .hljs-comment, .hljs-quote { color: #b18eb1; font-style: italic; } .hljs-doctag, .hljs-formula { color: #c678dd; } .hljs-section, .hljs-name, .hljs-selector-tag, .hljs-deletion, .hljs-subst { color: #e06c75; } .hljs-literal { color: #56b6c2; } .hljs-string, .hljs-regexp, .hljs-addition, .hljs-attribute, .hljs-meta-string { color: #98c379; } .hljs-built_in, .hljs-class .hljs-title { color: #e6c07b; } .hljs-attr, .hljs-variable, .hljs-template-variable, .hljs-type, .hljs-selector-class, .hljs-selector-attr, .hljs-selector-pseudo, .hljs-number { color: #d19a66; } .hljs-symbol, .hljs-bullet, .hljs-link, .hljs-meta, .hljs-selector-id, .hljs-title { color: #61aeee; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; } .hljs-link { text-decoration: underline; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-06-17T01:47:36.888Z","updated":"2020-06-17T01:47:36.888Z","comments":true,"path":"self/dracula.css","permalink":"https://www.itnxd.cn/self/dracula.css","excerpt":"","text":"/* Dracula Theme v1.2.0 https://github.com/zenorocha/dracula-theme Copyright 2015, All rights reserved Code licensed under the MIT license http://zenorocha.mit-license.org @author Éverton Ribeiro @author Zeno Rocha */ /* 新添加的内容 */ /* ------------------------------------- */ /* 代码框背景色和字体顔色,与hljs一样就行 */ /* 必须配置(把下面.hljs的color和background复製到这里来) */ #article-container pre, #article-container figure.highlight { background: #221a0f; color: #d3af86 } /* 代码框工具栏 (如果你关掉了copy、lang和shrink,可不用配置这个 */ #article-container figure.highlight .highlight-tools { color: #fff; background: #321a0f } /* 代码框行数(如果已经关掉line_number,可以不用配置这个) */ #article-container figure.highlight .gutter pre { background-color: #221a0f; color: #fff } /* 代码块figcaption配置(hexo自带标签https://hexo.io/zh-tw/docs/tag-plugins.html#Code-Block) */ /* 不需要可以不用配置这个 */ #article-container figure.highlight figcaption a { color: #d3af86 !important } /* ------------------------------------- */ /* 更改的内容 把.hljs改为 #article-container figure.highlight .hljs *、 /* ------------------------------------- */ #article-container figure.highlight .hljs { /* .hljs { */ display: block; overflow-x: auto; padding: 0.5em; background: #282a36; } .hljs-keyword, .hljs-selector-tag, .hljs-literal, .hljs-section, .hljs-link { color: #8be9fd; } .hljs-function .hljs-keyword { color: #ff79c6; } .hljs, .hljs-subst { color: #f8f8f2; } .hljs-string, .hljs-title, .hljs-name, .hljs-type, .hljs-attribute, .hljs-symbol, .hljs-bullet, .hljs-addition, .hljs-variable, .hljs-template-tag, .hljs-template-variable { color: #f1fa8c; } .hljs-comment, .hljs-quote, .hljs-deletion, .hljs-meta { color: #6272a4; } .hljs-keyword, .hljs-selector-tag, .hljs-literal, .hljs-title, .hljs-section, .hljs-doctag, .hljs-type, .hljs-name, .hljs-strong { font-weight: bold; } .hljs-emphasis { font-style: italic; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-02-05T09:18:22.000Z","updated":"2020-05-09T02:54:08.773Z","comments":true,"path":"tags/index.html","permalink":"https://www.itnxd.cn/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Java与数据库连接的纽带之JDBC使用总结","slug":"Java与数据库连接的纽带之Jdbc使用总结","date":"2021-03-04T03:05:39.000Z","updated":"2021-03-04T14:24:10.559Z","comments":true,"path":"posts/49844.html","link":"","permalink":"https://www.itnxd.cn/posts/49844.html","excerpt":"","text":"一、JDBC概述1、对JDBC的理解JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API）！ 简单理解：JDBC，是SUN提供的一套 API，使用这套API可以实现对具体数据库的操作；不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。提供数据库驱动jar包。我们可以导入这些jar包进行编程。 如下图所示： JDBC接口（API）包括两个层次： 面向应用的API：Java API，抽象接口，供应用程序开发人员使用 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 2、 Java中数据存储技术分类 在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO (Java Data Object )技术 第三方O/R工具，如Hibernate, Mybatis 等 JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。 二、获取数据库连接 本教程全部使用最新版的mysql数据库驱动，mysql-connector-java-8.0.23.jar 注意：新版本驱动将旧版驱动遗弃了，由com.mysql.jdbc.Driver改为 com.mysql.cj.jdbc.Driver 1、方式一 直接使用Driver连接数据库！ 1234567891011121314public void test1() throws SQLException { Driver driver = new com.mysql.cj.jdbc.Driver(); // jdbc:mysql：协议 // test：具体数据库 String url = \"jdbc:mysql://localhost:3306/test\"; Properties info = new Properties(); info.setProperty(\"user\", \"root\"); info.setProperty(\"password\", \"123\"); Connection conn = driver.connect(url, info); System.out.println(conn);} 几种常用数据库的 JDBC URL： jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值 jdbc:mysql://localhost:3306/test jdbc:mysql://localhost:3306/test**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456 2、方式二 对方式一的迭代：如下程序中不出现第三方API，程序具有更好的移植性！ 123456789101112131415161718public void test2() throws Exception { // 1. 获取driver实现类对象，使用反射 Class&lt;?&gt; clazz = Class.forName(\"com.mysql.cj.jdbc.Driver\"); Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance(); // 2. 提供要连接的数据库 String url = \"jdbc:mysql://localhost:3306/test\"; // 3. 提供连接需要的用户名和密码 Properties info = new Properties(); info.setProperty(\"user\", \"root\"); info.setProperty(\"password\", \"123\"); // 4. 获取连接 Connection conn = driver.connect(url, info); System.out.println(conn);} 3、方式三 使用DriverManager替换Driver！ 12345678910111213141516171819@Testpublic void test3() throws Exception{ // 1. 获取driver实现类对象，使用反射 Class&lt;?&gt; clazz = Class.forName(\"com.mysql.cj.jdbc.Driver\"); Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance(); // 2. 提供连接信息 String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"123\"; // 3. 注册驱动 DriverManager.registerDriver(driver); // 4. 获取连接（有多个重载方法！） Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn);} 4、方式四 对方式三的优化！ 几个注意点： java.sql.driver中使用静态代码块完成了驱动的注册！该步骤可以省略！ 1234567static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(\"Can't register driver!\"); }} 数据库厂家（mysql）已经内置了Class.forName(\"com.mysql.cj.jdbc.Driver\");其中的指定的包名在：该包下的META-INF/services/java.sql.Driver文件中为com.mysql.cj.jdbc.Driver虽然可以省略，但不建议省略，可能有的数据库厂家没有内置！目前mysql和oracle都内置了！ 123456789101112131415161718public void test4() throws Exception{ // 1. 提供连接信息 String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"xxx\"; // 2. 加载Driver Class.forName(\"com.mysql.cj.jdbc.Driver\"); // Driver driver = (Driver) clazz.getDeclaredConstructor().newInstance(); // DriverManager.registerDriver (driver); // 3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn);} 5、方式五（终极版） 对方式四改进，最终版本！ 将连接所需信息写到配置文件中再进行读取！ 防止部署到tomcat配置文件读取不到，我们将配置文件放到src下！ 优点： 实现了数据与代码的分离 如果需要修改配置文件信息，可以避免程序重新打包 1234567891011121314151617181920public void test5() throws Exception { // 自定义类是系统类加载器：类加载器主要作用就是获取src下的配置文件！ // 1. 读取配置文件的四个基本信息 InputStream is = CollectionTest.class.getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties properties = new Properties(); properties.load(is); String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); String url = properties.getProperty(\"url\"); String driverClass = properties.getProperty(\"driverClass\"); // 2. 加载驱动 Class.forName(driverClass); // 3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn);} jdbc.properties文件内容如下： 12345# JDBC配置文件，不要有空格！user=rootpassword=xxxurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=truedriverClass=com.mysql.cj.jdbc.Driver 使用配置文件的好处： 实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码 如果修改了配置信息，省去重新编译的过程。 用到的类加载器如图： 三、使用PreparedStatement实现CRUD操作1、java.sql下的三大接口在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 2、Statement的弊端 SQL注入：SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user='1' OR 1 = ' AND password = ' OR '1' = '1') ，从而利用系统的 SQL 引擎完成恶意行为的做法。 在上述语句中，user：1' OR 1 =，password： OR '1' = '1，该语句传到数据库服务器会被理解为几个与或语句，而最后一个语句永远成立，导致数据发生错误与不安全！ 拼串：String sql = \"SELECT user,password FROM user_table WHERE USER = '\" + userName + \"' AND PASSWORD = '\" + password + \"'\"; 存在拼串操作，繁琐 存在SQL注入问题 Statement没办法操作Blob类型变量 Statement实现批量插入时，效率较低 所以：使用preparedStatement替换，解决上述所有问题！ 3、两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 注意：sql是需要结合列名和表的属性名来写。注意起别名。 4、preparedStatement使用4.1、preparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql)方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement对象的 setXxx()方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1开始)，第二个是设置的 SQL 语句中的参数的值 4.2、PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 4.3、 Java与SQL对应数据类型转换 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 4.4、数据库连接与释放封装到JDBCUtils中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class JDBCUtils { /** * 获取数据库的连接！ * * @return Connection * @throws Exception */ public static Connection getConnection() throws Exception{ // 1. 读取配置文件的四个基本信息 InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties properties = new Properties(); properties.load(is); String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); String url = properties.getProperty(\"url\"); String driverClass = properties.getProperty(\"driverClass\"); // 2. 加载驱动 Class.forName(driverClass); // 3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); return conn; } /** * 关闭连接和 Statement的操作！ * * @param conn Connection * @param ps Statement */ public static void closeResource(Connection conn, Statement ps){ try { if(ps != null) ps.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(conn != null) conn.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } /** * 资源关闭操作！ * * @param conn Connection * @param ps Statement * @param rs ResultSet */ public static void closeResource(Connection conn, Statement ps, ResultSet rs){ try { if(ps != null) ps.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(conn != null) conn.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(rs != null) rs.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } }} 4.5、增删改实现 若执行查询语句，有结果集，则返回true，若执行增删改操作，无返回集，则返回false 可以使用executeUpdate()方法根据返回值判断执行结果的成与败：根据影响的行数返回值，0或非0！来判断是否成功！return ps.executeUpdate(); 1234567891011121314151617181920212223242526272829303132333435363738public void update(String sql, Object ...args) { Connection conn = null; PreparedStatement ps = null; try { // 1. 获取数据库连接 conn = JDBCUtils.getConnection(); // 2. 预编译sql语句，返回PrepareStatement实例 ps = conn.prepareStatement(sql); // 3. 填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 4. 执行操作 ps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { // 5. 资源关闭 JDBCUtils.closeResource(conn, ps); }}// 测试通用增删改操作！// 注意：若表名为关键字，需要加上``，例如order@Testpublic void test3(){ // 删： String sql = \"delete from customers where id = ?\"; update(sql, 3); // 改： String sql1 = \"update `order` set order_name = ? where order_id = ?\"; update(sql1, \"DD\", 2); // 增： String sql2 = \"insert into customers(name, email, birth) values(?, ?, ?)\"; update(sql2, \"陈小纭\", \"cxy@gmail.com\", new Date(System.currentTimeMillis()));} 4.6、查询实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * 1、针对所有表查询的通用方法！ * * @param clazz Class&lt;T&gt; * @param sql String * @param args Object * @param &lt;T&gt; 泛型方法 * @return T */public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object ...args){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); // 获取结果集的元数据！ ResultSetMetaData metaData = rs.getMetaData(); // 通过结果集的元数据获取列数！ int columnCount = metaData.getColumnCount(); if(rs.next()){ T t = clazz.getDeclaredConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { // 获取到每一列的值 Object columnValue = rs.getObject(i + 1); // 获取到每一列的别名或列名！（建议） String columnLabel = metaData.getColumnLabel(i + 1); // 使用反射设置值，给customer指定的属性columnLabel，赋值为columnValue Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnValue); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps, rs); } return null;}// 对通用方法的测试！@Testpublic void test(){ String sql = \"select order_id orderId, order_name orderName, order_date orderDate from `order` where order_id = ?\"; Orders order = getInstance(Orders.class, sql, 1); System.out.println(order); String sql1 = \"select id, name, email from customers where id = ?\"; Customers customer = getInstance(Customers.class, sql1, 1); System.out.println(customer);}/** * 2、针对所有表查询的通用方法！---解决多条数据返回！ * @param clazz Class&lt;T&gt; * @param sql String * @param args Object * @param &lt;T&gt; 泛型方法 * @return List&lt;T&gt; */public &lt;T&gt; List&lt;T&gt; getList(Class&lt;T&gt; clazz, String sql, Object ...args){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); // 获取结果集的元数据！ ResultSetMetaData metaData = rs.getMetaData(); // 通过结果集的元数据获取列数！ int columnCount = metaData.getColumnCount(); // 创建List集合 ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while(rs.next()){ T t = clazz.getDeclaredConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { // 获取到每一列的值 Object columnValue = rs.getObject(i + 1); // 获取到每一列的别名或列名！（建议） String columnLabel = metaData.getColumnLabel(i + 1); // 使用反射设置值，给customer指定的属性columnLabel，赋值为columnValue Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnValue); } list.add(t); } return list; } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps, rs); } return null;}@Testpublic void test2(){ String sql = \"select id, name, email from customers where id &lt; ?\"; List&lt;Customers&gt; list = getList(Customers.class, sql, 5); list.forEach(System.out::println); // 或 String sql1 = \"select id, name, email from customers\"; List&lt;Customers&gt; list1 = getList(Customers.class, sql1); list1.forEach(System.out::println);} 5、ResultSet与ResultSetMetaData介绍5.1、ResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet接口由数据库厂商提供实现 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(String columnName) 获取每一列的值。 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。 5.2、ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象！ ResultSetMetaData meta = rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名（无别名则为列名） getColumnCount()：返回当前 ResultSet 对象中的列数。 getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 isNullable(int column)：指示指定列中的值是否可以为 null。 isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 四、操作Blob类型字段1、BLOB类型介绍 MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。 需要注意的是：如果存储的文件过大，数据库的性能会下降。 如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet=16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。 注意：mysql8.0以上mediumblob（16m）没有package的1m限制！无需去my.ini去配置！ MySQL的四种BLOB类型： 2、插入实现123456789101112131415161718192021public void test1() { Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtils.getConnection(); String sql = \"insert into customers(name, email, birth, photo) values(?, ?, ?, ?)\"; ps = conn.prepareStatement(sql); ps.setObject(1, \"牛逼\"); ps.setObject(2, \"nb@gmail.com\"); ps.setObject(3, \"2021-02-01\"); ps.setBlob(4, new FileInputStream(\"hh2.png\")); ps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps); }} 4、查询实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void test2() { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; InputStream is = null; FileOutputStream fos = null; try { conn = JDBCUtils.getConnection(); String sql = \"select id,name,email,birth,photo from customers where id = ?\"; ps = conn.prepareStatement(sql); ps.setInt(1, 22); rs = ps.executeQuery(); if(rs.next()){ // 可以通过索引也可以通过别名！ int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String email = rs.getString(\"email\"); Date birth = rs.getDate(\"birth\"); Blob photo = rs.getBlob(\"photo\"); Customers cust = new Customers(id, name, email, birth); System.out.println(cust); // 将二进制图片写入本地！ is = photo.getBinaryStream(); fos = new FileOutputStream(\"nb.jpg\"); byte[] buffer = new byte[1024]; int len = 0; while((len = is.read(buffer)) != -1){ fos.write(buffer, 0, len); } } } catch (Exception e) { e.printStackTrace(); } finally { try { if(is != null) is.close(); } catch (IOException e) { e.printStackTrace(); } try { if(fos != null) fos.close(); } catch (IOException e) { e.printStackTrace(); } JDBCUtils.closeResource(conn, ps, rs); }} 五、批量插入1、方式一：使用Statement 已经弃用Statement，了解即可！每次都创建sql语句！效率极低！ 123456Connection conn = JDBCUtils.getConnection();Statement st = conn.createStatement();for(int i = 1;i &lt;= 20000;i++){ String sql = \"insert into goods(name)values('name_\" + i + \"')\"; st.execute(sql);} 2、方式二：使用prepareStatement 优化：使用prepareStatement的预编译SQL语句，减少SQL创建次数！一次编译，多次使用！可参考prepareStatement与statement的区别！ 123456789101112131415161718192021222324public void test1() { Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtils.getConnection(); String sql = \"insert into goods(name) values(?)\"; ps = conn.prepareStatement(sql); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) { ps.setObject(1, \"name_\" + i); ps.execute(); } long end = System.currentTimeMillis(); System.out.println(\"用时：\" + (end - start)); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps); }} 3、方式三：使用Batch优化注意点： mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。rewriteBatchedStatements=true 写在配置文件的url后面。 三个相关方法： addBatch(String)：添加需要批量处理的SQL语句或是参数； executeBatch()：执行批量处理语句； clearBatch(): 清空缓存的数据 jdbc.properties文件修改如下： 1url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true 代码实现： 1234567891011121314151617181920212223242526272829303132public void test2(){ Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtils.getConnection(); String sql = \"insert into goods(name) values(?)\"; ps = conn.prepareStatement(sql); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000; i++) { ps.setObject(1, \"name_\" + i); // 1. 攒够缓存Batch ps.addBatch(); if(i % 500 == 0){ // 2. 批量执行缓存Batch ps.executeBatch(); // 3. 清空缓存Batch ps.clearBatch(); } } long end = System.currentTimeMillis(); System.out.println(\"用时：\" + (end - start)); // 100w数据用时27300 } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps); }} 4、方式四：关闭自动提交（最优） mysql默认执行完语句都会自动提交，因此可以设置关闭自动提交来提高效率！执行完毕再进行手动提交！ 123456789101112131415161718192021222324252627282930313233343536373839public void test3(){ Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtils.getConnection(); // 一、关闭自动提交 conn.setAutoCommit(false); String sql = \"insert into goods(name) values(?)\"; ps = conn.prepareStatement(sql); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000; i++) { ps.setObject(1, \"name_\" + i); // 1. 攒够缓存Batch ps.addBatch(); if(i % 500 == 0){ // 2. 批量执行缓存Batch ps.executeBatch(); // 3. 清空缓存Batch ps.clearBatch(); } } // 二、手动提交 conn.commit(); long end = System.currentTimeMillis(); System.out.println(\"用时：\" + (end - start)); // 100w数据用时19448 } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps); }} 六、数据库事务 参考我之前写的文章，数据库事务处理，点击这里！ 1、对通用增删改考虑事务的优化 传入Connection连接即可，再外部连接使用全部结束后再关闭！ 注意： 以防发生自动提交，在获取连接后关闭自动提交！发生异常时进行回滚操作！最终在关闭连接前进行还原事务为自动提交！归还资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public void update(Connection conn, String sql, Object ...args) { PreparedStatement ps = null; try { // 1. 预编译sql语句，返回PrepareStatement实例 ps = conn.prepareStatement(sql); // 2. 填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 3. 执行操作 ps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { // 5. 资源关闭（以防关闭连接导致自动提交，传入null） JDBCUtils.closeResource(null, ps); }}// 测试考虑事务操作的update！public void test2(){ // 1. 处理一个连接多条语句 Connection conn = null; try { conn = JDBCUtils.getConnection(); // 2. 处理DML语言的默认提交 conn.setAutoCommit(false); String sql = \"update user_table set balance = balance - 100 where user = ?\"; update(conn, sql, \"AA\"); // 模拟网络异常： System.out.println(10 / 0); String sql1 = \"update user_table set balance = balance + 100 where user = ?\"; update(conn, sql1, \"BB\"); // 3. 手动提交 conn.commit(); } catch (Exception e) { e.printStackTrace(); // 4. 发生异常进行回滚 try { if(conn != null) conn.rollback(); } catch (SQLException throwables) { throwables.printStackTrace(); } } finally { // 5. 还原事务为自动提交（用在数据库连接池归还连接时还原为最初状态） try { conn.setAutoCommit(true); } catch (SQLException throwables) { throwables.printStackTrace(); } // 6. 关闭数据库连接！ JDBCUtils.closeResource(conn, null); }} 2、对通用查考虑事务的优化 传入Connection连接即可，再外部连接使用全部结束后再关闭！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 1、针对所有表查询的通用方法！v2.0 (考虑事务) * * @param clazz Class&lt;T&gt; * @param sql String * @param args Object * @param &lt;T&gt; 泛型方法 * @return T */public &lt;T&gt; T getInstance(Connection conn, Class&lt;T&gt; clazz, String sql, Object ...args){ PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); // 获取结果集的元数据！ ResultSetMetaData metaData = rs.getMetaData(); // 通过结果集的元数据获取列数！ int columnCount = metaData.getColumnCount(); if(rs.next()){ T t = clazz.getDeclaredConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { // 获取到每一列的值 Object columnValue = rs.getObject(i + 1); // 获取到每一列的别名或别名！（建议） String columnLabel = metaData.getColumnLabel(i + 1); // 使用反射设置值，给customer指定的属性columnLabel，赋值为columnValue Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnValue); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps, rs); } return null;} 3、会导致数据自动提交的操作 DDL操作一旦执行，都会自动提交。set autocommit = false 对DDL操作失效 DML默认情况下，一旦执行，就会自动提交。我们可以通过set autocommit = false的方式取消DML操作的自动提交。 默认在关闭连接时，会自动的提交数据 4、JDBC隔离级别的设置1234567891011public void test3() throws Exception{ Connection conn = JDBCUtils.getConnection(); // 查看当前事务隔离界别(1, 2, 4, 8) System.out.println(conn.getTransactionIsolation()); // 修改为 read uncommitted // 1. 通过对应数字修改 // conn.setTransactionIsolation(1); // 2. 通过隔离级别名称修改 conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);} 七、数据访问对象DAO DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更有利于代码的维护和升级 1、三部分组成 BaseDao：实现数据库增删改、查、分组函数的通用操作抽象类！只用于继承不用于实现！ XxxDao：实现对于某一个具体类的各种操作规范的接口，只用于定义规范，具体由XxxDaoImpl实现！ XxxDaoImpl：实现XxxDao定义的规范！ 2、BaseDao实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180public abstract class BaseDao&lt;T&gt; { // 反射：获取父类实现类的泛型！ // BaseDao作为通用父类，此处clazz是不确定的，无法声明为静态的，只能在子类实例化时创建！ private Class&lt;T&gt; clazz = null; // 如下方法使用clazz都是通过对象调用的，所以应该在对象实例化之前就知道clazz是谁！ // 可以显示赋值，构造器赋值，代码块赋值！ // 通过反射获取父类实现类的泛型，即本例子的customer泛型！ // 获取BaseDao的子类继承父类中的泛型！ // clazz为非静态，这里只能使用非静态代码块！ // 解释：此处this指的是创建对象时的类，即当前类的实现类CustomerDaoImpl！ // 代码块写在父类Dao中，可以动态的通过反射获取泛型，而无需在子类中进行重复创建！ { // 1. 获取当前对象的父类的泛型！ Type genericSuperclass = this.getClass().getGenericSuperclass(); // 2. 转换为带参数泛型！ ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass; // 3. 获取泛型参数 Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); // 4. 获取第一个参数，即customer! clazz = (Class&lt;T&gt;) actualTypeArguments[0]; } /** * 1. 考虑事务操作的通用增删改！ * * @param conn Connection * @param sql String * @param args Object */ public void update(Connection conn, String sql, Object ...args) { PreparedStatement ps = null; try { // 1. 预编译sql语句，返回PrepareStatement实例 ps = conn.prepareStatement(sql); // 2. 填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 3. 执行操作 ps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { // 5. 资源关闭（以防关闭连接导致自动提交，传入null） JDBCUtils.closeResource(null, ps); } } /** * 2、考虑事务操作的通用查询！ ----解决返回一条数据！ * * 此时不是泛型方法，去掉泛型方法声明，去掉class参数！ * * @param sql String * @param args Object * @return T */ public T getInstance(Connection conn, String sql, Object ...args){ PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); // 获取结果集的元数据！ ResultSetMetaData metaData = rs.getMetaData(); // 通过结果集的元数据获取列数！ int columnCount = metaData.getColumnCount(); if(rs.next()){ T t = clazz.getDeclaredConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { // 获取到每一列的值 Object columnValue = rs.getObject(i + 1); // 获取到每一列的别名或别名！（建议） String columnLabel = metaData.getColumnLabel(i + 1); // 使用反射设置值，给customer指定的属性columnLabel，赋值为columnValue Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnValue); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, ps, rs); } return null; } /** * 3、考虑事务操作的通用查询！---解决多条数据返回！ * * 此时不是泛型方法，去掉泛型方法声明，去掉class参数！ * * @param sql String * @param args Object * @return List&lt;T&gt; */ public List&lt;T&gt; getList(Connection conn, String sql, Object ...args){ PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtils.getConnection(); ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); // 获取结果集的元数据！ ResultSetMetaData metaData = rs.getMetaData(); // 通过结果集的元数据获取列数！ int columnCount = metaData.getColumnCount(); // 创建List集合 ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); while(rs.next()){ T t = clazz.getDeclaredConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { // 获取到每一列的值 Object columnValue = rs.getObject(i + 1); // 获取到每一列的别名或别名！（建议） String columnLabel = metaData.getColumnLabel(i + 1); // 使用反射设置值，给customer指定的属性columnLabel，赋值为columnValue Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnValue); } list.add(t); } return list; } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(null, ps, rs); } return null; } /** * 4. 考虑特殊值返回的操作（例如分组函数） * * @param conn Connection * @param sql String * @param args Object * @param &lt;E&gt; 泛型方法 * @return E */ public &lt;E&gt; E getValue(Connection conn, String sql, Object ...args){ PreparedStatement ps = null; ResultSet rs = null; try { ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); if(rs.next()){ return (E) rs.getObject(1); } } catch (SQLException throwables) { throwables.printStackTrace(); } finally { JDBCUtils.closeResource(null, ps, rs); } return null; }} 3、CustomerDao实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 再一步优化！ * * 该接口用于规范customers表的通用操作！ * * @author ITNXD * @create 2021-03-02 22:57 */public interface CustomerDAO { /** * 通过传入的Customers中的id插入数据！ * @param conn Connection * @param cust Customers */ void insert(Connection conn, Customers cust); /** * 通过传入的Customers中的id更新数据！ * @param conn Connection * @param cust Customers */ void update(Connection conn, Customers cust); /** * 通过传入的id删除数据！ * @param conn Connection * @param id int */ void deleteById(Connection conn, int id); /** * 通过传入的id获取Customer! * @param conn Connection * @param id int */ Customers getCustomerById(Connection conn, int id); /** * 获取表中所有数据构成的集合！ * @param conn Connection * @return List */ List&lt;Customers&gt; getAll(Connection conn); /** * 获取表中的数据项总数！ * @param conn Connection * @return long */ long getCount(Connection conn); /** * 获取最大生日日期返回！ * @param conn Connection * @return Date */ Date getMaxBirth(Connection conn);} 4、CustomerDaoImpl实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CustomerDAOImpl extends BaseDao&lt;Customers&gt; implements CustomerDAO { @Override public void insert(Connection conn, Customers cust) { String sql = \"insert into customers(name, email, birth) values(?,?,?)\"; update(conn, sql, cust.getName(), cust.getEmail(), cust.getbirth()); } @Override public void update(Connection conn, Customers cust) { String sql = \"update customers set name=?,email=?,birth=? where id = ?\"; update(conn, sql, cust.getName(), cust.getEmail(), cust.getbirth(), cust.getId()); } @Override public void deleteById(Connection conn, int id) { String sql = \"delete from customers where id = ?\"; update(conn, sql, id); } @Override public Customers getCustomerById(Connection conn, int id) { String sql = \"select id, name, email, birth from customers where id = ?\"; // 优化，customer实现类操作customer，所以应该无需传入customer.class// return getInstance(conn, Customers.class, sql, id); return getInstance(conn, sql, id); } @Override public List&lt;Customers&gt; getAll(Connection conn) { String sql = \"select id, name, email, birth from customers\"; // 优化，customer实现类操作customer，所以应该无需传入customer.class// return getList(conn, Customers.class, sql); return getList(conn, sql); } @Override public long getCount(Connection conn) { String sql = \"select count(*) from customers\"; return getValue(conn, sql); } @Override public Date getMaxBirth(Connection conn) { String sql = \"select Max(birth) from customers\"; return getValue(conn, sql); }} 5、测试该模块体系 IDEA中快速生成测试：要测试的类上右go to -&gt; test选择要测试方法和放在哪个包下就行！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * 测试CustomerDAOImpl类！ * * 快速生成测试：要测试的类上右键go to -&gt; test 选择要测试方法和放在哪个包下就行！ * * @author ITNXD * @create 2021-03-03 9:50 */class CustomerDAOImplTest { private CustomerDAOImpl dao = new CustomerDAOImpl(); @Test void insert() { Connection conn = null; try { conn = JDBCUtils.getConnection(); Customers cust = new Customers(1, \"牛逼\", \"nb@gmail.com\", new Date(System.currentTimeMillis())); dao.insert(conn, cust); System.out.println(\"添加成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } } @Test void update() { Connection conn = null; try { conn = JDBCUtils.getConnection(); Customers cust = new Customers(1, \"牛逼\", \"nb@gmail.com\", new Date(System.currentTimeMillis())); dao.update(conn, cust); System.out.println(\"更新成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } } @Test void deleteById() { Connection conn = null; try { conn = JDBCUtils.getConnection(); dao.deleteById(conn, 1); System.out.println(\"删除成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } } @Test void getCustomerById() { Connection conn = null; try { conn = JDBCUtils.getConnection(); Customers cust = dao.getCustomerById(conn, 2); System.out.println(cust); System.out.println(\"获取成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } } @Test void getAll() { Connection conn = null; try { conn = JDBCUtils.getConnection(); List&lt;Customers&gt; list = dao.getAll(conn); list.forEach(System.out::println); System.out.println(\"获取成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } } @Test void getCount() { Connection conn = null; try { conn = JDBCUtils.getConnection(); long count = dao.getCount(conn); System.out.println(count); System.out.println(\"获取成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } } @Test void getMaxBirth() { Connection conn = null; try { conn = JDBCUtils.getConnection(); Date birth = dao.getMaxBirth(conn); System.out.println(birth); System.out.println(\"获取成功\"); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } }} 八、数据库连接池1、数据库连接池技术的优点 类似于线程池，提高效率！ 1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 2、多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 BoneCP 是一个开源组织提供的数据库连接池，速度快 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 3、C3P0 需要导入：c3p0-0.9.1.2.jar开源包 123456789101112131415161718192021222324252627282930313233343536373839/* 方式一：*/@Testpublic void test1() throws Exception { // 从doc目录下的文档找到复制过来！ // 获取C3P0数据库连接池： ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass( \"com.mysql.cj.jdbc.Driver\" ); //loads the jdbc driver cpds.setJdbcUrl( \"jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true\" ); cpds.setUser(\"root\"); cpds.setPassword(\"xxx\"); // 通过设置相关参数对数据库连接池进行管理： // 设置初始数据库连接池连接数： cpds.setInitialPoolSize(10); Connection conn = cpds.getConnection(); System.out.println(conn); // 销毁C3P0数据库连接池： // 一般不进行销毁！ DataSources.destroy(cpds);}// 方式二：使用配置文件!/* 1. 使用properties文件：c3p0.properties 2. 使用xml文件配置：c3p0-config.xml 文件内容参考c3p0包下的文档例子！（推荐） 注意：都在src下 注意：idea文件创建xml：https://www.cnblogs.com/lvchengda/p/12620098.html */@Testpublic void test2() throws SQLException { // 参数为xml文件中自定义的named-config ComboPooledDataSource cpds = new ComboPooledDataSource(\"myC3p0\"); Connection conn = cpds.getConnection(); System.out.println(conn);} c3p0-config.xml文件： 注意事项： 所有的name命名都为小驼峰命名 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;c3p0-config&gt;&lt;!-- 注意：name命名为小驼峰命名!--&gt;&lt;!-- 注意：name命名为小驼峰命名!--&gt;&lt;!-- 注意：name命名为小驼峰命名!--&gt;&lt;!-- 注意：name命名为小驼峰命名!--&gt;&lt;!-- 配置命名：随意--&gt; &lt;named-config name=\"myC3p0\"&gt; &lt;!--提供获取连接的四个基本参数！--&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;!--如果为默认的：localhost:3306 则可省略--&gt;&lt;!-- &lt;property name=\"JdbcUrl\"&gt;jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&lt;/property&gt;--&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql:///test?rewriteBatchedStatements=true&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;xxx&lt;/property&gt;&lt;!-- 进行数据库连接池管理的基本信息！--&gt;&lt;!-- 当数据库连接池连接数不够时c3p0一次性向数据库服务器申请的连接数！--&gt; &lt;property name=\"acquireIncrement\"&gt;50&lt;/property&gt;&lt;!-- c3p0数据库连接池初始化的连接数！--&gt; &lt;property name=\"initialPoolSize\"&gt;10&lt;/property&gt;&lt;!-- c3p0数据库连接池维护的最少连接数！--&gt; &lt;property name=\"minPoolSize\"&gt;10&lt;/property&gt;&lt;!-- c3p0数据库连接池维护的最多连接数！--&gt; &lt;property name=\"maxPoolSize\"&gt;1000&lt;/property&gt;&lt;!-- c3p0数据库连接池最多维护的Statement个数！--&gt; &lt;property name=\"maxStatements\"&gt;50&lt;/property&gt;&lt;!-- 每个连接最多可使用的Statement数！--&gt; &lt;property name=\"maxStatementsPerConnection\"&gt;2&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 4、DBCP 需要导入： commons-dbcp-1.4.jar：连接池的实现 ``commons-pool-1.5.5.jar`：连接池的依赖库 Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 文档位置：E:commons-dbcp-1.4\\apidocs\\index.html 方式一： */@Testpublic void test1() throws SQLException { // 创建DBCP数据库连接池 BasicDataSource sources = new BasicDataSource(); // 设置基本信息： sources.setDriverClassName(\"com.mysql.cj.jdbc.Driver\"); sources.setUrl(\"jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true\"); sources.setUsername(\"root\"); sources.setPassword(\"xxx\"); // 设置其他连接池相关属性！ // E:\\Java学习\\尚硅谷Java\\1、JavaSE+JavaWeb\\4、尚硅谷_宋红康_JDBC核心技术(2019新版)\\3-资料\\2-驱动\\03-数据库连接池驱动\\dbcp.txt sources.setInitialSize(10); sources.setMaxActive(10); Connection conn = sources.getConnection(); System.out.println(conn);}// 方式二：使用配置文件：(推荐)@Testpublic void test2() throws Exception { Properties properties = new Properties(); // 方式一：默认为src下： // InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"dbcp.properties\"); // 方式二：默认为当前项目下，所以要转到src下： FileInputStream is = new FileInputStream(\"src/dbcp.properties\"); properties.load(is); DataSource source = BasicDataSourceFactory.createDataSource(properties); Connection conn = source.getConnection(); System.out.println(conn);} dbcp.properties文件： 123456driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=xxxinitialSize=10 可配置的连接池属性： 属性 默认值 说明 initialSize 0 连接池启动时创建的初始化连接数量 maxActive 8 连接池中可同时连接的最大的连接数 maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 poolPreparedStatements false 开启池的Statement是否prepared maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数 minEvictableIdleTimeMillis 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间 removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接 removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 5、Druid（推荐） 又称为德鲁伊！ Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。 12345678910111213/* druid API文档：druid-1.1.10\\doc\\index.html */@Testpublic void test1() throws Exception{ Properties properties = new Properties(); InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"druid.properties\"); properties.load(is); DataSource source = DruidDataSourceFactory.createDataSource(properties); Connection conn = source.getConnection(); System.out.println(conn);} druid.properties文件： 1234567driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=trueusername=rootpassword=xxxinitialSize=10maxActive=20 详细配置参数： 配置 缺省 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this) url 连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 6、使用数据库连接池对JDBCUtils重构 JDBCUtils实现了数据库的连接和资源释放操作！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/** * 对JDBCUtils的重构！使用数据库连接池！ * * @author ITNXD * @create 2021-03-03 15:24 */public class JDBCUtils { /** * 获取数据库的连接！（最基础） * * @return Connection * @throws Exception */ public static Connection getConnection() throws Exception{ // 1. 读取配置文件的四个基本信息 InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties properties = new Properties(); properties.load(is); String user = properties.getProperty(\"user\"); String password = properties.getProperty(\"password\"); String url = properties.getProperty(\"url\"); String driverClass = properties.getProperty(\"driverClass\"); // 2. 加载驱动 Class.forName(driverClass); // 3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); return conn; } // 数据库连接池只需创建一个！ private static ComboPooledDataSource cpds = new ComboPooledDataSource(\"myC3p0\"); /** * 1.1 使用c3p0数据库连接池重构的getConnection()方法！ * * @return Connection * @throws SQLException 异常 */ public static Connection getConnection1() throws SQLException { Connection conn = cpds.getConnection(); return conn; } /** * 1.2 使用dbcp数据库连接池重构的getConnection()方法！ * * @return Connection * @throws Exception 异常 */ private static DataSource source; static{ try { Properties properties = new Properties(); // 方式一：默认为src下： // InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"dbcp.properties\"); // 方式二：默认为当前项目下，所以要转到src下： FileInputStream is = new FileInputStream(\"src/dbcp.properties\"); properties.load(is); DataSource source = BasicDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } public static Connection getConnection2() throws Exception { Connection conn = source.getConnection(); return conn; } /** * 1.3 使用druid数据库连接池重构的getConnection()方法！ * @return Connection * @throws Exception */ private static DataSource source1 = null; static{ try { Properties properties = new Properties(); InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"druid.properties\"); properties.load(is); source1 = DruidDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } public static Connection getConnection3() throws Exception{ Connection conn = source1.getConnection(); return conn; } /** * 2. 关闭连接和 Statement的操作！ * * @param conn Connection * @param ps Statement */ public static void closeResource(Connection conn, Statement ps){ try { if(ps != null) ps.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(conn != null) conn.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } } /** * 3. 资源关闭操作！ * * @param conn Connection * @param ps Statement * @param rs ResultSet */ public static void closeResource(Connection conn, Statement ps, ResultSet rs){ try { if(ps != null) ps.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(conn != null) conn.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } try { if(rs != null) rs.close(); } catch (SQLException throwables) { throwables.printStackTrace(); } }} 九、Apache-DBUtil实现CRUD操作 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装! 需要导入：commons-dbutils-1.3.jar开源包！ dbutils API文档：commons-dbutils-1.3\\apidocs\\index.html API介绍： org.apache.commons.dbutils.QueryRunner：提供数据库操作的一系列重载的update()和query()操作 org.apache.commons.dbutils.ResultSetHandler：此接口用于处理数据库查询操作得到的结果集。不同的结果集的情形，由其不同的子类来实现 工具类：org.apache.commons.dbutils.DbUtils 1、QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 public int update(Connection conn, String sql, Object... params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 插入 public &lt;T&gt; T insert(Connection conn,String sql,ResultSetHandler&lt;T&gt; rsh, Object... params) throws SQLException：只支持INSERT语句 批处理 public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public &amp;lt;T&amp;gt; T insertBatch(Connection conn,String sql,ResultSetHandler&amp;lt;T&amp;gt; rsh,Object[][] params)throws SQLException：只支持INSERT语句 查询 public Object query(Connection conn, String sql, ResultSetHandler rsh,Object... params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 123456789101112131415161718192021222324// dbutils API文档：commons-dbutils-1.3\\apidocs\\index.htmlpublic class QueryRunnerTest { // 测试增删改： @Test public void test1() { Connection conn = null; try { QueryRunner runner = new QueryRunner(); // 使用德鲁伊数据库连接池获取连接： conn = JDBCUtils.getConnection3(); String sql = \"insert into customers(name, email, birth) values(?,?,?)\"; int insertCount = runner.update(conn, sql, \"牛逼1\", \"nb1@gmail.com\", \"2021-3-3\"); System.out.println(insertCount); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); } }} 2、ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs) 接口的主要实现类： ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List ScalarHandler：查询单个值对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145// 测试查询1：/* BeanHander：是ResultSetHandler的实现类！用于封装表中一条记录！ */@Testpublic void testQuery1(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id, name, email, birth from customers where id = ?\"; BeanHandler&lt;Customers&gt; handler = new BeanHandler&lt;Customers&gt;(Customers.class); Customers customers = runner.query(conn, sql, handler, 20); System.out.println(customers); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); }}// 测试查询2：/* BeanListHandler：是ResultSetHandler的实现类！用于封装表中多条记录！ */@Testpublic void testQuery2(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id, name, email, birth from customers where id &lt; ?\"; BeanListHandler&lt;Customers&gt; handler = new BeanListHandler&lt;Customers&gt;(Customers.class); List&lt;Customers&gt; list = runner.query(conn, sql, handler, 20); list.forEach(System.out::println); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); }}// 测试查询3：/* MapHandler：是ResultSetHandler的实现类！对应表中一条记录！ 将字段和相应字段的值作为map中的key和value! */@Testpublic void testQuery3(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id, name, email, birth from customers where id = ?\"; MapHandler handler = new MapHandler(); Map&lt;String, Object&gt; map = runner.query(conn, sql, handler, 20); System.out.println(map); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); }}// 测试查询4：/* MapListHandler：是ResultSetHandler的实现类！对应表中多条记录！ 将字段和相应字段的值作为map中的key和value! */@Testpublic void testQuery4(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id, name, email, birth from customers where id &lt; ?\"; MapListHandler handler = new MapListHandler(); List&lt;Map&lt;String, Object&gt;&gt; list = runner.query(conn, sql, handler, 20); list.forEach(System.out::println); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); }}// 测试查询5：/* ScalarHandler：是ResultSetHandler的实现类！返回分组函数查询的结果！ 查询特殊值！ */@Testpublic void testQuery5(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select count(*) from customers\"; ScalarHandler handler = new ScalarHandler(); long count = (long) runner.query(conn, sql, handler); System.out.println(count); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); }}// 测试查询6：/* 使用ResultSetHandler实现自定义handler 查询特殊值！ */@Testpublic void testQuery6(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id, name, email, birth from customers where id = ?\"; // 自定义类实现：匿名内部类里实现重写方法！ ResultSetHandler&lt;Customers&gt; handler = new ResultSetHandler&lt;&gt;() { @Override public Customers handle(ResultSet rs) throws SQLException { if(rs.next()){ int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String email = rs.getString(\"email\"); Date birth = rs.getDate(\"birth\"); return new Customers(id, name, email, birth); } return null; } }; Customers cust = runner.query(conn, sql, handler, 7); System.out.println(cust); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null); }} 3、DbUtils工具类 DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 12345678910111213141516171819202122232425 /* 资源关闭操作：使用DBUtils库实现： */public static void closeResource1(Connection conn, Statement ps, ResultSet rs){ // 没啥意思的关闭操作！ // try { // DbUtils.close(conn); // } catch (SQLException throwables) { // throwables.printStackTrace(); // } // try { // DbUtils.close(ps); // } catch (SQLException throwables) { // throwables.printStackTrace(); // } // try { // DbUtils.close(rs); // } catch (SQLException throwables) { // throwables.printStackTrace(); // } // 这样一次性关闭并处理异常！ DbUtils.closeQuietly(conn, ps, rs);} 十、JDBC总结12345678910111213141516171819202122232425262728293031323334353637@Testpublic void testUpdateWithTx() { Connection conn = null; try { //1.获取连接的操作 //① 手写的连接：JDBCUtils.getConnection(); //② 使用数据库连接池：C3P0;DBCP;Druid conn.setAutoCommit(false); //2.对数据表进行一系列CRUD操作 //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0) //version2.0的增删改public void update(Connection conn,String sql,Object ... args){} //version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args){} //② 使用dbutils提供的jar包中提供的QueryRunner类 //提交数据 conn.commit(); } catch (Exception e) { e.printStackTrace(); try { //回滚数据 conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } }finally{ //3.关闭连接等操作 //① JDBCUtils.closeResource(); //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://www.itnxd.cn/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://www.itnxd.cn/tags/JDBC/"}],"author":"ITNXD"},{"title":"再学MySql之使用大总结","slug":"再学MySql之使用大总结","date":"2021-02-22T03:58:51.000Z","updated":"2021-02-23T06:35:09.210Z","comments":true,"path":"posts/30836.html","link":"","permalink":"https://www.itnxd.cn/posts/30836.html","excerpt":"","text":"一、DQL语言 DQL(Data Query Language)：数据查询语言，用于查询！ 1、基础查询1.1、语法 查询列表可以是：表中的字段、常量值、表达式、函数 查询的结果是一个虚拟的表格 SELECT *代表查询该表全部字段 查询字符型和日期型的常量值必须用单引号引起来，数值型不需要 1SELECT 查询列表 FROM 表名; 1.2、别名12SELECT xxx 别名 FROM 表名;SELECT xxx AS 别名 FROM 表名; 1.3、去重1SELECT DISTINCT xxx FROM 表名; 1.4、关于+号 仅有运算符的功能！ select 数值+数值：直接运算 select 字符+数值：先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算 select null+值：结果都为null 1.5、几个函数 contact(xxx,xxx,xxx ...)：字符串拼接 ifnull(expr1, expr2)：判断expr1是否为null，如果为null返回expr2，否则返回expr1 isnull(xxx)：判断该字段值是否为null，是返回1，否则返回0 2、条件查询2.1、语法123select 查询列表from 表名where 筛选条件; 2.2、运算符 条件运算符：&gt;、&lt;、=、!=、&lt;&gt;、&gt;=、&lt;= 逻辑运算符：and or not 模糊查询关键字： like：一般搭配通配符使用，可以判断字符型或数值型。 通配符：%任意多个字符，_任意单个字符 若匹配_ 或 %则需要使用转移字符\\，或使用escape自定义转义字符 between xxx and xxx：在两范围之间，包含临界值 in(xxx, xxx ...)： in列表的值类型必须一致或兼容 in列表中不支持通配符 is null：=或&lt;&gt;不能用于判断null值，is null或is not null可以判断null值 is not null：略 安全等于&lt;=&gt;：可以判断可判断null和普通数值型，由于长得模棱两可，可读性低，一般不用 123SELECT last_nameFROM employeesWHERE last_name LIKE '_$_%' ESCAPE '$'; 3、排序查询3.1、语法1234select 查询列表from 表名【where 筛选条件】order by 排序的字段或表达式; 3.2、注意点 asc代表的是升序，可以省略。desc代表的是降序 order by子句可以支持 单个字段、别名、表达式、函数、多个字段 order by子句在一般放在查询语句的最后面，除了limit子句 4、常见函数 sql语言中索引从1开始！ 1、字符函数 我之前的教程！点击这里！ concat(exp1, exp2, exp3 …): 字符串连接 substr(str1, int): 截取从int位置开始之后str1剩余的所有字符（索引从1开始） substr(str1, int1, int2): 截取str1中从int1开始的int2个字符 upper(str)：变大写 lower(str)：变小写 replace(str1, str2, str3)：str1中的所有str2被替换成了str3 length(str)：获取字节长度（一个汉字是三个字节） trim(str): 去前后空格 (不光去空格 ) SELECT TRIM('aa' FROM 'aaa哈哈哈aaa')：返回a哈哈哈a lpad(str1, int, str2)：左填充，结果的长度为int，str1长度若不够int，将str2填充到str1左侧，直到长度为 int，如果str1长度大于int，则从左往右取int个输出，int不是指字节，指字符 rpad(str1, int, str2)：右填充 instr(str1, str2): 获取str1中第一次出现str2的索引值，如果找不到返回0 2、数学函数 我之前的教程！点击这里！ ceil(x): 向上取整 floor(x)：向下取整 round(x, [d])：四舍五入，d代表保留小数位数 mod(n, m)：取模 truncate(x, d): 截断，将数值保留int位小数，剩余尾数截断 rand(): 获取随机数，返回0-1之间的小数 3、日期函数 我之前的教程！点击这里！ 4、其他函数 version(): 当前数据库服务器的版本 database(): 当前打开的数据库 user(): 当前用户 password('字符’)：返回该字符的密码形式，新版mysql已不支持` md5(‘字符’): 返回该字符的md5加密形式 5、流程控制函数 if(条件表达式，表达式1，表达式2)：类似三元运算符 可以作为表达式放在任何位置 case情况1：类似于switch case，else省略，若都不匹配，则返回null 可以放在任何位置： 如果放在begin end 外面，作为表达式结合着其他语句使用 如果放在begin end 里面，一般作为独立的语句使用 123456case 表达式when 常量1 then 要显示的值1when 常量2 then 要显示的值2...else 要显示的值n（else可省略）end as 别名 case情况2：类似于if else 123456case when 条件1 then 要显示的值1when 条件2 then 要显示的值2...else 要显示的值n end as 别名 例如： 12345678SELECT salary 原始工资,department_id,CASE department_idWHEN 30 THEN salary*1.1WHEN 40 THEN salary*1.2WHEN 50 THEN salary*1.3ELSE salaryEND AS 新工资FROM employees; 6、分组函数 又叫做：聚合函数，统计函数，组函数 主要有：sum avg max min count 参数类型： sum, avg：适用于数值型，字符型也不报错，返回0 max, min：数值型，字符型 count：不为null的个数 注意：以上分组函数都忽略null值 可以和distinct搭配实现去重，eg：SELECT SUM(DISTINCT salary) FROM employees; 和分组函数一同查询的字段要求是group by后的字段，其他不行 count(*)：不忽略null，即返回总行数！ 如下写法，相当于加了一列： 12SELECT COUNT(1) FROM employees;SELECT COUNT('hh') FROM employee; 效率： myisam引擎：count(*)效率最高 innodb引擎：count(*)和count(1)差不多，比count(字段)高 5、分组查询5.1、语法 注意：查询的列表比较特殊，要求是分组函数和group by后出现的字段 123456select 查询列表from 表【where 筛选条件】group by 分组的字段(可为多个)【having 】【order by 排序的字段】; 举例： 123SELECT MAX(salary), job_idFROM employeesGROUP BY job_id; 5.2、having &amp; where where：对分组前结果进行筛选，放在group by之前 having：对分组后的结果进行筛选，放在group by之后，聚集函数一般放在having后！ 6、连接查询 又称为多表查询！防止未添加连接条件导致产生笛卡尔积现象！ 为方便操作，一般为表起别名！ 注意：为表起了别名，则查询的字段将不能再使用原表名进行限定，只能使用别名 6.1、分类 mysql虽然不支持全外连接，但可以使用UNION，左连接一次，右连接一次，再使用UNION合并来实现全外连接！ 年代分类 sql92：仅仅支持内连接（where后添加连接条件，已被弃用） sql99：全支持，但mysql不支持全连接！(on后添加连接条件) 功能分类 内连接（等值连接（交集）、非等值连接、自连接） 外连接（左外、右外、全外（mysql不支持）） 交叉连接 6.2、sql99语法1、内连接 12345678select 查询列表from 表1 别名【inner】 join 表2 别名 on 连接条件where 筛选条件group by 分组列表having 分组后的筛选order by 排序列表limit 子句; 2、左外&amp;右外连接 left join 左边的就是主表，right join右边的就是主表，full join 两边都是主表！ 12345678select 查询列表from 表1 别名left|right|full【outer】 join 表2 别名 on 连接条件where 筛选条件group by 分组列表having 分组后的筛选order by 排序列表limit 子句; 3、交叉连接 类似笛卡尔积！ 123select 查询列表from 表1 别名cross join 表2 别名; 6.3、总结 内连接和左右外连接 其他几种 7、子查询 可由后面的视图代替，提高可读性! 嵌套在其他语句内部的select语句称为子查询或内查询，外面如果为select语句，则此语句称为外查询或主查询！ 外面的语句可以是insert、update、delete、select等，一般select作为外面语句较多！ 7.1、分类 按出现位置 select后面：支持标量子查询 from后面：支持表子查询（子查询结果为一张虚拟表，要求必须起别名） where或having后面：支持标量子查询、列子查询 、行子查询 exists后面（相关子查询）：标量子查询、列子查询、行子查询、表子查询 按结果集行列 标量子查询（单行子查询）：结果集为一行一列 列子查询（多行子查询）：结果集为多行一列 行子查询：结果集为多行多列 表子查询：结果集为多行多列 exists(完整的查询语句)：结果为1或0，可用in代替！ 举例： 12345678910111213141516# 使用inSELECT department_nameFROM departments dWHERE d.`department_id` IN( SELECT department_id FROM employee;);# 使用existsSELECT department_nameFROM departments dWHERE EXISTS( SELECT * FROM employees e WHERE d.`department_id`=e.`department_id`); 7.2、注意点 子查询放在小括号内 子查询一般放在条件的右侧 子查询的执行优先于主查询，主查询用到了子查询的结果 标量子查询，一般搭配单行操作符使用 &lt; &gt; &gt;= &lt;= - &lt;&gt; 列子查询：一般搭配多行操作符使用 in \\ not in \\ any/some \\ all in 等于其中一个即可 not in 不是其中每个 any/some 比较其中一个即可 （可替换为max,min） all 比较所有值 （可替换为max,min） 列子查询举例： 1234567891011121314151617181920212223242526272829303132333435案例1：返回location_id是1400或1700的部门中的所有员工姓名SELECT last_nameFROM employeesWHERE department_id IN( SELECT DISTINCT department_id FROM departments WHERE location_id IN(1400,1700));# 或SELECT last_nameFROM employeesWHERE department_id = ANY( SELECT DISTINCT department_id FROM departments WHERE location_id IN(1400,1700));案例2：返回location_id不是1400或1700的部门中的所有员工姓名SELECT last_nameFROM employeesWHERE department_id NOT IN( SELECT DISTINCT department_id FROM departments WHERE location_id IN(1400,1700));# 或SELECT last_nameFROM employeesWHERE department_id &lt;&gt; ALL( SELECT DISTINCT department_id FROM departments WHERE location_id IN(1400,1700)); 8、分页查询8.1、语法 offset：起始索引（起始索引从0开始，唯一一个从0开始的，其他都是1开始） size：显示条数 123456789select 查询列表from 表【join type join 表2on 连接条件where 筛选条件group by 分组字段having 分组后的筛选order by 排序的字段】limit 【offset,】size; 8.2、注意点 limit语句放在查询语句的最后 要显示的页数 page，每页的条目数size，limit (page-1)*size, size; 使用order by和limit组合，可以找到一个列中最大值、最小值 9、联合查询 多次查询合并！ 将一条比较复杂的查询语句拆分成多条语句！ 9.1、语法12345查询语句1union 【all】查询语句2union 【all】... 9.2、注意点 要求多条查询语句的查询列数必须一致 要求多条查询语句的查询的各列类型、顺序最好一致 union去重，union all包含重复项 10、查询总结 各大关键字的位置及其执行顺序！ 123456789select 查询列表 ⑦from 表1 别名 ①连接类型 join 表2 ②on 连接条件 ③where 筛选 ④group by 分组列表 ⑤having 筛选 ⑥order by排序列表 ⑧limit 起始条目索引，条目数; ⑨ 二、DML语言 DML(Data Manipulation Language)：数据操纵语言，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心！ 1、插入1.1、语法123两种方式：insert into 表名(字段名,...) values(值,...);insert into 表名 set 字段=值,字段=值,...; 1.2、区别和注意点 方式一只需保证对应一致即可 方式一支持插入多行,方式二不支持 方式一支持子查询，方式二不支持 不可以为null的列必须插入值，可以为null的列可以写或不写 省略列名，默认所有列，值和表列的顺序要一致。 12345678910# 方式一插入多行insert into 表名 values(值,...),values(值,...),...# 方式一子查询INSERT INTO beauty(id,NAME,phone)SELECT id,boyname,'1234567'FROM boys WHERE id&lt;3; 2、修改1.1、语法123456789# 修改单表update 表名 set 字段=值,字段=值 【where 筛选条件】;# 修改多表update 表1 别名 left|right|inner join 表2 别名 on 连接条件 set 字段=值,字段=值 【where 筛选条件】; 3、删除 可以使用delete和truncate！ 3.1、语法123456789# 单表删除delete from 表名 【where 筛选条件】【limit 条目数】;# 级联删除(多表删除)delete 别名1,别名2 from 表1 别名 inner|left|right join 表2 别名 on 连接条件【where 筛选条件】; 1truncate table 表名 3.2、delete &amp; truncate delete 可以加where 条件，truncate不能加 truncate删除，效率高一丢丢 假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始；而truncate删除后，再插入数据，自增长列的值从1开始。 truncate删除没有返回值，delete删除有返回值 truncate删除不能回滚，delete删除可以回滚. 三、DDL语言 DDL(Data Definition Language)：数据定义语言，处理库和表的管理及各种约束！以create、alter、drop三种指令为核心！ 1、库的管理1.1、创建库1create database 【if not exists】 库名【 character set 字符集名】; 1.2、修改库12345# 更改库名RENAME DATABASE 库名 TO 新库名;# 更改库的字符集ALTER DATABASE 库名 CHARACTER SET 字符集名; 1.3、删除库1drop database 【if exists】 库名; 2、表的管理2.1、创建表1234567create table 表名( 列名 列的类型【(长度) 约束】, 列名 列的类型【(长度) 约束】, 列名 列的类型【(长度) 约束】, ... 列名 列的类型【(长度) 约束】); 2.2、修改表1234567891011121314151617# 语法：alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;# 修改列名ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 列类型;# 修改列的类型或约束alter table 表名 modify column 列名 新类型 【新约束】;# 添加新列ALTER TABLE 表名 ADD COLUMN 列名 列类型 约束条件; # 删除列ALTER TABLE 表名 DROP COLUMN 列名;# 修改表名ALTER TABLE 表名 RENAME 【TO】 新表名; 2.3、删除表1drop table 【if exists】 表名; 2.4、复制表1、复制表的结构 1CREATE TABLE 新表名 LIKE 旧表; 2、复制表的结构以及数据 12create table 新表名 select 查询列表 from 旧表【where 筛选】; 3、数据类型3.1、分类 整型型：tinyint(1)、smallint(2)、mediumint(3)、int/integer(4)、bigint(8) 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值 如果不设置长度，会有默认的长度长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！ 小数型：float(M,D)浮点型 ：4字节，double(M,D)定点型： 8字节 M代表整数部位+小数部位的字符个数，D代表小数部位 如果超出范围，则报out or range异常，并且插入临界值 M和D都可以省略，但对于定点数，M默认为10，D默认为0 如果精度要求较高，则优先考虑使用定点数 字符型：char、varchar、binary(二进制)、varbinary(二进制)、enum(枚举)、set(集合)、text、blob(较大二进制) char：固定长度的字符，写法为char(M)，最大长度不能超过M，其中M可以省略，默认为1 varchar：可变长度的字符，写法为varchar(M)，最大长度不能超过M，其中M不可以省略 日期型：date、time、year、datetime(8字节，范围：1000—9999)、timestamp(4字节，范围：1970-2038) timestamp：比较容易受时区、语法模式、版本的影响，更能反映当前时区的真实时间 SET time_zone='+9:00'：可设置时区 小栗子： 12345678910111213141516171819CREATE TABLE tab_char( c1 ENUM('a','b','c'));INSERT INTO tab_char VALUES('a');INSERT INTO tab_char VALUES('b');INSERT INTO tab_char VALUES('c');INSERT INTO tab_char VALUES('A');SELECT * FROM tab_set;CREATE TABLE tab_set( s1 SET('a','b','c','d'));INSERT INTO tab_set VALUES('a');INSERT INTO tab_set VALUES('A,B');INSERT INTO tab_set VALUES('a,c,d'); 4、常见约束4.1、常见约束 NOT NULL：非空，该字段的值必填 UNIQUE：唯一，该字段的值不可重复 DEFAULT：默认，该字段的值不用手动插入有默认值 CHECK：检查，mysql不支持 PRIMARY KEY：主键，该字段的值不可重复并且非空 ，等同于unique + not null FOREIGN KEY：外键，该字段的值引用了另外的表的字段 4.2、主键 &amp; 唯一键 一个表至多有一个主键，但可以有多个唯一 主键不允许为空，唯一可以为空 注意：新版支持唯一多null 联合主键：PRIMARY KEY(xxx, xxx) ，索引会显示两个主键（二者为整体来决定） 联合唯一键：UNIQUE(seat, age)，类似！ 4.2、外键 外键写法：[constraint 约束名] foreign key(从表被约束的列) references 主表(主表被引用列) 用于限制两个表的关系，从表的字段值引用了主表的某字段值 外键列和主表的被引用列要求类型一致，意义一样，名称无要求 主表的被引用列要求是一个key（一般是主键或唯一键） 插入数据，先插入主表。删除数据，先删除从表 可以通过以下两种方式来删除主表的记录： 1、级联删除：删除主表该数据的同时将从表该数据也删除 注意：接下来使用delete删除时，主表删除谁则从表对应数据行也删除 12# 例子：ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE; 2、级联置空：删除主表该数据的同时将从表该数据也置空 注意：接下来使用delete删除时，主表删除谁则从表对应数据（使用主表外键的列）置空 12# 例子：ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL; 4.3、约束使用1、创建表时添加约束 列级约束：不可以设置约束名 只支持默认、非空、主键、唯一键 一个字段可写多个，顺序随意，空格隔开即可 表级约束：【constraint 约束名】 约束类型(字段名) 只支持主键、外键、唯一键 可选部分不写默认为字段名！ 对主键无效！ 注意：主键、外键、唯一键会自动生成索引。可使用SHOW INDEX FROM 表名查看索引！ 123456789101112131415161718192021222324# 列级约束CREATE TABLE stuinfo( id INT PRIMARY KEY,#主键 stuName VARCHAR(20) NOT NULL UNIQUE,#非空 gender CHAR(1) CHECK(gender='男' OR gender ='女'),#检查 seat INT UNIQUE,#唯一 age INT DEFAULT 18,#默认约束 majorId INT REFERENCES major(id)#外键);# 表级约束CREATE TABLE stuinfo( id INT, stuname VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT, CONSTRAINT pk PRIMARY KEY(id),#主键 主键名改了无效，一定是primary CONSTRAINT uq UNIQUE(seat),#唯一键 CONSTRAINT ck CHECK(gender ='男' OR gender = '女'),#检查 CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键); 2、修改表时添加或删除约束 2.1、非空 1234# 添加非空alter table 表名 modify column 字段名 字段类型 not null;# 删除非空alter table 表名 modify column 字段名 字段类型 ; 2.2、默认 1234# 添加默认alter table 表名 modify column 字段名 字段类型 default 值;# 删除默认alter table 表名 modify column 字段名 字段类型 ; 2.3、主键 1234# 添加主键alter table 表名 add【 constraint 约束名】 primary key(字段名);# 删除主键alter table 表名 drop primary key; 2.4、唯一 1234# 添加唯一alter table 表名 add【 constraint 约束名】 unique(字段名);# 删除唯一alter table 表名 drop index 索引名; 2.5、外键 1234# 添加外键alter table 表名 add【 constraint 约束名】 foreign key(字段名) references 主表（被引用列）;# 删除外键alter table 表名 drop foreign key 约束名; 3、通用或建议写法 1234567891011121314151617# 语法CREATE TABLE 表名( 字段名 字段类型 列级约束, 字段名 字段类型, 表级约束);# 例子CREATE TABLE IF NOT EXISTS stuinfo( id INT PRIMARY KEY, stuname VARCHAR(20), sex CHAR(1), age INT DEFAULT 18, seat INT UNIQUE, majorid INT, CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)); 4.4、自增长列 不用手动插入值，可以自动提供序列值，默认从1开始，步长为1！ 1、注意点 一个表至多有一个自增长列 自增长列只能支持数值型 自增长列必须为一个key（主键、唯一键、外键） 2、更改默认起始值和步长 对于更改起始值：也可以在第一次插入时指定该值，则之后自增就以该值开始！ 注意：使用set设置变量，影响范围为当前会话，可以添加global|session修改为所有会话，永久改变，只能修改配置文件！ 1234# 更改起始值SET auto_increment_offset=值;# 更改步长set auto_increment_increment=值; 3、创建表时设置自增长列 自增长列赋值可以为null，还是自增！也可在插入时不插入该列！ 1234create table 表( 字段名 字段类型 约束 auto_increment, ...); 4、修改表时设置自增长列 1alter table 表 modify column 字段名 字段类型 约束 auto_increment; 5、删除自增长列 1alter table 表 modify column 字段名 字段类型 约束 ; 4.5、索引 以前写的教程，点击这里查看！ 四、DCL语言 DCL(Data Control Language)：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括grant、revoke等。 总链接：数据库教程之字符集.安全管理.维护，之前写的教程，点击这里！ 字符集和校对顺序，点击这里！ 安全管理，用户管理，访问控制，点击这里！ 数据库维护，备份，日志，点击这里！ 改善性能，mysql使用建议，点击这里！ 五、TCL语言 TCP(Transaction Control Language)：事务控制语言，处理事务及使用隔离级别解决并发问题！ 1、事务 事务：一条或多条sql语句组成一个执行单位，一组sql语句要么都执行要么都不执行，把多条语句作为一个整体进行操作的功能，被称为数据库事务！ 1.1、事务的ACID四个特性A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行； C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100； I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离； D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。 1.2、事务的创建 隐式事务：事务没有明显的开启和结束的标记 显示事务：事务具有明显的开启和结束的标记，前提：必须先设置自动提交功能为禁用 12345678910111213set autocommit=0;# 步骤1：开启事务set autocommit=0;【start transaction;】# 步骤2：编写事务中的sql语句(select insert update delete)语句1;语句2;...# 步骤3：结束事务commit;提交事务rollback;回滚事务 1.3、使用保留点savepoint12345678SET autocommit=0;START TRANSACTION;DELETE FROM account WHERE id=25;SAVEPOINT a;#设置保存点DELETE FROM account WHERE id=28;ROLLBACK TO a;#回滚到保存点SELECT * FROM account; 2、隔离级别 我之前写的教程更加详细：隔离级别，点击这里！ 2.1、注意点 serializable：效率低，类似于java多线程的锁，同一时刻只能有一个事务操作 oracle支持两种：serializable \\ read committed 2.2、默认隔离级别 mysql（如果使用InnoDB）中默认 第三个隔离级别 repeatable read oracle中默认第二个隔离级别 read committed 2.3、查看隔离级别1234# 旧版使用，新版本无法使用select @@tx_isolation; # 8.0版本改为：select @@transaction_isolation; 2.4、设置隔离级别1set session|global transaction isolation level 隔离级别; 在变量章节详细讲解！ session ：当前事务（可选，不写则不会马上生效） global：全局，一般设置后需重启mysql 六、视图 mysql5.1版本出现的新特性，本身是一个虚拟表，它的数据来自于表，通过执行时动态生成。只保存了sql逻辑，不保存查询结果！ 简化sql语句，提高了sql的重用性 保护基表的数据，提高了安全性(即封装性，将子查询封装) 1、视图和表对比 表保存数据，视图仅保存逻辑语句 视图一般用于查询，表一般用于增删改查 2、创建视图 使用：可以将视图名称当做表名使用即可！ 123# 语法：create view 视图名as 查询语句; 3、修改视图1234567# 方式一：存在则修改，不存在则创建create or replace view 视图名as 查询语句;# 方式二alter view 视图名as 查询语句; 4、删除视图1drop view 视图名,视图名,...; 5、查看视图12345# 视图结构DESC myv3;# 显示视图创建过程SHOW CREATE VIEW myv3; 6、更新视图 和表的操作一致，insert, update, delete！ 以下视图不允许更新： 包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all join 常量视图 where后的子查询用到了from中的表 用到了不可更新的视图 七、变量 global：所有会话（当前mysql所有连接，重启失效） session：默认值，当前会话 永久生效：修改配置文件 1、系统变量 分类： 全局变量 会话变量 1.1、查看所有系统变量1show global|【session】variables; 1.2、查看满足条件的部分系统变量1show global|【session】 variables like '%char%'; 1.3、查看指定的系统变量的值1select @@global|【session】系统变量名; 1.4、为某个系统变量赋值1234# 方式一：set global|【session】系统变量名=值;# 方式二：set @@global|【session】系统变量名=值; 2、自定义变量 分类： 用户变量 局部变量 2.1、用户变量 作用域：针对于当前连接（会话）生效 位置：begin end里面，也可以放在外面 注意：一般添加@ 123456789101112131415# 声明并赋值：推荐使用第二种（防止=歧义）set @变量名=值; #或set @变量名:=值; #或select @变量名:=值;# 更新值# 方式一：set @变量名=值; #或set @变量名:=值; #或select @变量名:=值;# 方式二：select xx into @变量名 from 表;# 查询select @变量名; 2.2、局部变量 作用域：仅仅在定义它的begin end中有效 位置：只能放在begin end中，而且只能放在第一句 注意：一般不添加@ 12345678910111213# 声明declare 变量名 类型 【default 值】;# 赋值或更新# 方式一：set 变量名=值; #或set 变量名:=值; #或select @变量名:=值;# 方式二：select xx into 变量名 from 表;# 查询select 变量名; 八、存储过程和函数 类似于方法！ 1、存储过程 视图是逻辑语句，存储过程是执行完的集合！一组预先编译好的SQL语句的集合，理解成批处理语句！ 存储过程无法被修改，只可以删除之后重建！ 1.1、创建 如果存储过程体仅仅只有一句话，begin end可以省略。 存储过程体中的每条sql语句的结尾要求必须加分号。 需要使用分隔符结束！ 123456DELIMITER $CREATE PROCEDURE 存储过程名(参数模式 参数名 参数类型, ...)BEGIN 存储过程体（一组合法的SQL语句）; ...END$ 参数模式： in：该参数需要调用方传入值（默认，可省略，但不建议） out：该参数可以作为返回值 inout：该参数既需要传入值，又可以返回值 几个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#1.空参列表#案例：插入到admin表中五条记录DELIMITER $CREATE PROCEDURE myp1()BEGIN INSERT INTO admin(username,`password`) VALUES('john1','0000'),('lily','0000'),('rose','0000'),('jack','0000'),('tom','0000');END $#调用：CALL myp1()$#2.创建带in模式参数的存储过程#案例：创建存储过程实现 根据女神名，查询对应的男神信息CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))BEGIN SELECT bo.* FROM boys bo RIGHT JOIN beauty b ON bo.id = b.boyfriend_id WHERE b.name=beautyName;END $#调用CALL myp2('柳岩')$#3.创建out 模式参数的存储过程#案例：根据输入的女神名，返回对应的男神名和魅力值CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) BEGIN SELECT boys.boyname ,boys.usercp INTO boyname,usercp FROM boys RIGHT JOIN beauty b ON b.boyfriend_id = boys.id WHERE b.name=beautyName ;END $#调用CALL myp7('小昭',@name,@cp)$SELECT @name,@cp$#4.创建带inout模式参数的存储过程#案例1：传入a和b两个值，最终a和b都翻倍并返回CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)BEGIN SET a=a*2; SET b=b*2;END $#调用SET @m=10$SET @n=20$CALL myp8(@m,@n)$SELECT @m,@n$ 1.2、分隔符 防止遇到分号提前结束语句！ 结束标记一旦指定，则当前会话结束标记都应为该符号！ sqlyog有点bug，每次运行都必须得指定该分隔符，控制台没问题！ 123delimiter 结束标记delimiter $ 1.3、调用1234567891011121314call 存储过程名(实参列表)# 调用in模式的参数：call sp1（‘值’）;# 调用out模式的参数：set @name; call sp1(@name);select @name;# 调用inout模式的参数：set @name=值; call sp1(@name); select @name; 1.4、查看1show create procedure 存储过程名; 1.5、删除12# 只能一个个删除drop procedure 存储过程名; 2、函数2.1、函数与存储过程区别 存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新 函数：有且仅有1个返回，适合做处理数据后返回一个结果 2.2、创建 函数体中仅有一句话，则可以省略begin end 使用 delimiter语句设置结束标记 12345delimiter $CREATE FUNCTION 函数名(参数名 参数类型, ...) RETURNS 返回类型BEGIN 函数体END$ 几个例子： 12345678910111213141516171819202122232425#1.无参有返回#案例：返回公司的员工个数CREATE FUNCTION myf1() RETURNS INTBEGIN DECLARE c INT DEFAULT 0;#定义局部变量 SELECT COUNT(*) INTO c#赋值 FROM employees; RETURN c;END $SELECT myf1()$#2.有参有返回#案例1：根据员工名，返回它的工资CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLEBEGIN SET @sal=0;#定义用户变量 SELECT salary INTO @sal #赋值 FROM employees WHERE last_name = empName; RETURN @sal;END $SELECT myf2('k_ing') $ 2.3、调用1SELECT 函数名(参数列表); 2.4、查看1show create function 函数名; 2.5、删除1drop function 函数名； 九、流程控制结构1、分支结构 if函数和case结构看第一章的第四节的第五小结的流程控制函数！ 1.1、if结构 只能放在begin end中！ 123456# 语法：if 条件1 then 语句1;elseif 条件2 then 语句2;...else 语句n;end if; 例子： 12345678910111213#案例：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回DCREATE FUNCTION test_if(score FLOAT) RETURNS CHARBEGIN DECLARE ch CHAR DEFAULT 'A'; IF score&gt;90 THEN SET ch='A'; ELSEIF score&gt;80 THEN SET ch='B'; ELSEIF score&gt;60 THEN SET ch='C'; ELSE SET ch='D'; END IF; RETURN ch;END $SELECT test_if(87)$ 2、循环结构 位置：都只能放在begin end中 2.1、while123【名称:】while 循环条件 do 循环体end while 【名称】; 2.2、loop 类似死循环！ 123【名称：】loop 循环体end loop 【名称】; 2.3、repeat 类似do while！ 1234【名称:】repeat 循环体until 结束条件 end repeat 【名称】; 2.4、循环控制语句 leave：类似于break，用于跳出所在的循环 iterate：类似于continue，用于结束本次循环，继续下一次 几个例子： 12345678910111213141516171819202122232425262728293031#1.添加leave语句#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止CREATE PROCEDURE test_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 1; a:WHILE i&lt;=insertCount DO INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000'); IF i&gt;=20 THEN LEAVE a; END IF; SET i=i+1; END WHILE a;END $CALL test_while1(100)$#2.添加iterate语句#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次CREATE PROCEDURE test_while2(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 0; a:WHILE i&lt;=insertCount DO SET i=i+1; IF MOD(i,2)!=0 THEN ITERATE a; END IF; INSERT INTO admin(username,`password`) VALUES(CONCAT('xiaohua',i),'0000'); END WHILE a;END $CALL test_while2(100)$ 十、游标和触发器 总链接：数据库教程之游标及触发器，之前写的教程，点击这里! 游标 触发器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.itnxd.cn/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.itnxd.cn/tags/MySQL/"}],"author":"ITNXD"},{"title":"再学Java之单例、模板方法、动静态代理设计模式","slug":"再学Java之单例、模板方法、动静态代理设计模式","date":"2021-02-17T13:29:59.000Z","updated":"2021-02-21T15:15:38.427Z","comments":true,"path":"posts/22183.html","link":"","permalink":"https://www.itnxd.cn/posts/22183.html","excerpt":"","text":"一、设计模式之单例设计模式 设计模式： 设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。 常用设计模式 — 23种经典的设计模式 GOF 创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 单例设计模式： 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。 1、饿汉式实现 坏处：对象加载时间过长。 好处：饿汉式是线程安全的 123456789101112131415161718192021222324public class SingletonTest1 { public static void main(String[] args) { Bank bank1 = Bank.getInstance(); Bank bank2 = Bank.getInstance(); System.out.println(bank1 == bank2); // true }}class Bank{ // 1. 私有化类构造器 private Bank() { } // 2. 内部创建类对象 // 4. 要求此对象也声明为静态 private static Bank instance = new Bank(); // 3. 提供公共静态方法，返回类对象 public static Bank getInstance() { return instance; }} 2、懒汉式实现 好处：延迟对象的创建。 目前的写法坏处：线程不安全 12345678910111213141516171819202122232425262728public class SingletonTest2 { public static void main(String[] args) { Order order1 = Order.getInstance(); Order order2 = Order.getInstance(); System.out.println(order1 == order2); // true }}class Order{ //1.私化类的构造器 private Order(){ } //2.声明当前类对象，没初始化 //4.此对象也必须声明为static的 private static Order instance = null; //3.声明public、static的返回当前类对象的方法 public static Order getInstance(){ if(instance == null) { instance = new Order(); } return instance; }} 3、懒汉式线程安全实现1234567891011121314151617181920212223242526272829303132333435363738class Order1{ private Order1(){} private static Order1 instance = null; // 方式一：效率稍差 /*public static Order1 getInstance(){ synchronized (Order1.class) { if(instance == null) { instance = new Order1(); } return instance; } }*/ // 方式二：效率稍高 public static Order1 getInstance(){ if(instance == null){ synchronized (Order1.class) { if(instance == null) { instance = new Order1(); } } } return instance; } // synchronized 写到函数声明上也可 /*public static synchronized Order1 getInstance(){ if(instance == null) { instance = new Order1(); } return instance; }*/} 4、单例设计模式应用场景 网站的计数器，一般也是单例模式实现，否则难以同步。 应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。 Application 也是单例的典型应用 Windows的Task Manager (任务管理器)就是很典型的单例模式 Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 二、设计模式之模板方法设计模式 1、解决的问题 在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变 部分可以抽象出来，供不同子类实现。这就是一种模板模式。 2、模板方法应用模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有： 数据库访问的封装 Junit单元测试 JavaWeb的Servlet中关于doGet/doPost方法调用 Hibernate中模板程序 Spring中JDBCTemlate、HibernateTemplate等 3、代码实现12345678910111213141516171819202122232425262728293031323334353637383940abstract class Template{ //计算某段代码执行所需要花费的时间 public void spendTime(){ long start = System.currentTimeMillis(); this.code();//不确定的部分、易变的部分 long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start)); } public abstract void code();}// 模板方法实现抽象接口：class SubTemplate extends Template{ @Override public void code() { for(int i = 2;i &lt;= 1000;i++){ boolean isFlag = true; for(int j = 2;j &lt;= Math.sqrt(i);j++){ if(i % j == 0){ isFlag = false; break; } } if(isFlag){ System.out.println(i); } } }} 三、设计模式之静态代理设计模式 1、解决的问题代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。 2、静态代理的缺点 代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。 每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。 3、代码实现 代理类：通用的入口 被代理类：具体的某一个 1234567891011121314151617181920212223242526272829303132333435363738394041public class StaticProxyTest { public static void main(String[] args) { // 创建被代理类对象: NikeProxyClothFactory nike = new NikeProxyClothFactory(); // 创建代理类对象： ProxyClothFactory proxyClothFactory = new ProxyClothFactory(nike); // 使用代理类对象调用被代理类方法： proxyClothFactory.produceCloth(); }}interface ClothFactory{ void produceCloth();}// 代理类：class ProxyClothFactory implements ClothFactory{ // 用被代理类对象实例化： private ClothFactory clothFactory; public ProxyClothFactory(ClothFactory clothFactory) { this.clothFactory = clothFactory; } @Override public void produceCloth() { System.out.println(\"代理工厂做一些准备工作！\"); clothFactory.produceCloth(); System.out.println(\"代理工厂做一些后续工作！\"); }}// 被代理类：class NikeProxyClothFactory implements ClothFactory{ @Override public void produceCloth() { System.out.println(\"Nike工厂生产一批衣服！\"); }} 四、设计模式之动态代理设计模式 反射的应用！ 代理模式的原理： 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 1、需要解决的两个主要问题 如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。（通过Proxy.newProxyInstance()实现） 当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。(通过InvocationHandler接口的实现类及其方法invoke() 2、动态代理的特点动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。 3、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class DynamicProxyTest { public static void main(String[] args) { // 例子一： // 1. 通过被代理类动态创建一个代理类对象 // 体现多态，我拿接口去接收！ Human human = (Human) ProxyFactory.getProxyInstance(new SuperMan()); // 2. 通过该代理类对象调用方法，自动调用被代理类的同方法！ human.eat(\"apple\"); String belief = human.getBelief(); System.out.println(belief); System.out.println(\"=====================================\"); // 例子二：动态性的体现；创建静态代理中用过的衣服工厂的例子！ ClothFactory nike = (ClothFactory) ProxyFactory.getProxyInstance(new NikeProxyClothFactory()); nike.produceCloth(); // 至此：实现任何被代理类的动态代理！ }}interface Human{ String getBelief(); void eat(String food);}// 被代理类：class SuperMan implements Human{ @Override public String getBelief() { return \"I believe I can fly!\"; } @Override public void eat(String food) { System.out.println(\"超人喜欢吃\" + food); }}// 1. 专门生产代理类的工厂：解决问题一class ProxyFactory{ // 2. 调用此方法，返回一个代理类对象！ // obj：被代理类对象！ public static Object getProxyInstance(Object obj){ MyInvocationHandler handler = new MyInvocationHandler(); // 9. 通过MyInvocationHandler绑定当前被代理类对象！ handler.bind(obj); // 3.调用Proxy.newProxyInstance方法获取代理类对象 // 参数一：指明被代理类的classLoader // 参数二：指明被代理类实现的接口 // 6. 参数三：指明被代理类的InvocationHandler，即解决问题二！ return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler); }}// 4.class MyInvocationHandler implements InvocationHandler{ // 8. 创建被代理类对象： private Object obj; public void bind(Object obj){ this.obj = obj; } // 5. 当我们通过代理类对象，调用方法a时，会自动调用如下方法：invoke() @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 7. 通过第三步的参数传来的方法名、参数去调用被代理类的方法！ // 10. 通过第九步绑定的被代理类对象来调用该对象的method方法！ return method.invoke(obj, args); }} 4、AOP动态代理（Aspect Orient Programming） 使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理 这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异 1234567891011121314151617181920212223242526272829303132class HumanUtil{ public void method1(){ System.out.println(\"===================通用方法一=======================\"); } public void method2(){ System.out.println(\"===================通用方法二=======================\"); }}// 改造上面的该方法：class MyInvocationHandler1 implements InvocationHandler{ private Object obj; public void bind(Object obj){ this.obj = obj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { HumanUtil humanUtil = new HumanUtil(); humanUtil.method1(); Object returnVal = method.invoke(obj, args); humanUtil.method2(); return returnVal; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.itnxd.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"ITNXD"},{"title":"再学Java之StringBuffer、StringBuilder、枚举类、注解、集合和泛型","slug":"再学Java之StringBuffer、StringBuilder、枚举类、注解和集合、泛型","date":"2021-02-15T11:06:25.000Z","updated":"2021-02-17T14:43:14.771Z","comments":true,"path":"posts/54748.html","link":"","permalink":"https://www.itnxd.cn/posts/54748.html","excerpt":"","text":"一、StringBuffer VS StringBuilder 1、String、StringBuffer、StringBuilder三者的对比 String：不可变的字符序列，底层使用char[]存储。 StringBuffer：可变的字符序列，线程安全的，效率低。底层使用char[]存储。 StringBuilder：可变的字符序列，JDK5.0新增的，线程不安全的，效率高。底层使用char[]存储。 因此，他们的效率高低依次为：StringBuilder &gt; StringBuffer &gt; String 注意： JDK8之后的版本使用的是byte[]存储！ 2、使用建议只要不是多线程问题，操作共享数据，都使用新增的StringBuilder！ 3、StringBuffer、StringBuilder内存解析 二者在内存层面存储扩容方面几乎一致，这里以StringBuffer为例！ 3.1、先来看一下String的存储String底层使用private final存储！ 12String str = new String(); // char[] value = new char[0];String str1 = new String(\"abc\"); // char[] value = new char[]{'a','b','c'}; 3.2、StringBuffer 默认开辟长度为16的数组 若为有参构造器，则开辟参数的长度 + 16的数组 扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍 + 2，同时将原数组中的元素复制到新的数组中。 12345StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。System.out.println(sb1.length());//sb1.append('a');//value[0] = 'a';sb1.append('b');//value[1] = 'b';StringBuffer sb2 = new StringBuffer(\"abc\");//char[] value = new char[\"abc\".length() + 16]; 3.3、总结开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)，提高效率！ 二、枚举类 JDK5.0之前，自定义枚举类，JDK5.0之后，使用enum关键字！ 1、自定义枚举类1234567891011121314151617181920212223242526272829303132333435//1. 自定义枚举类class Season{ //1.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私化类的构造器,并给对象属性赋值 private Season(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } //3.提供当前枚举类的多个对象：public static final的 public static final Season SPRING = new Season(\"春天\",\"春暖花开\"); public static final Season SUMMER = new Season(\"夏天\",\"夏日炎炎\"); public static final Season AUTUMN = new Season(\"秋天\",\"秋高气爽\"); public static final Season WINTER = new Season(\"冬天\",\"冰天雪地\"); //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } //4.其他诉求2：提供toString() @Override public String toString() { return \"Season{\" + \"seasonName='\" + seasonName + '\\'' + \", seasonDesc='\" + seasonDesc + '\\'' + '}'; }} 2、使用enum关键字 enum类的主要方法： values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符 串必须是枚举类对象的名字。如不是，会有运行时异常：IllegalArgumentException。 toString()：返回当前枚举类对象常量的名称 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) { Season1 autumn = Season1.AUTUMN; // 默认实现了toString()，为常量名 System.out.println(autumn); // AUTUMN System.out.println(Season1.class.getSuperclass()); // class java.lang.Enum // 也可以重写： System.out.println(autumn); // Season{seasonName='秋天', seasonDesc='秋高气爽'} /*=============================================*/ //1. toString():返回枚举类对象的名称 System.out.println(autumn.toString()); // AUTUMN //2. values():返回所的枚举类对象构成的数组 Season1[] values = Season1.values(); for (int i = 0; i &lt; values.length; i++) { System.out.println(values[i]); } Thread.State[] values1 = Thread.State.values(); for (int i = 0; i &lt; values1.length; i++) { System.out.println(values1[i]); } //3. valueOf(String objName):返回枚举类中对象名是objName的对象。 //如果没objName的枚举类对象，则抛异常：IllegalArgumentException // Season1 autumn11 = Season1.valueOf(\"AUTUMN1\"); Season1 autumn1 = Season1.valueOf(\"AUTUMN\"); System.out.println(autumn1); // ======================= // 1. 每个对象都是相同的show Season1 summer = Season1.SUMMER; summer.show(); // 这是一个季节！ // 2. 每个对象都有自己的show Season1.SPRING.show(); Season1.SUMMER.show(); Season1.AUTUMN.show(); Season1.WINTER.show();} 使用enum定义枚举类之后，如何让枚举类对象分别实现接口： 实现接口，在枚举类中实现抽象方法 让枚举类对象分别实现接口中的抽象方法 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 2. 使用enumenum Season1 implements Info{ //1.提供当前枚举类的对象，多个对象之间用\",\"隔开，末尾对象\";\"结束 SPRING(\"春天\",\"春暖花开\"){ @Override public void show() { System.out.println(\"春天在哪里！\"); } }, SUMMER(\"夏天\",\"夏日炎炎\"){ @Override public void show() { System.out.println(\"夏天在哪里！\"); } }, AUTUMN(\"秋天\",\"秋高气爽\"){ @Override public void show() { System.out.println(\"秋天在哪里！\"); } }, WINTER(\"冬天\",\"冰天雪地\"){ @Override public void show() { System.out.println(\"冬天在哪里！\"); } }; //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; private Season1(String seasonName,String seasonDesc){ this.seasonName = seasonName; this.seasonDesc = seasonDesc; } //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() { return seasonName; } public String getSeasonDesc() { return seasonDesc; } //4.其他诉求1：提供toString() @Override public String toString() { return \"Season{\" + \"seasonName='\" + seasonName + '\\'' + \", seasonDesc='\" + seasonDesc + '\\'' + '}'; } @Override public void show() { System.out.println(\"这是一个季节！\"); }} 三、注解 JDK5.0 新增的功能！ 框架 = 注解 + 反射机制 + 设计模式 1、注解概述 Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 2、注解的作用 生成文档相关的注解 在编译时进行格式检查(JDK内置的几个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 跟踪代码依赖性，实现替代配置文件功能 12345678910111213141516@Testpublic void test1(){ // @Deprecated Date date = new Date(2021, 2, 3); // 灰色是一个未使用的警告 int i1 = 10; // 这样就变黑了，编译将不会再有警告 @SuppressWarnings(\"unused\") int i2 = 10; // 表示未使用和未使用泛型 @SuppressWarnings({\"unused\", \"rawtypes\"}) ArrayList arrayList = new ArrayList();} 3、自定义注解 参照@SuppressWarnings定义！ 注解声明为：@interface 内部定义成员，通常使用value表示 可以指定成员的默认值，使用default定义 如果自定义注解没成员，表明是一个标识作用。 说明： 如果注解有成员，在使用注解时，需要指明成员的值。 自定义注解必须配上注解的信息处理流程(使用反射)才意义。 自定义注解通常都会指明两个元注解：Retention、Target 123456789101112131415161718192021222324// 自定义注解@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE, TYPE_PARAMETER, TYPE_USE})@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation{ // 1. 可以没有成员变量，没有则表名是一个标识 // 2. 声明成员变量，可以使用default定义默认值 String value() default \"hello\"; // 3. 也可定义为数组，表示参数为多个// String[] value1();}@Testpublic void test2(){ // 自定义注解若有成员，必须显示赋值（default除外） @MyAnnotation(value = \"hi\") int n = 10; // 提供了默认值，可以不写值 @MyAnnotation int m = 10;} 4、JDK中的四种元注解 对现有的注解进行解释说明的注解！ 后两种不常用。前两种常用，一般自定义注解都要有后两种！ Retention：指定所修饰的 Annotation 的生命周期：SOURCE\\CLASS（默认行为)\\RUNTIME，只有声明为RUNTIME生命周期的注解，才能通过反射获取。 RetentionPolicy.SOURCE：在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注解 RetentionPolicy.CLASS：在class文件中有效（即class保留） ，当运行 Java 程序时, JVM不会保留注解。 这是默认值 RetentionPolicy.RUNTIME：在运行时有效（即运行时保留），当运行 Java 程序时, JVM会保留注解。程序可以通过反射获取该注解 Target：用于指定被修饰的 Annotation 能用于修饰哪些程序元素 Documented：表示所修饰的注解在被javadoc解析时，保留下来。 Inherited：被它修饰的 Annotation将具继承性。（解释：即父类使用了带有Inherited的注解，子类自动具有该注解） Target注解的课取值： 5、JDK8中的新注解5.1、可重复注解@Repeatable 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 1234567891011121314151617181920212223242526272829303132333435363738// JDK8之前实现方式：数组@interface MyAnnotation{ String value() default \"hello\";}@interface MyAnnotations{ MyAnnotation[] value();}// 使用@MyAnnotations({@MyAnnotation(value = \"aa\"), @MyAnnotation(value = \"bb\")})class Person{}/****************************************************************/// JDK8之中实现方式：@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE, TYPE_PARAMETER, TYPE_USE})@Retention(RetentionPolicy.RUNTIME)// 多一个该注解：@Repeatable(MyAnnotations.class)@interface MyAnnotation{ String value() default \"hello\";}@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE, TYPE_PARAMETER, TYPE_USE})@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotations{ MyAnnotation[] value();}// 使用：@MyAnnotation(value = \"aa\")@MyAnnotation(value = \"bb\")class Person{} 5.2、类型注解 在target的属性中加入该类型即可！ ElementType.TYPE_PARAMETER ：表示该注解能写在类型变量的声明语句中，如：泛型声明 ElementType.TYPE_USE ：表示该注解能写在使用类型的任何语句中。 1234567891011// 类型注解一：TYPE_PARAMETER 能写在类型变量的声明语句中，可以修饰泛型！// 在target的属性中加入该类型即可！class P&lt;@MyAnnotation T&gt;{ // 类型注解二：TYPE_USE 能写在使用类型的任何语句中！ // 在target的属性中加入该类型即可！ public void show()throws @MyAnnotation Exception{ int i = (@MyAnnotation int) 111L; ArrayList&lt;@MyAnnotation String&gt; list = new ArrayList&lt;&gt;(); }} 四、集合 集合概述： Collection：单列集合 List：存储序的、可重复的数据（JDK1.2） ArrayList：线程不安全的，效率高，底层使用Object[] elementData存储。（JDK1.2） LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高，底层使用双向链表存储。（JDK1.2） Vector：作为List接口的古老实现类，线程安全的，效率低，底层使用Object[] elementData存储。（JDK1.0） Set：存储无序的、不可重复的数据（JDK1.2） HashSet：线程不安全的，可以存储null值（JDK1.2） LinkedHashSet：HashSet的子类，HashSet基础上加了双链表，可按序遍历。对于频繁的插入、删除操作，使用此类效率比HashSet高。（JDK1.4） TreeSet：可以照添加对象的指定属性，进行排序。（JDK1.2） Map：双列数据，存储key-value对的数据（JDK1.2） HashMap：线程不安全的，效率高。可存储null的key和value（JDK1.2） LinkedHashMap：HashMap的子类，HashMap基础上加了双链表，可按序遍历。对于频繁的插入、删除操作，使用此类效率比HashMap高（JDK1.4） TreeMap：可按key进行自然排序或定制排序。（JDK1.2） Hashtable：作为古老的实现类，线程安全的，效率低，不能存储null的key和value。（JDK1.0） Properties：常用来处理配置文件。key和value都是String类型。（JDK1.0） 1、List源码分析1.1、ArrayList JDK7中的ArrayList的对象的创建类似于单例的饿汉式，而JDK8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。 JDK7中： ArrayList list = new ArrayList()：底层创建了长度是10的Object[]数组elementData 扩容：默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中 开发中建议：使用带参的构造器：ArrayList list = new ArrayList(int capacity) JDK8中： ArrayList list = new ArrayList()：底层Object[] elementData初始化为{}，并没创建长度为10的数组 第一次调用add()时，底层才创建了长度10的数组，并将数据添加到elementData[0] 1.2、LinkedList LinkedList list = new LinkedList()：内部声明了Node类型的first和last属性，默认值为null list.add(123)：将123封装到Node中，创建了Node对象。 其中Node静态内部类长这样： 体现了LinkedList的双向链表的说法！ 1234567891011private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; }} 1.3、Vector 在多线程问题中，即使vector是线程安全的，也不去用它，而去用Collections工具类的SynchronizedList方法去将ArrayList扔进去返回的就是线程安全的集合！ JDK7和JDK8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组 扩容方面：默认扩容为原来的数组长度的2倍。 2、Set源码分析 关于存储数据无序的、不可重复的说明： 无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。 不可重复性：保证添加的元素照equals()判断时，不能返回true即：相同的元素只能添加一个。 因此，HashSet和LinkedHashSet存储对象所在类的要求： 向Set（主要指：HashSet、LinkedHashSet）中添加的数据，其所在的类一定要重写hashCode()和equals() 重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码 重写两个方法的小技巧：对象中用作 equals()方法比较的 Field，都应该用来计算hashCode值。 Set接口中没额外定义新的方法，使用的都是Collection中声明过的方法！ 三个实现类底层都是以Map存储的，详细的请看下一节的Map源码分析！ 2.1、HashSet 七上八下存储： JDK 7 ：元素a放到数组中，指向原来的元素。 JDK 8 ：原来的元素在数组中，指向元素a HashSet元素添加过程： 我们向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置)，判断数组此位置上是否已经元素： 如果此位置上没其他元素，则元素a添加成功。 —&gt;情况1 如果此位置上其他元素b(或以链表形式存在的多个元素)，则比较元素a与元素b的hash值： 如果hash值不相同，则元素a添加成功。—&gt;情况2 如果hash值相同，进而需要调用元素a所在类的equals()方法： equals()返回true,元素a添加失败。 equals()返回false,则元素a添加成功。—&gt;情况3 HashSet底层实际是用HashMap存储的： 具体细节在下面Map源码分析中详解！ 12345private transient HashMap&lt;E,Object&gt; map;public HashSet() { map = new HashMap&lt;&gt;();} 2.2、LinkedHashSet 继承自HashSet，同样底层实际使用LinkedHashMap存储！ 再添加数据的同时，维护了两个变量存储前后数据位置，类似双链表方式维护！ 具体在HashMap中详细讲解！ 2.3、TreeSet 向TreeSet中添加的数据，要求是相同类的对象。 两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator） 底层仍然是使用的TreeMap存储 3、Map源码分析 Map中的key：无序的、不可重复的，使用Set存储所的key —&gt; key所在的类要重写equals()和hashCode() Map中的value：无序的、可重复的，使用Collection存储所的value —&gt;value所在的类要重写equals() 一个键值对：key-value构成了一个Entry对象。 Map中的entry：无序的、不可重复的，使用Set存储所的entry 3.1、HashMap JDK7中： HashMap map = new HashMap()： 在实例化以后，底层创建了长度是16的一维数组Entry[] table map.put(key1,value1)： 首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。 如果此位置上的数据为空，此时的key1-value1添加成功。 —- 情况1 如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值： 如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。—- 情况2 如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较： 如果equals()返回false:此时key1-value1添加成功。—- 情况3 如果equals()返回true:使用value1替换value2。 补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。 在不断的添加过程中，会涉及到扩容问题：当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。 JDK8中与之前的不同之处： new HashMap()：底层没创建一个长度为16的数组 JDK8底层的数组是：Node[],而非Entry[] 首次调用put()方法时，底层创建长度为16的数组 JDK7底层结构：数组+链表。jdk8底层结构：数组+链表+红黑树。 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素） 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。 HashMap底层典型属性的属性的说明： DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 DEFAULT_LOAD_FACTOR：HashMap的默认负载因子：0.75 threshold：扩容的临界值 = 容量 * 填充因子`：16 * 0.75 =&gt; 12 TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树，8 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量，64 UNTREEIFY_THRESHOLD ：Bucket中红黑树存储的Node小于该默认值，转化为链表 MIN_TREEIFY_CAPACITY ：桶中的Node被树化时最小的hash表容量。（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。） 负载因子（填充比）的作用： 负载因子的大小决定了HashMap的数据密度。 负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。 负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。 按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数 3.2、LinkedHashMap LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap. 区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node. 123456789101112131415161718192021static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; }}static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); }} 3.3、TreeMap 向TreeMap中添加key-value，要求key必须是由同一个类创建的对象！ 照key进行排序：自然排序 、定制排序 3.4、Properties 是Hashtable的子类常用来处理配置文件。key和value都是String类型！ 本测试不放到main中找不到配置文件！ 配置文件中文乱码：打开IDEA设置的file encoding 中的Properties的勾勾！并且删掉原配置文件重新新建！ 配置文件新建方式：选择Resource Bundle写入文件名回车即可！ 配置文件中不要有空格！ 123456789101112131415161718192021222324public static void main(String[] args){ FileInputStream fis = null; try { Properties pros = new Properties(); // 加载配置文件到流 fis = new FileInputStream(\"test.properties\"); pros.load(fis); String name = pros.getProperty(\"name\"); String password = pros.getProperty(\"password\"); System.out.println(name + \" \" + password); } catch (IOException e) { e.printStackTrace(); } finally { if(fis != null){ try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } }} 五、泛型 JDK5.0新增！ 1、泛型注意事项 泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass&lt;E&gt;(){} 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。 泛型不同的引用不能相互赋值：尽管在编译时ArrayList&lt;String&gt;和ArrayList&lt;Integer&gt;是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。 经验：泛型要使用一路都用。要不用，一路都不要用。 jdk1.7，泛型的简化操作：ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;&gt;(); 泛型的指定中不能使用基本数据类型，可以使用包装类替换 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。（静态方法在类创建时加载时，但此时还没有造对象，T并不清楚） 异常类不能是泛型的 try catch(T e)也不行！ 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity];参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型： 子类不保留父类的泛型：按需实现 没有类型 擦除 具体类型 子类保留父类的泛型：泛型子类 全部保留 部分保留 关于第10点的说明： 防止晕头转向，这里稍微总结一下：看每种情况后面的泛型！ 123456789101112131415161718192021222324252627282930313233class Father&lt;T1, T2&gt; {}// 子类不保留父类的泛型// 1)没有类型 擦除：&lt;Object,Object&gt;class Son1 extends Father {// 等价于class Son extends Father&lt;Object,Object&gt;{}// 2)具体类型：&lt;Integer, String&gt;class Son2 extends Father&lt;Integer, String&gt; {}// 子类保留父类的泛型 // 1)全部保留：&lt;任意类型1, 任意类型2&gt;class Son3&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; {}// 2)部分保留：&lt;Integer, 任意类型2&gt;class Son4&lt;T2&gt; extends Father&lt;Integer, T2&gt; {}//====================================================================================// 子类不保留父类的泛型// 1)没有类型 擦除：&lt;Object,Object&gt;class Son&lt;A, B&gt; extends Father{//等价于class Son extends Father&lt;Object,Object&gt;{}// 2)具体类型：默认为&lt;Integer, String&gt;，但子类泛型若指定，父类泛型失效class Son2&lt;A, B&gt; extends Father&lt;Integer, String&gt; {}// 子类保留父类的泛型// 1)全部保留：&lt;任意类型1, 任意类型2，任意类型3，任意类型4&gt;class Son3&lt;T1, T2, A, B&gt; extends Father&lt;T1, T2&gt; {}// 2)部分保留：&lt;Ingeter, 任意类型2，任意类型3，任意类型4&gt;class Son4&lt;T2, A, B&gt; extends Father&lt;Integer, T2&gt; {} 2、泛型方法 泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。 换句话说，泛型方法所属的类是不是泛型类都没关系。 泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。 2.1、格式1[ 访问权限] &lt; 泛型&gt; 型 返回类型 名 方法名([ 泛型标识 称 参数名称]) 抛出的异常 2.2、举例123456789101112131415161718// &lt;E&gt;：作用：表名E是一个泛型而不是一个类！public &lt;E&gt; List&lt;E&gt; copyArrayFromList(E[] arr){ ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); for(E e : arr){ list.add(e); } return list;}@Testpublic void test5(){ Person&lt;String&gt; p = new Person&lt;&gt;(); Integer[] integer = new Integer[] {1, 2, 3, 4}; // 泛型方法调用时，指明泛型参数类型 List&lt;Integer&gt; list = p.copyArrayFromList(integer); System.out.println(list); // [1, 2, 3, 4]} 3、泛型在继承方面体现 虽然类A是类B的父类，但是G&lt;A&gt;和G&lt;B&gt;二者不具备子父类关系，二者是并列关系。 补充：类A是类B的父类（或接口），A&lt;G&gt;是 B&lt;G&gt; 的父类 1234567891011121314151617@Testpublic void test6(){ ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); // 编译错误：二者内存上指向同一个地址，对list1的操作会导致list2也修改，会产生类型不一致问题！ // list1 = list2; List&lt;String&gt; list3 = null; AbstractList&lt;String&gt; list5 = null; ArrayList&lt;String&gt; list4 = null; // 编译通过： list3 = list4;` list5 = list4;} 4、通配符使用 通配符：? 类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;是没关系的，二者共同的父类是：G&lt;?&gt; 限制条件的通配符的使用： ? extends A: 上界是A。 G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类 ? super A: 下界是A 。G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Testpublic void test7(){ ArrayList&lt;Object&gt; list1 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); ArrayList&lt;?&gt; list = new ArrayList&lt;&gt;(); // 可赋值！ list = list1; list = list2; show(list); // 允许读不允许写： // list.add(\"AA\"); // 不允许写：null除外（任何类型都可以使用null赋值） list.add(null); // 允许读：返回为Object（任何类型父类都是Object） Object o = list.get(0); ArrayList&lt;? extends Person&gt; list3 = null; ArrayList&lt;? super Person&gt; list4 = null; ArrayList&lt;Person&gt; list5 = null; ArrayList&lt;Sons&gt; list6 = null; ArrayList&lt;Object&gt; list7 = null; // ========================= // 父类接收子类 list3 = list5; list3 = list6; // list3 = list7; // 父类接收子类 list4 = list5; // list4 = list6; list4 = list7; // 读取数据举例：都是拿上界去接受即可！ Person p = list3.get(0); Object o1 = list4.get(0); // 写入数据举例： // 编译错误：list3就是继承自Person的子类，但并不明确是哪个子类，无法放入数据！ // list3.add(new Person()); // 编译正确：list4是Person的父类，自然可以放入Person及其子类！ list4.add(new Person()); list4.add(new Sons());}public void show(List&lt;?&gt; list){ Iterator&lt;?&gt; iterator = list.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://www.itnxd.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"泛型","slug":"泛型","permalink":"https://www.itnxd.cn/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"StringBuilder","slug":"StringBuilder","permalink":"https://www.itnxd.cn/tags/StringBuilder/"},{"name":"StringBuffer","slug":"StringBuffer","permalink":"https://www.itnxd.cn/tags/StringBuffer/"},{"name":"枚举类","slug":"枚举类","permalink":"https://www.itnxd.cn/tags/%E6%9E%9A%E4%B8%BE%E7%B1%BB/"},{"name":"集合","slug":"集合","permalink":"https://www.itnxd.cn/tags/%E9%9B%86%E5%90%88/"}],"author":"ITNXD"},{"title":"再学Java之面向对象与异常","slug":"再学Java之面向对象与异常","date":"2021-02-15T05:09:23.000Z","updated":"2021-02-17T13:34:31.204Z","comments":true,"path":"posts/6640.html","link":"","permalink":"https://www.itnxd.cn/posts/6640.html","excerpt":"","text":"这里仅记录我认为没有了解透彻的知识，并不很全面系统，仅用于自己的查漏补缺！不过，我相信我没写的大家都是了解清楚的！ 一、面向对象学习的三条主线 Java类及类的成员：属性、方法、构造器；代码块、内部类 面向对象的大特征：封装性、继承性、多态性、(抽象性) 其它关键字：this、super、static、final、abstract、interface、package、import等 二、零零碎碎 1、可变个数形参 JDK 5.0新增的内容： 可变个数形参的格式：数据类型 ... 变量名 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个，2个，。。。 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。 可变个数形参在方法的形参中，必须声明在末尾 可变个数形参在方法的形参中，最多只能声明一个可变形参。 2、方法重载参数个数或者参数类型不同即可！ 3、Eclipse的Junit单元测试步骤： 选中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步 创建Java类，进行单元测试。 此时的Java类要求： 此类是public的 此类提供公共的无参的构造器 4、包装类4.1、八种基本数据类型对应的包装类 4.2、基本数据类型、包装类、String的转换 基本数据类型 —&gt; 包装类 ：调用包装类的构造器 包装类 —&gt; 基本数据类型 ：调用包装类的Xxx的xxxValue()方法 基本数据类型 &lt;—&gt; 包装类：JDK 5.0 新特性：自动装箱 与自动拆箱 基本数据类型、包装类 —&gt; String: 调用String重载的valueOf(Xxx xxx) 可能会报NumberFormatException异常！ String —&gt; 基本数据类型、包装类: 调用包装类的parseXxx(String s) 4.3、包装类注意点123456789101112131415161718192021222324@Testpublic void test6() { // 注意点一： // 三元运算符要保证两个表达式一致，例如int和String就会编译出错。 // 这里相当于自动向上转型，都按照Double进行比较了！ Object obj = true ? new Integer(1) : new Double(2.0); System.out.println(obj); // 1.0 // 注意点二： // Integer类内部有一个IntegerCache的结构，定义了一个缓存数组，存储-128 ~ 127的数，因为最常用， // 从缓存加载可以提高速度！ // 所以Integer自动装箱的数如果在上述范围，则取到的是同一个地址！ Integer in1 = new Integer(1); Integer in2 = new Integer(1); System.out.println(in1 == in2); // false Integer in3 = 1; Integer in4 = 1; System.out.println(in3 == in4); // true Integer in5 = 128; Integer in6 = 128; System.out.println(in5 == in6); // false} 三、面向对象 1、四种权限修饰符 4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类。 修饰类的话，只能使用：缺省、public 四种权限修饰符的具体修饰范围： 2、JavaBean使用 所谓JavaBean，是指符合如下标准的Java类,是java语言的可重用组件： 类是公共的 一个无参的公共的构造器 属性，且对应的get、set方法 123456789101112public class JavaBeanTest { String name; public JavaBeanTest() { } public void setName(String s) { name = s; } public String getName() { return name; }} 3、this关键字this修饰：属性、方法、构造器 this不能调用自己本身的构造器！（this无法递归。。。) 注意点： 我们在类的构造器中，可以显式的使用this(形参列表)方式，调用本类中指定的其他构造器 构造器中不能通过this(形参列表)方式调用自己 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了this(形参列表) 规定：this(形参列表)必须声明在当前构造器的首行 构造器内部，最多只能声明一个this(形参列表)，用来调用其他的构造器 4、super关键字super修饰：属性、方法、构造器 super调用属性、方法： 我们可以在子类的方法或构造器中。通过使用super.属性或super.方法的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略super. 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用super.属性的方式，表明调用的是父类中声明的属性。 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用super.方法的方式，表明调用的是父类中被重写的方法。 super调用构造器： 我们可以在子类的构造器中显式的使用super(形参列表)的方式，调用父类中声明的指定的构造器 super(形参列表)的使用，必须声明在子类构造器的首行！ 我们在类的构造器中，针对于this(形参列表)或super(形参列表)只能二选一，不能同时出现 在构造器的首行，没显式的声明this(形参列表)或super(形参列表)，则默认调用的是父类中空参的构造器：super() 在类的多个构造器中，至少一个类的构造器中使用了super(形参列表)，调用父类中的构造器 5、import关键字 在源文件中显式的使用import结构导入指定包下的类、接口 声明在包的声明和类的声明之间 如果需要导入多个结构，则并列写出即可 可以使用xxx.的方式，表示可以导入xxx包下的所结构 如果使用的类或接口是java.lang包下定义的，则可以省略import结构 如果使用的类或接口是本包下定义的，则可以省略import结构 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。 使用xxx.*方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入 import static：导入指定类或接口中的静态结构：属性或方法。 6、面向对象的继承性6.1、子类继承父类的不同特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。 6.2、方法重写 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 特殊情况：子类不能重写父类中声明为private权限的方法 返回值类型： 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类 父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double) 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写))。 6.3、重载与重写 对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定” 而对于重写（即多态），只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定” 7、面向对象的多态性7.1、多态性的使用 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法！ 但在运行期，我们实际执行的是子类重写父类的方法。 虚拟方法调用：调用父子类同名方法，实际执行的是子类重写父类的方法！此时父类方法称为虚拟/虚方法 总结：编译，看左边；运行，看右边。（编译在父类，运行在子类） 7.2、多态性的使用前提 类的继承关系 方法的重写 7.3、多态性使用的注意点 对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边） 7.4、多态是编译时行为还是运行时行为？运行时行为（只有在运行才能真正确定是哪个对象！） 7.5、向下转型 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。 解决方法：向下转型！ 注意点： 使用强转时，可能出现ClassCastException的异常。 为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。 8、static关键字static修饰：属性、方法、代码块、内部类 补充：栈（局部变量），堆（new出来的结构），方法区（类的加载信息，静态域，常量池） 8.1、static修饰属性 属性，是否使static修饰，又分为：静态属性 vs 非静态属性(实例变量) static修饰属性的其他说明： 静态变量随着类的加载而加载。可以通过类.静态变量的方式进行调用 静态变量的加载要早于对象的创建。 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。 8.2、static修饰方法：静态方法、类方法 随着类的加载而加载，可以通过类.静态方法的方式进行调用 静态方法中，只能调用静态的方法或属性 8.3、static的注意点在静态的方法内，不能使用this关键字、super关键字，关于静态属性和静态方法的使用，大家都从生命周期的角度去理解！ 8.4、使用static关键字 关于属性： 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。 类中的常量也常常声明为static 关于方法： 操作静态属性的方法，通常设置为static的 工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections 9、代码块使用 代码块的作用：用来初始化类、对象的信息 分类：代码块要是使用修饰符，只能使用static。静态代码块 vs 非静态代码块 静态代码块： 内部可以输出语句 随着类的加载而执行,而且只执行一次 作用：初始化类的信息 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行 静态代码块的执行要优先于非静态代码块的执行 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构 非静态代码块： 内部可以输出语句 随着对象的创建而执行 每创建一个对象，就执行一次非静态代码块 作用：可以在创建对象时，对对象的属性等进行初始化 如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法 ​ 简单补充：类内不能直接对属性进行操作，但可以将其放到代码块内进行初始化！ 实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序： 由父及子，静态先行。 属性的赋值顺序： ① 默认初始化 ② 显式初始化 / ⑤在代码块中赋值（谁在前谁先执行，后覆盖前） ③ 构造器中初始化 ④ 有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值 执行的先后顺序：① - ② / ⑤ - ③ - ④ 10、final关键字final修饰：类、方法、变量 修饰类:此类不能被其他类所继承。 修饰方法：表明此方法不可以被重写 修饰变量：此时的”变量”就称为是一个常量 修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化 修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。 static final 用来修饰属性：全局常量 11、abstract关键字abstract修饰：类、方法 11.1、abstract修饰类：抽象类 此类不能实例化 抽象类中一定有构造器，便于子类实例化时调用 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 抽象的使用前提：继承性 11.2、abstract修饰方法：抽象方法 抽象方法只方法的声明，没方法体 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。 若子类重写了父类中的所的抽象方法后，此子类方可实例化 若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰 11.3、abstract注意点： abstract不能用来修饰：属性、构造器等结构 abstract不能用来修饰私有方法、静态方法、final的方法、final的类 补充：abstract和 final水火不容！ 12345678910111213141516171819// 抽象类abstract class Person{ String name; int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public void show() { System.out.println(\"show()...\"); } // 抽象方法： public abstract void eat();} 11.4、抽象类的匿名类 目的：只用一次该抽象类的子类，无需再使用class编写，而是用完就销毁，方便！ 12345678910111213141516171819202122232425public static void main(String[] args) { Son son = new Son(); method(son); // 非匿名的类，非匿名的对象！ method(new Son()); // 非匿名的类，匿名的对象 // 1. 抽象类的匿名类：创建了一个匿名子类的对象，多态性，由父类Person接收 Person p = new Person() { @Override public void eat() { System.out.println(\"匿名类...\"); } }; // 多态性... method(p); // 2. 直接在方法内部使用时进行匿名编写 // 匿名的类，匿名的对象 method(new Person() { @Override public void eat() { System.out.println(\"匿名类...\"); } });} 12、interface关键字 Java中，接口和类是并列的两个结构！ 12.1、接口中可定义的成员JDK7及以前：只能定义全局常量和抽象方法 全局常量：public static final的，但是书写时，可以省略不写 抽象方法：public abstract的，但是书写时，可以省略不写 接口中不能定义构造器的！意味着接口不可以实例化 123456789interface Flyable{ public static final int MAX_SPEED = 7900; // 系统自动添加：public static final int MIN_SPEED = 1; public abstract void fly(); // 系统自动添加：public abstract void stop();} 12.2、其他注意点 如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化 如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类 Java类可以实现多个接口 接口与接口之间可以继承，而且可以多继承 接口，实际上可以看做是一种规范 123456789101112// 接口之间可以继承！interface AA{}interface BB{}interface CC extends AA, BB{} 12.3、Java8中关于接口的新规范 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法 知识点1：接口中定义的静态方法，只能通过接口来调用。 知识点2：通过实现类的对象，可以调用接口中的默认方法。 如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法 知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法， 那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt; 类优先原则 知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法， 那么在实现类没重写此方法的情况下，报错。–&gt; 接口冲突。这就需要我们必须在实现类中重写此方法 知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法？ 123456789101112131415161718192021222324252627282930interface AAA{ public static void method1() { System.out.println(\"静态方法一\"); } public default void method2() { System.out.println(\"默认方法二\"); } // 默认就是public，省略不写 default void method3() { System.out.println(\"默认方法二\"); }}class SuperClass{ public void method3() { System.out.println(\"SuperClass\"); }}class BBB extends SuperClass implements AAA{ public void method() { // 调用父类方法 super.method3(); // 接口调用静态方法 AAA.method1(); // 接口调用非静态方法 AAA.super.method2(); AAA.super.method3(); }} 13、内部类13.1、内部类的分类 成员内部类（静态、非静态 ） 局部内部类(方法内、代码块内、构造器内) 13.2、成员内部类的使用 一方面，作为外部类的成员： 调用外部类的结构 可以被static修饰 可以被4种不同的权限修饰 另一方面，作为一个类： 类内可以定义属性、方法、构造器等 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承 可以被abstract修饰 13.3、局部内部类的使用注意点： 在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num) 的话,要求此局部变量声明为final的。 jdk 7及之前版本：要求此局部变量显式的声明为final的 jdk 8及之后的版本：可以省略final的声明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class InnerClassTest { public static void main(String[] args) { // 4.1 如何创建成员内部类的对象？(静态的，非静态的) // 静态： Person.Dog dog = new Person.Dog(); dog.show(); // 非静态： // Person.Bird bird = new Person.Bird(); 错误 Person p = new Person(); Person.Bird bird = p.new Bird(); bird.sing(); bird.display(\"333\"); } // 第6点解释：相当于InnerClassTest和两个AA两个字节码文件，互相独立 public void method() { // 局部变量：实际为final int num = 10; class AA{ // 此时num相当于局部变量num的副本 // num = 20; 错误，不能修改 public void show() { System.out.println(num); } } }}class Person{ String name = \"111\"; int age; public void eat() { System.out.println(\"人吃饭\"); } // 静态成员内部类： static class Dog{ String name; int age; public void show() { System.out.println(\"狗子\"); } } // 非静态成员内部类： class Bird{ String name = \"222\"; public Bird() { } // 4.2 如何在成员内部类中调用外部类的结构？ public void sing() { // 1.调用外部类的非静态属性一 eat(); // 2.调用外部类的非静态属性二 Person.this.eat(); } public void display(String name) { System.out.println(name); // 形参 System.out.println(this.name); // 内部类属性 System.out.println(Person.this.name); // 外部类属性 } } // 局部内部类： public Person() { class AA{ } } public void show() { class BB{ } } { class CC{ } } // ========================================================= // 局部内部类的使用： //返回一个实现了Comparable接口的类的对象 public Comparable getComparable() { //创建一个实现了Comparable接口的类:局部内部类 //方式一： class MyComparable implements Comparable{ @Override public int compareTo(Object o) { return 0; } } // return new MyComparable(); // 方法二：创建了一个实现该接口的匿名实现类的匿名对象 return new Comparable() { @Override public int compareTo(Object o) { // TODO Auto-generated method stub return 0; } }; }} 13.4、总结成员内部类和局部内部类，在编译以后，都会生成字节码文件： 格式： 员内部类：外部类$内部类名.class 局部内部类：外部类$数字 内部类名.class 四、异常 1、异常体系结构1234567891011121314java.lang.Throwable |-----java.lang.Error:一般不编写针对性的代码进行处理。 |-----java.lang.Exception:可以进行异常的处理 |------编译时异常(checked) |-----IOException |-----FileNotFoundException |-----ClassNotFoundException |------运行时异常(unchecked,RuntimeException) |-----NullPointerException |-----ArrayIndexOutOfBoundsException |-----ClassCastException |-----NumberFormatException |-----InputMismatchException |-----ArithmeticException 2、如何自定义异常类？ 继承于现的异常结构：RuntimeException 、Exception 提供全局常量：serialVersionUID 提供重载的构造器 123456789public class MyException extends Exception{ static final long serialVersionUID = -338751699319999948L; public MyException() { } public MyException(String msg) { super(msg); }} 3、throw 和 throws区别 throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。 throws 属于异常处理的一种方式，声明在方法的声明处。 4、注意点 catch中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓。 catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 常用的异常对象处理的方式： ① String getMessage() ② printStackTrace() 5、编译时异常和运行时异常 体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。 体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。 6、开发中应该如何 如果父类中被重写的方法没throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理。 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://www.itnxd.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"author":"ITNXD"},{"title":"LeetCode刷题-130. 被围绕的区域","slug":"LeetCode刷题-130-被围绕的区域","date":"2020-08-08T15:16:17.000Z","updated":"2020-08-12T15:08:09.131Z","comments":true,"path":"posts/10602.html","link":"","permalink":"https://www.itnxd.cn/posts/10602.html","excerpt":"","text":"题目链接：130. 被围绕的区域 题解： 经典的逆向思维算法，Flood Fill 题目简述：给定一个二维矩阵只包含O和X，找到没有被包围的O用X填充。 题解：题目理解： 任何与边界的O相连的O都会被填充为X 任何与不与边界的O相连的O都不会被填充为X 逆向思维Flood Fill： 我们先将与边界上的O相连的O全部标记出来，即换一个字符例如# 此时除了X和#剩下的O就是需要被修改为X的了 只需一遍扫描即可，将O换为X，将#换为O 注意：vector为空的特判！ 时间复杂度：每个点最多遍历两次，为O(n^2) AC代码：123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;vector&lt;char&gt;&gt; board; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int n, m; void solve(vector&lt;vector&lt;char&gt;&gt;&amp; _board) { board = _board; if(board.empty() || board[0].empty()) return; n = board.size(), m = board[0].size(); for(int i = 0; i &lt; n; i++){ if(board[i][0] == 'O') dfs(i, 0); if(board[i][m - 1] == 'O') dfs(i, m - 1); } for(int i = 0; i &lt; m; i++){ if(board[0][i] == 'O') dfs(0, i); if(board[n - 1][i] == 'O') dfs(n - 1, i); } for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ if(board[i][j] == '#') board[i][j] = 'O'; else if(board[i][j] == 'O') board[i][j] = 'X'; } } _board = board; } void dfs(int x, int y){ board[x][y] = '#'; for(int i = 0; i &lt; 4; i++){ int a = x + dx[i], b = y + dy[i]; if(a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m &amp;&amp; board[a][b] == 'O') dfs(a, b); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"Flood Fill","slug":"Flood-Fill","permalink":"https://www.itnxd.cn/tags/Flood-Fill/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-129. 求根到叶子节点数字之和","slug":"LeetCode刷题-129-求根到叶子节点数字之和","date":"2020-08-08T15:16:05.000Z","updated":"2020-08-12T15:08:09.129Z","comments":true,"path":"posts/59814.html","link":"","permalink":"https://www.itnxd.cn/posts/59814.html","excerpt":"","text":"题目链接：129. 求根到叶子节点数字之和 题解： 简单递归求解二叉树问题！ 题目简述：给定一棵二叉树，求出所有从根节点到叶子节点构成的数的和！ 题解：简单DFS： 从根节点开始搜索 当前节点为空直接返回 当前节点的左右儿子都不存在时即为叶子节点，进行累加当前和后返回 搜索左子树和右子树，值为sum * 10 + val 时间复杂度：每个节点遍历一次，为O(n) AC代码：1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int res; int sumNumbers(TreeNode* root) { dfs(root, 0); return res; } void dfs(TreeNode* root, int sum){ if(!root) return; if(!root-&gt;left &amp;&amp; !root-&gt;right){ res += sum * 10 + root-&gt;val; return; } dfs(root-&gt;left, sum * 10 + root-&gt;val); dfs(root-&gt;right, sum * 10 + root-&gt;val); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-128. 最长连续序列","slug":"LeetCode刷题-128-最长连续序列","date":"2020-08-08T15:15:50.000Z","updated":"2020-08-12T15:08:09.123Z","comments":true,"path":"posts/44196.html","link":"","permalink":"https://www.itnxd.cn/posts/44196.html","excerpt":"","text":"题目链接：128. 最长连续序列 题解： 题目简述：给定一个无序序列，求最长连续序列长度！ 要求时间复杂度为：O(n) 题解：哈希： 先将所有数存到哈希表 对于连续序列，我们可以从一个数开始，每次加一进行判断是否存在即可！ 为了保证不重复遍历，我们每次只枚举该连续区间的起始值即可，例如1 2 3 4，我们只枚举从1开始，而不枚举从2 3 4开始！即保证S.count(x) &amp;&amp; !S.count(x - 1! 每次更新最大值即可，区间长度为y - x + 1 注意： 对于重复数字特别多的时候，上述做法会造成所有重复数字的重复枚举，时间复杂度增大，为了解决该问题，我们可以将枚举过的数字全部删掉，这样可以保证所有数字只枚举一次！ 时间复杂度：所有数只枚举一次O(n) AC代码：1234567891011121314151617class Solution {public: int longestConsecutive(vector&lt;int&gt;&amp; nums) { unordered_set&lt;int&gt; S; for(auto x : nums) S.insert(x); int res = 0; for(auto x : nums){ if(S.count(x) &amp;&amp; !S.count(x - 1)){ int y = x; S.erase(x); while(S.count(y + 1)) y ++, S.erase(y); res = max(res, y - x + 1); } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-127. 单词接龙","slug":"LeetCode刷题-127-单词接龙","date":"2020-08-08T15:15:33.000Z","updated":"2020-08-12T15:08:09.126Z","comments":true,"path":"posts/25443.html","link":"","permalink":"https://www.itnxd.cn/posts/25443.html","excerpt":"","text":"题目链接：127. 单词接龙 题解： 是上一道题的简化版，只需要记录方案数即可！ 题目简述：和上一题一样，给定起始和终止单词和一个字典，求每次只能改变一个单词并且该单词存在于字典可以到达终止单词的方案数！ 题解：具体见上一题： 可以通过博客上方搜索功能搜索或者使用文章下方上一篇按钮跳转！ 由于只需要记录方案数，所以我们只需要上一道题的最短路的过程即可，即只需要BFS并在中途计数既可！ 最终答案：if(t == endWord) return dist[t]; 时间复杂度：同样见上一题分析，为O(26nL^2 + nL)即O(nL^2) AC代码：12345678910111213141516171819202122232425262728class Solution {public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { unordered_set&lt;string&gt; S; unordered_map&lt;string, int&gt; dist; queue&lt;string&gt; q; q.push(beginWord); dist[beginWord] = 1; for(auto x : wordList) S.insert(x); while(q.size()){ auto s = q.front(); q.pop(); for(int i = 0; i &lt; s.size(); i++){ string t = s; for(char j = 'a'; j &lt;= 'z'; j++){ if(j == s[i]) continue; t[i] = j; if(S.count(t) &amp;&amp; dist.count(t) == 0){ dist[t] = dist[s] + 1; if(t == endWord) return dist[t]; q.push(t); } } } } return 0; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://www.itnxd.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-126. 单词接龙 II","slug":"LeetCode刷题-126-单词接龙-II","date":"2020-08-08T15:15:16.000Z","updated":"2020-08-12T15:08:09.121Z","comments":true,"path":"posts/48766.html","link":"","permalink":"https://www.itnxd.cn/posts/48766.html","excerpt":"","text":"题目链接：126. 单词接龙 II 题解： 是一道难题，DFS和BFS的结合使用！ 题目简述：给定两个不一样的单词和一个字典，找到所有从一个单词到另一个单词的序列！ 单词的变化每次转换只能改变一个字母，字典中不一定存在起始单词！ 题解：这道题本质是一道求最短路的问题：即从起始单词到结束单词的最短路，并且边权为一，可以使用BFS来求最短路！ 这道题不仅仅要求最短路的长度，而是要记录出所有最短路的路径，这里需要使用DFS来搜索路径！ 关于建图方法： 假设单词数为n，单词长度为L 枚举所有单词，判断两两单词（n^2）是否只有一位不同（L），为 n^2L 枚举每个单词，每个单词的每一位（26nL）判断是否只有一位不同，哈希表优化判断存在或使用过，为 26nL^2 简单计算： 当26L &lt; n 时，使用第二种，否则使用第一种，本题的数据为n &gt; 26L，所以要使用第二种，否则超时 进入正题！！！本题思路： DFS + BFS： 使用BFS来求一个dist数组，表示当前点到起始点的最短路径长度 使用第二种建图方式，即要枚举每一位的二十六种变化即可，若该点在字典中并且没有被遍历过，即S.count(t) &amp;&amp; dist.count(t) == 0，我们就进行遍历dist[t] = dist[s] + 1，正常宽搜顺序，将当前点加入队列即可！ 若搜到了终点，直接break，跳到上一层循环，防止搜索不必要的路径 通过dist数组来倒着DFS搜索到起点的路径即可 dfs(endWord) 对于最当前点s，只需要搜索可以到达改点的路径，即s的邻接点，并且只要保证dist[s] = dist[t] + 1即说明有一条从t到s的最短路径，当然我们要保证该点在字典中即dist.count(t) != 0 接下来继续向上搜索，直到起始单词，由于路径数组path是倒序存储的，所以搜到起点要将容器进行反转计入答案，完事之后再将其恢复 若BFS搜完发现最短路径数组dist中没有终点单词，即dist.count(endWord) == 0，说明字典中都没有终点单词或者通过字典中单词根本变不成终点单词，直接return，防止进行不必要的DFS 注意： 对于BFS的生成的单词是否在字典中的判断，采用了unordered_set来做，提前将其全部插入哈希表，判断为O(L) 对于DFS的生成的单词是否在字典中的判断，采用dist数组来做，为什么不采用BFS用到的S数组呢？因为字典中不一定有起始单词，而dist一定有 时间复杂度： 建图：见上面建图分析，为O(26nL^2) 最短路BFS：每个点遍历一次，每次需要O(L)进行判断字典中是否存在或使用过，总共为O(nL) 搜索路径DFS：路径数量是指数级别的，记录方案需要O(nL)，总共为O(2^n nL) 终上为：O(26nL^2 + nL + 2^n nL) = O(2^n nL) AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; path; unordered_set&lt;string&gt; S; unordered_map&lt;string, int&gt; dist; string beginWord; queue&lt;string&gt; q; vector&lt;vector&lt;string&gt;&gt; findLadders(string _beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { beginWord = _beginWord; q.push(beginWord); dist[beginWord] = 0; for(auto x : wordList) S.insert(x); while(q.size()){ auto s = q.front(); q.pop(); for(int i = 0; i &lt; s.size(); i++){ string t = s; for(char j = 'a'; j &lt;= 'z'; j++){ if(j == t[i]) continue; t[i] = j; if(S.count(t) &amp;&amp; dist.count(t) == 0){ dist[t] = dist[s] + 1; if(t == endWord) break; q.push(t); } } } } if(dist.count(endWord) == 0) return res; path.push_back(endWord); dfs(endWord); return res; } void dfs(string s){ if(s == beginWord){ reverse(path.begin(), path.end()); res.push_back(path); reverse(path.begin(), path.end()); return; } for(int i = 0; i &lt; s.size(); i++){ string t = s; for(char j = 'a'; j &lt;= 'z'; j++){ if(j == s[i]) continue; t[i] = j; if(dist.count(t) &amp;&amp; dist[t] + 1 == dist[s]){ path.push_back(t); dfs(t); path.pop_back(); } } } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://www.itnxd.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-125. 验证回文串","slug":"LeetCode刷题-125-验证回文串","date":"2020-08-08T15:15:04.000Z","updated":"2020-08-12T15:08:09.116Z","comments":true,"path":"posts/33082.html","link":"","permalink":"https://www.itnxd.cn/posts/33082.html","excerpt":"","text":"题目链接：125. 验证回文串 题解： 简单回文串的验证！ 题目简述：验证一个字符串是不是回文串，只考虑数字和大小写字母！ 题解：简单双指针： 一个指针从前向后，一个指针从后向前 遇到不少字母和数字则向后或向前移动 由于题目忽略大小写的存在，我们将其全部转化为小写字母比较即可！ 注意： tolower() 和 toupper()：位于cctype或ctype.h头文件 时间复杂度：O(n) AC代码：1234567891011121314class Solution {public: bool check(char c){ return c &gt;= '0' &amp;&amp; c &lt;= '9' || c &gt;= 'a' &amp;&amp; c &lt;= 'z' || c &gt;= 'A' &amp;&amp; c &lt;= 'Z'; } bool isPalindrome(string s) { for(int i = 0, j = s.size() - 1; i &lt; j; i++, j--){ while(i &lt; j &amp;&amp; !check(s[i])) i++; while(i &lt; j &amp;&amp; !check(s[j])) j--; if(i &lt; j &amp;&amp; tolower(s[i]) != tolower(s[j])) return false; } return true; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-124. 二叉树中的最大路径和","slug":"LeetCode刷题-124-二叉树中的最大路径和","date":"2020-08-08T15:14:51.000Z","updated":"2020-08-12T15:08:09.112Z","comments":true,"path":"posts/20454.html","link":"","permalink":"https://www.itnxd.cn/posts/20454.html","excerpt":"","text":"题目链接：124. 二叉树中的最大路径和 题解： 很是巧妙的递归求解路径问题！ 题目简述：非空二叉树返回最大路径和！路径定义为从任意一个节点出发到任意一个节点序列！ 题解：思考： 如何将所有路径遍历全面（注意：路径是任意点到任意点，不一定是要经过根节点或者叶子节点）！ 对于一条路径，该路径的最高点是一定的，所以我们来枚举它的最高点！ 对于该最高点的路径有几种情况：res = max(res, left + root-&gt;val + right) 根节点 根节点和左子树最大值 根节点和右子树最大值 根节点和左右子树最大值 对于计算左右子树的最大值： int dfs(TreeNode* root)：计算当前根节点的最大路径 return root-&gt;val + max(left, right)：返回根节点和左右子树最大值的和 left = max(0, dfs(root-&gt;left))：保证往下走是可以增大路径的，和0取一下max。若为负值，即不走当前路径 right = max(0, dfs(root-&gt;right))：同理 时间复杂度：每个节点遍历一次，为O(n) AC代码：12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int res; int maxPathSum(TreeNode* root) { res = INT_MIN; dfs(root); return res; } int dfs(TreeNode* root){ if(!root) return 0; int left = max(0, dfs(root-&gt;left)); int right = max(0, dfs(root-&gt;right)); res = max(res, left + root-&gt;val + right); return root-&gt;val + max(left, right); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-123. 买卖股票的最佳时机 III","slug":"LeetCode刷题-123-买卖股票的最佳时机-III","date":"2020-08-08T15:14:39.000Z","updated":"2020-08-12T15:08:09.108Z","comments":true,"path":"posts/15796.html","link":"","permalink":"https://www.itnxd.cn/posts/15796.html","excerpt":"","text":"题目链接：123. 买卖股票的最佳时机 III 题解： 上一题的再次进阶版！ 题目简述：给定一个序列，从中选择两次交易（保证：后者大于前者，并且下一次交易前必须把当前股票卖出），求其最大值作为股票的最大利润！ 上上一题只能交易一次，上一题可以交易多次，这题只能交易两次！ 题解一：较好理解的贪心 + 动态规划： 贪心解释： 将区间按每个点分为两部分，每部分计算一下只交易一次的最大收益，最终答案就是每个点分为的两部分和的最大值！ 状态表示： l和r数组分别表示区间为0 ~ i和i + 1 ~ n - 1交易一次的最大收益！ 状态计算： 对于l[i]：就是前面0 ~ i - 1的最小值和当前值的差 对于r[i]：就是后面i + 2 ~ n - 1的最大值与当前值的差 最终答案： max(res, l[i] + r[i]) 注意： l和r数组的区间范围 时间复杂度： O(n) 空间复杂度： O(n) AC代码一：123456789101112131415161718192021// i为第一段的末尾下标 0 ~ i i + 1 ~ n - 1class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); if(!n) return 0; vector&lt;int&gt; l(n + 1), r(n + 1); for(int i = 1, minv = prices[0]; i &lt; n; i++){ l[i] = max(l[i - 1], prices[i] - minv); minv = min(minv, prices[i]); } for(int i = n - 3, maxv = prices[n - 1]; i &gt;= 0; i--){ r[i] = max(r[i + 2], maxv - prices[i + 1]); maxv = max(maxv, prices[i + 1]); } int res = 0; for(int i = 0; i &lt; n; i++) res = max(res, l[i] + r[i]); return res; }}; 题解二：不太好理解的思路算法和上面解法一完全一致，只是做了优化减少了一层循环！ 很明显：上面的更加直观明显，建议看上面题解一！ 题解一是枚举的是分界点，本题解枚举的分界点的含义是第二次交易的起点！ 为了方便区间改变了一下： 左边范围为0 ~ i - 1 右边范围为i ~ n - 1 所以，将该点作为第二次交易起点的情况就是：该点之前的最大交易和以该点为交易起点的最大交易的和取最大值！ 左边值为：l[i]，右边值为：maxv - prices[i] 所以最终答案为：max(res, l[i] + maxv - prices[i]) 注意： 唯一变化，枚举点的含义变了！ minv maxv初值选取要写对 时间复杂度： O(n) AC代码二：1234567891011121314151617181920// i为第二段的起始位置下标 0 ~ i - 1 i ~ n - 1class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); vector&lt;int&gt; l(n + 1); for(int i = 1, minv = INT_MAX; i &lt; n; i++){ l[i] = max(l[i - 1], prices[i - 1] - minv); minv = min(minv, prices[i - 1]); } int res = 0; for(int i = n - 1, maxv = 0; i &gt;= 0; i--){ res = max(res, l[i] + maxv - prices[i]); maxv = max(maxv, prices[i]); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"前后缀分解","slug":"前后缀分解","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E5%90%8E%E7%BC%80%E5%88%86%E8%A7%A3/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-122. 买卖股票的最佳时机 II","slug":"LeetCode刷题-122-买卖股票的最佳时机-II","date":"2020-08-08T15:14:26.000Z","updated":"2020-08-12T15:08:09.104Z","comments":true,"path":"posts/13431.html","link":"","permalink":"https://www.itnxd.cn/posts/13431.html","excerpt":"","text":"题目链接：122. 买卖股票的最佳时机 II 题解： 上一题的进化版！ 题目简述：给定一个序列，从中选择多次两点（保证：后者大于前者，并且下一次交易前必须把当前股票卖出），求其最大值作为股票的最大利润！ 上一题只能交易一次，这题可以交易多次！ 题解：贪心：类似上一题 首先给出结论： 一个区间的交易可以拆分为单天的交易！ 证明： 1234假设i,j,k三点，i &lt; j &lt; k，对于区间[i, j],[j, k]，以及[i, k]，可以发现：他们的收益分别为 j - i + k - j 和 k - i会发现是一样的！所以：一个区间的收益，可以简化为每一天的收益和！ 要想使得股票收益最大，我们只需要将单天收益为正值的累加起来即可！即res += max(0, prices[i] - prices[i - 1]) 时间复杂度：O(n) AC代码：123456789class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int res = 0; for(int i = 1; i &lt; prices.size(); i++) res += max(0, prices[i] - prices[i - 1]); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-121. 买卖股票的最佳时机","slug":"LeetCode刷题-121-买卖股票的最佳时机","date":"2020-08-08T15:14:04.000Z","updated":"2020-08-12T15:08:09.095Z","comments":true,"path":"posts/45780.html","link":"","permalink":"https://www.itnxd.cn/posts/45780.html","excerpt":"","text":"题目链接：121. 买卖股票的最佳时机 题解： 简单的贪心问题！ 题目简述：给定一个序列，从中选择两点（保证：后者大于前者），求其最大值作为股票的最大利润！ 题解：贪心： res表示0 ~ i区间的最大股票收益，minv表示该区间的最小值。 求最大值，则当前区间的最小值和当前区间的最后一个值的差自然就是该区间的最大股票收益了，遍历一遍该数组即可得到最大股票收益！ 得到1 ~ i - 1的最小值minv 做差即可：price[i] - minv 时间复杂度：O(n) AC代码：1234567891011class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int res = 0, minv = INT_MAX; for(int i = 0; i &lt; prices.size(); i++){ res = max(res, prices[i] - minv); minv = min(minv, prices[i]); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-120. 三角形最小路径和","slug":"LeetCode刷题-120-三角形最小路径和","date":"2020-08-07T14:10:33.000Z","updated":"2020-08-08T15:12:49.209Z","comments":true,"path":"posts/52215.html","link":"","permalink":"https://www.itnxd.cn/posts/52215.html","excerpt":"","text":"题目链接：120. 三角形最小路径和 题解： 简单动态规划题！ 题目简述：给定一个三角形，求自顶向下的最小路径！ 题解：动态规划： 状态表示： 使用原数组f[i][j]表示该位置到达最底部的最小距离！ 状态计算： 只能移动到下一行正下方和右下方，所以该值为f[i][j] += min(f[i + 1][j], f[i + 1][j + 1])，即当前值加上从最下面到达当前层的下一层的距离！ 最终答案： f[0][0] 注意： 最后一行不必处理！处理也可以！ 时间复杂度：O(n^2) 空间复杂度：O(1) AC代码：12345678910class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; f) { int n = f.size(); for(int i = n - 2; i &gt;= 0; i--) for(int j = 0; j &lt;= i; j++) f[i][j] += min(f[i + 1][j], f[i + 1][j + 1]); return f[0][0]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-119. 杨辉三角 II","slug":"LeetCode刷题-119-杨辉三角-II","date":"2020-08-07T14:10:23.000Z","updated":"2020-08-08T15:02:00.697Z","comments":true,"path":"posts/50033.html","link":"","permalink":"https://www.itnxd.cn/posts/50033.html","excerpt":"","text":"题目链接：119. 杨辉三角 II 题解： 类似于上一个杨辉三角！ 题目简述：赶回第k行杨辉三角，要求空间O(k) 题解一：普通版思路： 为了省空间到O(k)，我么使用滚动数组解决 一个数组记录上一层，一个数组记录下一层，来回滚动即可 时间复杂度：O(n^2) AC代码一：123456789101112131415class Solution {public: vector&lt;int&gt; getRow(int rowIndex) { vector&lt;int&gt; res, last; for(int i = 0; i &lt;= rowIndex; i++){ res.clear(); for(int j = 0; j &lt;= i; j++){ if(!j || j == i) res.push_back(1); else res.push_back(last[j] + last[j - 1]); } last = res; } return res; }}; 题解二：位运算优化思路： 对于滚动数组是有特点的，我们可以用位运算来优化一下： 位运算滚动数组： 根据行数编号的奇偶来运算，上一层若为奇数，则下一层为偶数，使用i表示下一层，则上一层为i - 1，若直接这样那么空间复杂度是n^2级别的，但是，我们只要两层，可以对其奇偶进行判断即可，即和1左与运算即可，当前层为i &amp; 1，上一层为i - 1 &amp; 1，这样就把空间降到了两层！ 使用位运算优化： 会比普通的滚动数组快一点！ 最后答案： f[n &amp; 1] 实现： 构建二维数组，第一维只有2，使用时将第一维都与1做一下与运算即可！ 时间复杂度：O(n) AC代码二：123456789101112class Solution {public: vector&lt;int&gt; getRow(int n) { vector&lt;vector&lt;int&gt;&gt; f(2, vector&lt;int&gt;(n + 1)); for(int i = 0; i &lt;= n; i++){ f[i &amp; 1][0] = f[i &amp; 1][i] = 1; for(int j = 1; j &lt; i; j++) f[i &amp; 1][j] = f[i - 1 &amp; 1][j - 1] + f[i - 1 &amp; 1][j]; } return f[n &amp; 1]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递推","slug":"递推","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E6%8E%A8/"},{"name":"位运算","slug":"位运算","permalink":"https://www.itnxd.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"滚动数组","slug":"滚动数组","permalink":"https://www.itnxd.cn/tags/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-118. 杨辉三角","slug":"LeetCode刷题-118-杨辉三角","date":"2020-08-07T14:10:12.000Z","updated":"2020-08-08T14:26:28.433Z","comments":true,"path":"posts/46834.html","link":"","permalink":"https://www.itnxd.cn/posts/46834.html","excerpt":"","text":"题目链接：118. 杨辉三角 题解： 简单的杨辉三角！ 题目简述：给定一个数，生成杨辉三角的那几行！ 题解：递推： 对于每一行第一个和最后一个都是1，即!j || j == i 其他数字，都等于该数正上方和左上方的和，即res[i - 1][j - 1] + res[i - 1][j] 时间复杂度：O(n^2) AC代码：123456789101112131415class Solution {public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) { vector&lt;vector&lt;int&gt;&gt; res; for(int i = 0; i &lt; numRows; i++){ vector&lt;int&gt; level; for(int j = 0; j &lt;= i; j++){ if(!j || j == i) level.push_back(1); else level.push_back(res[i - 1][j - 1] + res[i - 1][j]); } res.push_back(level); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递推","slug":"递推","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E6%8E%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-117. 填充每个节点的下一个右侧节点指针 II","slug":"LeetCode刷题-117-填充每个节点的下一个右侧节点指针-II","date":"2020-08-07T14:10:02.000Z","updated":"2020-08-08T14:20:22.859Z","comments":true,"path":"posts/18637.html","link":"","permalink":"https://www.itnxd.cn/posts/18637.html","excerpt":"","text":"题目链接：117. 填充每个节点的下一个右侧节点指针 II 题解： 上一题的进阶版，二叉树变得更加的普通！ 题目简述：给定一棵非常普通的二叉树，每个节点多一个next指针，我们需要将其指向同一行紧挨着的下一个节点！ 要求空间O(1) 题解：不要求空间则可以通过简单BFS实现！ 和上一题思想类似： 不过这个题我么无法直接通过上一层来找到下一层的对应关系，但是我们可以对下一层进行构造横向链表！ 若下一层存在：构建虚拟头结点以及尾指针，进行尾插法形成下一层单链表 若上一层节点左儿子存在，则尾插法插入该节点 若上一层节点右儿子存在，则尾插法插入该节点 走向下一层，cur = head-&gt;next，由于head为虚拟头节点 时间复杂度：同样每个节点遍历一次，为O(n) AC代码：12345678910111213141516171819202122232425262728293031323334/*// Definition for a Node.class Node {public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {}};*/class Solution {public: Node* connect(Node* root) { if(!root) return root; auto cur = root; while(cur){ auto head = new Node(-1), tail = head; for(auto p = cur; p; p = p-&gt;next){ if(p-&gt;left) tail = tail-&gt;next = p-&gt;left; if(p-&gt;right) tail = tail-&gt;next = p-&gt;right; } cur = head-&gt;next; } return root; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-116. 填充每个节点的下一个右侧节点指针","slug":"LeetCode刷题-116-填充每个节点的下一个右侧节点指针","date":"2020-08-07T14:09:50.000Z","updated":"2020-08-08T13:59:27.438Z","comments":true,"path":"posts/54940.html","link":"","permalink":"https://www.itnxd.cn/posts/54940.html","excerpt":"","text":"题目链接：116. 填充每个节点的下一个右侧节点指针 题解： 类似链表的操作题！ 题目简述：给定一个二叉树，该二叉树每个节点多一个next指针用来横着指向下一个节点！ 要求：空间O(1) 题解：类似BFS： 该题要求空间O(1)，所以使用很简单的栈实现的BFS就不能使用了！ 思路： 若下一层存在，则通过上一层的每个节点p来链接下一层之间的关系： 先连接上一层根节点的左儿子为其右儿子，即 p-&gt;left-&gt;next = p-&gt;right 若上一层有后一个节点：（即此时为两个父亲四个儿子正中间的情况），即p-&gt;right-&gt;next = p-&gt;next-&gt;left 接下来，走到下一层，即level = level-&gt;left 时间复杂度：每个节点遍历一次为O(n) AC代码：123456789101112131415161718192021222324252627282930313233/*// Definition for a Node.class Node {public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {}};*/class Solution {public: Node* connect(Node* root) { if(!root) return root; auto level = root; while(level-&gt;left){ for(auto p = level; p; p = p-&gt;next){ p-&gt;left-&gt;next = p-&gt;right; if(p-&gt;next) p-&gt;right-&gt;next = p-&gt;next-&gt;left; } level = level-&gt;left; } return root; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-115. 不同的子序列","slug":"LeetCode刷题-115-不同的子序列","date":"2020-08-07T14:09:40.000Z","updated":"2020-08-08T13:43:47.987Z","comments":true,"path":"posts/39299.html","link":"","permalink":"https://www.itnxd.cn/posts/39299.html","excerpt":"","text":"题目链接：115. 不同的子序列 题解： 熟悉的动态规划又来了！ 题目简述：给定两个字符串，问按顺序可以从第一个字符串中找到多少种方案可以组成第二个字符！ 题解：动态规划：同样字符串前面加空格更好的处理边界问题！ 状态表示： 两个字符串，使用二维数组f[i][j]表示s串前i个字符和t串前j个字符的方案数 状态计算： 两种情况： s[i] != t[j]：则当前状态f[i][j] = f[i - 1][j]，即为s串前i - 1个字符和t串前j个字符的方案数 s[i] == t[j]：则当前状态f[i][j] = f[i - 1][j] + f[i - 1][j - 1]，即可以匹配最后一个字符即为f[i - 1][j - 1]，也可以不匹配即为f[i - 1][j] 最终答案： f[n][m] 边界条件： f[i][0] = 1，即s串前i个字符和t串前0个字符（空格）的方案数都是1，s一定有一个空格（开始部分）。 时间复杂度：O(nm) AC代码：12345678910111213141516class Solution {public: int numDistinct(string s, string t) { int n = s.size(), m = t.size(); s = ' ' + s, t = ' ' + t; vector&lt;vector&lt;long long&gt;&gt; f(n + 1, vector&lt;long long&gt;(m + 1)); for(int i = 0; i &lt;= n; i++) f[i][0] = 1; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ f[i][j] = f[i - 1][j]; if(s[i] == t[j]) f[i][j] += f[i - 1][j - 1]; } } return f[n][m]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-114. 二叉树展开为链表","slug":"LeetCode刷题-114-二叉树展开为链表","date":"2020-08-07T14:09:28.000Z","updated":"2020-08-08T10:38:34.224Z","comments":true,"path":"posts/34497.html","link":"","permalink":"https://www.itnxd.cn/posts/34497.html","excerpt":"","text":"题目链接：114. 二叉树展开为链表 题解： 找规律？ 题目简述：讲一个二叉树变为一个链表，具体查看题目链接！ 题解：思路： 若当前点存在左子树，则将左子树右链插入当前节点的右儿子 否则，当前节点走到右子树 就是每次将从左上到右下方向的链插入到该父节点的右链！ 时间复杂度：外层循环遍历每个节点一次为O(n)，内存循环会将每个右链遍历一次，每个节点最多被遍历两次，为O(n) AC代码：1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: void flatten(TreeNode* root) { while(root){ auto p = root-&gt;left; if(p){ while(p-&gt;right) p = p-&gt;right; p-&gt;right = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = NULL; } root = root-&gt;right; } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-113. 路径总和 II","slug":"LeetCode刷题-113-路径总和-II","date":"2020-08-07T14:09:15.000Z","updated":"2020-08-08T10:25:02.538Z","comments":true,"path":"posts/47363.html","link":"","permalink":"https://www.itnxd.cn/posts/47363.html","excerpt":"","text":"题目链接：113. 路径总和 II 题解： 和上一题类似，简单递归！ 题目简述：和上一题类似，多加了一个记录路径的要求！ 题解：递归： 根节点为空直接返回 将当前节点加入路径 答案条件：到了叶子结点并且sum减到了0 左子树不空递归左子树 右子树不空递归右子树 将当前加点删掉，恢复状态 由于要走遍所有情况，所以和上一题相比少了一个都不空的情况！ 时间复杂度：遍历所有节点为O(n)，记录所有路径为O(n)，总复杂度为O(n^2) AC代码：1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) { dfs(root, sum); return res; } void dfs(TreeNode* root, int sum){ if(!root) return; path.push_back(root-&gt;val); sum -= root-&gt;val; if(!root-&gt;left &amp;&amp; !root-&gt;right){ if(sum == 0) res.push_back(path); } if(root-&gt;left) dfs(root-&gt;left, sum); if(root-&gt;right) dfs(root-&gt;right, sum); path.pop_back(); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-112. 路径总和","slug":"LeetCode刷题-112-路径总和","date":"2020-08-07T14:09:02.000Z","updated":"2020-08-08T10:10:56.946Z","comments":true,"path":"posts/61574.html","link":"","permalink":"https://www.itnxd.cn/posts/61574.html","excerpt":"","text":"题目链接：112. 路径总和 题解： 简单递归！ 题目简述：给定一个二叉树和一个目标值，问是否有从根节点到叶子节点的和为目标值的线路！ 题解：递归：从根节点开始减，直到叶子节点判断是否为0即可，几种情况 根节点为空：返回false 左右子树都空：返回!sum 左右子树都不空：左边符合直接返回true，否则处理右边 左右子树一个空一个非空：放回该方向是否符合！ 注意： 注释部分为分开写法 可以合并为最后一句：左边存在且符合直接返回，不符合继续看右边是否存在，存在则看是否符合，最终返回！ 时间复杂度：遍历每个节点一次，为O(n) AC代码：123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool hasPathSum(TreeNode* root, int sum) { if(!root) return false; sum -= root-&gt;val; if(!root-&gt;left &amp;&amp; !root-&gt;right) return !sum; // if(root-&gt;left &amp;&amp; root-&gt;right) return hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum); // if(root-&gt;left) return hasPathSum(root-&gt;left, sum); // return hasPathSum(root-&gt;right, sum); return root-&gt;left &amp;&amp; hasPathSum(root-&gt;left, sum) || root-&gt;right &amp;&amp; hasPathSum(root-&gt;right, sum); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-111. 二叉树的最小深度","slug":"LeetCode刷题-111-二叉树的最小深度","date":"2020-08-07T14:08:40.000Z","updated":"2020-08-08T09:58:13.462Z","comments":true,"path":"posts/24315.html","link":"","permalink":"https://www.itnxd.cn/posts/24315.html","excerpt":"","text":"题目链接：111. 二叉树的最小深度 题解： 求二叉树的深度问题！ 题目简述：求二叉树的最小深度！ 题解：简单递归：最小深度一定是左右子树中较小的一个，递归去处理，分几种情况： 根节点为空：返回0 左右子树都为空：返回1 左右子树都非空：返回左右子树的较小深度加一 左右子树一个空一个非空：返回该子树深度加一 时间复杂度：遍历每个节点一次，为O(n) AC代码：12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int minDepth(TreeNode* root) { if(!root) return 0; if(!root-&gt;left &amp;&amp; !root-&gt;right) return 1; if(root-&gt;left &amp;&amp; root-&gt;right) return min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1; if(root-&gt;left) return minDepth(root-&gt;left) + 1; return minDepth(root-&gt;right) + 1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-110. 平衡二叉树","slug":"LeetCode刷题-110-平衡二叉树","date":"2020-08-05T11:25:37.000Z","updated":"2020-08-07T14:07:34.652Z","comments":true,"path":"posts/58905.html","link":"","permalink":"https://www.itnxd.cn/posts/58905.html","excerpt":"","text":"题目链接：110. 平衡二叉树 题解： 平衡二叉树的判断！ 题目简述：给定一棵二叉树判断是否是平衡二叉树！ 题解：平衡二叉树定义：所有 左右子树高度差不超过1 思路：根据定义来求解 求每个左右子树的高度，判断高度差是否大于1即可，即abs(lh - rh) &gt; 1 二叉树高度，同之前的求高度问题，左右高度最大值加一即可，即max(lh, rh) + 1 其实就是递归求二叉树高度问题多了一个变量来存储是否差值超过了1！ 时间复杂度：每个节点遍历一次，为O(n) AC代码：1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool res; bool isBalanced(TreeNode* root) { res = true; dfs(root); return res; } int dfs(TreeNode* root){ if(!root) return 0; int lh = dfs(root-&gt;left), rh = dfs(root-&gt;right); if(abs(lh - rh) &gt; 1) res = false; return max(lh, rh) + 1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"平衡二叉树","slug":"平衡二叉树","permalink":"https://www.itnxd.cn/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-109. 有序链表转换二叉搜索树","slug":"LeetCode刷题-109-有序链表转换二叉搜索树","date":"2020-08-05T11:25:17.000Z","updated":"2020-08-07T14:00:50.248Z","comments":true,"path":"posts/11732.html","link":"","permalink":"https://www.itnxd.cn/posts/11732.html","excerpt":"","text":"题目链接：109. 有序链表转换二叉搜索树 题解： 同样是构造二叉搜索树！链表比较麻烦一点！ 题目简述：将有序链表构造为高度平衡的二叉搜索树！ 题解：链表构造二叉树会麻烦一点！ 思路：总思路和数组相同，递归解决，仍是区间角度考虑！ 与数组不同，这个无法使用正常的区间，由于是链表，只能使用一个指针指向区间起点！ 为了找到节点数，需要遍历一次求长度 长度为1直接返回当前节点（也是为了处理边界问题） 找到中间节点：我们应该扎到左子树区间的终点cur，这样可以通过改点找到右子树的起点cur-&gt;next-&gt;next，循环n / 2 - 1次即可，保证左边比右边多一（偶数时）或者相等（奇数时），可以处理边界条件（当节点为2时，防止左右子树起点都不正确） 先处理右子树，在处理左子树，否则左子树的区间长度就不是一半了，变成整个区间了，不正确！先处理右子树，处理完将cur-&gt;next = NULL将区间分为两段head ~ cur， cur-&gt;next-&gt;next ~ NULL 最后返回当前根节点root，区间为空返回NULL 时间复杂度：递归logn层，每层为O(n)，总复杂度为O(nlogn) AC代码：123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; *//** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* sortedListToBST(ListNode* head) { if(!head) return NULL; int n = 0; for(auto p = head; p; p = p-&gt;next) n++; if(n == 1) return new TreeNode(head-&gt;val); auto cur = head; for(int i = 0; i &lt; n / 2 - 1; i++) cur = cur-&gt;next; auto root = new TreeNode(cur-&gt;next-&gt;val); root-&gt;right = sortedListToBST(cur-&gt;next-&gt;next); cur-&gt;next = NULL; root-&gt;left = sortedListToBST(head); return root; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-108. 将有序数组转换为二叉搜索树","slug":"LeetCode刷题-108-将有序数组转换为二叉搜索树","date":"2020-08-05T11:24:51.000Z","updated":"2020-08-07T14:01:23.619Z","comments":true,"path":"posts/58650.html","link":"","permalink":"https://www.itnxd.cn/posts/58650.html","excerpt":"","text":"题目链接：108. 将有序数组转换为二叉搜索树 题解： 构造二叉搜索树问题！ 题目简述：将有序数组构造为高度平衡的二叉搜索树！ 题解：仍然从区间角度去考虑递归子问题来解决！ 思路： 对于有序数组，二叉搜索树的根节点一定是区间的中心，即 l + r &gt;&gt; 1 根节点：root = new TreeNode(nums[mid]) 左子树区间：l, mid - 1 右子树区间：mid + 1, r l &gt; r区间为空返回NULL 关于高度平衡即左右子树高度差小于一的证明： 很明显，和二分一样，高度一定是Log2 (n + 1)上取整的！ 关于更加数学化的证明：参考 y 总证明！点击这里！ 时间复杂度：每个节点遍历一次，为O(n) AC代码：1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) { return build(nums, 0, nums.size() - 1); } TreeNode* build(vector&lt;int&gt;&amp; nums, int l, int r){ if(l &gt; r) return NULL; int mid = l + r &gt;&gt; 1; auto root = new TreeNode(nums[mid]); root-&gt;left = build(nums, l, mid - 1); root-&gt;right = build(nums, mid + 1, r); return root; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树搜索树","slug":"二叉树搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%90%9C%E7%B4%A2%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-107. 二叉树的层次遍历 II","slug":"LeetCode刷题-107-二叉树的层次遍历-II","date":"2020-08-05T11:24:27.000Z","updated":"2020-08-07T13:18:20.822Z","comments":true,"path":"posts/61896.html","link":"","permalink":"https://www.itnxd.cn/posts/61896.html","excerpt":"","text":"题目链接：107. 二叉树的层次遍历 II 题解： 和第102道题一样！ 题目简述：二叉树层次遍历，要求先遍历最底层！ 题解：嗯，按照正常顺序层序遍历，最后将答案进行反转即可！ 正常层序遍历思路参见第102道题题解！使用博客搜索框搜索即可！ 时间复杂度：O(n) AC代码：1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(q.size()){ vector&lt;int&gt; level; int len = q.size(); while(len --){ auto t = q.front(); q.pop(); level.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); } res.push_back(level); } reverse(res.begin(), res.end()); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://www.itnxd.cn/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-106. 从中序与后序遍历序列构造二叉树","slug":"LeetCode刷题-106-从中序与后序遍历序列构造二叉树","date":"2020-08-05T11:24:13.000Z","updated":"2020-08-07T13:13:47.063Z","comments":true,"path":"posts/35952.html","link":"","permalink":"https://www.itnxd.cn/posts/35952.html","excerpt":"","text":"题目链接：106. 从中序与后序遍历序列构造二叉树 题解： 二叉树的后中序构造二叉树！ 题目简述：给定二叉树的后中序遍历来构造一颗二叉树！ 题解： 后序遍历：根节点最后遍历 中序遍历：通过后序遍历得到的值找到中序序列的根节点下标位置，将序列分为左右子树 与前中序一样，详细见上一道题！ 这里只给出下标对应关系： 左子树下标：pl, k - 1 - il + pl, il, k - 1 右子树下标：k - 1 - il + pl + 1, pr - 1, k + 1, ir 下标计算同上一道前中序计算，参考上一题！ 时间复杂度：同样适用哈希表将复杂度降为O(n) AC代码：12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: unordered_map&lt;int, int&gt; pos; TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { for(int i = 0; i &lt; inorder.size(); i++) pos[inorder[i]] = i; return build(postorder, inorder, 0, postorder.size() - 1, 0, inorder.size() - 1); } TreeNode* build(vector&lt;int&gt;&amp; postorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir){ if(pl &gt; pr) return NULL; auto root = new TreeNode(postorder[pr]); int k = pos[root-&gt;val]; root-&gt;left = build(postorder, inorder, pl, k - 1 - il + pl, il, k - 1); root-&gt;right = build(postorder, inorder, k - 1 - il + pl + 1, pr - 1, k + 1, ir); return root; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"后序遍历","slug":"后序遍历","permalink":"https://www.itnxd.cn/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-105. 从前序与中序遍历序列构造二叉树","slug":"LeetCode刷题-105-从前序与中序遍历序列构造二叉树","date":"2020-08-05T11:23:54.000Z","updated":"2020-08-07T13:08:53.539Z","comments":true,"path":"posts/53963.html","link":"","permalink":"https://www.itnxd.cn/posts/53963.html","excerpt":"","text":"题目链接：105. 从前序与中序遍历序列构造二叉树 题解： 二叉树的前中序构造二叉树！ 题目简述：给定二叉树的前中序遍历来构造一颗二叉树！ 题解：必会知识： 前序遍历的第一个节点一定是根节点 中序遍历可以借助前序遍历得到的根节点将区间分为左右子树两部分 看明白了吧，按照左右子树区间进行递归即可！ 思路： 由于我们要从中序遍历找前序遍历得到的根节点，所以事先将中序遍历的节点和下标关系存储于哈希表，使得可以在O(1)时间查询到下标 根节点：前序遍历的第一个节点，root = new TreeNode(preorder[pl]) 当没有节点时即pl &gt; pr，返回NULL TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir)，参数分别为：前序，中序，前序起始下标，前序终止下标，中序起始下标，中序终止下标 k为中序遍历根节点下标，创建一个根节点，左右子树递归得到 左子树下标：pl + 1, k - 1 - il + pl + 1, il, k - 1 右子树下标：k - 1 - il + pl + 1 + 1, pr, k + 1, ir 下标计算见下图： 时间复杂度：由于哈希表的应用使得复杂度降到了O(n) AC代码：12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: unordered_map&lt;int, int&gt; pos; TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { for(int i = 0; i &lt; inorder.size(); i++) pos[inorder[i]] = i; return build(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1); } TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pl, int pr, int il, int ir){ if(pl &gt; pr) return NULL; auto root = new TreeNode(preorder[pl]); int k = pos[root-&gt;val]; root-&gt;left = build(preorder, inorder, pl + 1, k - 1 - il + pl + 1, il, k - 1); root-&gt;right = build(preorder, inorder, k - 1 - il + pl + 1 + 1, pr, k + 1, ir); return root; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"前序遍历","slug":"前序遍历","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-104. 二叉树的最大深度","slug":"LeetCode刷题-104-二叉树的最大深度","date":"2020-08-05T11:23:29.000Z","updated":"2020-08-07T12:22:06.831Z","comments":true,"path":"posts/10832.html","link":"","permalink":"https://www.itnxd.cn/posts/10832.html","excerpt":"","text":"题目链接：104. 二叉树的最大深度 题解： 二叉树深度问题！ 题目简述：求二叉树的最大深度！ 题解：很简单的！ 思路： 深度对于根结点来说就是左子树和右子树的最大深度加一即可，则我们递归去求其高度！ 时间复杂度：O(n) AC代码：12345678910111213141516/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int maxDepth(TreeNode* root) { if(!root) return 0; return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-103. 二叉树的锯齿形层次遍历","slug":"LeetCode刷题-103-二叉树的锯齿形层次遍历","date":"2020-08-05T11:23:13.000Z","updated":"2020-08-07T12:17:41.698Z","comments":true,"path":"posts/24916.html","link":"","permalink":"https://www.itnxd.cn/posts/24916.html","excerpt":"","text":"题目链接：103. 二叉树的锯齿形层次遍历 题解： 同样是二叉树层序遍历！ 题目简述：给定一个二叉树进行层序遍历，但是要保证左右，右左顺序来回交替遍历！ 题解：思路：和上一题一模一样，多了一个条件，即当层数（从0开始）为奇数时，将遍历得到的vector反转一次即可！ 时间复杂度：O(n) AC代码：123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); int k = 0; while(q.size()){ vector&lt;int&gt; level; int len = q.size(); while(len --){ auto t = q.front(); q.pop(); level.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); } if(k++ % 2) reverse(level.begin(), level.end()); res.push_back(level); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://www.itnxd.cn/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-102. 二叉树的层序遍历","slug":"LeetCode刷题-102-二叉树的层序遍历","date":"2020-08-05T11:22:59.000Z","updated":"2020-08-07T12:12:52.684Z","comments":true,"path":"posts/30623.html","link":"","permalink":"https://www.itnxd.cn/posts/30623.html","excerpt":"","text":"题目链接：102. 二叉树的层序遍历 题解： 二叉树层序遍历，很巧的思路！ 题目简述：给定一个二叉树，返回一个层序遍历的二维vector! 题解：很明显是一个BFS： 思路： 宽搜进行遍历每一层 遍历当前层时将下一层全部入队即可，循环次数就是当前层的节点数 时间复杂度：O(n) AC代码：12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(q.size()){ vector&lt;int&gt; level; int len = q.size(); while(len --){ auto t = q.front(); q.pop(); level.push_back(t-&gt;val); if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); } res.push_back(level); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://www.itnxd.cn/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-101. 对称二叉树","slug":"LeetCode刷题-101-对称二叉树","date":"2020-08-05T11:22:27.000Z","updated":"2020-08-06T04:14:37.999Z","comments":true,"path":"posts/63008.html","link":"","permalink":"https://www.itnxd.cn/posts/63008.html","excerpt":"","text":"题目链接：101. 对称二叉树 题解： 简单递归！ 题目简述：给定一棵二叉树判断是否是对称的！ 题解一：递归对于根节点来说，对称意味着左子树和右子树一致。 对于左子树和右子树，即保证左子树的左子树和右子树的右子树一致并且左子树的右子树和右子树的左子树一致即可！ 则我们可以递归分解为子问题来解决！ 递归DFS： dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left); 最终答案：dfs(root-&gt;left, root-&gt;right) 递归出口：和前几道题一样： !p &amp;&amp; !q：都空返回true !p || !q || p-&gt;val != q-&gt;val：一个空一个非空，或者都不空但值不相同返回false 注意： 根节点为空，直接返回true 时间复杂度：每个节点只被遍历一次，为O(n) AC代码一：123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSymmetric(TreeNode* root) { if(!root) return true; return dfs(root-&gt;left, root-&gt;right); } bool dfs(TreeNode* p, TreeNode* q){ if(!p &amp;&amp; !q) return true; if(!p || !q || p-&gt;val != q-&gt;val) return false; return dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left); }}; 题解二：非递归非递归写法：即用两个栈来模拟正常的中序遍历和反着的中序遍历（右根左）！ 注意点： while条件为lc || rc || left.size() 内部while条件为lc &amp;&amp; rc，左的往左走，右的往右走 退出while的判断为lc || rc，退出循环的情况一定是都空（不需要处理）或者是一个空一个不空（需要处理，无法对称） 值不相同，无法对称 左的往右走，右的往左走 时间复杂度：每个节点只被遍历一次，为O(n) AC代码二：1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSymmetric(TreeNode* root) { if(!root) return true; stack&lt;TreeNode*&gt; left, right; auto lc = root-&gt;left, rc = root-&gt;right; while(lc || rc || left.size()){ while(lc &amp;&amp; rc){ left.push(lc), lc = lc-&gt;left; right.push(rc), rc = rc-&gt;right; } if(lc || rc) return false; lc = left.top(), rc = right.top(); left.pop(), right.pop(); if(lc-&gt;val != rc-&gt;val) return false; lc = lc-&gt;right, rc = rc-&gt;left; } return true; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-100. 相同的树","slug":"LeetCode刷题-100-相同的树","date":"2020-08-03T10:16:50.000Z","updated":"2020-08-06T02:12:19.549Z","comments":true,"path":"posts/37006.html","link":"","permalink":"https://www.itnxd.cn/posts/37006.html","excerpt":"","text":"题目链接：100. 相同的树 题解： 简单判断两颗二叉树是否相同！ 题目简述：给定两颗二叉树，判断是否相同！ 题解一：DFS两树相同，即对应的左子树相同，对应的右子树相同即可！ 思路： 左子树相同，并且右子树相同即可，即isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right) 递归出口： 两子树都空，返回true 一子树空，一子树不空，或者两子树都不空但值不同，返会false 时间复杂度：所有节点遍历一次， 为 O(n) AC代码一：12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { if(!p &amp;&amp; !q) return true; if(!p || !q || p-&gt;val != q-&gt;val) return false; return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); }}; 题解二：BFS使用BFS来遍历一次两树即可！ 思路： 每次都是将同一方向的两树入队，左左右右，使得需要比较的节点为相邻状态即可！ 若两树都空，跳过即可，continue 若一树空，一树不空，或者两树都不空但是值不一样，直接返回false 然后按照左左右右顺序入队两棵树 循环结束没有返回false，则最终返回true 很明显，递归更好写！ 时间复杂度：遍历一遍所有节点，为O(n) AC代码二：123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { queue&lt;TreeNode*&gt; Q; Q.push(p), Q.push(q); while(Q.size()){ p = Q.front(), Q.pop(); q = Q.front(), Q.pop(); if(!q &amp;&amp; !p) continue; if(!p || !q || p-&gt;val != q-&gt;val) return false; Q.push(p-&gt;left), Q.push(q-&gt;left); Q.push(p-&gt;right), Q.push(q-&gt;right); } return true; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-99. 恢复二叉搜索树","slug":"LeetCode刷题-99-恢复二叉搜索树","date":"2020-08-03T10:16:32.000Z","updated":"2020-08-06T02:12:19.716Z","comments":true,"path":"posts/9694.html","link":"","permalink":"https://www.itnxd.cn/posts/9694.html","excerpt":"","text":"题目链接：99. 恢复二叉搜索树 题解： 一个占用空间为O(1)的新的二叉树遍历算法面世！ 题目简述：交换了两个节点的二叉搜索树，需要我们将其恢复回来！ 要求空间复杂度为O(1) 题解一：空间O(n)先给出空间占用为O(n)的算法！ 当前很好想，就是使用递归或非递归的栈来实现！ 现在先简单介绍一下这题怎么能找出两个被交换的节点？ 我们知道，二叉搜索树中序遍历有序，若交换两个点会造成逆序对出现，我们就根据逆序对来找两个点的位置！ 两种情况： 交换两元素相邻：如 1 3 2 4 5 6 7，即3，2逆序对，就是交换的两个节点 交换两元素不相邻：如 1 6 3 4 5 2 7，即6，2交换，对于相邻元素的逆序对有两个，即6 3和5 2，即交换位置为第一个相邻元素逆序对的第一个值和第二个相邻元素逆序对的第二个值！ 具体做法： 与中序遍历递归写法一样，多一个指针指向当前节点的上一个节点last，每次进行相邻元素判断是否是逆序对，是则更新两个交换指针first, second，之后再次遇到只更新second即可 最后进行两节点值的交换swap(first-&gt;val, second-&gt;val) 时间复杂度：O(n) 空间复杂度：O(n) AC代码一：1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* first, *second, *last; void recoverTree(TreeNode* root) { dfs(root); swap(first-&gt;val, second-&gt;val); } void dfs(TreeNode* root){ if(!root) return; dfs(root-&gt;left); if(last &amp;&amp; last-&gt;val &gt; root-&gt;val){ if(!first) first = last, second = root; else second = root; } last = root; dfs(root-&gt;right); }}; 题解二：空间O(1)为了符合题目要求只能使用这个牛逼有难写的Morris遍历，可将空间复杂度降低到O(1)! Morris-traversal：核心就是将栈进行了优化，非递归栈的最大作用是为了回溯时找到该节点（即栈顶），而这个遍历就是为了优化这一步！优化步骤：将子树最后遍历的节点的右指针指向要回溯的节点！ 该遍历算法流程： 若该节点没有左子树，则遍历当前节点，然后遍历右子树 若该节点有左子树，则找该节点的前驱结点p（即指向该节点的节点，这里指的是该子树要遍历的最后一个节点） 若p-&gt;right == NULL：说明我们的遍历顺序是从上面下来的，即该左子树并没有进行遍历，然后将前驱结点指向根节点p-&gt;right = root ，继续遍历左子树root = root-&gt;left！ 若p-&gt;right != NULL：说明我们的遍历顺序是从下面上去的，则该左子树已经遍历过了，将当前状态清空p-&gt;right = NULL，遍历当前节点，继续遍历右子树root = root-&gt;right！ 我们要在上面两处遍历当前点的情况时进行寻找逆序对，和题解一一样！ 最终结果：将first second的值进行交换即可！ 如何去找该子树最后一个被遍历的节点？ 很简单，即先往左走一步，然后一直往右走到底就是该节点！想想是不是！右节点一定是最后遍历的！ 注意： 找该节点时的条件为：p-&gt;right &amp;&amp; p-&gt;right != root，使用p-&gt;right != root，防止形成环成为死循环！ 时间复杂度：关键在于求前驱结点的while循环，求前驱结点的最坏情况为O(n)，然而对于二叉树来说，每条边最多被遍历两次，时间复杂度为O(2n)，即为O(n) 哪两次呢？ 第一次：对于左儿子没有右子树的情况，后面的点即左儿子最多会被根节点遍历一次！第二次：对于左儿子有右子树的情况，后面的点最多被根节点遍历一次！终上所述，每个节点最多遍历两次！ 空间复杂度：没有开辟额外空间，为O(1) AC代码二：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: void recoverTree(TreeNode* root) { TreeNode *first = NULL, *second = NULL, *last = NULL; while(root){ // 没有左子树 if(!root-&gt;left){ // 遍历当前根节点 if(last &amp;&amp; last-&gt;val &gt; root-&gt;val){ if(!first) first = last, second = root; else second = root; } // 更新当前节点的上一个节点为当前节点 last = root; // 走向右子树 root = root-&gt;right; }else{ // 有左子树 // 走向第一个左儿子 auto p = root-&gt;left; // 走向第一个左儿子的最右边即前驱结点 while(p-&gt;right &amp;&amp; p-&gt;right != root) p = p-&gt;right; // 说明是从上面下来的 if(!p-&gt;right) p-&gt;right = root, root = root-&gt;left; else{ // 说明是从下面上来的 // 恢复该指针 p-&gt;right = NULL; // 遍历当前节点 if(last &amp;&amp; last-&gt;val &gt; root-&gt;val){ if(!first) first = last, second = root; else second = root; } last = root; // 走向右子树 root = root-&gt;right; } } } swap(first-&gt;val, second-&gt;val); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"Morris-traversal","slug":"Morris-traversal","permalink":"https://www.itnxd.cn/tags/Morris-traversal/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-98. 验证二叉搜索树","slug":"LeetCode刷题-98-验证二叉搜索树","date":"2020-08-03T10:16:15.000Z","updated":"2020-08-06T02:12:19.713Z","comments":true,"path":"posts/58463.html","link":"","permalink":"https://www.itnxd.cn/posts/58463.html","excerpt":"","text":"题目链接：98. 验证二叉搜索树 题解： 判断是否是二叉搜索树！递归写法有点意思！ 题目简述：判断是否是二叉搜索树！ 题解一：非递归我们知道二叉搜索树中序遍历后是有序的！ 思路： 中序遍历二叉搜索树 两个变量指向一前一后 若后面大于前面直接返回false 时间复杂度：O(n) AC代码一：12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isValidBST(TreeNode* root) { TreeNode* pre = NULL; stack&lt;TreeNode*&gt; stk; while(root || stk.size()){ while(root){ stk.push(root); root = root-&gt;left; } root = stk.top(); stk.pop(); if(pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) return false; pre = root; root = root-&gt;right; } return true; }}; 题解二：递归递归写法就不太好写了！ 思路： 由二叉搜索树定义来递归验证，即验证左子树和右子树是否符合，逐级向上，直到根节点！ dfs的vector返回值存储三项，当前子树是否是二叉搜索树，当前子树的最小值，当前子树的最大值！ 具体来说： 若左子树存在则遍历左子树 若左子树不是二叉搜索树，或者左子树是二叉搜索树但根节点小于左子树的最大值，则说明当前根节点不是二叉搜索树，标记res[0] = 0 更新包含当前根节点的子树的最大最小值 若右子树存在则遍历右子树 若右子树不是二叉搜索树，或者右子树是二叉搜索树但根节点大于右子树的最小值，则说明当前根节点不是二叉搜索树，标记res[0] = 0 更新包含当前根节点的子树的最大最小值 返回res 最终结果： dfs[root][0] 时间复杂度： 每个节点遍历一次，为 O(n) AC代码二：1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isValidBST(TreeNode* root) { if(!root) return true; return dfs(root)[0]; } vector&lt;int&gt; dfs(TreeNode* root){ vector&lt;int&gt; res({1, root-&gt;val, root-&gt;val}); if(root-&gt;left){ auto t = dfs(root-&gt;left); if(!t[0] || t[2] &gt;= root-&gt;val) res[0] = 0; res[1] = min(res[1], t[1]); res[2] = max(res[2], t[2]); } if(root-&gt;right){ auto t = dfs(root-&gt;right); if(!t[0] || t[1] &lt;= root-&gt;val) res[0] = 0; res[1] = min(res[1], t[1]); res[2] = max(res[2], t[2]); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-97. 交错字符串","slug":"LeetCode刷题-97-交错字符串","date":"2020-08-03T10:16:01.000Z","updated":"2020-08-06T02:25:40.565Z","comments":true,"path":"posts/40380.html","link":"","permalink":"https://www.itnxd.cn/posts/40380.html","excerpt":"","text":"题目链接：97. 交错字符串 题解： 简单动态规划！ 题目简述：给定三个字符串，前两个字符串能否组成第三个字符串！ 题解：动态规划： 状态表示： 两个字符串，使用二维数组f[i][j]，s1串的前i个字符串和s2串的前j个字符能否构成s3串的前i + j个字符！ 状态计算：同样的套路，只考虑最后一步，即能交错形成的条件： 当s1[i] == s3[i + j]时：s1串的前i - 1个和s2的前j个匹配 当s2[j] == s3[i + j]时：s1串的前i个和s2的前j - 1个匹配 综上所述： 状态转移方程为：f[i][j] = f[i - 1][j] || f[i][j - 1] 初始转态： f[0][0] == true 同样取决于能否将所有状态全部计算对！不解释了！ 最终结果： f[n][m] 时间复杂度：O(n^2) AC代码：12345678910111213141516171819class Solution {public: bool isInterleave(string s1, string s2, string s3) { int n = s1.size(), m = s2.size(); if(n + m != s3.size()) return false; s1 = ' ' + s1, s2 = ' ' + s2, s3 = ' ' + s3; vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1)); for(int i = 0; i &lt;= n; i++){ for(int j = 0; j &lt;= m; j++){ if(!i &amp;&amp; !j) f[i][j] = true; else{ if(i &amp;&amp; s1[i] == s3[i + j]) f[i][j] = f[i - 1][j]; if(j &amp;&amp; s2[j] == s3[i + j]) f[i][j] = f[i][j] || f[i][j - 1]; } } } return f[n][m]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-96. 不同的二叉搜索树","slug":"LeetCode刷题-96-不同的二叉搜索树","date":"2020-08-03T10:15:40.000Z","updated":"2020-08-06T02:12:19.698Z","comments":true,"path":"posts/31482.html","link":"","permalink":"https://www.itnxd.cn/posts/31482.html","excerpt":"","text":"题目链接：96. 不同的二叉搜索树 题解： 本题就是求卡特兰数，这里使用动态规划来写！ 题目简述：求n个节点可以构成二叉搜索树的个数！ 题解：可以直接利用卡特兰数公式来求，似乎不太好求！ 这里使用动态规划来求： 和上一道类似，同样是乘法原理，j表示长度为1 ~ i的根节点的位置，左子树的长度为 j - 1，右子树的长度为i - j 状态表示：f[i]表示i长度的二叉搜索树个数 状态计算： f[i] += f[j - 1] * f[i - j]（j可以取该区间任何位置，累加关系） 乘法原理，左边乘以右边 初始转态： f[0] = 1，同样这个初始状态由能否使得所有状态算对即可！当i, j都为1时，f[i] = f[j - 1] * f[i - j]应该为1，即f[0] = 1 最终答案：f[n] 即n长度的二叉搜索树个数 注意：对于1 ~ 5 和2 ~ 6可以构成的二叉搜索树是一样的，可以这样想，将1 ~ 5构成的二叉搜索树根据对应关系可以全部替换为2 ~ 6，即二叉搜索树的个数时有区间长度决定的！ 时间复杂度：O(n^2) AC代码：1234567891011class Solution {public: int numTrees(int n) { vector&lt;int&gt; f(n + 1); f[0] = 1; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) f[i] += f[j - 1] * f[i - j]; return f[n]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"卡特兰数","slug":"卡特兰数","permalink":"https://www.itnxd.cn/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-95. 不同的二叉搜索树 II","slug":"LeetCode刷题-95-不同的二叉搜索树-II","date":"2020-08-03T10:15:25.000Z","updated":"2020-08-06T02:12:19.720Z","comments":true,"path":"posts/3575.html","link":"","permalink":"https://www.itnxd.cn/posts/3575.html","excerpt":"","text":"题目链接：95. 不同的二叉搜索树 II 题解： 生成所有二叉搜索树！有意思的题！ 题目简述：给定一个序列，生成所有二叉搜索树的序列！ 题解：递归DFS： 对于一个区间的二叉搜索树，我们只需要枚举根节点所在的位置即可，通过递归一步步构建不同的二叉搜索树！ 从1 ~ n开始搜索 枚举根节点位置为l ~ r 递归左子树l ~ i - 1，右子树i + 1 ~ r 由于相当于乘法原理，左子树随便一种情况和右子树随便一种情况组合都是一个合法的二叉搜索树 左子树取一种情况，右子树取一种情况，构建根节点，连接起来形成当前结构的二叉搜索树 将当前所有二叉搜索树插入res并返回 递归终止条件： l &gt; r：即为空树，返回NULL n == 0：即输入为0，直接返回空容器{} 注意： 根节点一定要随用随创建，若创建第一层for循环，会导致覆盖情况发生，由于存储的是指针，最后存储将都会是一样的一个二叉树 此处的res不能创建到全局的，那样无法完成下一层向上一层的传递 时间复杂度：是卡特兰数，n个节点构成的二叉搜索树种类是卡特兰数，即 C2nn / n + 1 ！对于n个点的二叉搜索树，方案数如下： 其实推完公式就是卡特兰数，这里就不推了！ AC代码：123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&lt;TreeNode*&gt; generateTrees(int n) { if(!n) return {}; return dfs(1, n); } vector&lt;TreeNode*&gt; dfs(int l, int r) { if(l &gt; r) return {NULL}; vector&lt;TreeNode*&gt; res; for(int i = l; i &lt;= r; i++){ auto left = dfs(l, i - 1), right = dfs(i + 1, r); for(auto&amp; l : left){ for(auto&amp; r : right){ auto root = new TreeNode(i); root-&gt;left = l, root-&gt;right = r; res.push_back(root); } } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-94. 二叉树的中序遍历","slug":"LeetCode刷题-94-二叉树的中序遍历","date":"2020-08-03T10:15:09.000Z","updated":"2020-08-06T02:12:19.677Z","comments":true,"path":"posts/16898.html","link":"","permalink":"https://www.itnxd.cn/posts/16898.html","excerpt":"","text":"题目链接：94. 二叉树的中序遍历 题解： 开始进入二叉树的世界！ 题目简述：给定一个二叉树，返回中序遍历序列！ 题解：中序遍历：即左根右的顺序去遍历！ 递归： 从根节点开始遍历 遍历左子树 访问当前根节点 遍历右子树 递归到空节点返回 时间复杂度：O(n) AC代码一：递归实现1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; res; vector&lt;int&gt; inorderTraversal(TreeNode* root) { dfs(root); return res; } void dfs(TreeNode* root){ if(!root) return; dfs(root-&gt;left); res.push_back(root-&gt;val); dfs(root-&gt;right); }}; AC代码：非递归实现（模板）非递归：即借助栈来实现！ 思想： 先将左子树都压入栈中 出栈栈顶 指向当前栈顶的右子树 终止条件： 栈空并且当前节点为空 时间复杂度：O(n) 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stk; while(root || stk.size()){ while(root){ stk.push(root); root = root-&gt;left; } root = stk.top(); stk.pop(); res.push_back(root-&gt;val); root = root-&gt;right; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-93. 复原IP地址","slug":"LeetCode刷题-93-复原IP地址","date":"2020-08-03T10:06:50.000Z","updated":"2020-08-06T02:12:19.657Z","comments":true,"path":"posts/14783.html","link":"","permalink":"https://www.itnxd.cn/posts/14783.html","excerpt":"","text":"题目链接：93. 复原IP地址 题解： 带有剪枝的搜索，挺有意思！ 题目简述：给定一串数字，需要将其可以转化为的IP地址返回！ 题解：暴力搜索DFS：void dfs(string s, int u, int k, string path) u：当前搜索到的位置 k：当前搜索的点的个数 path：当前状态下的IP地址 思路： 对于前导0的处理，即012，IP地址没有前导0的，这个已经见过很多次了，直接i &gt; u &amp;&amp; s[u] == '0'即可判断！ 然后搜索下一位时保证下一位在0 ~ 255范围即为合法数字，否则直接return 下一个数的搜索要从上一个数的后一位开始，即i = u开始 终止条件： u == s.size()：即搜到了字符串末尾 剪枝优化：u &lt; s.size() &amp;&amp; k == 4：即没有搜到最后，已经够了四个点 答案： u == s.size() &amp;&amp; k == 4：即恰好组成一组IP地址，此时将该IP地址path最后的小数点去掉，即为答案 时间复杂度：一共n位，n - 1个空隙可插入点，即从n - 1个空隙三个点，即时间复杂度为：Cn-13 AC代码：AC代码：123456789101112131415161718192021222324class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; restoreIpAddresses(string s) { dfs(s, 0, 0, \"\"); return res; } void dfs(string s, int u, int k, string path){ if(u == s.size()){ if(k == 4){ path.pop_back(); res.push_back(path); } return; } if(k == 4) return; for(int i = u, t = 0; i &lt; s.size(); i++){ if(i &gt; u &amp;&amp; s[u] == '0') return; t = t * 10 + s[i] - '0'; if(t &lt;= 255) dfs(s, i + 1, k + 1, path + to_string(t) + '.'); else return; } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"搜索","slug":"搜索","permalink":"https://www.itnxd.cn/tags/%E6%90%9C%E7%B4%A2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-92. 反转链表 II","slug":"LeetCode刷题-92-反转链表-II","date":"2020-08-03T10:06:21.000Z","updated":"2020-08-06T02:12:19.669Z","comments":true,"path":"posts/56919.html","link":"","permalink":"https://www.itnxd.cn/posts/56919.html","excerpt":"","text":"题目链接：92. 反转链表 II 题解： 又是链表操作题，记得要画图哦！ 题目简述：将一个链表的m ~ n位置进行翻转！ 题解：思路： 将m ~ n进行指针翻转 将m指向n的下一位， 将a指向n 如下图： 具体来说： 首先找到m的前一个位置a 让b指向m， c指向m的下一位，t指向c的下一位 接下来将m ~ n进行指针翻转，即让c指向b 然后b c指针顺次后移 最后将该链如上图所示，连起来！懒得解释了，看图吧！ 时间复杂度：O(n) AC代码：123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseBetween(ListNode* head, int m, int n) { auto dummy = new ListNode(-1); dummy-&gt;next = head; auto a = dummy; for(int i = 0; i &lt; m - 1; i++) a = a-&gt;next; auto b = a-&gt;next, c = b-&gt;next; for(int i = 0; i &lt; n - m; i++){ auto t= c-&gt;next; c-&gt;next = b; b = c, c = t; } auto t = a-&gt;next; a-&gt;next = b; t-&gt;next = c; return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-91. 解码方法","slug":"LeetCode刷题-91-解码方法","date":"2020-08-03T03:16:42.000Z","updated":"2020-08-06T02:12:19.653Z","comments":true,"path":"posts/45808.html","link":"","permalink":"https://www.itnxd.cn/posts/45808.html","excerpt":"","text":"题目链接：91. 解码方法 题解： 简单的动态规划题！ 题目简述：将A ~ Z编码为 1 ~ 26，给定一个数字字符串求共有多少种解码方式！ 题解：动态规划： 状态表示： f[i]表示前i个字符的解码方法数 状态计算：考虑最后一步 最后一位不为0时，解码数为f[i - 1] 最后两位为10 ~ 26时，解码数为f[i - 2] 综上所述，状态转移方程为： f[i] = f[i - 1] + f[i - 2] 最终结果： f[n] 初始转态： f[0] = 1 ，初始转态为0还是1由是否能满足所有状态的正确性决定，由于f[1] = s[1] != '0' ? 1: 0;，所以f[0] = 1! 时间复杂度：O(n) 注意： 为了使得处理边界简单，将字符串前面加空格处理！ AC代码：1234567891011121314151617class Solution {public: int numDecodings(string s) { int n = s.size(); s = ' ' + s; vector&lt;int&gt; f(n + 1); f[0] = 1; for(int i = 1; i &lt;= n; i++){ if(s[i] != '0') f[i] += f[i - 1]; if(i &gt; 1){ int t = s[i] - '0' + (s[i - 1] - '0') * 10; if(t &gt;= 10 &amp;&amp; t &lt;= 26) f[i] += f[i - 2]; } } return f[n]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-90. 子集 II","slug":"LeetCode刷题-90-子集-II","date":"2020-07-25T03:43:41.000Z","updated":"2020-07-25T14:49:35.995Z","comments":true,"path":"posts/51468.html","link":"","permalink":"https://www.itnxd.cn/posts/51468.html","excerpt":"","text":"题目链接：90. 子集 II 题解： 又是不能重复的递归问题，和LeetCode刷题-47.全排列II此题的关键位置有点像！ 题目简述：给定一个包含重复元素的无序序列，返回该序列可以构成的不能重复的所有组合！ 题解：递归： 关键部分：如何去重？ 首先将数组排序，使得相同元素挨到一起 对于1 2 2来说，处理1 x x时，第二位只使用第一个2即可，不要让他使用第二个2即可！ i &lt;= start ：保证该位置的第一次选择直接使用第一个重复元素 i &lt;= start &amp;&amp; nums[i] == nums[i - 1]：保证该位置的下一种选择方案要保证不是重复元素 时间复杂度：最多有 2^n 个子集，每个子集存储需要O(n)计算量，总时间复杂度为：O(n * 2^n) AC代码一：for循环去处理长度为0 ~ n的情况！ 递归出口：当前位数 == 需要位数，即u == n AC代码二更加简洁！ 1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path, nums; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; _nums) { nums = _nums; sort(nums.begin(), nums.end()); for(int i = 0; i &lt;= nums.size(); i++) dfs(i, 0, 0); return res; } void dfs(int n, int u, int start){ if(u == n){ res.push_back(path); return; } for(int i = start; i &lt; nums.size(); i++){ if(i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; path.push_back(nums[i]); dfs(n, u + 1, i + 1); path.pop_back(); } }}; AC代码二：不用那么麻烦，使用for循环，由于递归本就是一颗二叉树，所以到达每个节点都是一种情况，所以可以像下面这样写！ 1234567891011121314151617181920class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path, nums; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; _nums) { nums = _nums; sort(nums.begin(), nums.end()); dfs(0); return res; } void dfs(int start){ res.push_back(path); for(int i = start; i &lt; nums.size(); i++){ if(i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue; path.push_back(nums[i]); dfs(i + 1); path.pop_back(); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-89. 格雷编码","slug":"LeetCode刷题-89-格雷编码","date":"2020-07-25T03:43:27.000Z","updated":"2020-07-25T14:49:35.992Z","comments":true,"path":"posts/56047.html","link":"","permalink":"https://www.itnxd.cn/posts/56047.html","excerpt":"","text":"题目链接：89. 格雷编码 题解： 一个有趣的题，做法也是特殊的，需要记住！ 题目简述：格雷编码是一个二进制数组合，每两个二进制数对应位数只能有一位不同，所有的组合对应的数集合称之为格雷编码！ 给定一个数，为二进制位数，返回该位数的格雷编码集合！ 题解：特殊题目： 特殊做法，记住即可！ 思路： n位二进制，共有2^n种组合！ 先将n-1位的二进制位，上下轴对称，再将轴上方的最后补0，轴下方的最后补1即可！ 如下图： 简单解释一下正确性： 对n - 1来说，已经满足格雷编码性质，现在来看n的情况： 对于轴上部分，原来相邻的都差一位不同，在最后都加一个相同的0则还是相邻之间差一位 对于轴下部分，原来相邻的都差一位不同，在最后都加一个相同的1则还是相邻之间差一位 对于轴上下相邻部分，由于轴对称，原来是完全一致的，现在一个加0，一个加1，也满足差一位的性质 对于数组具体存储数字的处理： 轴上的部分在最后加0，相当于整体左移一位，即res[i] *= 2 或 res[i] &lt;&lt; 1，没有产生新数据，原数据发生改变 轴下的部分在最后加1，相当于原数加1产生的新数假如数组末尾，即res.push_back(res[i] + 1) 当然，对轴下部分的处理的顺序和图片上的不一致，如果对第一个数加1，相当于轴下的最后一个数，从图上来说，即轴下的新数据是从下往上添加到数组末尾的，产生了新的数据 初始转态： 为n = 0时候，数组只要一个0. 时间复杂度：对于给定的n，计算量为：1 + 2 + 4 + 8 + … + 2^n-1 = 2 * (2^n-1 - 1) = 2^n - 2，即O(2^n) AC代码：12345678910111213class Solution {public: vector&lt;int&gt; grayCode(int n) { vector&lt;int&gt; res(1, 0); while(n--){ for(int i = res.size() - 1; i &gt;= 0; i--){ res[i] *= 2; res.push_back(res[i] + 1); } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"找规律","slug":"找规律","permalink":"https://www.itnxd.cn/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"},{"name":"格雷编码","slug":"格雷编码","permalink":"https://www.itnxd.cn/tags/%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-88. 合并两个有序数组","slug":"LeetCode刷题-88-合并两个有序数组","date":"2020-07-25T03:43:06.000Z","updated":"2020-07-25T14:49:35.986Z","comments":true,"path":"posts/33104.html","link":"","permalink":"https://www.itnxd.cn/posts/33104.html","excerpt":"","text":"题目链接：88. 合并两个有序数组 题解： 挺有意思的题，使用原数组多余空间来存储！ 题目简述：给定两个有序序列，第一个序列的总长度为两序列之和，多出来的长度为0，即空的！要求使用原数组（可以放得下两数组的数据）不开辟空间进行有序存储！ 题解：嗯，如果从前向后扫描，会将第一个数组的前面覆盖掉！ 既然第一个数组后面是空的，何不利用起来，先往第一个数组最后从后向前放数据，这样就不会造成覆盖问题！ 具体：从后向前扫描，较大的放到第一个数组最后，依次向前放 双指针？一个指针i指向第一个数组最后一个元素，一个指针j指向第二个数组最后一个元素，然后从后向前扫描即可！ nums1[i] &gt; nums2[j]：nums1[k--] = nums1[i--]; nums1[i] &lt;= nums2[j]：nums1[k--] = nums1[i--]; 结束条件：其中一个数组扫描完了 最后：两种情况 第二个数组没扫描完，则从后向前依次放到第一个数组 第一个数组没扫描完，则不用操作，想想，是不是？因为剩下的空间和第一个数组空间一致，并且，第一个数组本来就是有序的，所以他们所在的位置都是在正确位置上，不需要处理！ 时间复杂度：O(n) AC代码：123456789101112class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int k = n + m - 1; int i = m - 1, j = n - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0){ if(nums1[i] &gt; nums2[j]) nums1[k--] = nums1[i--]; else nums1[k--] = nums2[j--]; } while(j &gt;= 0) nums1[k--] = nums2[j--]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%BB%84/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-87. 扰乱字符串","slug":"LeetCode刷题-87-扰乱字符串","date":"2020-07-25T03:42:54.000Z","updated":"2020-07-25T14:49:35.989Z","comments":true,"path":"posts/30973.html","link":"","permalink":"https://www.itnxd.cn/posts/30973.html","excerpt":"","text":"题目链接：87. 扰乱字符串 题解： 本题也可以使用动态规划，但是似乎是三位数组的表示，及其复杂！ 本题可以使用递归分解子问题求解！较为简单一些！ 题目简述：给定一个字符串，我们可以把它逐层分解为子串，类似于二叉树，我们可以对非叶子节点（叶子节点只有一个字符）进行交换，然后该节点对应的儿子节点和父节点就会发生改变，最终的字符串就会发生一部分的反转！ 给定原串和一个待确认字符串，求解是否是原串通过反转得到的，即为扰乱字符串！ 题解：由于动态规划及其复杂，我们这里换一种思路来做！ 递归思想： 对于该扰乱字符串的简单理解，就是将一部分长度内的字符串在某个位置进行了前后对调，既然如此，我们就可以通过递归找到该长度的字符串，进而和待匹配串对应的位置进行比较即可！ 两种情况：该区间反转和该区间未反转 简单举例：以gr区间和eat区间为例， 此时区间长度i = 2： 不反转，great和great：则需要原串的前i个字符和待匹配串的前i个字符匹配，并且原串的后n - i个字符与待匹配串的后n - i个字符匹配，即isScramble(s1.substr(0, i), s2.substr(0, i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i)) 反转，great和eatgr：则需要原串的前i个字符和待匹配串的后i个字符匹配，并且原串的后n - i个字符与待匹配串的前n - i个字符匹配，即isScramble(s1.substr(0, i), s2.substr(n- 1)) &amp;&amp; isScramble(s1.substr(i), s2.substr(0, n - i)) 递归出口： 若子问题原串于待匹配串完全相同，则返回true 否则进行排序，查看是否一致，不一致则说明不可能匹配（例如字符个数不同，字符种类不同），直接返回false 若一致，则说明有可能匹配，继续进行递归求解 需要枚举每个区间长度，找到直接终止程序，否则继续查找所有可能，找完还没找到一种正确情况，这说明无法匹配，返回false 时间复杂度：用an表示两个字符串区间长度为n时的计算量，则 12345678an = 4(a1 + a2 + ... an-1)因为：每次都需要四个递归式同理：an-1 = 4(a1 + a2 + ... an-2)两式相减得：an - an-1 = 4an-1an = 5an-1 = 5^2 an-2 = .... = 5^n a0an = 5^n 所以时间复杂度为：O(5^n) AC代码：123456789101112131415161718class Solution {public: bool isScramble(string s1, string s2) { if(s1 == s2) return true; string t1 = s1, t2 = s2; sort(t1.begin(), t1.end()), sort(t2.begin(), t2.end()); if(t1 != t2) return false; int n = s1.size(); for(int i = 1; i &lt; n; i++){ if(isScramble(s1.substr(0, i), s2.substr(0, i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i))) return true; if(isScramble(s1.substr(0, i), s2.substr(n - i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(0, n - i))) return true; } return false; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-86. 分隔链表","slug":"LeetCode刷题-86-分隔链表","date":"2020-07-25T03:42:41.000Z","updated":"2020-07-25T14:49:35.982Z","comments":true,"path":"posts/44795.html","link":"","permalink":"https://www.itnxd.cn/posts/44795.html","excerpt":"","text":"题目链接：86. 分隔链表 题解： 又是一道链表题，自己做又写成了死循环。。。 一定要画图去做！ 题目简述：给定一个无序链表，给定一个目标值，将小于目标值的节点放到大于等于目标值的左边！ 题解：很明显：要将链表一分为二，一部分放小于目标值，一部分放大于目标值。 具体思路：如下图 遇到小的放到一个链表，遇到大的放到另一个链表，最后将小的链表尾指向大的链表头，再将大的链表的末尾指向空即可！ 注意：为了防止两个链表头找不到，一定要预先设置两个头lh, rh，并设置虚拟头结点，否则lt, rt后面的指向会乱，而且会构成死循环！（我好像就错到了这里） 时间复杂度：O(n) AC代码：1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* partition(ListNode* head, int x) { auto lh = new ListNode(-1), rh = new ListNode(-1); auto lt = lh, rt = rh; for(auto p = head; p; p = p-&gt;next){ if(p-&gt;val &lt; x) lt = lt-&gt;next = p; else rt = rt-&gt;next = p; } lt-&gt;next = rh-&gt;next; rt-&gt;next = NULL; return lh-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-85. 最大矩形","slug":"LeetCode刷题-85-最大矩形","date":"2020-07-25T03:42:22.000Z","updated":"2020-07-25T14:49:35.979Z","comments":true,"path":"posts/16580.html","link":"","permalink":"https://www.itnxd.cn/posts/16580.html","excerpt":"","text":"题目链接：85. 最大矩形 题解： 似乎动态规划也可以做，但好像是三维的数组表示，比较复杂！ 本题可以借助上一题思想，使用单调栈求矩形面积！ 本题求矩形面积，使用动态规划较为复杂，如果求的是正方形，使用动态规划就简单了！ 题目简述：给定一个只包含0，1的矩阵，找到一个只包含1的面积最大的矩形！ 题解：暴力思想：枚举每个点，将其作为右下角，枚举长宽，枚举长宽围成的矩形内的0，1。 时间复杂度为：O(n^2 * n^2 * n^2)，爆炸级别的复杂度！ 正确思想： 本题竟然能和单调栈求矩形面积的上一题有关联！ 我们按照矩阵的每一行作为可能出现都是1的矩形的底边，从该底边求一个最大矩形即可，和上一题类似，求最大矩形面积一样，将所有行作为底边枚举一遍求出来的就是所有可以形成的矩形，最大矩形就是答案！ 完全使用上一题求最大矩形的函数 枚举每一行，并取最大值即可 关键问题：如何求柱子高度，即从当前点可以向上走的高度（即该柱子都是1）？ 可以使用动态规划： 状态表示：h[i][j]表示该位置向上可以走的最大距离 状态计算：h[i][j] = 1 + h[i - 1][j]，即该位置为上一个位置的最大距离加上自己本身，前提是本身得是1，否则该位置为h[i][j] = 0 最终答案：res = max(res, largestRectangleArea(h[i])) 时间复杂度：枚举n行，每行单调栈求矩形面积需要枚举m列，所以为：O(n * m) ，即O(n^2)级别的 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; h) { int n = h.size(); vector&lt;int&gt; left(n), right(n); stack&lt;int&gt; stk; for(int i = 0; i &lt; n; i ++){ while (stk.size() &amp;&amp; h[stk.top()] &gt;= h[i]) stk.pop(); if (stk.empty()) left[i] = -1; else left[i] = stk.top(); stk.push(i); } stk = stack&lt;int&gt;(); for(int i = n - 1; i &gt;= 0; i --){ while (stk.size() &amp;&amp; h[stk.top()] &gt;= h[i]) stk.pop(); if (stk.empty()) right[i] = n; else right[i] = stk.top(); stk.push(i); } int res = 0; for(int i = 0; i &lt; n; i ++ ) res = max(res, h[i] * (right[i] - left[i] - 1)); return res; } int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { if(matrix.empty() || matrix[0].empty()) return 0; int n = matrix.size(), m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; h(n, vector&lt;int&gt;(m)); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) if(matrix[i][j] == '1'){ if(i) h[i][j] = 1 + h[i - 1][j]; else h[i][j] = 1; } int res = 0; for(int i = 0; i &lt; n; i++) res = max(res, largestRectangleArea(h[i])); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"https://www.itnxd.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-84. 柱状图中最大的矩形","slug":"LeetCode刷题-84-柱状图中最大的矩形","date":"2020-07-25T03:42:07.000Z","updated":"2020-07-25T14:49:35.984Z","comments":true,"path":"posts/64100.html","link":"","permalink":"https://www.itnxd.cn/posts/64100.html","excerpt":"","text":"题目链接：84. 柱状图中最大的矩形 题解： 第二次遇到单调栈了，不太好理解的一个算法和思路！ 和LeetCode刷题-42.接雨水很是类似！ 题目简述：给了一堆高高低低的柱子，要求从中找到一个面积最大的矩形！ 题解：首先想一下以某一个柱子为矩形上边界怎样得到该最大矩形？ 很好想，只要在其左右两边找到离他最近的第一个比他矮的柱子即可！因为比他高，则说明可以继续向外拓展，比他矮就不行了！ 到了这里，就会发现本题的实质就是：找到一个数左边第一个比他小的数和右边第一个比他大的数即可，面积就是左右间隔乘以该柱子高度取最大值即可！ 这里就要想到使用单调栈了，单调栈的核心就是：找到一个数左边第一个比他小的数！ 现在先稍微解释一下单调栈实现的原理： 由于该栈单调递增，对于当前处理的柱子来说，需要找到左边第一个比他矮的柱子 所以从栈顶开始往回看第一个比他矮的，比他高则该栈顶出栈，直到找到比他矮的，然后该柱子进栈 一个问题：删了该栈顶不会影响后面的柱子吗，当然不会！对于后面的柱子，也要找左边第一个比他矮的柱子，如果下一个柱子比当前栈顶高，则第一个矮的就是当前栈顶（即上一个柱子）否则，下一个柱子比当前栈顶矮，则之前出栈的柱子都比他高，所以该出栈柱子不会使第一个比他矮的柱子，即删除的柱子对后面柱子处理不会产生影响！ 所以该栈就是扫描到谁就是以谁为栈顶的一个递增序列！ 时间复杂度：O(n) TLE代码：暴力求解左右两边第一个矮柱子！ 时间复杂度：O(n^2) 妥妥超时！ 12345678910111213class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int res = 0; for(int i = 0; i &lt; heights.size(); i++){ int j = i + 1, k = i - 1; while(j &lt; heights.size() &amp;&amp; heights[j] &gt;= heights[i]) j++; while(k &gt;= 0 &amp;&amp; heights[k] &gt;= heights[i]) k--; res = max(res, heights[i] * (j - k - 1)); } return res; }}; AC代码一：单调栈使用left[i]，right[i]来表示i柱子左右两边比他第一个矮的柱子的下标！ 对于本题的一些细节： 如果该柱子左边都比他高，则当前柱子的左边比他第一矮的为 -1 如果该柱子右边都比他高，则当前柱子的左边比他第一矮的为 n 最终答案：res = max(res, h[i] * (right[i] - left[i] - 1)) 注意： 栈第二次使用前要清空 时间复杂度：O(n) 空间复杂度： O(n) 比下面的AC代码二多一点空间，但更好理解 1234567891011121314151617181920212223242526class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; h) { int n = h.size(); vector&lt;int&gt; left(n), right(n); stack&lt;int&gt; stk; for(int i = 0; i &lt; n; i ++){ while (stk.size() &amp;&amp; h[stk.top()] &gt;= h[i]) stk.pop(); if (stk.empty()) left[i] = -1; else left[i] = stk.top(); stk.push(i); } stk = stack&lt;int&gt;(); for(int i = n - 1; i &gt;= 0; i --){ while (stk.size() &amp;&amp; h[stk.top()] &gt;= h[i]) stk.pop(); if (stk.empty()) right[i] = n; else right[i] = stk.top(); stk.push(i); } int res = 0; for(int i = 0; i &lt; n; i ++ ) res = max(res, h[i] * (right[i] - left[i] - 1)); return res; }}; AC代码二：单调栈相比上一个单调栈的写法：此写法不如上一种好理解！主要是省了两个数组空间… 思想一模一样， 略有不同： 上一个直接预处理当前柱子i的昨天最矮和右边最矮。 本方法直接处理每个栈顶t，即遇到当前柱子i比栈顶t矮，则说明右边第一个矮的已经找到就是当前柱子i，栈顶出栈，而左边第一个比他矮的就更简单了，就是该栈顶的上一个元素stk.top()（因为该栈递增，所以栈顶的上一个元素就是当前栈顶左边第一个比他矮的元素），两种情况： 若该栈顶没有上一个元素，则说明该栈顶的左边比他矮的没有，则为起始位置，面积为：h[t] * i 若该栈顶有上一个元素，则说明当前栈顶（原栈顶已出栈）就是左边第一个比他矮的柱子，面积为：h[t] * (i - stk.top() - 1) 注意： 为了保证栈递增，如果h[stk.top()] &lt;= h[i]，则当前柱子直接入栈！ 为了处理最后一个柱子，将柱子最后加一个-1，因为他每次处理的都是i柱子之前的栈内的柱子，所以最后一个处理不到，加一个-1，即可处理到！ 综上所述：还是AC代码一既正确又好理解！ 时间复杂度：O(n) 空间复杂度： O(n) 12345678910111213141516171819class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; h) { int n = h.size(); h.push_back(-1); stack&lt;int&gt; stk; int res = 0; for(int i = 0; i &lt;= n; i++){ while(stk.size() &amp;&amp; h[stk.top()] &gt; h[i]){ int t = stk.top(); stk.pop(); if(stk.empty()) res = max(res, h[t] * i); else res = max(res, h[t] * (i - stk.top() - 1)); } stk.push(i); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://www.itnxd.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-83. 删除排序链表中的重复元素","slug":"LeetCode刷题-83-删除排序链表中的重复元素","date":"2020-07-25T03:41:50.000Z","updated":"2020-07-25T14:49:35.967Z","comments":true,"path":"posts/20015.html","link":"","permalink":"https://www.itnxd.cn/posts/20015.html","excerpt":"","text":"题目链接：83. 删除排序链表中的重复元素 题解： 与上一个题类似，链表操作！ 题目简述：给定一个有序链表，将有重复的元素删掉（有重复的保留一个） 与上一题全删有点不同 题解：由于重复元素可以保留一个，所以第一个节点处理和后面一样，所以这里不需要建立虚拟头结点了！ 思路： 判断后面节点和当前已扫描节点形成的链表的最后一个节点是否相同 若相同，则跳过当前节点，指向该节点下一个节点l-&gt;next = l-&gt;next-&gt;next 若不同，则指向当前节点，即l = l-&gt;next 相同时，保证末尾l不动，next移动，不同时，l直接移到不同的节点。 时间复杂度：O(n) AC代码：1234567891011121314151617181920/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if(!head) return head; auto l = head; while(l-&gt;next){ if(l-&gt;val == l-&gt;next-&gt;val) l-&gt;next = l-&gt;next-&gt;next; else l = l-&gt;next; } return head; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-82. 删除排序链表中的重复元素 II","slug":"LeetCode刷题-82-删除排序链表中的重复元素-II","date":"2020-07-25T03:41:38.000Z","updated":"2020-07-25T14:49:35.977Z","comments":true,"path":"posts/1807.html","link":"","permalink":"https://www.itnxd.cn/posts/1807.html","excerpt":"","text":"题目链接：82. 删除排序链表中的重复元素 II 题解： 链表的操作题，感觉对这类链表操作还不太熟练，多做做吧！ 题目简述：给定一个有序链表，只要出现重复元素，就将该段重复元素删去（注意：不是删的只留一个，而是该段全删） 题解：类似双指针做法： 一个指针p-&gt;next指向已扫描位置的下一个位置，一个指针q指向第一个与上一个指针值不一样的位置。(直到与上一个指针不同是为止！) 此时有两种情况： 两指针相距一即p-&gt;next-&gt;next == q：即待扫描该位后面无重复元素，已扫描链表后移p = p-&gt;next 两指针相距大于一即p-&gt;next-&gt;next != q：即待扫描的该位后面有重复元素，跳过重复一段，直接指向第一个不重复元素p，即p-&gt;next = q 注意： 由于要从没有扫描的下一个位置开始，为了方便，建立虚拟头结点，此时未扫描部分对第一个节点的处理就和其他节点统一了，最终返回dummy-&gt;next 时间复杂度：O(n) AC代码：1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* deleteDuplicates(ListNode* head) { auto dummy = new ListNode(-1); dummy-&gt;next = head; auto p = dummy; while(p-&gt;next){ auto q = p-&gt;next-&gt;next; while(q &amp;&amp; p-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next; if(p-&gt;next-&gt;next == q) p = p-&gt;next; else p-&gt;next = q; } return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-81. 搜索旋转排序数组 II","slug":"LeetCode刷题-81-搜索旋转排序数组-II","date":"2020-07-23T02:53:18.000Z","updated":"2020-07-23T10:27:12.237Z","comments":true,"path":"posts/38820.html","link":"","permalink":"https://www.itnxd.cn/posts/38820.html","excerpt":"","text":"题目链接：81. 搜索旋转排序数组 II 题解： 和之前题目类似：LeetCode刷题-33.搜索旋转排序数组 题目简述：给定一个有序有重复元素的序列，从某一个点反转一下，问该序列是否存在目标值！ 比之前类似题目多了一个重复元素！ 题解一：二分其实不需要使用二分，因为二分最坏时间复杂度也为O(n)！ 我们使用二分的思路来做一下： 与之前写法完全一致，就是多了一点，不能直接进行二分！ 由于多了重复元素，会使得，该序列前一个升序的开始和后一个升序的结尾会有重合部分，无法通过二分得到中间值！ 所以：将第二个升序序列从末尾开始，如果和第一个升序序列开始一样，就删去，这样就完全转化为之前的题目了！ 具体操作： while(R &gt;= 0 &amp;&amp; nums[0] == nums[R]) R--; 就多了这一句，将重复部分删掉，注意删到只有一个元素的情况，直接判断返回即可 接下来和之前类似题目一模一样 先二分得到两端升序序列的分隔点 再判断在哪个序列 进行第二次二分找目标值 最后判断返回结果 具体思路：参考之前题目：LeetCode刷题-33.搜索旋转排序数组 时间复杂度： 最坏情况为，整个序列元素完全一样，这样第一个while循环会扫描n次，所以最坏时间复杂度为 O(n)，所以不如直接扫描一遍来的快！ AC代码一：123456789101112131415161718192021222324class Solution {public: bool search(vector&lt;int&gt;&amp; nums, int target) { if(nums.empty()) return false; int R = nums.size() - 1; while(R &gt;= 0 &amp;&amp; nums[0] == nums[R]) R--; if(R &lt; 0) return nums[0] == target; int l = 0, r = R; while(l &lt; r){ int mid = l + r + 1 &gt;&gt; 1; if(nums[mid] &gt;= nums[0]) l = mid; else r = mid - 1; } if(nums[0] &lt;= target) l = 0; else l = r + 1, r = R; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid; else l = mid + 1; } return nums[r] == target; }}; 题解二：直接扫描没什么可解释的！ 时间复杂度： O(n) AC代码二：12345678class Solution {public: bool search(vector&lt;int&gt;&amp; nums, int target) { for(auto x : nums) if(x == target) return true; return false; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"},{"name":"线性扫描","slug":"线性扫描","permalink":"https://www.itnxd.cn/tags/%E7%BA%BF%E6%80%A7%E6%89%AB%E6%8F%8F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-80. 删除排序数组中的重复项 II","slug":"LeetCode刷题-80-删除排序数组中的重复项-II","date":"2020-07-23T02:52:28.000Z","updated":"2020-07-23T10:27:12.229Z","comments":true,"path":"posts/40432.html","link":"","permalink":"https://www.itnxd.cn/posts/40432.html","excerpt":"","text":"题目链接：80. 删除排序数组中的重复项 II 题解： 与之前一道题几乎类似：LeetCode刷题-26.删除排序数组中的重复项 题目简述：类似题目是删除排序数组重复项，最多出现一次，这个题是最多出现两次！ 要求：使用原地算法，即不开辟额外空间！ 题解：思路： k &lt; 2时，直接存储到原数组 k &gt; 2时，判断当前元素和和该元素之前的前两个元素是否相同，若之前已经有两个和当前元素相同，则该元素多余直接跳过，否则累积起来，即nums[k ++ ] = x 最后返回长度k 时间复杂度：O(n) AC代码：12345678910class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { int k = 0; for(auto&amp; x : nums) if(k &lt; 2 || nums[k - 1] != x || nums[k - 2] != x) nums[k ++ ] = x; return k; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"Mr.Niu"},{"title":"LeetCode刷题-79. 单词搜索","slug":"LeetCode刷题-79-单词搜索","date":"2020-07-23T02:52:15.000Z","updated":"2020-07-23T10:27:12.234Z","comments":true,"path":"posts/24999.html","link":"","permalink":"https://www.itnxd.cn/posts/24999.html","excerpt":"","text":"题目链接：79. 单词搜索 题解： 纯搜索题！ 题目简述：在一个矩阵中找一个字符串，看是否存在，找的时候只能上下左右找，不能走走过的地方！ 题解：DFS搜索： bool dfs(int x, int y, int u) x, y：为当前位置下标 u：记录当前搜到的个数 递归出口：u == word.size() - 1 思路： 把每个点都当做起点进行搜索，每次搜索四个方向 若当前搜索位置和待匹配字符不匹配，直接return false 否则标记当前位置为*表示该位置已使用，且无法与待匹配字符进行匹配 开始搜索四个方向，保证下标不越界 如果有一个方向符合条件，直接终止搜索，返回return true，即if(dfs(tx, ty, u + 1)) return true;（可以保证有一条有效路径就直接终止搜索） for循环结束，说明当前位置无法继续向前，还原该位置标记，返回return false 有一个起点符合即终止，全部起点都不匹配，直接返回return false 注意： 向四个方向搜索，判断条件没有写是否访问该点，其实写不写都可以，因为下一次搜索如果搜索上一次用过的，会在下一次搜索的第一句话直接返回false，所以无影响 时间复杂度： 由于有n2个起点，每个起点除了第一个位置四个方向，后面都是三个方向（不能走回头路），每个方向的深度为k即待匹配字符串的长度，所以总时间复杂度为：O(n 2 * 3 k)。是一个指数级别的爆搜，会爆掉时间，但是一般由于数据较水，也可以通过剪枝，使得搜到的子问题很小，一般不需要考虑爆搜时间复杂度！ AC代码：不使用数组标记1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;vector&lt;char&gt;&gt; board; string word; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; _board, string _word) { board = _board, word = _word; int n = board.size(), m = board[0].size(); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) if(dfs(i, j, 0)) return true; return false; } bool dfs(int x, int y, int u){ if(board[x][y] != word[u]) return false; if(u == word.size() - 1) return true; char t = board[x][y]; board[x][y] = '*'; int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1}; for(int i = 0; i &lt; 4; i++){ int tx = x + dx[i], ty = y + dy[i]; if(tx &gt;= 0 &amp;&amp; tx &lt; board.size() &amp;&amp; ty &gt;= 0 &amp;&amp; ty &lt; board[0].size()){ if(dfs(tx, ty, u + 1)) return true; } } board[x][y] = t; return false; }}; AC代码：使用数组标记由于使用数组标记，就不具备上面的注意点那条性质了，必须乖乖的判断是否访问过！ 这样写会额外开辟一个数组空间，显然前者更加优一点！ 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;char&gt;&gt; board; vector&lt;vector&lt;bool&gt;&gt; vis; string word; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; _board, string _word) { board = _board, word = _word; int n = board.size(), m = board[0].size(); vis = vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(m)); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) if(dfs(i, j, 0)) return true; return false; } bool dfs(int x, int y, int u){ if(board[x][y] != word[u]) return false; if(u == word.size() - 1) return true; vis[x][y] = true; int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1}; for(int i = 0; i &lt; 4; i++){ int tx = x + dx[i], ty = y + dy[i]; if(tx &gt;= 0 &amp;&amp; tx &lt; board.size() &amp;&amp; ty &gt;= 0 &amp;&amp; ty &lt; board[0].size() &amp;&amp; !vis[tx][ty]){ if(dfs(tx, ty, u + 1)) return true; } } vis[x][y] = false; return false; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"搜索","slug":"搜索","permalink":"https://www.itnxd.cn/tags/%E6%90%9C%E7%B4%A2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-78. 子集","slug":"LeetCode刷题-78-子集","date":"2020-07-23T02:52:04.000Z","updated":"2020-07-23T10:27:12.221Z","comments":true,"path":"posts/61204.html","link":"","permalink":"https://www.itnxd.cn/posts/61204.html","excerpt":"","text":"题目链接：78. 子集 题解： 与之前的题几乎一致：AcWing-92.递归实现指数型枚举 题目简述：给定一个集合，枚举所有子集，包括空集！ 题解一：使用二进制和之前题一样，做法一模一样： 每个数选与不选两种情况，一共有0 ~ 1 &lt;&lt; nums.size() - 1种情况，枚举每个二进制位是否为1即可！ 时间复杂度： 一共枚举2n 个数，每个数枚举n位，总时间复杂度为 O(2n * n) 注意： 当 n &gt;= 30时，2n &gt; 109 会超时 AC代码一：12345678910111213class Solution {public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; res; for(int state = 0; state &lt; 1 &lt;&lt; nums.size(); state ++){ vector&lt;int&gt; path; for(int k = 0; k &lt; nums.size(); k++) if(state &gt;&gt; k &amp; 1) path.push_back(nums[k]); res.push_back(path); } return res; }}; 题解二：使用DFS思路： 使用for循环分别去搜索位数为0 ~ nums.size()的序列 dfs(int u, int cnt, int start)：参数分别为 目标位数，当前第几位，下一次的起始位置（防止重复） AC代码二：1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;int&gt; nums; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; _nums) { nums = _nums; sort(nums.begin(), nums.end()); for(int i = 0; i &lt;= nums.size(); i++) dfs(i, 0, 0); return res; } void dfs(int u, int cnt, int start){ if(cnt == u){ res.push_back(path); return; } for(int i = start; i &lt; nums.size(); i++){ path.push_back(nums[i]); dfs(u, cnt + 1, i + 1); path.pop_back(); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-77. 组合","slug":"LeetCode刷题-77-组合","date":"2020-07-23T02:51:52.000Z","updated":"2020-07-23T10:27:12.219Z","comments":true,"path":"posts/14686.html","link":"","permalink":"https://www.itnxd.cn/posts/14686.html","excerpt":"","text":"题目链接：77. 组合 题解： 简单递归！ 题目简述：在 n 个数选取 k 个数的组合！ 题解：DFS思路：dfs(int u, int start) u：记录当前搜到了第几个数 start：记录当前数的开始位置，即从上一个数的后一个开始，有效避免重复 res累积答案，path保存每一组合法序列！ 递归出口：u == k 搜完u个数即终止！ 时间复杂度： 方案数为 O(Cnk )，每个方案需要O(k)，总时间复杂度为O(Cnk * k) AC代码：12345678910111213141516171819202122class Solution {public: int n, k; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; combine(int _n, int _k) { n = _n, k = _k; dfs(0, 1); return res; } void dfs(int u, int start){ if(u == k){ res.push_back(path); return; } for(int i = start; i &lt;= n; i++){ path.push_back(i); dfs(u + 1, i + 1); path.pop_back(); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-76. 最小覆盖子串","slug":"LeetCode刷题-76-最小覆盖子串","date":"2020-07-23T02:51:41.000Z","updated":"2020-07-23T10:27:12.206Z","comments":true,"path":"posts/59607.html","link":"","permalink":"https://www.itnxd.cn/posts/59607.html","excerpt":"","text":"题目链接：76. 最小覆盖子串 题解： 滑动窗口界的一大难题！ 题目简述：给定两个字符串，从一个串找到包含另一个字符串所有字符的子串，并找到最短的一个！ 题解：双指针算法： 两个指针都从起点从左向右，i指针指向该区间终点，j指针指向该区间起点，维护一段区间i ~ j使得该区间包含待匹配字符串的每个字符。 具体做法： 为了判断该区间是否包含待匹配字符串的每个字符，我们使用一个哈希表动态存储该区间每个字符出现的次数 使用变量cnt统计该区间有效字符个数（即待匹配字符串中对应匹配的字符），只要该区间当前字符个数小于等于待匹配字符串的当前字符个数，即为有效字符，进行统计，即hs[s[j]] &lt;= ht[s[j]] 维护起点j，若新加入的字符导致hs[s[j]] &gt; ht[s[j]]，则说明起点j可以后移，即hs[s[j ++ ]] --，还得保证起点j一定是一个合法字符（即起点一定不是待匹配字符串没有的字符，如：ADOBECODEBA 匹配 ABC，应该要将起点A删去，再将DOBECODE删去。剩下BA，即这里是需要while来控制的） 当cnt == t.size()：即该区间已经匹配，进行更新res即可，res为空也要更新！ 使用双指针算法的条件：一定要有单调性，即一个指针后移，另一个指针也要后移！ 对于本题：i' &lt; i, j &lt; j'时，当i向后走到i'，由于原来的j ~ i已经匹配，所以j一定不会往前走到j'，即j一定会不动或者向后走，这样就保证了单调性！ 时间复杂度： O(n) AC代码：12345678910111213141516171819class Solution {public: string minWindow(string s, string t) { unordered_map&lt;char, int&gt; hs, ht; for(auto&amp; c : t) ht[c] ++; int cnt = 0; string res; for(int i = 0, j = 0; i &lt; s.size(); i ++){ hs[s[i]] ++; if(hs[s[i]] &lt;= ht[s[i]]) cnt ++; while(hs[s[j]] &gt; ht[s[j]]) hs[s[j ++ ]] --; if(cnt == t.size()){ if(res.empty() || i - j + 1 &lt; res.size()) res = s.substr(j, i - j + 1); } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://www.itnxd.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-75. 颜色分类","slug":"LeetCode刷题-75-颜色分类","date":"2020-07-22T14:26:43.000Z","updated":"2020-07-23T10:27:12.216Z","comments":true,"path":"posts/3416.html","link":"","permalink":"https://www.itnxd.cn/posts/3416.html","excerpt":"","text":"题目链接：75. 颜色分类 题解： 通过双指针思路将区间划分开，并进行维护区间操作！ 题目简述：给定0、1、2三个数字的乱序序列，按照0，1，2的顺序将相同数字排到一起！ 要求不使用排序函数！ 题解：思路：双指针，其实是三指针，i和j 从前往后扫描，k从后往前扫描，维护下面三个区间 0 ~ j - 1：保证都是0 j ~ i - 1：保证都是1 nums.size() - 1 ~ k + 1：保证都是2 i和k相遇即排好序！ nums[i]的三种情况： nums[i] == 0：swap(nums[j++], nums[i++]) 交换后i位置为1，可以直接往后走，即i++ nums[i] == 1：该位置属于为1的区间，直接i后移，即i++ nums[i] == 2：swap(nums[i], nums[k--]) 交换后i位置未知，不可以直接往后走 时间复杂度： O(n) AC代码：12345678910class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { for(int i = 0, j = 0, k = nums.size() - 1; i &lt;= k;){ if(nums[i] == 0) swap(nums[i++], nums[j++]); else if(nums[i] == 2) swap(nums[i], nums[k--]); else i++; } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"三指针","slug":"三指针","permalink":"https://www.itnxd.cn/tags/%E4%B8%89%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-74. 搜索二维矩阵","slug":"LeetCode刷题-74-搜索二维矩阵","date":"2020-07-22T14:26:29.000Z","updated":"2020-07-23T10:27:12.225Z","comments":true,"path":"posts/59764.html","link":"","permalink":"https://www.itnxd.cn/posts/59764.html","excerpt":"","text":"题目链接：74. 搜索二维矩阵 题解： 二维的二分，第一次见，其实可以通过取除和取余转换为一维！ 题目简述：给定一个二维有序矩阵，从左到右，从上到下，都是升序序列，每行最末小于下一行最开始！ 判断知否存在一个目标值！ 题解：嗯，暴力，使用额外数组将二维变为一维！ 再进行二分！ 二分条件：v[mid] &gt;= target 注意： 对空矩阵判断，两种情况[]，[[]]，所以需要matrix.empty() || matrix[0].empty() 其实可以将一个0 ~ n * m - 1的数转变为一个二维下标的： matrix[mid / m][mid % m]：第一个算行，第二个算列即可！ 详细代码见AC代码二！ AC代码一：暴力12345678910111213141516171819class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { if(matrix.empty() || matrix[0].empty()) return false; int n = matrix.size(), m = matrix[0].size(); vector&lt;int&gt; v(n * m); int k = 0; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) v[k++] = matrix[i][j]; int l = 0, r = k - 1; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(v[mid] &gt;= target) r = mid; else l = mid + 1; } return v[r] == target; }}; AC代码二：正解1234567891011121314class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { if(matrix.empty() || matrix[0].empty()) return false; int n = matrix.size(), m = matrix[0].size(); int l = 0, r = n * m - 1; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(matrix[mid / m][mid % m] &gt;= target) r = mid; else l = mid + 1; } return matrix[r / m][r % m] == target; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"},{"name":"二维二分","slug":"二维二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E7%BB%B4%E4%BA%8C%E5%88%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-73. 矩阵置零","slug":"LeetCode刷题-73-矩阵置零","date":"2020-07-22T14:26:14.000Z","updated":"2020-07-23T10:27:12.199Z","comments":true,"path":"posts/11107.html","link":"","permalink":"https://www.itnxd.cn/posts/11107.html","excerpt":"","text":"题目链接：73. 矩阵置零 题解： LeetCode题目总是要求不使用额外空间。。导致这道题做法就特别取巧，不好想！ 题目简述：给定一个矩阵只有0和其他数，将是0的对应的改行与该列都变为0！ 要求不使用额外空间！ 题解：本来这题开一个数组即可，非要求原地处理。。。 现在给出空间O(1)的算法： 使用两个变量r0和c0分别记录第一列和第一行是否有0 使用矩阵的第一行matrix[0][j]记录第j列是否有0（j 的范围为 1 - m - 1) 使用矩阵的第一列matrix[i][0]记录第i行是否有0 （i 的范围为 1 - n - 1) 现在就可以根据上面的记录去处理每一行和每一列了！ 时间复杂度： O(n * m) AC代码：12345678910111213141516171819202122232425262728293031class Solution {public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if(matrix.empty()) return; int n = matrix.size(), m = matrix[0].size(); int r0 = 1, c0 = 1; for(int i = 0; i &lt; n; i++) if(!matrix[i][0]) r0 = 0; for(int i = 0; i &lt; m; i++) if(!matrix[0][i]) c0 = 0; for(int i = 1; i &lt; n; i++) for(int j = 0; j &lt; m; j++) if(!matrix[i][j]) matrix[i][0] = 0; for(int i = 1; i &lt; m; i++) for(int j = 0; j &lt; n; j++) if(!matrix[j][i]) matrix[0][i] = 0; for(int i = 1; i &lt; n; i++) if(!matrix[i][0]) for(int j = 0; j &lt; m; j++) matrix[i][j] = 0; for(int i = 1; i &lt; m; i++) if(!matrix[0][i]) for(int j = 0; j &lt; n; j++) matrix[j][i] = 0; if(!r0) for(int i = 0; i &lt; n; i++) matrix[i][0] = 0; if(!c0) for(int i = 0; i &lt; m; i++) matrix[0][i] = 0; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"取巧算法","slug":"取巧算法","permalink":"https://www.itnxd.cn/tags/%E5%8F%96%E5%B7%A7%E7%AE%97%E6%B3%95/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-72. 编辑距离","slug":"LeetCode刷题-72-编辑距离","date":"2020-07-22T14:26:00.000Z","updated":"2020-07-23T10:27:12.211Z","comments":true,"path":"posts/60666.html","link":"","permalink":"https://www.itnxd.cn/posts/60666.html","excerpt":"","text":"题目链接：72. 编辑距离 题解： 动态规划应用，很有意思！ 题目简述：将一个单词变为另一个单词，只有三种操作，替换，删除，插入！问最少步数！ 题解：动态规划： 状态表示： 两个字符串，使用二维数组f[i][j]表示a字符串的的0 - i和b字符串的 0 - j匹配时的最少步数！ 状态计算： 处理最后一步， 三种情况 删除一个字符：f[i][j] = f[i - 1][j] + 1 即a字符串删除一个会匹配，则a字符串的前i - 1个是和b字符串的前j个匹配，所以当前最少步数就是该匹配最少步数加一（当前删除操作的一步） 插入一个字符：f[i][j] = f[i][j - 1] + 1 解释：与上面同理 替换一个字符：两种情况 a[i] == b[j]：即该字符已经匹配无需替换，f[i - 1][j - 1] + 0 a[i] != b[j]：即该字符已经匹配需要替换，f[i - 1][j - 1] + 1 综上所述： 状态转移方程为：f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1; f[i][j] = min(f[i][j], f[i - 1][j - 1] + t); 最终答案： f[n][m] 表示a字符串变为b字符串的最少步数！ 初始化： f[i][0] = i, f[0][j] = j 即一个为空，一个不空，则最少需要不空的长度才可以转变为一样 注意： 为了不对边界0的处理，字符串都在最前端加一个空格！ 时间复杂度： O(n) AC代码：123456789101112131415161718class Solution {public: int minDistance(string a, string b) { int n = a.size(), m = b.size(); a = ' ' + a, b = ' ' + b; vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1)); for(int i = 0; i &lt;= n; i++) f[i][0] = i; for(int i = 0; i &lt;= m; i++) f[0][i] = i; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1; int t = a[i] == b[j] ? 0: 1; f[i][j] = min(f[i][j], f[i - 1][j - 1] + t); } } return f[n][m]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-71. 简化路径","slug":"LeetCode刷题-71-简化路径","date":"2020-07-22T14:25:39.000Z","updated":"2020-07-23T10:27:12.203Z","comments":true,"path":"posts/59982.html","link":"","permalink":"https://www.itnxd.cn/posts/59982.html","excerpt":"","text":"题目链接：71. 简化路径 题解： 模拟题，总是处理两个斜杠中间字符！ 题目简述：给定一个绝对路径，该绝对路径以/开始，不一定以/结束，并且可能会出现连续斜杠，要求转换为最简的路径！ ./：当前目录 ../：上层目录 根目录没有上层目录，仍为根目录 题解：思路： 将两个斜杠中间的字符截取出来，进行判断 答案的格式保证一定是/xxx/xxx... .：即为当前目录，不处理，跳过即可 ..：即返回上一层目录，将当前答案字符串res从后向前删到第一个斜杠，再将此处斜杠删掉（保证不越界） 空：即两个斜杠挨着，不处理，跳过 目录名：合法目录，将在答案最后加一个斜杠，再加上当前目录名 /：即累积的中间字符结束 注意： 以防给定的绝对路径最后不是空格，导致最后一组斜杠中间的字符无法截取，我们给最后没有斜杠的绝对路径加一个斜杠进行统一！ 每次将name字符串清空 对于在根目录进行上层操作的行为，会使得最后答案为空，所以在最后判断一下是否为空，是则返回一个斜杠！ string的back()和pop_back()属于C++ 11 标准！ AC代码：12345678910111213141516171819202122class Solution {public: string simplifyPath(string path) { string res, name; if (path.back() != '/') path += '/'; for (auto c : path) { if (c != '/') name += c; else { if (name == \"..\") { while (res.size() &amp;&amp; res.back() != '/') res.pop_back(); if (res.size()) res.pop_back(); } else if (name != \".\" &amp;&amp; name != \"\") { res += '/' + name; } name.clear(); } } if (res.empty()) res = \"/\"; return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"}],"author":"Mr.Niu"},{"title":"蓝桥杯省赛-1207. 大臣的旅费","slug":"蓝桥杯省赛-1207-大臣的旅费","date":"2020-07-21T09:57:22.000Z","updated":"2020-07-21T13:41:29.829Z","comments":true,"path":"posts/61315.html","link":"","permalink":"https://www.itnxd.cn/posts/61315.html","excerpt":"","text":"题目链接：蓝桥杯省赛-1207. 大臣的旅费 题目来源：第四届蓝桥杯省赛C++A组 题解： 本题用到了许多知识！下面给出参考教程及必备知识！ 链式前向星：我的简单总结！点击这里！ 树的直径及树形DP：秦淮岸灯火阑珊大佬的数的直径及树形DP讲义！点击这里！ 秦淮岸大佬讲义对应视频：点击这里！ 两次BFS搜索：DaulFrank大佬的两次BFS搜索！点击这里！ 两次DFS搜索：小呆呆大佬的两次DFS搜索！点击这里！ 两次搜索与树形DP区别： 两次搜索可以求出数的直径的路径与值！写起来略麻烦！ 树形DP仅仅可以求出值！写起来简单！ 知识积累一：树的直径首先先引入圆的直径： 圆的直径就是圆上两点连线的最长的时候，所以树的直径就是树上最远两个点的距离！ 官方解释： 在一棵树中，每一条边都有权值，树中的两个点之间的距离，定义为连接两点的路径上边权之和，那么树上最远的两个点，他们之间的距离，就被称之为，树的直径。 树的直径的别称，树的最长链。 请注意：树的直径，还可以认为是一条路径，不一定是只是一个数值。 稍做解释： 当树的边权都为1或者没有边权时，即为树的最长连 当树的边权不都为1时，树的直径为一条路径上的边权之和最大的那条 知识积累二：树形DP主要用来求树的直径！ 树形DP定义： 设1号节点为根节点，那么一张N个点，N−1条边的无向图,我们可以认为它是一棵有根树。 我们不妨设dis[x]表示从节点x出发，以x为根的子树，能过到达最远节点的距离。 也就是对于x节点而言的最长链。（注意：此处x到达的只能是孩子节点，不能到达父节点） 做一个规约： 父节点为 x 子节点为 y dis[x]表示从x节点出发的最长链的边权和 ver[i]表示以i为终点的边权 res 表示树的直径，即最大的边权之和 接下来继续： 状态表示： dis[x] 含义见上面！ 转态计算：dis[x] = max(dis[x], dis[y] + ver[i]) 简单解释：从x出发的最长链 = 从儿子节点出发的最长链 + 父亲到儿子的距离 并且最后取一个最大值（即找一边权和最大的） 再看此时的数的直径如何计算？ *先给出结论：数的直径 = 最长链 + 次长链 即 res = max(res, dis[x] + dis[y] + ver[i]); * 简单解释： 从一个节点出发的最长链和次长链的和就是一条待选择的，所有节点的最长链和次长链的和的最大值即为树的直径！ 对于最长链和次长链的两种情况： dis[x] &lt; dis[y] + ver[i]：即当前儿子的路径更长，由于原来最长为dis[x]，现在儿子最长，则最长链：dis[y] + ver[i]； 次长链为：dis[x] dis[x] &gt; dis[y] + ver[i]：即当前儿子的路径不如父亲长，此时：最长链：dis[x] 次长链：？dis[y] + ver[i]是吗？不是的，此时的儿子还不一定遍历完了，所以，此时的儿子这条路径可能为第二长，第三长 …… 对于第一种情况：res = dis[x] + dis[y] + ver[i] 对于第二种情况：res = dis[x] + dis[y] + ver[i] （虽然此时的儿子路径不一定是次长，但是后面遍历的过程会逐渐更新） 此时的y指的是x的所有儿子节点，所以最终数的直径为：res = max(res, dis[x] + dis[y] + ver[i]) 注意点： 下面代码顺序不能换，一定要先搜索到根节点，然后先更新树的直径，再更新父节点的边权！ 后两句顺序反了会导致父节点先更新，答案树的直径逻辑就不对了！ 123dp(y);res = max(res, dis[x] + dis[y] + ver[i]);dis[x] = max(dis[x], dis[y] + ver[i]); 模板：树的直径下面的例题就是树的直径模板题！ 代码见 AC代码一 ！ 题目简述：给定n个节点，n - 1条边的带权无向图，问从一个节点到另一个节点的最大边权之和的路径的路费！ 对于路费：如果边权之和为1 则路费为11 边权和为 2 路费为 11 + 12 ….类似 即 11 + 12 + 13 + 14…….. 题解一：树形DP有了上面两个知识积累，会发现这个题就是让你求数的直径，然后将数的直径转换为路费即可！ 对于路费：是一个以11为首相，1为公差，项数为树的直径的等差数列，求和公式为 res * 11 + res * (res - 1ll) / 2 注意： 防止结果溢出，使用1ll强转一下 无向图，需要正反存储两次边 正反存储两次边，所以对于链式前向星存储，每条边的编号tot的范围为 2 * (n - 1) 一条边需要两个编号（正反向），所以edge ver Next数组都是2倍空间！ 注意链式前向星head数组的初始化，即最开始邻接表都指向-1 时间复杂度： $O(n)$ AC代码一：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int head[N], edge[N * 2], ver[N * 2], Next[N * 2], n, tot;int vis[N], dis[N], res;void add(int u, int v, int w){ edge[tot] = v; ver[tot] = w; Next[tot] = head[u]; head[u] = tot++;}void dp(int x){ vis[x] = 1; for(int i = head[x]; ~i; i = Next[i]){ int y = edge[i]; if(vis[y]) continue; dp(y); res = max(res, dis[x] + dis[y] + ver[i]); dis[x] = max(dis[x], dis[y] + ver[i]); }}int main(){ cin &gt;&gt; n; memset(head, -1, sizeof head); for(int i = 0; i &lt; n - 1; i++){ int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, w); } dp(1); printf(\"%lld\\n\", res * 11 + res * (res - 1ll) / 2); return 0;} 知识积累三：两次搜索两次搜索思量： 随便选一点x开始搜索，找到离当前点最远的y 从y开始搜索，找到离当前节点最远的z y到z的路径就是树的直径！ 由于是搜索，是可以记录路径的！ 证明： y一定是树的直径的一个端点 仍然使用反证法： 假设：y不是树的直径的一个端点，且 u - v 为树的直径！ 默认条件： 离 x 最远的节点为 y 情况一： x - y 与 u - v有交点，且 离 x 最远的节点为 y，则： 123451 + 4 &gt;= 1 + 3即 3 &lt;= 43 + 2 &lt;= 4 + 2即 u - v 不一定最长若u - v 为直径，则u - y, v - y 都是直径，与假设矛盾， 即y一定是树的直径的一个端点！ 情况二： x - y 与 u - v没有交点，且 离 x 最远的节点为 y，则： 1234561 + 2 &gt;= 1 + 3 + 5即 2 &gt;= 3 + 52 + 3 &gt; 52 + 3 + 4 &gt; 5 + 4即 u - v 一定不是最长与假设矛盾，从y出发一定有比 u - v更长的路径，如 2 - 3 - 4 、2 - 3 - 5 终上所述： 从一个点搜索到距离最远的点，改点一定是树的直径的一个端点！ 从树的直径出发搜一个最远的点，一定是树的直径！ 题解二：两次DFS搜索使用DFS搜索：两种方法，建议使用第二种，少开辟一个数组，并且减少一次初始化操作！ void dfs(int x, int distance) ：参数为父节点和当前已经累积的距离 void dfs(int x, int father, int distance)：参数为父节点和当前节点的父节点，以及当前已经累积的距离 搜索入口：dfs(1, -1, 0) 以1号边为根节点开始搜索，根节点没有父节点为-1 简单的思路： 从根节点开始，往下搜索一个儿子就将当前儿子的权累加父节点，直到搜完节点，得到每个叶子节点从根到自己的权之和！ 遍历一次每个节点，找到从根节点最远的节点，即dis数组最大的那个节点的下标即可！ 再从当前最大权的节点搜索一次，找到离当前端点最远的节点即可！ 再次遍历一次每个及诶单，找到该最远的节点！ 等差求和 注意： 第二次搜索dis数组不需要初始化，因为下一次搜索会全部进行覆盖！ 时间复杂度： $O(n)$ AC代码二：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// 使用vis数组判断 第二次搜索需要初始化一次该数组#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int head[N], edge[N * 2], ver[N * 2], Next[N * 2], n, tot;int vis[N], dis[N], res;void add(int u, int v, int w){ edge[tot] = v; ver[tot] = w; Next[tot] = head[u]; head[u] = tot++;}void dfs(int x, int distance){ dis[x] = distance; vis[x] = 1; for(int i = head[x]; ~i; i = Next[i]){ int j = edge[i]; if(vis[j]) continue; dfs(j, distance + ver[i]); }}int main(){ cin &gt;&gt; n; memset(head, -1, sizeof head); for(int i = 0; i &lt; n - 1; i++){ int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, w); } dfs(1, 0); int u = 1; for(int i = 1; i &lt;= n; i++) if(dis[i] &gt; dis[u]) u = i; memset(vis, 0, sizeof vis); dfs(u, 0); for(int i = 1; i &lt;= n; i++) res = max(res, dis[i]); printf(\"%lld\\n\", res * 11 + res * (res - 1ll) / 2); return 0;}/************************************************************************************************//************************************************************************************************/// 不使用vis数组 使用father变量判断#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int head[N], edge[N * 2], ver[N * 2], Next[N * 2], n, tot;int vis[N], dis[N], res;void add(int u, int v, int w){ edge[tot] = v; ver[tot] = w; Next[tot] = head[u]; head[u] = tot++;}void dfs(int x, int father, int distance){ dis[x] = distance; for(int i = head[x]; ~i; i = Next[i]){ int y = edge[i]; if(y == father) continue; dfs(y, x, distance + ver[i]); }}int main(){ cin &gt;&gt; n; memset(head, -1, sizeof head); for(int i = 0; i &lt; n - 1; i++){ int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, w); } dfs(1, -1, 0); int u = 1; for(int i = 1; i &lt;= n; i++) if(dis[i] &gt; dis[u]) u = i; dfs(u, -1, 0); for(int i = 1; i &lt;= n; i++) res = max(res, dis[i]); printf(\"%lld\\n\", res * 11 + res * (res - 1ll) / 2); return 0;} 题解三：两次BFS搜索两次BFS搜索： 思路： 与两次DFS思想一致，走到儿子就更新儿子的权，下方BFS过程也是一个标准过程！ 先进行vis 和 dis数组的初始化 随便一个节点进行搜索 将当前节点假如队列，标记使用过 出队列，将当前队首的所有没有访问过的儿子节点进队 更新儿子节点的权为父节点权与当前路径之和，即 dis[y] = dis[x] + ver[i]; 为了减少最后的扫描，可以在其中进行统计最大权的下标max_i 标记儿子用过，儿子入队 队列为空结束 从最大权的下标max_i开始第二次搜索找到树的直径的终点！ 等差求和 时间复杂度： $O(n)$ AC代码三：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// https://www.acwing.com/solution/content/7896/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int head[N], edge[N * 2], ver[N * 2], Next[N * 2], n, tot;int vis[N], dis[N], res;void add(int u, int v, int w){ edge[tot] = v; ver[tot] = w; Next[tot] = head[u]; head[u] = tot++;}int bfs(int u){ queue&lt;int&gt; q; memset(vis, 0, sizeof vis); memset(dis, 0, sizeof dis); int max_i; q.push(u); vis[u] = 1; while(q.size()){ int x = q.front(); q.pop(); for(int i = head[x]; ~i; i = Next[i]){ int y = edge[i]; if(vis[y]) continue; dis[y] = dis[x] + ver[i]; if(dis[y] &gt; res){ res = dis[y]; max_i = y; } vis[y] = 1; q.push(y); } } return max_i;}int main(){ cin &gt;&gt; n; memset(head, -1, sizeof head); for(int i = 0; i &lt; n - 1; i++){ int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w), add(v, u, w); } int u = bfs(1); bfs(u); printf(\"%lld\\n\", res * 11 + res * (res - 1ll) / 2); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://www.itnxd.cn/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[{"name":"树的直径","slug":"树的直径","permalink":"https://www.itnxd.cn/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"两次搜索","slug":"两次搜索","permalink":"https://www.itnxd.cn/tags/%E4%B8%A4%E6%AC%A1%E6%90%9C%E7%B4%A2/"},{"name":"树形DP","slug":"树形DP","permalink":"https://www.itnxd.cn/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"链式前向星","slug":"链式前向星","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-70. 爬楼梯","slug":"LeetCode刷题-70-爬楼梯","date":"2020-07-20T13:46:14.000Z","updated":"2020-07-21T03:10:22.374Z","comments":true,"path":"posts/42551.html","link":"","permalink":"https://www.itnxd.cn/posts/42551.html","excerpt":"","text":"题目链接：70. 爬楼梯 题解： 简单动态规划问题！ 题目简述：每次只能爬一个台阶或两个台阶，求爬到第 n 个台阶的方案数！ 题解：动态规划： 状态表示：f[i]表示爬到第 i 个台阶的方案数 状态计算：f[i] = f[i - 1] + f[i - 2] 简单解释：爬到第 i 个台阶的最后一步，一定是跨了一步或跨了两步，所以到达当前台阶的方案数一定是前 i - 1个台阶的方案数和前 i - 2 个台阶的方案数之和！ 初始转态： f[0] = 1 f[1] = 1 最终结果： f[n] 优化一下，不开辟数组，降低空间复杂度，只使用三个变量即可，如下！ 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ AC代码：123456789101112131415161718192021class Solution {public: int cnt; int climbStairs(int n) { // vector&lt;int&gt; f(n + 1); // f[0] = 1; // f[1] = 1; // for(int i = 2; i &lt;= n; i++){ // f[i] = f[i - 1] + f[i - 2]; // } // return f[n]; int a = 1, b = 1, c; if(n &lt;= 1) return 1; for(int i = 2; i &lt;= n; i++){ c = a + b; a = b; b = c; } return c; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-69. x 的平方根","slug":"LeetCode刷题-69-x-的平方根","date":"2020-07-20T13:46:00.000Z","updated":"2020-07-21T03:10:22.373Z","comments":true,"path":"posts/15768.html","link":"","permalink":"https://www.itnxd.cn/posts/15768.html","excerpt":"","text":"题目链接：69. x 的平方根 题解： 二分应用求平方根！一定要斟酌好使用哪个模板！ 题目简述：开平方，小数部分舍去求整数部分！ 题解：使用二分解决，一定要选对模板！ 选不对模板，会有特别情况需要去处理！ AC代码一：二分模板一防止溢出，加一个 1ll条件：mid &lt;= x / mid （不要使用mid * mid会溢出）最终找到的是小于等于根号x的最大整数！ 123456789101112class Solution {public: int mySqrt(int x) { int l = 0, r = x; while(l &lt; r){ int mid = l + r + 1ll &gt;&gt; 1; if(mid &lt;= x / mid) l = mid; else r = mid - 1; } return r; }}; AC代码二：二分模板二防止溢出，加一个 0ll条件：mid &gt;= x / mid （不要使用mid * mid会溢出）最终找到的是大于等于根号x的最小整数！（根号9 找到的是 3； 根号10 找到的是4） 使用此模板需要特判： x 为 0 或 1 进入while会成为死循环，特判返回x 如果针对根号10的情况，即r &gt; x / r 需要 r-- 1234567891011121314class Solution {public: int mySqrt(int x) { if(x &lt;= 1) return x; int l = 0, r = x; while(l &lt; r){ int mid = l + 0ll + r &gt;&gt; 1; if (mid &gt;= x / mid) r = mid; else l = mid + 1; } if(r &gt; x / r) r--; return r; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-68. 文本左右对齐","slug":"LeetCode刷题-68-文本左右对齐","date":"2020-07-20T13:45:42.000Z","updated":"2020-07-21T03:10:22.370Z","comments":true,"path":"posts/6698.html","link":"","permalink":"https://www.itnxd.cn/posts/6698.html","excerpt":"","text":"题目链接：68. 文本左右对齐 题解： 又是一道有点恶心的模拟题，刚开始竟然没有看懂题！ 题目简述：给定一堆单词，和一个最大长度，要求在不超过最大长度的条件下尽可能多放单词，并使得单词之间尽可能均匀分布！ 题解：题目解释： 假如一行放三个单词长度不超过最大长度，放四个超过了，则当前行只能放三个，还得保证三个单词之间的两个空隙尽可能相等（使用空格填充），如果无法相等，则保证左边的比右边的多一！ 举个例子： 该行最多放四个单词，总长为9， 最大长度为20，则剩余空格数为11个，要均匀分布到三个空隙，所以11 / 3 = 3 … 2 所以三个空隙空格数依次为：3 + 1， 3 + 1，4 即可！ 分析： 左对齐： 最后一行需要左对齐 某一行只有一个单词需要左对齐 左右对齐：一般情况，不是最后一行和不仅仅只有一个单词！ 具体做法： 先找到一行能放的最大长度，该长度包括两个单词间的一个空隙 若为一个单词或最后一行，即j == words.size() || j == i + 1，将单词间隔一个空隙，后面的位置填补空格 若为一般情况，需要计算空隙数cnt = j - i - 1以及剩余空格数maxWidth - len + cnt(因为len中已经包含了两个单词间的一个空隙，所以多减了，再加回来) 如果剩余空格和空隙无法平均分配，则将前面的多加一，即k &lt; blank % cnt，即空隙为string(blank / cnt + 1, ' ')；剩余的空隙为string(blank / cnt, ' ') 将当前行假如res 更新下一行起点为i = j AC代码：123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) { vector&lt;string&gt; res; for(int i = 0; i &lt; words.size();){ int j = i + 1; int len = words[i].size(); while(j &lt; words.size() &amp;&amp; len + 1 + words[j].size() &lt;= maxWidth) len += 1 + words[j++].size(); string line; // 最后一行或该行只有一个单词 左对齐 if(j == words.size() || j == i + 1){ line += words[i]; for(int k = i + 1; k &lt; j; k++) line += ' ' + words[k]; while(line.size() &lt; maxWidth) line += ' '; }else{ // 一般情况，左右对齐 // 空隙数 剩余空格数 int cnt = j - i - 1, blank = maxWidth - len + cnt; line += words[i]; int k = 0; while(k &lt; blank % cnt) line += string(blank / cnt + 1, ' ') + words[i + k + 1], k++; while(k &lt; cnt) line += string(blank / cnt, ' ') + words[i + k + 1], k++; } res.push_back(line); // 更新下一行起点 i = j; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-67. 二进制求和","slug":"LeetCode刷题-67-二进制求和","date":"2020-07-20T13:45:28.000Z","updated":"2020-07-21T03:10:22.371Z","comments":true,"path":"posts/15234.html","link":"","permalink":"https://www.itnxd.cn/posts/15234.html","excerpt":"","text":"题目链接：67. 二进制求和 题解： 类似于高精度加法！ 题目简述：两个二进制数的加法！ 题解：为了方便做加法，现将两个字符串倒序！ 模拟加法即可！ 循环终止条件：i &lt; a.size() || i &lt; b.size() || t 最终再次倒序，即为答案！ AC代码：12345678910111213141516class Solution {public: string addBinary(string a, string b) { reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); string res; for(int i = 0, t = 0; i &lt; a.size() || i &lt; b.size() || t; i++){ if(i &lt; a.size()) t += a[i] - '0'; if(i &lt; b.size()) t += b[i] - '0'; res += t % 2 + '0'; t /= 2; } reverse(res.begin(), res.end()); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"https://www.itnxd.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-66. 加一","slug":"LeetCode刷题-66-加一","date":"2020-07-20T13:45:14.000Z","updated":"2020-07-21T03:10:22.362Z","comments":true,"path":"posts/48186.html","link":"","permalink":"https://www.itnxd.cn/posts/48186.html","excerpt":"","text":"题目链接：66. 加一 题解： 简单题！ 题目简述：给定一个数字序列，最后一位加一，满十进一，求加一后的序列！ 题解：从最后一位开始，给他加一，然后更新当前位的值为digits[i] %= 10 t更新为digits[i] / 10 最后若进位到最前面，需要进行插入，即在最前面插入t即可! AC代码：12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { vector&lt;int&gt; res; int t = 1; for(int i = digits.size() - 1; i &gt;= 0; i--){ digits[i] += t; t = digits[i] / 10; digits[i] %= 10; } if(t) digits.insert(digits.begin(), t); return digits; }};// 几乎一样：class Solution {public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { vector&lt;int&gt; res; int t = 1; for(int i = digits.size() - 1; i &gt;= 0; i--){ t += digits[i]; digits[i] = t % 10; t /= 10; } if(t) digits.insert(digits.begin(), t); return digits; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-65. 有效数字","slug":"LeetCode刷题-65-有效数字","date":"2020-07-20T13:44:52.000Z","updated":"2021-02-06T14:43:33.221Z","comments":true,"path":"posts/47819.html","link":"","permalink":"https://www.itnxd.cn/posts/47819.html","excerpt":"","text":"题目链接：65. 有效数字 题解： 恶心人的字符串模拟题，边界条件一大堆！ 题目简述：判断一个字符串是否可以转化为数字！ 题解：步骤： 去掉首尾空格 若只有正负号，返回false 若只有一个.或者.e、.E都不成立，返回false 循环整个字符串： 对于.：若多于一个或者在e或E之后，返回false 对于e 或 E：e 或 E前后为空，或者多于一个，返回false 对于e 或 E：e 或 E后为正负号，且正负号后面没有数字，返回false 不是. e E 0-9：直接返回false 剩下其他情况合法，返回true 老多的边界条件！！！ AC代码：12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: bool isNumber(string s) { int i = 0, j = s.size() - 1; // 去掉前后空格 while(i &lt; s.size() &amp;&amp; s[i] == ' ') i++; while(j &gt;= 0 &amp;&amp; s[j] == ' ') j--; if(i &gt; j) return false; s = s.substr(i, j - i + 1); // 只有正负号 if(s[0] == '+' || s[0] == '-') s = s.substr(1); if(s.empty()) return false; // . .e .E 都不成立 if(s[0] == '.' &amp;&amp; (s.size() == 1 || s[1] == 'e' || s[1] == 'E')) return false; int dot = 0, e = 0; for(int i = 0; i &lt; s.size(); i++){ if(s[i] == '.'){ // 多余一个点或点在e之后 .2.3 3e5.2 if(dot &gt; 0 || e &gt; 0) return false; dot ++; }else if(s[i] == 'e' || s[i] == 'E'){ // e前为空 e后为空 e出现过 if(!i || i + 1 == s.size() || e &gt; 0) return false; // e后有正负号 if(s[i + 1] == '+' || s[i + 1] == '-'){ // e后正负号后没有数字 if(i + 2 == s.size()) return false; // 跳过正负号 i ++; } e ++; // 不是. e 0-9 }else if(s[i] &lt; '0' || s[i] &gt; '9') return false; } return true; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-64. 最小路径和","slug":"LeetCode刷题-64-最小路径和","date":"2020-07-20T13:44:50.000Z","updated":"2020-07-21T03:10:22.353Z","comments":true,"path":"posts/27804.html","link":"","permalink":"https://www.itnxd.cn/posts/27804.html","excerpt":"","text":"题目链接：64. 最小路径和 题解： 和前两道类似，同样使用动态规划！ 题目简述：给定一个方格，从左上走到右下，求最小代价！ 题解：动态规划： 状态表示： f[i][j]表示到达当前点的最小代价 状态计算： 在不越界的情况下 f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j] 初始转态：f[0][0] = gird[0][0] 最终结果：f[n - 1][m - 1] 时间复杂度： $O(n \\times m)$ AC代码：12345678910111213141516class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(), m = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m, INT_MAX)); f[0][0] = grid[0][0]; for(int i = 0; i &lt; n; i++){ for(int j =0; j &lt; m; j++){ if(i &amp;&amp; j) f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j]; else if(i) f[i][j] = f[i - 1][j] + grid[i][j]; else if(j) f[i][j] = f[i][j - 1] + grid[i][j]; } } return f[n - 1][m - 1]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-63. 不同路径 II","slug":"LeetCode刷题-63-不同路径-II","date":"2020-07-20T13:44:16.000Z","updated":"2021-02-06T14:43:03.243Z","comments":true,"path":"posts/8265.html","link":"","permalink":"https://www.itnxd.cn/posts/8265.html","excerpt":"","text":"题目链接：63. 不同路径 II 题解： 和上一道题相比多了一些障碍物设置，基本类似！ 题目简述：仍然是n * m的方格从左上到右下的路径数，路径中可能有障碍物！ 题解：动态规划： 状态表示：f[i][j]表示从起点到当前位置的路径数！ 状态计算：由于到当前位置只有两条路径，即上和左，所以状态转移方程为，f[i][j] = f[i - 1][j] + f[i][j - 1] 初始状态由path[0][0]决定，若起点有障碍物，则f[0][0]为0，且最终方案数为0 若终点path[n - 1][m - 1]有障碍物，则最终方案数为0 以上两种情况需要特判！ 最终结果：f[n - 1][m - 1] 与上一道题不同之处： 当前位置有了障碍物则到达当前位置的方案数为f[i][j] = 0 时间复杂度：$O(n \\times m)$ AC代码：1234567891011121314151617181920class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; path) { int n = path.size(), m = path[0].size(); vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m)); if(path[n - 1][m - 1] || path[0][0]) return 0; f[0][0] = 1; for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ if(path[i][j]){ f[i][j] = 0; continue; } if(i - 1 &gt;= 0) f[i][j] += f[i - 1][j]; if(j - 1 &gt;= 0) f[i][j] += f[i][j - 1]; } } return f[n - 1][m - 1]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-62. 不同路径","slug":"LeetCode刷题-62-不同路径","date":"2020-07-20T13:43:28.000Z","updated":"2020-07-21T03:10:22.357Z","comments":true,"path":"posts/21929.html","link":"","permalink":"https://www.itnxd.cn/posts/21929.html","excerpt":"","text":"题目链接：62. 不同路径 题解： 简单的动态规划题目！ 一个方格，算出从左上走到右下的不同方案数！ 题解一：直接爆搜，时间会爆炸的！ TLE代码：123456789101112131415161718class Solution {public: int cnt; int n, m; int uniquePaths(int _m, int _n) { n = _n, m = _m; dfs(1, 1); return cnt; } void dfs(int x, int y){ if(x &gt; n || y &gt; m) return; if(x == n &amp;&amp; y == m){ cnt ++; } dfs(x, y + 1); dfs(x + 1, y); }}; 题解二：使用动态规划： 状态表示：f[i][j]表示从起点到当前位置的路径数！ 状态计算：由于到当前位置只有两条路径，即上和左，所以状态转移方程为，f[i][j] = f[i - 1][j] + f[i][j - 1] 初始状态，f[0][0] = 1，最终结果：f[n - 1][m - 1] 注意：防止越界，进行一下特判！ 时间复杂度： O(n * m) AC代码：1234567891011121314class Solution {public: int uniquePaths(int m, int n) { vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m)); f[0][0] = 1; for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ if(i - 1 &gt;= 0) f[i][j] += f[i - 1][j]; if(j - 1 &gt;= 0) f[i][j] += f[i][j - 1]; } } return f[n - 1][m - 1]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-61. 旋转链表","slug":"LeetCode刷题-61-旋转链表","date":"2020-07-20T13:42:55.000Z","updated":"2020-07-21T03:10:22.359Z","comments":true,"path":"posts/20286.html","link":"","permalink":"https://www.itnxd.cn/posts/20286.html","excerpt":"","text":"题目链接：61. 旋转链表 题解： 直接移动 题目简述：将一个链表向后移动k个位置！ 题解一：暴力傻傻的移动k次即可，每次将倒数第一个节点指向最前面的头结点，倒数第二个节点指向空，完成一个交换即可！ 由于k太大，会导致超时，所以请看题解二！ TLE代码：1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* rotateRight(ListNode* head, int k) { auto dummy = new ListNode(-1); dummy-&gt;next = head; if(head == NULL) return head; for(int i = 0; i &lt; k; i++){ auto l = dummy; while(l-&gt;next-&gt;next) l = l-&gt;next; auto t = l-&gt;next; l-&gt;next = NULL; auto s = dummy-&gt;next; dummy-&gt;next = t; t-&gt;next = s; } return dummy-&gt;next; }}; 题解二：取余优化如果k是节点数的倍数，那么会发现我们做了倍数次重复操作。。。 所以直接对节点数取余，然后就是我们实际需要移动的次数！ 具体操作： 先遍历链表，计算节点数以及找到最后一个节点 若k是节点数的整数倍，直接返回原来的表头，即不需要移动，都是重复操作 否则，找到前len - k和后k位置，将二者交换即可！ 简单的链表连接操作，不说了！ AC代码：12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* rotateRight(ListNode* head, int k) { auto dummy = new ListNode(-1), l = dummy; dummy-&gt;next = head; if(head == NULL) return head; int len = 0; ListNode* tail; while(l-&gt;next){ l = l-&gt;next; tail = l; len++; } k %= len; if(k == 0) return head; l = dummy; for(int i = 0; i &lt; len - k; i++) l = l-&gt;next; tail-&gt;next = dummy-&gt;next; dummy-&gt;next = l-&gt;next; l-&gt;next = NULL; return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题- 60. 第k个排列","slug":"LeetCode刷题-60-第k个排列","date":"2020-07-20T13:42:25.000Z","updated":"2020-07-21T03:10:22.355Z","comments":true,"path":"posts/40239.html","link":"","permalink":"https://www.itnxd.cn/posts/40239.html","excerpt":"","text":"题目链接：60. 第k个排列 题解： 依次考虑每一位，很是巧妙的做法！ 题目简述：求一个序列字典序的第k个排列！ 题解一：直接使用全排列函数：next_permutation() 第k个序列，就是要循环k - 1次。 时间复杂度：$O(n! \\times k)$ AC代码一：1234567891011class Solution {public: string getPermutation(int n, int k) { string res; for(int i = 1; i &lt;= n; i++) res += i + '0'; for(int i = 0; i &lt; k - 1; i++){ next_permutation(res.begin(), res.end()); } return res; }}; 题解二：计数 思路： 从高到低依次考虑每一位 对于每一位，从小到大枚举没有使用过的数，确定当前位 看下方的一个例子：n = 4, k = 10 第一位放1，后面有3！= 6种情况，放2后面也有3！= 6种情况，而k = 10，所以第一位一定是2，k = 10 - 6= 4 第二位放1，后面有2！= 2种情况，放3后面也有2！= 2种情况，而k = 4，所以第二位一定是3， k = 4 - 2 = 2 第三位放1，后面有1！= 1种情况，放4后面也有1！= 1种情况，而k = 2，所以第三位一定是4，k = 2 - 1 = 1 第四位放1，后面有1种情况，而k = 1, 所以第四位一定是1，k = 1 时间复杂度：$O(n^2)$ 注意： else内进入后即已经找到当前为改填的数，标记为true后直接break！ AC代码二：12345678910111213141516171819202122class Solution {public: string getPermutation(int n, int k) { string res; vector&lt;bool&gt; vis(10); for(int i = 0; i &lt; n; i++){ int fact = 1; for(int j = 1; j &lt;= n - i - 1; j++) fact *= j; for(int j = 1; j &lt;= n; j++){ if(!vis[j]){ if(fact &lt; k) k -= fact; else { res += j + '0'; vis[j] = true; break; } } } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"全排列","slug":"全排列","permalink":"https://www.itnxd.cn/tags/%E5%85%A8%E6%8E%92%E5%88%97/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-59. 螺旋矩阵 II","slug":"LeetCode刷题-59-螺旋矩阵-II","date":"2020-07-09T13:40:21.000Z","updated":"2020-07-21T03:10:22.349Z","comments":true,"path":"posts/63939.html","link":"","permalink":"https://www.itnxd.cn/posts/63939.html","excerpt":"","text":"题目链接：59. 螺旋矩阵 II 题解： 螺旋矩阵问题，和上一个基本类似。 题目简述：给定一个数字 n，按照从右、下、左、上的顺序生成一个螺旋矩阵！ 题解：和54题-螺旋矩阵类似，同样使用两个方向数组，参考上一篇题解，同样是一个方向走到不能走就换方向。 此处的res数组存储每个位置要填的值！ AC代码：12345678910111213141516171819class Solution {public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n)); int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(n)); for(int i = 1, x = 0, y = 0, d = 0; i &lt;= n * n; i++){ res[x][y] = i; vis[x][y] = true; int a = x + dx[d], b = y + dy[d]; if(a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n || vis[a][b]){ d = (d + 1) % 4; a = x + dx[d], b = y + dy[d]; } x = a, y = b; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-58. 最后一个单词的长度","slug":"LeetCode刷题-58-最后一个单词的长度","date":"2020-07-08T13:47:51.000Z","updated":"2020-07-08T14:45:19.089Z","comments":true,"path":"posts/33807.html","link":"","permalink":"https://www.itnxd.cn/posts/33807.html","excerpt":"","text":"题目链接：58. 最后一个单词的长度 题解： 简单题！ 题目简述：返回最后一个字符串的长度！ 题解：思路： 先将末尾多余的空格过滤掉！ 再从后往前扫描，进行统计，直到遇到第一个空格为止！ 注意： 特判字符串为空的情况！ AC代码：1234567891011121314class Solution {public: int lengthOfLastWord(string s) { if(s.size() == 0) return 0; int res = 0; int n = s.size() - 1; while(n &amp;&amp; s[n] == ' ') n--; for(int i = n; i &gt;= 0; i--){ if(s[i] == ' ') return res; res ++; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-57. 插入区间","slug":"LeetCode刷题-57-插入区间","date":"2020-07-08T13:47:29.000Z","updated":"2020-07-08T14:45:19.085Z","comments":true,"path":"posts/4935.html","link":"","permalink":"https://www.itnxd.cn/posts/4935.html","excerpt":"","text":"题目链接：57. 插入区间 题解： 看似和上一题区间合并类似，实则没什么关系！ 题目简述：给一个按照区间左端点排序的列表，给定一个待插入区间，使得插入后，没有重叠元素！ 题解：由于已经排好序了，所以我们就不需要排序了！ 分三段处理： 找到可以插入待插入区间的上一个区间，即从开始到该区间是不需要参与合并的，即a[k][1] &lt; b[0] 找到可以和待插入区间合并的区间的最后一个区间，即a[k][0] &lt;= b[1]，不断更新待插入区间的右端点，直到无法合并结束，此时区间为待插入区间 最后一段就是剩下的区间了，按顺序插入即可 看一下简图： 注意： 处理第二段不要越界，即k &lt; a.size() 时间复杂度： 扫描一遍，为O(n) AC代码：123456789101112131415class Solution {public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; a, vector&lt;int&gt;&amp; b) { vector&lt;vector&lt;int&gt;&gt; res; int k = 0; while(k &lt; a.size() &amp;&amp; a[k][1] &lt; b[0]) res.push_back(a[k++]); if(k &lt; a.size()){ b[0] = min(a[k][0], b[0]); while(k &lt; a.size() &amp;&amp; a[k][0] &lt;= b[1]) b[1] = max(b[1], a[k++][1]); } res.push_back(b); while(k &lt; a.size()) res.push_back(a[k++]); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-56. 合并区间","slug":"LeetCode刷题-56-合并区间","date":"2020-07-08T13:46:14.000Z","updated":"2020-07-08T14:45:19.079Z","comments":true,"path":"posts/63206.html","link":"","permalink":"https://www.itnxd.cn/posts/63206.html","excerpt":"","text":"题目链接：56. 合并区间 题解： 区间合并问题，先人的总结，先按照左端点排序再进行合并！ 题目简述：给定一堆区间，将重叠的区间进行合并，重新返回！ 题解：思路： 按照左端点排序，左端点相同，按照右端点排序 使用l，r两个指针维护最大可拓展区间 若当前左端点严格大于右指针，说明当前区间无法和上一个区间合并，则将上一个区间保存起来，更新新的左右指针为当前区间 若当前左端点小于等于上一个区间，则说明当前区间可以与上一个区间进行合并，则更新最大可拓展区间的右端点（即右指针） 最后将最后一个区间也保存起来 稍做解释： 按左端点排序，再按右端点排序，那么如果有重叠部分的区间，该区间的左端点一定在上一个区间的左端点的后面！这样如果有重叠就合并，没有就插入新的容器！ 时间复杂度： 排序O(nlogn)，线性扫描O(n)，总时间复杂度为O(nlogn) 注意点： 特判为空的情况，直接返回 记得要把最后一个区间插入 vector进行排序默认按照第一个值，第二个值等等进行排序 AC代码：1234567891011121314151617class Solution {public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { vector&lt;vector&lt;int&gt;&gt; res; if(intervals.empty()) return res; sort(intervals.begin(), intervals.end()); int l = intervals[0][0], r = intervals[0][1]; for(int i = 1; i &lt; intervals.size(); i++){ if(intervals[i][0] &gt; r) { res.push_back({l, r}); l = intervals[i][0], r = intervals[i][1]; } else r = max(r, intervals[i][1]); } res.push_back({l, r}); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-55. 跳跃游戏 ","slug":"LeetCode刷题-55-跳跃游戏","date":"2020-07-07T06:11:12.000Z","updated":"2020-07-07T09:18:51.765Z","comments":true,"path":"posts/23034.html","link":"","permalink":"https://www.itnxd.cn/posts/23034.html","excerpt":"","text":"题目链接：55. 跳跃游戏 题解： 这个是45题跳跃游戏的简化版！ 题目简述：本题和 LeetCode刷题-45.跳跃游戏II一样，上一题是要计算到达终点的最小步数！本题不一定能走到终点，问是否能走到终点！ 题解一：首先：能跳到的位置一定是连续的一段，即某个位置跳不到，后面位置一定跳不到！ 反证法： 假如能跳到i + 1位置，跳不到i位置，那么跳到i + 1位置的位置应该在i位置之前，因为i位置无法跳到，无法从他开始跳，那么该位置可以调到i + 1一定可以跳到i，矛盾！假设不成立，即跳到的位置一定是连续的一段！ 解法，一模一样： 同样是具有单调性的动态规划，找到第一个可以到达当前位置i的位置即可！若last已经到了当前位置i，说明到不了当前位置i，也就到不了最后的终点，直接返回false 否则：说明全部点都能到达，返回true 时间复杂度：O(n) 空间复杂度：O(1) AC代码一：1234567891011class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for(int i = 1, last = 0; i &lt; n; i++){ while(last &lt; i &amp;&amp; last + nums[last] &lt; i) last++; if(last == i) return false; } return true; }}; 题解二：另一种解释：基本和题解一类似！ 使用j表示从可以跳到的最远位置，i表示扫描到的位置！ 若j &lt; i：说明当前能跳到的最远位置到不了i，即到不了终点，直接返回false 否则：更新j，即j = max(j, i + nums[i])，即从第i个位置可以跳多远，更新一下j 初始化：j = 0，能跳到的最远处为起点！ AC代码二：12345678910class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { for(int i = 0, j = 0; i &lt; nums.size(); i++){ if(j &lt; i) return false; j = max(j, i + nums[i]); } return true; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-54. 螺旋矩阵 ","slug":"LeetCode刷题-54-螺旋矩阵","date":"2020-07-07T06:10:12.000Z","updated":"2020-07-07T09:18:51.762Z","comments":true,"path":"posts/395.html","link":"","permalink":"https://www.itnxd.cn/posts/395.html","excerpt":"","text":"题目链接：54. 螺旋矩阵 题解： 又是旋转相关的模拟题！ 题目简述：给定一个矩阵，按照右下左上的顺序进行遍历！ 题解：枚举 n * m个点，按照右下左上的顺序循环进行，如螺旋般，一个方向走到头，换下一个方向！ 使用0,1,2,3分别表示四个方向，走到头就换一下方向，即d = (d + 1) % 4 使用dx和dy数组表示四个方向坐标的变化。 如果，坐标越界（第一次访问该方向），或者已经访问过的位置（不是第一次访问该方向），就要换到当前方向的下一个方向，同时更新当前坐标。即a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || vis[a][b] 注意：数组为空的判断！ AC代码：123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { vector&lt;int&gt; res; int n = matrix.size(); if(n == 0) return res; int m = matrix[0].size(); int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(m)); for(int i = 0, x = 0, y = 0, d = 0; i &lt; n * m; i++){ res.push_back(matrix[x][y]); vis[x][y] = true; int a = x + dx[d], b = y + dy[d]; if(a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || vis[a][b]){ d = (d + 1) % 4; a = x + dx[d], b = y + dy[d]; } x = a, y = b; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-53. 最大子序和 ","slug":"LeetCode刷题-53-最大子序和","date":"2020-07-07T06:09:12.000Z","updated":"2020-07-07T09:18:51.758Z","comments":true,"path":"posts/60904.html","link":"","permalink":"https://www.itnxd.cn/posts/60904.html","excerpt":"","text":"题目链接：53. 最大子序和 题解： 动态规划应用！ 题目简述：给定一个数组，找一个连续区间，使得该区间和最大！ 题解一：同样使用闫式DP分析法： 状态表示： f[i]表示以i位置结尾的区间的最大和 状态计算： f[i] = max(f[i - 1] + nums[i], nums[i]) 初始化： f[0] = nums[0]，res = nums[0] 稍做解释： f[i] nums[i] i - 1 ~ i,i - 2 ~ i……0 ~ i ，将最后一位i抛掉以后，剩下的其实就是f[i - 1]，此种情况的和为 f[i - 1] + nums[i] 最终就是：f[i] = max(f[i - 1] + nums[i], nums[i]) 时间复杂度：O(n) 空间复杂度：O(n) AC代码一：12345678910111213class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; f(nums.size()); int res = nums[0]; f[0] = nums[0]; for(int i = 1; i &lt; nums.size(); i++){ f[i] = max(f[i - 1] + nums[i], nums[i]); res = max(res, f[i]); } return res; }}; 题解二：优化空间占用会发现都是前后的关系：f[i - 1] f[i]，那么完全可以使用last变量来代替，而不去使用数组！ 注意：res 初始化为 极小值！ 时间复杂度：O(n) 空间复杂度：O(1) AC代码二：123456789101112class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int res = INT_MIN; for(int i = 0, last = 0; i &lt; nums.size(); i++){ // last = nums[i] + max(last, 0); last = max(last + nums[i], nums[i]); res = max(res, last); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-52. N皇后 II ","slug":"LeetCode刷题-52-N皇后-II","date":"2020-07-07T06:08:12.000Z","updated":"2020-07-07T09:18:51.755Z","comments":true,"path":"posts/47720.html","link":"","permalink":"https://www.itnxd.cn/posts/47720.html","excerpt":"","text":"题目链接：52. N皇后 II 题解： 同样是N皇后，比上一题更加简单。 题目简述：N皇后问题，问最后的方案数！ 题解：具体思路详见上一题 51题！ 由于问方案数，我们就不必开数组去存储路径了。 在递归出口i == n时， 直接进行统计即可res++. AC代码：1234567891011121314151617181920212223class Solution {public: vector&lt;bool&gt; col, dg, udg; int res; int totalNQueens(int n) { col = vector&lt;bool&gt;(n); dg = udg = vector&lt;bool&gt;(n * 2); dfs(0, n); return res; } void dfs(int i, int n){ if(i == n){ res ++; return; } for(int j = 0; j &lt; n; j++){ if(!col[j] &amp;&amp; !dg[i + j] &amp;&amp; !udg[i - j + n]){ col[j] = dg[i + j] = udg[i - j + n] = true; dfs(i + 1, n); col[j] = dg[i + j] = udg[i - j + n] = false; } } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-51. N 皇后 ","slug":"LeetCode刷题-51-N-皇后","date":"2020-07-07T06:07:12.000Z","updated":"2020-07-07T09:18:51.751Z","comments":true,"path":"posts/29682.html","link":"","permalink":"https://www.itnxd.cn/posts/29682.html","excerpt":"","text":"题目链接：51. N 皇后 题解： 经典的N皇后问题！ 题目简述：n * n 的棋盘放n个皇后，保证每行每列每条斜线都不能有大于一个皇后！ 题解：DFS来一遍即可！ 使用col dg udg分别存储列和两条对角线是否有皇后。使用res存储答案，使用path存储路径。 void dfs(int i, int n) i：代表第几层 n：代表皇后数或棋盘行列数 递归出口： i == n即n个皇后都已经找到，将当前方案加入答案res 使用dg[i + j]和udg[i - j + n] 来标识两条对角线，原因就是你可以将它看成坐标系，一条对角线为y = x + b，另一条为y = -x + b，即可解的b = y - x, b = y + x，y - x可能越界，让他偏移n，即可保证不越界。 递归开始： 只要列以及两条斜线以及没有被访问过，即可访问！使用path[i][j]记录路径，表示i行的j列有一个皇后，更新标记，最后清空标记！ 注意：数组的初始化，path需要全部初始化为.，col要初始化n个位置，dg udg要初始化n * 2个位置。 AC代码：12345678910111213141516171819202122232425262728class Solution {public: vector&lt;bool&gt; col, dg, udg; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; path; vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { col = vector&lt;bool&gt;(n); dg = udg = vector&lt;bool&gt;(n * 2); path = vector&lt;string&gt;(n, string(n, '.')); dfs(0, n); return res; } void dfs(int i, int n){ if(i == n){ res.push_back(path); return; } for(int j = 0; j &lt; n; j++){ if(!col[j] &amp;&amp; !dg[i + j] &amp;&amp; !udg[i - j + n]){ col[j] = dg[i + j] = udg[i - j + n] = true; path[i][j] = 'Q'; dfs(i + 1, n); path[i][j] = '.'; col[j] = dg[i + j] = udg[i - j + n] = false; } } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-50. Pow(x, n)","slug":"LeetCode刷题-50-Pow-x-n","date":"2020-07-07T02:54:18.000Z","updated":"2020-07-07T09:18:51.744Z","comments":true,"path":"posts/4834.html","link":"","permalink":"https://www.itnxd.cn/posts/4834.html","excerpt":"","text":"题目链接：50. Pow(x, n) 题解： 快速幂应用！ 题目简述：浮点数的幂运算！ 题解：详见之前的这道题详解！ 不同之处，可能有负数，一个数的负数次幂，等于1 除以正数次幂，判断一下即可！ 注意：由于有负数，要求绝对值可能会越界，使用LL强转一下即可！ AC代码：123456789101112class Solution {public: double myPow(double x, int n) { typedef long long LL; double res = 1; for(LL k = abs((LL)n); k; k &gt;&gt;= 1){ if(k &amp; 1) res *= x; x *= x; } return n &gt; 0 ? res : 1 / res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"快速幂","slug":"快速幂","permalink":"https://www.itnxd.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-49.字母异位词分组","slug":"LeetCode刷题-49-字母异位词分组","date":"2020-07-07T02:53:42.000Z","updated":"2020-07-07T09:18:51.748Z","comments":true,"path":"posts/15108.html","link":"","permalink":"https://www.itnxd.cn/posts/15108.html","excerpt":"","text":"题目链接：49.字母异位词分组 题解： 又是一个好巧的做法，借用排序即可处理！ 题目简述：将一组字符串数组中每个字符串每个字符相同且数量一致的放到一组返回！ 题解：怎么处理？ 既然你不一样，我就把你变成一样的，排个序不就行了，排完序后，该是一组的就都变成同一个字符串了，然后使用哈希表做一下映射即可！ 具体做法： 定义一个哈希表：unordered_map&lt;string, vector&lt;string&gt;&gt; hash;第一维度存储排序后统一的字符串，第二维度存储没有排序的原始字符串。例如：aet 对应 ate, aet, tae, tea, eat, eta 然后再将第二维度导入一个新数组即可！ AC代码：1234567891011121314class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { unordered_map&lt;string, vector&lt;string&gt;&gt; hash; for(auto&amp; str : strs){ string s = str; sort(str.begin(), str.end()); hash[str].push_back(s); } vector&lt;vector&lt;string&gt;&gt; res; for(auto&amp; item : hash) res.push_back(item.second); return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"哈希表","slug":"哈希表","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-48.旋转图像","slug":"LeetCode刷题-48-旋转图像","date":"2020-07-07T02:53:21.000Z","updated":"2020-07-07T09:18:51.740Z","comments":true,"path":"posts/39221.html","link":"","permalink":"https://www.itnxd.cn/posts/39221.html","excerpt":"","text":"题目链接：48.旋转图像 题解： 将一个矩阵反转，顺时针，逆时针，以及180度反转！ 有更精妙的方法吗？详见下文！ 题目简述：将一个矩阵顺时针反转90度！ 不能使用额外的数组！ 题解：第一想法：转圈来回换，例如1 3 9 7，2 6 8 4， … 但是找下标的关系会很复杂，我第一次就是这样做的，果然，找下标成功将我绕晕了！ 有没有更好的办法了？ 有的！ 对于顺时针90度，先按主对角线对称，再按中间竖线对称！ 对于逆时针90度，先按主对角线对称，再按中间横线对称！ 对于180度，先按主对角线对称，再按副对角线对称！ 顺时针90度： 逆时针90度： 180度： AC代码：12345678910111213141516class Solution {public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; i; j++){ swap(matrix[i][j], matrix[j][i]); } } for(int i = 0; i &lt; n; i++){ for(int j = 0, k = n - 1; j &lt; k; j++, k--){ swap(matrix[i][j], matrix[i][k]); } } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"旋转","slug":"旋转","permalink":"https://www.itnxd.cn/tags/%E6%97%8B%E8%BD%AC/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-47.全排列II","slug":"LeetCode刷题-47-全排列II","date":"2020-07-07T02:52:56.000Z","updated":"2020-07-07T09:18:51.732Z","comments":true,"path":"posts/23499.html","link":"","permalink":"https://www.itnxd.cn/posts/23499.html","excerpt":"","text":"题目链接：47.全排列II 题解： 相比上一道多了重复元素！ 题目简述：给定一个可包含重复数字的序列，返回所有不重复的全排列。 题解：和 46 题类似，多了重复元素和去重！ 步骤也多了两步： 排序，使得相同的元素排到一起 过滤，同一个位置同一个相同元素只用没有使用的第一个元素，并且使用顺序一定是从前到后 过滤方法：i &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !vis[i - 1]即遇到和上一个相同，上一个没有被用过，则说明当前数不是第一次被用，就不要取用，跳过即可！ 举个例子：1(1) 1(2) 3 可能为 1(1) 1(2) 3也可能为1(2) 1(1) 3 ，我们要去除重复的，可以只将顺序排列的留下即可！即相同数的第一个没有被用到，就不要使用第二个，第三个！可以保证相同数只有一种情况，即顺序排列的情况！ AC代码：123456789101112131415161718192021222324252627class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;bool&gt; vis; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); vis = vector&lt;bool&gt;(nums.size()); dfs(0, nums); return res; } void dfs(int cnt, vector&lt;int&gt;&amp; nums){ if(cnt == nums.size()){ res.push_back(path); return; } for(int i = 0; i &lt; nums.size(); i++){ if(!vis[i]){ if(i &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !vis[i - 1]) continue; path.push_back(nums[i]), vis[i] = true; dfs(cnt + 1, nums); path.pop_back(), vis[i] = false; } } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-46.全排列","slug":"LeetCode刷题-46-全排列","date":"2020-07-07T02:52:37.000Z","updated":"2020-07-07T09:18:51.736Z","comments":true,"path":"posts/44968.html","link":"","permalink":"https://www.itnxd.cn/posts/44968.html","excerpt":"","text":"题目链接：46.全排列 题解： 全排列问题，经典DFS！ 题目简述：给定没有重复元素的序列，输出全排列！ 题解：直接搜索加回溯就行了： 参数： cnt：表示当前搜到第几位数 nums：传入原数组 递归出口：cnt == nums.size() 搜索过的直接跳过即可，使用vis数组标记即可！ AC代码：1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;bool&gt; vis; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { vis = vector&lt;bool&gt;(nums.size()); dfs(0, nums); return res; } void dfs(int cnt, vector&lt;int&gt;&amp; nums){ if(cnt == nums.size()){ res.push_back(path); return; } for(int i = 0; i &lt; nums.size(); i++){ if(vis[i]) continue; path.push_back(nums[i]); vis[i] = true; dfs(cnt + 1, nums); path.pop_back(); vis[i] = false; } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-45.跳跃游戏II","slug":"LeetCode刷题-45-跳跃游戏II","date":"2020-07-06T12:42:28.000Z","updated":"2020-07-07T09:18:51.718Z","comments":true,"path":"posts/31960.html","link":"","permalink":"https://www.itnxd.cn/posts/31960.html","excerpt":"","text":"题目链接：45.跳跃游戏II 题解： 普通动态规划超时，需要想到是否具有单调性，再从单调性出发使用贪心求解！ 动态规划难度尚可，加上单调性就复杂了许多！ 题目简述：给了一个非负整数数组，每个位置代表能从当前位置挑的最大步数，题目规定一定可以跳到终点，问最短步数！ 题解一：动态规划同样使用闫式DP分析法： 状态表示：使用f[i]数组表示跳到i位置的最小步数 状态计算： 那么f[i]应该为前面的所有位置跳到当前位置的步数中的最小值。即t = min(t, f[j] + 1) 最终答案：答案就是f[n - 1] 解释一下：j + nums[j] &gt;= i表示能从j位置跳到i位置 时间复杂度：O(n ^ 2) 空间复杂度：O(n) 时间复杂度有点高，会超时TLE，请看题解二，利用单调性！ 超时代码：1234567891011121314151617class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n + 1); for(int i = 1; i &lt; n; i++){ int t = INT_MAX; for(int j = 0; j &lt; i; j++){ if(j + nums[j] &gt;= i){ t = min(t, f[j] + 1); } } f[i] = t; } return f[n - 1]; }}; 题解二：动态规划 + 单调性 + 贪心既然动态规划会超时，我们就需要想想该状态数组是否具有单调性！ 我们会发现，f数组是单调递增的，可能为0,1,1,2,3,4,4,4,5,6....也就是f[i - 1] &lt;= f[i] 开始证明： 反证法： 假设f[i - 1] &gt; f[i]，不妨假设是从k（k位置一定在i - 1 位置之前）位置跳到了f[i]，即 k + nums[k] &gt;= i，那么k + nums[k] &gt;= i - 1一定成立！此时f[i - 1] &lt;= f[i]，即能跳到后一个位置，一定能跳到前一个位置，这样到达前一个位置的步数一定不会大于后一个位置的步数！即假设不成立，状态数组是单调递增的！ 有了单调性的性质，计算步数就会简单多了！ 我们只需要尽可能找到靠前的能跳到当前位置的位置即可，因为其后面的一定可以跳过去，步数也一定会比前面能跳过去的位置要多，所以最优解就是从前往后第一个可以跳到当前位置的位置！即while(last &lt; i &amp;&amp; last + nums[last] &lt; i) last++; last位置就是第一个可以跳过去的位置，也就是最优解。当前位置的最小步数，当然就是上一个位置的最小步数 + 1，即f[i] = f[last] + 1 最终答案：f[n - 1] 时间复杂度：最多扫描两遍，为O(n) 空间复杂度：O(n) AC代码：123456789101112class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; f(n + 1); for(int i = 1, last = 0; i &lt; n; i++){ while(last &lt; i &amp;&amp; last + nums[last] &lt; i) last++; f[i] = f[last] + 1; } return f[n - 1]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-44.通配符匹配","slug":"LeetCode刷题-44-通配符匹配","date":"2020-07-06T12:41:42.000Z","updated":"2020-07-07T09:18:51.728Z","comments":true,"path":"posts/18504.html","link":"","permalink":"https://www.itnxd.cn/posts/18504.html","excerpt":"","text":"题目链接：44.通配符匹配 题解： 又是一道关于正则表达式匹配问题的，和上一道10.正则表达式匹配几乎类似！ 同样的做法，再来一次动态规划！ 题目简述：? ：可以匹配任何单个字符。*： 可以匹配任意字符串（包括空字符串）。 给一个字符串，给一个正则，检查能否匹配。 很明显，这个定义和正则的含义不尽相同，没关系，根据题意来就行了。 题解：同样使用闫式DP分析法： 分为状态表示和状态计算： 如下图，由于我写过了一遍，就不再写了！ 状态转移方程如下： 当p[j] != '*' f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == '?') 当 p[j] == '*' f[i][j] = f[i][j - 1] || i &amp;&amp; f[i - 1][j] （添加 i 防止越界） 注意点： 初始状态f[0][0] = true j从0开始无意义，因为非空串无法匹配空串 第一个if同样需要防止越界 最终答案为f[n][m] 将字符串从0开始，可以省去边界情况的处理 时间复杂度：O(n * m) AC代码：12345678910111213141516171819class Solution {public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); s = ' ' + s, p = ' ' + p; vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1)); f[0][0] = true; for(int i = 0; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ if(i &amp;&amp; p[j] != '*'){ f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == '?'); }else if(p[j] == '*'){ f[i][j] = f[i][j - 1] || i &amp;&amp; f[i - 1][j]; } } } return f[n][m]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-43.字符串相乘","slug":"LeetCode刷题-43-字符串相乘","date":"2020-07-06T12:41:23.000Z","updated":"2020-07-07T09:18:51.724Z","comments":true,"path":"posts/1953.html","link":"","permalink":"https://www.itnxd.cn/posts/1953.html","excerpt":"","text":"题目链接：43.字符串相乘 题解： 高精度乘以高精度！ 题目简述：两个字符串高精度相乘返回结果的字符串！ 题解：模拟小学乘法即可！ 两个数相乘，最后积的位数为两数长度之和或者为长度之和减 1 ！ 思路： 先将字符串映射成数字，再倒序存到数组，为了方便计算！ 两层循环，让第二个数的每一位去乘第一个数，存到新数组c[i + j]，这样可以保证该放到同一列的都在同一列 然后将需要进位的给了下一位，即c[i + j + 1] += c[i + j] / 10 再将本位的余数留下即可，即c[i + j] %= 10 最后需要将末尾的零去掉，即反转为正常数字的前导0.（例如乘以0，或者位数为两数之和减 1） 在将其映射为字符串，倒序存储到新数组，返回！ 算了，懒得画图了，太好理解了！ 时间复杂度： O(n * m) AC代码：123456789101112131415161718192021class Solution {public: string multiply(string num1, string num2) { int n = num1.size(), m = num2.size(); vector&lt;int&gt; a(n), b(m), c(n + m); for(int i = 0; i &lt; n; i++) a[n - i - 1] = num1[i] - '0'; for(int i = 0; i &lt; m; i++) b[m - i - 1] = num2[i] - '0'; for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ c[i + j] += a[i] * b[j]; c[i + j + 1] += c[i + j] / 10; c[i + j] %= 10; } } int len = n + m; while(len &gt; 1 &amp;&amp; c[len - 1] == 0) len--; string res = \"\"; for(int i = len - 1; i &gt;= 0; i--) res += c[i] + '0'; return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"https://www.itnxd.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-42.接雨水","slug":"LeetCode刷题-42-接雨水","date":"2020-07-05T01:18:21.000Z","updated":"2021-02-06T14:42:50.861Z","comments":true,"path":"posts/57751.html","link":"","permalink":"https://www.itnxd.cn/posts/57751.html","excerpt":"","text":"题目链接：42.接雨水 题解： 多种做法，第一次接触确实有点难，单调栈的应用，以及双指针这个神奇算法的应用！ 计算这种面积，不要瞎想，大概两种，一种计算纵向，一种计算横向！ 下面三种解法，推荐去看双指针和单调栈，学习算法，尽可能多的一题多解，双指针解法是最优的，但是单调栈也是一种思想，多学点没坏处！ 题目简述：接雨水，给定一堆柱子，问柱子之间的凹槽最多放多少水！如下图：蓝色部分就是最多的接水量。 题解一：三次扫描计算纵向：即每个柱子上方可以存水的量，累加即可！ 如何计算？ 观察会发现，当前柱子能存的水取决于当前柱子左边最高的柱子和当前柱子右边最高的柱子，由于短板效应，所以能存的水为左右两边最高的柱子的较小值与当前柱子高度的差值。 如何计算左右最高的柱子？ 简单办法：直接扫描一遍即可，使用两个数组保存该位置左右的最高柱子，left_max[i]表示i位置（包括自己）的柱子左边的最高柱子，同理right_max[i]表示i位置（包括自己）右边最高柱子。一个从左向右扫描维护该数组，一个从右向左扫描维护该数组即可。 第三次扫描，直接计算每个柱子的可存水的高度即可！即min(left_max[i], right_max[i]) - height[i] 注意：因为要进行动态维护，要和前一个最大值比较，所以数组left_max从1开始，right_max从n - 1开始。 时间复杂度： 三次线性扫描，为 O(n) 空间复杂度： 开辟了两个额外数组，空间占用为 O(n) 注意：判断为空的情况！ 为什么要扫描三次，一次扫描不行吗？ 答案是可以，使用双指针来维护！详见题解二！ AC代码一：1234567891011121314151617class Solution {public: int trap(vector&lt;int&gt;&amp; height) { int n = height.size(), res = 0; if(n == 0) return 0; vector&lt;int&gt; left_max(n), right_max(n); left_max[0] = height[0]; for(int i = 1; i &lt; n; i++) left_max[i] = max(left_max[i - 1], height[i]); right_max[n - 1] = height[n - 1]; for(int i = n - 2; i &gt;= 0; i--) right_max[i] = max(right_max[i + 1], height[i]); for(int i = 0; i &lt; n; i++) res += min(left_max[i], right_max[i]) - height[i]; return res; }}; 题解二：双指针同样是计算纵向！ 使用双指针，一次扫描，不用多余的空间！ 首先：思想就是一个桶能装多少水，一定是由短板决定的，所以我们就是根据这句话来想，我们不去找左右最大值，直接找短板即可！ 当前算法过程就是不断的计算左柱子和右柱子，直到左右相碰结束！ 具体解法： 使用l和r分别指向左右两个指针 使用left_max和right_max分别指向l左边最大值和r右边最大值 左边最大值小于右边最大值时，即left_max &lt; right_max，说明height[l]这根柱子的短板已经找到，为left_max，当前总面积累加为res += left_max - height[l] 然后左指针右移，l++ 更新left_max，即left_max = max(left_max, height[l]) 左边最大值大于等于右边最大值时，同理！ 具体解释： 为什么左最大小于右最大，即为左柱子的短板；为什么右最大小于左最大，即为右柱子的短板？ 还是短板效应！ 如果左最大小于右最大，左边柱子的赛点就到了，左边最大即为当前柱子的短板！你想啊，虽然两个指针中间还有未走完的路，但是右边的最大值一定会在后续更新到更大，不管怎样，相比之下，左右最大值中的最小值一定是当前左边的最大值。同理右边较小时也是！ 时间复杂度： l 和 r一共扫描一遍数组，为 O(n) 空间复杂度： 没有使用额外空间，空间占用为 O(1) 注意：判断为空的情况！ AC代码二：12345678910111213141516171819202122// 双指针 时间 O(n) 空间 O(1)class Solution {public: int trap(vector&lt;int&gt;&amp; height) { int n = height.size(), res = 0; if(n == 0) return 0; int left_max = height[0], right_max = height[n - 1]; int l = 0, r = n - 1; while(l &lt; r){ if(left_max &lt; right_max){ res += left_max - height[l++]; left_max = max(left_max, height[l]); }else{ res += right_max - height[r--]; right_max = max(right_max, height[r]); } } return res; }}; 题解三：单调栈计算横向！ 我是第一次接触单调栈！ 本题可以使用单调栈，所谓单调栈就是具有单调性的栈。。。 为了存到水，那么一定要有凹槽，即左边下去，右边起来，我们用栈来维护左边下去的这一段，即当前栈是一个单调递减的栈！ 如下图： 我们在栈中存储左边那四根递减的柱子！ 具体算法： 有了凹槽才需要计算面积，所以，递减的栈要找到大于栈顶的位置才需要计算面积。 首先出栈栈顶并将其记为top，然后当前stk.top()、top、i就构成了一个凹槽，可以进行一次计算， 即红色块面积，宽度为i - stk.top() - 1，高度为min(height[i], height[stk.top()]) - height[top] 算完后while结束，继续下一次for循环，i后移，严格保证栈的单调性 此时栈又不单调了，进行处理，此时i到了i'，会发现多出了黄色三个矩形块的面积，2,3,4号矩形，可以在while内循环全部干掉，边干边出栈，最后栈内为1,6 每次while循环结束，将当前位置 i压入栈内。 具体看下方图理解一下，这里维护了一个单调栈，永远单调，遇到凹槽就进行计算累加，横向的面积！ 注意：如果出栈一次后，栈空，即当前的形状不是凹槽，就像当前只有top和i一样，无法存水，break即可！ 时间复杂度： 扫描一次，为 O(n) 空间复杂度： 栈开辟了一个数组，空间占用为 O(n) AC代码三：123456789101112131415161718// 单调栈 时间O(n) 空间O(n)class Solution {public: int trap(vector&lt;int&gt;&amp; height) { stack&lt;int&gt; stk; int res = 0; for(int i = 0; i &lt; height.size(); i++){ while(stk.size() &amp;&amp; height[stk.top()] &lt; height[i]){ int top = stk.top(); stk.pop(); if(stk.empty()) break; res += (i - stk.top() - 1) * (min(height[i], height[stk.top()]) - height[top]); } stk.push(i); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://www.itnxd.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-41.缺失的第一个正数","slug":"LeetCode刷题-41-缺失的第一个正数","date":"2020-07-05T01:17:41.000Z","updated":"2021-02-06T14:43:18.102Z","comments":true,"path":"posts/50883.html","link":"","permalink":"https://www.itnxd.cn/posts/50883.html","excerpt":"","text":"题目链接：41.缺失的第一个正数 题解： 一种排序算法的应用？ 题目简述：给定一组未排序数组，找出其中没有出现过的最小正整数！ 要求：时间 O(n) 空间 O(1) 题解：由于时间为O(n)限制，不能直接使用sort再扫描，现在给出一种排序： 小于等于0，大于 n 的数字不用管（因为我们要正数的排序，排序的最后一个数应该为n，所以大于n的不用管） 从前向后扫描，保证每个数字出现在正确位置上，即 5 应该跑到下标为 4 的位置，即nums[i]要跑到下标为nums[i] - 1的位置 扫描一遍以后，整个数组1 ~ n的数字已经正确归位，所以只需要从前向后再扫描一遍没出现过的数字即可，即nums[i] != i + 1。若全部匹配，则说明是第 n +1 个数没有出现 具体解释： 遇到1 ~ n的就进行归位，将该数放到该放的位置，使用swap进行交换，交换完成后一个数已经归位，交换过来的数若不是它该待的正确位置，继续进行交换，直到当前位置为正确数字或遇到不在1 ~ n范围内的数结束当前位置。 时间复杂度： 别看有两层循环，但是两层循环加起来最多执行n次，因为while循环一次就会归位一个该归位的数（1 ~ n），所以时间复杂度为O(n) 空间复杂度： 没有使用额外空间，所以空间复杂度为 O(1) AC代码：123456789101112131415class Solution {public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for(int i = 0; i &lt; n; i++) while(nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - 1]) swap(nums[i], nums[nums[i] - 1]); for(int i = 0; i &lt; n; i++) if(nums[i] != i + 1) return i + 1; return n + 1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"}],"author":"Mr.Niu"},{"title":"数据库教程之字符集.安全管理.维护","slug":"数据库教程之字符集-安全管理-维护","date":"2020-07-03T02:23:19.000Z","updated":"2021-02-23T04:51:22.992Z","comments":true,"path":"posts/28616.html","link":"","permalink":"https://www.itnxd.cn/posts/28616.html","excerpt":"","text":"一、字符集和校对顺序1、字符集和校对顺序 在MySQL的正常数据库活动（ SELECT 、 INSERT 等）中，不需要操心太多的东西。使用何种字符集和校对的决定在服务器、数据库和表级进行。 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对为规定字符如何比较的指令。 2、使用字符集和校对顺序2.1 查看支持的字符集 使用命令：SHOW CHARACTER SET; callation为校对顺序！ 这条语句显示所有可用的字符集以及每个字符集的描述和默认校对。 123456789101112131415161718192021mysql&gt; SHOW CHARACTER SET;+----------+---------------------------------+---------------------+--------+| Charset | Description | Default collation | Maxlen |+----------+---------------------------------+---------------------+--------+| armscii8 | ARMSCII-8 Armenian | armscii8_general_ci | 1 || ascii | US ASCII | ascii_general_ci | 1 || big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 || binary | Binary pseudo charset | binary | 1 || cp1250 | Windows Central European | cp1250_general_ci | 1 || cp1251 | Windows Cyrillic | cp1251_general_ci | 1 || cp1256 | Windows Arabic | cp1256_general_ci | 1 || cp1257 | Windows Baltic | cp1257_general_ci | 1 || cp850 | DOS West European | cp850_general_ci | 1 || cp852 | DOS Central European | cp852_general_ci | 1 || cp866 | DOS Russian | cp866_general_ci | 1 || cp932 | SJIS for Windows Japanese | cp932_japanese_ci | 2 || dec8 | DEC West European | dec8_swedish_ci | 1 || eucjpms | UJIS for Windows Japanese | eucjpms_japanese_ci | 3 || euckr | EUC-KR Korean | euckr_korean_ci | 2 |.......... 2.2 查看支持的校对顺序 非常多，展示部分！ 用来显示所有可用的校对，以及它们适用的字符集。有的字符集具有不止一种校对。 使用命令：SHOW COLLATION; 1234567891011121314151617mysql&gt; SHOW COLLATION;+----------------------------+----------+-----+---------+----------+---------+---------------+| Collation | Charset | Id | Default | Compiled | Sortlen | Pad_attribute |+----------------------------+----------+-----+---------+----------+---------+---------------+| armscii8_bin | armscii8 | 64 | | Yes | 1 | PAD SPACE || armscii8_general_ci | armscii8 | 32 | Yes | Yes | 1 | PAD SPACE || ascii_bin | ascii | 65 | | Yes | 1 | PAD SPACE || ascii_general_ci | ascii | 11 | Yes | Yes | 1 | PAD SPACE || big5_bin | big5 | 84 | | Yes | 1 | PAD SPACE || big5_chinese_ci | big5 | 1 | Yes | Yes | 1 | PAD SPACE || binary | binary | 63 | Yes | Yes | 1 | NO PAD || cp1250_bin | cp1250 | 66 | | Yes | 1 | PAD SPACE || cp1250_croatian_ci | cp1250 | 44 | | Yes | 1 | PAD SPACE || cp1250_czech_cs | cp1250 | 34 | | Yes | 2 | PAD SPACE || cp1250_general_ci | cp1250 | 26 | Yes | Yes | 1 | PAD SPACE |.......... 2.3 确认默认字符集和校对顺序 通常系统管理在安装时定义一个默认的字符集和校对。 此外，也可以在创建数据库时，指定默认的字符集和校对。 字符集很少是服务器范围（甚至数据库范围）的设置。不同的表，甚至不同的列都可能需要不同的字符集，而且两者都可以在创建表时指定。 为了确定所用的字符集和校对，可以使用以下语句： 1234567891011121314151617181920212223242526-- 默认字符集mysql&gt; SHOW VARIABLES LIKE 'character%';+--------------------------+--------------------------+| Variable_name | Value |+--------------------------+--------------------------+| character_set_client | utf8mb4 || character_set_connection | utf8mb4 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | utf8mb4 || character_set_server | utf8mb4 || character_set_system | utf8 || character_sets_dir | D:\\MySQL\\share\\charsets\\ |+--------------------------+--------------------------+8 rows in set, 1 warning (0.00 sec)-- 默认校对顺序mysql&gt; SHOW VARIABLES LIKE 'collation%';+----------------------+--------------------+| Variable_name | Value |+----------------------+--------------------+| collation_connection | utf8mb4_0900_ai_ci || collation_database | utf8mb4_0900_ai_ci || collation_server | utf8mb4_0900_ai_ci |+----------------------+--------------------+3 rows in set, 1 warning (0.00 sec) 2.4 指定字符集和校对顺序 在CREATE语句最后加上DEFAULT CHARACTER SET 字符集名 COLLATE 校对顺序名; 如果不指定，则使用2.3中的默认值！ 123456CREATE TABLE mytable( columnn1 INT， columnn2 VARCHAR(10)) DEFAULT CHARACTER SET hebrewCOLLATE hebrew_general_ci; 2.5 单独对某列设定字符集和校对顺序 既对整个表设定也对某个列设定！ 1234567CREATE TABLE mytable(columnn1 INT，columnn2 VARCHAR(10)，co1umnn3 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ci) DEFAULT CHARACTER SET hebrewCOLLATE hebrew_general_ci; 2.6 对ORDER BY子句设定校对顺序 通过对该排序设定校对顺序，可以临时区分大小写来排序！即latin1_genera1_Cs可以区分大小写的校对顺序。 123SELECT * FROM customersORDER BY lastname, firstname COLLATE latin1_genera1_Cs; 2.7 其他支持设定校对顺序的语句 COLLATE 还可以用于 GROUP BY 、 HAVING 、聚集函数、别名等。 如果绝对需要，串可以在字符集之间进行转换。为此，使用 Cast() 或 Convert ()函数。 二、安全管理1、访问控制 说白了就是分配给谁多大的权限进行数据库操作！ MySQL默认有一个root用户，对MySQL服务具有完全的控制！在日常工作中，决不能使用root，应该创建一系列账号，用于管理及用户使用！ 仅在绝对需要时使用它（或许在你不能登录其他管理账号时使用）。不应该在日常的MySQL操作中使用 root 。 举例子如下： 多数用户只需要对表进行读和写，但少数用户甚至需要能创建和删除表； 某些用户需要读表，但可能不需要更新表； 你可能想允许用户添加数据，但不允许他们删除数据； 某些用户（管理员）可能需要处理用户账号的权限，但多数用户不需要； 你可能想让用户通过存储过程访问数据，但不允许他们直接访问数据； 你可能想根据用户登录的地点限制对某些功能的访问。 2、管理用户2.1 创建用户账号 GRANT 语句也可以创建用户账号，但一般来说CREATE USER是最清楚和最简单的句子。此外，也可以通过直接插入行到 user 表来增加用户，不过为安全起见，一般不建议这样做。MySQL用来存储用户账号信息的表（以及表模式等）极为重要，对它们的任何毁坏都可能严重地伤害到MySQL服务器。因此，相对于直接处理来说，最好是用标记和函数来处理这表。 语法：CREATE USER 用户名 IDENTIFIED BY '口令' 该口令为纯文本，MySQL会在存入user表之前进行加密！ 注意：查询用户可到mysql表下的user表查询！ user表中localhost表示仅可在本机使用此用户登录数据库 user表中通配符 % 代表可以在任意主机使用此用户登录数据库 创建用户时不添加主机名则默认为%！ 1234CREATE USER ben IDENTIFIED BY 'p@$$wOrd' ;CREATE USER 'xxx'@'localhost' IDENTIFIED BY '123';CREATE USER 'xxx'@'%' IDENTIFIED BY '123'; CREATE USER 创建一个新用户账号。在创建用户账号时不一定需要口令，不过这个例子用 IDENTIFIED BY 'p@$$wOrd'给出了一个口令。 指定散列口令： 语法：CREATE USER 用户名 IDENTIFIED BY PASSWORD 重命名用户名： 语法：RENAME USER 用户名 TO 新用户名 1RENAME USER ben TO bforta; 2.2 删除用户账号 语法：DROP USER 用户名 DROP USER 删除用户账号和所有相关的账号权限。 在MySQL 5以前， DROP USER 只能用来删除用户账号，不能删除相关的权限。因此，如果使用旧版本的MySQL，需要先用 REVOKE 删除与账号相关的权限，然后再用 DROP USER删除账号。 1DROP USER ben; 2.3 设置访问权限 新建的用户没有权限，只能进行登录操作！ 2.3.1 查看用户权限 语法：SHOW GRANTS 用户名 下面显示有一个权限： USAGE ON *.*，USAGE表名没有任何权限。 MySQL的权限用用户名和主机名结合定义。如果不指定主机名，则使用默认的主机名 % （授予用户访问权限而不管主机名）。如：'ben' @ '%' 1234567mysql&gt; SHOW GRANTS FOR ben;+---------------------------------+| Grants for ben@% |+---------------------------------+| GRANT USAGE ON *.* TO `ben`@`%` |+---------------------------------+1 row in set (0.00 sec) 2.3.2 授予用户权限三步： 要授予的权限； 被授予访问权限的数据库或表； 用户名。 此 GRANT 允许用户在crashcourse.*（ crashcourse数据库的所有表）上使用 SELECT。通过只授予SELECT访问权限，用户 ben对crashcourse 数据库中的所有数据具有只读访问权限。 语法：GRANT 权限 ON 目标数据库 TO 用户 多个权限使用逗号分隔即可！ 1234567891011GRANT SELECT ON crashcourse.* TO ben;-- 使用SHOW FRANTS 查询权限mysql&gt; SHOW GRANTS FOR ben;+----------------------------------------------+| Grants for ben@% |+----------------------------------------------+| GRANT USAGE ON *.* TO `ben`@`%` || GRANT SELECT ON `crashcourse`.* TO `ben`@`%` |+----------------------------------------------+2 rows in set (0.00 sec) 2.3.3 撤销用户权限 语法：REVOKE 权限 ON 目标数据库 FROM 用户 撤销的权限必须存在，否则会报错！ 多个权限使用逗号分隔即可！ 1REVOKE SELECT ON crashcourse.* FROM bforta; GRANT 和 REVOKE 的几个层次： 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 2.3.4 权限信息如下 2.4 更改口令（密码） 语法：SET PASSWORD FOR 用户名 = Passward('新口令'); 或 update user set password = password(‘新密码’) where user = ‘用户名’; 1234SET PASSWORD FOR ben = Password('sdjfaosljdfk');# 或update user set password = password(‘xxx’) where user = ‘ben’; 设置自己口令： 在不指定用户名时， SET PASSWORD更新当前登录用户的口令。 1SET PASSWORD = Password('sdjfaosljdfk'); 三、数据库维护1、备份数据 像所有数据一样，MySQL的数据也必须经常备份。由于MySQL数据库是基于磁盘的文件，普通的备份系统和例程就能备份MySQL的数据。但是，由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效。 首先刷新未写数据 为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用 FLUSH TABLES 语句。 解决方案： 使用命令行实用程序 mysqldump 转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。 可用命令行实用程序 mysqlhotcopy 从一个数据库复制所有数据（并非所有数据库引擎都支持这个实用程序）。 可以使用MySQL的 BACKUP TABLE 或 SELECT INTO OUTFILE 转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用 RESTORETABLE 来复原。 代码示例： 12345678# 备份mysqldump -u用户名 -p密码 需要备份的数据库名称 &gt; 保存路径# 还原：a.登录数据库b.创建数据库c.使用数据库d.执行语法：source 文件路径 2、进行数据库维护2.1 检查表键是否正确 语法：ANALYZE TABLE 表名 1234567mysql&gt; ANALYZE TABLE orders;+-------------+---------+----------+----------+| Table | Op | Msg_type | Msg_text |+-------------+---------+----------+----------+| test.orders | analyze | status | OK |+-------------+---------+----------+----------+1 row in set (0.13 sec) 2.2 对表进行多种问题检查 语法：CHECK TABLE 表名 在 MyISAM 表上还对索引进行检查。CHECK TABLE 支持一系列的用于 MyISAM 表的方式。CHANGED 检查自最后一次检查以来改动过的表。 EXTENDED 执行最彻底的检查，FAST 只检查未正常关闭的表， MEDIUM检查所有被删除的链接并进行键检验， QUICK只进行快速扫描。如下所示，CHECK TABLE 发现和修复问题： 如果 MyISAM 表访问产生不正确和不一致的结果，可能需要用REPAIR TABLE 来修复相应的表。这条语句不应该经常使用，如果需要经常使用，可能会有更大的问题要解决。 如果从一个表中删除大量数据，应该使用 OPTIMIZE TABLE 来收回所用的空间，从而优化表的性能。 12345678910mysql&gt; CHECK TABLE orders，orderitems ;+--------------------------+-------+----------+------------------------------------------------+| Table | Op | Msg_type | Msg_text |+--------------------------+-------+----------+------------------------------------------------+| test.orders，orderitems | check | Error | Table 'test.orders，orderitems' doesn't exist || test.orders，orderitems | check | status | Operation failed |+--------------------------+-------+----------+------------------------------------------------+2 rows in set (0.00 sec) 3、诊断启动问题 服务器启动问题通常在对MySQL配置或服务器本身进行更改时出现。MySQL在这个问题发生时报告错误，但由于多数MySQL服务器是作为系统进程或服务自动启动的，这些消息可能看不到。在排除系统启动问题时，首先应该尽量用手动启动服务器。MySQL服务器自身通过在命令行上执行 mysqld 启动。 几个重要的 mysqld命令行选项： --help显示帮助——一个选项列表； --safe-mode 装载减去某些最佳配置的服务器； --verbose 显示全文本消息（为获得更详细的帮助消息与 –help联合使用）； --version 显示版本信息然后退出。 4、查看日志文件 MySQL维护管理员依赖的一系列日志文件。主要的日志文件有以下几种。 错误日志。它包含启动和关闭问题以及任意关键错误的细节。此日志通常名为 hostname.err ，位于 data目录中。此日志名可用--log-error 命令行选项更改。 查询日志。它记录所有MySQL活动，在诊断问题时非常有用。此日志文件可能会很快地变得非常大，因此不应该长期使用它。此日志通常名为 hostname.log ，位于 data目录中。此名字可以用--log命令行选项更改。 二进制日志。它记录更新过数据（或者可能更新过数据）的所有语句。此日志通常名为hostname-bin ，位于data 目录内。此名字可以用 --log-bin 命令行选项更改。注意，这个日志文件是MySQL5中添加的，以前的MySQL版本中使用的是更新日志。 缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询。这个日志在确定数据库何处需要优化很有用。此日志通常名为hostname-slow.log ， 位 于 data目 录 中 。 此 名 字 可 以 用--log-slow-queries 命令行选项更改。 在使用日志时，可用 FLUSH LOGS 语句来刷新和重新开始所有日志文件。 四、改善性能 数据库管理员把他们生命中的相当一部份时间花在了调整、试验以改善DBMS性能之上。在诊断应用的滞缓现象和性能问题时，性能不良的数据库（以及数据库查询）通常是最常见的祸因。 下面的内容并不能完全决定MySQL的性能。只是提供进行性能优化探讨和分析的一个出发点。 首先，MySQL（与所有DBMS一样）具有特定的硬件建议。在学习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但对用于生产的服务器来说，应该坚持遵循这些硬件建议。 一般来说，关键的生产DBMS应该运行在自己的专用服务器上。 MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大小等。（为查看当前设置，可使用 SHOW VARIABLES; 和 SHOW STATUS; 。） MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多个任务。如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢。如果你遇到显著的性能不良，可使用 SHOW PROCESSLIST显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL 命令终结某个特定的进程（使用这个命令需要作为管理员登录）。 总是有不止一种方法编写同一条 SELECT 语句。应该试验联结、并、子查询等，找出最佳的方法。 使用 EXPLAIN 语句让MySQL解释它将如何执行一条 SELECT 语句。 一般来说，存储过程执行得比一条一条地执行其中的各条MySQL语句快。 应该总是使用正确的数据类型。 决不要检索比需求还要多的数据。换言之，不要用 SELECT * （除非你真正需要每个列）。 有的操作（包括 INSERT ）支持一个可选的 DELAYED 关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。 在导入数据时，应该关闭自动提交。你可能还想删除索引（包括FULLTEXT 索引），然后在导入完成后再重建它们。 必须索引数据库表以改善数据检索的性能。确定索引什么不是一件微不足道的任务，需要分析使用的 SELECT 语句以找出重复的WHERE 和 ORDER BY 子句。如果一个简单的 WHERE 子句返回结果所花的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。 你的 SELECT 语句中有一系列复杂的 OR 条件吗？通过使用多条SELECT 语句和连接它们的 UNION 语句，你能看到极大的性能改进。 索引改善数据检索的性能，但损害数据插入、删除和更新的性能。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。（索引可根据需要添加和删除。） LIKE 很慢。一般来说，最好是使用 FULLTEXT 而不是 LIKE 。 数据库是不断变化的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变。 最重要的规则就是，每条规则在某些条件下都会被打破。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"字符集","slug":"字符集","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"name":"安全管理","slug":"安全管理","permalink":"https://www.itnxd.cn/tags/%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/"},{"name":"数据库维护","slug":"数据库维护","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/"},{"name":"改善性能","slug":"改善性能","permalink":"https://www.itnxd.cn/tags/%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD/"}],"author":"Mr.Niu"},{"title":"数据库教程之游标及触发器","slug":"数据库教程之游标及触发器","date":"2020-07-02T10:12:23.000Z","updated":"2021-02-06T13:51:02.917Z","comments":true,"path":"posts/43244.html","link":"","permalink":"https://www.itnxd.cn/posts/43244.html","excerpt":"","text":"一、游标 游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。 在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。 注意：只能用于存储过程 不像多数DBMS，MySQL游标只能用于存储过程(和函数)。 1、使用游标 在声明游标后，可根据需要频繁地打开和关闭游标。在游标打开后，可根据需要频繁地执行取操作。 首先声明(定义)游标。这个过程实际上没有检索数据，只是定义要使用的SELECT语句。 声明后，必须打开游标使用。这个过程用前面定义的SELECT语句把数据实际检索出来。 对于填有数据的游标，根据需要取出(检索)各行 结束游标使用时，必须关闭游标 2、创建游标 游标创建用DELCARE语句，(和前面的存储过程中声明变量的关键字一样)。 DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句。 DECLARE 语句用来定义和命名游标，这里为 ordernumbers 。 存储过程处理完成后，游标就消失（因为它局限于存储过程）。 123456CREATE PROCEDURE processorders()BEGIN DELCARE ordernumbers CURSOR FOR SELECT order_num FROM orders;END; 3、打开关闭游标 在处理OPEN语句时执行查询，存储检索出的数据以供浏览和滚动。 CLOSE释放游标使用的所有内部内存和资源，因此在每个游标不再需要时都应该关闭。 隐含关闭：如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。 12345-- 打开游标OPEN ordernumbers;-- 关闭游标CLOSE ordernumbers; 修改版本： 这个存储过程声明、打开和关闭一个游标。但对检索出的数据什么也没有做… 12345678910111213CREATE PROCEDURE processorders()BEGIN -- Delcare the cursor DELCARE ordernumbers CURSOR FOR SELECT order_num FROM orders; -- Open the cursor OPEN ordernumbers; -- Close the cursor CLOSE ordernumbers;END; 4、使用游标数据 在一个游标被打开后，可以使用 FETCH 语句分别访问它的每一行。 FETCH指定检索什么数据(所需的列)，检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行(不重复读取同一行)。 4.1 FETCH获取一条数据 FETCH用来检索当前行的order_num列(将自动从第一行开始)到一个名为o的局部声明的变量中。 12345678910111213141516171819CREATE PROCEDURE processorders()BEGIN -- Declare local variables DECLARE o INT; -- Delcare the cursor DELCARE ordernumbers CURSOR FOR SELECT order_num FROM orders; -- Open the cursor OPEN ordernumbers; -- Get order number FETCH ordernumbers INTO o; -- Close the cursor CLOSE ordernumbers;END; 4.2 FETCH循环检索数据 这里的FETCH在REPEAT内，因此反复执行直到done为真（ UNTIL done END REPEAT;）。 上面这条语句定义了一个CONTINUE HANDLER，它是在条件出现时被执行的代码。指出当SQL STATE '02000'出现时，SET done = 1。 REPEAT循环语句：REPEAT ... UNTIL 变量 END REPEAT; 1234567891011121314151617181920212223242526272829CREATE PROCEDURE processorders()BEGIN -- Declare local variables DECLARE done BOOLEAN DEFAULT 0; DECLARE o INT; -- Delcare the cursor DELCARE ordernumbers CURSOR FOR SELECT order_num FROM orders; -- Declare continue handler DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1; -- Open the cursor OPEN ordernumbers; -- Loop through all rows REPEAT -- Get order number FETCH ordernumbers INTO o; -- End of loop UNTIL done END REPEAT; -- Close the cursor CLOSE ordernumbers;END; 4.3 定义DECLARE语句的次序 DECLARE语句定义的局部变量必须在定义任意游标或句柄(普通语句)之前定义 句柄(普通语句)必须在游标之后定义(如循环的条件等) 4.4 利用游标处理数据 此存储过程不返回数据，但它能够创建和填充另一个表，可以用一条简单的SELECT语句查看该表。 这是存储过程、游标、逐行处理以及存储过程调用其他存储过程的一个完整的工作样例。 1234567891011121314151617181920212223242526272829303132333435363738394041CREATE PROCEDURE processorders()BEGIN -- Declare local variables DECLARE done BOOLEAN DEFAULT 0; DECLARE o INT; DECLARE t DECIMAL(8, 2); -- Delcare the cursor DELCARE ordernumbers CURSOR FOR SELECT order_num FROM orders; -- Declare continue handler DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1; -- Create a table to store the results CREATE TABLE IF NOT EXISTS ordertotals (order_num INT, total DECIMAL(8,2)); -- Open the cursor OPEN ordernumbers; -- Loop through all rows REPEAT -- Get order number FETCH ordernumbers INTO o; -- Get the total for this order CALL ordertotal(o, 1, t); --前一章的存储过程，主要是计算带税订单的合计，存储到t -- Insert order and total into ordertotals INSERT INTO ordertotals(order_num, totals) VALUES(o, t); -- End of loop UNTIL done END REPEAT; -- Close the cursor CLOSE ordernumbers;END; 二、触发器 存储过程的执行是需要自己调用的，需要是进行调用！ 而触发器则是在触发某个条件自动执行！ 触发器，当然就是触发了然后自动执行。。。 触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句(或位于BEGIN和END语句之间的一组语句)： DELETE UPDATE INSERT 1、创建触发器 注意：保持每个数据库的触发器名唯一。在MySQL 5中，触发器名必须在每个表中唯一，但不是在每个数据库中唯一。 虽然MySQL允许同一数据库可使用相同触发器名（不同表即可），但是这样很明显不是好的做法，最好保证同一数据库触发器名唯一！ 需要的四条信息： 唯一的触发器名 触发器关联的表 触发器应该响应的活动(DELETE、INSERT、UPDATE) 触发器何时执行(处理之前后之后) 创建触发器： CREATE TRIGGER用来创建名为newproduct的新触发器。 触发器可在一个操作发生之前或之后执行，这里给出了AFTER INSERT，所以此触发器将在INSERT语句成功执行后执行。 这个触发器还指定FOR EACH ROW，因此代码对每个插入行执行。 在这个例子中，文本Product added将对每个插入的行显示一次。 12CREATE TRIGGER newproduct AFTER INSERT ON productsFOR EACH ROW SELECT 'Product added'; 注意： 只有表才支持触发器，视图不支持，临时表也不支持。 每个表的每个事件每次只允许一个触发器 每个表最多支持6个触发器（每条INSERT、UPDATE和DELETE的之前和之后） 单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。 触发器失败： 如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）。 2、删除触发器 注意：触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建。 1DROP TRIGGER 触发器名字; 3、使用触发器3.1 INSERT触发器INSERT触发器在INSERT语句执行之前或之后执行 。 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行 在BEFORE INSERT触发器中，NEW的值也可以被更新(允许更改被插入的值) 对于AUTO_INCREMENT列，NEW在INSERT执行前包含0，在INSERT被执行后包含新的自动生成值。 会发现下面INSERT语句的执行多了输出结果！就是因为触发了上面的neworder触发器，执行了SELECT NEW.order_num;语句！ 此代码创建一个名为neworder的触发器，它按照AFTER INSERT ON orders执行。 在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。 触发器从NEW. order_num取得这个值并返回它。 此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。 12345678910111213-- 创建触发器CREATE TRIGGER neworder AFTER INSERT ON ordersFOR EACH ROW SELECT NEW.order_num;-- 触发开始INSERT INTO orders(order_date，cust_id)VALUES (Now()，10001) ;+-----------+| order_num |+-----------+| 20010 |+-----------+ BEFORE或AFTER？ 通常，将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据）。本提示也适用于UPDATE触发器。 3.2 DELETE触发器DELETE触发器在DELETE语句执行之前或之后执行： 在DELETE触发器代码内，可以引用一个名为OLD的虚拟表，访问被删除的行 OLD中的值全部都是只能读的，不能更新 在任意订单被删除前将执行此触发器。 它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中（为实际使用这个例子，你需要用与orders相同的列创建一个名为archive_orders的表）。 使用BEFORE DELETE触发器的优点（相对于AFTER DELETE触发器 来说），如果由于某种原因，订单不能存档，DELETE本身将被放弃。 123456CREATE TRIGGER deleteorder BEFORE DELETE ON ordersFOR EACH ROWBEGIN INSERT INTO archive_orders(order_num, order_date, cust_id) VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);END; 多语句触发器： 正如所见，触发器deleteorder使用BEGIN和END语句标记触发器体。这在此例子中并不是必需的，不过也没有害处。 使用BEGIN END块的好处是触发器能容纳多条SQL语句（在BEGIN END块中一条挨着一条）。 3.3 UPDATE触发器UPDATE触发器在UPDATE语句执行之前或之后执行 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问 以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新 更新的值； 在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值） OLD中的值全都是只读的，不能更新。 显然：数据净化都需要在 UPDATE 语句之前进行，就像这个例子中一样。每次更新一个行时， NEW.vend_state中的值（将用来更新表行的值）都用 Upper(NEW.vend_state) 替换。 此例子：保证州名缩写总是大写（不管 UPDATE 语句中给出的是大写还是小写）。 12CREATE TRIGGER updatevendor BEFORE UPDATE ON vendorsFOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state); 4、触发器补充知识 与其他DBMS相比，MySQL 5中支持的触发器相当初级。未来的 MySQL版本中有一些改进和增强触发器支持的计划。 创建触发器可能需要特殊的安全访问权限，但是，触发器的执行是自动的。如果INSERT、UPDATE或DELETE语句能够执行，则相关 的触发器也能执行。 应该用触发器来保证数据的一致性（大小写、格式等）。在触发器 中执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。 触发器的一种非常有意义的使用是创建审计跟踪。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易。 遗憾的是，MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"游标","slug":"游标","permalink":"https://www.itnxd.cn/tags/%E6%B8%B8%E6%A0%87/"},{"name":"触发器","slug":"触发器","permalink":"https://www.itnxd.cn/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/"}],"author":"Mr.Niu"},{"title":"数据库教程之表.视图.存储过程","slug":"数据库教程之表-视图-存储过程","date":"2020-07-01T03:05:00.000Z","updated":"2021-02-06T13:52:27.883Z","comments":true,"path":"posts/34686.html","link":"","permalink":"https://www.itnxd.cn/posts/34686.html","excerpt":"","text":"一、创建表1、简单示例如下：12345678910111213CREATE TABLE customers( cust_id int NOT NULL AUTO_INCREMENT, cust_name char(50) NOT NULL, cust_address char(50) NULL, cust_city char(50) NULL, cust_state char(50) NULL, cust_zip char(50) NULL, cust_country char(50) NULL, cust_contact char(50) NULL, cust_email char(50) NULL, PRIMARY KEY(cust_id)) ENGINE = InnoDB; 新表的名字，在关键字create table之后给出 表列的名字和定义，用逗号分隔 使用PRIMARY KEY()指出主键 使用ENGINE = InnoDB指出使用的引擎 2、IF NOT EXISTS 如果你仅想在一个表不存在则创建它，应该在表名后给出IF NOT EXISTS。 这样不做检查已有表的模式是否与你打算创建的表模式相匹配。它只是查看表名是否存在，并且仅在表名不存在时创建它。 3、NULL 默认为NULL，可以设定为NOT NULL 允许NULL值的列也允许在插入行时不给出该列的值。 4、主键 主键值必须唯一。 主键中只能使用不允许NULL值的列。允许值为NULL的列不能作为唯一标识。 如果主键使用单个列，则它的值必须唯一， 如果使用多个列，则这些列的组合值必须唯一。 主键可以在创建表时定义，也可以在创建表之后定义。 5、AUTO_INCREMENT AUTO_INCREMENT告诉MySQL，本列每当增加一行时，自动增量。 每个表只允许一个AUTO_INCREMENT列，而且它必须被索引 INSERT插入一行时若给定一个值（只要没使用过，是唯一的）该值会覆盖自动增量生成的值，后续的增量将开始使用该手工插入的值。 last_insert_id() 使用last_insert_id()获取最后一次自增的值！ 1SELECT last_insert_id()； 6、指定默认值 建表时可以指定默认值，使用DEFAULT 默认值只能是常量，不能是函数或其他！ 注意：一般不使用NULL值，而使用默认值！ 123456CREATE TABLE customers( cust_id int NOT NULL AUTO_INCREMENT, quantity int NOT NULL DEFAULT 1, PRIMARY KEY(cust_id)) ENGINE = InnoDB; 6、三种引擎 引擎类型可以混用。不同的表可以根据需要的功能使用不同的引擎. 外键不能跨引擎：混用引擎有一个大缺陷，外键不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎的表的外键。 InnoDB：可靠的事务处理引擎，不支持全文本搜索 MEMORY：功能上等同于MyISAM，但由于数据存储在内存中，速度很快 MyISAM：性能极高的引擎，支持全文本搜索，但不支持事务的处理。 二、更新表 使用 ALTER TABLE语句！ 1、增加列12ALTER TABLE vendorsADD vend_phone CHAR(20); 2、删除列12ALTER TABLE vendorsDROP vend_phone; 3、定义外键123ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_ordersFOREING KEY(order_num) REFERENCES orders(order_num); 4、复杂的表结构更改步骤 用新的列布局创建一个新表 使用INSERT SELECT语句从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段 检验包含所需数据的新表 重命名旧表(如果确定，可以删除它) 用旧表原来的名字重新命名新表 根据需要，重新创建触发器、存储过程、索引和外键。 三、删除表 使用DROP TALBE删除一个表！ 1DROP TABLE 表名; 四、重命名表 使用RENAME TABLE 新表名 TO 旧表名，可以有多个重命名 12345RENAME TABLE backup_customers TO customers;RENAME TABLE backup_customers TO customers, backup_vendors TO vendors, backup_products TO products; 五、视图1、视图 视图是虚拟的表，视图本身不包含数据。 与包含数据的表不一样，视图只包含使用时动态检索数据的查询。 视图是个啥？ 简单来说就是针对SELECT一系列操作的集合。。。为了之后操作的简单而引入！ 注意：视图返回的数据是从其他表中检索出来的，在添加或更加这些表中的数据时，视图将返回改变过的数据。 2、为什么使用视图算是优点吧！ 重用SQL语句 简化复杂SQL的操作 使用表的组成部分而不是整个表 保护数据。可以给用户手续表的特定部分的访问权限而不是整个表的访问权限。 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图执行 SELECT 操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据！ 性能问题： 如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会造成性能下降得很厉害。 3、视图的规则和限制 视图名字必须唯一(和表名一样，不能给视图取与别的视图或表名相同的名字) 对于可以创建的视图数目没有限制 为了创建视图，必须具有一足够的访问权限，这些限制通常由数据库管理人员授予。 视图可以嵌套，即可以利用从其他视图中检索出来的数据的查询来构造一个视图 ORDER BY可以用在视图中，但如果从该视图检索数据的select语句中也含有order by，那么该视图的order by会被覆盖 视图不能索引，也不能有关联的触发器或默认值 视图可以和表一起使用。例如，编写一条联结表和视图的select语句。 4、使用视图 视图用CREATE VIEW语句创建 使用show create view viewname查看创建视图的语句 使用drop view viewname来删除视图 更新视图：先drop再create，也可以直接使用create or replace view。 一次编写，到处运行？！！ 4.1 简化复杂联结 创建可重用的视图 创建不受特定数据限制的视图是一种好办法。扩展视图的范围不仅使得它能被重用，而且甚至更有用。这样做不需要创建和维护多个类似视图。 1234567891011-- 第一步：CREATE VIEW productcustomers ASselect cust_name, cust_contact, prod_idfrom customers, orders, orderitemswhere customers.cust_id = orders.cust_idand orderitems.order_num = orders.order_num;-- 第二步：select cust_name, cust_contactfrom productcustomerswhere prod_id = 'TNT2'; 4.2 重新格式化检索出的数据1234CREATE VIEW vendorlocations ASselect Contact(RTrim(vend_name)), '(', RTrim(vend_country),')')from vendorsorder by vend_name; 4.3 过滤不想要的数据 视图中的WHERE会和检索中的WHERE实行AND操作！ 1234CREATE VIEW customeremaillist ASSELECT cust_id, cust_name, cust_emailFROM customersWEHRE cust_email IS NOT NULL; 4.4 使用视图与计算字段1234567CREATE VIEW orderitemsexpanded ASSELECT order_num, prod_id, quantity, item_price, quantity*item_price AS expanded_priceFROM orderitems; 4.5 更新视图 通常，视图是可更新的，即可以对它们进行INSERT、UPDATE和DELETE。 更新一个视图将更新其基表。如果你对视图增加或删除，实际上是对基表进行增加和删除。 但是，并非所有的视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新。 注意：视图主要用于数据检索，而不用于更新。 即如果视图定义中有以下操作，则不能进行视图的更新： 分组(GROUP BY 或者HAVING) 联结 子查询 并 聚集函数(Min()、Max()、Count()、Sum()等) DISTINCT 导出(计算)列 六、存储过程 存储过程，简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。 类似其他语言的函数，一次声明，到处调用！ 1、存储过程的优缺点优点 通过把处理封装在容易使用的单元中，简化复杂操作。 由于不要求反复建立一系列处理步骤，保证了数据的完整性。如果所有开发人员和应用程序都使用同一存储过程，则使用的代码都是相同的。(减少错误) 简化对变动的管理。如果表名、列名或业务逻辑有变化，只需要修改存储过程的代码。使用它的人员甚至不需要知道这些变化。(安全性) 提高性能。存储过程比单独的SQL语句要快。 存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写共鞥更强更灵活的代码。 缺点 存储过程比SQL语句复杂得多 并不是所有人都有创建存储过程的安全访问权限。许多数据库管理员限制存储过程的创建权限，允许用户使用存储过程，但不允许他们创建存储过程。 2、执行存储过程 存储过程名可以理解为函数名，CALL表示简要调用此存储过程！ @param1、@param2.....等等为当前存储过程的参数，可以理解为函数的参数！ 12345678910CALL 存储过程名(@param1, @param2, ...);-- 实例如下：CALL productpricing(@pricelow, @pricehigh, @priceaveage); 3、创建存储过程 语法格式：CREATE PROCEDURE 存储过程名（@param1,@param2...） BEGIN ... END; BEGIN与END中间的就是存储过程的语句！ 12345CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END; 4、mysql命令行客户机的分隔符 默认的MySQL分隔符为;(和SQL语句一样)，mysql命令行实用程序也使用，作为语句分隔符。如果命令行实用程序要解释存储过程自身内；字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL语句出现句法错误。 简单来说就是;被占用了，sql语句就不会正确执行了。 解决办法： 更改默认分隔符;，使用完再进行还原！ 除\\ 符号外，任何字符都可以用作语句分隔符。 123456789-- 更改分隔符DELIMITER //CREATE PRODUCER productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END //-- 还原分隔符DELEMITER ; 5、删除存储过程 使用IF EXISTS，若不存在也将不会报错！ 语法格式：DROP PROCUDURE 存储过程 123DROP PROCEDURE 存储过程名;DROP PROCUDURE 存储过程名 IF EXISTS; 6、带参数的存储过程 一般，存储过程并不显示结果，而是把结果返回给你指定的变量（临时保存返回结果）。 参数必须有指定的类型。不能通过一个参数返回多个行和列。 格式：OUT/IN/INOUT 变量名 类型 SELECT ... INTO 参数名：即将结果传给该参数！ 12345678910111213141516CREATE PRODUCER productpricing( OUT pl DECIMAL(8, 2), OUT ph DECIMAL(8, 2), OUT pa DECIMAL(8, 2))BEGIN SELECT Min(prod_price) INTO pl FROM products; SELECT Max(prod_price) INTO ph FROM products; SELECT Avg(prod_price) INTO pa FROM products;END; 参数类型： OUT：指出相应的参数用来从存储过程传出一个值(返回给调用者) IN：传递给存储过程 INOUT：对存储过程传入和传出 开始执行存储过程： 这样调用存储过程就会将内部得到的值返回给@开头的三个参数！使用 SELECT @参数名 ...即可查询到当前结果！ 变量名：所有MySQL的变量都必须以@开始 1234567CALL productpricing(@pricelow, @pricehigh, @priceaveage);SELECT @priceaverage;SELECT @pricelow, @pricehigh, @priceaveage; 使用IN和OUT参数： 使用了IN自然就得传入一个参数，如下方的20005。 1234567891011121314151617-- 创建存储过程CREATE PRODUCER ordertotal( IN onumber INT, OUT ototal DECIMAL(8, 2))BEGIN SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num = onumber INTO ototal;END;-- 调用存储过程CALL orderitems(20005, @total);-- 查看结果select @total; 7、复杂存储过程 DECLARE：用于定义变量，需要指明类型！ COMMIT：不是必需的，但是如果给出，将在SHOW PROCEDURE STATUS的结果中显示。 IF：条件语句，还支持ELSEIF， ELSE语句，格式：IF THEN ELSEIF ELSE END IF; 12345678910111213141516171819202122232425262728293031323334-- Name：ordertotal-- Parameters：onumber = order number-- taxable = 0 if not taxable, 1 if taxable-- ototal = order total variableCREATE PROCEDURE ordertotal( IN onumber INT, IN taxable BOOLEAN, OUT ototal DECIMAL(8, 2)) COMMIT \"obtain order total, optionally adding tex\"BEGIN -- Declare variable for total DECLARE total DECIMAL(8, 2); -- Declare tax percentage DECLARE taxrate INT DEFAULT 6; -- Get the order total SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num = onumber INTO total; -- Is it taxable? IF taxable THEN -- Yes, so add taxrate to the total SELECT total+(total/100*taxrate) INTO total; END IF; -- And finally, save to out variable SELECT total INTO ototal;END;-- 调用存储过程CALL orderototal(20005, 0, @total);SELECT @total; 8、检查存储过程 可以显示用来创建一个存储过程的 CREATE 语句。 为了获得包括何时、由谁创建等详细信息的存储过程列表，使用 SHOW PROCEDURE STATUS。 12345678-- 显示创建存储过程的语句SHOW CREATE PROCEDURE ordertotal;-- 何时、由谁创建等详细信息SHOW PROCEDURE STATUS;-- 使用过滤SHOW PROCEDURE STATUS LIKE 'ordertotal'; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"表","slug":"表","permalink":"https://www.itnxd.cn/tags/%E8%A1%A8/"},{"name":"视图","slug":"视图","permalink":"https://www.itnxd.cn/tags/%E8%A7%86%E5%9B%BE/"},{"name":"存储过程","slug":"存储过程","permalink":"https://www.itnxd.cn/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-40.组合总和II","slug":"LeetCode刷题-40-组合总和II","date":"2020-06-27T14:09:19.000Z","updated":"2021-02-06T14:40:13.891Z","comments":true,"path":"posts/41794.html","link":"","permalink":"https://www.itnxd.cn/posts/41794.html","excerpt":"","text":"题目链接：40.组合总和II 题解： 和上一道类似，递归解决，多了一个限制！ 题目简述：给定一个数组（可能有相同元素），每个数只能用一次，求出和为目标值的组合。组合不能重复。 题解：上一题是没有相同元素，一数可多选。本题是有相同元素，一数只能一选。 关键点：将上一道题的dfs(candidates, target - candidates[i], i)的i改为i + 1即可，即可以保证一数一选。 第二点 ：需要进行判重，先排序，使得相同元素扎堆在一起，然后在进行同位置的选取时，进行判断跳过相同元素即可if(i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue;，这样会保证路径在同一个位置的选取不会重复，即可以保证结果不会有重复组合。 具体如何判重： 如果是同一个位置的第一次选取，是不会影响的，由于i &gt; start，第一次进去是i == start，同一个位置的多次选取，即回溯时遇到的for循环，candidates[i] == candidates[i - 1]，这个条件则可以保证同一个位置不选择重复的数。 同样使用递归解决： dfs(vector&lt;int&gt;&amp; candidates, int target, int start) start用来指向从该数组的哪一个数进行循环。 递归出口： target &lt; 0，即已经将目标值减没了，可以return了。 target == 0，恰好等于0，则说明找到了一种组合，将当前有效路径path加入答案res 从start开始循环，path添加当前选取值，进行下一轮dfs(candidates, target - candidates[i], i + 1)，start从i + 1开始即可，选下一个位置的数，超过即target &lt; 0，直接返回 一个位置选择完毕将会进入下一个位置的选取。 for循环内dfs的结束有两种情况，一是当前位置的条件下有解，二是当前位置条件下无解。然后进行回溯，取消path中的路径，找下一个位置的选取情况。 AC代码：1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(), candidates.end()); dfs(candidates, target, 0); return res; } void dfs(vector&lt;int&gt;&amp; candidates, int target, int start){ if(target &lt; 0) return; if(target == 0){ res.push_back(path); return; } for(int i = start; i &lt; candidates.size(); i++){ if(i &gt; start &amp;&amp; candidates[i] == candidates[i - 1]) continue; path.push_back(candidates[i]); dfs(candidates, target - candidates[i], i + 1); path.pop_back(); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-39.组合总和","slug":"LeetCode刷题-39-组合总和","date":"2020-06-27T14:08:53.000Z","updated":"2021-02-06T14:40:56.666Z","comments":true,"path":"posts/34556.html","link":"","permalink":"https://www.itnxd.cn/posts/34556.html","excerpt":"","text":"题目链接：39.组合总和 题解： 递归同一元素可重复选取的解决，用减法减到 0 为止！ 当然也可以加法加到目标值，都行！ 题目简述：给定一个无重复元素的序列，找到符合目标值的所有组合，不重复的组合。 题解：使用深搜即可，关键点，每个数可以选不止一次。 本题可进行累加，也可以进行累减。推荐使用累减版本！ 具体解决： dfs(vector&lt;int&gt;&amp; candidates, int target, int start) start用来指向从该数组的哪一个数进行循环。 递归出口： target &lt; 0，即已经将目标值减没了，可以return了。 target == 0，恰好等于0，则说明找到了一种组合，将当前有效路径path加入答案res 从start开始循环，path添加当前选取值，进行下一轮dfs(candidates, target - candidates[i], i)，start仍然从i开始即可，选同一个数的最多次，超过即target &lt; 0，直接返回 同一个数的最多次选择完毕将会进入下一个数的选取。 for循环内dfs的结束有两种情况，一是当前数的次数已经选到了最多，二是当前次数条件下无解。然后进行回溯，取消path中的路径，找下一个数的多次选取情况。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 累减版本class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { dfs(candidates, target, 0); return res; } void dfs(vector&lt;int&gt;&amp; candidates, int target, int start){ if(target &lt; 0) return; if(target == 0){ res.push_back(path); return; } for(int i = start; i &lt; candidates.size(); i++){ path.push_back(candidates[i]); dfs(candidates, target - candidates[i], i); path.pop_back(); } }};// 累加版本class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { dfs(candidates, target, 0, 0); return res; } void dfs(vector&lt;int&gt;&amp; candidates, int target, int start, int num){ if(target &lt; num) return; if(target == num){ res.push_back(path); return; } for(int i = start; i &lt; candidates.size(); i++){ path.push_back(candidates[i]); dfs(candidates, target, i, num + candidates[i]); path.pop_back(); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-38.外观数列","slug":"LeetCode刷题-38-外观数列","date":"2020-06-27T14:07:59.000Z","updated":"2021-02-06T14:40:36.834Z","comments":true,"path":"posts/58677.html","link":"","permalink":"https://www.itnxd.cn/posts/58677.html","excerpt":"","text":"题目链接：38.外观数列 题解： 嗯，做这种题得有宏观思想，我就是被细小地方搞混乱了！ 也是双指针的思想。 题目简述：给定一个序列1，接下来每一项都是前一项的描述，详细请看官网描述！ 题解：说白了，就是从前一项找到相同的字符的起始位置即可。。 例如：12233344只要能分成1、22、333、44四段即可！ 具体思路： 借助双指针思想，一个指向该段起点j，一个指向该段最后一个位置的下一个位置k即可。该段的长度就是k - j，该段的字符就是s[j]。 即最终为t += to_string(k - j) + s[j] 注意 ：使用两个变量来回切换，s指向上一个，t指向当前。以及j = k，来进行动态跳转到下一段位置起点！ 关于 to_string()： C++11支持的转换字符串函数，在这里如果不使用这个函数，也可以通过'0' + k - j，但是这样有个缺点，不能超过ASCII码的范围！ AC代码：1234567891011121314151617class Solution {public: string countAndSay(int n) { string s = \"1\"; for(int i = 0; i &lt; n - 1; i++){ string t; for(int j = 0; j &lt; s.size();){ int k = j + 1; while(k &lt; s.size() &amp;&amp; s[j] == s[k]) k++; t += to_string(k - j) + s[j]; j = k; } s = t; } return s; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-37.解数独","slug":"LeetCode刷题-37-解数独","date":"2020-06-27T12:10:59.000Z","updated":"2021-02-06T14:36:19.902Z","comments":true,"path":"posts/37046.html","link":"","permalink":"https://www.itnxd.cn/posts/37046.html","excerpt":"","text":"题目链接：37.解数独 题解： 好了，来开始解数独了！ 题目简述：同上一题，都是数独，此题用来解数独。 题解：这道题的第一个关键在于填数字的时候如何处理行列即九宫格是否有该数！ 同上一题的判断有效性，使用三个数组row[9][9], col[9][9], cell[3][3][9]来分别指向九行，九列，九个九宫格，的九个数来进行标记。 对于九宫格的处理： 可以对行列取除i / 3, j / 3，会发现只要是在九宫格他们得到的结果一定是每个九宫格左上角的坐标位置，这样就可以进行轻松的标记！ 递归过程： 递归出口，由于从左到右从上到下进行爆搜，所以： 若y == 9，则x ++, y = 0，即到了行末，进行换行 若x == 9，则return true ，即已经搜完了最后一行最后一个了，直接返回 若当前搜到的为.，则直接跳过，return dfs(board, x, y + 1) 否则，进行循环搜索，若行列九宫格都没有重复，则填充当前值，并将行列九宫格都标记为true 继续向后搜索，若可以搜到底，直接返回true，说明找到了一种情况。 否则，进行回溯，取消标记，将填充值恢复为. 若搜完九个数并没有可以填的数，直接返回false 注意： 将下标转换为字符，board[x][y] = '1' + i，将字符转换为数字，board[i][j] - '1' AC代码：12345678910111213141516171819202122232425262728293031class Solution {public: bool row[9][9], col[9][9], cell[3][3][9]; void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { for(int i = 0; i &lt; 9; i++){ for(int j = 0; j &lt; 9; j++){ if(board[i][j] != '.'){ int t = board[i][j] - '1'; row[i][t] = col[j][t] = cell[i / 3][j / 3][t] = true; } } } dfs(board, 0, 0); } bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y){ if(y == 9) x ++, y = 0; if(x == 9) return true; if(board[x][y] != '.') return dfs(board, x, y + 1); for(int i = 0; i &lt; 9; i++){ if(!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[x / 3][y / 3][i]){ board[x][y] = '1' + i; row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = true; if(dfs(board, x, y + 1)) return true; board[x][y] = '.'; row[x][i] = col[y][i] = cell[x / 3][y / 3][i] = false; } } return false; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"数独","slug":"数独","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%8B%AC/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-36.有效的数独","slug":"LeetCode刷题-36-有效的数独","date":"2020-06-27T12:10:38.000Z","updated":"2021-02-06T14:36:33.874Z","comments":true,"path":"posts/63579.html","link":"","permalink":"https://www.itnxd.cn/posts/63579.html","excerpt":"","text":"题目链接：36.有效的数独 题解： 数独游戏的到来，这道题判断是否有解，下一道题咱们来填数独！ 题目简述：给定一个9 X 9 的数独，判断当前状态是否有解！ 题解：判断是否有解，即判断行和列以及九个小九宫格是否会出现一个数多用的情况即可！ 判断行：直接遍历即可，每行进行一下数组清零 判断列：将i, j调换一下即可！每列进行一下数组清零 判断九宫格：可以使用i, j指向每个九宫格的第一个位置代表不同的九宫格，即i, j += 3 然后再在个九宫格中使用两层循环遍历九个格子即可，每个九宫格进行数组清零，指向的位置即为i + x, j + y 使用过直接返回false，全部遍历完都没问题，则返回true 注意：要将数独中的字符转变为数字进行！转换为了1 - 9 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { bool s[10]; for(int i = 0; i &lt; 9; i ++){ memset(s, 0, sizeof s); for(int j = 0; j &lt; 9; j ++){ if(board[i][j] != '.'){ int t = board[i][j] - '0'; if(s[t]) return false; s[t] = true; } } } for(int i = 0; i &lt; 9; i ++){ memset(s, 0, sizeof s); for(int j = 0; j &lt; 9; j ++){ if(board[j][i] != '.'){ int t = board[j][i] - '0'; if(s[t]) return false; s[t] = true; } } } for(int i = 0; i &lt; 9; i += 3){ for(int j = 0; j &lt; 9; j += 3){ memset(s, 0, sizeof s); for(int x = 0; x &lt; 3; x ++){ for(int y = 0; y &lt; 3; y ++){ if(board[i + x][j + y] != '.'){ int t = board[i + x][j + y] - '0'; if(s[t]) return false; s[t] = true; } } } } } return true; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数独","slug":"数独","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%8B%AC/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-35.搜索插入位置","slug":"LeetCode刷题-35-搜索插入位置","date":"2020-06-27T03:01:50.000Z","updated":"2021-02-06T14:36:52.728Z","comments":true,"path":"posts/24432.html","link":"","permalink":"https://www.itnxd.cn/posts/24432.html","excerpt":"","text":"题目链接：35.搜索插入位置 题解： 同样是二分！ 题目简述：给一个有序数组，查找目标值的位置，若数组中存在，返回该下标，否则返回目标值应该插入的位置！ 题解：继续二分： 找到二分条件：x &gt;= target，右端满足，左端不满足！ 如果最终该目标值越界，即nums[r] &lt; target，直接返回r + 1或nums.size()。 会发现：其实直接使用右端点r = nums.size()二分即可！最后也可以不用判断是否越界！ AC代码：123456789101112131415161718192021222324252627class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int l = 0, r = nums.size() - 1; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid; else l = mid + 1; } if(nums[r] &lt; target) return r + 1; return r; }};// 或者这样：class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int l = 0, r = nums.size(); while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid; else l = mid + 1; } return r; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-34.在排序数组中查找元素的第一个和最后一个位置","slug":"LeetCode刷题-34-在排序数组中查找元素的第一个和最后一个位置","date":"2020-06-27T03:01:28.000Z","updated":"2021-02-06T14:31:25.112Z","comments":true,"path":"posts/39392.html","link":"","permalink":"https://www.itnxd.cn/posts/39392.html","excerpt":"","text":"题目链接：34.在排序数组中查找元素的第一个和最后一个位置 题解： 同样是二分！ 题目简述：给定一个有序数组，找到目标值出现的开始和结束位置！ 题解：同样是二分：目的在于找到两个端点，如下图： 使用 x &gt;= target可以找到满足该条件的最后一个数，即左端点！ 使用x &lt;= target可以找到满足该条件的最后一个数， 即右端点！ 具体情况： 若数组为空，直接返回-1 若左端点不存在，即不存在target直接返回-1 否则，重新二分该数组找到右端点，最后返回。 注意： 二分左端点时，r的选取可以是nums.size() - 1，也可以是上次二分的结果。复杂度不影响！ AC代码：123456789101112131415161718192021class Solution {public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { if(nums.empty()) return {-1, -1}; int l = 0, r = nums.size() - 1; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid; else l = mid + 1; } if(nums[r] != target) return {-1, -1}; int L = r; l = 0, r = nums.size() - 1; while(l &lt; r){ int mid = l + r + 1 &gt;&gt; 1; if(nums[mid] &lt;= target) l = mid; else r = mid - 1; } return {L, r}; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-33.搜索旋转排序数组","slug":"LeetCode刷题-33-搜索旋转排序数组","date":"2020-06-27T03:00:58.000Z","updated":"2021-02-06T14:33:46.357Z","comments":true,"path":"posts/51598.html","link":"","permalink":"https://www.itnxd.cn/posts/51598.html","excerpt":"","text":"题目链接：33.搜索旋转排序数组 题解： 开始进入二分的时代，二分模板要掌握并理解。 题目简述：一个升序序列在某一点反转形成两个升序序列，从其中找到一个目标值，不存在返回 -1，要求时间复杂度为O(log n)级别。 题解：自然而然的想到要使用二分了！ 二分的二段性：一段满足，另一段不满足，则可以将分界点二分出来！ 二分可以找到满足条件的最后一个数！最后（指的是按照区间缩小的趋势最后满足条件的数） 二分模板：点击这里！ 注意：关于mid加不加一的问题，若 l= mid就得加，否则只有两数会造成死循环；若r = mid就不能加，否则只有两数也会造成死循环。 ‘ 本题分为了两段，根据二分的二段性，当 x &gt;= nums[0]的时候，会发现左边一段都符合条件，右边一段都不符合条件，可以使用二分，二分到分界点。 如下图： 找到分界点后，判断当前目标值在哪一段，继续进行二分即可！ 0 ~ mid mid + 1 ~ nums.size() - 1 AC代码：1234567891011121314151617181920212223class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { if(nums.empty()) return -1; // 0 1 int l = 0, r = nums.size() - 1; while(l &lt; r){ int mid = l + r + 1 &gt;&gt; 1; if(nums[mid] &gt;= nums[0]) l = mid; else r = mid - 1; } if(target &gt;= nums[0]) l = 0; else l = r + 1, r = nums.size() - 1; while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid; else l = mid + 1; } if(nums[r] == target) return r; else return -1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"}],"author":"Mr.Niu"},{"title":"数据库教程之事务及隔离","slug":"数据库教程之事务及隔离","date":"2020-06-26T02:51:23.000Z","updated":"2021-02-06T13:49:12.957Z","comments":true,"path":"posts/61605.html","link":"","permalink":"https://www.itnxd.cn/posts/61605.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、事务 把多条语句作为一个整体进行操作的功能，被称为数据库事务。 数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。 与多条语句分别执行而不使用事务的区别： 不使用事务，若某一句执行出错，则执行成功的语句将会生效 使用事务，若某一句执行出错，当我们关掉窗口再次打开则会自动触发回滚操作ROLLBACK 事务(transaction)：一组SQL语句 回退(rollback)：撤销指定SQL语句 提交(commit)：指将未存储的SQL语句结果写入数据库表 保留点(savepoint)：指事务处理中设置的临时占位符，你可以对它发布回退(与回退整个事务处理不同) 1、数据库事务的ACID四个特性 A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行； C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100； I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离； D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。 2、隐式事务 对于单条SQL语句，数据库系统自动将其作为一个事务执行！这种事务被称为隐式事务。 1UPDATE accounts SET balance = balance - 100 WHERE id = 1; 3、显示事务 对于多条SQL语句，想要使用事务，必须手动启用，使用BEGIN或START TRANSACTION开启一个事务，使用COMMIT提交一个事务，这种事务被称为显式事务。 有一句执行失败，系统就会调用ROLLBACK进行回滚。 1234BEGIN;UPDATE accounts SET balance = balance - 100 WHERE id = 1;UPDATE accounts SET balance = balance + 100 WHERE id = 2;COMMIT; 做个试验： 1234567891011121314151617181920212223242526-- 原来的样子mysql&gt; SELECT * FROM accounts;+----+---------+| id | balance |+----+---------+| 1 | 134 || 2 | 123 |+----+---------+2 rows in set (0.00 sec)-- 开始测试BEGIN;UPDATE accounts SET balance = balance - 100 WHERE id = 1;-- 此时为错误语句UPDATE accounts SET balance = balance + 100 WHERE d = 2;-- 现在关闭窗口 重新打开-- 会发现没有改变，系统自动进行了ROLLBACK操作mysql&gt; SELECT * FROM accounts;+----+---------+| id | balance |+----+---------+| 1 | 134 || 2 | 123 |+----+---------+2 rows in set (0.00 sec) 那些语句可以回退？ INSERT UPDATE DELETE SELECT(无意义) CREATE、DROP(事务处理块中可以使用这个语句，但是回退后，他们不会撤销操作) 4、主动失败 有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务。 如下方语句，会发现并没有造成修改，其实是做了回滚。 12345678910111213141516171819202122232425262728293031mysql&gt; SELECT * FROM accounts;+----+---------+| id | balance |+----+---------+| 1 | 134 || 2 | 123 |+----+---------+2 rows in set (0.00 sec)mysql&gt; BEGIN;Query OK, 0 rows affected (0.00 sec)mysql&gt; UPDATE accounts SET balance = balance - 100 WHERE id = 1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; UPDATE accounts SET balance = balance + 100 WHERE id = 2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; ROLLBACK;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT * FROM accounts;+----+---------+| id | balance |+----+---------+| 1 | 134 || 2 | 123 |+----+---------+2 rows in set (0.00 sec) 5、使用保留点 简单的事务可能只需要COMMIT或ROLLBACK，但是复杂的事务可能就需要进行部分提交或回退。 保留点可以使你回退到某个位置，而不是全部都进行回退！ 保留点越多越好 释放保留点保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。 创建保留点（占位符）： 1SAVEPOINT 保留点名字; 回退到保留点： 1ROLLBACK TO 保留点名字; 6、更改默认提交行为 默认的MySQL行为是自动提交的，如果要更改，需要使用以下语句： 1SET autocommit=0 autocommit标志决定是否自动提交更改，不管有没有COMMIT语句。 设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止）。 不管是平时的默认语句，还是事务，都需要commit之后才会提交，可以用两个终端来测试。 标志为连接专用: autocommit标志是针对每个连接而不是服务器的。 二、隔离级别 对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。 SQL标准定义了4种隔离级别： Isolation Level 脏读（Dirty Read） 不可重复读（Non Repeatable Read） 幻读（Phantom Read） Read Uncommitted Yes Yes Yes Read Committed - Yes Yes Repeatable Read - - Yes Serializable - - - 1、Read Uncommitted Read Uncommitted是隔离级别最低的一种事务级别。 在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。 先创建一个表： 12345678910111213141516171819mysql&gt; CREATE TABLE student_of_dirty_read ( -&gt; id BIGINT NOT NULL AUTO_INCREMENT, -&gt; name VARCHAR(100) NOT NULL, -&gt; PRIMARY KEY (id) -&gt; );Query OK, 0 rows affected (0.03 sec)mysql&gt; INSERT INTO student_of_dirty_read (name) VALUE (\"Alice\");Query OK, 1 row affected (0.01 sec)mysql&gt; SELECT * FROM student_of_dirty_read;+----+-------+| id | name |+----+-------+| 1 | Alice |+----+-------+1 row in set (0.00 sec)mysql&gt; 然后分别开启两个MySql数据连接，按顺序执行下列命令： 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; 2 BEGIN; BEGIN; 3 UPDATE students SET name = ‘Bob’ WHERE id = 1; 4 SELECT * FROM students WHERE id = 1; 5 ROLLBACK; 6 SELECT * FROM students WHERE id = 1; 7 COMMIT; SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED：意思是设置事务隔离级别为Read Uncommitted 1234567891011121314151617-- 第一次mysql&gt; SELECT * FROM student_of_dirty_read WHERE id = 1;+----+------+| id | name |+----+------+| 1 | Bob |+----+------+1 row in set (0.00 sec)-- 第二次mysql&gt; SELECT * FROM student_of_dirty_read WHERE id = 1;+----+-------+| id | name |+----+-------+| 1 | Alice |+----+-------+1 row in set (0.00 sec) 事务B两次输出不一样，读到了为提交的数据！这就是脏读！ 可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。 2、Read Committed 不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。 一点区别： Read Uncommitted 隔离级别下，一个事务可以读到另一个事务更新数据后未提交的数据 Read Committed 隔离级别下，一个事务在另一个事务更新数据后，不能读取另一个事务更新数据后 *未提交 *的数据(或者说想读取更新后的数据，必须在提交事务后；在提交事务前，只能读取到更新前的数据) 仍然是上面的未修改的表： 分别开启两个MySql数据连接，按顺序执行下列命令： 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; SET TRANSACTION ISOLATION LEVEL READ COMMITTED; 2 BEGIN; BEGIN; 3 UPDATE students SET name = ‘Bob’ WHERE id = 1; 4 SELECT * FROM students WHERE id = 1; 5 COMMIT; 6 SELECT * FROM students WHERE id = 1; 7 COMMIT; SET TRANSACTION ISOLATION LEVEL READ COMMITTED：意思是设置事务隔离级别为Read Committed 1234567891011121314151617-- 第一次：mysql&gt; SELECT * FROM student_of_dirty_read;+----+-------+| id | name |+----+-------+| 1 | Alice |+----+-------+1 row in set (0.00 sec)-- 第二次mysql&gt; SELECT * FROM student_of_dirty_read;+----+------+| id | name |+----+------+| 1 | Bob |+----+------+1 row in set (0.00 sec) 会发现事务B在事务A没提交的时候，只能读到原始数据，提交后才能读到修改后的数据。由于读到的两次数据不一致，所以这样的重复读会造成问题。 3、Repeatable Read 幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。 仍然是上面的未修改的表： 分别开启两个MySql数据连接，按顺序执行下列命令： 时刻 事务A 事务B 1 SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; 2 BEGIN; BEGIN; 3 SELECT * FROM students WHERE id = 99; 4 INSERT INTO students (id, name) VALUES (99, ‘Bob’); 5 COMMIT; 6 SELECT * FROM students WHERE id = 99; 7 UPDATE students SET name = ‘ccc’ WHERE id = 99; 8 SELECT * FROM students WHERE id = 99; 9 COMMIT; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ：意思是设置事务隔离级别为Repeatable Read 12345678910111213141516-- 第一次：mysql&gt; SELECT * FROM student_of_dirty_read WHERE id = 99;Empty set (0.00 sec)-- 第二次：mysql&gt; SELECT * FROM student_of_dirty_read WHERE id = 99;Empty set (0.00 sec)-- 第三次mysql&gt; SELECT * FROM student_of_dirty_read;+----+------+| id | name |+----+------+| 1 | ccc |+----+------+1 row in set (0.00 sec) 第一次读不到，第二次仍然读不到，第三次更新却可以进行，并且查询也可以正常进行，这就是幻读。 4、Serializable Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。 虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。 5、默认隔离级别 如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"事务","slug":"事务","permalink":"https://www.itnxd.cn/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"隔离","slug":"隔离","permalink":"https://www.itnxd.cn/tags/%E9%9A%94%E7%A6%BB/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-32.最长有效括号","slug":"LeetCode刷题-32-最长有效括号","date":"2020-06-25T10:37:59.000Z","updated":"2021-02-06T14:34:14.946Z","comments":true,"path":"posts/24831.html","link":"","permalink":"https://www.itnxd.cn/posts/24831.html","excerpt":"","text":"题目链接：32.最长有效括号 题解： 又是动态规划的题，需要多加理解与按步骤走；同时使用栈也可以巧妙的解决！ 题目简述：给定一个包含左右括号的字符串，需要求出最长的有效匹配括号的子串的长度！ 题解一：使用栈首先，先回忆一下括号匹配的两个条件？ 上次的括号问题有提到的，点击这里！ 左右括号相等 任意前缀左括号数量大于等于右括号数量 接下来，我们可以将该括号序列分为若干段： 从前向后找，找到右括号大于左括号的位置，此时就是一段合法区间 从所有合法区间中找到一个最大匹配有效长度即可 参考下面的图： 具体操作： 使用start标记可匹配区间的上一个元素，即每次出现的右大于左的位置！ 遇到左括号直接进栈 遇到右括号： 若栈不空，说明没走到右大于左的位置，此时栈顶元素与之对应的左括号出栈 如果出栈后栈空，说明从起点start到当前位置i是一组有效括号序列，更新最大值 如果出栈后不空，说明栈顶到当前位置i是一组有效括号序列，更新最大值 若栈为空，说明已经走到右大于左的位置，此时更新start为当前位置i AC代码一：123456789101112131415161718class Solution {public: int longestValidParentheses(string s) { stack&lt;int&gt; stk; int res = 0; for(int i = 0, start = -1; i &lt; s.size(); i++){ if(s[i] == '(') stk.push(i); else{ if(stk.size()){ stk.pop(); if(stk.size()) res = max(res, i - stk.top()); else res = max(res, i - start); }else start = i; } } return res; }}; 题解二：动态规划 参考题解：点击这里！ 题目中提到了最长，可以考虑使用动态规划解题！ 同样分为两步： 状态表示：一个字符串，使用一维数组dp[i]，表示以s[i]为结尾的字符串中有效括号的最大长度（包括i） 状态计算： 若s[i]为左括号，由于左括号不可能和之前括号组合为有效括号，故 dp[i] = 0 若s[i]为右括号： 若s[i - 1]为左括号，形如：...()，此时dp[i] = 2；若相邻的之前还有匹配括号，则dp[i] += dp[i - 2]，见下方图一！ 若s[i - 1]为右括号，形如：...))，则此时只有保证当前右括号有匹配项，即dp[i - 1] &gt; 0，形如：...(...))；并且保证s[i]也有括号匹配，即s[i - dp[i - 1] - 1] == '('，形如：...((...))，这样才可完成s[i]的匹配，此时dp[i] = dp[i - 1] + 2；若与s[i]匹配的左括号相邻的之前还有匹配括号，形如：.(..)((...))，则dp[i] += dp[i -dp[i - 1] - 2]，见下方图二！ 图一： 图二： AC代码二：1234567891011121314151617181920class Solution {public: int longestValidParentheses(string s) { vector&lt;int&gt; dp(s.size()); int res = 0; for(int i = 1; i &lt; s.size(); i++){ if(s[i] == ')'){ if(s[i - 1] == '('){ dp[i] = 2; if(i - 2 &gt;= 0) dp[i] += dp[i - 2]; }else if(dp[i - 1] &gt; 0 &amp;&amp; i - dp[i - 1] - 1 &gt;= 0 &amp;&amp; s[i - dp[i - 1] - 1] == '('){ dp[i] = dp[i - 1] + 2; if(i - dp[i - 1] - 2 &gt;= 0) dp[i] += dp[i -dp[i - 1] - 2]; } res = res &lt; dp[i] ? dp[i] : res; } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-31.下一个排列","slug":"LeetCode刷题-31-下一个排列","date":"2020-06-25T10:37:25.000Z","updated":"2021-02-06T14:29:10.719Z","comments":true,"path":"posts/17783.html","link":"","permalink":"https://www.itnxd.cn/posts/17783.html","excerpt":"","text":"题目链接：31.下一个排列 题解： 手动实现全排列函数，有点巧妙！ 题目简述：给定一个序列，计算出按照字典序的下一组更大的排列！ 题解一：直接调用algorithm头文件里的next_permutation即可！ 当然，本题意在让你自己实现，而不是调用库函数，题解二将进行手动实现。 AC代码一：123456class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { next_permutation(nums.begin(), nums.end()); }}; 题解二：思路： 从后向前找一个降序序列，该序列的第一个元素为最大值，找到当前序列的上一个元素，即非降序位置。 从后面的降序序列找一个比当前非降序位置值大的最小元素，交换二者位置。 将降序序列倒序 简图如下： 我的简单理解与解释： 后面是一个降序序列，要想找到下一个字典序，必须找到降序的上一个非降序的位置，因为降序序列的位置是不能动的，该降序序列已经到了字典序的最大值，要动也是前一个位置进行变大。 变多大呢？ 当然是变一个比当前值大的，而且是大的中的最小值，然后后面从小到大排列，像是加法的进位一样！ AC代码二：123456789101112131415class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { int k = nums.size() - 1; while(k &gt; 0 &amp;&amp; nums[k - 1] &gt;= nums[k]) k--; if(k &lt;= 0){ reverse(nums.begin(), nums.end()); }else{ int t = k; while(t &lt; nums.size() &amp;&amp; nums[t] &gt; nums[k - 1]) t++; swap(nums[t - 1], nums[k - 1]); reverse(nums.begin() + k, nums.end()); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"全排列","slug":"全排列","permalink":"https://www.itnxd.cn/tags/%E5%85%A8%E6%8E%92%E5%88%97/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-30.串联所有单词的子串","slug":"LeetCode刷题-30-串联所有单词的子串","date":"2020-06-22T08:37:11.000Z","updated":"2020-06-22T10:21:00.426Z","comments":true,"path":"posts/49123.html","link":"","permalink":"https://www.itnxd.cn/posts/49123.html","excerpt":"","text":"题目链接：30.串联所有单词的子串 题解： 嗯，有点难度，使用哈希表和分类的思想！ 题目简述：给定一个字符串，一个字符串数组，从字符串中找出可以包含字符串数组左右元素的起始位置！ 题解：暴力：不推荐 这里直接采用高效率的算法： 预先规定： n = s.size(), m = words.size(), w = words[0].size(); 使用分类思想： 本题可以划分为w类，如下图所示： 可以发现，可以把起点分为0 - w-1的w组，你会惊奇的发现，起点从w-1往后，都已经被前面的情况所包括了！ 而且，我们扫描时按单词的长度w往后走，即每个单词一定落在坑里！ 具体做法： 使用一个哈希表tot记录words数组中单词出现的数量，使用另个一个哈希表wd 动态 记录选定区间的单词数量。 当两个哈希表单词和数量对应相等时即匹配了一组，继续后续匹配。 怎样处理两个哈希表是否一致，暴力，复杂度太高，所以使用一个 动态 变量cnt，用来统计两个容器对应的个数！ 当cnt == m时，即为找到了一组合法区间。 如何动态维护wd哈希表？ 如果当前处理个数不到m，即j &lt; i + m * w，则不需要进行哈希表的左端删除，只进行有端的添加，将当前单词substr(j, w)截取出来，wd[word]++进行统计： 若统计完以后，发现当前单词个数比需要的数量&gt;= tot[word]，则说明当前单词不在tot中，不需要统计 否则，说明当前单词在tot容器中，cnt++ 如果当前处理个数大于等于m个，即j &gt;= i + m * w，则需要进行左端的删除和有端的添加，动态维护wd容器为m个单词。截取substr(j - m * w, w)第一个单词，wd[word]--进行统计： 若统计完以后，发现当前单词个数比需要的数量tot[word]要少，说明当前单词删除有效，删的在tot中，cnt-- 否则说明，删除了一个不在tot中的单词，无序处理cnt 进行有端的添加，和第一步一样操作一模一样。 匹配条件：cnt == m即两个哈希表匹配成功，找到了一组合法区间一一对应，起始下标为j - (m - 1) * w 下标图解如下： 时间复杂度： 小区间个数为n / w，一共分为了w类，哈希表的插入删除复杂度为word长度w，总时间复杂度为O(n / w * w * w) = O(n * w) 进一步优化： 使用字符串哈希，可以将哈希表的插入删除降到O(1)，总时间复杂度降为O(n)。奈何没有学到，今后再学习，进行补充！ AC代码：123456789101112131415161718192021222324252627class Solution {public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) { vector&lt;int&gt; res; if(words.empty()) return res; int n = s.size(), m = words.size(), w = words[0].size(); unordered_map&lt;string, int&gt; tot; for(auto&amp; word : words) tot[word]++; for(int i = 0; i &lt; w; i++){ unordered_map&lt;string, int&gt; wd; int cnt = 0; for(int j = i; j + w &lt;= n; j += w){ if(j &gt;= i + m * w){ auto word = s.substr(j - m * w, w); wd[word]--; if(wd[word] &lt; tot[word]) cnt--; } auto word = s.substr(j, w); wd[word]++; if(wd[word] &lt;= tot[word]) cnt++; if(cnt == m) res.push_back(j - (m - 1) * w); } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-29.两数相除","slug":"LeetCode刷题-29-两数相除","date":"2020-06-22T08:36:25.000Z","updated":"2020-06-22T10:21:00.419Z","comments":true,"path":"posts/6904.html","link":"","permalink":"https://www.itnxd.cn/posts/6904.html","excerpt":"","text":"题目链接：29.两数相除 题解： 嗯，倍增思想的应用！ 题目简述：给定两个int范围的数相除，要求不使用乘除法和取余计算得到结果！ 题解一：暴力不能使用乘除就使用减法，一直减去除数直到减到负数即可！ 当然这样会超时，例如输入：2147483647 和 1 ，此时的数量级是10的9次方的，妥妥超时！ 超出int范围，统一返回INT_MAX 正确做法：请看题解二，使用倍增思想！ TLE代码：12345678910111213class Solution {public: int divide(int dividend, int divisor) { long long res = 0, k = 1; if((dividend &lt; 0 &amp;&amp; divisor &gt; 0) || (dividend &gt; 0 &amp;&amp; divisor &lt; 0)) k = -1; long long dividend1 = abs(dividend), divisor1 = abs(divisor); while(dividend1 - divisor1 &gt;= 0){ res ++; dividend1 -= divisor1; } return k == 1 ? (res &gt; INT_MAX ? INT_MAX : res) : (-res &lt; INT_MIN ? INT_MAX : -res); }}; 题解二：倍增一个一个减岂不是有点笨？ 那么我们就每次尽可能多的去减！ a / b = k 先预处理出来，1 * b 2 * b 4 * b 8 * b...... k * b 然后倒着去减，从大到小减，直到剩下的不够减的大小，即终止！ 第一次减去 k * b，若足够大，继续向后去减！ 由于我们的答案求得是k的和，而不是k * b的和，所以我们要将每次减去的k累积起来！ k 的取值：1 2 4 8 16..... 即 2^0 2^1 2^2 2^3 2^4 ......2^k 所以每次给res累积1ll &lt;&lt; i;即可！ 注意： 1ll：防止越界，转化为ll类型。例如i = 31就会发生越界 开始时将其全部转化为正数进行计算，最后再转换回来 使用abs()也要使用LL强转，防止越界 如果res最后越界，统一返回INT_MAX AC代码：12345678910111213141516171819202122class Solution {public: int divide(int x, int y) { typedef long long LL; LL res = 0, k = 1; if(x &lt; 0 &amp;&amp; y &gt; 0 || x &gt; 0 &amp;&amp; y &lt; 0) k = -1; LL a = abs((LL)x), b = abs((LL)y); vector&lt;LL&gt; p; for(LL i = b; i &lt;= a; i += i) p.push_back(i), cout &lt;&lt; i &lt;&lt; endl; for(int i = p.size() - 1; i &gt;= 0; i--){ if(p[i] &lt;= a){ res += 1ll &lt;&lt; i; a -= p[i]; } } if(k == -1) res = -res; if(res &lt; INT_MIN || res &gt; INT_MAX) res = INT_MAX; return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"倍增","slug":"倍增","permalink":"https://www.itnxd.cn/tags/%E5%80%8D%E5%A2%9E/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-28.实现strStr()","slug":"LeetCode刷题-28-实现strStr","date":"2020-06-21T15:13:02.000Z","updated":"2021-02-06T14:28:42.332Z","comments":true,"path":"posts/45773.html","link":"","permalink":"https://www.itnxd.cn/posts/45773.html","excerpt":"","text":"题目链接：28.实现strStr() 题解： 嗯，使用暴力就是简单题！ 提高效率使用KMP，复杂了，好好理解，多实现，最好记住模板！本题就是一个模板。 题目简述：给定两个字符串，从第一个中找第二个串，能找到返回起始下标，找不到返回-1，第二个串为空，直接返回0。 题解一：暴力直接扫描一遍原串即可： 先判断当前位置是否够子串的长度，不够直接返回-1，因为肯定没有可以匹配的。 如果位置长度够，就从当前位置截取和子串长度相同，查看是否相等，相等直接返回当前下标i，否则继续下次循环 时间复杂度：substr(pos, m)：复杂度为O(len)，总时间复杂度为O(n*m) AC代码一：123456789101112131415161718192021222324class Solution {public: int strStr(string haystack, string needle) { if(needle.empty()) return 0; for(int i = 0; i &lt; haystack.size(); i++){ if(haystack.size() - i &lt; needle.size()) return -1; if(haystack.substr(i, needle.size()) == needle) return i; } return -1; }};// 改一下这样可能更好。class Solution {public: int strStr(string haystack, string needle) { if(needle.empty()) return 0; for(int i = 0; haystack.size() - i &gt;= needle.size(); i++) if(haystack.substr(i, needle.size()) == needle) return i; return -1; }}; 题解二：KMP 为了弄明白KMP算法，我也是盯着看，画着图搞了一上午！ 这也是一个模板题，需要记下来并掌握代码的实现及理解该算法的运行流程！ 时间复杂度： O(n + m) 为了方便，这里将字符串都从1开始！ 1s = \" \" + s, p = \" \" + p; KMP算法的核心就是一个next数组： next数组的作用：若没有该数组，后续匹配过程中出现不匹配的话，需要将起始位置后移一位，重新开始一一匹配，但是有了该数组，就不一定是移动一位了，而是移动尽可能多的位置，使得前j个字符和原串仍然匹配，只需判断第j + 1个字符即可！ 首先搞清楚next数组存储的东西是什么？ next[i]： 所有s[1]-s[i]中前缀等于后缀的最大长度（特指非平凡前缀和后缀） 非平凡：指的是不包括自己，eg：abc中的next[3]不能为3，应该为0。 举个例子： 举个例子：abcdefghabcd中，next[12]就应该为4，即前缀和后缀相等的最大长度，为前缀abcd和后缀abcd匹配时的值。 下一个问题，怎么求next数组？ 首先，next[0]不需要管，下标从1开始，next[1] = 0，非平凡不包括自己！ 从下标为2开始即可！ 假设当前状态如下：i - 1为原串p指向的位置，j为p的前缀后缀相等时前缀的尾。序号1和序号2是同一段，序号3是原串1 ~ (i - 1)中与前缀相等的后缀，此时序号1，2，3都是相等的。 若 i 和 j + 1可以匹配，此时next[i]就会由j变为j + 1，则效果图如下： 若 i 和 j + 1无法匹配，则说明前缀串1 ~ j无法满足当前next[i]的条件，此时j的位置就需要发生变化，将前缀缩小为1 ~ next[j]去试探此时是否可以匹配next[i]的条件，若一直无法匹配，已经到了next[1] = 0或j == 0时，仍然无法匹配，则当前next[i] = 0；若试探中，某次可以匹配，则当前next[i]的值就可以更新为当前next[j] + 1 会发现后面的next计算都在前面已经算出来的基础上进行试探的，而前面算出来的都是前后缀相等且最长的，所以这样可以求得所有next数组的值，且一定是正确的！ 下一个问题，怎么求子串与原串的匹配并计算得到起始下标？ 和求解next数组一样，求解next数组是用的两个待匹配字符串p，求下面这个问题则只需要将第一个串换成s串即可，最后只需要判断什么时候等于待匹配字符串的长度，直接计算返回该下标即可！ 什么时候就算找到了？ 当然是当j == m的时候，即说明此时已经匹配完了p串。 最终返回的长度就是i - m，即s串的匹配终点的前m个字符的位置，应该为i - m + 1，但是我们下标是从1开始，所以要减去1，i - m + 1 - 1即i - m。 注意：需要特判p串为空的情况，需要返回0。 AC代码二：123456789101112131415161718192021class Solution {public: int strStr(string s, string p) { if(p.empty()) return 0; int n = s.size(), m = p.size(); s = \" \" + s, p = \" \" + p; vector&lt;int&gt; next(m + 1); for (int i = 2, j = 0; i &lt;= m; i ++){ while(j &amp;&amp; p[i] != p[j + 1]) j = next[j]; if(p[i] == p[j + 1]) j ++; next[i] = j; } for (int i = 1, j = 0; i &lt;= n; i ++){ while(j &amp;&amp; s[i] != p[j + 1]) j = next[j]; if(s[i] == p[j + 1]) j ++; if(j == m) return i - m; } return -1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://www.itnxd.cn/tags/KMP/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-27.移除元素","slug":"LeetCode刷题-27-移除元素","date":"2020-06-21T15:11:51.000Z","updated":"2021-02-06T14:29:29.371Z","comments":true,"path":"posts/37226.html","link":"","permalink":"https://www.itnxd.cn/posts/37226.html","excerpt":"","text":"题目链接：27.移除元素 题解： 简单题，两行代码！ 题目简述：去除数组中值等于val的数，并返回去掉后的长度。 题解：同样使用双指针，一个指针i指向数组当前扫描位置，一个指针k指向当前新数组的下一个元素，遇到和val值相等的，直接跳过即可！ AC代码：123456789class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int k = 0; for(int i = 0; i &lt; nums.size(); i++) if (nums[i] != val) nums[k++] = nums[i]; return k; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-26.删除排序数组中的重复项","slug":"LeetCode刷题-26-删除排序数组中的重复项","date":"2020-06-21T15:11:20.000Z","updated":"2020-06-22T06:15:32.490Z","comments":true,"path":"posts/20075.html","link":"","permalink":"https://www.itnxd.cn/posts/20075.html","excerpt":"","text":"题目链接：26.删除排序数组中的重复项 题解： 嗯，简单题。 题目简述：删除有序数组长度重复项，返回不重复元素的长度！ 题解：用两个指针一个指针t指向不重复元素的末尾，一个指针i指向当前扫描的位置，如果当前扫描位置和不重复元素的末尾相同，则继续后移，找到不一样的插到不重复元素的下一个位置。 最后返回长度，此处t指向下标，长度为t + 1. 注意：这样写需要特判nums为空的情况！ AC代码：12345678910111213141516171819202122232425class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return 0; int t = 0; for(int i = 0; i &lt; nums.size();){ while(i &lt; nums.size() &amp;&amp; nums[i] == nums[t]) i++; if(i &lt; nums.size()) nums[++t] = nums[i]; } return t + 1; }};// 这样一写，更加简洁：class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return 0; int t = 0; for(int i = 0; i &lt; nums.size(); i++) if(nums[i] ！= nums[t]) nums[++t] = nums[i]; return t + 1; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%BB%84/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-25.K个一组翻转链表","slug":"LeetCode刷题-25-K个一组翻转链表","date":"2020-06-21T13:24:47.000Z","updated":"2021-02-06T14:26:13.396Z","comments":true,"path":"posts/42577.html","link":"","permalink":"https://www.itnxd.cn/posts/42577.html","excerpt":"","text":"题目链接：25.K个一组翻转链表 题解： 两两一组升级为 k 个一组！ 参考上一篇两两一组的解法，基本一致！ 题目简述：给定一个链表，k个一组进行倒序反转！ 题解一：我的 –&gt; 乱嗯，不推荐看这个，虽然我自己写的也AC了，但是着实有点乱，有点多，不条理。非常建议直接看题解二：更加清晰！ 接下来介绍一下我的乱乱的思路： 特判一下k为1的情况，直接返回即可 先通过pt指针循环找到第k个节点。用b指针指向第k个节点。用a指针指向第一个节点。（如果存在） 如果不够第k个节点，直接返回。 用t指向第二个节点， p指向第k个节点b 使用循环将第二个节点到第k个节点全部反向指一下。 使用s指针指向第k个节点到第二个节点。 使用b来反向连接 t-&gt;next = a：第二个指向第一个 p = a：p指向a 。。。。其实画个图还是很明白的，我懒得画了，毕竟有点乱！ 强烈建议看题解二！ AC代码一：（复杂，不调理，易错）123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseKGroup(ListNode* head, int k) { if(k == 1) return head; auto dummy = new ListNode(-1), p = dummy; dummy-&gt;next = head; bool ok = true; while(1){ ListNode* a, *b; ListNode* t, *pt = p; bool ok = true; for(int i = 0; i &lt; k; i++){ if(i == 0 &amp;&amp; pt-&gt;next) a = pt-&gt;next; if(pt-&gt;next) pt = pt-&gt;next, b = pt; else{ ok = false; break; } } if(!ok) break; p-&gt;next = b; t = a-&gt;next; a-&gt;next = b-&gt;next; for(int j = 0; j &lt; k - 2; j++){ auto s = t; for(int i = 0; i &lt; k - j - 3; i++) s = s-&gt;next; b-&gt;next = s; b = s; } t-&gt;next = a; p = a; } return dummy-&gt;next; }}; 题解二：别人的 –&gt; 清晰同样：和两个一组反转类似，同样使用a、b指向第一个和第二个，多了一个c指向第三个，防止找不到下一个。 使用q来判断存不存在第k个节点。 内部的for循环用来将第1个到第k个节点反转链接。a、b顺次后移，如下图的第一二步： 然后让p指向第k个节点a，让外部的c（始终指向第一个节点，即转换后的最后一个节点）指向第k个节点的下一个，即下一组的开始。然后p节点后移，指向下一组节点的上一个节点c 具体如图所示：看图更易于理解！ AC代码二：（清晰）123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseKGroup(ListNode* head, int k) { auto dummy = new ListNode(-1), p = dummy; dummy-&gt;next = head; while(p){ auto q = p; for(int i = 0; i &lt; k &amp;&amp; q; i++) q = q-&gt;next; if(!q) break; auto a = p-&gt;next, b = a-&gt;next; for(int i = 0; i &lt; k - 1; i++){ auto c = b-&gt;next; b-&gt;next = a; a= b, b = c; } auto c = p-&gt;next; p-&gt;next = a, c-&gt;next = b; p = c; } return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-24.两两交换链表中的节点","slug":"LeetCode刷题-24-两两交换链表中的节点","date":"2020-06-21T13:14:13.000Z","updated":"2020-06-22T06:15:32.485Z","comments":true,"path":"posts/28774.html","link":"","permalink":"https://www.itnxd.cn/posts/28774.html","excerpt":"","text":"题目链接：24.两两交换链表中的节点 题解： 链表的指针切换问题！ 题目简述：给定一个链表，两两相邻的做一下交换。 我的错误题解：我的代码如下： l指向 2 再指向 1 ，此时2到3已经断了，会发现1和2已经成环了，会形成死循环！ 我看了好久，都没发现2到3已经断了，还以为head-&gt;next-&gt;next为3了，懵逼了！ 以此为戒：做链表题一定要画好图，看清哪里断了，哪里没断！ 错误代码：1234567891011121314151617181920/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { auto dummy = new ListNode(-1), l = dummy; while(head){ l-&gt;next = head-&gt;next; l = head-&gt;next; l-&gt;next = head; l = head; head = head-&gt;next-&gt;next; } return dummy-&gt;next; }}; 题解：使用两个指针，（类似双指针解法），一个指向带翻转的第一个，一个指向第二个。如下图： 第二步一定要在第三步之前，否则下一个节点就找不到了！ p永远指向下一组节点的上一个节点，a、b永远指向下一组节点。 要严格保证后面有两个节点或以上才可以，p-&gt;next &amp;&amp; p-&gt;next-&gt;next，即这两个节点非空！ AC代码：1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { auto dummy = new ListNode(-1), p = dummy; dummy-&gt;next = head; while(p-&gt;next &amp;&amp; p-&gt;next-&gt;next){ auto a = p-&gt;next, b = a-&gt;next; p-&gt;next = b; a-&gt;next = b-&gt;next; b-&gt;next = a; p = a; } return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-23.合并K个排序链表","slug":"LeetCode刷题-23-合并K个排序链表","date":"2020-06-21T11:56:39.000Z","updated":"2020-06-22T06:15:32.477Z","comments":true,"path":"posts/57955.html","link":"","permalink":"https://www.itnxd.cn/posts/57955.html","excerpt":"","text":"题目链接：23.合并K个排序链表 题解： 由二路归并变为k路归并，有优化的地方的！ 题目简述：k个有序链表，合并生成一个有序链表。 题解一：低效率（我的）嗯，暴力去扫描每个最小值！ 具体： mint：记录当前最小的节点。 minv：记录当前最小节点所在的链表的下标 特判一下当前链表是否为空，是的话直接跳过。 如果能找到最小值，即minv != -1，则更新当前链表即最小值所在链表！ 找不到最小值直接退出 时间复杂度：假设链表数组个数为 N，扫描每个最小值都要N次，所有链表元素为M的话，最终时间复杂度为 O(N*M) 欢迎查看题解二：使用堆优化！ AC代码一：123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { auto dummy = new ListNode(-1), p = dummy; while(1){ auto mint = new ListNode(INT_MAX); int minv = -1; for(int i = 0; i &lt; lists.size(); i++){ if(!lists[i]) continue; if(mint-&gt;val &gt; lists[i]-&gt;val){ mint = lists[i]; minv = i; } } if(minv != -1) { p-&gt;next = mint; p = p-&gt;next; lists[minv] = lists[minv]-&gt;next; } else break; } return dummy-&gt;next; }}; 题解二：高效率（别人的）查找最小值可以使用堆来进行优化，将查询的时间复杂度从O(N)降到O(logN)，整体时间复杂度为O(M*logN) 堆，即使用优先队列priority_queue： 先将每个序列的头结点插入堆，（如果存在） 然后去取堆顶元素，直到去完（即最小值都已查找了一遍），若当前最小值有后继结点，则将其插入堆中。 由于使用的是priority_queue&lt;ListNode*&gt;类型，所以需要重载小括号： return a-&gt;val &lt; b-&gt;val：即默认的降序 return a-&gt;val &gt; b-&gt;val：即升序 特殊之处：priority_queue的排序函数不是函数，是一个结构体，需要这样来写： 12345struct Cmp{ bool operator() (ListNode* a, ListNode* b){ return a-&gt;val &gt; b-&gt;val; }}; AC代码二：123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: struct Cmp{ bool operator() (ListNode* a, ListNode* b){ return a-&gt;val &gt; b-&gt;val; } }; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Cmp&gt; heap; auto dummy = new ListNode(-1), p = dummy; for(auto l : lists) if(l) heap.push(l); while(heap.size()){ auto t = heap.top(); heap.pop(); p-&gt;next = t; p = p-&gt;next; if(t-&gt;next) heap.push(t-&gt;next); } return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://www.itnxd.cn/tags/%E5%A0%86/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"},{"name":"k路归并","slug":"k路归并","permalink":"https://www.itnxd.cn/tags/k%E8%B7%AF%E5%BD%92%E5%B9%B6/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-22.括号生成","slug":"LeetCode刷题-22-括号生成","date":"2020-06-21T11:56:10.000Z","updated":"2020-06-22T06:15:32.481Z","comments":true,"path":"posts/51962.html","link":"","permalink":"https://www.itnxd.cn/posts/51962.html","excerpt":"","text":"题目链接：22.括号生成 题解： 简单的递归问题，会在题解二给出一个关于括号匹配的结论！非常重要！ 题目简述：给定一个n，找到所有n组括号有效可匹配的情况。 题解一：低效率（我的）很明显：直接使用DFS即可！ void dfs(int l, int r, int n, string path) l：记录左括号使用数 r：记录右括号使用数 n：记录括号组数 path：记录当前情况的括号组合 bool isMatch(string str)：判断当前括号序列是否是有效匹配 这里我使用了dfs(1, 0, n, \"(\")作为入口，即可以排除)开头的不可能匹配序列！虽然优化了一点点，但是还是请看题解二！ 退出条件 ：l == n &amp;&amp; r == n，即左右括号都已经使用够了n个。 这样有一个麻烦：由于这样会生成一个全排列，每次都需要判断是否是合法的括号序列，浪费了许多时间。所以请查看题解二解决这个麻烦！ AC代码一：12345678910111213141516171819202122232425class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; generateParenthesis(int n) { dfs(1, 0, n, \"(\"); return res; } void dfs(int l, int r, int n, string path){ if(l == n &amp;&amp; r == n){ if(isMatch(path)) res.push_back(path); return; } if(l &lt; n) dfs(l + 1, r, n, path + '('); if(r &lt; n) dfs(l, r + 1, n, path + ')'); } bool isMatch(string str){ stack&lt;char&gt; stk; for(int i = 0; i &lt; str.size(); i++){ if(stk.empty() &amp;&amp; str[i] == ')') return false; if(str[i] == '(') stk.push('('); if(str[i] == ')' &amp;&amp; stk.top() == '(') stk.pop(); } return stk.empty(); }}; 题解二：高效率（别人的）括号匹配问题的充要条件：（只有一种括号） 任意前缀中(数量大于等于)数量 左右括号数量相等 这个结论想想就知道是成立的！反证法肯定无法匹配！ 第二个条件本题默认满足（都是 n ），所以只要满足第一个条件即可！ 所以本题即变成了这样： 左括号直接使用 右括号要满足第一个条件r &lt; l，可不是r &lt;= l，即当前右括号还没有使用。 假如本题问的是匹配的数量：可以直接使用公式计算即可： n 组括号 可以构成 C 2nn / (n + 1) 个有效匹配序列！和卡特兰数有关！ AC代码二：12345678910111213141516class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; generateParenthesis(int n) { dfs(0, 0, n, \"\"); return res; } void dfs(int l, int r, int n, string path){ if(l == n &amp;&amp; r == n){ res.push_back(path); }else{ if(l &lt; n) dfs(l + 1, r, n, path + '('); if(r &lt; n &amp;&amp; r &lt; l) dfs(l, r + 1, n, path + ')'); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-21.合并两个有序链表","slug":"LeetCode刷题-21-合并两个有序链表","date":"2020-06-21T11:55:40.000Z","updated":"2020-06-22T06:15:32.473Z","comments":true,"path":"posts/12870.html","link":"","permalink":"https://www.itnxd.cn/posts/12870.html","excerpt":"","text":"题目链接：21.合并两个有序链表 题解： 经典的二路归并算法，温习一下吧！ 题目简述：给定两个有序链表，合并为一个有序链表！ 题解：二路归并：由于原序列都是有序的，所以每次选取头部的最小值即可将所有节点按从小到大排好。 嗯，不需要做过多解释！ 和数组不一样的一点 ：最后某个链表非空时，可以直接指针指向非空链表的头结点即可，数组还需要进行循环去一个一个链接。 AC代码：1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { auto dummy = new ListNode(-1), l = dummy; while(l1 &amp;&amp; l2){ if(l1-&gt;val &lt; l2-&gt;val) l-&gt;next = l1, l = l1, l1 = l1-&gt;next; else l-&gt;next = l2, l = l2, l2 = l2-&gt;next; } if(l1) l-&gt;next = l1; if(l2) l-&gt;next = l2; return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"},{"name":"二路归并","slug":"二路归并","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-20.有效的括号","slug":"LeetCode刷题-20-有效的括号","date":"2020-06-19T14:43:38.000Z","updated":"2020-06-19T15:07:27.252Z","comments":true,"path":"posts/15525.html","link":"","permalink":"https://www.itnxd.cn/posts/15525.html","excerpt":"","text":"题目链接：20.有效的括号 题解： 嗯，经典的栈的应用，括号匹配！ 题目简述：给定一堆大中小括号，询问是否能完整匹配！ 题解一：就是经典括号匹配，具体细节自己想想就明白了！ 具体思想： 左括号直接入栈 右括号先判断是不是栈空，栈空则无法匹配返回false，不空则和当前栈顶进行匹配，匹配了直接从栈中弹出，否则直接返回false 最后判断栈是否为空，不为空这说明无法完成匹配，直接返回false，其他情况返回true AC代码一：1234567891011121314151617class Solution {public: bool isValid(string s) { stack&lt;char&gt; stk; for(int i = 0; i &lt; s.size(); i++){ if(stk.empty() &amp;&amp; (s[i] == ')' || s[i] == ']' || s[i] == '}')) return false; if(s[i] == '(') stk.push('('); else if(s[i] == ')' &amp;&amp; stk.top() == '(') stk.pop(); else if(s[i] == '[') stk.push('['); else if(s[i] == ']' &amp;&amp; stk.top() == '[') stk.pop(); else if(s[i] == '{') stk.push('{'); else if(s[i] == '}' &amp;&amp; stk.top() == '{') stk.pop(); else return false; } return stk.empty(); }}; 题解二：嗯，题解一是我写的，是不是看起来有点臃肿，是的！ 所以接下来看一下 伟大的 y总这偷工减料的优质写法！ 实现原理： 判断是否匹配做了改进，由于差ASCII码表可以知道，匹配的括号的ASCII码值最多相差2， 所以匹配的写法可以简化为abs(stk.top() - c) &lt;= 2 真。。。会玩，优秀的 y总！ AC代码二：123456789101112131415class Solution {public: bool isValid(string s) { stack&lt;char&gt; stk; // y总的偷工减料做法！ for(auto c : s){ if(c == '(' || c == '[' || c == '{') stk.push(c); else{ if(!stk.empty() &amp;&amp; abs(stk.top() - c) &lt;= 2) stk.pop(); else return false; } } return stk.empty(); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-19.删除链表的倒数第N个节点","slug":"LeetCode刷题-19-删除链表的倒数第N个节点","date":"2020-06-19T14:33:24.000Z","updated":"2020-06-19T15:01:38.018Z","comments":true,"path":"posts/29380.html","link":"","permalink":"https://www.itnxd.cn/posts/29380.html","excerpt":"","text":"题目链接：19.删除链表的倒数第N个节点 题解： 链表的基本操作！ 题目简述：如题，删除链表倒数第n个节点！ 题解：题目说，要使用一遍扫描解决？？？我想了想，这是不可能的，最起码都得两遍。。。 或许人家是说O(N)的时间复杂度。。。 具体做法： 同样使用一个虚拟节点 值为-1做头节点，便于操作 先计算节点总数，包括虚拟的节点 然后计算一下应该循环到哪里进行删除（即要找到要删元素的上一个元素进行删除） 如1-&gt;2-&gt;3-&gt;4-&gt;5删除倒数第二个，加了一个虚拟节点，所以现在应该为-1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5，即下标要遍历到总结点数-倒数的数-1，即k - n - 1即可，这时，p指向要删的倒数第n个节点的上一个节点 这时，直接p-&gt;next = p-&gt;next-&gt;next;，删除完毕！ 返回dummy-&gt;next AC代码：12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { // ListNode* dummy = new ListNode(-1); auto dummy = new ListNode(-1); dummy-&gt;next = head; int k = 0; for(auto p = dummy; p; p = p-&gt;next) k++; auto p = dummy; for(int i = 0; i &lt; k - n - 1; i++) p = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; return dummy-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-18.四数之和","slug":"LeetCode刷题-18-四数之和","date":"2020-06-19T14:25:18.000Z","updated":"2020-06-19T15:07:20.014Z","comments":true,"path":"posts/4066.html","link":"","permalink":"https://www.itnxd.cn/posts/4066.html","excerpt":"","text":"题目链接：18.四数之和 题解： 又是使用双指针的题，双指针可以将复杂度降低一维！ 这道题和LeetCode的第15题完全一样！我的第15题链接 题目简述：给定一个nums数组，需要求出所有相加为target的四元组，并且要求不包含重复四元组！ 题解：当然可以使用暴力，嗯，，四重循环，没试过，可能会超时！ 使用呢双指针将四维降到三维度，固定前两个数，后两个数使用双指针移动！ 题解：参考我写的LeetCode第15题的题解。具体做法，判重，注意事项，完全一样！ 时间复杂度： 第一层循环O(N)，第二层O(N)，第三层看似O(N ^ 2)，实则l和r各最多扫描N次，所以最终复杂度为O(N ^ 3) AC代码：123456789101112131415161718192021class Solution {public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size(); i ++){ if(i &amp;&amp; nums[i] == nums[i - 1]) continue; for(int j = i + 1; j &lt; nums.size(); j ++){ if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; for(int l = j + 1, r = nums.size() - 1; l &lt; r; l ++){ if(l &gt; j + 1 &amp;&amp; nums[l] == nums[l - 1]) continue; while(l &lt; r - 1 &amp;&amp; nums[i] + nums[j] + nums[l] + nums[r] &gt; target) r --; if(nums[i] + nums[j] + nums[l] + nums[r] == target){ res.push_back({nums[i], nums[j], nums[l], nums[r]}); } } } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-17.电话号码的字母组合","slug":"LeetCode刷题-17-电话号码的字母组合","date":"2020-06-19T14:13:39.000Z","updated":"2020-06-19T15:01:38.008Z","comments":true,"path":"posts/24700.html","link":"","permalink":"https://www.itnxd.cn/posts/24700.html","excerpt":"","text":"题目链接：17.电话号码的字母组合 题解： 嗯，，一道经典的递归问题，简单！ 题目简述：有一个电话，九键，和手机键盘一样，都有3-4个字母，要求按了几个数字后，要将所有组合全排列输出！ 题解：定义函数dfs(string digits, int u, string path) digits：输入的按键 u：表示当前处理到第几个按键 path：表示当前处理了的按键构成的组合 递归终止条件：u == digits.size()，即每个数字都已经取了一个字母 递归过程：每个u的位置去循环每一个字母，dfs(digits, u + 1, path + c); 这个最简单的递归过程会将全排列都走一遍的！ 注意： 需要特判输入为空的情况，应该直接返回，否则会返回一个带有\"\"元素的数组。 AC代码：12345678910111213141516171819class Solution {public: string str[10] = { \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" }; vector&lt;string&gt; res; vector&lt;string&gt; letterCombinations(string digits) { if(digits.empty()) return res; dfs(digits, 0, \"\"); return res; } void dfs(string digits, int u, string path){ if(u == digits.size()) res.push_back(path); else{ for(auto c : str[digits[u] - '0']) dfs(digits, u + 1, path + c); } }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-16.最接近的三数之和","slug":"LeetCode刷题-16-最接近的三数之和","date":"2020-06-19T13:54:22.000Z","updated":"2020-06-19T15:06:25.064Z","comments":true,"path":"posts/14896.html","link":"","permalink":"https://www.itnxd.cn/posts/14896.html","excerpt":"","text":"题目链接：16.最接近的三数之和 题解： 嗯，也是双指针，和LeetCode的第15题（也就是我的上一篇文章的题解基本类似）。 题目简述：上一题求三数字和为0， 这一题求三数之和最接近！ 题解：和上一题类似，求为0的三元组每次只有一种情况，即nums[i] + nums[j] + nums[k] 但是求最接近则有两种（左和右）：nums[i] + nums[j] + nums[k] - target，nums[i] + nums[j] + nums[k + 1] - target 思路是一样的，同样是双指针！思路见上一篇题解，即第15题 三数之和！ 本题此题不需要去重，最终结果也只有一个！ 同样需要排序！ 不同之处： nums[i] + nums[j] + nums[k] &gt; target时，就k--，找到最接近的位置 若k + 1没有超界，则计算一下nums[i] + nums[j] + nums[k + 1]的情况（右边） 还有左边的情况（一定不会超界） 使用minv更新与目标值相差最小的差值，即最接近值，若minv发生了更新，则更新res的值为差值较小的一方。 初始值minv，t1，t2都初始化为极大值INT_MAX。 注意： 差值计算需要使用绝对值abs()，同样while内的条件j &lt; k - 1也得保证k--不会越界。 AC代码：12345678910111213141516171819202122class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int res = 0, minv = INT_MAX; for(int i = 0; i &lt; nums.size(); i++){ for(int j = i + 1, k = nums.size() - 1; j &lt; k; j++){ while(j &lt; k - 1 &amp;&amp; nums[i] + nums[j] + nums[k] &gt; target) k--; int t1 = INT_MAX, t2 = INT_MAX; t1 = abs(nums[i] + nums[j] + nums[k] - target); if(k + 1 &lt; nums.size()) t2 = abs(nums[i] + nums[j] + nums[k + 1] - target); if(minv &gt; min(t1, t2)){ minv = t1 &lt; t2 ? t1 : t2; res = t1 &lt; t2 ? nums[i] + nums[j] + nums[k] : nums[i] + nums[j] + nums[k + 1]; } } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-15.三数之和","slug":"LeetCode刷题-15-三数之和","date":"2020-06-19T12:53:48.000Z","updated":"2020-06-19T15:01:37.997Z","comments":true,"path":"posts/55831.html","link":"","permalink":"https://www.itnxd.cn/posts/55831.html","excerpt":"","text":"题目链接：15.三数之和 题解： 又是使用双指针的题，双指针可以将复杂度降低一维！ 这道题和LeetCode后面的16、18题类似。 题目简述：给定一个nums数组，需要求出所有相加为零的三元组，并且要求不包含重复三元组！ 题解：当然可以使用暴力，嗯，，三重循环，没试过，可能会超时！ 咱们有好的算法，就不去暴力求解！ 使用双指针，固定第一个数，后两个数使用双指针，可以将O(N ^ 3)的复杂度降到O(N ^ 2)，即使用双指针可以将维度降低一维！ 使用双指针的前提是序列得有序： 具体做法： 固定第一个数 第二个数 j 从 i + 1开始，k从 nums.size() - 1开始向内走 nums[i] + nums[j] + nums[k] &gt; 0三数之和大于0，k就一直--，直到找到&lt;= 0的位置，或者j与k相邻（即j = k - 1） 此时判断三数之和是不是0，是则push进去！ 此时以i和j为第一二个数的情况就找完了，继续第二个数的循环。 Tips： 由于数组有序，所以我们固定第一个数，嗯，第二个数也相当于固定，去滑动第三个数，直到最接近0的位置，然后去判断是否等于0，这样一定是对的！ 关于判重： 如果第一个数和下一个数重复，那么下一个数的情况和上一个数是完全一样的，不需要进行处理，continue即可！ eg：1111111-2， 第一个1的情况和第二个1以及后面的1的情况是完全相同的，可以直接跳过！ 也就是每次循环都要判断是否和上一个数相同，相同则跳过 注意： 要保证上一个元素下标不越界得保证i &gt; 0, j &gt; i + 1 注意： while 内的j &lt; k - 1的条件，要写对，防止下标越界，此处（j 和 k 的关系）最终退出条件为j == k - 1，即后两个数相邻！ 时间复杂度： 第一层循环O(N)，第二层看似O(N ^ 2)，实则j和k各最多扫描N次，所以最终复杂度为O(N ^ 2) AC代码：123456789101112131415161718class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size(); i++){ if(i &amp;&amp; nums[i] == nums[i - 1]) continue; for(int j = i + 1, k = nums.size() - 1; j &lt; k; j++){ if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; while(j &lt; k - 1 &amp;&amp; nums[i] + nums[j] + nums[k] &gt; 0) k--; if(nums[i] + nums[j] + nums[k] == 0){ res.push_back({nums[i], nums[j], nums[k]}); } } } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-14.最长公共前缀","slug":"LeetCode刷题-14-最长公共前缀","date":"2020-06-19T12:45:43.000Z","updated":"2020-06-19T15:01:37.987Z","comments":true,"path":"posts/4096.html","link":"","permalink":"https://www.itnxd.cn/posts/4096.html","excerpt":"","text":"题目链接：14.最长公共前缀 题解： 嗯，直接做就行，注意一点细节即可！ 题目简述：给定一个字符串数组。求最长公共前缀！ 题解：首先：以第一个字符串为基准，和其他字符串一一对应比较，都相同则继续后移，累加res；不同则直接返回之前已累积的公共前缀！ 一个注意点： 若其他字符串的长度小于当前第一个字符串的位置，则直接返回即可。 AC代码：1234567891011121314151617class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { string res = \"\"; if(strs.empty()) return res; for(int i = 0; i &lt; strs[0].size(); i++){ char c = strs[0][i]; for(int j = 0; j &lt; strs.size(); j++){ if(i &gt;= strs[j].size() || strs[j][i] != c){ return res; } } res += c; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-13.罗马数字转整数","slug":"LeetCode刷题-13-罗马数字转整数","date":"2020-06-19T12:13:17.000Z","updated":"2020-06-19T15:05:10.106Z","comments":true,"path":"posts/11911.html","link":"","permalink":"https://www.itnxd.cn/posts/11911.html","excerpt":"","text":"题目链接：13.罗马数字转整数 题解： 和 12.整数转罗马数字类似，就是反过来问的！处理稍有不同！ 题目简述：给出罗马数字，转化为普通数字！ 例如： “MCMXCIV” ————&gt; 1994 题解：同样适用哈希表存储，不过与上一道题反着的，存储类型反着换了一下！ 首先从左到右搜索每一位罗马字符，能找到对应的字符就给value进行累加。 应该先按两个进行搜索，因为会出现这种情况\"MCMXCIV\" ，先按照一个字符搜，遇到CM应该处理为900，但是按照一个字母先走，会变成C + M，就变成了 1100。这是不对的。 先按照两个搜索，然后 i += 2，然后按照一个进行搜索i += 1. AC代码：12345678910111213141516171819202122232425class Solution {public: int romanToInt(string s) { unordered_map&lt;string, int&gt; hash; int value = 0; hash[\"I\"] = 1; hash[\"IV\"] = 4; hash[\"V\"] = 5; hash[\"IX\"] = 9; hash[\"X\"] = 10; hash[\"XL\"] = 40; hash[\"L\"] = 50; hash[\"XC\"] = 90; hash[\"C\"] = 100; hash[\"CD\"] = 400; hash[\"D\"] = 500; hash[\"CM\"] = 900; hash[\"M\"] = 1000; for(int i = 0; i &lt; s.size();){ if(hash.count(s.substr(i, 2))) value += hash[s.substr(i, 2)], i += 2; else if(hash.count(s.substr(i, 1))) value += hash[s.substr(i, 1)], i += 1; } return value; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-12.整数转罗马数字","slug":"LeetCode刷题-12-整数转罗马数字","date":"2020-06-19T03:24:14.000Z","updated":"2020-06-19T15:01:37.980Z","comments":true,"path":"posts/61074.html","link":"","permalink":"https://www.itnxd.cn/posts/61074.html","excerpt":"","text":"题目链接：12.整数转罗马数字 题解： 嗯，，这题挺简单，字符串处理，我使用了具有对应关系的哈希表！ 题目简述：给定了一个正数，转化成罗马数字。 例如：1994———&gt; “MCMXCIV” 题解：罗马数字就是下面十三种字母的组合，首先使用一种数据结构将对应的数字与罗马数字对应起来！ 这里我使用了unordered_map哈希表存储！ 和每次将一个数取余取除类似，可以搞到每一位！ 所以：思路就是将普通数字，一直对高位取除，即从1000、900、500…..1，取除： 如果等于0，则说明剩余部分比该数字要小，直接跳过； 不等于0，则进行处理，将str 累加一下对应的字符t次，即可 每次进行取余计算剩下的即可！ AC代码：1234567891011121314151617181920212223242526272829303132class Solution {public: string intToRoman(int num) { unordered_map&lt;int, string&gt; hash; int a[13] = {1,4,5,9,10,40,50,90,100,400,500,900,1000}; int k = 12; string str = \"\"; hash[1] = \"I\"; hash[4] = \"IV\"; hash[5] = \"V\"; hash[9] = \"IX\"; hash[10] = \"X\"; hash[40] = \"XL\"; hash[50] = \"L\"; hash[90] = \"XC\"; hash[100] = \"C\"; hash[400] = \"CD\"; hash[500] = \"D\"; hash[900] = \"CM\"; hash[1000] = \"M\"; while(num){ // 3 / 1 int t = num / a[k]; num %= a[k]; if(t != 0){ for(int i = 0; i &lt; t; i++) str += hash[a[k]]; } k--; } return str; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-11.盛最多水的容器","slug":"LeetCode刷题-11-盛最多水的容器","date":"2020-06-18T14:29:47.000Z","updated":"2020-06-19T02:39:56.664Z","comments":true,"path":"posts/22556.html","link":"","permalink":"https://www.itnxd.cn/posts/22556.html","excerpt":"","text":"题目链接：11.盛最多水的容器 题解： 双指针使用，巧妙的思路！ 也是不太好理解！多看看！ 题目简述：给了一堆柱子及其高度，要求选出两个柱子，使得凹槽内的面积达到最大，当然两根柱子要选较低的一根作为高，否则会发生漏水！ 题解一：本题可以使用暴力，直接两层循环，但是会超时！ 所以可以使用双指针算法： 先给出具体思路：两个指针（i 和 j）一个从左走，一个从右走，若左边的比右边的高，则高的一边往内靠，即左面的往后走，右面的往前走，i++，j--，直到i == j结束。 给出证明一： 假设最优解对应的下标为i', j'（i' &lt; j'），在两指针（i, j）移动的过程中不断靠近最优解，先假设i 先走到 i'，且此时j' &lt; j。 反证：假设此时 a[i] &lt;= a[j]，用s表示i,j盛水的面积，s'表示i',j'盛水的面积，则： s = min(a[i], a[j]) * (j - i) = a[i] * (j - i) s' = min(a[i'], a[j']) * (j' - i') = min(a[i], a[j']) * (j' - i) &lt;= a[i] * (j' - i) &lt; a[i] * (j - i) = s 即如果a[i] &lt;= a[j]，则最优解 s'是小于 s的，发生矛盾！假设不成立。 结论：要想使i', j'为最优解，必须使a[i] &gt; a[j]，这样可以使得j指针可以向前移动，逐渐靠近j' 可以结合我画的图来看：s‘面积最大为s2' 给出证明二： 题解来源：LeetCode 两个指分别指向两端，假设左边的较低！ 如果固定左边的柱子，移动右边的柱子，那么水的高度一定不会增加，且宽度一定减少，所以水的面积一定减少。这个时候，左边的柱子和任意一个其他柱子的组合，其实都可以排除了（因为一定宽度变小，高度一定 &lt;= 当前最小高度，面积一定减小）。也就是我们可以排除掉左边的柱子了。（即左边的柱子存在的毫无意义，固定左边右边移动一定不会使面积变大） 总结：较低的一方固定了，较高的一方进行移动，毫无意义，不会使得面积增大！所以要想得到最大值，一定是较长的一方固定，较短的一方移动。 时间复杂度：没根柱子只扫描一遍，为 O(N) AC代码一：123456789101112class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int res = 0; for(int i = 0, j = height.size() - 1; i &lt; j;){ res = max(res, min(height[i], height[j]) * (j - i)); if(height[i] &lt; height[j]) i++; else j--; } return res; }}; 题解二：这种好像更好理解！同样是双指针！ 想让i, j指向两边，此时的构成的矩形宽度是最大的，但是面积不一定是最大的，所以两个指针要想内游走。 对于此时i, j指向的直线，宽度是最大的，向内收敛的过程中，宽度是在减小的。如果遇到高度更低的柱子，那么现在构成的矩形面积一定会比原来的要小，毕竟宽度变小，高度变小；所以只有遇到高度更高的柱子，才有可能比当前的面积要大。 所以，遇到更短的直接向后走，遇到高的则做一下比较，留下最大值即可！ 注意长短的比较是和上一次最短的比较！ 时间复杂度：同样为 O(N) 其实代码意思一样的，换了个写法！ AC代码二：123456789101112131415class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int i = 0, j = height.size() - 1; int res = 0; while (i &lt; j) { int h = min(height[i], height[j]); res = max(res, h * (j - i)); while (i &lt; j &amp;&amp; height[i] &lt;= h) i ++; while (i &lt; j &amp;&amp; height[j] &lt;= h) j --; } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-10.正则表达式匹配","slug":"LeetCode刷题-10-正则表达式匹配","date":"2020-06-15T06:57:45.000Z","updated":"2021-02-06T14:25:46.137Z","comments":true,"path":"posts/6262.html","link":"","permalink":"https://www.itnxd.cn/posts/6262.html","excerpt":"","text":"题目链接：10.正则表达式匹配 题解： 又是一道很难的动态规划题，或许他不难，只是我遇到动态规划的题太少了罢了！ 历时很久才将其看懂：还是 y 总牛逼！ 题目简述：正则匹配：处理两个字符* 和 . *：表示0个或多个 .：任意一个字符 给一个字符串，给一个正则，检查能否匹配。 题解：使用闫式Dp分析法：（集合的方式） 再字符串前面加一个空格，使子符串从1开始！ 分为状态表示和状态计算： 转态表示：两个字符串，则使用两维数组f[i][j] ，来表示原串和正则串的 [1, i] 个 和 [1, j]个是否匹配，存储的是bool值（表示是否存在一个合法方案，由于*的原因导致方案不唯一）。 状态计算：（分为两种情况） p[j] != '*'：则f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == .) p[j] == '*'：则f[i][j] = f[i][j-2] || f[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.') 详细解释一下： 1、p[j] != '*'：s串的前 i 个和 p串的前 j个字符f[i][j] 的情况有两个因素确定： f[i - 1][j - 1]：即去除s串的最后一个待匹配字符与p串的最后一个待匹配字符后，要保证前 i - 1和 前 j - 1 个字符匹配 (s[i] == p[j] || p[j] == ‘.’)：并且s 串和p串的最后一个字符匹配，或者s串任意字符，p串为 .（匹配任意字符） 2、p[j] == '*'：s串的前 i 个和 p串的前 j个字符f[i][j] 的情况有两个因素确定（（1）即 *表示的个数：0，1，2，3…. （2）s与p串尾部的匹配工作）： 0个：f[i][j - 2] 1个：f[i - 1][j - 2] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.') 2个：f[i - 2][j - 2] &amp;&amp; (s[i] == p[j - 1] &amp;&amp; s[i - 1] == p[j - 1] || p[j - 1] == '.') …… 最后是否匹配即上面有一个成立即可 合并起来看一下： f[i][j] = f[i][j - 2] || f[i - 1][j - 2]&amp;&amp;(s[i] == p[j - 1] || p[j - 1] == '.') || f[i - 2][j - 2] &amp;&amp; (s[i] == p[j - 1] &amp;&amp; s[i - 1] == p[j - 1] || p[j - 1] == '.') ......... 无穷无尽 …… 所以咱们来看一下： f[i - 1][j]，同理*号可以取0，1，3，4，5………. 最后合并起来就是：f[i - 1][j] = f[i - 1][j - 2] || f[i - 2][j - 2] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.') || f[i - 3][j - 2] &amp;&amp; (s[i - 1] == p[j - 1] &amp;&amp; s[i - 2] == p[j - 1] || p[j - 1] == '.') .............. 观察两个式子，会发现存在一个关系： f[i][j]包含了f[i - 1][j]：f[i][j] = f[i][j - 2] || f[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.') 这就是状态转移方程！ 注意：相当于乘法分配律：（A || B）&amp;&amp; C == A &amp;&amp; C || B &amp;&amp; C，所以可以提出来公共项：(s[i] == p[j - 1] || p[j - 1] == '.') 将上诉关系放到代码框内方便查看： 12345678910111213- 0个：`f[i][j - 2]`- 1个：`f[i - 1][j - 2] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.')`- 2个：`f[i - 2][j - 2] &amp;&amp; (s[i] == p[j - 1] &amp;&amp; s[i - 1] == p[j - 1] || p[j - 1] == '.')`- ......// f[i][j]f[i][j] = f[i][j - 2] || f[i - 1][j - 2]&amp;&amp;(s[i] == p[j - 1] || p[j - 1] == '.') || f[i - 2][j - 2] &amp;&amp; (s[i] == p[j - 1] &amp;&amp; s[i - 1] == p[j - 1] || p[j - 1] == '.') .......// f[i - 1][j]f[i - 1][j] = f[i - 1][j - 2] || f[i - 2][j - 2] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.') || f[i - 3][j - 2] &amp;&amp; (s[i - 1] == p[j - 1] &amp;&amp; s[i - 2] == p[j - 1] || p[j - 1] == '.') .......// 最终状态转移方程：f[i][j] = f[i][j - 2] || f[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.') AC代码：这里说一下细节处理： f[0][0] = true：初始值，两个串的前0个都是空格，匹配。 j = 1开始：j从0开始无意义，从0开始的话，一个非空的串是不可能匹配一个空串 如：f[1][0]。也可以从0开始，但是得防止下标越界问题，不如直接从1开始。 i 从 0 开始：i 可以从 0 开始，s为空格，p为 .* ，即f[0][1] i == 0：需要特殊判断，i &amp;&amp; p[j] != '*'，这个条件得保证i != 0，以防下标越界 j不需要考虑越界问题：j的取值可能在else if下越界，但是，如果走到else if，j 的下标一定大于等于3，即p串至少也是a*，前面再加上初始空格，一定大于等于3，不会发生越界！ s 与 p 串都加一个空格：这样f[0][0]是可以确定的！不加空格，无法有一个初始值。可能会更加复杂！ 最后答案就是： f[n][m]即 s 整个串和 p 整个串匹配！ 注意：vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1));，初始化了一个 (n + 1 )* (m + 1)二维数组，默认为false。 详细代码如下： 12345678910111213141516171819class Solution {public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); s = ' ' + s, p = ' ' + p; vector&lt;vector&lt;bool&gt;&gt; f(n + 1, vector&lt;bool&gt;(m + 1)); f[0][0] = true; for (int i = 0; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) { if (j + 1 &lt;= m &amp;&amp; p[j + 1] == '*') continue; if (i &amp;&amp; p[j] != '*') { f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i] == p[j] || p[j] == '.'); } else if (p[j] == '*') { f[i][j] = f[i][j - 2] || i &amp;&amp; f[i - 1][j] &amp;&amp; (s[i] == p[j - 1] || p[j - 1] == '.'); } } return f[n][m]; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"Dp","slug":"Dp","permalink":"https://www.itnxd.cn/tags/Dp/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-9.回文数","slug":"LeetCode刷题-9-回文数","date":"2020-06-14T10:37:52.000Z","updated":"2021-02-06T14:25:14.168Z","comments":true,"path":"posts/22431.html","link":"","permalink":"https://www.itnxd.cn/posts/22431.html","excerpt":"","text":"题目链接：9. 回文数 题解： 虽然简单，但是还是有可以优化的地方！ 题目简述：给一个 int 类型的数，判断是不是回文数！ 注意：-121 反转后 为 121- 不是回文数。 题解一：循环嗯，太简单了，不写解释了！ 注意一点：int 正序可能没溢出，但是反转过来就不一定没有溢出，所以，要用 long long 来存储一下！ AC代码：123456789101112class Solution {public: bool isPalindrome(int x) { if(x &lt; 0) return false; long long t = 0, r = x; while(r){ t = t * 10 + r % 10; r /= 10; } return t == x; }}; 题解二：循环优化由于是回文串，那么如果是的话，他的前半部分和后半部分是完全一样的，所以我们可以只处理一半即可得到答案。 如果为负数和末尾有0一定不是回文数。（除了 0） 如果后半部分等于前半部分即是回文数，否则不是： 奇数：s == x / 10 偶数：s == x 退出条件 s &lt;= x，大于就超过了中点位置！ AC代码：12345678910111213class Solution {public: bool isPalindrome(int x) { if(x &lt; 0 || (x &amp;&amp; x % 10 == 0)) return false; int t = 0; while(t &lt;= x){ t = t * 10 + x % 10; if(t == x || t == x / 10) return true; x /= 10; } return false; }}; 题解三：使用 string to_string：是 C++11支持的。 s.rbegin() 和 s.rend()：返回一个逆向迭代器，分别指向字符串的最后一个字符和起始位置（第一个字符前面一个字符位置） 也可以使用reverse()进行反转，不过他没有返回值，而是直接将原串都修改了，不推荐使用。 AC代码：12345678910111213class Solution {public: bool isPalindrome(int x) { if(x &lt; 0) return false; string s = to_string(x); return s == string(s.rbegin(), s.rend()); // 或者： // string t = s; // reverse(t.begin(), t.end()); // return s == t; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"回文数","slug":"回文数","permalink":"https://www.itnxd.cn/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-8.字符串转换整数(atoi)","slug":"LeetCode刷题-8-字符串转换整数","date":"2020-06-14T05:39:07.000Z","updated":"2021-02-06T14:25:27.585Z","comments":true,"path":"posts/64625.html","link":"","permalink":"https://www.itnxd.cn/posts/64625.html","excerpt":"","text":"题目链接：8.字符串转换整数(atoi) 题解： 细节特别多，水题！ 题目简述：将字符串开头是数字的抠出来！ 题解：大致有一下这五种情况： &lt;空格&gt;123：返回123 +123：返回123 -123：返回-123 +-123或-+123：返回 0 w123： 返回 0 注意：如果转换后的数字大于INT_MAX 或小于INT_MIN，返回INT_MAX 或INT_MIN。 注意：long long也不一定能存下，所以只要超过INT_MAX 或INT_MIN就返回INT_MAX 或INT_MIN。 具体解释：查看代码中注释。 AC代码：12345678910111213141516171819202122232425class Solution {public: int myAtoi(string str) { int i = 0, t = 1; long long res = 0; // 处理开头空格 while(str[i] == ' ') i++; // 处理++ -- +- -+ if((str[i] == '+' || str[i] == '-') &amp;&amp; (str[i + 1] == '+' || str[i + 1] == '-')) return 0; // 处理负数 if(str[i] == '-') t = -1, i++; // 处理正数 if(str[i] == '+') i++; for(; i &lt; str.size(); i++){ if(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9'){ res = res * 10 + str[i] - '0'; // 超过int范围 if(res * t &lt; INT_MIN) return INT_MIN; if(res * t &gt; INT_MAX) return INT_MAX; }else break; } res *= t; return res; }}; 只使用 int处理： res = res * 10 + str[i] - '0';可能会溢出，处理这里即可。 res * 10 + x &gt; INT_MAX ---&gt; res &gt; (INT_MAX - x) / 10 -res * 10 - x &lt; INT_MIN ---&gt; -res &lt; (INT_MAX + x) / 10 -2147483648：这个循环内算的是 2147483648，但是res为正数的int，最大为2147483647，会发生越界。判断条件：-res * 10 - x == INT_MIN 12345678910111213141516171819202122232425class Solution {public: int myAtoi(string str) { int i = 0, t = 1; int res = 0; while(str[i] == ' ') i++; if((str[i] == '+' || str[i] == '-') &amp;&amp; (str[i + 1] == '+' || str[i + 1] == '-')) return 0; if(str[i] == '-') t = -1, i++; if(str[i] == '+') i++; for(; i &lt; str.size(); i++){ if(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9'){ int x = str[i] - '0'; // res * 10 + x &gt; INT_MAX ---&gt; res &gt; (INT_MAX - x) / 10 if(t == 1 &amp;&amp; res &gt; (INT_MAX - x) / 10) return INT_MAX; // -res * 10 - x &lt; INT_MIN ---&gt; -res &lt; (INT_MAX + x) / 10 if(t == -1 &amp;&amp; -res &lt; (INT_MIN + x) / 10) return INT_MIN; // -2147483648 if(-res * 10 - x == INT_MIN) return INT_MIN; res = res * 10 + x; }else break; } res *= t; return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-7.整数反转","slug":"LeetCode刷题-7-整数反转","date":"2020-06-14T04:24:06.000Z","updated":"2021-02-06T14:24:57.297Z","comments":true,"path":"posts/58547.html","link":"","permalink":"https://www.itnxd.cn/posts/58547.html","excerpt":"","text":"题目链接：7.整数反转 题解： 水题一个！ 题目简述：正负数都倒序输出即可，负数处理完还是负数。 题解：正负数的原因，应该分开处理，但是C++取余不区分正负，和数学不一样，会区分正负。 题目有 2 ^ 31的限制，即 int的最大最小值，使用INT_MAX 和 INTMIN即可，头文件位于climits中。res定义为long long防止溢出。 注意：不要使用 2 &lt;&lt; 31，会溢出的，结果为 0。 AC代码：123456789101112class Solution {public: int reverse(int x) { long long res = 0; while(x){ res = res * 10 + x % 10; x /= 10; } if(res &gt; INT_MAX || res &lt; INT_MIN) return 0; return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"反转","slug":"反转","permalink":"https://www.itnxd.cn/tags/%E5%8F%8D%E8%BD%AC/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-6.Z字形变换","slug":"LeetCode刷题-6-Z字形变换","date":"2020-06-14T02:44:43.000Z","updated":"2021-02-06T14:22:13.493Z","comments":true,"path":"posts/60082.html","link":"","permalink":"https://www.itnxd.cn/posts/60082.html","excerpt":"","text":"题目链接：6.Z字形变换 题解： 完全就是找规律，找到每行下标的规律即可，为一个等差数列！ 题目简述：将字符串按倒Z型排列，然后按行读取完整字符，输出对应字符串！ 题解：以一个容易发现规律的例子来解释： 以四行为例： 12340 6 121 5 7 11 13 ..2 4 8 10 14 163 9 15 第一行和最后一行公差相同，为 2 * n - 2，即从0 - 6 中间隔了1-3 和 4 - 6 即两个 n - 1. 中间其他行，看做两个等差序列的混合，分别去处理，竖线上的同样是以2 * n - 2为公差的等差数列，不在竖线上的是以2 * n - 2 - i为首项，以2 * n - 2为公差的等差数列！ 2 * n - 2 - i：会发现 1 + 5 = 6 2 + 4 = 6，即 i + x = 2 * n - 2，x = 2 * n - 2 - i 注意： n = 1时，2 * n - 2为零，循环为死循环，所以进行特判，返回原串 s。 AC代码：1234567891011121314151617181920class Solution {public: string convert(string s, int n) { string str; if(n == 1) return s; for(int i = 0; i &lt; n; i++){ if(i == 0 || i == n - 1){ for(int j = i; j &lt; s.size(); j += 2 * n - 2){ str += s[j]; } }else{ for(int j = i, k = 2 * n - 2 - i; j &lt; s.size() || k &lt; s.size(); j += 2 * n - 2, k += 2 * n - 2){ if(j &lt; s.size()) str += s[j]; if(k &lt; s.size()) str += s[k]; } } } return str; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"找规律","slug":"找规律","permalink":"https://www.itnxd.cn/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-5.最长回文子串","slug":"LeetCode刷题-5-最长回文子串","date":"2020-06-14T01:27:14.000Z","updated":"2021-02-06T14:21:47.434Z","comments":true,"path":"posts/30088.html","link":"","permalink":"https://www.itnxd.cn/posts/30088.html","excerpt":"","text":"题目链接：5.最长回文子串 题解： 本题有一个将时间复杂度降到O(N)的算法：马拉车算法 Manacher‘s Algorithm 此算法专门由于求解最长回文子串问题！但是 y总说不太常用！ 还有一个O(NlogN)的算法：哈希 + 二分 有点困难，能力强了再去玩玩！ 本次：使用枚举暴力做法！时间复杂度 O(n^2) 题目简述：求解最长回文子串！若不止一个最长，随便输出一个！ 题解：使用暴力枚举即可： 使用两个指针 l, r, 从中间往两边扩即可！ 奇数：另 l = i - 1, r = i + 1 偶数：另 l = i, r = i + 1 条件： l &gt;= 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] == s[r]：即可以往两边移 str.size() &lt; r - l -1：即当前回文子串更长，则更新 str 时间复杂度：O(n^2) AC代码：12345678910111213141516class Solution {public: string longestPalindrome(string s) { string str; for(int i = 0; i &lt; s.size(); i++){ int l = i - 1, r = i + 1; while(l &gt;= 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] == s[r]) l--, r++; if(str.size() &lt; r - l -1) str = s.substr(l + 1, r - l - 1); l = i, r = i + 1; while(l &gt;= 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] == s[r]) l--, r++; if(str.size() &lt; r - l -1) str = s.substr(l + 1, r - l - 1); } return str; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"枚举","slug":"枚举","permalink":"https://www.itnxd.cn/tags/%E6%9E%9A%E4%B8%BE/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-4.寻找两个正序数组的中位数","slug":"LeetCode刷题-4-寻找两个正序数组的中位数","date":"2020-06-13T13:45:10.000Z","updated":"2021-02-06T14:22:46.833Z","comments":true,"path":"posts/44209.html","link":"","permalink":"https://www.itnxd.cn/posts/44209.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：4.寻找两个正序数组的中位数 题解： 此题 y总 的链接！ 此题据 y总 说是LeetCode最难题目之一！ 这个题目或许又可以称为 求解第k小数问题 题目简述：两个有序序列，求中位数！ 有一个很 优秀的要求：时间复杂度要控制在 O(log(m + n)) 题解一：先不看题目时间复杂度的要求：使用二路归并进行，时间复杂度O(n + m) 由于时间也不算太慢，还是可以AC的。题解二将使用更优秀的算法解决。 二路归并：思路，每次两两比较，将较小值放到新的容器。若某一个遍历完毕，则将没有遍历完的另一个一次放到新的容器。 本题奇偶两种情况处理，奇数位的中位数为 len &gt; 1， 偶数位的中位数为 len &gt; 1 和 (len &gt; 1) - 1 和的均值！ 注意点：返回值为double，所以记得乘以 1. 0 或除以 2.0 AC代码1：12345678910111213141516class Solution {public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int len = nums1.size() + nums2.size(); vector&lt;int&gt; nums3; int i = 0, j = 0; while(i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()){ if(nums1[i] &lt; nums2[j]) nums3.push_back(nums1[i++]); else nums3.push_back(nums2[j++]); } while(i &lt; nums1.size()){nums3.push_back(nums1[i++]);} while(j &lt; nums2.size()){nums3.push_back(nums2[j++]);} if(len &amp; 1) return nums3[len &gt;&gt; 1]; else return (nums3[len &gt;&gt; 1] + nums3[(len &gt;&gt; 1) - 1]) * 1.0 / 2; }}; 题解二：由于题目要求时间复杂度为 O(log(n + m))，所有第一种解法不符合题意，虽然可以AC。 现在将给出第二种解法：使用递归分治 如何想到使用分治的呢？ 时间复杂度为log级别的，想到 log 就会想到 除2，除2，除2 。。。。 所以本题采用类似思想，即每递归一次就将数据量减半，达到log级别！ 具体实现： 递归函数的目的：在可选区间找到第 k 小的数 ，k &gt; 0。 递归分治的思想：即将问题子问题化，由大变小，逐个解决。 本题求解：即求k = (n + m) / 2的位置即可，使用递归求解 k / 2, k / 2 / 2.。。。。。直到k = 1，回溯到 k = (n + m) / 2的解，即为答案！ 时间复杂度：O(log(k)) 即 O(log((n + m) / 2) 即 O(log(n + m)) 好！ 开始分解子问题：(k / 2) 先进行判断：保证函数参数 nums1为较短的数组，nums2为较长的数组。 1、假设 m, n &gt;= k/ 2，即 k / 2 的位置不会越界。这样会有三种情况： 虽然从两个数组各选了k / 2 个值，但是第k小不一定在这k个数内。 但是却可以确定，第k小的数一定不在较小的数组那 k /2 的范围，这时可以舍弃 k / 2 的数据量，转而求舍弃后的两个数组（即被截取前 k / 2个数的数组和完整的另一个数组） 若两个值相等就简单了：两个 k / 2 的序列合起来就是两个数组的前 k 小的序列，即第k 小为任意一个 nums1[k / 2 - 1]或 num2[k / 2 - 1] 注意：相等情况的特殊之处：并不能直接返回，因为可能执行到某个阶段，不一定某个序列还有 k / 2个数。所以这个边界情况会导致当前数就不是第 k 小数了！ 所以：最终只分两种情况即可： &lt; 和 &gt; 注意：k从1开始，下标从0开始！ nums1[k / 2 - 1] &lt; nums2[k / 2 - 1]： nums1[k / 2 - 1] &gt; nums2[k / 2 - 1]： nums1[k / 2 - 1] = nums2[k / 2 - 1]： 2、若 m &lt; k / 2，则 nums1[k / 2]会发生越界 m 对应较短数组的长度，发生越界则将其规约到他的最大长度：si = min((int)nums1.size(), i + k / 2) 3、具体情形 find()：i， j 为起始位置 递归出口： k == 1：nums1为空，则return nums2[j]，否则return min(nums1[i], nums2[j]) k != 1：nums1为空，则return nums2[j + k -1]（j为nums2的起始下标，k从1开始） si规约：si = min((int)nums1.size(), i + k / 2) &lt; &gt;： nums1[si - 1] &gt; nums2[sj - 1]：则return find(nums1, i, nums2, sj, k - (sj - j)); nums1[si - 1] &lt;= nums2[sj - 1]：（关于等于处理请看上面红字），则return find(nums1, si, nums2, j, k - (si - i)); 注意：si - i 和 sj - j 为砍掉的数目！ 关于 k / 2 和 k - k / 2：由于奇偶问题，k / 2，不一定和 k - k / 2相等！ 注意：vector.size()返回值为size_type，需要使用 int强转一下。 ==时间复杂度：O(log(m + n))== AC代码2：1234567891011121314151617181920212223242526272829303132class Solution {public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int len = nums1.size() + nums2.size(); if(len &amp; 1){ return find(nums1, 0, nums2, 0, (len &gt;&gt; 1) + 1); }else{ int left = find(nums1, 0, nums2, 0, len &gt;&gt; 1); int right = find(nums1, 0, nums2, 0, (len &gt;&gt; 1) + 1); return (left + right) / 2.0; } } int find(vector&lt;int&gt;&amp; nums1, int i, vector&lt;int&gt; nums2, int j, int k){ // 始终保证较小的传给参数nums1 if(nums1.size() - i &gt; nums2.size() - j) return find(nums2, j, nums1, i, k); if(k == 1){ // nums1为空 if(nums1.size() == i) return nums2[j]; return min(nums1[i], nums2[j]); } // nums1为空 if(nums1.size() == i) return nums2[j + k -1]; // si 规约 k / 2 和 k - k / 2 int si = min((int)nums1.size(), i + k / 2), sj = j + k - k / 2; // （规约）后的两种情况 if(nums1[si - 1] &gt; nums2[sj - 1]) return find(nums1, i, nums2, sj, k - (sj - j)); else return find(nums1, si, nums2, j, k - (si - i)); }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"分治","slug":"分治","permalink":"https://www.itnxd.cn/tags/%E5%88%86%E6%B2%BB/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-3.无重复字符的最长子串","slug":"LeetCode刷题-3-无重复字符的最长子串","date":"2020-06-13T03:05:26.000Z","updated":"2021-02-06T14:21:12.490Z","comments":true,"path":"posts/25173.html","link":"","permalink":"https://www.itnxd.cn/posts/25173.html","excerpt":"","text":"题目链接：3.无重复字符的最长子串 题解： 双指针形成的滑动窗口实现！双指针被形象表示为滑动窗口！ 题目简述：两个概念： 子串：连续的 子序列：不一定连续，下标递增 找出一个字符串中最长不重复的子串，返回最大长度！ 题解：使用两个指针i, j，（j &lt; i）, 区间[j, i]表示以 i 为尾的子串的区间。 使用 unordered_map&lt;char, int&gt; hash来表示 字符出现的次数。 双指针扫描时来维护该区间[j, i]，使得该区间为以 i 为底的，保证不重复的最大区间。 初始[j, i]无重复，i往后走，将其加入哈希表 若加入后，hash[s[i]] &gt; 1说明 i位置出现了和前面重复的字符，由于前面是不重复的，所以只有可能是i位置的字符重复，接下来，j开始后移，同时进行hash[s[j++]]--来j将哈希表前面的字符清零，直到找到一个新的 j使的 hash[s[i]] &gt; 1不成立，即当前 j 的位置为与 i重复字符的下一个字符，当前[j, i]为以 i为尾的最长子串。 画一个简图如下： 时间复杂度：每个点最多被i 和 j 各扫描一次，所以为 O(N) AC代码：1234567891011121314151617class Solution {public: int lengthOfLongestSubstring(string s) { int res = 0; // 字符出现的个数 unordered_map&lt;char, int&gt; hash; // [j, i] for(int i = 0, j = 0; i &lt; s.size(); i++){ hash[s[i]]++; while(hash[s[i]] &gt; 1){ hash[s[j++]]--; } res = max(res, i - j + 1); } return res; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://www.itnxd.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-2.两数相加","slug":"LeetCode刷题-2-两数相加","date":"2020-06-12T14:09:58.000Z","updated":"2021-02-06T14:20:59.186Z","comments":true,"path":"posts/1127.html","link":"","permalink":"https://www.itnxd.cn/posts/1127.html","excerpt":"","text":"题目链接：2.两数相加 题解： 链表的简单操作！模拟数字相加。 题目简述：两个倒序链表：例如：234的链表为 4 -&gt; 3 -&gt; 2，给定两个倒序链表，返回两个链表正序相加后的倒序链表！ 题解：由于给出的顺序是倒序，可以直接像普通加法从个位开始加起，进位即可。 初始化时可以设置一个虚节点：ListNode* l3 = new ListNode(-1);，返回时直接返回l3-&gt;next即可。 用 t表示进位，while退出后若仍有进位，则链表末尾补 1 ； AC代码1：1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* l3 = new ListNode(-1); ListNode* res = l3; int t = 0; while(l1 || l2){ // 链表结束，之后全部置为0 int n1 = l1 ? l1-&gt;val : 0; int n2 = l2 ? l2-&gt;val : 0; int sum = n1 + n2 + t; // t 表示进位 t = sum / 10; res-&gt;next = new ListNode(sum % 10); res = res-&gt;next; if(l1) l1 = l1-&gt;next; if(l2) l2 = l2-&gt;next; } // 最高位有进位： if(t) res-&gt;next = new ListNode(1); // 返回除了第一个-1之外的节点 return l3-&gt;next; }}; AC代码2： 写法更加简洁：直接使用 t进行累加即可！ 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* l3 = new ListNode(-1); ListNode* res = l3; int t = 0; while(l1 || l2 || t){ if(l1) t += l1-&gt;val, l1 = l1-&gt;next; if(l2) t += l2-&gt;val, l2 = l2-&gt;next; res-&gt;next = new ListNode(t % 10); res = res-&gt;next; t /= 10; } return l3-&gt;next; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"LeetCode刷题-1.两数之和","slug":"LeetCode刷题-1-两数之和","date":"2020-06-12T12:53:28.000Z","updated":"2021-02-06T14:20:45.226Z","comments":true,"path":"posts/43672.html","link":"","permalink":"https://www.itnxd.cn/posts/43672.html","excerpt":"","text":"题目链接：1.两数之和 题解：1、暴力由于答案的解唯一，可以使用两层循环，找到直接返回！ 假如：最后为{i, j}， i &lt; j，两层循环如下方代码。 时间复杂度：O(N^2) AC代码：1234567891011121314class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { for(int i = 0; i &lt; nums.size(); i++) { for(int j = i + 1; j &lt; nums.size(); j++) { if(nums[i] + nums[j] == target) return {i, j}; } } return {}; }}; 2、使用哈希表本题的目标就是找一个数，target - nums[i] ，找到一个即为答案，对于快速的查找可以使用哈希表！ 这里的 下标 i 规定为 {j, i}，j &lt; i， 只需要每次从i - j 的范围找一个 target - nums[i]即可，找到即为答案，返回{hash[target - nums[i]], i}. 判断target - nums[i]是否在哈希表 不在则将当前数加到哈希表 哈希表： unordered_map： 增删改查复杂度为O(1) 两个函数： count()：统计个数，C++ unordered_map不允许有重复的 key，所以该返回值为1 或 0； find()：找到返回迭代器，找不到返回 hash.end() 时间复杂度：O(N) AC代码：12345678910111213141516171819class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; hash; for(int i = 0; i &lt; nums.size(); i++){ int r = target - nums[i]; // 使用find // if(hash.find(r) != hash.end()){ // return {hash[r], i}; // } // count if(hash.count(r)){ return {hash[r], i}; } hash[nums[i]] = i; } return {}; }}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%BB%84/"},{"name":"哈希表","slug":"哈希表","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"author":"Mr.Niu"},{"title":"数据库教程之修改数据","slug":"数据库教程之修改数据","date":"2020-06-09T10:36:02.000Z","updated":"2021-02-06T13:50:03.846Z","comments":true,"path":"posts/26278.html","link":"","permalink":"https://www.itnxd.cn/posts/26278.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve(检索)、Update、Delete。其中，对于查询，我们已经详细讲述了SELECT语句的详细用法。 而对于增、删、改，对应的SQL语句分别是： INSERT：插入新记录； UPDATE：更新已有记录； DELETE：删除已有记录。 一、INSERT1、插入一条记录 语法：INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...); id字段是一个自增主键，它的值可以由数据库自己推算出来。 如果一个字段有默认值或设置为允许NULL值，那么在INSERT语句中也可以不出现。 要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。 可以不指定插入列，但必须和表的列完全匹配，这样并不安全，高度依赖于表中的定义顺序，表结构变动后，就不一定匹配了！一般不这样使用！ 12345678910111213141516171819202122232425262728293031323334INSERT INTO CustomersVALUES (NULL,'Pep E. LaPew'，'100 Main Street','LoS Ange les','CA','90046'，'USA',NULL,NULL);-- 推荐写法mysql&gt; INSERT INTO students (class_id, name, gender, score) VALUES (2, '大牛', 'M', 80);Query OK, 1 row affected (0.03 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 73 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 55 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 |+----+----------+--------+--------+-------+12 rows in set (0.00 sec) 2、插入多条记录 语法：INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...), VALUES (值1, 值2, ...).....; 多条语句，逗号隔开！ 1234567891011121314151617181920212223242526$ mysql&gt; INSERT INTO students (class_id, name, gender, score) VALUES -&gt; (1, '大宝', 'M', 87), -&gt; (2, '二宝', 'M', 81);Query OK, 2 rows affected (0.01 sec)Records: 2 Duplicates: 0 Warnings: 0$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 73 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 55 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) 3、插入检索出的数据 即使用INSERT INTO ... SELECT ... FROM ... 为简单起见，这个例子在 NSERT 和SELECT 语句中使用了相同的列名。但是，不一定要求列名匹配。事实上，MySQL甚至不关心 SELECT 返回的列名。它使用的是列的位置，因此 SELECT 中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。这对于从使用不同列名的表中导入数据是非常有用的。 这个例子导入了 cust_id （假设你能够确保 cust_id 的值不重复）。 1234567891011121314151617181920INSERT INTO customers(cust_id,cust_contact ,cust_emai 1，cust_name ，cust_address,cust_city ，cust_state,cust_zip,cust_country)SELECT cust_id,cust_contact ，cust_emai 1，cust_name , .cust_address,cust_city ，cust_state,cust_zip,cust_countryFROM custnew; 4、提高整体性能 INSERT 操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的 SELECT 语句的性能。 如果数据检索是最重要的（通常是这样），则你可以通过在INSERT 和 INTO 之间添加关键字 LOW_PRIORITY，指示MySQL降低INSERT 语句的优先级，如下所示： 1INSERT LOW_PRIORITY INTO 5、IGNORE 如果用 INSERT 语句插入多行，并且在插入这些行中的一行或多行时出一个现错误，则整个 INSERT 操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。 使用IGNORE即使是发生错误，也继续进行更新，如下所示：INSERT IGNORE INTO customers.... 二、UPDATE 在 UPDATE 语句中使用子查询 ，UPDATE 语句中可以使用子查询，使得能用 SELECT 语句检索出的数据更新列数据。 1、更新一条记录 语法：UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...; 1234567891011$ mysql&gt; UPDATE students SET name='大牛', score=66 WHERE id=1;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0$ mysql&gt; SELECT * FROM students WHERE id=1;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 大牛 | M | 66 |+----+----------+--------+--------+-------+1 row in set (0.00 sec) 2、更新多条记录 语法：UPDATE students SET name='小牛', score=77 WHERE id&gt;=5 AND id&lt;=7; WHERE条件可与逻辑运算符结合，更新指定条件的记录。 如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。 123456789101112131415161718192021222324$ mysql&gt; UPDATE students SET score=score+10 WHERE score&lt;80;Query OK, 3 rows affected (0.01 sec)Rows matched: 3 Changed: 3 Warnings: 0$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 大牛 | M | 76 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) 3、不使用WHERE条件 此举动要小心，整个表的所有记录都会被更新。 eg：UPDATE students SET score=60; 效果：整个表的学生分数都变为了60. 注意：所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。 4、IGNORE 如果用 UPDATE 语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个 UPDATE 操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。 使用IGNORE即使是发生错误，也继续进行更新，如下所示：UPDATE IGNORE customers... SET... 5、MySQL提示信息 使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。 123$ mysql&gt; UPDATE students SET name='大牛', score=66 WHERE id=1;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0 三、DELETE1、删除记录 语法：DELETE FROM &lt;表名&gt; WHERE ...; 同样：可以配合逻辑运算符实现多条删除！ 如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。 12345678910111213141516171819202122$ mysql&gt; DELETE FROM students WHERE id=1;Query OK, 1 row affected (0.01 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+13 rows in set (0.00 sec) 2、不使用WHERE条件 此举动要小心，整个表的所有记录都会被删除。 eg：DELETE FROM students; 效果：变成了一张空表。 注意：所以，在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。 4、删除指定列 将某列更新为NULL值，如果表定义允许NULL值。 123UPDATE customersSET cust_email = NULLWHERE cust_id = 10005; 5、删除所有行普通方法： 1DELETE FROM students; 更快的方法： 使用TRUNCATE TABLE，它完成相同的工作，但速度更快（ TRUNCATE 实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。 6、MySQL提示信息 使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。 12$ mysql&gt; DELETE FROM students WHERE id=1;Query OK, 1 row affected (0.01 sec) 四、实用SQL语句1、插入或替换 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用REPLACE语句。 1234567891011121314151617181920212223$ mysql&gt; REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);Query OK, 1 row affected (0.01 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | F | 99 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) 2、插入或更新 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用INSERT INTO ... ON DUPLICATE KEY UPDATE ...语句： 1234567891011121314151617181920212223$ mysql&gt; INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, ' 小明', 'F', 99) ON DUPLICATE KEY UPDATE name='小明', gender='F', score=98;Query OK, 2 rows affected (0.00 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | F | 98 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) 3、插入或忽略 如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用INSERT IGNORE INTO ...语句。 1234567891011121314151617181920212223$ mysql&gt; INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);Query OK, 0 rows affected, 1 warning (0.00 sec)$ mysql&gt; SELECT * FROM students;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | F | 98 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 65 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+14 rows in set (0.00 sec) 4、快照 如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT。 可选的复制复制了一份，和该表结构一致。 12345678910111213141516171819202122232425$ mysql&gt; CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1;Query OK, 5 rows affected (0.09 sec)Records: 5 Duplicates: 0 Warnings: 0$ mysql&gt; SHOW TABLES;+--------------------+| Tables_in_test |+--------------------+| classes || students || students_of_class1 |+--------------------+3 rows in set (0.01 sec)$ mysql&gt; SELECT * FROM students_of_class1;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | F | 98 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 13 | 1 | 大宝 | M | 87 |+----+----------+--------+--------+-------+5 rows in set (0.00 sec) 5、写入查询结果集 如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。 先创建满足需求的表 1234567$ mysql&gt; CREATE TABLE result ( -&gt; id BIGINT NOT NULL AUTO_INCREMENT, -&gt; class_id BIGINT NOT NULL, -&gt; average DOUBLE NOT NULL, -&gt; PRIMARY KEY (id) -&gt; );Query OK, 0 rows affected (0.03 sec) 使用INSERT INTO ... SELECT ... FROM... 1234567891011121314$ mysql&gt; INSERT INTO result (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;Query OK, 4 rows affected (0.01 sec)Records: 4 Duplicates: 0 Warnings: 0$ mysql&gt; SELECT * FROM result;+----+----------+--------------+| id | class_id | average |+----+----------+--------------+| 1 | 1 | 90.2 || 2 | 2 | 78.4 || 3 | 3 | 88.333333333 || 4 | 5 | 88 |+----+----------+--------------+4 rows in set (0.00 sec) 6、强制使用指定索引 在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。 指定索引前提是索引（idx_class_id）必须存在！ 1$ SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"修改","slug":"修改","permalink":"https://www.itnxd.cn/tags/%E4%BF%AE%E6%94%B9/"},{"name":"INSERT","slug":"INSERT","permalink":"https://www.itnxd.cn/tags/INSERT/"},{"name":"UPDATE","slug":"UPDATE","permalink":"https://www.itnxd.cn/tags/UPDATE/"},{"name":"DELETE","slug":"DELETE","permalink":"https://www.itnxd.cn/tags/DELETE/"}],"author":"Mr.Niu"},{"title":"JS实战之油猴脚本编写之知乎一键转载","slug":"JS实战之油猴脚本编写之知乎一键转载","date":"2020-06-07T14:23:46.000Z","updated":"2021-02-06T14:18:42.406Z","comments":true,"path":"posts/1495.html","link":"","permalink":"https://www.itnxd.cn/posts/1495.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、准备工作 根据所学JS知识以及又拍云小哥直播的讲解实战开发的一个小脚本！ 所有链接： 又拍云上直播地址：点击这里！ 又拍云油猴脚本开发：点击这里！ 我的油猴知乎实战脚本，点击这里！ 二、实现功能 隐藏回答界面的右边侧栏，提升阅读舒适性！ 加宽回答的可视区域，让您看的更加舒服！ 增加一个一键转载按钮（一键复制），禁止转载的给出提示信息！ 实现效果如下： 三、完整代码 脚本地址，点击这里！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// ==UserScript==// @name 知乎一键转载// @namespace http://tampermonkey.net/// @version 0.5// @description 模仿又拍云 demo 实现并修改的知乎一件转载，可以一键复制到剪贴板！隐藏知乎右边侧栏，加宽回答可视区域，使您阅读的更加舒服！欢迎食用！// @author NXD// @match https://www.zhihu.com/question/*// @grant GM_addStyle// ==/UserScript==// Question-sideColumn 隐藏右边栏GM_addStyle('.Question-sideColumn {display: none !important}');// 回答界面加宽GM_addStyle('.Question-mainColumn {width: 1000px !important}');(function() { 'use strict'; function createElement(eleName, text, attrs){ let ele = document.createElement(eleName); ele.innerText = text; for(let k in attrs){ ele.setAttribute(k, attrs[k]); } return ele; } // 复制到剪贴板函数 function addToClipboard(text){ navigator.clipboard.writeText(text).then(function() { // 一切都没问题的话会执行 alert 操作 alert('succeed copy'); }, function(err) { // 失败时执行的函数 console.info('failed copy', err); alert('faild copy') }); } // added 是一个全局变量, 用来保存已经添加过按钮的节点. let added = []; // 按钮样式 let btnStyle = 'background-color: #0084ff; margin-top: 15px; margin-bottom: 15px; margin-left:-5px; cursor:pointer; color: #fff; border-radius: 3px; border: 1px solid; padding: 3px 6px'; // 第一个回答 Card AnswerCard function addFirstBtn(){ // 获得第一个回答 let first = document.querySelector(\"#root &gt; div &gt; main &gt; div &gt; div.Question-main &gt; div.ListShortcut &gt; div &gt; div.Card.AnswerCard\"); // 获取每个回答的头部信息位置 let meta = first.querySelector('div[class=\"ContentItem-meta\"]'); // https://www.zhihu.com/question/398927155/answer/1266562835 获取到网址拿到最后的answer Id let who = meta.querySelector('meta[itemprop=\"url\"]').getAttribute('content').split('/').pop(); // 添加过的不再添加 if(added.indexOf(who) === -1){ // 没添加的插入数组 added.push(who); // 创建按钮 let btn = createElement('button', '转载按钮', {style: btnStyle}); // 获取文章内容 let text = first.querySelector('div[class=\"RichContent-inner\"]').innerText; // 将文章内容复制到剪贴板 btn.addEventListener('click', ()=&gt;{addToClipboard(text)}); meta.append(btn); } } // 更多回答：Card MoreAnswers function addBtn(){ // 更多回答 let all = document.querySelectorAll('div[class=\"List-item\"]'); for(let item of all){ // 获取每个回答的头部信息位置 let meta = item.querySelector('div[class=\"ContentItem-meta\"]'); // https://www.zhihu.com/question/398927155/answer/1266562835 获取到网址拿到最后的answer Id let who = meta.querySelector('meta[itemprop=\"url\"]').getAttribute('content').split('/').pop(); // 添加过的不再添加 if(added.indexOf(who) !== -1){ continue; } // 没添加的插入数组 added.push(who); // 创建按钮 let btn = createElement('button', '转载按钮', {style: btnStyle}); // 获取文章内容 let text = item.querySelector('div[class=\"RichContent-inner\"]').innerText; // 将文章内容复制到剪贴板 btn.addEventListener('click', ()=&gt;{addToClipboard(text)}); meta.append(btn); } } // 点击查看全部回答调用addBtn // 点击后 window.addEventListener('load', addBtn); // 点击前 // 1. 加载完调用 处理第一个回答 window.addEventListener('load', addFirstBtn); // 2. 随着滚动条调用后续方法 window.addEventListener('scroll', addBtn);})(); 四、代码实现介绍 模仿又拍云小哥demo实现，由于小哥原版的有一些bug，我做了简单修复，具体内容如下： 修复回答界面点击查看全部回答后第一个回答无法加载按钮的bug 修复点进回答界面第一个回答按钮无法加载需要触发滚动事件的bug 修复来修复去，又多了一个bug，点进查看全部回答界面似乎又不进行加载脚本了，我心累了！原脚本也有这个bug。 1、油猴脚本头部123456789// ==UserScript==// @name 知乎一键转载// @namespace http://tampermonkey.net/// @version 0.5// @description 模仿又拍云 demo 实现并修改的知乎一件转载，可以一键复制到剪贴板！隐藏知乎右边侧栏，加宽回答可视区域，使您阅读的更加舒服！欢迎食用！// @author NXD// @match https://www.zhihu.com/question/*// @grant GM_addStyle// ==/UserScript== name：脚本名称 version：版本 description：脚本描述 author：作者 match：匹配生效的网址 grant：导入油猴官方的API namespace：是命名空间，可以用你的网站名称 其他关键词及API请访问油猴文档！ 2、相关函数介绍2.1 GM_addStyle 油猴官方实现的接口用于写更方便的写CSS！ 怎么写CSS就怎么使用该方法。 1GM_addStyle('.Question-mainColumn {width: 1000px !important}'); 2.2 createElement 创建元素函数！ createElement(eleName, text, attrs)：元素名，元素内的文本信息，以及属性接收一个对象（即{}参数） 2.3 addToClipboard 复制到剪贴板函数！ 传入text参数，为复制的文本信息。 2.4 addFirstBtn 由于不点击查看全部回答第一个回答和后续回答不一样，要格外设置一个函数去处理第一个回答！ 第一个回答的 class：Card AnswerCard 点击查看全部回答后的 class：Card MoreAnswers 2.5 addBtn 同样：处理没点击查看全部回答的后续回答（除了第一个不一样的）以及点击查看全部回答的所有回答。 3、加载事件设置 window.addEventListener('load', addFirstBtn)：处理第一个不一样的回答 window.addEventListener('load', addBtn)：主要用于处理点击查看全部回答后的回答，加载完调用。 window.addEventListener('scroll', addBtn)：同时处理点击或每点击后续流式加载出现的回答，随滚动条加载。 防止出现重复添加按钮，使用added数组来判断：added.indexOf(who) !== -1 添加按钮即push到数组 没有添加则应该为 -1 12345678// 点击查看全部回答调用addBtn// 点击后window.addEventListener('load', addBtn);// 点击前// 1. 加载完调用 处理第一个回答window.addEventListener('load', addFirstBtn);// 2. 随着滚动条调用后续方法window.addEventListener('scroll', addBtn); 五、总结 一个脚本的编写需要去网页找到对应的元素class，获取到位置再进行操作 需要修复好多的bug，泪目啊！ 需要有HTML CSS JS知识，最好有强硬的JS能力。 这一次脚本编写也是极大的锻炼了我的JS实战能力，掌握了一些用法。虽然本脚本实现的功能较为简单与简陋，甚至有好多bug，但是我会在后续不断改进，完善的！ 很开心的一次实战！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JS实战","slug":"JS实战","permalink":"https://www.itnxd.cn/categories/JS%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"油猴脚本","slug":"油猴脚本","permalink":"https://www.itnxd.cn/tags/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"},{"name":"知乎","slug":"知乎","permalink":"https://www.itnxd.cn/tags/%E7%9F%A5%E4%B9%8E/"}],"author":"Mr.Niu"},{"title":"数据库教程之查询数据","slug":"数据库教程之查询数据","date":"2020-06-02T09:37:39.000Z","updated":"2021-02-06T13:47:33.087Z","comments":true,"path":"posts/16928.html","link":"","permalink":"https://www.itnxd.cn/posts/16928.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、准备数据 廖雪峰SQL教程例子：例子代码点击这里！ 将上方链接或者下方代码保存到文本文件，改名为init-test-data.sql。然后再本地cmd运行$ mysql -u root -p &lt; init-test-data.sql即可创建一个名为test的数据库，有两张表classes和students! 注意要在cmd，不要使用powershell，powershell无法识别命令行&lt;这个符号！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-- 如果test数据库不存在，就创建test数据库：CREATE DATABASE IF NOT EXISTS test;-- 切换到test数据库USE test;-- 删除classes表和students表（如果存在）：DROP TABLE IF EXISTS classes;DROP TABLE IF EXISTS students;-- 创建classes表：CREATE TABLE classes ( id BIGINT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 创建students表：CREATE TABLE students ( id BIGINT NOT NULL AUTO_INCREMENT, class_id BIGINT NOT NULL, name VARCHAR(100) NOT NULL, gender VARCHAR(1) NOT NULL, score INT NOT NULL, PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 插入classes记录：INSERT INTO classes(id, name) VALUES (1, '一班');INSERT INTO classes(id, name) VALUES (2, '二班');INSERT INTO classes(id, name) VALUES (3, '三班');INSERT INTO classes(id, name) VALUES (4, '四班');-- 插入students记录：INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'M', 90);INSERT INTO students (id, class_id, name, gender, score) VALUES (2, 1, '小红', 'F', 95);INSERT INTO students (id, class_id, name, gender, score) VALUES (3, 1, '小军', 'M', 88);INSERT INTO students (id, class_id, name, gender, score) VALUES (4, 1, '小米', 'F', 73);INSERT INTO students (id, class_id, name, gender, score) VALUES (5, 2, '小白', 'F', 81);INSERT INTO students (id, class_id, name, gender, score) VALUES (6, 2, '小兵', 'M', 55);INSERT INTO students (id, class_id, name, gender, score) VALUES (7, 2, '小林', 'M', 85);INSERT INTO students (id, class_id, name, gender, score) VALUES (8, 3, '小新', 'F', 91);INSERT INTO students (id, class_id, name, gender, score) VALUES (9, 3, '小王', 'M', 89);INSERT INTO students (id, class_id, name, gender, score) VALUES (10, 3, '小丽', 'F', 85);-- OK:SELECT 'ok' as 'result:'; 二、基本查询1、SELECT语句 使用SELECT * FROM students时，SELECT是关键字，表示将要执行一个查询，*表示“所有列”，FROM表示将要从哪个表查询，本例中是students表。 该SQL将查询出students表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。 12$ USE test;$ SELECT * FROM &lt;表名&gt;; 2、DISTINCT只返回不同值 用于返回不同的值！ DISTINCT 关键字应用于所有列而不仅是前置它的列。如果给出 SELECT DISTINCT vend_id,prod_price ，除非指定的两个列都不同，否则所有行都将被检索出来。 1SELECT DISTINCT vend_id FROM products; 3、用于计算的SELECT 上述查询会直接计算出表达式的结果。虽然SELECT可以用作计算，但它并不是SQL的强项。但是，不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1;来测试数据库连接。 1234567$ mysql&gt; SELECT 200 * 3000000000;+------------------+| 200 * 3000000000 |+------------------+| 600000000000 |+------------------+1 row in set (0.00 sec) 三、条件查询1、WHERE 条件 使用SELECT * FROM &lt;表名&gt;可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。 格式如下： 1$ SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt; 效果如下： 2、逻辑运算 与其他语言不同：等于号不是==而是=！ 2.1 AND 就是与运算符！ 12345678910$ mysql&gt; SELECT * FROM students WHERE score &gt;= 80 AND gender = 'M';+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 3 | 1 | 小军 | M | 88 || 7 | 2 | 小林 | M | 85 || 9 | 3 | 小王 | M | 89 |+----+----------+--------+--------+-------+4 rows in set (0.00 sec) 2.2 OR 就是或运算符！ 123456789101112131415$ mysql&gt; SELECT * FROM students WHERE score &gt;= 80 OR gender = 'M';+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 55 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 |+----+----------+--------+--------+-------+9 rows in set (0.00 sec) 2.3 NOT 就是非运算符！ MySQL支持使用 NOT 对 IN 、 BETWEEN 和EXISTS子句取反，这与多数其他 DBMS允许使用 NOT 对各种条件取反有很大的差别。 12345678910111213$ mysql&gt; SELECT * FROM students WHERE NOT class_id = 2;+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 1 | 1 | 小明 | M | 90 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 73 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 |+----+----------+--------+--------+-------+7 rows in set (0.00 sec) 2.4 多条件使用括号 同样：加括号改变了优先级！ 12345678$ mysql&gt; SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = 'M';+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 6 | 2 | 小兵 | M | 55 |+----+----------+--------+--------+-------+1 row in set (0.00 sec) 3、条件表达式符号 注意：不等于可以是!=或者是&lt;&gt;！ 字符串要用单引号引起来！ %可以匹配任意字符，包括空字符且不一定是一个字符！ 条件 表达式举例1 表达式举例2 说明 使用=判断相等 score = 80 name = ‘abc’ 字符串需要用单引号括起来 使用&gt;判断大于 score &gt; 80 name &gt; ‘abc’ 字符串比较根据ASCII码，中文字符比较根据数据库设置 使用&gt;=判断大于或相等 score &gt;= 80 name &gt;= ‘abc’ 使用&lt;判断小于 score &lt; 80 name &lt;= ‘abc’ 使用&lt;=判断小于或相等 score &lt;= 80 name &lt;= ‘abc’ 使用&lt;&gt;判断不相等 score &lt;&gt; 80 name &lt;&gt; ‘abc’ 使用!=判断不相等 score!=80 name!=’abc’ 使用LIKE判断相似 name LIKE ‘ab%’ name LIKE ‘%bc%’ %表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’ BETWEEN a AND b BETWEEN 80 AND 90 在指定两个值之间 IS NULL score IS NULL 指的是空，不是0，空字符串，空格，可能出现在建表时设置的NOT NULL的属性列 4、 其他操作符4.1 IN IN 操作符用来指定条件范围，范围中的每个条件都可以进行匹配。 IN 取合法值的由逗号分隔的清单，全都括在圆括号中。 123IN (值1，值2....);SELECT * FROM student WHERE class_id IN (1,2) ORDER BY name; IN 与 OR相比的优点： 在使用长的合法选项清单时，IN 操作符的语法更清楚且更直观。 在使用 IN 时，计算的次序更容易管理（因为使用的操作符更少）。 IN 操作符一般比 OR 操作符清单执行更快。 IN 的最大优点是可以包含其他 SELECT 语句，使得能够更动态地建立 WHERE 子句。（后续会介绍） 4.2 LIKE LIKE 指示MySQL后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。 4.2.1 百分号（%）通配符 % 表示任何字符出现任意（0,1，….）次数！ 此搜索区分大小写，'jet%' 与 JetPack 1000 将不匹配。 可以出现在任意位置，可以出现任意多个。 例如：s%e,%ss% 注意： 尾空格：%abc无法匹配%abc&lt;空格&gt;，要想匹配可以在最后再加一个%abc%，后面会讲到一个更好的方法，使用函数 %无法匹配NULL。 4.2.2 下划线（_）通配符 _只匹配单个（只能是1个）任意字符， 1SELECT prod_id, prod_name FROM products WHERE prod_name LIKE '_ abc'; 4.2.3 使用通配符的优缺点 可以使用通配符完成一些不易完成的搜索 使用通配符会带来效率的降低，会比其他搜索更耗时 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 四、投影查询 使用SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。 如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用SELECT 列1, 列2, 列3 FROM ...，让结果集仅包含指定列。这种操作称为投影查询。 投影查询：仅返回指定列！ 1、普通投影1$ SELECT 列1, 列2, 列3 FROM ...，; 例子如下： 12345678910111213141516$ mysql&gt; SELECT id, score, name FROM students;+----+-------+--------+| id | score | name |+----+-------+--------+| 1 | 90 | 小明 || 2 | 95 | 小红 || 3 | 88 | 小军 || 4 | 73 | 小米 || 5 | 81 | 小白 || 6 | 55 | 小兵 || 7 | 85 | 小林 || 8 | 91 | 小新 || 9 | 89 | 小王 || 10 | 85 | 小丽 |+----+-------+--------+10 rows in set (0.01 sec) 2、别名投影1$ SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...; 例子如下：score 一列改别名为 points ！ 12345678910111213141516$ mysql&gt; SELECT id, score points, name FROM students;+----+--------+--------+| id | points | name |+----+--------+--------+| 1 | 90 | 小明 || 2 | 95 | 小红 || 3 | 88 | 小军 || 4 | 73 | 小米 || 5 | 81 | 小白 || 6 | 55 | 小兵 || 7 | 85 | 小林 || 8 | 91 | 小新 || 9 | 89 | 小王 || 10 | 85 | 小丽 |+----+--------+--------+10 rows in set (0.00 sec) 3、复杂投影 将投影与别名与WHERE条件查询结合！ 1234567891011mysql&gt; SELECT id, score points, name FROM students WHERE gender = 'M';+----+--------+--------+| id | points | name |+----+--------+--------+| 1 | 90 | 小明 || 3 | 88 | 小军 || 6 | 55 | 小兵 || 7 | 85 | 小林 || 9 | 89 | 小王 |+----+--------+--------+5 rows in set (0.00 sec) 五、排序 我们使用SELECT查询时，细心的读者可能注意到，查询结果集通常是按照id排序的，也就是根据主键排序。这也是大部分数据库的做法。 在给出 ORDER BY 子句时，应该保证它位于 FROM 子句之后。如果使用 LIMIT ，它必须位于 ORDER BY之后。使用子句的次序不对将产生错误消息。 1、升序 使用 ORDER BY ***语句；ASC：升序，可省略！ 12345678910111213141516$ mysql&gt; SELECT id, name, gender, score FROM students ORDER BY score;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 6 | 小兵 | M | 55 || 4 | 小米 | F | 73 || 5 | 小白 | F | 81 || 7 | 小林 | M | 85 || 10 | 小丽 | F | 85 || 3 | 小军 | M | 88 || 9 | 小王 | M | 89 || 1 | 小明 | M | 90 || 8 | 小新 | F | 91 || 2 | 小红 | F | 95 |+----+--------+--------+-------+10 rows in set (0.00 sec) 2、降序 使用 ORDER BY *** DESC，DESC表示“倒序”，不可省略！ 12345678910111213141516$ mysql&gt; SELECT id, name, gender, score FROM students ORDER BY score DESC;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 2 | 小红 | F | 95 || 8 | 小新 | F | 91 || 1 | 小明 | M | 90 || 9 | 小王 | M | 89 || 3 | 小军 | M | 88 || 7 | 小林 | M | 85 || 10 | 小丽 | F | 85 || 5 | 小白 | F | 81 || 4 | 小米 | F | 73 || 6 | 小兵 | M | 55 |+----+--------+--------+-------+10 rows in set (0.00 sec) 3、复杂排序3.1 多列排序 若score列有相同的数据，要进一步排序，可以继续添加列名。 即先按score降序，再按gender升序（默认为ASC升序）。 1234567891011121314151617$ mysql&gt; SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 2 | 小红 | F | 95 || 8 | 小新 | F | 91 || 1 | 小明 | M | 90 || 9 | 小王 | M | 89 || 3 | 小军 | M | 88 || 10 | 小丽 | F | 85 || 7 | 小林 | M | 85 || 5 | 小白 | F | 81 || 4 | 小米 | F | 73 || 6 | 小兵 | M | 55 |+----+--------+--------+-------+10 rows in set (0.00 sec) 3.2 条件排序 如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面！ 12345678910111213$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; WHERE class_id = 1 -&gt; ORDER BY score DESC;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 2 | 小红 | F | 95 || 1 | 小明 | M | 90 || 3 | 小军 | M | 88 || 4 | 小米 | F | 73 |+----+--------+--------+-------+4 rows in set (0.00 sec) 六、分页查询 使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。 要实现分页功能，实际上就是从结果集中显示第1 ~ 100条记录作为第1页，显示第101 ~ 200条记录作为第2页，以此类推。 因此，分页实际上就是从结果集中“截取”出第M ~ N条记录。 通过LIMIT &lt;M&gt; OFFSET &lt;N&gt;子句实现：LIMIT表示每页最多三条信息，OFFSET表示从第几条开始。（SQL索引从0开始） 可以使用LIMIT控制要输出的结果！ 注意： OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。 在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15。 使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;分页时，随着N越来越大，查询效率也会越来越低。 规则：分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值： LIMIT总是设定为pageSize； OFFSET计算公式为pageSize * (pageIndex - 1)。 如下：1234567891011121314151617181920212223242526272829303132333435363738$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; ORDER BY score DESC -&gt; LIMIT 3 OFFSET 0;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 2 | 小红 | F | 95 || 8 | 小新 | F | 91 || 1 | 小明 | M | 90 |+----+--------+--------+-------+3 rows in set (0.00 sec)$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; ORDER BY score DESC -&gt; LIMIT 3 OFFSET 3;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 9 | 小王 | M | 89 || 3 | 小军 | M | 88 || 10 | 小丽 | F | 85 |+----+--------+--------+-------+3 rows in set (0.00 sec)...$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; ORDER BY score DESC -&gt; LIMIT 3 OFFSET 9;+----+--------+--------+-------+| id | name | gender | score |+----+--------+--------+-------+| 6 | 小兵 | M | 55 |+----+--------+--------+-------+1 row in set (0.00 sec) 若OFFSET设置的越界了，并不会报错，会返回一个空集合！ 12345$ mysql&gt; SELECT id, name, gender, score -&gt; FROM students -&gt; ORDER BY score DESC -&gt; LIMIT 3 OFFSET 20;Empty set (0.00 sec) 七、聚合（聚集）查询 对于统计总数、平均数这类计算，SQL提供了专门的聚合(聚集)函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。 1、COUNT()函数 COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)。 可以设置一个别名，便于处理结果： COUNT(*)和COUNT(id)实际上是一样的效果。 如果指定列名，则指定列的值为空的行被 COUNT()函数忽略，但如果 COUNT() 函数中用的是星号（ * ），则不忽略。 12345678910111213141516$ mysql&gt; SELECT COUNT(*) FROM students;+----------+| COUNT(*) |+----------+| 10 |+----------+1 row in set (0.00 sec)-- 取一个别名 nummysql&gt; SELECT COUNT(*) num FROM students;+-----+| num |+-----+| 10 |+-----+1 row in set (0.00 sec) 同样可以使用WHERE条件 1234567mysql&gt; SELECT COUNT(*) boys FROM students WHERE gender = 'M';+------+| boys |+------+| 5 |+------+1 row in set (0.00 sec) 2、其他聚集函数 注意，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。 注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL： 函数 说明 SUM 计算某一列的合计值，该列必须为数值类型，SUM() 函数忽略列值为 NULL 的行 AVG 计算某一列的平均值，该列必须为数值类型，AVG() 函数忽略列值为 NULL 的行。 MAX 计算某一列的最大值，MAX() 函数忽略列值为 NULL 的行 MIN 计算某一列的最小值，MIN() 函数忽略列值为 NULL 的行 CEILING 上取整 FLOOR 下取整 12345678910111213141516171819202122232425262728$ mysql&gt; SELECT AVG(score) average FROM students WHERE gender = 'M';+---------+| average |+---------+| 81.4000 |+---------+1 row in set (0.01 sec)-- WHERE找不到返回NULL$ mysql&gt; SELECT AVG(score) average FROM students WHERE gender = 'X';+---------+| average |+---------+| NULL |+---------+1 row in set (0.00 sec)-- 计算页数$ SELECT CEILING(COUNT(*) / 3) pageSize FROM students;mysql&gt; SELECT CEILING(COUNT(*) / 3) pageSize FROM students;+----------+| pageSize |+----------+| 4 |+----------+1 row in set (0.00 sec) 3、使用DISTINCT 默认为ALL，可选DISTINCT，即去掉重复值 上面的聚集（聚合）函数都可以使用DISTINCT来去重计算 对于MIN，MAX添加该参数无意义，因为去不去重结果无影响！ 下面的这个例子就是将价格不同的过滤掉，仅计算价格不同的均值。 12345678SELECT AVG(DISTINCT prod_price) avg_riceFROM productsWHERE vend_id = 1003;+-----------+| avg_price |+-----------+| 15 .998000|+-----------+ 4、组合聚集函数 即一条语句使用多个聚集函数。 12345SELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS price_max,AVG(prod_price) AS price_avgFROM products; 八、多表查询 由于多表查询的笛卡尔乘积问题，会导致每行两表的数据并没有逻辑对应关系。。。 即直接查出来的数据对应不一定正确，需要进行条件限定，如students表的class_id 与 classes表的id相同才能唯一确定一个对应关系。 一般使用主键或外键进行多表关联查询，笛卡尔乘积没太多意义，而且很容易查询量爆炸，不建议使用！ 1、语法： SELECT * FROM &lt;表1&gt; &lt;表2&gt;。 这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。 这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。 给表起别名，再给相同列起别名有助于查看！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$ mysql&gt; SELECT -&gt; s.id sid, -&gt; s.name, -&gt; s.gender, -&gt; s.score, -&gt; c.id cid, -&gt; c.name cname -&gt; FROM students s, classes c;+-----+--------+--------+-------+-----+--------+| sid | name | gender | score | cid | cname |+-----+--------+--------+-------+-----+--------+| 1 | 小明 | M | 90 | 1 | 一班 || 1 | 小明 | M | 90 | 2 | 二班 || 1 | 小明 | M | 90 | 3 | 三班 || 1 | 小明 | M | 90 | 4 | 四班 || 2 | 小红 | F | 95 | 1 | 一班 || 2 | 小红 | F | 95 | 2 | 二班 || 2 | 小红 | F | 95 | 3 | 三班 || 2 | 小红 | F | 95 | 4 | 四班 || 3 | 小军 | M | 88 | 1 | 一班 || 3 | 小军 | M | 88 | 2 | 二班 || 3 | 小军 | M | 88 | 3 | 三班 || 3 | 小军 | M | 88 | 4 | 四班 || 4 | 小米 | F | 73 | 1 | 一班 || 4 | 小米 | F | 73 | 2 | 二班 || 4 | 小米 | F | 73 | 3 | 三班 || 4 | 小米 | F | 73 | 4 | 四班 || 5 | 小白 | F | 81 | 1 | 一班 || 5 | 小白 | F | 81 | 2 | 二班 || 5 | 小白 | F | 81 | 3 | 三班 || 5 | 小白 | F | 81 | 4 | 四班 || 6 | 小兵 | M | 55 | 1 | 一班 || 6 | 小兵 | M | 55 | 2 | 二班 || 6 | 小兵 | M | 55 | 3 | 三班 || 6 | 小兵 | M | 55 | 4 | 四班 || 7 | 小林 | M | 85 | 1 | 一班 || 7 | 小林 | M | 85 | 2 | 二班 || 7 | 小林 | M | 85 | 3 | 三班 || 7 | 小林 | M | 85 | 4 | 四班 || 8 | 小新 | F | 91 | 1 | 一班 || 8 | 小新 | F | 91 | 2 | 二班 || 8 | 小新 | F | 91 | 3 | 三班 || 8 | 小新 | F | 91 | 4 | 四班 || 9 | 小王 | M | 89 | 1 | 一班 || 9 | 小王 | M | 89 | 2 | 二班 || 9 | 小王 | M | 89 | 3 | 三班 || 9 | 小王 | M | 89 | 4 | 四班 || 10 | 小丽 | F | 85 | 1 | 一班 || 10 | 小丽 | F | 85 | 2 | 二班 || 10 | 小丽 | F | 85 | 3 | 三班 || 10 | 小丽 | F | 85 | 4 | 四班 |+-----+--------+--------+-------+-----+--------+40 rows in set (0.00 sec) 2、使用WHERE 同样可以使用WHERE进行限制。 12345678910111213141516171819mysql&gt; SELECT -&gt; s.id sid, -&gt; s.name, -&gt; s.gender, -&gt; s.score, -&gt; c.id cid, -&gt; c.name cname -&gt; FROM students s, classes c -&gt; WHERE s.gender = 'M' AND c.id = 1;+-----+--------+--------+-------+-----+--------+| sid | name | gender | score | cid | cname |+-----+--------+--------+-------+-----+--------+| 1 | 小明 | M | 90 | 1 | 一班 || 3 | 小军 | M | 88 | 1 | 一班 || 6 | 小兵 | M | 55 | 1 | 一班 || 7 | 小林 | M | 85 | 1 | 一班 || 9 | 小王 | M | 89 | 1 | 一班 |+-----+--------+--------+-------+-----+--------+5 rows in set (0.01 sec) 九、连接（联结）查询 连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。 1、INNER JOIN查询（内连接） 现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。 这时，连接查询就派上了用场。 看下方结果，就知道这是连接了classes表的name列，尽可能满足两个表情况，不会出现NULL的情况。 先确定主表，仍然使用FROM &lt;表1&gt;的语法； 再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法； 然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接； 可选：加上WHERE子句、ORDER BY等子句。 示例图如下： 代码如下： 12345678910111213141516171819$ mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; INNER JOIN classes c -&gt; ON s.class_id = c.id;+----+--------+----------+------------+--------+-------+| id | name | class_id | class_name | gender | score |+----+--------+----------+------------+--------+-------+| 1 | 小明 | 1 | 一班 | M | 90 || 2 | 小红 | 1 | 一班 | F | 95 || 3 | 小军 | 1 | 一班 | M | 88 || 4 | 小米 | 1 | 一班 | F | 73 || 5 | 小白 | 2 | 二班 | F | 81 || 6 | 小兵 | 2 | 二班 | M | 55 || 7 | 小林 | 2 | 二班 | M | 85 || 8 | 小新 | 3 | 三班 | F | 91 || 9 | 小王 | 3 | 三班 | M | 89 || 10 | 小丽 | 3 | 三班 | F | 85 |+----+--------+----------+------------+--------+-------+10 rows in set (0.01 sec) 2、RIGHT OUTER JOIN（右外连接） 尽量满足第二个表的情况，第一个表若没有对应的信息，会以NULL显示： 注意：左右外连接可以省略写OUTER。 示例图如下： 代码如下： 1234567891011121314151617181920$ mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; RIGHT OUTER JOIN classes c -&gt; ON s.class_id = c.id;+------+--------+----------+------------+--------+-------+| id | name | class_id | class_name | gender | score |+------+--------+----------+------------+--------+-------+| 1 | 小明 | 1 | 一班 | M | 90 || 2 | 小红 | 1 | 一班 | F | 95 || 3 | 小军 | 1 | 一班 | M | 88 || 4 | 小米 | 1 | 一班 | F | 73 || 5 | 小白 | 2 | 二班 | F | 81 || 6 | 小兵 | 2 | 二班 | M | 55 || 7 | 小林 | 2 | 二班 | M | 85 || 8 | 小新 | 3 | 三班 | F | 91 || 9 | 小王 | 3 | 三班 | M | 89 || 10 | 小丽 | 3 | 三班 | F | 85 || NULL | NULL | NULL | 四班 | NULL | NULL |+------+--------+----------+------------+--------+-------+11 rows in set (0.01 sec) 3、LEFT OUTER JOIN（左外连接） 尽量满足第一个表的情况，第二个表若没有对应信息，会以NULL显示： 由于students表都可以在classes表匹配，所以添加一行吧唧id为5的，来说明左外连接问题。 示例图如下： 代码如下： 123456789101112131415161718192021222324-- $ mysql&gt; INSERT INTO students (class_id, name, gender, score) values (5, '新生', 'M', 88);Query OK, 1 row affected (0.01 sec)$ mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; LEFT OUTER JOIN classes c -&gt; ON s.class_id = c.id;+----+--------+----------+------------+--------+-------+| id | name | class_id | class_name | gender | score |+----+--------+----------+------------+--------+-------+| 1 | 小明 | 1 | 一班 | M | 90 || 2 | 小红 | 1 | 一班 | F | 95 || 3 | 小军 | 1 | 一班 | M | 88 || 4 | 小米 | 1 | 一班 | F | 73 || 5 | 小白 | 2 | 二班 | F | 81 || 6 | 小兵 | 2 | 二班 | M | 55 || 7 | 小林 | 2 | 二班 | M | 85 || 8 | 小新 | 3 | 三班 | F | 91 || 9 | 小王 | 3 | 三班 | M | 89 || 10 | 小丽 | 3 | 三班 | F | 85 || 11 | 新生 | 5 | NULL | M | 88 |+----+--------+----------+------------+--------+-------+11 rows in set (0.01 sec) 4、FULL OUTER JOIN（全外连接） 也就是左右外连接的并集，没有的信息显示为NULL： MySQL并不支持全连接。。。 示例图如下： 代码如下： 123456$ mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; FULL OUTER JOIN classes c -&gt; ON s.class_id = c.id;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FULL OUTER JOIN classes cON s.class_id = c.id' at line 3 代替解决方案：使用UNION，左连接一次，右连接一次，再使用UNION合并。 代码如下： 123456789101112131415161718192021222324mysql&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; RIGHT OUTER JOIN classes c ON class_id = c.id -&gt; UNION -&gt; SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score -&gt; FROM students s -&gt; LEFT OUTER JOIN classes c ON class_id = c.id;+------+--------+----------+------------+--------+-------+| id | name | class_id | class_name | gender | score |+------+--------+----------+------------+--------+-------+| 1 | 小明 | 1 | 一班 | M | 90 || 2 | 小红 | 1 | 一班 | F | 95 || 3 | 小军 | 1 | 一班 | M | 88 || 4 | 小米 | 1 | 一班 | F | 73 || 5 | 小白 | 2 | 二班 | F | 81 || 6 | 小兵 | 2 | 二班 | M | 55 || 7 | 小林 | 2 | 二班 | M | 85 || 8 | 小新 | 3 | 三班 | F | 91 || 9 | 小王 | 3 | 三班 | M | 89 || 10 | 小丽 | 3 | 三班 | F | 85 || NULL | NULL | NULL | 四班 | NULL | NULL || 11 | 新生 | 5 | NULL | M | 88 |+------+--------+----------+------------+--------+-------+12 rows in set (0.00 sec) 十、正则搜索查询 可以使用正则的所有语法！ 参考我之前的Java教程的正则表达式！，以及JavaScript教程的正则表达式！，以及加强版的正则表达式! 这里只介绍一些不同点！ 12345678910111213141516mysql&gt; SELECT * FROM students WHERE score REGEXP '8\\\\d';+----+----------+--------+--------+-------+| id | class_id | name | gender | score |+----+----------+--------+--------+-------+| 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 83 || 5 | 2 | 小白 | F | 81 || 7 | 2 | 小林 | M | 85 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 || 11 | 5 | 新生 | M | 88 || 12 | 2 | 大牛 | M | 80 || 13 | 1 | 大宝 | M | 87 || 14 | 2 | 二宝 | M | 81 |+----+----------+--------+--------+-------+10 rows in set (0.00 sec) 1、语法格式 与LIKE的通配符类似！ 注意： mysql的正则表达式不区分大小写，指的是这样子的 SELECT 'jack 001' REGEXP 'Jack 001'; 可以加上BINARY来区分大小写，eg：SELECT 'jack 001' REGEXP BINARY 'Jack 001'; 123SELECT * FROM students WHERE score REGEXP '8\\\\d';SELECT * FROM students WHERE score LIKE '8%'; 特殊字符格式： \\\\- \\\\. \\\\| \\\\( \\\\{ \\\\[ 以及 \\\\f \\\\r \\\\t \\\\v分别表示换页，换行，回车，制表符，纵向制表符。 \\\\\\表示\\ 匹配字符类： 存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。为更方便工作，可以使用预定义的字符集，称为字符类. 如下： 1SELECT 'HHH123' REGEXP '[[:digit:]]{3}'; 2、使用SELECT进行简单测试 匹配返回 1，不匹配返回 0 LIKE和REGEXP都可以！ 12345678910111213141516mysql&gt; SELECT 'habc123' LIKE 'ha%3';+-----------------------+| 'habc123' LIKE 'ha%3' |+-----------------------+| 1 |+-----------------------+1 row in set (0.00 sec)-- 如下mysql&gt; SELECT 'habc123' REGEXP '^\\\\w*\\\\d{3}$';+---------------------------------+| 'habc123' REGEXP '^\\\\w*\\\\d{3}$' |+---------------------------------+| 1 |+---------------------------------+1 row in set (0.00 sec) 3、REGEXP 和 LIKE一些区别： REGEXP可以匹配子串，只要有子串匹配就可以返回真值，当然也可以匹配原串。 LIKE只能匹配原串，必须将原串全部匹配才可。 十一、创建计算字段 创建计算字段主要是为了格式化输出，可以获得需要的输出结果！ 其他DBMS使用 + ，||来实现拼接来处理格式化，MySql使用Concat()函数进行拼接来处理格式化。 这类普通函数与聚集函数写法规范略有不同，聚集函数全部大写如AVG()，普通函数首字母大写Concat()。 这仅仅是一个规定，约定俗成的规矩，大小写MySql是忽略的。 1、使用Concat()函数1234567891011121314151617181920mysql&gt; SELECT Concat(name, ' ---------- ', score) name_score FROM students;+----------------------+| name_score |+----------------------+| 小明 ---------- 98 || 小红 ---------- 95 || 小军 ---------- 88 || 小米 ---------- 83 || 小白 ---------- 81 || 小兵 ---------- 65 || 小林 ---------- 85 || 小新 ---------- 91 || 小王 ---------- 89 || 小丽 ---------- 85 || 新生 ---------- 88 || 大牛 ---------- 80 || 大宝 ---------- 87 || 二宝 ---------- 81 |+----------------------+14 rows in set (0.00 sec) 同样可以使用一些其他函数来进行控制，使用别名来替换该字段： 这里用到了RTrim()，LTrim()，Trim()，来进行配合，分别为去掉右边空格，左边空格，及两边空格！ 也可以使用别名来重命名该列。 别名可以使用a AS b来表示，也可以直接空格隔开，两种写法完全一致，但一般空格隔开即可！ 123SELECT Concat(RTrim(name), ' - ', LTrim(score)) name_score FROM students;SELECT Concat(RTrim(name), ' - ', LTrim(score)) AS name_score FROM students; 2、执行算术计算 可以使用+-*/来进行计算得到新的一列。 1234SELECT prod_id, quantity, item_price,quantity * item_price expanded_priceFROM orderitemsWHERE order_num = 20005; 可以使用SELECT的测试功能来简单测试一下 123456789101112131415mysql&gt; SELECT Trim(' bsd ');+----------------------+| Trim(' bsd ') |+----------------------+| bsd |+----------------------+1 row in set (0.00 sec)mysql&gt; SELECT 3 * 5;+-------+| 3 * 5 |+-------+| 15 |+-------+1 row in set (0.01 sec) 十二、其他普通函数1、文本处理函数 SOUNDEX 是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。 SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然SOUNDEX 不是SQL概念，但MySQL（就像多数DBMS一样）都提供对SOUNDEX的支持。 可以在你拼错的时候返回正确的匹配项！有发音相似性匹配。。神奇！ 12345678910111213141516mysql&gt; SELECT Soundex('Lie') = Soundex('Lee');+---------------------------------+| Soundex('Lie') = Soundex('Lee') |+---------------------------------+| 1 |+---------------------------------+1 row in set (0.00 sec)SELECT cust_name，cust_contactFROM customersWHERE Soundex(cust_contact) = Soundex('Y Lie');+-------------+--------------+| cust_name | cust_contact || Coyote Inc. | Y Lee |+-------------+--------------+ 2、日期和时间处理函数 日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和有效地排序或过滤，并且节省物理存储空间。 主要是从DATETIME数据类型中截取需要的数据！ 部分示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950mysql&gt; SELECT Now();+---------------------+| Now() |+---------------------+| 2020-06-29 21:45:11 |+---------------------+1 row in set (0.01 sec)mysql&gt; SELECT Date('2020--06-29 00:00:00');+------------------------------+| Date('2020-06-29 00:00:00') |+------------------------------+| 2020-06-29 |+------------------------------+1 row in set (0.01 sec)mysql&gt; SELECT DayOfWeek('2020-06-29 00:00:00');+-----------------------------------+| DayOfWeek('2020-06-29 00:00:00') |+-----------------------------------+| 2 |+-----------------------------------+1 row in set (0.01 sec)mysql&gt; SELECT Now();+---------------------+| Now() |+---------------------+| 2020-06-29 21:56:31 |+---------------------+1 row in set (0.00 sec)mysql&gt; SELECT CurTime();+-----------+| CurTime() |+-----------+| 21:57:09 |+-----------+1 row in set (0.01 sec)-- 实际用于按日期，时间等匹配日期-- 此处的order_date为datetime类型：SEL ECT cust_id，order_numFROM ordersWHERE Date(order_date) = '2020-09-01';-- 使用 Between AndSELECT cust_id，order_numFROM ordersWHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30'; 3、数值处理函数 数值处理函数仅处理数值数据。这些函数一般主要用于代数、三角或几何运算，因此没有串或日期 — 时间处理函数的使用那么频繁。具有讽刺意味的是，在主要DBMS的函数中，数值函数是最一致最统一的函数。 十三、分组（GROUP） 用于统计一类数据的方法：GROUP BY 某一列 HAVING 条件 GROUP BY 子句中列出的每个列都必须是检索列或有效的表达式(eg:nums * score)（但不能是聚集函数）。如果在 SELECT 中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集计算语句外， SELECT 语句中的每个列都必须在 GROUP BY 子句中给出。 如果分组列中具有 NULL 值，则 NULL 将作为一个分组返回。如果列中有多行 NULL 值，它们将分为一组。 GROUP BY 子句必须出现在 WHERE 子句之后， ORDER BY 子句之前。 1、单列分组123456789$ mysql&gt; SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;+----------+-----+| class_id | num |+----------+-----+| 1 | 4 || 2 | 3 || 3 | 3 |+----------+-----+3 rows in set (0.00 sec) 2、多列分组123456789101112$ mysql&gt; SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;+----------+--------+-----+| class_id | gender | num |+----------+--------+-----+| 1 | M | 2 || 1 | F | 2 || 2 | F | 1 || 2 | M | 2 || 3 | F | 2 || 3 | M | 1 |+----------+--------+-----+6 rows in set (0.00 sec) 注意：SQL引擎不能把多个name的值放入一行记录中。因此，聚合查询的列中，只能放入分组的列。 原因：class_id = 1 有 4 个人，他们班级名相同，但name不同，如果有了name列，应该显示几个名字呢？？？ 所以干脆直接报错！ 12$ mysql&gt; SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.students.name' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 3、WITH ROLLUP 在GROUP BY后面加WITH ROLLUP来进行统计分组的总行数。 如下方的最后一行！ 1234567891011mysql&gt; SELECT class_id, COUNT(*) total FROM students GROUP BY class_id WITH ROLLUP;+----------+-------+| class_id | total |+----------+-------+| 1 | 5 || 2 | 5 || 3 | 3 || 5 | 1 || NULL | 14 |+----------+-------+5 rows in set (0.01 sec) 4、对分组的过滤 WHERE用于过滤行，HAVING用于过滤分组。 语法与WHERE一模一样。 WHERE 在数据分组前进行过滤， HAVING 在数据分组后进行过滤。 123456789mysql&gt; SELECT class_id, COUNT(*) total FROM students GROUP BY class_id HAVING COUNT(*) &gt;= 3;+----------+-------+| class_id | total |+----------+-------+| 1 | 5 || 2 | 5 || 3 | 3 |+----------+-------+3 rows in set (0.01 sec) 全部使用的顺序 SELECT子句顺序：SELECT (FROM) (WHERE) (GROUP BY) (ORDER BY) (LIMIT) 括号表示可选！ 12345678910111213mysql&gt; SELECT class_id, COUNT(*) total -&gt; FROM students -&gt; WHERE gender = 'M' -&gt; GROUP BY class_id HAVING COUNT(*) &gt;= 2 -&gt; ORDER BY total -&gt; LIMIT 3;+----------+-------+| class_id | total |+----------+-------+| 1 | 2 || 2 | 4 |+----------+-------+2 rows in set (0.01 sec) 十四、子查询 就是嵌套的多级SELECT语句。 使用连接（联结）通常比子查询要更快！ 1、利用子查询进行过滤 子查询总是从内向外处理，使用适当的缩进可以更易于阅读和调试。内层子查询的结果作为上层的基础进行查询，如下所示，将内层查询结果转变为IN的格式进行下一次查询。 不仅仅可以使用IN，其他的操作符都是可以的，LIKE，&gt;，，，等等都可以！ 嵌套太多会降低性能，不建议嵌套太多！ 注意：要保证WHERE的列与子查询SELECT的列相同！ 同样：使用多表连接通过WHERE也可以实现相同效果。 1234567891011121314151617181920SELECT cust_name，cust_contactFROM customersWHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2'));+----------------+--------------+| cust_name | cust_contact || Coyote InC. | Y Lee || Yosemite P1ace | Y Sam |+----------------+--------------+-- 完全相同SELECT cust_name，cust_contactFROM customers，orders，orderitemsWHERE customers.cust_id = orders.cust_idAND orderitems.order_num = orders.order_numAND prod_id = 'TNT2' ; 2、利用子查询处理计算字段 除了在WHERE后进行过滤，还可以在WHERE前进行计算字段的查询处理！ 这里使用了完全限定列名，即使用表.列 orders.cust_id来进行限定列的范围，当然是为了防止多表存在相同列名。 1234567891011121314151617SELECT cust_name, cust_state， (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS orders FROM customersORDER BY cust_name;+----------------+------------+--------+| cust_name |cust_state | orders |+----------------+------------+--------+| Coyote Inc. | MI | 2 || E Fudd | IL | 1 || Mouse House | 0H | 0 || Wascals | IN | 1 || Yosemite Place | AZ | 1 |+----------------+------------+--------+ 十五、组合查询 即使用UNION来合并多条SELECT语句。 1、UNION 和 WHERE UNION 几乎总是完成与多个WHERE 条件相同的工作。 UNION ALL 为 UNION 的一种形式，它完成WHERE 子句完成不了的工作。如果确实需要每个条件的匹配行全部出现（包括重复行），则必须使用 UNION ALL 而不是 WHERE 。 UNION 中的每个查询必须包含相同的列、表达式或聚集函数！ 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。 2、UNION 会过滤重复行！ 1234567SELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5UNIONSELECT vend_id，prod_id，prod_priceFROM productsWHERE vend_id IN (1001,1002); 3、UNION ALL 不会过滤重复行！ 1234567SELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5UNION ALLSELECT vend_id，prod_id，prod_priceFROM productsWHERE vend_id IN (1001,1002); 4、组合结果排序 只能在最后使用一条ORDER BY 进行排序，排序作用于UNION的结果！ 12345678SELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5UNION ALLSELECT vend_id，prod_id，prod_priceFROM productsWHERE vend_id IN (1001,1002)ORDER BY ven_id, prod_price; 十六、全文本搜索1、两种引擎 InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索，但支持事务处理。 MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。 性能：通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行（而且这些搜索极少使用表索引）。因此，由于被搜索行数不断增加，这些搜索可能非常耗时。 明确控制：使用通配符和正则表达式匹配，很难（而且并不总是能）明确地控制匹配什么和不匹配什么。例如，指定一个词匹配和指定一个词不匹配…. 智能化的结果：虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索，但它们都不能提供一种智能化的选择结果的方法。例如：一个特殊词的搜索将会返回包含这些词的所有行，而不区分包含单个匹配的行和包含多个匹配的行（按照可能是更好地匹配来排列它们）。类似，一个特殊词的搜索将不会找出不包含该词但包含其他相关词的行。 所有这些限制以及更多的限制都可以用全文本搜索来解决，在使用全文本搜索时，MySQL不需要分别查看每个行，不需要分别分析和处理每个词。MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行。这样，MySQL可以快速有效的决定那些词分配（那些行包含它们），那些词不匹配，它们匹配的频率，等等。 2、启用全文本搜索 这些列中有一个名为note_text的列，为了进行全文本搜索，MySQL根据字句FULLTEXT(note_text)的指示对它进行了索引，这里的FULLTEXT索引单个列，如果需要也可以指定多个列。 在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，索引随之自动更新。 可以在创建表时指定FULLTEXT，或者在稍后指定。但是不要在导入数据时使用FULLTEXT，因为更新索引需要时间，虽然不是很多，但毕竟要花时间。如果正在导入数据到一个新表，此时不应该启用FULLTEXT索引。应该首先导入所有数据，然后在修改表，定义FULLTEXT，这要有助于更快地导入数据（而且使索引的总时间小于在导入每行每行时分别进行索引所需的总时间）。 在建表最后指出引擎：ENGINE=MyISAM 123456789CREATE TABLE productnotes ( note_id int NOT NULL AUTO_INCREMENT, prod_id char(10) NOT NULL, note_text text NOT NULL, note_date datetime NOT NULL, PRIMARY KEY(note_id), FULLTEXT(note_text))ENGINE=MyISAM; 3、进行全文本搜索全文本搜索用到的两个函数： 传递给Match的值必须与FULLTEXT()定义中的相同，如果指定多个列，则必须列出它们（而且次序相同）。 搜索不区分大小写，除非使用BINARY方式。 全文本搜索的一个重要部分就是对结果排序。具有较高等级（单词出现的位置靠前，数量多的优先级更高）的行先返回。LIKE同样可以实现，但是由于使用通配符搜索，效率低，速度慢，且输出无序！ Match()指定被搜索的列 Against()指定要使用的搜索表达式。 1234567SELECT note_textFROM productnotesWHERE Match(note_text) Against('rabbit');SELECT note_textFROM productnotesWHERE note_text LIKE '%rabbit%'; 如下：可以返回每行计算后的优先级作为RANK一列！ 等级由MySQL根据行中词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来。 123SELECT note_text Match(note_text) Against('rabbit') AS RANKFROM productnotes; 4、使用查询拓展 查询扩展用来设法放宽所返回的全文本搜索结果的范围。 在Against内添加WITH QUERY EXPANSION表名使用查询拓展！ 使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索： 首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有航 其次，MySQL检查这些匹配行并选择所有有用的词 再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还是用使用所有有用的词 123SELECT note_textFROM productnotesWHERE Match(note_text) Against('anvils' WITH QUERY EXPANSION) ; 5、布尔文本搜索 MySQL支持全文本搜索的另外一种形式，称为布尔方式（boolean mode）。 即使没有FULLTEXT索引也可以使用 布尔方式不同于迄今为止使用的全文本搜索语法的地方在于，即使没有定义fulltext索引，也可以使用它。但是这是一种非常缓慢的操作（其性能随着数据量的增加而降低）。 在Against内添加IN BOOLEAN MODE来表名使用布尔文本搜索！ 此全文本搜索检索包含词heavy的所有行（有两行）。其中使用了关键字IN BOOLEAN MODE，但实际上没有指定布尔操作符，因此，其结果与没有指定布尔方式的结果相同： 123SELECT note_textFROM productnotesWHERE Match(note_text) Against('heavy' IN BOOLEAN MODE); 可匹配包含heavy但不包含任意以rope开始的词的所有行： 123SELECT` `note_textFROM` `productnotesWHERE` `Match(note_text) Against('heavy -rope*' IN BOOLEAN MODE); 全文本布尔操作符： 布尔操作符 说明 + 包含，词必须存在 - 排除，词必须不出现 &gt; 包含，而且增加等级值 &lt; 包含，而且减少等级制 () 把词组成表达式(允许这些子表达式作为一个组被包含、排除、排列等) ~ 取消一个词的排序值 * 词尾的通配符 “” 定义一个短语(与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语) 部分示例如下： 1234567891011121314151617181920212223242526272829SELECT note_textFROM productnotesWHERE Match(note_text) Against('+rabbit +bait' IN BOOLEAN MODE);这个搜索匹配包含词rabbit和bait的行 SELECT note_textFROM productnotesWHERE Match(note_text) Against('rabbit bait' IN BOOLEAN MODE);没有指定操作符，这个搜索匹配包含词rabbit和bait中的至少一个词的行； SELECT note_textFROM productnotesWHERE Match(note_text) Against('“rabbit bait”' IN BOOLEAN MODE);这个搜索匹配短语rabbit bait，而不是匹配两个词； SELECT note_textFROM productnotesWHERE Match(note_text) Against('&gt;rabbit &lt;carrot' IN BOOLEAN MODE);这个搜索匹配rabbit 和carrot，增加前者的等级，降低后者的等级； SELECT note_textFROM productnotesWHERE Match(note_text) Against('+safe +(&lt;combination)' IN BOOLEAN MODE);这个搜索匹配safe 和combination，降低后者的等级； 小总结： 全文本搜索数据时，短词被忽略而且从索引中删除。短词定义为那些具有3个或者3个以下字符的词（如果需要，这个数目可以修改）。 MySQL带有一个内建的非用词（``stopword`）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参阅MySQL文档以了解如何完成此工作）。 许多词出现的频率高，搜索它们没有用处（返回太多的结果），因此，MySQL定义了一条50%的规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN MODE 如果表中的行数小于3行，则全文本搜索将不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。 忽略词中的单引号 ‘ 。例如， don't索引为 dont 。 仅在MyISAM的数据库引擎中支持全文本搜索。 不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。 数据库教程之查询数据已完成！敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SELECT","slug":"SELECT","permalink":"https://www.itnxd.cn/tags/SELECT/"},{"name":"查询","slug":"查询","permalink":"https://www.itnxd.cn/tags/%E6%9F%A5%E8%AF%A2/"}],"author":"Mr.Niu"},{"title":"数据库教程之基础知识","slug":"数据库教程之基础知识","date":"2020-05-26T10:39:46.000Z","updated":"2021-02-06T13:48:19.932Z","comments":true,"path":"posts/15411.html","link":"","permalink":"https://www.itnxd.cn/posts/15411.html","excerpt":"","text":"一、什么是数据库1、数据库（database） 保存有组织的数据的容器（通常是一个文件或一组文件）。 2、数据库与数据库软件 数据库（database）：数据库可以是保存在硬设备上的文件，但也可以不是。 数据库软件（DBMS数据库管理系统）：数据库是通过DBMS创建和操纵的容器，使用DBMS来替你访问数据库。 3、表 在你将资料放入自己的文件柜时，并不是随便将它们扔进某个抽屉就完事了，而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。 在数据库领域中，这种文件称为表。表是一种结构化的文件，可用来存储某种特定类型的数据。表可以保存顾客清单、产品目录，或者其他信息清单。 表（table）： 某种特定类型数据的结构化清单。 表名 数据库中的每个表都有一个名字，用来标识自己。此名字是唯一的，这表示数据库中没有其他表具有相同的名字。 表名的唯一性取决于多个因素，如数据库名和表名等的结合。这表示，虽然在相同数据库中不能两次使用相同的表名，但在不同的数据库中却可以使用相同的表名。 模式 表具有一些特性，这些特性定义了数据在表中如何存储，如可以存储什么样的数据，数据如何分解，各部分信息如何命名等等。描述表的这组信息就是所谓的模式，模式可以用来描述数据库中特定的表以及整个数据库（和其中表的关系）。 模式（schema）：关于数据库和表的布局及特性的信息。 4、列 表由列组成。列中存储着表中某部分的信息。 列（字段）定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL。注意NULL表示字段数据不存在。一个整型字段如果为NULL不表示它的值为0，同样的，一个字符串型字段为NULL也不表示它的值为空串''。 通常情况下，字段应该避免允许为NULL。不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。 列（column） ：表中的一个字段。所有表都是由一个或多个列组成的。 5、数据类型数据类型（datatype）： 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。 6、行 是记录还是行？ 你可能听到用户在提到行（row）时称其为数据库记录（record）。在很大程度上，这两个术语是可以互相替代的，但从技术上说，行才是正确的术语。 行（row）： 表中的一个记录。 7、主键 唯一标识表中每行的这个列（或这组列）称为主键。主键用来表示一个特定的行。没有主键，更新或删除表中特定行很难，因为没有安全的方法保证只涉及相关的行。 关键点：对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 主键（primary key）：一列（或一组列），其值能够唯一区分表中每个行。 7.1 可作为主键的条件： 任意两行都不具有相同的主键值； 每个行都必须具有一个主键值（主键列不允许NULL值）。 注意：主键通常定义在表的一列上，但这并不是必需的，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到构成主键的所有列，所有列值的组合必须是唯一的（但单个列的值可以不唯一）。 7.2 使用主键的好习惯 不更新主键列中的值； 不重用主键列的值； 不在主键列中使用可能会更改的值。 不使用任何业务相关的字段作为主键。（身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。会发生变更！） 7.3 主键id 作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。 对于大部分应用来说，通常自增类型的主键就能满足需求。 如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。 可作为id字段的类型有： 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键； 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。 7.4 联合主键 关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。 没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。 8、外键外键（FOREIGN KEY）：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。 关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。 如下面的表格，class_id就将student表与class表之间形成了关联！ 我们就可以根据class_id这个列直接定位出一个students表的记录应该对应到classes的哪条记录。 外键参考资料，点击这里！ id class_id name other columns… 1 1 小明 … 2 1 小红 … 5 2 小白 … 外键的实现 外键并不是通过列名实现的，而是通过定义外键约束实现的： 外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。 通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。 由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。 1234ALTER TABLE studentsADD CONSTRAINT fk_class_idFOREIGN KEY (class_id)REFERENCES classes (id); 要删除一个外键约束，也是通过ALTER TABLE实现的： 注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的。 12ALTER TABLE studentsDROP FOREIGN KEY fk_class_id; 两种关系 多对多 多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系！ 三个表：teachers表、classes表、teacher_class表（存放teacher ID 与 class ID对应信息） 一对一 一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。 有两个表：students表、contact表（存手机号） 实际上，一对一关系准确地说，是contacts表一对一对应students表。 因为有的学生没有手机号，如果都写道一个students表，会有空出现，写到另一个contact表则不会出现空。 还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度。 9、索引 在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。 索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。 可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。 对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。 使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引有多列直接括号里继续写。 12345ALTER TABLE studentsADD INDEX idx_score (score);ALTER TABLE studentsADD INDEX idx_name_score (name, score); 唯一索引 在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。 但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。 例如name不能重复（通过UNIQUE关键字我们就添加了一个唯一索引。） 12ALTER TABLE studentsADD UNIQUE INDEX uni_name (name); 只对某一列添加一个唯一约束而不创建唯一索引。（name列没有索引，但仍然具有唯一性保证。） 12ALTER TABLE studentsADD CONSTRAINT uni_name UNIQUE (name); 总结：无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。 二、什么是SQL1、什么是SQL 什么是SQL？(Structured Query Language)，SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。 虽然SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为PL/SQL，Microsoft把自己扩展的SQL称为T-SQL。 现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。 2、SQL的优点 SQL不是某个特定数据库供应商专有的语言。几乎所有重要的DBMS都支持SQL，所以，学习此语言使你几乎能与所有数据库打交道。 SQL简单易学。它的语句全都是由描述性很强的英语单词组成，而且这些单词的数目不多。 SQL尽管看上去很简单，但它实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。 3、SQL语言的能力 *DDL：Data Definition Language *：DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。 *DML：Data Manipulation Language *：DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。 *DQL：Data Query Language *：DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。 4、SQL语法特点 SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。 所以，本教程约定：SQL关键字总是大写，以示突出，表名和列名均使用小写。 5、数据模型 数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型： 随着时间的推移和市场竞争，最终，基于关系模型的关系数据库获得了绝对市场份额。 层次模型：层次模型就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树 网状模型：网状模型把每个数据节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网 关系模型：关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，它的数据模型看起来就是一个Excel表 6、数据类型 上面的表中列举了最常用的数据类型。很多数据类型还有别名，例如，REAL又可以写成FLOAT(24)。还有一些不常用的数据类型，例如，TINYINT（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如JSON。 选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，BIGINT能满足整数存储的需求，VARCHAR(N)能满足字符串存储的需求，这两种类型是使用最广泛的。 名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2020-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2020-06-22 12:20:59 7、主流关系数据库 商用数据库，例如：Oracle，SQL Server，DB2等； 开源数据库，例如：MySQL，PostgreSQL等； 桌面数据库，以微软Access为代表，适合桌面应用程序使用； 嵌入式数据库，以Sqlite为代表，适合手机应用和桌面程序。 三、什么是MySQL1、MySQL那些事 MySQL是目前应用最广泛的开源关系数据库。MySQL最早是由瑞典的MySQL AB公司开发，该公司在2008年被SUN公司收购，紧接着，SUN公司在2009年被Oracle公司收购，所以MySQL最终就变成了Oracle旗下的产品。 MySQL是一种DBMS，即它是一种数据库软件。 2、MySQL的优点 成本——MySQL是开放源代码的，一般可以免费使用（甚至可以免费修改）。 性能——MySQL执行很快（非常快）。 可信赖——某些非常重要和声望很高的公司、站点使用MySQL，这些公司和站点都用MySQL来处理自己的重要数据。 简单——MySQL很容易安装和使用。 3、MySQL数据引擎 和其他关系数据库有所不同的是，MySQL本身实际上只是一个SQL接口，它的内部还包含了多种数据引擎！ MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎（IE引擎或Webkit引擎）的关系。对用户而言，切换浏览器引擎不影响浏览器界面，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。 使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择InnoDB就好了。 InnoDB：由Innobase Oy公司开发的一款支持事务的数据库引擎，2006年被Oracle收购； MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。 4、MySQL衍生版本 因为MySQL一开始就是开源的，所以基于MySQL的开源版本，又衍生出了各种版本: MariaDB由MySQL的创始人创建的一个开源分支版本，使用XtraDB引擎。 Aurora由Amazon改进的一个MySQL版本，专门提供给在AWS托管MySQL用户，号称5倍的性能提升。 PolarDB由Alibaba改进的一个MySQL版本，专门提供给在阿里云托管的MySQL用户，号称6倍的性能提升。 MySQL官方版本 以下版本的功能依次递增，价格也依次递增。不过，功能增加的主要是监控、集群等管理功能，对于基本的SQL功能是完全一样的。 Community Edition：社区开源版本，免费； Standard Edition：标准版； Enterprise Edition：企业版； Cluster Carrier Grade Edition：集群版。 5、MySQL版本 4——InnoDB引擎，增加事务处理、并、改进全文本搜索等的支持。 4.1——对函数库、子查询、集成帮助等的重要增加。 5——存储过程、触发器、游标、视图等。 6、安装MySQL 安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。 嗯。。网上找一篇教程安装即可！有时间我再写一下安装教程！ MySQL Client 与 MySQL Server： MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。 在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是127.0.0.1:3306。 123┌──────────────┐ SQL ┌──────────────┐│ MySQL Client │───────&gt;│ MySQL Server │└──────────────┘ TCP └──────────────┘ 7、运行MySQL 管理员身份启动MySQL服务 使用命令登录MySQL 123$ net start mysql$ mysql -u root -pEnter password: ********** 如下图： -u：指定用户名 -p：输入密码 -h：主机名 ，本地默认为localhost，远程服务器为公网ip地址 -P：端口号 8、注意点 命令用;或\\g结束，Enter键不执行操作。 输入help或\\h获得帮助，也可以输入help select获取关于SELECT语句的帮助 输入quit或exit退出命令行程序（并没有关闭mysql服务） 9、管理MySQL数据库相关命令：9.1 列出数据库1$ mysql&gt; SHOW DATABASES; 其中，information_schema、mysql、performance_schema和sys是系统库，不要去改动它们。其他的是用户创建的数据库。 9.2 创建数据库12$ mysql&gt; CREATE DATABASE test;Query OK, 1 row affected (0.01 sec) 9.3 删除数据库12$ mysql&gt; CREATE DATABASE mytest;Query OK, 1 row affected (0.01 sec) 9.4 使用数据库 对一个数据库进行操作时，要首先将其切换为当前数据库： 12$ mysql&gt; USE test;Database changed 表相关命令：9.5 列出表 列出当前数据库的所有表: 1234567$ mysql&gt; SHOW TABLES;+------------------+| Tables_in_mytest |+------------------+| students |+------------------+1 row in set (0.00 sec) 9.6 创建表123456$ mysql&gt; CREATE TABLE students -&gt; ( -&gt; id INT(11), -&gt; name VARCHAR(25) -&gt; );Query OK, 0 rows affected, 1 warning (0.05 sec) 9.7 查看创建表的语句123456789101112$ mysql&gt; SHOW CREATE TABLE students;+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| students | CREATE TABLE `students` ( `id` int DEFAULT NULL, `name` varchar(25) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.01 sec) 9.7 查看表的结构123456789101112$ DESCRIBE &lt;表名&gt;;或$ DESC &lt;表名&gt;;$ mysql&gt; DESC students;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int | YES | | NULL | || name | varchar(25) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.01 sec) 9.8 删除表12$ mysql&gt; DROP TABLE students;Query OK, 0 rows affected (0.03 sec) 9.9 修改表 较为复杂，后续讲解！ 退出MySQL 两种，大小写都可！ 12345$ mysql&gt; EXITBye$ mysql&gt; QUITBye 10、SHOW语句10.1 SHOW TABLES;1234567$ mysql&gt; SHOW TABLES;+------------------+| Tables_in_mytest |+------------------+| students |+------------------+1 row in set (0.00 sec) 10.2 SHOW COLUMNS FROM &lt;表名&gt;; 它对每个字段返回一行，行中包含字段名、数据类型、是否允许 NULL 、键信息、默认值以及其他信息。 DESCRIBE&lt;表名&gt; 语句 SHOW COLUMNS FROM &lt;表名&gt;;的快捷方式！ 简写：DESC &lt;表名&gt; 12345678$ SHOW COLUMNS FROM students;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int | YES | | NULL | || name | varchar(25) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec) 10.3 SHOW STATUS; SHOW STATUS ，用于显示广泛的服务器状态信息。 12$ SHOW STATUS;.... 10.4 SHOW CREATE DATABASE &lt;数据库名&gt;; 显示创建数据库的语句： 12345678$ mysql&gt; SHOW CREATE DATABASE mytest;+----------+----------------------------------------------------------------------------------------------------------------------------------+| Database | Create Database |+----------+----------------------------------------------------------------------------------------------------------------------------------+| mytest | CREATE DATABASE `mytest` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */ |+----------+----------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 10.5 SHOW CREATE TABLE &lt;表名&gt;; 显示创建表的语句： 123456789101112$ mysql&gt; SHOW CREATE TABLE students;+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+| students | CREATE TABLE `students` ( `id` int DEFAULT NULL, `name` varchar(25) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |+----------+---------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 10.6 SHOW GRANTS; 用来显示授予用户（所有用户或特定用户）的安全权限； 12345678910111213141516171819202122mysql&gt; SHOW GRANTS;+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Grants for root@localhost |+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, SHUTDOWN, PROCESS, FILE, REFERENCES, INDEX, ALTER, SHOW DATABASES, SUPER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION SLAVE, REPLICATION CLIENT, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE TABLESPACE, CREATE ROLE, DROP ROLE ON *.* TO `root`@`localhost` WITH GRANT OPTION || GRANT APPLICATION_PASSWORD_ADMIN,AUDIT_ADMIN,BACKUP_ADMIN,BINLOG_ADMIN,BINLOG_ENCRYPTION_ADMIN,CLONE_ADMIN,CONNECTION_ADMIN,ENCRYPTION_KEY_ADMIN,GROUP_REPLICATION_ADMIN,INNODB_REDO_LOG_ARCHIVE,PERSIST_RO_VARIABLES_ADMIN,REPLICATION_APPLIER,REPLICATION_SLAVE_ADMIN,RESOURCE_GROUP_ADMIN,RESOURCE_GROUP_USER,ROLE_ADMIN,SERVICE_CONNECTION_ADMIN,SESSION_VARIABLES_ADMIN,SET_USER_ID,SYSTEM_USER,SYSTEM_VARIABLES_ADMIN,TABLE_ENCRYPTION_ADMIN,XA_RECOVER_ADMIN ON *.* TO `root`@`localhost` WITH GRANT OPTION || GRANT PROXY ON ''@'' TO 'root'@'localhost' WITH GRANT OPTION |+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+3 rows in set (0.00 sec) 10.7 SHOW ERRORS ; 显示服务器错误信息： 12$ mysql&gt; SHOW ERRORS;Empty set (0.00 sec) SHOW WARNINGS; 显示服务器警告信息： 12$ mysql&gt; SHOW WARNINGS;Empty set (0.00 sec) 10.8 HELP SHOW; 用来显示允许SHOW语句的信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061mysql&gt; HELP SHOW;Name: 'SHOW'Description:SHOW has many forms that provide information about databases, tables,columns, or status information about the server. This section describesthose following:SHOW {BINARY | MASTER} LOGSSHOW BINLOG EVENTS [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]SHOW CHARACTER SET [like_or_where]SHOW COLLATION [like_or_where]SHOW [FULL] COLUMNS FROM tbl_name [FROM db_name] [like_or_where]SHOW CREATE DATABASE db_nameSHOW CREATE EVENT event_nameSHOW CREATE FUNCTION func_nameSHOW CREATE PROCEDURE proc_nameSHOW CREATE TABLE tbl_nameSHOW CREATE TRIGGER trigger_nameSHOW CREATE VIEW view_nameSHOW DATABASES [like_or_where]SHOW ENGINE engine_name {STATUS | MUTEX}SHOW [STORAGE] ENGINESSHOW ERRORS [LIMIT [offset,] row_count]SHOW EVENTSSHOW FUNCTION CODE func_nameSHOW FUNCTION STATUS [like_or_where]SHOW GRANTS FOR userSHOW INDEX FROM tbl_name [FROM db_name]SHOW MASTER STATUSSHOW OPEN TABLES [FROM db_name] [like_or_where]SHOW PLUGINSSHOW PROCEDURE CODE proc_nameSHOW PROCEDURE STATUS [like_or_where]SHOW PRIVILEGESSHOW [FULL] PROCESSLISTSHOW PROFILE [types] [FOR QUERY n] [OFFSET n] [LIMIT n]SHOW PROFILESSHOW RELAYLOG EVENTS [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]SHOW SLAVE HOSTSSHOW SLAVE STATUS [FOR CHANNEL channel]SHOW [GLOBAL | SESSION] STATUS [like_or_where]SHOW TABLE STATUS [FROM db_name] [like_or_where]SHOW [FULL] TABLES [FROM db_name] [like_or_where]SHOW TRIGGERS [FROM db_name] [like_or_where]SHOW [GLOBAL | SESSION] VARIABLES [like_or_where]SHOW WARNINGS [LIMIT [offset,] row_count]like_or_where: LIKE 'pattern' | WHERE exprIf the syntax for a given SHOW statement includes a LIKE 'pattern'part, 'pattern' is a string that can contain the SQL % and _ wildcardcharacters. The pattern is useful for restricting statement output tomatching values.Several SHOW statements also accept a WHERE clause that provides moreflexibility in specifying which rows to display. Seehttps://dev.mysql.com/doc/refman/8.0/en/extended-show.html.URL: https://dev.mysql.com/doc/refman/8.0/en/show.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.itnxd.cn/tags/MySQL/"},{"name":"SQL","slug":"SQL","permalink":"https://www.itnxd.cn/tags/SQL/"}],"author":"Mr.Niu"},{"title":"Java教程系列之加密与安全","slug":"Java教程系列之加密与安全","date":"2020-04-20T12:12:43.000Z","updated":"2021-02-06T14:14:19.500Z","comments":true,"path":"posts/25096.html","link":"","permalink":"https://www.itnxd.cn/posts/25096.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 这一节你一定会懵逼，不过这都是绝对会用到知识，先简单过一遍，用到了再细过一次！点击这里，查看原文！ 看的是真的艰难啊！坚持中！！！ 一、URL编码 URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分。 服务器只识别ASCII字符！ URL编码是编码算法，不是加密算法！（主要用来处理文本如汉字。。） 1、编码规则 如果字符是A ~ Z，a ~ z，0 ~ 9以及-、_、.、*、=，则保持不变； 如果是其他字符，先转换为UTF-8编码，然后对每个字节以%XX表示。都是大写。 例如：字符中的UTF-8编码是0xe4b8ad，因此，它的URL编码是%E4%B8%AD。URL编码总是大写。 2、使用URLEncoder 中的URL编码是%E4%B8%AD，文的URL编码是%E6%96%87，!虽然是ASCII字符，也要对其编码为%21。 URL编码与UTF-8编码相对应。 和标准的URL编码稍有不同，URLEncoder把空格字符编码成+，而现在的URL编码标准要求空格被编码为%20，不过，服务器都可以处理这两种情况。 浏览器加号和%20都可以处理为空格： 123456789101112131415161718package com.org;import java.net.URLDecoder;import java.net.URLEncoder;import java.nio.charset.StandardCharsets;public class EnCode { public static void main(String[] args) { // https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87 // 编码： String encoded = URLEncoder.encode(\"中文!\", StandardCharsets.UTF_8); System.out.println(encoded); // %E4%B8%AD%E6%96%87%21 // 解码： String decoded = URLDecoder.decode(encoded, StandardCharsets.UTF_8); System.out.println(decoded); // 中文! }} 二、Base64编码 URL编码是对字符进行编码，表示成%xx的形式，而Base64编码是对二进制数据进行编码，表示成文本格式。 Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。 Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。（？？？不明白） 和URL编码一样，Base64编码是一种编码算法，不是加密算法。 如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。 1、编码规则将三字节的十六进制表示为二进制0和1，一共24bit，然后每6bit一组，得到四个十进制数：（6bit范围为0-63，可以用64个字符表示：） 字符A ~ Z对应索引0 ~ 25 字符a ~ z对应索引26 ~ 51 字符0 ~ 9对应索引52 ~ 61 最后两个索引62、63分别用字符+和/表示。 2、使用Base64 二进制数据就是byte[]数组。Java标准库提供了Base64来对byte[]数组进行编解码： 编码：3byte转6bit，转化为四个十六进制，将对应的十六进制转化为十进制再去上面的规则中查找，返回四个字符：5Lit 解码：将编码后字符按上面规则转化为十进制再转换为二进制，得到3byte，24bit的0和1，再将其转化为十进制输出，有正负区别：[-28, -72, -83] 123456789101112131415161718package com.org;import java.util.Arrays;import java.util.Base64;public class Base64EnCode { public static void main(String[] args) { // 0xe4b8ad // 编码：(3byte -&gt; 6bit一组进行十六进制转换【39, 0b, 22, 2d】) byte[] input = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad }; String b64encoded = Base64.getEncoder().encodeToString(input); System.out.println(b64encoded); // 5Lit // 解码： byte[] output = Base64.getDecoder().decode(b64encoded); System.out.println(Arrays.toString(output)); // [-28, -72, -83] }} 3、Byte数组长度不为3倍数 每三个元素为一组，不为3的倍数如何处理呢？ 这种情况下，需要对输入的末尾补一个或两个0x00，编码后，在结尾加一个=表示补充了1个0x00，加两个=表示补充了2个0x00，解码的时候，去掉末尾补充的一个或两个0x00即可。 编码后的长度加上=总是4的倍数，所以即使不加=也可以计算出原始输入的byte[]。 对于下方例子：前3byte按6bit一组为5Lit，最后1byte(0x21)，前6bit为I，后两个bit补充4个0，达到六bit，即对应Q。由于不够3倍数，会多加两个0x00，所以最终结果最后会多两个=号，代表加了两个0x00。 使用withoutPadding去除末尾等号！ 解码同样，变为8bit的字节，转化为带符号的十进制输出！ 1234567891011121314151617181920package com.org;import java.util.Arrays;import java.util.Base64;public class Base64EnCode { public static void main(String[] args) { byte[] input1 = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad, (byte) 0x21 }; // 编码： // 有=号： String b64encoded1 = Base64.getEncoder().encodeToString(input1); // 去等于号： String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input1); System.out.println(b64encoded1); // 5LitIQ== System.out.println(b64encoded2); // 5LitIQ // 解码： byte[] output1 = Base64.getDecoder().decode(b64encoded2); System.out.println(Arrays.toString(output1)); // [-28, -72, -83, 33] }} 4、将Base64转化为URL编码 URL编码允许出现的特殊符号：-、_、.、*、= Base64编码允许出现的特殊符号：+、/、=， 标准的Base64编码会出现+、/和=，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把+变成-，/变成_： 1234567891011121314151617package com.org;import java.util.Arrays;import java.util.Base64;public class Base64EnCode { public static void main(String[] args) { byte[] input2 = new byte[] { 0x01, 0x02, 0x7f, 0x00 }; // 针对URL的Base64编码：/ -&gt; _ String b64encoded3 = Base64.getUrlEncoder().encodeToString(input2); System.out.println(b64encoded3); // AQJ_AA== // 解码： byte[] output2 = Base64.getUrlDecoder().decode(b64encoded3); System.out.println(Arrays.toString(output2)); // [1, 2, 127, 0] }} 下面就是加密算法： 三、哈希算法1、哈希算法简介 哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。 哈希算法的目的就是为了验证原始数据是否被篡改。 Java字符串的hashCode()就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节int整数。 同样，有一个哈希冲突问题：（字节组合是有穷的，但输入组合是无穷的，一定会出现冲突。。） 特点： 相同的输入一定得到相同的输出； 不同的输入大概率得到不同的输出。 安全哈希算法条件： 碰撞概率低； 不能猜测输出。 一个hashCode例子： 123456789package com.org;public class HashAlgorithm { public static void main(String[] args) { System.out.println(\"hello\".hashCode()); // 99162322 // 使用Ingeter实现十六进制输出 System.out.println(Integer.toString(\"hello\".hashCode(), 16)); // 5e918d2 }} 2、常见哈希算法 算法 输出长度（位） 输出长度（字节） MD5 128 bits 16 bytes SHA-1 160 bits 20 bytes RipeMD-160 160 bits 20 bytes SHA-256 256 bits 32 bytes SHA-512 512 bits 64 bytes 2.1 MD5 使用MessageDigest时，我们首先根据哈希算法获取一个MessageDigest实例，然后，反复调用update(byte[])输入数据。当输入结束后，调用digest()方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。 123456789101112131415161718package com.org;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;public class HashAlgorithm { public static void main(String[] args) throws Exception { // 创建一个MessageDigest实例: MessageDigest md = MessageDigest.getInstance(\"MD5\"); // 反复调用update输入数据: md.update(\"Hello\".getBytes(StandardCharsets.UTF_8)); md.update(\"World\".getBytes(StandardCharsets.UTF_8)); byte[] result = md.digest(); // 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6 // BigInteger的第一个signum参数表示符号位（1：正数；-1：负数） System.out.println(new BigInteger(1, result).toString(16)); }} 2.2 其他哈希算法 将MessageDigest.getInstance(\"MD5\");的算法模式修改即可！ SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。 注意：MD5因为输出长度较短，短时间内破解是可能的，目前已经不推荐使用。 Java标准库支持的所有哈希算法可以在点击这里查到。 再举一个SHA-512算法： 1234567891011121314151617package com.org;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;public class HashAlgorithm { public static void main(String[] args) throws Exception { // 创建一个MessageDigest实例: MessageDigest md1 = MessageDigest.getInstance(\"SHA-512\"); // 反复调用update输入数据: md1.update(\"Hello\".getBytes(StandardCharsets.UTF_8)); md1.update(\"World\".getBytes(StandardCharsets.UTF_8)); byte[] result1 = md1.digest(); // 64 bytes: 8ae6ae71a75d3fb2e0225deeb004faf95d816a0a58093eb4cb5a3aa0f197050d7a4dc0a2d5c6fbae5fb5b0d536a0a9e6b686369fa57a027687c3630321547596 System.out.println(new BigInteger(1, result1).toString(16)); }} 3、哈希算法的用途 验证文件完整性及是否篡改 数据库的用户口令密码的安全性和正确性 4、彩虹表 什么是彩虹表呢？上面讲到了，如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。 然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表。 这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因！ 解决方法： 如果用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）： 加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。 1digest = md5(salt+inputPassword) 四、BouncyCastle BouncyCastle就是一个提供了很多哈希算法和加密算法的第三方库。它提供了Java标准库没有的一些算法，例如，RipeMD160哈希算法。 首先，我们必须把BouncyCastle提供的jar包放到classpath中。这个jar包就是bcprov-jdk15on-xxx.jar，可以从官方网站下载。 IDEA下载下来将其移到lib目录下，然后file-&gt;project structure-&gt;dependencies中右边的加号选择导入jre即可！ 使用第三方算法前需要通过Security.addProvider()注册。（Java标准库的java.security包提供了一种标准机制，允许第三方提供商无缝接入。） 123456789101112131415161718192021package com.org;import org.bouncycastle.jce.provider.BouncyCastleProvider;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;import java.security.Security;public class BouncyCastle00 { public static void main(String[] args) throws Exception{ // 注册BouncyCastle: Security.addProvider(new BouncyCastleProvider()); // 按名称正常调用: MessageDigest md = MessageDigest.getInstance(\"RipeMD160\"); md.update(\"HelloWorld\".getBytes(StandardCharsets.UTF_8)); byte[] result = md.digest(); // ecabeaa2eb986c85e6a6ea2c22b248ab6916de35 System.out.println(new BigInteger(1, result).toString(16)); }} 五、Hmac算法 前面讲到哈希算法时，我们说，存储用户的哈希口令时，要加盐(salt)存储，目的就在于抵御彩虹表攻击。 这个salt可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。 Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。 Hmac算法总是和某种哈希算法配合起来用的。 HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加salt，有如下好处： HmacMD5使用的key长度是64字节，更安全； Hmac是标准算法，同样适用于SHA-1等其他哈希算法； Hmac输出和原有的哈希算法长度一致。 可见，Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。 为了保证安全，我们不会自己指定key，而是通过Java标准库的KeyGenerator生成一个安全的随机的key： 1、加密一般步骤： 通过名称HmacMD5获取KeyGenerator实例； 通过KeyGenerator创建一个SecretKey实例； 通过名称HmacMD5获取Mac实例； 用SecretKey初始化Mac实例； 对Mac实例反复调用update(byte[])输入数据； 调用Mac实例的doFinal()获取最终的哈希值。 12345678910111213141516171819202122232425262728package com.org;import javax.crypto.KeyGenerator;import javax.crypto.Mac;import javax.crypto.SecretKey;import java.math.BigInteger;import java.nio.charset.StandardCharsets;public class Hmac00 { public static void main(String[] args) throws Exception{ KeyGenerator keyGen = KeyGenerator.getInstance(\"HmacMD5\"); SecretKey key = keyGen.generateKey(); // 打印随机生成的key:(64byte) byte[] skey = key.getEncoded(); // 9e62a1d17f27ca9cad816dddce959e3d819e47eb1849adc4fb9a95ee8a2720b14aa9a054acf4a6e1c4028354ce322e58b4b787bab06294f737c606ac98ad6c43 System.out.println(new BigInteger(1, skey).toString(16)); Mac mac = Mac.getInstance(\"HmacMD5\"); // 使用随机key加盐： mac.init(key); mac.update(\"HelloWorld\".getBytes(StandardCharsets.UTF_8)); // salt + HelloWorld：转化为字节 byte[] result = mac.doFinal(); // 转化为16进制：(仍然是原长16byte) // cca902c5a59b5d7ac45bd856fcfdea34 System.out.println(new BigInteger(1, result).toString(16)); }} 2、解密 不知道为啥，解密输出和原来并不一样。。。 先放下。。。 12345678910111213141516171819202122232425262728293031323334353637383940package com.org;import javax.crypto.KeyGenerator;import javax.crypto.Mac;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.util.Arrays;public class Hmac00 { public static void main(String[] args) throws Exception{ KeyGenerator keyGen = KeyGenerator.getInstance(\"HmacMD5\"); SecretKey key = keyGen.generateKey(); // 打印随机生成的key: byte[] skey = key.getEncoded(); System.out.println(new BigInteger(1, skey).toString(16)); System.out.println(Arrays.toString(skey)); Mac mac = Mac.getInstance(\"HmacMD5\"); // 使用随机key加盐： mac.init(key); mac.update(\"HelloWorld\".getBytes(StandardCharsets.UTF_8)); // salt + HelloWorld：转化为字节 byte[] result = mac.doFinal(); // 转化为16进制： System.out.println(new BigInteger(1, result).toString(16)); /*解密：*/ SecretKey key1 = new SecretKeySpec(skey, \"HmacMD5\"); Mac mac1 = Mac.getInstance(\"HmacMD5\"); mac1.init(key1); mac1.update(\"HelloWorld\".getBytes(StandardCharsets.UTF_8)); byte[] result1 = mac.doFinal(); System.out.println(Arrays.toString(result1)); System.out.println(new BigInteger(1, result1).toString(16)); }} 六、对称加密算法 对称加密算法就是传统的用一个密码进行加密和解密。例如，我们常用的WinZIP和WinRAR对压缩包的加密和解密，就是使用对称加密算法。 1、常用对称加密算法 密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。Java标准库提供的算法实现并不包括所有的工作模式和所有填充模式，但是通常我们只需要挑选常用的使用就可以了。 最后注意，DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。 算法 密钥长度 工作模式 填充模式 DES 56/64 ECB/CBC/PCBC/CTR/… NoPadding/PKCS5Padding/… AES 128/192/256 ECB/CBC/PCBC/CTR/… NoPadding/PKCS5Padding/PKCS7Padding/… IDEA 128 ECB PKCS5Padding/PKCS7Padding/… 2、使用AES加密 AES算法是目前应用最广泛的加密算法。我们先用ECB模式加密并解密。 这鸡巴有点难搞。。。 一般步骤： 根据算法名称/工作模式/填充模式获取Cipher实例； 根据算法名称初始化一个SecretKey实例，密钥必须是指定长度； 使用SerectKey初始化Cipher实例，并设置加密或解密模式； 传入明文或密文，获得密文或明文。 2.1 ECB模式 ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低！ 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.org;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.util.Base64;public class AES00 { public static void main(String[] args) throws Exception{ // 原文: String message = \"Hello, world!\"; System.out.println(\"Message: \" + message); // 128位密钥 = 16 bytes Key:（必须指定密钥长度） byte[] key = \"1234567890abcdef\".getBytes(StandardCharsets.UTF_8); // 加密: byte[] data = message.getBytes(StandardCharsets.UTF_8); byte[] encrypted = encrypt(key, data); // Encrypted: 2xiGROlFBhC57b7EGu5c3g== System.out.println(\"Encrypted: \" + Base64.getEncoder().encodeToString(encrypted)); // 解密: byte[] decrypted = decrypt(key, encrypted); // Decrypted: Hello, world! System.out.println(\"Decrypted: \" + new String(decrypted, StandardCharsets.UTF_8)); } // 加密: public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); SecretKey keySpec = new SecretKeySpec(key, \"AES\"); cipher.init(Cipher.ENCRYPT_MODE, keySpec); return cipher.doFinal(input); } // 解密: public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); SecretKey keySpec = new SecretKeySpec(key, \"AES\"); cipher.init(Cipher.DECRYPT_MODE, keySpec); return cipher.doFinal(input); }} 2.2 CBC模式 更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同： 在CBC模式下，需要一个随机生成的16字节IV参数，必须使用SecureRandom生成。因为多了一个IvParameterSpec实例，因此，初始化方法需要调用Cipher的一个重载方法并传入IvParameterSpec。 观察输出，可以发现每次生成的IV不同，密文也不同。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.org;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.security.SecureRandom;import java.util.Base64;public class AES_CBC { public static void main(String[] args) throws Exception{ // 原文: String message = \"Hello, world!\"; System.out.println(\"Message: \" + message); // 256位密钥 = 32 bytes Key: byte[] key = \"1234567890abcdef1234567890abcdef\".getBytes(StandardCharsets.UTF_8); // 加密: byte[] data = message.getBytes(StandardCharsets.UTF_8); byte[] encrypted = encrypt(key, data); // Encrypted: DSXvNDWdzvPhMp9nGR0lXfiTE9lPcVbKSw4gWLGpxFU= System.out.println(\"Encrypted: \" + Base64.getEncoder().encodeToString(encrypted)); // 解密: byte[] decrypted = decrypt(key, encrypted); // Decrypted: Hello, world! System.out.println(\"Decrypted: \" + new String(decrypted, StandardCharsets.UTF_8));} // 加密: public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\"); // CBC模式需要生成一个16 bytes的initialization vector: SecureRandom sr = SecureRandom.getInstanceStrong(); byte[] iv = sr.generateSeed(16); IvParameterSpec ivps = new IvParameterSpec(iv); cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps); byte[] data = cipher.doFinal(input); // IV不需要保密，把IV和密文一起返回: return join(iv, data); } // 解密: public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException { // 把input分割成IV和密文: byte[] iv = new byte[16]; byte[] data = new byte[input.length - 16]; System.arraycopy(input, 0, iv, 0, 16); System.arraycopy(input, 16, data, 0, data.length); // 解密: Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\"); IvParameterSpec ivps = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, keySpec, ivps); return cipher.doFinal(data); } public static byte[] join(byte[] bs1, byte[] bs2) { byte[] r = new byte[bs1.length + bs2.length]; System.arraycopy(bs1, 0, r, 0, bs1.length); System.arraycopy(bs2, 0, r, bs1.length, bs2.length); return r; }} 七、口令加密算法 上一节我们讲的AES加密，细心的童鞋可能会发现，密钥长度是固定的128/192/256位，而不是我们用WinZip/WinRAR那样，随便输入几位都可以。 这是因为对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。 但是我们平时使用的加密软件，输入6位、8位都可以，难道加密方式不一样？ 实际上用户输入的口令并不能直接作为AES的密钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。 PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.org;import org.bouncycastle.jce.provider.BouncyCastleProvider;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.PBEKeySpec;import javax.crypto.spec.PBEParameterSpec;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.security.SecureRandom;import java.security.Security;import java.util.Base64;public class PBE00 { public static void main(String[] args) throws Exception { // 把BouncyCastle作为Provider添加到java.security: Security.addProvider(new BouncyCastleProvider()); // 原文: String message = \"Hello, world!\"; // 加密口令: String password = \"hello12345\"; // 16 bytes随机Salt: byte[] salt = SecureRandom.getInstanceStrong().generateSeed(16); // salt: salt: 9ae41dc05680b0fda28be0f1d6454f3a System.out.printf(\"salt: %032x\\n\", new BigInteger(1, salt)); // 加密: byte[] data = message.getBytes(StandardCharsets.UTF_8); byte[] encrypted = encrypt(password, salt, data); // encrypted: MHVOyeWBxGM7RhpN8xy9fA== System.out.println(\"encrypted: \" + Base64.getEncoder().encodeToString(encrypted)); // 解密: byte[] decrypted = decrypt(password, salt, encrypted); // decrypted: Hello, world! System.out.println(\"decrypted: \" + new String(decrypted, StandardCharsets.UTF_8)); } // 加密: public static byte[] encrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException { PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray()); SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); SecretKey skey = skeyFactory.generateSecret(keySpec); PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000); Cipher cipher = Cipher.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps); return cipher.doFinal(input); } // 解密: public static byte[] decrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException { PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray()); SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); SecretKey skey = skeyFactory.generateSecret(keySpec); PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000); Cipher cipher = Cipher.getInstance(\"PBEwithSHA1and128bitAES-CBC-BC\"); cipher.init(Cipher.DECRYPT_MODE, skey, pbeps); return cipher.doFinal(input); }} 使用PBE时，我们还需要引入BouncyCastle，并指定算法是PBEwithSHA1and128bitAES-CBC-BC。观察代码，实际上真正的AES密钥是调用Cipher的init()方法时同时传入SecretKey和PBEParameterSpec实现的。在创建PBEParameterSpec的时候，我们还指定了循环次数1000，循环次数越多，暴力破解需要的计算量就越大。 如果我们把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，即使用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。 八、密钥交换算法 解决如何传递密钥的问题： 在不安全的信道上传递加密文件是没有问题的，因为黑客拿到加密文件没有用。但是，如何如何在不安全的信道上安全地传输密钥？ 要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。 DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。 我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做： 甲首选选择一个素数p，例如509，底数g，任选，例如5，随机数a，例如123，然后计算A=g^a mod p，结果是215，然后，甲发送p＝509，g=5，A=215给乙； 乙方收到后，也选择一个随机数b，例如，456，然后计算B=g^b mod p，结果是181，乙再同时计算s=A^b mod p，结果是121； 乙把计算的B=181发给甲，甲计算s＝B^a mod p的余数，计算结果与乙算出的结果一样，都是121。 所以最终双方协商出的密钥s是121。注意到这个密钥s并没有在网络上传输。而通过网络传输的p，g，A和B是无法推算出s的，因为实际算法选择的素数是非常大的。 所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。 如果我们把a看成甲的私钥，A看成甲的公钥，b看成乙的私钥，B看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥secretKey，DH算法通过数学定律保证了双方各自计算出的secretKey是相同的。 但是DH算法并未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。消除中间人攻击需要其他方法。 Java实现DH算法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.org;import javax.crypto.KeyAgreement;import java.math.BigInteger;import java.security.*;import java.security.spec.X509EncodedKeySpec;public class DH00 { public static void main(String[] args) {// Bob和Alice: Person bob = new Person(\"Bob\"); Person alice = new Person(\"Alice\"); // 各自生成KeyPair: bob.generateKeyPair(); alice.generateKeyPair(); // 双方交换各自的PublicKey: // Bob根据Alice的PublicKey生成自己的本地密钥: bob.generateSecretKey(alice.publicKey.getEncoded()); // Alice根据Bob的PublicKey生成自己的本地密钥: alice.generateSecretKey(bob.publicKey.getEncoded()); // 检查双方的本地密钥是否相同: bob.printKeys(); alice.printKeys(); // 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密... }}class Person { public final String name; public PublicKey publicKey; private PrivateKey privateKey; private byte[] secretKey; public Person(String name) { this.name = name; } // 生成本地KeyPair: public void generateKeyPair() { try { KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"DH\"); kpGen.initialize(512); KeyPair kp = kpGen.generateKeyPair(); this.privateKey = kp.getPrivate(); this.publicKey = kp.getPublic(); } catch (GeneralSecurityException e) { throw new RuntimeException(e); } } public void generateSecretKey(byte[] receivedPubKeyBytes) { try { // 从byte[]恢复PublicKey: X509EncodedKeySpec keySpec = new X509EncodedKeySpec(receivedPubKeyBytes); KeyFactory kf = KeyFactory.getInstance(\"DH\"); PublicKey receivedPublicKey = kf.generatePublic(keySpec); // 生成本地密钥: KeyAgreement keyAgreement = KeyAgreement.getInstance(\"DH\"); keyAgreement.init(this.privateKey); // 自己的PrivateKey keyAgreement.doPhase(receivedPublicKey, true); // 对方的PublicKey // 生成SecretKey密钥: this.secretKey = keyAgreement.generateSecret(); } catch (GeneralSecurityException e) { throw new RuntimeException(e); } } public void printKeys() { System.out.printf(\"Name: %s\\n\", this.name); System.out.printf(\"Private key: %x\\n\", new BigInteger(1, this.privateKey.getEncoded())); System.out.printf(\"Public key: %x\\n\", new BigInteger(1, this.publicKey.getEncoded())); System.out.printf(\"Secret key: %x\\n\", new BigInteger(1, this.secretKey)); }} 运行结果：（Secret key是相同的） 12345678Name: BobPrivate key: 3081d202010030819706092a864886f70d010301308189024100fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e170240678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca40202018004330231009b3e8e2cd56ae4b0501da4eeb6c2813370b5a3a73e8a1d9ccbbd6e30f27c1f1aa05d68d20da4bba167a8d141203b4d26Public key: 3081e030819706092a864886f70d010301308189024100fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e170240678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca4020201800344000241009b3b7b8ae229ff5f082b725d7f2f4f94c5cd61063e621776012d4a995df4f3ef8df2cadba6e2c54f1e639b7fa51ff84d3fbe74dd2bf55ec2f72cc7cf2a58947bSecret key: 2e516324b72d75e81da0e9c4d328d9401478a07baf667a87e39e3d7c841c892af27d1cddf4a41767a78a2799a2bbb5f3a08988c5c59f6c058cd84d3e790b9bc5Name: AlicePrivate key: 3081d202010030819706092a864886f70d010301308189024100fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e170240678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca4020201800433023100b5b2212c1d074a75eab86290b58d275252e062305ccc25a4b81e5cf96f41e053d15b8718b07cc414a2c0b800253d8df5Public key: 3081df30819706092a864886f70d010301308189024100fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e170240678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca40202018003430002404585b6c895f58eab57a3028f73d62beda35bea505b1a1ae11faafcc7c3054b61e5c4455d09fb1fd6c817147cb7ca9895620ced591183aa88d70a3fbf4b124213Secret key: 2e516324b72d75e81da0e9c4d328d9401478a07baf667a87e39e3d7c841c892af27d1cddf4a41767a78a2799a2bbb5f3a08988c5c59f6c058cd84d3e790b9bc5 九、非对称加密算法 从DH算法我们可以看到，公钥-私钥组成的密钥对是非常有用的加密方式，因为公钥是可以公开的，而私钥是完全保密的，由此奠定了非对称加密的基础。 非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。 因此，如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。 非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。 非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要N*(N-1)/2个密钥，因此每个人需要管理N-1个密钥，密钥管理难度大，而且非常容易泄漏。 既然非对称加密这么好，那我们抛弃对称加密，完全使用非对称加密行不行？也不行。因为非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多。 所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后： 小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红； 小红用自己的RSA私钥解密得到AES口令； 双方使用这个共享的AES口令用AES加密通信。 可见非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。 RSA算法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.org;import javax.crypto.Cipher;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.*;public class RSA00 { public static void main(String[] args) throws Exception { // 明文: byte[] plain = \"Hello, encrypt use RSA\".getBytes(StandardCharsets.UTF_8); // 创建公钥／私钥对: Person1 alice = new Person1(\"Alice\"); // 用Alice的公钥加密: byte[] pk = alice.getPublicKey(); System.out.println(String.format(\"public key: %x\", new BigInteger(1, pk))); byte[] encrypted = alice.encrypt(plain); System.out.println(String.format(\"encrypted: %x\", new BigInteger(1, encrypted))); // 用Alice的私钥解密: byte[] sk = alice.getPrivateKey(); System.out.println(String.format(\"private key: %x\", new BigInteger(1, sk))); byte[] decrypted = alice.decrypt(encrypted); System.out.println(new String(decrypted, StandardCharsets.UTF_8)); }}class Person1 { String name; // 私钥: PrivateKey sk; // 公钥: PublicKey pk; public Person1(String name) throws GeneralSecurityException { this.name = name; // 生成公钥／私钥对: KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"RSA\"); kpGen.initialize(1024); KeyPair kp = kpGen.generateKeyPair(); this.sk = kp.getPrivate(); this.pk = kp.getPublic(); } // 把私钥导出为字节 public byte[] getPrivateKey() { return this.sk.getEncoded(); } // 把公钥导出为字节 public byte[] getPublicKey() { return this.pk.getEncoded(); } // 用公钥加密: public byte[] encrypt(byte[] message) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(Cipher.ENCRYPT_MODE, this.pk); return cipher.doFinal(message); } // 用私钥解密: public byte[] decrypt(byte[] input) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(Cipher.DECRYPT_MODE, this.sk); return cipher.doFinal(input); }} 输出结果： 12345public key: 30819f300d06092a864886f70d010101050003818d003081890281810089411cd2ceb3f44d43641d265de1ba63f752eccf739f4e33e8e4c111ce261ba378729d354797afe6991d5e530c849f42390d0ed098a47b51dd130a1f7303b2ee04f589e9f1ca78d8167c8949e619653f6361f05dec81c44427dbd21ab088ad55790eafb7afedcd03472b57cc7d1aba30656db06210b97dba15c649962df42b5b0203010001encrypted: 7762b626f22c8671049c6114dbe070f551f9a444a11c0e8e9e41a1ff270d2d4515fa0be12c51df055a1ba71cc5360a4646b35498caf69381a959f7e272ede890d7d8d0422e063570116396e2f9bdc2f705c2f6bbc88bc5bdd110026bcbd008d93235a9d27093cfe238b1110115bd2d6d606f44b271152c3f423799fb5ffdda13private key: 30820275020100300d06092a864886f70d01010105000482025f3082025b0201000281810089411cd2ceb3f44d43641d265de1ba63f752eccf739f4e33e8e4c111ce261ba378729d354797afe6991d5e530c849f42390d0ed098a47b51dd130a1f7303b2ee04f589e9f1ca78d8167c8949e619653f6361f05dec81c44427dbd21ab088ad55790eafb7afedcd03472b57cc7d1aba30656db06210b97dba15c649962df42b5b0203010001028180653eb19b533c6d4e7d12a16a06c096b45ce13fabfb771cc1afdee608534fcafd77c0dbf44c5e3933d9e84f06e5ea026c601720c180877c2c33ee727e2662291ecc0cdc56c5144b47f312cf9021c97dc6adfa9573476a99fd27666f252affe3016699d4a9e739bf7aa8d08525f64b8e9f22bdd33bae5d23125145000219e01a49024100eda89fa24ac30b6b65db6592ba570f228cbfa4a656ccbb13cd8fd2f174e3d4dbc26789aad8c5c0e56e2415e807ff00e957183a3c4de14e6d51d7ed7539f90e9f02410093d8d1ec2e6302d5ea315673b1a44ac4d00f94f5b653fa5b84ff2137eeb8a7f0d3bc0b122f274aa8d4eb08595a6524116e91abe0d0e0e4bf5d019775799b35c50240606ab4b8c6d3f26213e4ba84988c915b56f6b8f9b2e5445078690d0f6078bdf69a1c1f41ecc7edc626b5051e29804f025b8f3cb1127781b5e02a55efe52121c9024019754b6884f04dabb220fec6fb3ed41521d29d0ed66f8d7bb6e20bc14add072623ff8c547c4422ca01a7db0f2fce9cb057bec3bef998d02ad7840fa58de419150240790e8dadbfd8adc0ce6b1eebf1c03d450adcae72e686ac8d9ecc71ce32a34e12ac768cb882ece363ea2f8d6236394ac30187b345d55eb4e42597a7114406ff09Hello, encrypt use RSA RSA的公钥和私钥都可以通过getEncoded()方法获得以byte[]表示的二进制数据，并根据需要保存到文件中。要从byte[]数组恢复公钥或私钥，可以这么写： 以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。 如果修改待加密的byte[]数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。 此外，只使用非对称加密算法不能防止中间人攻击。 123456789byte[] pkData = ...byte[] skData = ...KeyFactory kf = KeyFactory.getInstance(\"RSA\");// 恢复公钥:X509EncodedKeySpec pkSpec = new X509EncodedKeySpec(pkData);PublicKey pk = kf.generatePublic(pkSpec);// 恢复私钥:PKCS8EncodedKeySpec skSpec = new PKCS8EncodedKeySpec(skData);PrivateKey sk = kf.generatePrivate(skSpec); 十、签名算法 我们使用非对称加密算法的时候，对于一个公钥-私钥对，通常是用公钥加密，私钥解密。 如果使用私钥加密，公钥解密是否可行呢？实际上是完全可行的。 不过我们再仔细想一想，私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密。这个加密有什么意义？ 这个加密的意义在于，如果小明用自己的私钥加密了一条消息，比如小明喜欢小红，然后他公开了加密消息，由于任何人都可以用小明的公钥解密，从而使得任何人都可以确认小明喜欢小红这条消息肯定是小明发出的，其他人不能伪造这个消息，小明也不能抵赖这条消息不是自己写的。 因此，私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。 在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名。 对签名进行验证实际上就是用公钥解密。 然后把解密后的哈希与原始消息的哈希进行对比。 因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。 常用签名算法1.1 RSA签名 实际上就是指定某种哈希算法进行RSA签名的方式 MD5withRSA SHA1withRSA SHA256withRSA 使用其他公钥，或者验证签名的时候修改原始信息，都无法验证成功。 123456789101112131415161718192021222324252627282930313233package com.org;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.*;public class QianMing { public static void main(String[] args) throws Exception{ // 生成RSA公钥/私钥: KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"RSA\"); kpGen.initialize(1024); KeyPair kp = kpGen.generateKeyPair(); PrivateKey sk = kp.getPrivate(); PublicKey pk = kp.getPublic(); // 待签名的消息: byte[] message = \"Hello, I am Bob!\".getBytes(StandardCharsets.UTF_8); // 用私钥签名: Signature s = Signature.getInstance(\"SHA1withRSA\"); s.initSign(sk); s.update(message); byte[] signed = s.sign(); System.out.println(String.format(\"signature: %x\", new BigInteger(1, signed))); // 用公钥验证: Signature v = Signature.getInstance(\"SHA1withRSA\"); v.initVerify(pk); v.update(message); boolean valid = v.verify(signed); System.out.println(\"valid? \" + valid); }} 输出结果： 12signature: 7ce04446376358e2de5b5f299c780385f2e436154f6ad03df846fe4ec14f7de8d1a4acdade4a0951f99c02f4305c6ddb1327321ac4086737690b2bf2b9297050cba1a30451c989ef1512ec453625e289525e492ab707ec110b2928c13faa154b1ebd21f001cb0c61a273a8c74ac51ee6a2bdef5161a05f4e1997b364f5dfc889valid? true 1.2 DSA签名 除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。 和RSA数字签名相比，DSA的优点是更快。 DSA只能配合SHA使用，常用的算法有： SHA1withDSA SHA256withDSA SHA512withDSA 1.3 ECDSA签名 椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。 十一、数字证书 我们知道，摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。 因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。 数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。 我们在上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性。 要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用自签名的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。 在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。我们用下面的命令创建一个key store，并设定口令123456： 1$ keytool -storepass 123456 -genkeypair -keyalg RSA -keysize 1024 -sigalg SHA1withRSA -validity 3650 -alias mycert -keystore my.keystore -dname \"CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN\" 几个主要的参数是： keyalg：指定RSA加密算法； sigalg：指定SHA1withRSA签名算法； validity：指定证书有效期3650天； alias：指定证书在程序中引用的名称； dname：最重要的CN=www.sample.com指定了Common Name，如果证书用在HTTPS中，这个名称必须与域名完全一致。 执行上述命令，JDK会在当前目录创建一个my.keystore文件，并存储创建成功的一个私钥和一个证书，它的别名是mycert。 通过数字证书进行加解密和签名： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.org;import com.sun.tools.javac.Main;import javax.crypto.Cipher;import java.io.InputStream;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.security.GeneralSecurityException;import java.security.KeyStore;import java.security.PrivateKey;import java.security.Signature;import java.security.cert.X509Certificate;public class NumberZhengShu { public static void main(String[] args) throws Exception { byte[] message = \"Hello, use X.509 cert!\".getBytes(StandardCharsets.UTF_8); // 读取KeyStore: KeyStore ks = loadKeyStore(\"my.keystore\", \"123456\"); // 读取私钥: PrivateKey privateKey = (PrivateKey) ks.getKey(\"mycert\", \"123456\".toCharArray()); // 读取证书: X509Certificate certificate = (X509Certificate) ks.getCertificate(\"mycert\"); // 加密: byte[] encrypted = encrypt(certificate, message); System.out.println(String.format(\"encrypted: %x\", new BigInteger(1, encrypted))); // 解密: byte[] decrypted = decrypt(privateKey, encrypted); System.out.println(\"decrypted: \" + new String(decrypted, StandardCharsets.UTF_8)); // 签名: byte[] sign = sign(privateKey, certificate, message); System.out.println(String.format(\"signature: %x\", new BigInteger(1, sign))); // 验证签名: boolean verified = verify(certificate, message, sign); System.out.println(\"verify: \" + verified); } static KeyStore loadKeyStore(String keyStoreFile, String password) { try (InputStream input = NumberZhengShu.class.getResourceAsStream(keyStoreFile)) { if (input == null) { throw new RuntimeException(\"file not found in classpath: \" + keyStoreFile); } KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType()); ks.load(input, password.toCharArray()); return ks; } catch (Exception e) { throw new RuntimeException(e); } } static byte[] encrypt(X509Certificate certificate, byte[] message) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(certificate.getPublicKey().getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, certificate.getPublicKey()); return cipher.doFinal(message); } static byte[] decrypt(PrivateKey privateKey, byte[] data) throws GeneralSecurityException { Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateKey); return cipher.doFinal(data); } static byte[] sign(PrivateKey privateKey, X509Certificate certificate, byte[] message) throws GeneralSecurityException { Signature signature = Signature.getInstance(certificate.getSigAlgName()); signature.initSign(privateKey); signature.update(message); return signature.sign(); } static boolean verify(X509Certificate certificate, byte[] message, byte[] sig) throws GeneralSecurityException { Signature signature = Signature.getInstance(certificate.getSigAlgName()); signature.initVerify(certificate); signature.update(message); return signature.verify(sig); }} 输出结果： 1234encrypted: 7f88754e3e31ab5f6aa80d6a2f4610095bc0057b05fab78e5e9e14839103e8648d219a9bb43189d4896b5c5f95c82a85c94e242b6afdc54303650ce7513fa5877e3adb91afb38cbf036e419ade2406ea563bf7a7520454b689ea81281fdc999b58550178403094b44df047c188918b2743b98c5e46f7bcc8f50c3aa2bd8fb11cdecrypted: Hello, use X.509 cert!signature: 1d13d65d2a8928ccb6639f5d325f77e4b211b5cb3a120f6a182a05c4ddedde29cc8a3af1ee02473015514a8b65e743f6f58997aa5f00e464a68136f8b680682af5107bda5d4de925f3699f7d7327fee21c4b9e5c90641b91a6cb8be93a6f008006eb4052749a6cffa43a7e4749e4afc55293097baebc5a72e3a05b21dbba8a34verify: true 在上述代码中，我们从key store直接读取了私钥-公钥对，私钥以PrivateKey实例表示，公钥以X509Certificate表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。 以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下： 浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书； 浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器； 服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。 上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。 注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商DigiNotar就发生过私钥泄漏导致公司破产的事故。 这艰难的一节终于简单过了一遍，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"加密","slug":"加密","permalink":"https://www.itnxd.cn/tags/%E5%8A%A0%E5%AF%86/"},{"name":"安全","slug":"安全","permalink":"https://www.itnxd.cn/tags/%E5%AE%89%E5%85%A8/"}],"author":"Mr.Niu"},{"title":"Java教程系列之正则表达式","slug":"Java教程系列之正则表达式","date":"2020-04-18T10:06:42.000Z","updated":"2021-02-06T14:16:53.668Z","comments":true,"path":"posts/53926.html","link":"","permalink":"https://www.itnxd.cn/posts/53926.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 由于学JavaScript时就已经学过了正则的规则，所以本文只介绍与其不同支出，大概的一个框架及用法！ 一、正则匹配规则 \\d ：一个数字 \\D：一个非数字 \\w ：一个数字或一个字母（大小写） \\W：与\\w相对。。。匹配其不能匹配的 \\s ：一个空格 \\S：与\\s相对，匹配其不能匹配的 \\u548c：匹配一个指定Unicode字符 . ：一个任意字符 \\. ：一个小数点 * ：任意个（包括0个） + ：至少一个 ？ ：0个或1个 {n,}：至少n个 {n} ：n个 {n, m} ：n 到 m 个 \\- ：一个- \\\\ ：一个\\ [abc]：匹配其中一个 [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串 [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就JavaScript允许的变量名 [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符） [^0-9]：不匹配数字，匹配其他任意字符一个 A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 ()：相当于提取公因式。。 ^和$写在正则表达式前后可以精确控制字符串，保证开头和结尾的规则，在JavaScript中，js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了；而在Java中，js不可以匹配'jsp'。 二、Java中使用String正则不同之处 Java没有专门的正则对象，所以用String字符串来表示一个正则表达式： 这样就会使得与正则表达式不一样了： 格式：标准正则 - - - - - - - -&gt; Java中字符串表示的正则 \\d -&gt; \\\\d \\\\ -&gt; \\\\\\\\ \\- -&gt; - \\_ -&gt; _ \\$ -&gt; $ \\\" -&gt; \\\" \\' -&gt; ' / -&gt; / 总结：java中的特殊字符可以直接用，双引号特殊得用斜杠转义： 标准正则两个斜杠代表一个斜杠，Java字符串则是四个斜杠代表一个斜杠，即前两个转义为1个，后两个转义为1个，前面再将后面的转义为斜杠。。。 大概就是这些。。。 1234567891011121314package com.org;public class Regex01 { public static void main(String[] args) { // /\\d\\\\\\-\\_\\$\\\"\\' String re = \"/\\\\d\\\\\\\\-_&amp;\\\"'\"; System.out.println(\"/3\\\\-_&amp;\\\"'\".matches(re));// true String re1 = \"[^1-9]*\"; System.out.println(\"h)fkd-+d\".matches(re1)); // true // 与JavaScript不同，特别的地方。。 String re3 = \"js\"; System.out.println(\"jsp\".matches(re3)); // false JavaScript可以匹配。。。 }} 三、分组匹配（引入regex包） ()的一个重要作用，用来分组： 使用String.matches()方法只能判断，要想获得匹配子串需要使用regex包的对象。 还有：Java的正则匹配和JavaScript有点不一样：（参考第一小节最后的内容！） 引入java.util.regex包，用Pattern对象匹配，匹配后获得一个Matcher对象，如果匹配成功，就可以直接从Matcher.group(index)返回子串： 下标为0返回原串，下标为1以后的则返回匹配的字串！ 1、一个例子12345678910111213141516171819package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex02 { public static void main(String[] args) { Pattern p = Pattern.compile(\"(\\\\d{3,4})-(\\\\d{7,8})\"); Matcher m = p.matcher(\"010-12345678\"); if (m.matches()) { System.out.println(m.group(0)); // 010-12345678 System.out.println(m.group(1)); // 010 System.out.println(m.group(2)); // 12345678 } else { System.out.println(\"匹配失败!\"); } }} 2、Pattern 使用String和regex包，实际上这两种代码本质上是一样的，因为String.matches()方法内部调用的就是Pattern和Matcher类的方法。 反复使用String.matches()对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的Pattern对象。 完全可以先创建出一个Pattern对象，然后反复使用，就可以实现编译一次，多次匹配： 使用Matcher时，必须首先调用matches()判断是否匹配成功，匹配成功后，才能调用group()提取子串。 代码见上面例子： 四、贪婪匹配1、贪婪匹配 看下方例子，这就是贪婪匹配，\\d+将后面的所有数字都给匹配了，所以0*就无法匹配了！ 贪婪匹配：任何一个规则，它总是尽可能多地向后匹配，因此，\\d+总是会把后面的0包含进来。 123456789101112131415package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex04 { public static void main(String[] args) { Pattern pattern = Pattern.compile(\"(\\\\d+)(0*)\"); Matcher matcher = pattern.matcher(\"1230000\"); if (matcher.matches()) { System.out.println(matcher.group(1)); // \"1230000\" System.out.println(matcher.group(2)); // \"\" } }} 2、解决方法：（非贪婪匹配） 使用?，使其尽可能先去满足后面的规则，完事了在满足自己规则； 123456789101112131415package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex04 { public static void main(String[] args) { Pattern pattern = Pattern.compile(\"(\\\\d+?)(0*)\"); Matcher matcher = pattern.matcher(\"1230000\"); if (matcher.matches()) { System.out.println(matcher.group(1)); // \"123\" System.out.println(matcher.group(2)); // \"0000\" } }} 3、?? 连续两个问号：(针对没有+*的时候使用) 第一个：表示基础意思，匹配0个或1个。。 第二个：非贪婪匹配 只有一个问号：（+*符号后面） 默认就是：非贪婪匹配 只有一个问号：（没有+*符号） 默认就是：表示基础意思，匹配0个或1个。。 123456789101112131415package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex04 { public static void main(String[] args) { Pattern pattern = Pattern.compile(\"(\\\\d??)(0*)\"); Matcher matcher = pattern.matcher(\"10000\"); if (matcher.matches()) { System.out.println(matcher.group(1)); // \"1\" System.out.println(matcher.group(2)); // \"0000\" } }} 五、分割 使用split()方法，返回一个String数组。 1、使用Pattern的split方法12345678910111213package com.org;import java.util.regex.Pattern;public class Regex05 { public static void main(String[] args) { Pattern pattern = Pattern.compile(\"[\\s,\\\\\\\\*;]+\"); String[] str = pattern.split(\"2 ;;,43\\\\ 5* ,7\"); for (String s : str) { System.out.print(s + \" \"); // 2 43 5 7 } }} 2、使用String 的split方法 直接使用String的split方法更简单！ 1234567891011package com.org;public class Regex06 { public static void main(String[] args) { String[] str = \"2 ;;,43\\\\ 5* ,7\".split(\"[\\s,\\\\\\\\*;]+\"); for (String s : str) { System.out.print(s + \" \"); //2 43 5 7 } }} 六、搜索和替换1、搜索 使用Matcher.find()判断有没有匹配子串了。 使用Matcher.start()和Matcher.end()方法返回子串的起始下标位置，类似于迭代器，找完一个找下一个，直到找完。Matcher.find()方法也是，找过一个就不回去找了，直到找不到返回false！ 使用String.substring()来切割输出！ 12345678910111213141516package com.org;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Regex07 { public static void main(String[] args) { String s = \"the quick brown fox jumps over the lazy dog.\"; Pattern p = Pattern.compile(\"\\\\wo\\\\w\"); Matcher m = p.matcher(s); while (m.find()) { String sub = s.substring(m.start(), m.end()); System.out.println(sub); // row fox dog } }} 2、替换 使用正则表达式替换字符串可以直接调用String.replaceAll()，它的第一个参数是正则表达式，第二个参数是待替换的字符串： 如下例子：将多个空格替换为一个空格 123456789package com.org;public class Regex08 { public static void main(String[] args) { String s = \"The quick\\t\\t brown fox jumps over the lazy dog.\"; String r = s.replaceAll(\"\\\\s+\", \" \"); System.out.println(r); // \"The quick brown fox jumps over the lazy dog.\" }} 3、反向引用 第二个参数可以使用$1、$2来反向引用匹配到的子串。 $1指的是前面括号的一组内容，$2只第二个括号的内容，以此类推。。 一个例子：将四字母单词加上&lt;b&gt;&lt;/b&gt;，即HTML的加粗标签！ 即([a-z]{4})替换了$1。 123456789package com.org;public class Regex08 { public static void main(String[] args) { String ss = \"the quick brown fox jumps over the lazy dog.\"; String rr = ss.replaceAll(\"\\\\s([a-z]{4})\\\\s\", \" &lt;b&gt;$1&lt;/b&gt; \"); System.out.println(rr); // the quick brown fox jumps &lt;b&gt;over&lt;/b&gt; the &lt;b&gt;lazy&lt;/b&gt; dog. }} 正则表达式已完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Regex","slug":"Regex","permalink":"https://www.itnxd.cn/tags/Regex/"}],"author":"Mr.Niu"},{"title":"Java教程系列之单元测试","slug":"Java教程系列之单元测试","date":"2020-04-16T10:05:18.000Z","updated":"2021-02-06T14:07:29.549Z","comments":true,"path":"posts/44270.html","link":"","permalink":"https://www.itnxd.cn/posts/44270.html","excerpt":"","text":"一、编写Junit测试 单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。 实现测试与主程序分离，实现打印测试结果，可编写通用测试代码！ 1、Junit JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试。 使用JUnit编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。 JUnit目前最新版本是5。 2、步骤： 首先在src同级下建立test目录 设置为测试专用文件夹，右键test目录找到Mark Directory as 选择子选项的Test Sources Root 回到src，找到需要测试的方法，右键选择Go To的子选项Test，出现的选项中点击Creat new Test 后面用到的Junit等相关库，Idea会自动去导包，并加入classpath! 写好主程序和测试程序后，去测试程序运行即可： 3、编写举例 核心测试方法testFact()加上了@Test注解，这是JUnit要求的，它会把带有@Test的方法识别为测试方法。 习惯上将Test文件的名字命名为需测试类名+Test.java： eg：主程序：Factory.java 测试程序：FactoryTest.java 以计算阶乘的方法为例： 测试成功情况：Factory： 1234567891011package com.org;public class Factory { public static long fact(long n) { long r = 1; for (long i = 1; i &lt;= n; i++) { r = r * i; } return r; }} FactoryTest： 1234567891011121314151617package com.org;import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.*;public class FactoryTest { @Test void fact() { assertEquals(1, Factory.fact(1)); assertEquals(2, Factory.fact(2)); assertEquals(6, Factory.fact(3)); assertEquals(3628800, Factory.fact(10)); assertEquals(2432902008176640000L, Factory.fact(20)); }} 没有问题不会输出东西： 1Process finished with exit code 0 测试失败情况： 将测试程序认为改一下： assertEquals(1, Factory.fact(1)) -&gt; assertEquals(2, Factory.fact(1))： 输出结果： 会显示不一致的地方： 123456789org.opentest4j.AssertionFailedError: Expected :2Actual :1&lt;Click to see difference&gt; at org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:55) at org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:195) at ..... 浮点数的处理 由于浮点数运算会有误差，所以需要设置一个误差值来限定： 使用assertEquals()的重载方法，第三个参数指定误差范围即可： 1234567891011121314151617package com.org;import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.*;public class Double01Test { @Test void calc() { //assertEquals(0.1, Math.abs(1 - 9 / 10.0)); // 0.09999999999999998 assertEquals(0.1, Math.abs(1 - 9 / 10.0), 0.000001); assertEquals(0.2, Math.abs(1 - 8 / 10.0), 0.000001); //assertEquals(0.1, Math.abs(1 - 0.9)); // 0.09999999999999998 assertEquals(0.1, Math.abs(1 - 0.9), 0.0000001); }} 4、Assertion（断言） 在测试方法内部，我们用assertEquals(1, Factorial.fact(1))表示，期望Factorial.fact(1)返回1。assertEquals(expected, actual)是最常用的测试方法，它在Assertion类中定义。 在异常处理一节第六点提到过断言，点击这里！ Assertion还定义了其他断言方法，例如： assertTrue(): 期待结果为true assertFalse(): 期待结果为false assertNotNull(): 期待结果为非null assertArrayEquals(): 期待结果为数组并与期望数组每个元素的值均相等 … 5、单元测试总结 单元测试可以确保单个方法按照正确预期运行，如果修改了某个方法的代码，只需确保其对应的单元测试通过，即可认为改动正确。此外，测试代码本身就可以作为示例代码，用来演示如何调用该方法。 使用JUnit进行单元测试，我们可以使用断言（Assertion）来测试期望结果，可以方便地组织和运行测试，并方便地查看测试结果。此外，JUnit既可以直接在IDE中运行，也可以方便地集成到Maven这些自动化工具中运行。 在编写单元测试的时候，我们要遵循一定的规范： 一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试； 二是每个单元测试应当互相独立，不依赖运行的顺序； 三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为0，null，空字符串\"\"等情况。 二、使用Fixture 在一个单元测试中，我们经常编写多个@Test方法，来分组、分类对目标代码进行测试。 在测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个@Test方法都写一遍这样的重复代码，显然比较麻烦。 JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。 1、@BeforeEach 和 @AfterEach 在CalculatorTest测试中，有两个标记为@BeforeEach和@AfterEach的方法，它们会在运行每个@Test方法前后自动运行： 通过@BeforeEach来初始化，通过@AfterEach来清理资源： 试了一下，不用Fixture，也可以正常测试成功，所以我觉得Java默认是有这两个方法在每个test方法前后去执行的，不过自己加上更加明显，修改之类的都可以更加方便，所以还是自己写上为好：（Idea可以在go to 后直接选择添加，并不需要手写：） 举一个例子： Calculator类： 123456789101112131415package com.org;public class Calculator { private long n = 0; public long add(long x) { n = n + x; return n; } public long sub(long x) { n = n - x; return n; }} CalculatorTest类： 123456789101112131415161718192021222324252627282930313233343536package com.org;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import static org.junit.jupiter.api.Assertions.*;public class CalculatorTest { Calculator calculator; @BeforeEach void setUp() { this.calculator = new Calculator(); } @AfterEach void tearDown() { this.calculator = null; } @Test void add() { assertEquals(100, this.calculator.add(100)); assertEquals(150, this.calculator.add(50)); assertEquals(130, this.calculator.add(-20)); } @Test void sub() { assertEquals(-100, this.calculator.sub(100)); assertEquals(-150, this.calculator.sub(50)); assertEquals(-130, this.calculator.sub(-20)); }} 2、@BeforeAll 和 @AfterAll 它们在运行所有@Test前后运行： 因为@BeforeAll和@AfterAll在所有@Test方法运行前后仅运行一次，因此，它们只能初始化静态方法的静态变量： 有一些资源初始化和清理可能更加繁琐，而且会耗费较长的时间：（例如初始化数据库） 一般不会用到这两个！ 不举例子了，点击这里： 3、小结 大多数情况下，使用@BeforeEach和@AfterEach就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到@BeforeAll和@AfterAll。 注意到每次运行一个@Test方法前，JUnit首先创建一个XxxTest实例，因此，每个@Test方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个@Test方法带到另一个@Test方法。 这样说来就解释了第一点不使用Fixture仍然可以测试成功的原因： 对于实例变量，在@BeforeEach中初始化，在@AfterEach中清理，它们在各个@Test方法中互不影响，因为是不同的实例； 对于静态变量，在@BeforeAll中初始化，在@AfterAll中清理，它们在各个@Test方法中均是唯一实例，会影响各个@Test方法。 三、异常测试 在Java程序中，异常处理是非常重要的。 我们自己编写的方法，也经常抛出各种异常。对于可能抛出的异常进行测试，本身就是测试的重要环节。 因此，在编写JUnit测试的时候，除了正常的输入输出，我们还要特别针对可能导致异常的情况进行测试： 还是以Factory()方法举例： Factory类： 在方法入口，我们增加了对参数n的检查，如果为负数，则直接抛出IllegalArgumentException。 1234567891011121314package com.org;public class Factory { public static long fact(long n) { if(n &lt; 0){ throw new IllegalArgumentException(); } long r = 1; for (long i = 1; i &lt;= n; i++) { r = r * i; } return r; }} FactoryTest类： 我们希望对异常进行测试。在JUnit测试中，我们可以编写一个@Test方法专门测试异常testNegative()方法： JUnit提供assertThrows()来期望捕获一个指定的异常。第二个参数Executable封装了我们要执行的会产生异常的代码。当我们执行Factorial.fact(-1)时，必定抛出IllegalArgumentException。assertThrows()在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。 编写一个Executable的匿名类实在是太繁琐了。实际上，Java 8开始引入了函数式编程，所有单方法接口都可以简写如下testNegative1()方法： 1234567891011121314151617181920212223242526272829303132333435package com.org;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.function.Executable;import static org.junit.jupiter.api.Assertions.*;public class FactoryTest { @Test void fact() { assertEquals(1, Factory.fact(1)); assertEquals(2, Factory.fact(2)); assertEquals(6, Factory.fact(3)); assertEquals(3628800, Factory.fact(10)); assertEquals(2432902008176640000L, Factory.fact(20)); } // 普通写法： @Test void testNegative(){ assertThrows(IllegalArgumentException.class, new Executable() { @Override public void execute() throws Throwable { Factory.fact(-1); } }); } // 使用函数式编程简化： @Test void testNegative1(){ assertThrows(IllegalArgumentException.class, ()-&gt;{Factory.fact(-1);}); }} 四、条件测试 简单来说就是控制@test在什么条件下才执行： 在@test后面再加一些条件注解： 一些常用的条件注解： @Disabled(“bug-101”)：此测试不会执行，括号参数可选，为输出提示信息。 @EnabledOnOs(OS.WINDOWS)：在什么系统测试。 @DisabledOnOs(OS.WINDOWS)：不在什么系统测试。 @DisabledOnJre(JRE.JAVA_8)：不在Java8test。 @EnabledIfSystemProperty(named = “os.arch”, matches = “.64.“)：只能在六十四位系统测试。 @EnabledIfEnvironmentVariable(named = “DEBUG”, matches = “true”)：需要传入环境变量DEBUG=true才能执行的测试，即控制台里面传入该参数才可以。 @EnabledIf(“java.time.LocalDate.now().getDayOfWeek()==java.time.DayOfWeek.SUNDAY”)：万能判断语句，当前是星期日才会执行测试。 万能的@EnableIf可以执行任意Java语句并根据返回的boolean决定是否执行测试。 Config类： 1234567891011121314package com.org;public class Config { public String getConfigFile(String filename) { String os = System.getProperty(\"os.name\").toLowerCase(); if (os.contains(\"win\")) { return \"C:\\\\\" + filename; } if (os.contains(\"mac\") || os.contains(\"linux\") || os.contains(\"unix\")) { return \"/usr/local/\" + filename; } throw new UnsupportedOperationException(); }} ConfigTest类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.org;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.condition.*;import static org.junit.jupiter.api.Assertions.assertEquals;public class ConfigTest { Config config; @BeforeEach public void setUp() { this.config = new Config(); } @Test @EnabledOnOs(OS.WINDOWS) void testWindows() { assertEquals(\"C:\\\\test.ini\", config.getConfigFile(\"test.ini\")); } @Test @EnabledOnOs({ OS.LINUX, OS.MAC }) void testLinuxAndMac() { assertEquals(\"/usr/local/test.cfg\", config.getConfigFile(\"test.cfg\")); } @Test @Disabled(\"bug-101\") void testBug101() { // TODO: this test is disabled for bug fixing } @Test @DisabledOnOs(OS.WINDOWS) void testOnNonWindowsOs() { // TODO: this test is disabled on windows } @Test @DisabledOnJre(JRE.JAVA_8) void testOnJava9OrAbove() { // TODO: this test is disabled on java 8 } @Test @EnabledIfSystemProperty(named = \"os.arch\", matches = \".*64.*\") void testOnlyOn64bitSystem() { // TODO: this test is only run on 64 bit system } @Test @EnabledIfEnvironmentVariable(named = \"DEBUG\", matches = \"true\") void testOnlyOnDebugMode() { // TODO: this test is only run on DEBUG=true } @Test @EnabledIf(\"java.time.LocalDate.now().getDayOfWeek()==java.time.DayOfWeek.SUNDAY\") void testOnlyOnSunday() { // TODO: this test is only run on Sunday }} 测试输出结果及提示信息： 1234567891011Environment variable [DEBUG] does not existWarning: Nashorn engine is planned to be removed from a future JDK releaseScript `java.time.LocalDate.now().getDayOfWeek()==java.time.DayOfWeek.SUNDAY` evaluated to: falsebug-101Disabled on operating system: Windows 10Disabled on operating system: Windows 10 五、参数化测试 如果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法 参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。 JUnit提供了一个@ParameterizedTest注解，用来进行参数化测试。 与之前的测试不同，不再使用@test了！ 以下方例子进行测试：将字符串转化为第一个字母大写，后面小写的形式： 12345678910package com.org;public class ArgumentsN { public static String capitalize(String s) { if (s.length() == 0) { return s; } return Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase(); }} 1、使用@MethodSource 编写一个同名的静态方法来提供测试参数： 返回一个List&lt;Arguments&gt;，方法内使用Arguments.arguments()方法，指定输入和输出参数。 如果静态方法和测试方法的名称不同，@MethodSource也允许指定方法名。但使用默认同名方法最方便。 12345678910111213141516171819202122232425262728293031323334353637383940package com.org;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.Arguments;import org.junit.jupiter.params.provider.CsvFileSource;import org.junit.jupiter.params.provider.MethodSource;import java.util.List;import static org.junit.jupiter.api.Assertions.assertEquals;public class ArgumentsNTest { @ParameterizedTest @MethodSource void testCapitalize(String input, String result) { assertEquals(result, ArgumentsN.capitalize(input)); } static List&lt;Arguments&gt; testCapitalize() { return List.of( // arguments: Arguments.arguments(\"abc\", \"Abc\"), // Arguments.arguments(\"APPLE\", \"Apple\"), // Arguments.arguments(\"gooD\", \"Good\")); } // 静态方法名字不一致时：指定静态方法名：（一般不这样写） @ParameterizedTest @MethodSource(\"testCapitalize1\") void testCapitalize(String input, String result) { assertEquals(result, ArgumentsN.capitalize(input)); } static List&lt;Arguments&gt; testCapitalize1() { return List.of( // arguments: Arguments.arguments(\"abc\", \"Abc\"), // Arguments.arguments(\"APPLE\", \"Apple\"), // Arguments.arguments(\"gooD\", \"Good\")); }} 2、使用@CsvSource 它的每一个字符串表示一行，一行包含的若干参数用,分隔，如下： 12345678910111213141516171819package com.org;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.Arguments;import org.junit.jupiter.params.provider.CsvFileSource;import org.junit.jupiter.params.provider.MethodSource;import java.util.List;import static org.junit.jupiter.api.Assertions.assertEquals;public class ArgumentsNTest { @ParameterizedTest @CsvSource({ \"abc, Abc\", \"APPLE, Apple\", \"gooD, Good\" }) void testCapitalize(String input, String result) { assertEquals(result, ArgumentsN.capitalize(input)); }} 3、使用@CsvFileSource 如果有成百上千的测试输入，那么，直接写@CsvSource就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上@CsvFileSource：(使用参数指定csv的路径名) JUnit只在classpath中查找指定的CSV文件，因此，test-capitalize.csv这个文件要放到test目录下：（Idea可以写好路径，快捷进行创建文件：） CSV文件的内容：（逗号分隔，一行一个） 1234apple, AppleHELLO, HelloJUnit, JunitreSource, Resource 12345678910111213141516171819package com.org;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.Arguments;import org.junit.jupiter.params.provider.CsvFileSource;import org.junit.jupiter.params.provider.MethodSource;import java.util.List;import static org.junit.jupiter.api.Assertions.assertEquals;public class ArgumentsNTest { @ParameterizedTest @CsvFileSource(resources = { \"/test-capitalize.csv\" }) void testCapitalizeUsingCsvFile(String input, String result) { assertEquals(result, ArgumentsN.capitalize(input)); }} 单元测试一节已然完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JUnit","slug":"JUnit","permalink":"https://www.itnxd.cn/tags/JUnit/"}],"author":"Mr.Niu"},{"title":"Java教程系列之日期与时间","slug":"Java教程系列之日期与时间","date":"2020-04-13T08:26:06.000Z","updated":"2021-02-06T14:14:53.349Z","comments":true,"path":"posts/51490.html","link":"","permalink":"https://www.itnxd.cn/posts/51490.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、一些概念1、本地时间 当我们说当前时刻是2019年11月20日早上8:15的时候，我们说的实际上是本地时间。在国内就是北京时间。在这个时刻，如果地球上不同地方的人们同时看一眼手表，他们各自的本地时间是不同的！ 所以，不同的时区，在同一时刻，本地时间是不同的。全球一共分为24个时区，伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区！ eg：2020-1-1 20:21:59 2、时区 光靠本地时间还无法唯一确定一个准确的时刻，所以我们还需要给本地时间加上一个时区： 以GMT或者UTC加时区偏移表示，例如：GMT+08:00或者UTC+08:00表示东八区。（GMT和UTC可以认为基本是等价的，只是UTC使用更精确的原子钟计时，每隔几年会有一个闰秒，我们在开发程序的时候可以忽略两者的误差，因为计算机的时钟在联网的时候会自动与时间服务器同步时间。） 另一种是缩写，例如，CST表示China Standard Time，也就是中国标准时间。但是CST也可以表示美国中部时间Central Standard Time USA，因此，缩写容易产生混淆，我们尽量不要使用缩写。 最后一种是以洲／城市表示，例如，Asia/Shanghai，表示上海所在地的时区。特别注意城市名称不是任意的城市，而是由国际标准组织规定的城市。 3、夏令时 所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。我们国家实行过一段时间夏令时，1992年就废除了，但是矫情的美国人到现在还在使用，所以时间换算更加复杂。 实行夏令时的不同地区，进入和退出夏令时的时间很可能是不同的。同一个地区，根据历史上是否实行过夏令时，标准时间在不同年份换算成当地时间也是不同的。因此，计算夏令时，没有统一的公式，必须按照一组给定的规则来算，并且，该规则要定期更新。 计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。 时区 2019-11-20 2019-6-20 GMT-05:00 19:00 19:00 UTC-05:00 19:00 19:00 America/New_York 19:00 20:00 4、本地化 在计算机中，通常使用Locale表示一个国家或地区的日期、时间、数字、货币等格式。Locale由语言_国家的字母缩写构成，例如，zh_CN表示中文+中国，en_US表示英文+美国。语言使用小写，国家使用大写。 计算机用Locale在日期、时间、货币和字符串之间进行转换！ 对于日期来说，不同的Locale，例如，中国和美国的表示方式如下： zh_CN：2016-11-30 en_US：11/30/2016 二、Date和Calendar1、Epoch Time Epoch Time是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数！ Epoch Time又称为时间戳！ 1231574208900 = 北京时间2019-11-20 8:15:00 = 伦敦时间2019-11-20 0:15:00 = 纽约时间2019-11-19 19:15:00 因此，在计算机中，只需要存储一个整数1574208900表示某一时刻。当需要显示为某一地区的当地时间时，我们就把它格式化为一个字符串 时间戳在不同的编程语言中，会有几种存储方式： 以秒为单位的整数：1574208900，缺点是精度只能到秒； 以毫秒为单位的整数：1574208900123，最后3位表示毫秒数； 以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。 它们之间转换非常简单。而在Java程序中，时间戳通常是用long表示的毫秒数 1long t = 1574208900123L; 转换成北京时间就是2019-11-20T8:15:00.123。要获取当前时间戳，可以使用System.currentTimeMillis()，这是Java程序获取时间戳最常用的方法。 2、标准库APIJava标准库有两套处理日期和时间的API： 一套定义在java.util这个包里面，主要包括Date、Calendar和TimeZone这几个类； 一套新的API是在Java 8引入的，定义在java.time这个包里面，主要包括LocalDateTime、ZonedDateTime、ZoneId等。 为什么会有新旧两套API呢？因为历史遗留原因，旧的API存在很多问题，所以引入了新的API。 那么我们能不能跳过旧的API直接用新的API呢？如果涉及到遗留代码就不行，因为很多遗留代码仍然使用旧的API，所以目前仍然需要对旧的API有一定了解，很多时候还需要在新旧两种对象之间进行转换。 3、Date Date对象有几个严重的问题：它不能转换时区，除了toGMTString()可以按GMT+0:00输出外，Date总是以当前计算机系统的默认时区为基础进行输出。此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。 java.util.Date是用于表示一个日期和时间的对象，注意与java.sql.Date区分，后者用在数据库中。如果观察Date的源码，可以发现它实际上存储了一个long类型的以毫秒表示的时间戳： 123456public class Date implements Serializable, Cloneable, Comparable&lt;Date&gt; { private transient long fastTime; ...} 常用方法： 注意getYear()返回的年份必须加上1900，getMonth()返回的月份是011分别表示112月，所以要加1，而getDate()返回的日期范围是1~31，又不能加1。 1234567891011121314151617181920212223package com.learn.file;import java.util.Date;public class DateTest { public static void main(String[] args) { // 获取当前时间戳： long time = System.currentTimeMillis(); System.out.println(time); // 1586770437800 最后三位表示毫秒数，即0.xxx秒 // 获取当前时间: Date date = new Date(); System.out.println(date.getYear() + 1900); // 必须加上1900 System.out.println(date.getMonth() + 1); // 0~11，必须加上1 System.out.println(date.getDate()); // 1~31，不能加1 // 转换为String: 输出为CST格式（即China Standard Time缩写） System.out.println(date.toString()); // Mon Apr 13 17:43:12 CST 2020 // 转换为GMT时区: System.out.println(date.toGMTString()); // 13 Apr 2020 09:43:12 GMT // 转换为本地时区: System.out.println(date.toLocaleString()); // 2020年4月13日 下午5:43:12 }} 使用SimpleDateFormat进行格式化有如下格式： yyyy：年 MM：月 dd: 日 HH: 小时 mm: 分钟 ss: 秒 E: 周几 123456789101112package com.learn.file;import java.text.SimpleDateFormat;import java.util.Date;public class DateTest { public static void main(String[] args) { Date date1 = new Date(); var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(sdf.format(date1)); // 2020-04-13 17:48:42 }} Java的格式化预定义了许多不同的格式，我们以MMM和E为例： M：输出9 MM：输出09 MMM：输出Sep MMMM：输出September 12345678910111213141516171819package com.learn.file;import java.text.SimpleDateFormat;import java.util.Date;public class DateTest { public static void main(String[] args) { Date date2 = new Date(); var sdf2 = new SimpleDateFormat(\"E M dd, yyyy\"); var sdf3 = new SimpleDateFormat(\"E MM dd, yyyy\"); var sdf4 = new SimpleDateFormat(\"E MMM dd, yyyy\"); var sdf5 = new SimpleDateFormat(\"E MMMM dd, yyyy\"); System.out.println(sdf2.format(date2)); //周一 4 13, 2020 System.out.println(sdf3.format(date2)); //周一 04 13, 2020 System.out.println(sdf4.format(date2)); //周一 4月 13, 2020 System.out.println(sdf5.format(date2)); //周一 四月 13, 2020 }} 4、Calendar Calendar可以用于获取并设置年、月、日、时、分、秒，它和Date比，主要多了一个可以做简单的日期和时间运算的功能。 Calendar获取年月日这些信息变成了get(int field)，返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，1~7分别表示周日，周一，……，周六。 Calendar只有一种方式获取，即Calendar.getInstance()： 1234567891011121314151617181920package com.learn.file;import java.util.Calendar;public class CalendarTest { public static void main(String[] args) { // 获取当前时间: Calendar c = Calendar.getInstance(); int y = c.get(Calendar.YEAR); int m = 1 + c.get(Calendar.MONTH); int d = c.get(Calendar.DAY_OF_MONTH); int w = c.get(Calendar.DAY_OF_WEEK); int hh = c.get(Calendar.HOUR_OF_DAY); int mm = c.get(Calendar.MINUTE); int ss = c.get(Calendar.SECOND); int ms = c.get(Calendar.MILLISECOND); System.out.println(y + \"-\" + m + \"-\" + d + \" \" + w + \" \" + hh + \":\" + mm + \":\" + ss + \".\" + ms); // 2020-4-13 2 18:1:7.601 }} 设置成特定的一个日期和时间 必须先清除所有字段： 利用Calendar.getTime()可以将一个Calendar对象转换成Date对象，然后就可以用SimpleDateFormat进行格式化了。 1234567891011121314151617181920212223242526package com.learn.file;import java.text.SimpleDateFormat;import java.util.Calendar;public class CalendarTest { public static void main(String[] args) { // 获取当前时间: Calendar c = Calendar.getInstance(); // 清除所有: c.clear(); // 设置2020年: c.set(Calendar.YEAR, 2020); // 设置4月:注意3表示4月: c.set(Calendar.MONTH, 3); // 设置2日: c.set(Calendar.DATE, 13); // 设置时间: c.set(Calendar.HOUR_OF_DAY, 18); c.set(Calendar.MINUTE, 20); c.set(Calendar.SECOND, 23); // 使用getTime转化为Date对象，再使用SimpleDateFormat格式化输出： System.out.println(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(c.getTime())); // 2019-09-02 21:22:23 }} 5、TimeZone Calendar和Date相比，它提供了时区转换的功能。时区用TimeZone对象表示 1234567891011121314package com.learn.file;import java.util.TimeZone;public class TimeZoneTest { public static void main(String[] args) { TimeZone tzDefault = TimeZone.getDefault(); // 当前时区 TimeZone tzGMT9 = TimeZone.getTimeZone(\"GMT+09:00\"); // GMT+9:00时区 TimeZone tzNY = TimeZone.getTimeZone(\"America/New_York\"); // 纽约时区 System.out.println(tzDefault.getID()); // Asia/Shanghai System.out.println(tzGMT9.getID()); // GMT+09:00 System.out.println(tzNY.getID()); // America/New_York }} 时区的唯一标识是以字符串表示的ID，我们获取指定TimeZone对象也是以这个ID为参数获取，GMT+09:00、Asia/Shanghai都是有效的时区ID。 可使用TimeZone.getAvailableIDs()方法来列出系统支持的所有时区ID： 1System.out.println(Arrays.toString(TimeZone.getAvailableIDs())); 对指定时间进行转换利用Calendar进行时区转换的步骤是： 清除所有字段； 设定指定时区； 设定日期和时间； 创建SimpleDateFormat并设定目标时区； 格式化获取的Date对象（注意Date对象无时区信息，时区信息存储在SimpleDateFormat中）。 本质上时区转换只能通过SimpleDateFormat在显示的时候完成 将北京时间转换为纽约时间： 1234567891011121314151617181920212223242526272829package com.learn.file;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.TimeZone;public class TimeZoneTest { public static void main(String[] args) { // 当前时间: Calendar c = Calendar.getInstance(); // 清除所有: c.clear(); // 设置为北京时区: c.setTimeZone(TimeZone.getTimeZone(\"Asia/Shanghai\")); // 设置年月日时分秒: c.set(2020, 3 /* 4月 */, 13, 18, 15, 0); // 或者这样： c.set(2020, Calendar.APRIL /* 11月 */, 13, 18, 15, 0); // 显示时间: System.out.println(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(c.getTime())); // 2020-04-13 18:15:00 var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); sdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\")); System.out.println(sdf.format(c.getTime())); // 2020-04-13 06:15:00 }} 对日期和时间进行简单加减123456789101112131415161718192021222324package com.learn.file;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.TimeZone;public class TimeZoneTest { public static void main(String[] args) { // 当前时间: Calendar c1 = Calendar.getInstance(); // 清除所有: c1.clear(); // 设置年月日时分秒: c1.set(2020, 3 /* 4月 */, 13, 18, 15, 0); var sdf1 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(sdf1.format(c1.getTime())); // 2020-04-13 18:15:00 // 加5天并减去2小时: c1.add(Calendar.DAY_OF_MONTH, 5); c1.add(Calendar.HOUR_OF_DAY, -2); // 显示时间: System.out.println(sdf1.format(c1.getTime())); // 2020-04-18 16:15:00 }} 三、LocalDateTime 从Java 8开始，java.time包提供了新的日期和时间API： 和旧的API相比，新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便。 此外，新API修正了旧API不合理的常量设计： Month的范围用1~12表示1月到12月； Week的范围用1~7表示周一到周日。 最后，新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。 LocalDateTime无法与时间戳进行转换，因为LocalDateTime没有时区，无法确定某一时刻。后面我们要介绍的ZonedDateTime相当于LocalDateTime加时区的组合，它具有时区，可以与long表示的时间戳进行转换。 主要涉及的类型有： 本地日期和时间：LocalDateTime，LocalDate，LocalTime； 带时区的日期和时间：ZonedDateTime； 时刻：Instant； 时区：ZoneId，ZoneOffset； 时间间隔：Duration。 以及一套新的用于取代SimpleDateFormat的格式化类型DateTimeFormatter。 1、LocalDateTime 本地日期和时间通过now()获取到的总是以当前默认时区返回的，和旧API不同，LocalDateTime、LocalDate和LocalTime默认严格按照ISO 8601规定的日期和时间格式进行打印。 LocalTime的精度是纳秒！ 12345678910111213141516package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;public class LocalDateTimeTest { public static void main(String[] args) { LocalDate d = LocalDate.now(); // 当前日期 LocalTime t = LocalTime.now(); // 当前时间 LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间 System.out.println(d); // 严格按照ISO 8601格式打印 2020-04-13 System.out.println(t); // 严格按照ISO 8601格式打印 19:34:03.468952 System.out.println(dt); // 严格按照ISO 8601格式打印 2020-04-13T19:34:03.468952 }} LocalDate和LocalTime与LocalDateTime互转 下面代码其实有一个小问题，在获取3个类型的时候，由于执行一行代码总会消耗一点时间，因此，3个类型的日期和时间很可能对不上（时间的毫秒数基本上不同）。为了保证获取到同一时刻的日期和时间，可以改写如下： 123456789101112131415161718192021package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;public class LocalDateTimeTest { public static void main(String[] args) { // LocalDateTime -&gt; LocalDate/LocalTime LocalDateTime dt1 = LocalDateTime.now(); // 当前日期和时间 LocalDate d1 = dt1.toLocalDate(); // 转换到当前日期 LocalTime t1 = dt1.toLocalTime(); // 转换到当前时间 // // LocalDate/LocalTime -&gt; LocalDateTime // 指定日期和时间: LocalDate d2 = LocalDate.of(2019, 11, 30); // 2019-11-30, 注意11=11月 LocalTime t2 = LocalTime.of(15, 16, 17); // 15:16:17 LocalDateTime dt2 = LocalDateTime.of(2019, 11, 30, 15, 16, 17); LocalDateTime dt3 = LocalDateTime.of(d2, t2); }} 字符串转换为LocalDateTime12345678910111213package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;public class LocalDateTimeTest { public static void main(String[] args) { LocalDateTime dt4 = LocalDateTime.parse(\"2019-11-19T15:16:17\"); LocalDate d4 = LocalDate.parse(\"2019-11-19\"); LocalTime t4 = LocalTime.parse(\"15:16:17\"); }} 日期和时间之间的 ‘T’注意ISO 8601规定的日期和时间分隔符是T。标准格式如下： 日期：yyyy-MM-dd 时间：HH:mm:ss 带毫秒的时间：HH:mm:ss.SSS 日期和时间：yyyy-MM-dd’T’HH:mm:ss 带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS 2、DateTimeFormatter 自定义输出的格式，或者要把一个非ISO 8601格式的字符串解析成LocalDateTime： 123456789101112131415161718package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;public class LocalDateTimeTest { public static void main(String[] args) { // 自定义格式化: DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\"); System.out.println(dtf.format(LocalDateTime.now())); // 用自定义格式解析: LocalDateTime dt5 = LocalDateTime.parse(\"2019/11/30 15:16:17\", dtf); System.out.println(dt5); // 2019-11-30T15:16:17 }} 3、对日期和时间进行简单加减 注意到月份加减会自动调整日期，例如从2019-10-31减去1个月得到的结果是2019-09-30，因为9月没有31日： 12345678910111213141516171819package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;public class LocalDateTimeTest { public static void main(String[] args) { LocalDateTime dt6 = LocalDateTime.of(2019, 10, 26, 20, 30, 59); System.out.println(dt6); // 2019-10-26T20:30:59 // 加5天减3小时: LocalDateTime dt7 = dt6.plusDays(5).minusHours(3); System.out.println(dt7); // 2019-10-31T17:30:59 // 减1月: LocalDateTime dt8 = dt7.minusMonths(1); System.out.println(dt8); // 2019-09-30T17:30:59 }} 4、对日期和时间进行调整常用方法： 调整年：withYear() 调整月：withMonth() 调整日：withDayOfMonth() 调整时：withHour() 调整分：withMinute() 调整秒：withSecond() 同样注意到调整月份时，会相应地调整日期，即把2019-10-31的月份调整为9时，日期也自动变为30。 12345678910111213141516171819package com.learn.file;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;public class LocalDateTimeTest { public static void main(String[] args) { LocalDateTime dt9 = LocalDateTime.of(2019, 10, 26, 20, 30, 59); System.out.println(dt9); // 2019-10-26T20:30:59 // 日期变为31日: LocalDateTime dt10 = dt9.withDayOfMonth(31); System.out.println(dt2); // 2019-10-31T20:30:59 // 月份变为9: LocalDateTime dt11 = dt10.withMonth(9); System.out.println(dt11); // 2019-09-30T20:30:59 }} 5、使用with()方法做更复杂的运算 对于计算某个月第1个周日这样的问题，新的API可以轻松完成。 基本就是first和last的组合吧！ 1234567891011121314151617181920212223242526package com.learn.file;import java.time.DayOfWeek;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.temporal.TemporalAdjusters;public class LocalTest { public static void main(String[] args) { // 本月第一天0:00时刻: LocalDateTime firstDay = LocalDate.now().withDayOfMonth(1).atStartOfDay(); System.out.println(firstDay); // 2020-04-01T00:00 // 本月最后1天: LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth()); System.out.println(lastDay); // 2020-04-30 // 下月第1天: LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth()); System.out.println(nextMonthFirstDay); // 2020-05-01 // 本月第1个周一: LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)); System.out.println(firstWeekday); // 2020-04-06 }} 6、判断时间先后 要判断两个LocalDateTime的先后，可以使用isBefore()、isAfter()方法，对于LocalDate和LocalTime类似： 1234567891011121314151617package com.learn.file;import java.time.DayOfWeek;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.temporal.TemporalAdjusters;public class LocalTest { public static void main(String[] args) { LocalDateTime now = LocalDateTime.now(); LocalDateTime target = LocalDateTime.of(2019, 11, 19, 8, 15, 0); System.out.println(now.isBefore(target)); // false System.out.println(LocalDate.now().isBefore(LocalDate.of(2019, 11, 19))); // false System.out.println(LocalTime.now().isAfter(LocalTime.parse(\"08:15:00\"))); // true }} 6、Duration和Period Duration表示两个时刻之间的时间间隔。 另一个类似的Period表示两个日期之间的天数： Duration和Period的表示方法也符合ISO 8601的格式，它以P...T...的形式表示，P...T之间表示日期间隔，T后面表示时间间隔。如果是PT...的格式表示仅有时间间隔： 123456789101112131415161718package com.learn;import java.time.Duration;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.Period;public class DurationAndPeriod { public static void main(String[] args) { LocalDateTime start = LocalDateTime.of(2019, 11, 19, 8, 15, 0); LocalDateTime end = LocalDateTime.of(2020, 1, 9, 19, 25, 30); Duration d = Duration.between(start, end); System.out.println(d); // PT1235H10M30S 表示1235小时10分钟30秒 Period p = LocalDate.of(2019, 11, 19).until(LocalDate.of(2020, 1, 9)); System.out.println(p); // P1M21D 表示1个月21天 }} 利用ofXxx()或者parse()方法也可以直接创建Duration： 1234567891011121314package com.learn;import java.time.Duration;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.Period;public class DurationAndPeriod { public static void main(String[] args) { Duration d1 = Duration.ofHours(10); // 10 hours Duration d2 = Duration.parse(\"P1DT2H3M\"); // 1 day, 2 hours, 3 minutes }} 四、ZonedDateTime LocalDateTime总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要ZonedDateTime。 可以简单地把ZonedDateTime理解成LocalDateTime加ZoneId。ZoneId是java.time引入的新的时区类，注意和旧的java.util.TimeZone区别。 1、创建ZonedDateTime对象1.1 一种是通过now()方法返回当前时间： 下面时区不同，但表示的时间都是同一时刻（毫秒数不同是执行语句时的时间差）： 时间相不同，时区不同，时刻相同： 12345678910111213package com.learn.file;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区 ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(\"America/New_York\")); // 用指定时区获取当前时间 System.out.println(zbj); // 2020-04-13T20:49:45.964482300+08:00[Asia/Shanghai] System.out.println(zny); // 2020-04-13T08:49:45.971487100-04:00[America/New_York] }} 1.2 通过给一个LocalDateTime附加一个ZoneId 以这种方式创建的ZonedDateTime，它的日期和时间与LocalDateTime相同，但附加的时区不同，因此是两个不同的时刻： 时间相同，时区不同，时刻不同： 123456789101112131415package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { LocalDateTime ldt = LocalDateTime.of(2019, 9, 15, 15, 16, 17); ZonedDateTime zbj1 = ldt.atZone(ZoneId.systemDefault()); ZonedDateTime zny1 = ldt.atZone(ZoneId.of(\"America/New_York\")); System.out.println(zbj1); // 2019-09-15T15:16:17+08:00[Asia/Shanghai] System.out.println(zny1); // 2019-09-15T15:16:17-04:00[America/New_York] }} 2、时区转换 通过withZoneSameInstant()将关联时区转换到另一个时区，转换后日期和时间都会相应调整： 时刻相同，时间改变，日期改变，时区改变： 12345678910111213141516package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { // 以中国时区获取当前时间: ZonedDateTime zbj2 = ZonedDateTime.now(ZoneId.of(\"Asia/Shanghai\")); // 转换为纽约时间: ZonedDateTime zny2 = zbj2.withZoneSameInstant(ZoneId.of(\"America/New_York\")); System.out.println(zbj2); // 2020-04-13T20:58:58.227352600+08:00[Asia/Shanghai] System.out.println(zny2); // 2020-04-13T08:58:58.227352600-04:00[America/New_York] }} 3、夏令时处理 时区转换的时候，由于夏令时的存在，不同的日期转换的结果很可能是不同的。 涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。 如下：有一个小时的夏令时时差： 123452019-09-15T21:05:50.187697+08:00[Asia/Shanghai]2019-09-15T09:05:50.187697-04:00[America/New_York]2019-11-15T21:05:50.187697+08:00[Asia/Shanghai]2019-11-15T08:05:50.187697-05:00[America/New_York] 使用ZonedDateTime处理 将一个未知时区转换为本地时间，转换为本地时间时，内部使用的就是ZonedDateTime的时区信息： 1234567891011121314package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(\"America/New_York\")); LocalDateTime ldt1 = zdt.toLocalDateTime(); System.out.println(zdt); // 2020-04-13T09:15:56.939055400-04:00[America/New_York] System.out.println(ldt1); // 2020-04-13T09:15:56.939055400 }} 4、对日期和时间进行简单加减 ZonedDateTime仍然提供了plusDays()等加减操作。 12345678910111213package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { ZonedDateTime zdt1 = ZonedDateTime.now(); System.out.println(zdt1); // 2020-04-13T21:21:24.013394800+08:00[Asia/Shanghai] System.out.println(zdt1.plusDays(5).minusHours(3)); // 2020-04-18T18:21:24.013394800+08:00[Asia/Shanghai] }} 5、一个时间转换例子 某航线从北京飞到纽约需要13小时20分钟，请根据北京起飞日期和时间计算到达纽约的当地日期和时间。 123456789101112131415161718192021222324252627282930313233343536package com.learn.file;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.ZonedDateTime;public class ZonedDateTimeTest { public static void main(String[] args) { // 一个例子： LocalDateTime departureAtBeijing = LocalDateTime.of(2019, 9, 15, 13, 0, 0); int hours = 13; int minutes = 20; LocalDateTime arrivalAtNewYork = calculateArrivalAtNY(departureAtBeijing, hours, minutes); System.out.println(departureAtBeijing + \" -&gt; \" + arrivalAtNewYork); // 2019-09-15T13:00 -&gt; 2019-09-15T14:20 // test: if (!LocalDateTime.of(2019, 10, 15, 14, 20, 0) .equals(calculateArrivalAtNY(LocalDateTime.of(2019, 10, 15, 13, 0, 0), 13, 20))) { System.err.println(\"测试失败!\"); } else if (!LocalDateTime.of(2019, 11, 15, 13, 20, 0) .equals(calculateArrivalAtNY(LocalDateTime.of(2019, 11, 15, 13, 0, 0), 13, 20))) { System.err.println(\"测试失败!\"); } } static LocalDateTime calculateArrivalAtNY(LocalDateTime bj, int h, int m) { // 加上用时后转化为不带时区的LocalDateTime： bj = bj.plusHours(h).plusMinutes(m); // lbj和lbj1都可以：将时区转化为上海 ZonedDateTime lbj = ZonedDateTime.of(bj, ZoneId.of(\"Asia/Shanghai\")); ZonedDateTime lbj1 = bj.atZone(ZoneId.of(\"Asia/Shanghai\")); // 将时区转化为纽约： ZonedDateTime zdt = lbj1.withZoneSameInstant(ZoneId.of(\"America/New_York\")); // 返回LocalDateTime类型的时间： return zdt.toLocalDateTime(); }} 五、DateTimeFormatter 使用旧的Date对象时，我们用SimpleDateFormat进行格式化显示。使用新的LocalDateTime或ZonedLocalDateTime时，我们要进行格式化显示，就要使用DateTimeFormatter。 和SimpleDateFormat不同的是，DateTimeFormatter不但是不变对象，它还是线程安全的（后面会学到！）。 因为SimpleDateFormat不是线程安全的，使用的时候，只能在方法内部创建新的局部变量。而DateTimeFormatter可以只创建一个实例，到处引用。 1、创建DateTimeFormatter 传入字符串 123456789101112package com.learn.file;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;public class DateTimeFormatterTest { public static void main(String[] args) { DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\"); ZonedDateTime zonedDateTime = ZonedDateTime.now(); System.out.println(formatter.format(zonedDateTime)); // 2020-04-13 22:25 }} 同时传入Local 12345678910111213package com.learn.file;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.util.Locale;public class DateTimeFormatterTest { public static void main(String[] args) { DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern(\"E,yyyy-MMMM-dd HH:mm\", Locale.US); ZonedDateTime zonedDateTime1 = ZonedDateTime.now(); System.out.println(formatter1.format(zonedDateTime1)); // Mon,2020-April-13 22:30 }} 2、一些格式化例子 分别以默认方式、中国地区和美国地区对当前时间进行显示： 12345678910111213141516171819package com.learn.file;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.util.Locale;public class DateTimeFormatterTest { public static void main(String[] args) { ZonedDateTime zdt = ZonedDateTime.now(); var formatter2 = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm ZZZZ\"); System.out.println(formatter2.format(zdt)); // 2020-04-13T22:32 GMT+08:00 var zhFormatter = DateTimeFormatter.ofPattern(\"yyyy MMM dd EE HH:mm\", Locale.CHINA); System.out.println(zhFormatter.format(zdt)); // 2020 4月 13 周一 22:32 var usFormatter = DateTimeFormatter.ofPattern(\"E, MMMM/dd/yyyy HH:mm\", Locale.US); System.out.println(usFormatter.format(zdt)); // Mon, April/13/2020 22:32 }} 当我们直接调用System.out.println()对一个ZonedDateTime或者LocalDateTime实例进行打印的时候，实际上，调用的是它们的toString()方法，默认的toString()方法显示的字符串就是按照ISO 8601格式显示的，我们可以通过DateTimeFormatter预定义的几个静态变量来引用： 123456789101112131415package com.learn.file;import java.time.LocalDateTime;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.util.Locale;public class DateTimeFormatterTest { public static void main(String[] args) { var ldt = LocalDateTime.now(); System.out.println(DateTimeFormatter.ISO_DATE.format(ldt)); // 2020-04-13 System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt)); // 2020-04-13T22:36:25.9843329 }} 六、Instant 计算机存储的当前时间，本质上只是一个不断递增的整数。Java提供的System.currentTimeMillis()返回的就是以毫秒表示的当前时间戳。 这个当前时间戳在java.time中以Instant类型表示，我们用Instant.now()获取当前时间戳： Instant内部只有两个核心字段： 一个是以秒为单位的时间戳， 一个是更精确的纳秒精度。 它和System.currentTimeMillis()返回的long相比，只是多了更高精度的纳秒。 1、Instant的创建 直接输出Instant默认是伦敦的标准时区，和我们东八区差半个小时： 1234567891011121314151617package com.learn.file;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;public class InstantTest { public static void main(String[] args) { System.out.println(System.currentTimeMillis()); // 1586855486387 Instant instant = Instant.now(); System.out.println(instant); // 2020-04-14T09:55:19.411338900Z // 按秒表示： System.out.println(instant.getEpochSecond()); // 1586855486 // 按毫秒表示： System.out.println(instant.toEpochMilli()); // 1586855486388 }} 2、Instant +ZonedId = ZonedDateTime 既然Instant就是时间戳，那么，给它附加上一个时区，就可以创建出ZonedDateTime： 对于某一个时间戳，给它关联上指定的ZoneId，就得到了ZonedDateTime，继而可以获得了对应时区的LocalDateTime。 1234567891011121314151617package com.learn.file;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;public class InstantTest { public static void main(String[] args) { // 以指定时间戳创建Instant: Instant ins = Instant.now(); Instant ins1 = Instant.ofEpochSecond(1586855486); ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault()); ZonedDateTime zdt1 = ins1.atZone(ZoneId.of(\"Asia/Shanghai\")); System.out.println(zdt); // 2020-04-14T17:13:51.251631400+08:00[Asia/Shanghai] System.out.println(zdt1); // 2020-04-14T17:11:26+08:00[Asia/Shanghai] }} 3、类之间的相互转换 long指的是以long表示的一个时间戳： 123456789101112┌─────────────┐│LocalDateTime│────┐└─────────────┘ │ ┌─────────────┐ ├───&gt;│ZonedDateTime│┌─────────────┐ │ └─────────────┘│ ZoneId │────┘ ▲└─────────────┘ ┌─────────┴─────────┐ │ │ ▼ ▼ ┌─────────────┐ ┌─────────────┐ │ Instant │&lt;───&gt;│ long │ └─────────────┘ └─────────────┘ 七、新旧API的互相转换 由于Java提供了新旧两套日期和时间的API，除非涉及到遗留代码，否则我们应该坚持使用新的API。 如果需要与遗留代码打交道，则需要在新旧API之间进行互相转换！ 处理日期和时间时，尽量使用新的java.time包； 1、旧API转新API 把旧式的Date或Calendar转换为新API对象，可以通过toInstant()方法转换为Instant对象，再继续转换为ZonedDateTime： Calendar -&gt; ZonedDateTime时：应该使用本身自带的时区信息，calendar.getTimeZone().toZoneId()，即将旧的TimeZone转化为新的ZoneId。或者可以直接使用atZone()来指定时区： 123456789101112131415161718192021222324252627package com.learn;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;import java.util.Calendar;import java.util.Date;public class NewOldAPI { public static void main(String[] args) { // Date -&gt; Instant：（无时区） System.out.println(new Date()); // Tue Apr 14 18:12:07 CST 2020 Instant instant = new Date().toInstant(); System.out.println(instant); // Calendar -&gt; Instant -&gt; ZonedDateTime Calendar calendar = Calendar.getInstance(); Instant instant1 = calendar.toInstant(); ZonedDateTime zonedDateTime = instant1.atZone(ZoneId.systemDefault()); System.out.println(zonedDateTime); // 2020-04-14T18:19:18.108+08:00[Asia/Shanghai] ZonedDateTime zdt = instant1.atZone(calendar.getTimeZone().toZoneId()); System.out.println(zdt); // 2020-04-14T18:19:18.108+08:00[Asia/Shanghai] System.out.println(calendar.getTimeZone().toZoneId()); // Asia/Shanghai }} 2、新API转旧API 把新的ZonedDateTime转换为旧的API对象，只能借助long型时间戳做一个“中转”： 使用ZonedDateTime.toEpochSecond()方法，获得时间戳的秒数，乘以1000获得毫秒数，然后用Date创建即可：（Date接收的参数为毫秒，不是秒！） 123456789101112131415161718192021222324252627282930313233343536package com.learn;import java.text.SimpleDateFormat;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;import java.util.Calendar;import java.util.Date;import java.util.TimeZone;public class NewOldAPI { public static void main(String[] args) { // ZonedDateTime -&gt; long -&gt; Date ZonedDateTime zonedDateTime1 = ZonedDateTime.now(); long l = zonedDateTime1.toEpochSecond() * 1000; Date date = new Date(l); System.out.println(date); // Tue Apr 14 18:35:52 CST 2020 // ZonedDateTime -&gt; long -&gt; Calendar: ZonedDateTime zonedDateTime2 = ZonedDateTime.now(); // 创建Calender： Calendar calendar1 = Calendar.getInstance(); // 清空： calendar1.clear(); //设置时区TimeZone: (两者都可) calendar1.setTimeZone(TimeZone.getTimeZone(zonedDateTime2.getZone())); calendar1.setTimeZone(TimeZone.getTimeZone(zonedDateTime2.getZone().getId())); System.out.println(zonedDateTime2.getZone()); // Asia/Shanghai System.out.println(zonedDateTime2.getZone().getId()); // Asia/Shanghai // 设置时间戳：（传入毫秒，需要将秒*1000） calendar1.setTimeInMillis(zonedDateTime2.toEpochSecond() * 1000); // 将Calender转化为Date再使用SimpleDateFormat进行格式化： System.out.println(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(calendar1.getTime())); // 2020-04-14 18:45:59 }} 3、数据库中存储日期时间 除了旧式的java.util.Date，我们还可以找到另一个java.sql.Date，它继承自java.util.Date，但会自动忽略所有时间相关信息。这个奇葩的设计原因要追溯到数据库的日期与时间类型。 在数据库中，我们需要存储的最常用的是时刻（Instant），因为有了时刻信息，就可以根据用户自己选择的时区，显示出正确的本地时间。所以，最好的方法是直接用长整数long表示，在数据库中存储为BIGINT类型。 在数据库中存储时间戳时，尽量使用long型时间戳，它具有省空间，效率高，不依赖数据库的优点。 在数据库中，也存在几种日期和时间类型： DATETIME：表示日期和时间； DATE：仅表示日期； TIME：仅表示时间； TIMESTAMP：和DATETIME类似，但是数据库会在创建或者更新记录的时候同时修改TIMESTAMP。 数据库类型与Java新旧API的映射关系 数据库 对应Java类（旧） 对应Java类（新） DATETIME java.util.Date LocalDateTime DATE java.sql.Date LocalDate TIME java.sql.Time LocalTime TIMESTAMP java.sql.Timestamp LocalDateTime 4、为不同用户以不同的偏好来显示不同的本地时间 DateTimeFormatter：其中的ofLocalizedDateTime()方法，传入两个参数，一个日期格式，一个时间格式，具体的参数可以查看JDK源码，Idea直接按住Ctrl+左键即可跳转到源码对应位置： 123456789101112131415161718192021222324252627282930package com.learn;import java.time.Instant;import java.time.ZoneId;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.time.format.FormatStyle;import java.util.Locale;public class DateTimeWork { public static void main(String[] args) { Instant instant = Instant.now(); long l = instant.toEpochMilli(); System.out.println(instant.toEpochMilli()); System.out.println(timestampToString(l, Locale.CHINA, \"Asia/Shanghai\")); // 2020年4月14日 下午7:21 System.out.println(timestampToString(l, Locale.US, \"America/New_York\")); //Apr 14, 2020, 7:21 AM } static String timestampToString(long epochMilli, Locale lo, String zoneId) { // 将long转化为Instant： Instant ins = Instant.ofEpochMilli(epochMilli); // 创建格式化方法： DateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT); // 将Instant按照当前ZoneId转化为ZonedDateTime再使用DateTimeFormatter进行格式化： // 方式一：不传Local则会默认以中国格式输出： //return f.format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId))); // 2020年4月14日 上午7:28 // 方式二：传Local会以当前国家格式输出： return f.withLocale(lo).format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId))); // Apr 14, 2020, 7:28 AM }} 本节已经完结！敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Date","slug":"Date","permalink":"https://www.itnxd.cn/tags/Date/"},{"name":"Time","slug":"Time","permalink":"https://www.itnxd.cn/tags/Time/"}],"author":"Mr.Niu"},{"title":"Java教程系列之IO流","slug":"Java教程系列之IO流","date":"2020-04-10T14:12:52.000Z","updated":"2021-02-06T14:18:12.441Z","comments":true,"path":"posts/61053.html","link":"","permalink":"https://www.itnxd.cn/posts/61053.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、IO介绍IO是指Input/Output，即输入和输出。以内存为中心： Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。 Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。 IO流是一种流式的数据输入/输出模型： 二进制数据以byte为最小单位在InputStream/OutputStream中单向流动； 字符数据以char为最小单位在Reader/Writer中单向流动。 Java标准库的java.io包提供了同步IO功能： 字节流接口：InputStream/OutputStream； 字符流接口：Reader/Writer。 注意：UTF-8编码下，英文字符占一个字节，中文字符占三个字节！ Java的读写数据在传输时都是byte[]，String这两种方式！ 1、Reader 和 Writer 如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照char来读写显然更方便，这种流称为字符流。 Reader和Writer本质上是一个能自动编解码的InputStream和OutputStream。 使用Reader，数据源虽然是字节，但我们读入的数据都是char类型的字符，原因是Reader内部把读入的byte做了解码，转换成了char。使用InputStream，我们读入的数据和原始二进制数据一模一样，是byte[]数组，但是我们可以自己把二进制byte[]数组按照某种编码转换为字符串。究竟使用Reader还是InputStream，要取决于具体的使用场景。如果数据源不是文本，就只能使用InputStream，如果数据源是文本，使用Reader更方便一些。Writer和OutputStream是类似的。 2、同步和异步 同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。 而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。 Java标准库的包java.io提供了同步IO，而java.nio则是异步IO。上面我们讨论的InputStream、OutputStream、Reader和Writer都是同步IO的抽象类，对应的具体实现类，以文件为例，有FileInputStream、FileOutputStream、FileReader和FileWriter。 二、File对象1、创建File对象 File file = new File(\"路径\"); 1.1 路径的写法 注意Windows平台使用\\作为路径分隔符，在Java字符串中需要用\\\\表示一个\\。Linux平台使用/作为路径分隔符： 用.表示当前目录，..表示上级目录。 12345678910111213141516171819202122package com.learn.file;import java.io.File;import java.io.FilenameFilter;import java.io.IOException;public class FileTest { public static void main(String[] args) throws IOException { File file = new File(\".\"); File file01 = new File(\".\\\\\"); File file02 = new File(\"..\\\\\"); File file1 = new File(\"..\"); File file2 = new File(\"Settings\\\\setting.properties\"); File file3 = new File(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\"); // 打印系统当前分隔符： System.out.println(File.separator); // / // Linux 下路径写法，斜杠换一下即可！ File f = new File(\"/usr/bin/javac\"); }} 1.2 获取路径 getPath()：返回构造方法传入的路径，直接输出File对象名效果一样！ getAbsolutePath()：返回绝对路径，若传入参数有.，则该方法也会出现.; getCanonicalPath()：返回的是规范路径，若传入参数有.，则该方法会将点翻译为正确路径; 路径如下： 12345678910111213141516171819202122232425262728293031323334353637383940package com.learn.file;import java.io.File;import java.io.FilenameFilter;import java.io.IOException;public class FileTest { public static void main(String[] args) throws IOException { File file = new File(\".\"); System.out.println(file); // . System.out.println(file.getPath()); // . System.out.println(file.getAbsolutePath()); // E:\\MyJavaProgram\\. System.out.println(file.getCanonicalPath()); // E:\\MyJavaProgram\\ System.out.println(\"---------------------------------------------\"); File file01 = new File(\".\\\\\"); System.out.println(file01.getCanonicalPath()); // E:\\MyJavaProgram System.out.println(\"---------------------------------------------\"); File file02 = new File(\"..\\\\\"); System.out.println(file02.getCanonicalPath()); // E:\\ System.out.println(\"---------------------------------------------\"); File file1 = new File(\"..\"); System.out.println(file1.getPath()); // .. System.out.println(file1.getAbsolutePath()); // E:\\MyJavaProgram\\.. System.out.println(file1.getCanonicalPath()); // E:\\ System.out.println(\"---------------------------------------------\"); File file2 = new File(\"Settings\\\\setting.properties\"); System.out.println(file2.getPath()); // Settings\\setting.properties System.out.println(file2.getAbsolutePath()); // E:\\MyJavaProgram\\Settings\\setting.properties System.out.println(file2.getCanonicalPath()); // E:\\MyJavaProgram\\Settings\\setting.properties System.out.println(\"---------------------------------------------\"); File file3 = new File(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\"); System.out.println(file3.getPath()); // E:\\MyJavaProgram\\Settings\\setting.properties System.out.println(file3.getAbsolutePath()); // E:\\MyJavaProgram\\Settings\\setting.properties System.out.println(file3.getCanonicalPath()); // E:\\MyJavaProgram\\Settings\\setting.properties } 2、文件目录判断 File对象既可以表示文件，也可以表示目录。 特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。 isFile()：判断是否是已存在文件 isDirectory()：判断是否是已存在目录 isAbsolute()：判断是否是完整路径 isHidden()：判断是否是隐藏文件 1234567891011121314File file1 = new File(\"..\");File file2 = new File(\"Settings\\\\setting.properties\");File file3 = new File(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\");System.out.println(file3.isAbsolute()); // trueSystem.out.println(file3.isDirectory()); // falseSystem.out.println(file3.isFile()); // trueSystem.out.println(file3.isHidden()); // falseSystem.out.println(\"---------------------------------------------\");System.out.println(file2.isAbsolute()); // falseSystem.out.println(file1.isAbsolute()); // falseSystem.out.println(file1.isFile()); // falseSystem.out.println(file1.isDirectory()); // true 3、File权限判断用File对象获取到一个文件时，还可以进一步判断文件的权限和大小： boolean canRead()：是否可读； boolean canWrite()：是否可写； boolean canExecute()：是否可执行； long length()：文件字节大小。 对目录而言，是否可执行表示能否列出它包含的文件和子目录。 123456System.out.println(\"---------------------------------------------\");File fileExe = new File(\"E:\\\\MyJavaProgram\\\\Settings\\\\test.exe\");System.out.println(fileExe.canRead()); // trueSystem.out.println(fileExe.canWrite()); // trueSystem.out.println(fileExe.canExecute()); // true 4、创建和删除文件 先将需要创建的文件test.txt传入File对象，再调用creatNewFile()方法来创建！ 可通过createTempFile()创建临时文件，以及deleteOnExit()在JVM退出时自动删除该文件。 createNewFile()：返回boolean值，若文件已存在返回false！ delete()：返回boolean值，若文件已不存在返回false！ createTempFile()：创建临时文件，创建位置为C盘某个位置，需要传入两个参数，一个前缀，一个后缀！ deleteOnExit()：JVM退出时自动删除，删除后仍然可获得File对象路径！ 12345678910111213141516// 创建文件：File file4 = new File(\"Settings\\\\test.txt\");if(file4.createNewFile()){ System.out.println(\"test.txt创建成功！\");}// 删除文件：if(file4.delete()){ System.out.println(\"test.txt删除成功！\");}// 创建临时文件，使用后删除File file5 = File.createTempFile(\"temp\",\".cpp\");System.out.println(file5.getCanonicalPath()); // C:\\Users\\15890\\AppData\\Local\\Temp\\temp10279290225517315464.cppfile5.deleteOnExit();// 删除后仍然可以获得路径：System.out.println(file5.getCanonicalPath()); // C:\\Users\\15890\\AppData\\Local\\Temp\\temp10279290225517315464.cpp 5、创建和删除目录 boolean mkdir()：创建当前File对象表示的目录； boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来； boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功，是能删除最内部的目录，并且只有目录为空才可删除！ 创建目录使用mkdirs()即可，mkdir()可以做到的，mkdirs()都可以做到！ 12345678910111213141516File file7 = new File(\".\\\\test\");//File file8 = new File(\".\");if(file7.mkdir()){ System.out.println(\"test目录创建成功！\");}if(file7.delete()){ System.out.println(\"test目录删除成功！\");}File file8 = new File(\".\\\\test\\\\test02\\\\test03\");if(file8.mkdirs()){ System.out.println(\"嵌套目录创建成功！\"); if(file8.delete()){ System.out.println(\"test03目录删除成功！\"); }} 6、遍历文件和目录 使用listFiles()获取当前目录层次关系，用File对象数组接收，可以传入FilenameFilter()方法来过滤不需要的文件或目录！ 1234567891011121314151617181920212223242526272829303132package com.learn.file;import java.io.File;import java.io.FilenameFilter;import java.io.IOException;public class FileTest { public static void main(String[] args) throws IOException { System.out.println(\"-----------------------------------------------\"); File file6 = new File(\".\"); File[] files = file6.listFiles(); printFiles(files); File[] files1 = file6.listFiles(new FilenameFilter() { @Override public boolean accept(File dir, String name) { return name.endsWith(\".idea\"); } }); printFiles(files1); } static void printFiles(File[] files){ System.out.println(\"-----------------------------------------------\"); if(files != null){ for(var file : files){ System.out.println(file); } } }} 7、Path对象 Java标准库还提供了一个Path对象，它位于java.nio.file包。Path对象和File对象类似，但操作更加简单： Paths.get()：参数可以有多个，表示路径，后面的一定得是前面路径的子路径！ toAbsolutePath()：转化为带.的绝对路径 normalize()：将构造路径的点去掉 toAbsolutePath().normalize()：将带点的绝对路径去掉点，转化为完整的路径！ toFile()：转化为File对象！ 1234567891011121314151617181920212223242526272829package com.learn.file;import java.io.File;import java.io.IOException;import java.nio.file.Path;import java.nio.file.Paths;public class PathTest { public static void main(String[] args) throws IOException { Path path = Paths.get(\".\\\\Path\",\"PathTest\\\\test01\", \"test02\"); System.out.println(path); // .\\Path\\PathTest\\test01\\test02 System.out.println(path.toAbsolutePath()); // E:\\MyJavaProgram\\.\\Path\\PathTest\\test01\\test02 System.out.println(path.normalize()); // Path\\PathTest\\test01\\test02 System.out.println(path.toAbsolutePath().normalize()); // E:\\MyJavaProgram\\Path\\PathTest\\test01\\test02 File file = path.toFile(); System.out.println(file); // 嵌套目录遍历： for(var p : path){ System.out.println(p); } System.out.println(); for(var p : path.toAbsolutePath()){ System.out.println(p); } }} 8、遍历目录例子 为了有层次关系，可进行空格的控制输出，使用getName()方法获取目录或文件名！ 使用递归去进行层次遍历！ 12345678910111213141516171819202122232425262728293031323334package com.learn.file;import java.io.File;import java.io.IOException;/** @:实现打印当前目录的层次关系！* */public class FileWork { public static void main(String[] args) throws IOException { File file = new File(\".\"); ListDir(file, 0); } static void ListDir(File file, int level) { File[] files = file.listFiles(); if (files != null) { for (var ls : files) { for(int i = 0; i &lt; level; i++){ System.out.print(\" \"); } if (ls.isFile()) { System.out.println(ls.getName()); } else { System.out.println(ls.getName() + \"\\\\\"); } ListDir(ls, level + 1); } } }} 三、InputStream InputStream就是Java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步IO的功能。 要特别注意的一点是，InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()。 这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。 FileInputStream是InputStream的一个子类 1、读取和关闭FileInputStream 在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。 InputStream和OutputStream都是通过close()方法来关闭流。关闭流就会释放对应的底层资源。 我们还要注意到在读取或写入IO流的过程中，可能会发生错误，例如，文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成IOException异常并抛出。因此，所有与IO操作相关的代码都必须正确处理IOException。 1.1 手动关闭 + 未处理异常 如果读取过程中发生了IO错误，InputStream就没法正确地关闭，资源也就没法及时释放。 1234567891011121314151617181920package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ InputStream input = new FileInputStream(\"Settings\\\\readme.txt\"); int n; while((n = input.read()) != -1){ System.out.print(n + \" \"); } input.close(); }} 1.2 使用 try finally 来处理异常 无论是否异常，总会执行finally来关闭文件！ 注意：关闭流时要保证流不为null，否则会抛出NullPointerException 12345678910111213141516171819202122232425262728package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ System.out.println(); InputStream input1 = null; //input1.close(); // throws NullPointerException try{ input1 = new FileInputStream(\"Settings\\\\readme.txt\"); int n1; while((n1 = input1.read()) != -1){ System.out.print(n1 + \" \"); } }finally { if(input1 != null){ input1.close(); } } }} 1.3 使用 try(resource) 实现自动关闭流（推荐） 编译器自动为我们关闭资源 实际上，编译器并不会特别地为InputStream加上自动关闭。编译器只看try(resource = ...)中的对象是否实现了java.lang.AutoCloseable接口，如果实现了，就自动加上finally语句并调用close()方法。InputStream和OutputStream都实现了这个接口，因此，都可以用在try(resource)中。 只有实现了上述接口使用该语法才会进行自动关闭！ 123456789101112131415161718192021package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ System.out.println(); try(InputStream input2 = new FileInputStream(\"Settings\\\\readme.txt\")) { int n2; while((n2 = input2.read()) != -1){ System.out.print(n2 + \" \"); } } }} 2、读到缓存中 在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。 一次读取多个字节时，需要先定义一个byte[]数组作为缓冲区，read()方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。 read()方法的返回值不再是字节的int值，而是返回实际读取了多少个字节。如果返回-1，表示没有更多的数据了。 InputStream提供了两个重载方法来支持读取多个字节： int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数 int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数 12345678910111213141516171819202122package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ System.out.println(); try(InputStream input3 = new FileInputStream(\"Settings\\\\readme.txt\")) { int n2; byte[] buffer = new byte[10]; while((n2 = input3.read(buffer)) != -1){ System.out.println(\"读取了\" + n2 + \"个字节\"); } } }} 如下： 1234读取了10个字节读取了10个字节读取了10个字节读取了2个字节 3、阻塞 在调用InputStream的read()方法读取数据时，我们说read()方法是阻塞（Blocking）的！ 执行到第二行代码时，必须等read()方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定read()方法调用到底要花费多长时间。 123int n;n = input.read(); // 必须等待read()方法返回才能执行下一行代码int m = n; 4、InputStream实现类 除了FileInputStream可以从文件获取输入流，还有ByteArrayInputStream可以在内存中模拟一个InputStream： ByteArrayInputStream实际上是把一个byte[]数组在内存中变成一个InputStream，虽然实际应用不多，但测试的时候，可以用它来构造一个InputStream。 4.1 使用ByteArrayInputStream模拟InputStream12345678910111213141516171819package com.learn.file;import java.io.ByteArrayInputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { byte[] data = { 72, 101, 108, 108, 111, 33 }; try(InputStream input4 = new ByteArrayInputStream(data)){ int n3; while((n3 = input4.read()) != -1){ System.out.print((char)n3 + \" \"); // H e l l o ! } } }} 4.2 封装为函数进行测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.learn.file;import java.io.ByteArrayInputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class InputStreamTest { public static void main(String[] args) throws IOException { /* 文件内容： * 测试输入流！ * hello world! * */ byte[] data = { 72, 101, 108, 108, 111, 33 }; try(InputStream input4 = new ByteArrayInputStream(data)){ int n3; while((n3 = input4.read()) != -1){ System.out.print((char)n3 + \" \"); // H e l l o ! } } System.out.println(); String s; try(InputStream input5 = new FileInputStream(\"Settings\\\\readme.txt\")) { int n5; StringBuilder sb = new StringBuilder(); while((n5 = input5.read()) != -1){ sb.append((char)n5); } s = sb.toString(); } System.out.println(s); // 输出结果： /* æµè¯è¾å¥æµï¼ hello world! */ // 使用封装函数来输出： String s1; try (InputStream input6 = new FileInputStream(\"Settings\\\\readme.txt\")) { s1 = readAsString(input6); } System.out.println(s1); // 直接通过ByteArrayInputStream的模拟来输出： try(InputStream input7 = new ByteArrayInputStream(data)){ String s2 = readAsString(input7); System.out.println(s2); // Hello! } } // 封装一个函数： public static String readAsString(InputStream input) throws IOException { int n; StringBuilder sb = new StringBuilder(); while ((n = input.read()) != -1) { sb.append((char) n); } return sb.toString(); }} 四、OutputStream 和InputStream相反，OutputStream是Java标准库提供的最基本的输出流。 和InputStream类似，OutputStream也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是void write(int b) 这个方法会写入一个字节到输出流。要注意的是，虽然传入的是int参数，但只会写入一个字节，即只写入int最低8位表示字节的部分： OutputStream也提供了close()方法关闭输出流，以便释放系统资源！ 1public abstract void write(int b) throws IOException; 1、flush方法 它的目的是将缓冲区的内容强制输出到目的地。 向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以OutputStream有个flush()方法，能强制把缓冲区内容输出。 通常情况下，我们不需要调用这个flush()方法，因为缓冲区写满了OutputStream会自动调用它，并且，在调用close()方法关闭OutputStream之前，也会自动调用flush()方法。 需要手动调用该方法的例子：实时聊天软件，不能等缓冲区满了在进行输出吧！ 2、写入和关闭FileOutStream 如下方，只有当append参数为true时才不会进行覆盖，默认为false！ 123new FileOutputStream(File file, boolean append); //append = falsenew FileWriter(File file, boolean append); //append = false 2.1 一个字节的去读1234567891011121314151617181920package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class OutputStreamTest { public static void main(String[] args) throws IOException { File file = new File(\"Settings\\\\input.txt\"); if(file.createNewFile()){ System.out.println(\"input.txt创建成功！\"); } OutputStream output = new FileOutputStream(\"Settings\\\\input.txt\"); output.write(72); // H output.write(101); // e output.write(108); // l output.write(108); // l output.write(111); // o output.close(); }} 2.2 一次性读入若干字节12345678910111213141516package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class OutputStreamTest { public static void main(String[] args) throws IOException { File file = new File(\"Settings\\\\input.txt\"); if(file.createNewFile()){ System.out.println(\"input.txt创建成功！\"); } OutputStream output = new FileOutputStream(\"Settings\\\\input.txt\"); output.write(\"world\".getBytes(StandardCharsets.UTF_8)); output.close(); }} 2.3 使用try(resourse)自动关闭（推荐）123456789101112131415161718192021222324package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class OutputStreamTest { public static void main(String[] args) throws IOException { File file = new File(\"Settings\\\\input.txt\"); if(file.createNewFile()){ System.out.println(\"input.txt创建成功！\"); } try(OutputStream output1 = new FileOutputStream(\"Settings\\\\input.txt\")){ output1.write(\"hello world!\".getBytes(StandardCharsets.UTF_8)); }// 编译器在此自动为我们写入finally并调用close() try(InputStream input = new FileInputStream(\"Settings\\\\input.txt\")){ int n; while((n = input.read()) != -1){ System.out.print((char) n); } } }} 3、阻塞 同样，只有等write方法执行完毕才能执行下一行！ 所以write方法也是阻塞的！ 123int n;n = output.write(); // 必须等待write()方法返回才能执行下一行代码int m = n; 4、OutputStream实现类 用FileOutputStream可以从文件获取输出流，这是OutputStream常用的一个实现类。此外，ByteArrayOutputStream可以在内存中模拟一个OutputStream ByteArrayOutputStream实际上是把一个byte[]数组在内存中变成一个OutputStream，虽然实际应用不多，但测试的时候，可以用它来构造一个OutputStream。 使用ByteArrayOutputStream模拟OutputStream 123456789101112131415package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class OutputStreamTest { public static void main(String[] args) throws IOException { byte[] data; try(ByteArrayOutputStream output1 = new ByteArrayOutputStream()){ output1.write(\"Hello world!\".getBytes(StandardCharsets.UTF_8)); data = output1.toByteArray(); } System.out.println(new String(data));//Hello world! }} 5、一个小例子 实现文件的复制！ 在命令行进行运行带有参数的运行，即将source.txt 复制到copy.txt； 当然要在源文件下，或者使用相对路径绝对路径都可以！ 前提是两个文件都已经存在了！ 1$ java CopyTest.java source.txt copy.txt main函数的args参数就是用来接收命令行参数的，直接将第一个参数给了输入流，第二个参数给了输出流，即可实现将输入流复制到输出流的copy文件里！ 123456789101112131415package com.learn.file;import java.io.*;public class CopyTest { public static void main(String[] args) throws IOException { try(InputStream source = new FileInputStream(args[0]); OutputStream copyfile = new FileOutputStream(args[1])){ int n; while((n = source.read()) != -1){ copyfile.write(n); } } }} 效果： 之前： 1234source.txt：I am a source file!copy.txt：（空） 之后： 1234source.txt：I am a source file!copy.txt：I am a source file! 五、Filter模式 InputStream，OutputStream都是以这种Filter模式来提供各种功能： 下面仅以InputStream举例！ 1、InputStream来源 FileInputStream：从文件读取数据，是最终数据源； ServletInputStream：从HTTP请求读取数据，是最终数据源； Socket.getInputStream()：从TCP连接读取数据，是最终数据源； … 2、引入FilterInputStream原因 如果要给FileInputStream添加各种功能： 1234567// 添加缓冲功能：BufferedFileInputStream extends FileInputStream// 添加计算签名功能：DigestFileInputStream extends FileInputStream// 添加加密解密功能：CipherFileInputStream extends FileInputStream// 以及其他类之间的相互组合.....等等 这还只是针对FileInputStream设计，如果针对另一种InputStream设计，很快会出现子类爆炸的情况。 因此，直接使用继承，为各种InputStream附加更多的功能，根本无法控制代码的复杂度，很快就会失控。 3、FilterInputStream简介 为了解决依赖继承会导致子类数量失控的问题，JDK首先将InputStream分为两大类： 无论我们包装多少次，得到的对象始终是InputStream，我们直接用InputStream来引用它！ 通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。它可以让我们通过少量的类来实现各种功能的组合！ FilterInputStream是其他各钟功能的父类！ 一类是直接提供数据的基础InputStream，例如： FileInputStream ByteArrayInputStream ServletInputStream … 一类是提供额外附加功能的InputStream，例如： BufferedInputStream DigestInputStream CipherInputStream … 123456InputStream file = new FileInputStream(\"test.gz\");// 使用BufferedInputStream包装InputStream,添加缓冲功能：InputStream buffered = new BufferedInputStream(file);// 使用GZIPInputStream包装InputStream,添加解压功能：InputStream gzip = new GZIPInputStream(buffered); 结构图像这样： OutputStream也一样！ 12345678910111213141516 ┌─────────────┐ │ InputStream │ └─────────────┘ ▲ ▲┌────────────────────┐ │ │ ┌─────────────────┐│ FileInputStream │─┤ └─│FilterInputStream│└────────────────────┘ │ └─────────────────┘┌────────────────────┐ │ ▲ ┌───────────────────┐│ByteArrayInputStream│─┤ ├─│BufferedInputStream│└────────────────────┘ │ │ └───────────────────┘┌────────────────────┐ │ │ ┌───────────────────┐│ ServletInputStream │─┘ ├─│ DataInputStream │└────────────────────┘ │ └───────────────────┘ │ ┌───────────────────┐ └─│CheckedInputStream │ └───────────────────┘ 4、编写FilterInputStream 下面编写一个自定义的FilterInputStream来实现需要实现的功能，同时还可以使得所有InputStream都可以使用该功能： CountInputStream实现了计数功能； 所有的功能都必须得继承自FilterInputStream！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.learn.file;import java.io.ByteArrayInputStream;import java.io.FilterInputStream;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;public class FilterWork { public static void main(String[] args) throws IOException{ byte[] data = \"hello world!\".getBytes(StandardCharsets.UTF_8); // 使用ByteArrayInputStream将byte数组封装为InputStream; try(CountInputStream inputStream = new CountInputStream(new ByteArrayInputStream(data))){ int n; while ((n = inputStream.read()) != -1){ System.out.print((char)n); // hello world! } System.out.println(\"\\nTotal read \" + inputStream.getBytesRead() + \" bytes!\"); // Total read 12 bytes! } }}class CountInputStream extends FilterInputStream{ private int count; // Idea自动生成的注释： /** * Creates a {@code FilterInputStream} * by assigning the argument {@code in} * to the field {@code this.in} so as * to remember it for later use. * * @param in the underlying input stream, or {@code null} if * this instance is to be created without an underlying stream. */ protected CountInputStream(InputStream in) { super(in); } public int getBytesRead() { return this.count; } public int read() throws IOException { int n = in.read(); if (n != -1) { this.count ++; } return n; } public int read(byte[] b, int off, int len) throws IOException { int n = in.read(b, off, len); this.count += n; return n; }} 六、操作Zip1、ZipInputStream ZipInputStream是一种FilterInputStream，它可以直接读取zip包的内容： 另一个JarInputStream是从ZipInputStream派生，它增加的主要功能是直接读取jar文件里面的MANIFEST.MF文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。 继承的结构关系： 1234567891011121314151617181920212223┌───────────────────┐│ InputStream │└───────────────────┘ ▲ │┌───────────────────┐│ FilterInputStream │└───────────────────┘ ▲ │┌───────────────────┐│InflaterInputStream│└───────────────────┘ ▲ │┌───────────────────┐│ ZipInputStream │└───────────────────┘ ▲ │┌───────────────────┐│ JarInputStream │└───────────────────┘ 2、读取Zip包 创建一个ZipInputStream，通常是传入一个FileInputStream作为数据源，然后，循环调用getNextEntry()，直到返回null，表示zip流结束。 一个ZipEntry表示一个压缩文件或目录，如果是压缩文件，我们就用read()方法不断读取，直到返回-1： 1234567891011121314151617181920212223242526package com.learn.file;import java.io.FileInputStream;import java.io.IOException;import java.util.zip.ZipEntry;import java.util.zip.ZipInputStream;public class ZipTest { public static void main(String[] args) throws IOException { try (ZipInputStream zip = new ZipInputStream(new FileInputStream(\".\\\\zip.zip\"))) { ZipEntry entry = null; while ((entry = zip.getNextEntry()) != null) { System.out.println(\"文件或目录名：\" + entry.getName()); if (!entry.isDirectory()) { int n; System.out.print(\"内容：\"); while ((n = zip.read()) != -1) { System.out.print((char) n); } System.out.println(); } } } }} 结果如下： 12345文件或目录名：niub/文件或目录名：test.txt内容：I am a Test file!文件或目录名：zip.txt内容：hello world! 3、写入Zip包 ZipOutputStream是一种FilterOutputStream，它可以直接写入内容到zip包。我们要先创建一个ZipOutputStream，通常是包装一个FileOutputStream，然后，每写入一个文件前，先调用putNextEntry()，然后用write()写入byte[]数据，写入完毕后调用closeEntry()结束这个文件的打包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.learn.file;import java.io.*;import java.util.zip.ZipEntry;import java.util.zip.ZipInputStream;import java.util.zip.ZipOutputStream;public class ZipTest { public static void main(String[] args) throws IOException { try (ZipInputStream zip = new ZipInputStream(new FileInputStream(\".\\\\zip.zip\"))) { ZipEntry entry = null; while ((entry = zip.getNextEntry()) != null) { System.out.println(\"文件或目录名：\" + entry.getName()); if (!entry.isDirectory()) { int n; System.out.print(\"内容：\"); while ((n = zip.read()) != -1) { System.out.print((char) n); } System.out.println(); } } } File file1 = new File(\".\\\\Settings\"); try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(\".\\\\zip.zip\"))) { File[] files = file1.listFiles(); if(files != null){ for (File file : files) { // 在Zip中创建文件 zip.putNextEntry(new ZipEntry(file.getName())); // 将内容写入 zip.write(getFileDataAsBytes(file)); // 关闭外部文件 zip.closeEntry(); } } } } private static byte[] getFileDataAsBytes(File file) throws IOException{ byte[] data = new byte[1024]; try(InputStream file1 = new FileInputStream(file)){ int n; while((n = file1.read(data)) != -1){ System.out.println(\"read \" + n + \" byte\"); } } return data; }} 七、读取classpath资源 是一种与路径无关的读取文件的方式： 从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把default.properties文件放到classpath中，就不用关心它的实际存放路径。 在classpath中的资源文件，路径总是以／开头，我们先获取当前的Class对象，然后调用getResourceAsStream()就可以直接从classpath读取任意的资源文件！ 关于classpath目前还不太清楚，后续再进行学习！ Java存放.class的目录或jar包也可以包含任意其他类型的文件，例如： 配置文件，例如.properties； 图片文件，例如.jpg； 文本文件，例如.txt，.csv； …… 1234567891011121314151617package com.learn.file;import java.io.IOException;import java.io.InputStream;public class ClassPathTest { public static void main(String[] args) throws IOException { try (InputStream input = ClassPathTest.class.getResourceAsStream(\"/default.properties\")) { if (input != null) { int n; while((n = input.read()) != -1){ System.out.print((char) n); } } } }} 如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置： 123Properties props = new Properties();props.load(inputStreamFromClassPath(\"/default.properties\"));props.load(inputStreamFromFile(\"./conf.properties\")); 八、序列化 序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。 为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。 有序列化，就有反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。 一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口： Serializable接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。 这节有点云里雾里，后续再看！ 1、序列化 把一个Java对象变为byte[]数组，需要使用ObjectOutputStream。它负责把一个Java对象写入一个字节流。 ObjectOutputStream既可以写入基本类型，如int，boolean，也可以写入String（以UTF-8编码），还可以写入实现了Serializable接口的Object。 因为写入Object时需要大量的类型信息，所以写入的内容很大。 123456789101112131415161718192021package com.learn.file;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.util.Arrays;public class SerializableTest { public static void main(String[] args) throws IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); try (ObjectOutputStream output = new ObjectOutputStream(buffer)) { // 写入int: output.writeInt(12345); // 写入String: output.writeUTF(\"Hello\"); // 写入Object: output.writeObject(123.456); } System.out.println(Arrays.toString(buffer.toByteArray())); }} 2、反序列化 和ObjectOutputStream相反，ObjectInputStream负责从一个字节流读取Java对象 除了能读取基本类型和String类型外，调用readObject()可以直接返回一个Object对象。要把它变成一个特定类型，必须强制转型。 要特别注意反序列化的几个重要特点： 反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。 readObject()可能抛出的异常有： ClassNotFoundException：没有找到对应的Class； InvalidClassException：Class不匹配。 对于ClassNotFoundException，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，Person对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义Person类，所以无法反序列化。 对于InvalidClassException，这种情况常见于序列化的Person对象定义了一个int类型的age字段，但是反序列化时，Person类定义的age字段被改成了long类型，所以导致class不兼容。 123456789101112131415161718package com.learn.file;import java.io.*;import java.util.Arrays;public class SerializableTest { public static void main(String[] args) throws Exception { ByteArrayInputStream bufferin = new ByteArrayInputStream(buffer.toByteArray()); try (ObjectInputStream input = new ObjectInputStream(bufferin)) { int n = input.readInt(); String s = input.readUTF(); Double d = (Double) input.readObject(); System.out.println(n); System.out.println(s); System.out.println(d); } }} 为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的serialVersionUID静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变serialVersionUID的值，这样就能自动阻止不匹配的class版本： 123public class Person implements Serializable { private static final long serialVersionUID = 2709425275741743919L;} 3、安全性 因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 九、Reader Reader是Java的IO库提供的另一个输入流接口。和InputStream的区别是，InputStream是一个字节流，即以byte为单位读取，而Reader是一个字符流，即以char为单位读取： java.io.Reader是所有字符输入流的超类！ read()方法读取字符流的下一个字符，并返回字符表示的int，范围是0~65535。如果已读到末尾，返回-1。 1、Reader和InputStream对比 InputStream Reader 字节流，以byte为单位 字符流，以char为单位 读取字节（-1，0~255）：int read() 读取字符（-1，0~65535）：int read() 读到字节数组：int read(byte[] b) 读到字符数组：int read(char[] c) 2、FileReader FileReader是Reader的一个子类，它可以打开文件并获取`Reader： FileReader()可以接收一个编码参数！ 2.1 直接创建FileReader12345678910111213141516package com.learn.file;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class ReaderTest { public static void main(String[] args) throws IOException { Reader reader = new FileReader(\"Settings\\\\readme.txt\"); int n; while((n = reader.read()) != -1){ System.out.print((char) n); } reader.close(); }} 2.2 使用try(resourse)实现自动关闭资源1234567891011121314151617package com.learn.file;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class ReaderTest { public static void main(String[] args) throws IOException { try(Reader reader = new FileReader(\"Settings\\\\readme.txt\")){ int n; while((n = reader.read()) != -1){ System.out.print((char) n); } } }} 2.3 填充字符到char数组 read(char[] c)返回实际读入的字符个数，最大不超过char[]数组的长度。返回-1表示流结束。 123456789101112131415161718package com.learn.file;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class ReaderTest { public static void main(String[] args) throws IOException { try(Reader reader = new FileReader(\"Settings\\\\readme.txt\")){ int n; char[] buffer = new char[100]; while((n = reader.read(buffer)) != -1){ System.out.println(\"read \" + n + \"chars\"); } } }} 3、CharArrayReader CharArrayReader可以在内存中模拟一个Reader，它的作用实际上是把一个char[]数组变成一个Reader： 123456try (Reader reader = new CharArrayReader(\"Hello\".toCharArray())) { int n; while((n = reader.read()) != -1){System.out.print((char) n); }} 4、StringReader StringReader可以直接把String作为数据源，它和CharArrayReader几乎一样： 123456try (Reader reader = new StringReader(\"Hello\")) { int n; while((n = reader.read()) != -1){ System.out.print((char) n); }} 5、InputStreamReader 除了特殊的CharArrayReader和StringReader，普通的Reader实际上是基于InputStream构造的。 因为Reader需要从InputStream中读入字节流（byte），然后，根据编码设置，再转换为char就可以实现字符流。 InputStreamReader就是一个转换器，它可以把任何InputStream转换为Reader： 两个参数，一个InputStream，一个可选的编码方式参数！ 使用try (resource)结构时，当我们关闭Reader时，它会在内部自动调用InputStream的close()方法，所以，只需要关闭最外层的Reader对象即可 12345678910// 持有InputStream:InputStream input = new FileInputStream(\"src/readme.txt\");// 变换为Reader:Reader reader = new InputStreamReader(input, StandardCharsets.UTF_8);// 使用try(resourse)：try (Reader reader1 = new InputStreamReader(new FileInputStream(\"src/readme.txt\"),StandardCharsets.UTF_8)) { // TODO: System.out.println(reader1);} 十、Writer Reader是带编码转换器的InputStream，它把byte转换为char，而Writer就是带编码转换器的OutputStream，它把char转换为byte并输出： 1、Reader和InputStream对比 OutputStream Writer 字节流，以byte为单位 字符流，以char为单位 写入字节（0~255）：void write(int b) 写入字符（0~65535）：void write(int c) 写入字节数组：void write(byte[] b) 写入字符数组：void write(char[] c) 无对应方法 写入String：void write(String s) Writer是所有字符输出流的超类，它提供的方法主要有： 写入一个字符（0~65535）：void write(int c)； 写入字符数组的所有字符：void write(char[] c)； 写入String表示的所有字符：void write(String s)。 2、FileWriter 同样可以设置第三个参数，使其不进行覆盖写入： 123456789101112131415161718192021package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class WriterTest { public static void main(String[] args) throws IOException { try (Writer writer = new FileWriter(\"readme.txt\", StandardCharsets.UTF_8, true)) { writer.write('H'); // 写入单个字符 writer.write(\"Hello\".toCharArray()); // 写入char[] writer.write(\"Hello\"); // 写入String } try (Reader reader = new FileReader(\"readme.txt\")){ int n; while((n = reader.read()) != -1){ System.out.print((char) n); } } }} 3、CharArrayWriter CharArrayWriter可以在内存中创建一个Writer，它的作用实际上是构造一个缓冲区，可以写入char，最后得到写入的char[]数组： 12345678910111213141516package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class WriterTest { public static void main(String[] args) throws IOException { try (CharArrayWriter writer = new CharArrayWriter()) { writer.write(65); writer.write(66); writer.write(67); char[] data = writer.toCharArray(); System.out.print(data); // ABC } }} 4、StringWriter StringWriter也是一个基于内存的Writer，它和CharArrayWriter类似。实际上，StringWriter在内部维护了一个StringBuffer，并对外提供了Writer接口： 可以使用StringBuffer的所有方法，只是实现了一个writer接口： 1234567891011121314package com.learn.file;import java.io.*;import java.nio.charset.StandardCharsets;public class WriterTest { public static void main(String[] args) throws IOException { try (StringWriter writer = new StringWriter()) { writer.write(\"hello world nxd\"); writer.append(\" last!\"); System.out.print(writer); } }} 5、OutputStreamWriter 除了CharArrayWriter和StringWriter外，普通的Writer实际上是基于OutputStream构造的，它接收char，然后在内部自动转换成一个或多个byte，并写入OutputStream。因此，OutputStreamWriter就是一个将任意的OutputStream转换为Writer的转换器： 12345try (Writer writer = new OutputStreamWriter(new FileOutputStream(\"readme.txt\"), StandardCharsets.UTF_8)) { // TODO: int n; writer.write(\"hello\");} 十一、PrintStream和PrintWriter1、PrintStream PrintStream和OutputStream相比，除了添加了一组print()/println()方法，可以打印各种数据类型，比较方便外，它还有一个额外的优点，就是不会抛出IOException，这样我们在编写代码的时候，就不必捕获IOException。 以及对应的一组println()方法，它会自动加上换行符。 我们经常使用的System.out.println()实际上就是使用PrintStream打印各种数据。其中，System.out是系统默认提供的PrintStream，表示标准输出. System.err是系统默认提供的标准错误输出。 PrintStream是一种FilterOutputStream，它在OutputStream的接口上，额外提供了一些写入各种数据类型的方法： 写入int：print(int) 写入boolean：print(boolean) 写入String：print(String) 写入Object：print(Object)，实际上相当于print(object.toString()) … 1234567891011package com.learn.file;public class PrintStreamTest { public static void main(String[] args) { System.out.print(12345); // 输出12345 System.out.print(new Object()); // 输出类似java.lang.Object@3c7a835a System.out.println(\"Hello\"); // 输出Hello并换行 System.err.println(\"hhh\"); }} 2、PrintWriter PrintStream最终输出的总是byte数据，而PrintWriter则是扩展了Writer接口，它的print()/println()方法最终输出的是char数据。两者的使用方法几乎是一模一样的： 12345678910111213141516package com.learn.file;import java.io.PrintWriter;import java.io.StringWriter;public class PrintWriterTest { public static void main(String[] args) { StringWriter buffer = new StringWriter(); try (PrintWriter pw = new PrintWriter(buffer)) { pw.println(\"Hello\"); pw.println(12345); pw.println(true); } System.out.println(buffer.toString()); }} 本章终于完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://www.itnxd.cn/tags/IO/"},{"name":"File","slug":"File","permalink":"https://www.itnxd.cn/tags/File/"}],"author":"Mr.Niu"},{"title":"Java教程系列之集合","slug":"Java教程系列之集合","date":"2020-04-07T08:23:56.000Z","updated":"2021-02-06T14:12:51.589Z","comments":true,"path":"posts/46100.html","link":"","permalink":"https://www.itnxd.cn/posts/46100.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、Java集合介绍 在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合！ 数组就是一种集合： 123String[] ss = new String[10]; // 可以持有10个String对象ss[0] = \"Hello\"; // 可以放入String对象String first = ss[0]; // 可以获取String对象 1、数组的不足 数组初始化后大小不可变； 数组只能按索引顺序存取。 2、需要各种类型的集合 可变大小的顺序链表； 保证无重复元素的集合； … 3、Collection Collection，它是除Map外所有其他集合类的根接口，来自于java.util包！ 3.1 三种主要集合： List：一种有序列表的集合 Set：一种保证没有重复元素的集合 Map：一种通过键值（key-value）查找的映射表集合 3.2 Java集合的特点： 一是实现了接口和实现类相分离，例如，有序表的接口是List，具体的实现类有ArrayList，LinkedList等. 二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素. 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 只能放入String类型 3.3 集合访问（Iterator） Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。 Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。 3.4 不建议继续使用的集合由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用： Hashtable：一种线程安全的Map实现； Vector：一种线程安全的List实现； Stack：基于Vector实现的LIFO的栈。 还有一小部分接口是遗留接口，也不应该继续使用： Enumeration：已被Iterator取代。 二、使用List List是最基础的一种集合：它是一种有序链表。 1、数组的删除和添加 删除：删掉指定索引位置后将后面元素整体前移一位； 添加：将指定索引位置及之后元素后移一位，将新元素插入该位置； 可见：操作增删是很复杂的，需要人为介入去处理！ 2、ArrayList 把添加和删除的操作封装起来，让我们操作List类似于操作数组，却不用关心内部元素如何移动。 变成了自动操作！ 增删可以直接使用，已经封装为函数！ 数组已满时的操作： 先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组 3、List&lt;E&gt;接口主要的接口方法： 在末尾添加一个元素：void add(E e) 在指定索引添加一个元素：void add(int index, E e) 删除指定索引的元素：int remove(int index)：返回索引+1，从1开始计数！ 删除某个元素：int remove(Object e) 获取指定索引的元素：E get(int index) 获取链表大小（包含元素的个数）：int size() 4、ArrayList与LinkedList 都是List接口实现的实例类！ LinkedList相当于单链表，有前后的指针关系！ 通常情况下，我们总是优先使用ArrayList。 区别： ArrayList LinkedList 获取指定元素 速度很快 需要从头开始查找元素 添加元素到末尾 速度很快 速度很快 在指定位置添加/删除 需要移动元素 不需要移动元素 内存占用 少 较大 5、List的特点 元素可重复 允许添加null 123456789101112131415package com.learn.java;import java.util.ArrayList;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"hello\"); list.add(\"hello\"); list.add(null); System.out.println(list.size()); // 3 System.out.println(list.toString()); // [hello, hello, null] }} 6、创建List 通过List接口提供的of()方法，根据给定元素快速创建List： 但是List.of()方法不接受null值，如果传入null，会抛出NullPointerException异常。 123List&lt;String&gt; list1 = List.of(\"hello\", \"hello\", \"world\");// 无法传入null:List&lt;String&gt; list2 = List.of(null); 7、遍历List7.1 通过get方法遍历（不推荐） 缺点： 一是代码复杂； 二是因为get(int)方法只有ArrayList的实现是高效的，换成LinkedList后，索引越大，访问速度越慢。 12345678910111213141516package com.learn.java;import java.util.ArrayList;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"hello\"); list.add(\"hello\"); list.add(null); for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); } }} 7.2 通过Iterator遍历 使用迭代器Iterator来访问List。 Iterator本身也是一个对象，但它是由List的实例调用iterator()方法的时候创建的。 Iterator对象知道如何遍历一个List，并且不同的List类型，返回的Iterator对象实现也是不同的，但总是具有最高的访问效率。 两个方法： boolean hasNext()：判断是否有下一个元素 E next()：返回下一个元素 1234567891011121314151617package com.learn.java;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"hello\"); list.add(\"hello\"); list.add(null); for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ){ System.out.println(it.next()); } }} 7.3 通过for each遍历（推荐） 编译器内部其实会通过Iterator来实现遍历，达到最高效！ 和7.2的实现是一样的，但是更加简单使用，推荐使用！ 只要实现了Iterable接口的集合类都可以直接用for each循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把for each循环变成Iterator的调用，原因就在于Iterable接口定义了一个Iterator iterator()方法，强迫集合类必须返回一个Iterator实例。 12345678910111213141516package com.learn.java;import java.util.ArrayList;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"hello\"); list.add(\"hello\"); list.add(null); for (String s : list) { System.out.println(s); } }} 8、List转换为Array8.1 使用toArray()方法 调用toArray()方法直接返回一个Object[]数组： 这种方法会丢失类型信息，所以实际应用很少。 12List&lt;String&gt; list = List.of(\"apple\", \"pear\", \"banana\");Object[] array = list.toArray(); 8.2 使用toArray(T[])方法 给toArray(T[])传入一个类型相同的Array，List内部自动把元素复制到传入的Array中： 该方法的泛型参数&lt;T&gt;并不是List接口定义的泛型参数&lt;E&gt;！ 参数可传入实际类型及其父类： 12345678910111213141516171819package com.learn.java;import java.util.List;public class ListTest { public static void main(String[] args) { List&lt;Integer&gt; list = List.of(1, 3, 5); Number[] arr = list.toArray(new Number[3]); Object[] arr1 = list.toArray(new Object[3]); for (Number number : arr) { System.out.print(number + \" \"); } System.out.println(); for (Object o : arr1) { System.out.print(o + \" \"); } }} 如果传入的数组不够大，那么List内部会创建一个新的刚好够大的数组，填充后返回； 如果传入的数组比List元素还要多，那么填充完元素后，剩下的数组元素一律填充null。 8.3 传入恰好大小的数组12List&lt;Integer&gt; list = List.of(1, 3, 5);Integer[] array = list.toArray(new Integer[list.size()]); 8.4 使用函数式写法 更简洁的写法是通过List接口定义的T[] toArray(IntFunction generator)方法： 函数式写法后面会讲到： 1Integer[] array = list.toArray(Integer[]::new); 9、Array转换为List 直接借助List.of()方法： 12345Integer[] array = { 1, 2, 3 };List&lt;Integer&gt; list = List.of(array);// jdk11之前可以这样用：List&lt;Integer&gt; list = Arrays.asList(array); 使用List.of()方法返回的是一个只读的List，无法调用add和remove等方法！ 会抛出UnsupportedOperationException。 1234567// 正确：List&lt;Integer&gt; lis = new ArrayList&lt;&gt;();lis.add(3);// 抛出错误：List&lt;Integer&gt; list = List.of(1, 3, 5);list.add(5); 三、编写equals方法1、contains 和 indexOf方法 List还提供了boolean contains(Object o)方法来判断List是否包含某个指定元素. int indexOf(Object o)方法可以返回某个元素的索引，如果元素不存在，就返回-1。 12345678910111213package com.learn.java;import java.util.List;public class Equals { public static void main(String[] args) { List&lt;String&gt; list = List.of(\"A\", \"B\", \"C\"); System.out.println(list.contains(\"C\")); // true System.out.println(list.contains(\"X\")); // false System.out.println(list.indexOf(\"C\")); // 2 System.out.println(list.indexOf(\"X\")); // -1 }} 2、判断两个元素相等 传入不同的实例，仍然可以通过下面两个函数比较得到结果： 因为List内部并不是通过==判断两个元素是否相等，而是使用equals()方法判断两个元素是否相等： Java标准中的引用类型定义的类已经正确实现了equals方法！ 所以自定义的类需要手动覆写equals方法； 12System.out.println(list.contains(new String(\"C\"))); // trueSystem.out.println(list.indexOf(new String(\"C\"))); // 2 3、编写equals方法3.1 equals方法需要满足的条件 自反性（Reflexive）：对于非null的x来说，x.equals(x)必须返回true； 对称性（Symmetric）：对于非null的x和y来说，如果x.equals(y)为true，则y.equals(x)也必须为true； 传递性（Transitive）：对于非null的x、y和z来说，如果x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)也必须为true； 一致性（Consistent）：对于非null的x和y来说，只要x和y状态不变，则x.equals(y)总是一致地返回true或者false； 对null的比较：即x.equals(null)永远返回false。 3.2 equals方法编写步骤 先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等； 用instanceof判断传入的待比较的Object是不是当前类型，如果是，继续比较，否则，返回false； 对引用类型用Objects.equals()比较，对基本类型直接用==比较。 对于引用字段比较，我们使用equals()，对于基本类型字段的比较，我们使用==。 使用instanceof来判断两个对象类型是否一致！当然参数为当前对象子类时也可以进入判断！ 普通方法编写： 要判断null的特殊情况！ 123456789101112131415161718192021public class Person { public String name; public int age; public boolean equals(Object o) { if (o instanceof Person) { Person p = (Person) o; boolean nameEquals = false; // 都是null返回true if (this.name == null &amp;&amp; p.name == null) { nameEquals = true; } if (this.name != null) { nameEquals = this.name.equals(p.name); } return nameEquals &amp;&amp; this.age == p.age; } return false; } } 借助Objects.equals()方法判断 使用Objects.equals()比较两个引用类型是否相等的目的是省去了判断null的麻烦。两个引用类型都是null时它们也是相等的。 12345678910111213public class Person { public String name; public int age; public boolean equals(Object o) { if (o instanceof Person) { Person p = (Person) o; return Objects.equals(this.name, p.name) &amp;&amp; this.age == p.age; } return false; } } 4、什么时候需要编写equals方法如果不调用List的contains()、indexOf()这些方法，那么放入的元素就不需要实现equals()方法。 总而言之：不需要进行元素的比较就不需要编写！ 四、使用Map Map是一种键值（key-value）映射表的数据结构，作用就是能高效通过key快速查找value（元素）。 Map和List一样也是一个接口，最常用的实现类是HashMap。 1、常用方法 V put(K key, V value)：存储键值对，没有键时返回null，有键时返回旧的value，新的覆盖旧的！ V get(K key)：获取键对应的值！ boolean containsKey(K key)：查询键是否存在！ 123456789101112131415161718import java.util.HashMap;import java.util.Map;public class Main { public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"apple\", 123); map.put(\"pear\", 456); System.out.println(map.get(\"apple\")); // 123 map.put(\"apple\", 789); // 再次放入apple作为key，但value变为789 System.out.println(map.get(\"apple\")); // 789 // 当然：value可重复 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"apple\", 123); map.put(\"pear\", 123); // ok }} 2、Map遍历 Map存储的是key-value的映射关系，并且，它不保证顺序，即遍历的顺序是不确定的！ 三种遍历如下： 1234567891011121314151617181920212223242526package com.learn.java;import java.util.HashMap;import java.util.Map;public class MapTest { public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"niu\", 20); map.put(\"ge\", 30); map.put(\"hello\", 30); // 遍历key for(String key : map.keySet()){ System.out.println(key); } // 遍历value for(Integer value : map.values()){ System.out.println(value); } // 遍历key-value for(Map.Entry&lt;String, Integer&gt; entry : map.entrySet()){ System.out.println(entry.getKey() + \" \" + entry.getValue()); } }} 3、高效查找例子 List来存储所有信息，Map来存储经常需要查询的信息！提高查找效率！ 现在Map中找，找到直接返回，找不到再从List中找，找到将这组信息放入Map，并返回该信息！ Map永远存储最常用的信息，极大提高效率！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.learn.java;import java.util.HashMap;import java.util.List;import java.util.Map;public class MapWork { public static void main(String[] args) { List&lt;Student&gt; list = List.of( new Student(\"Bob\", 78), new Student(\"Alice\", 85), new Student(\"Brush\", 66), new Student(\"Newton\", 99)); var holder = new Students(list); System.out.println(holder.getScore(\"Bob\") == 78 ? \"测试成功!\" : \"测试失败!\"); System.out.println(holder.getScore(\"Alice\") == 85 ? \"测试成功!\" : \"测试失败!\"); System.out.println(holder.getScore(\"Tom\") == -1 ? \"测试成功!\" : \"测试失败!\"); }}class Students { List&lt;Student&gt; list; Map&lt;String, Integer&gt; cache; Students(List&lt;Student&gt; list) { this.list = list; cache = new HashMap&lt;&gt;(); } /** * 根据name查找score，找到返回score，未找到返回-1 */ Integer getScore(String name) { // 先在Map中查找: Integer score = this.cache.get(name); if (score == null) { // TODO: score = findInList(name); if(score != null){ cache.put(name, score); } } return score == null ? -1 : score; } Integer findInList(String name) { for (var ss : this.list) { if (ss.name.equals(name)) { return ss.score; } } return null; }}class Student { String name; int score; Student(String name, int score) { this.name = name; this.score = score; }} 五、编写hashCode和equals方法 当然是针对HashMap的，get方法查找的时候HashMap内部要进行比对，通过equals方法，编写方法同第三大节的编写equals方法，当自定义的类出现时，就需要去覆写equals方法。 在Map的内部，对key做比较是通过equals()实现的，这一点和List查找元素需要正确覆写equals()是一样的，即正确使用Map必须保证：作为key的对象必须正确覆写equals()方法。 Map内部是通过hashCode()方法来计算key对应的value的索引， 正确使用Map必须保证： 作为key的对象必须正确覆写equals()方法，相等的两个key实例调用equals()必须返回true； 作为key的对象还必须正确覆写hashCode()方法，且hashCode()方法要严格遵循以下规范： 如果两个对象相等，则两个对象的hashCode()必须相等； 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。 第一条规范是正确性，必须保证实现，否则HashMap不能正常工作。 而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的hashCode()，会造成Map内部存储冲突，使存取的效率下降。 1、equals方法覆写同第三节的编写equals方法！ 2、编写hashCode方法 当然还是针对自定义类的覆写，标准库的类，java内部已经实现！ 2.1 实现原理 此方法并没有处理参数为null的问题，要想写完整需要加上关于null的判断！ 在计算Person的hashCode()时，反复使用31*h，这样做的目的是为了尽量把不同的Person实例的hashCode()均匀分布到整个int范围。 1234567891011121314public class Person { String firstName; String lastName; int age; @Override int hashCode() { int h = 0; h = 31 * h + firstName.hashCode(); h = 31 * h + lastName.hashCode(); h = 31 * h + age; return h; }} 2.2 使用Objects.hash方法 直接借助Objects.hash()方法，自动实现null的处理； 123int hashCode() { return Objects.hash(firstName, lastName, age);} 2.3 编写原则 equals()用到的用于比较的每一个字段，都必须在hashCode()中用于计算； equals()中没有使用到的字段，绝不可放在hashCode()中计算。 另外注意，对于放入HashMap的value对象，没有任何要求。 2.4 完整示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.learn.java;import java.util.HashMap;import java.util.Map;import java.util.Objects;public class HashCode { public static void main(String[] args) { Map&lt;Persons, String&gt; map = new HashMap&lt;&gt;(); map.put(new Persons(\"hello1\", \"world1\", 20), \"first\"); map.put(new Persons(\"hello2\", \"world2\", 21), \"second\"); map.put(new Persons(\"hello3\", \"world3\", 22), \"three\"); String str = map.get(new Persons(\"hello2\", \"world2\", 21)); System.out.println(str); // second Persons key = new Persons(\"hello2\", \"world2\", 21); int index = key.hashCode() &amp; 0xf; System.out.println(index); // 4 }}class Persons { String firstName; String lastName; int age; Persons(String firstName, String lastName, int age){ this.firstName = firstName; this.lastName = lastName; this.age = age; } @Override public boolean equals(Object o){ if(o instanceof Persons){ Persons p = (Persons) o; return Objects.equals(this.firstName, p.firstName) &amp;&amp; Objects.equals(this.lastName, p.lastName) &amp;&amp; this.age == p.age; } return false; } /*@Override // 普通方法： public int hashCode() { int h = 0; h = 31 * h + firstName.hashCode(); h = 31 * h + lastName.hashCode(); h = 31 * h + age; return h; }*/ @Override public int hashCode(){ return Objects.hash(firstName, lastName, age); }} 3、hashCode延伸 HashMap内部使用了数组，通过计算key的hashCode()直接定位value所在的索引！ 3.1 HashMap的数组变化HashMap初始化时默认的数组大小只有16，索引为在0～15，超过范围，自动扩容为原来的二倍，即长度为16的数组扩展为长度32，相应地，需要重新确定hashCode()计算的索引位置。 扩容会导致重新分布已有的key-value，所以，频繁扩容对HashMap的性能影响很大，所以在创建时就指定容量！ 虽然指定容量是10000，但HashMap内部的数组长度总是2n，因此，实际数组长度被初始化为比10000大的16384（214）。 1234567Persons key = new Persons(\"hello2\", \"world2\", 21);// 调用hashCode方法与容量做按位与获取value下标：int index = key.hashCode() &amp; 0xf;System.out.println(index);// 在创建时指定容量：Map&lt;String, Integer&gt; maps = new HashMap&lt;&gt;(10000); 3.2 hashCode计算得到的索引相同 若计算出的数组索引相同，并不会发生覆盖现象，只要key不相同，它们映射的value就互不干扰！ 假设\"a\"和\"b\"这两个key最终计算出的索引都是5，那么，在HashMap的数组中，实际存储的不是一个Person实例，而是一个List，它包含两个Entry，一个是\"a\"的映射，一个是\"b\"的映射！ HashMap内部通过\"a\"找到的实际上是List&gt;，它还需要遍历这个List，并找到一个Entry，它的key字段是\"a\"，才能返回对应的Person实例！ 我们把不同的key具有相同的hashCode()的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用List存储hashCode()相同的key-value。显然，如果冲突的概率越大，这个List就越长，Map的get()方法效率就越低，这就是为什么要尽量满足条件二： 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。 12map.put(\"a\", new Person(\"Xiao Ming\"));map.put(\"b\", new Person(\"Xiao Hong\")); 六、使用EnumMap HashMap是一种通过对key计算hashCode()，通过空间换时间的方式，直接定位到value所在的内部数组的索引，因此，查找效率非常高。 如果作为key的对象是enum类型，那么，还可以使用Java集合库提供的一种EnumMap，它在内部以一个非常紧凑的数组存储value，并且根据enum类型的key直接定位到内部数组的索引，并不需要计算hashCode()，不但效率最高，而且没有额外的空间浪费。 使用EnumMap的时候，我们总是用Map接口来引用它，因此，实际上把HashMap和EnumMap互换，在客户端看来没有任何区别。 12345678910111213141516171819202122232425package com.learn.java;import java.time.DayOfWeek;import java.util.EnumMap;import java.util.Map;public class EnumMapTest { public static void main(String[] args) { // 参数作用：泛型擦除，方法内部从T拿不到class Map&lt;DayOfWeek, String&gt; map = new EnumMap&lt;&gt;(DayOfWeek.class); map.put(DayOfWeek.MONDAY, \"星期一\"); map.put(DayOfWeek.TUESDAY, \"星期二\"); map.put(DayOfWeek.WEDNESDAY, \"星期三\"); map.put(DayOfWeek.THURSDAY, \"星期四\"); map.put(DayOfWeek.FRIDAY, \"星期五\"); map.put(DayOfWeek.SATURDAY, \"星期六\"); map.put(DayOfWeek.SUNDAY, \"星期日\"); System.out.println(map); System.out.println(map.get(DayOfWeek.MONDAY)); /* {MONDAY=星期一, TUESDAY=星期二, WEDNESDAY=星期三, THURSDAY=星期四, FRIDAY=星期五, SATURDAY=星期六, SUNDAY=星期日} 星期一 */ }} 七、使用TreeMap HashMap是一种以空间换时间的映射表，它的实现原理决定了内部的Key是无序的，即遍历HashMap的Key时，其顺序是不可预测的（但每个Key都会遍历一次且仅遍历一次）。 还有一种Map，它在内部会对Key进行排序，这种Map就是SortedMap。 注意到SortedMap是接口，它的实现类是TreeMap。 1、Map的继承关系：1234567891011121314 ┌───┐ │Map│ └───┘ ▲ ┌────┴─────┐ │ │┌───────┐ ┌─────────┐│HashMap│ │SortedMap│└───────┘ └─────────┘ ▲ │ ┌─────────┐ │ TreeMap │ └─────────┘ 2、普通排序 使用TreeMap时，放入的Key必须实现Comparable接口。String、Integer这些类已经实现了Comparable接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。 123456789101112public class Main { public static void main(String[] args) { Map&lt;String, Integer&gt; map = new TreeMap&lt;&gt;(); map.put(\"orange\", 1); map.put(\"apple\", 2); map.put(\"pear\", 3); for (String key : map.keySet()) { System.out.println(key); } // apple, orange, pear }} 3、自定义类的排序 通过Comparable接口实现一个自定义排序算法： String类型通过compareTo()方法比较，int通过-比较！ 不需要覆写equals()和hashCode()，因为TreeMap不使用equals()和hashCode()。 在创建TreeMap时的参数中传入排序算法： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.learn.java;import java.util.Comparator;import java.util.Map;import java.util.TreeMap;public class TreeMapTest { public static void main(String[] args) { Map&lt;Person1, Integer&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Person1&gt;() { @Override public int compare(Person1 o1, Person1 o2) { return o1.name.compareTo(o2.name); } }); map.put(new Person1(\"Tom\"), 1); map.put(new Person1(\"Bob\"), 2); map.put(new Person1(\"Lily\"), 3); for(var key : map.keySet()){ System.out.println(key); } for(var entry : map.entrySet()){ System.out.println(entry.getKey() + \" \" + entry.getValue()); } System.out.println(map.get(new Person1(\"Lily\"))); // 3 }}class Person1{ public String name; Person1(String name){ this.name = name; } public String toString(){ return \"name: \" + name; }} 八、使用Properties 在编写应用程序的时候，经常需要读写配置文件！ 配置文件的特点是，它的Key-Value一般都是String-String类型的，因此我们完全可以用Map来表示它。 因为配置文件非常常用，所以Java集合库提供了一个Properties来表示一组“配置”。由于历史遗留原因，Properties内部本质上是一个Hashtable，但我们只需要用到Properties自身关于读写配置的接口。 1、读取配置文件 用Properties读取配置文件非常简单。Java默认配置文件以.properties为扩展名，每行以key=value表示，以#课开头的是注释。以下是一个典型的配置文件： 配置文件实例： 1234# setting.propertieslast_open_file=/data/hello.txtauto_save_interval=60 读取步骤： Properties读取配置文件，一共有三步： 创建Properties实例； 调用load()读取文件； 调用getProperty()获取配置。（如果key不存在，将返回null。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。） 也可以从classpath读取.properties文件，因为load(InputStream)方法接收一个InputStream实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流！ 1234567891011// 读取步骤：String f = \"setting.properties\";Properties props = new Properties();props.load(new java.io.FileInputStream(f));// 获取属性值：String filepath = props.getProperty(\"last_open_file\");String interval = props.getProperty(\"auto_save_interval\", \"120\");// 从classpath读取配置文件：Properties props = new Properties();props.load(getClass().getResourceAsStream(\"/common/setting.properties\")); 2、配置读取实例 从内存读取一个字节流： 123456789101112131415161718package com.learn.java;import java.io.ByteArrayInputStream;import java.util.Properties;public class PropertiesTest { public static void main(String[] args) throws Exception{ String settings = \"# test\" + \"\\n\" + \"course=Java\" + \"\\n\" + \"last_open_date=2019-08-07T12:35:01\"; ByteArrayInputStream input = new ByteArrayInputStream(settings.getBytes(\"UTF-8\")); Properties props = new Properties(); props.load(input); System.out.println(\"course: \" + props.getProperty(\"course\")); System.out.println(\"last_open_date: \" + props.getProperty(\"last_open_date\")); System.out.println(\"last_open_file: \" + props.getProperty(\"last_open_file\")); System.out.println(\"auto_save: \" + props.getProperty(\"auto_save\", \"60\")); }} 输出结果： 1234course: Javalast_open_date: 2019-08-07T12:35:01last_open_file: nullauto_save: 60 3、多配置文件 可以反复调用load()读取，后读取的key-value会覆盖已读取的key-value： 下面的代码演示了Properties的一个常用用法：可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。 123Properties props = new Properties();props.load(getClass().getResourceAsStream(\"/common/setting.properties\"));props.load(new FileInputStream(\"C:\\\\conf\\\\setting.properties\")); Properties设计的目的是存储String类型的key－value，但Properties实际上是从Hashtable派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了getProperty()和setProperty()方法外，还有从Hashtable继承下来的get()和put()方法，这些方法的参数签名是Object，我们在使用Properties的时候，不要去调用这些从Hashtable继承下来的方法。 4、写入配置文件 使用setProperty()方法修改Properties实例； 可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用store()方法！ 123456Properties props2 = new Properties();props2.setProperty(\"url\", \"https://niuxvdong.top/\");props2.setProperty(\"language\", \"Java\");//E:\\MyJavaProgram\\Settings 已写入我的E盘props2.store(new FileOutputStream(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\"), \"这是写入的properties注释\"); 结果如下： 第一行是“这是写入的properties注释”的Unicode编码！ 第二行是生成的时间： 后面是你设置的属性！ 1234#\\u8FD9\\u662F\\u5199\\u5165\\u7684properties\\u6CE8\\u91CA#Wed Apr 08 21:58:45 CST 2020url=https\\://niuxvdong.top/language=Java 5、编码 早期版本的Java规定.properties文件编码是ASCII编码（ISO8859-1），如果涉及到中文就必须用name=\\u4e2d\\u6587来表示，非常别扭。从JDK9开始，Java的.properties文件可以使用UTF-8编码了。 不过，需要注意的是，由于load(InputStream)默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法load(Reader)读取！ 就可以正常读取中文。InputStream和Reader的区别是一个是字节流，一个是字符流。字符流在内存中已经以char类型表示了，不涉及编码问题。 1234Properties props3 = new Properties();props3.load(new FileReader(\"E:\\\\MyJavaProgram\\\\Settings\\\\setting.properties\", StandardCharsets.UTF_8));System.out.println(props3.getProperty(\"language\")); // JavaSystem.out.println(props3.getProperty(\"url\")); // https://niuxvdong.top/ 九、使用Set Map用于存储key-value的映射，对于充当key的对象，是不能重复的，并且，不但需要正确覆写equals()方法，还要正确覆写hashCode()方法。 如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用Set。 Set实际上相当于只存储key、不存储value的Map。我们经常用Set用于去除重复元素。 因为放入Set的元素和Map的key类似，都要正确实现equals()和hashCode()方法，否则该元素无法正确地放入Set。 1、常用方法 将元素添加进Set：boolean add(E e) 将元素从Set删除：boolean remove(Object e) 判断是否包含元素：boolean contains(Object e) 1234567891011121314151617package com.learn.java;import java.util.HashSet;import java.util.Set;public class SetTest { public static void main(String[] args) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); System.out.println(set.add(\"abc\")); // true System.out.println(set.add(\"xyz\")); // true System.out.println(set.add(\"xyz\")); // false，添加失败，因为元素已存在 System.out.println(set.contains(\"xyz\")); // true，元素存在 System.out.println(set.contains(\"XYZ\")); // false，元素不存在 System.out.println(set.remove(\"hello\")); // false，删除失败，因为元素不存在 System.out.println(set.size()); // 2，一共两个元素 }} 2、Set实现代码简化版 最常用的Set实现类是HashSet，实际上，HashSet仅仅是对HashMap的一个简单封装，它的核心代码如下： 123456789101112131415161718192021public class HashSet&lt;E&gt; implements Set&lt;E&gt; { // 持有一个HashMap: private HashMap&lt;E, Object&gt; map = new HashMap&lt;&gt;(); // 放入HashMap的value: private static final Object PRESENT = new Object(); public boolean add(E e) { // 放入成功会返回null，失败返回旧value return map.put(e, PRESENT) == null; } public boolean contains(Object o) { return map.containsKey(o); } public boolean remove(Object o) { // 删除成功返回value,失败返回null return map.remove(o) == PRESENT; }} 3、两种Set实现类 HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口； TreeSet是有序的，因为它实现了SortedSet接口。 继承关系如下： 1234567891011121314 ┌───┐ │Set│ └───┘ ▲ ┌────┴─────┐ │ │┌───────┐ ┌─────────┐│HashSet│ │SortedSet│└───────┘ └─────────┘ ▲ │ ┌─────────┐ │ TreeSet │ └─────────┘ 3.1 HashSet 是无序的，类似HashMap！ 自定义类同样需要实现equals() 和 hashCode()方法！ 3.2 TreeSet 实现了SortedSet接口！ 自定义类必须正确实现Comparable接口！ TreeSet不需要覆写equals()和hashCode()方法： 关于TreeSet不需要覆写两个方法！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.learn.java;import java.util.Comparator;import java.util.Set;import java.util.TreeSet;public class TreeSetTest { public static void main(String[] args) { Set&lt;Person2&gt; set = new TreeSet&lt;&gt;(new Comparator&lt;Person2&gt;() { @Override public int compare(Person2 o1, Person2 o2) { if(o1.age != o2.age) return o1.age - o2.age; else return o1.name.compareTo(o2.name); } }); set.add(new Person2(\"hello\", 25)); set.add(new Person2(\"world\", 25)); set.add(new Person2(\"abc\", 30)); set.add(new Person2(\"abc\", 30)); for (var p : set){ System.out.println(p.toString()); } }}class Person2{ public String name; public int age; Person2(String name, int age){ this.age = age; this.name = name; } @Override public String toString(){ return this.name + \" \" + this.age; } /* 不需要覆写： @Override public boolean equals(Object o){ if(o instanceof Person2){ Person2 p = (Person2) o; return Objects.equals(this.name, p.name) &amp;&amp; this.age == p.age; } return false; } @Override public int hashCode(){ return Objects.hash(name, age); }*/} 4、一个去重例子 在聊天软件中，发送方发送消息时，遇到网络超时后就会自动重发，因此，接收方可能会收到重复的消息，在显示给用户看的时候，需要首先去重，使用Set去重！ 注释中的两种方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.learn.java;import java.util.*;public class TreeSetTest02 { public static void main(String[] args){ List&lt;Message&gt; received = List.of( new Message(1, \"Hello!\"), new Message(2, \"发工资了吗？\"), new Message(2, \"发工资了吗？\"), new Message(3, \"去哪吃饭？\"), new Message(3, \"去哪吃饭？\"), new Message(4, \"Bye\") ); List&lt;Message&gt; displayMessages = process(received); for (Message message : displayMessages) { System.out.println(message.text); } } static List&lt;Message&gt; process(List&lt;Message&gt; received) { // TODO: 按sequence去除重复消息 // 方法一：通过覆写equals和hashCode方法，来使用Set去重 /*Set&lt;Message&gt; set = new HashSet&lt;&gt;(); List&lt;Message&gt; ls = new ArrayList&lt;&gt;(); for(var list : received) { if (set.add(list)) ls.add(list); } return ls;*/ // 方法二：使用TreeSet进行去重，不需要覆写那两个方法：当然必须实现一个Comparator方法 Set&lt;Message&gt; set = new TreeSet&lt;&gt;(new Comparator&lt;Message&gt;() { @Override public int compare(Message o1, Message o2) { // 这里随便，按照sequence从小到大排 return o1.sequence - o2.sequence; } }); // 将原List放入TreeSet自动实现去重 set.addAll(received); // 返回一个由Set构造的List return new ArrayList&lt;Message&gt;(set); }}class Message { public final int sequence; public final String text; public Message(int sequence, String text) { this.sequence = sequence; this.text = text; } /* 方法一的覆写： @Override public boolean equals(Object o){ if(o instanceof Message){ Message m = (Message) o; return Objects.equals(this.text, m.text) &amp;&amp; this.sequence == m.sequence; } return false; } @Override public int hashCode(){ return Objects.hash(sequence, text); }*/} 十、使用Queue 队列（Queue）是一种经常使用的集合。Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作： 把元素添加到队列末尾； 从队列头部取出元素。 1、常用方法 int size()：获取队列长度； boolean add(E)/boolean offer(E)：添加元素到队尾； E remove()/E poll()：获取队首元素并从队列中删除； E element()/E peek()：获取队首元素但并不从队列中删除。 关于上面方法的区别： THROW EXCEPTION 返回false或null 添加元素到队尾 add(E e) boolean offer(E e) 取队首元素并删除 E remove() E poll() 取队首元素但不删除 E element() E peek() add方法超过队列容量会抛出异常，offer方法超过队列容量会返回false； remove方法删除空队列会抛出异常，poll方法删除空队列会返回null; …. 123456789101112131415161718192021222324252627package com.learn.java;import java.util.LinkedList;import java.util.Queue;public class QueueTest { public static void main(String[] args) { Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); System.out.println(queue.peek()); // null //System.out.println(queue.element()); // throws NoSuchElementException System.out.println(queue.poll()); // null //System.out.println(queue.remove()); // throws NoSuchElementException queue.offer(\"hello\"); queue.offer(\"world\"); queue.add(\"add\"); System.out.println(queue.size()); // 3 // 获取队首并删除 System.out.println(queue.remove()); // hello System.out.println(queue.poll()); // world // 获取队首不删除 System.out.println(queue.element()); // add System.out.println(queue.peek()); // add }} 2、注意点 注意：不要把null添加到队列中，否则poll()方法返回null时，很难确定是取到了null元素还是队列为空。 LinkedList即实现了List接口，又实现了Queue接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用： 1234// 这是一个List:List&lt;String&gt; list = new LinkedList&lt;&gt;();// 这是一个Queue:Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); 十一、使用PriorityQueue 用来实现“VIP插队”的业务！ PriorityQueue和Queue的区别在于，它的出队顺序与元素的优先级有关，对PriorityQueue调用remove()或poll()方法，返回的总是优先级最高的元素。 1、标准类的优先队列 所谓不需要实现Comparable接口，因为Java已经实现了这些标准类了！ String当然是按照字母顺序来排列的！ 12345678910111213141516package com.learn.java;import java.util.PriorityQueue;public class PriorityQueueTest01 { public static void main(String[] args) { PriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;(); pq.offer(\"hello\"); pq.offer(\"world\"); pq.offer(\"ababa\"); for(var s : pq){ System.out.println(s); } }} 2、自定义类的优先队列 和TreeSet一样，实现一个Comparator对象即可！ 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.learn.java;import java.util.Comparator;import java.util.PriorityQueue;public class PriorityQueueTest02 { public static void main(String[] args) { PriorityQueue&lt;User&gt; pq = new PriorityQueue&lt;User&gt;(new Comparator&lt;User&gt;() { @Override public int compare(User o1, User o2) { if(o1.age == o2.age){ return o1.name .compareTo(o2.name); } return o1.age - o2.age; } }); pq.offer(new User(\"hello\", 25)); pq.offer(new User(\"world\", 10)); pq.offer(new User(\"abcde\", 25)); pq.offer(new User(\"cfgeg\", 30)); while (!pq.isEmpty()){ System.out.println(pq.poll()); } }}class User{ public String name; public int age; User(String name, int age) { this.name = name; this.age = age; } @Override public String toString(){ return name + \" \" + age; }} 也可以这样写 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.learn.java;import java.util.Comparator;import java.util.PriorityQueue;import java.util.Queue;public class PriorityQueueTest03 { public static void main(String[] args) { Queue&lt;Users&gt; pq = new PriorityQueue&lt;Users&gt;(new UsersComparator()); pq.offer(new Users(\"hello\", 25)); pq.offer(new Users(\"world\", 10)); pq.offer(new Users(\"abcde\", 25)); pq.offer(new Users(\"cfgeg\", 30)); while (!pq.isEmpty()){ System.out.println(pq.poll()); } }}class UsersComparator implements Comparator&lt;Users&gt; { public int compare(Users o1, Users o2) { if(o1.age == o2.age){ return o1.name .compareTo(o2.name); } return o1.age - o2.age; }}class Users{ public String name; public int age; public Users(String name, int age) { this.name = name; this.age = age; } @Override public String toString(){ return name + \" \" + age; }} 十二、使用Deque Deque是一个接口，它的实现类有ArrayDeque和LinkedList。 LinkedList真是一个全能选手，它即是List，又是Queue，还是Deque的接口！ 两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名Deque。 1、常用方法 queue Deque 添加元素到队尾 add(E e) / offer(E e) addLast(E e) / offerLast(E e) 取队首元素并删除 E remove() / E poll() E removeFirst() / E pollFirst() 取队首元素但不删除 E element() / E peek() E getFirst() / E peekFirst() 添加元素到队首 无 addFirst(E e) / offerFirst(E e) 取队尾元素并删除 无 E removeLast() / E pollLast() 取队尾元素但不删除 无 E getLast() / E peekLast() 1234567891011121314151617package com.learn.java;import java.util.Deque;import java.util.LinkedList;public class DequeTest01 { public static void main(String[] args) { Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); deque.offerLast(\"A\"); // A deque.offerLast(\"B\"); // B -&gt; A deque.offerFirst(\"C\"); // B -&gt; A -&gt; C System.out.println(deque.pollFirst()); // C, 剩下B -&gt; A System.out.println(deque.pollLast()); // B System.out.println(deque.pollFirst()); // A System.out.println(deque.pollFirst()); // null }} 2、一些建议 Deque接口实际上扩展自Queue！Queue提供的add()/offer()方法在Deque中也可以使用，但是，使用Deque，最好不要调用offer()，而是调用offerLast()： 123public interface Deque&lt;E&gt; extends Queue&lt;E&gt; { ...} 不要使用接口去实例化 尽量持有接口，而不是具体的实现类。 123456// 不推荐的写法:LinkedList&lt;String&gt; d1 = new LinkedList&lt;&gt;();d1.offerLast(\"z\");// 推荐的写法：Deque&lt;String&gt; d2 = new LinkedList&lt;&gt;();d2.offerLast(\"z\"); 十三、使用Stack 栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。 Stack只有入栈和出栈的操作： 把元素压栈：push(E)； 把栈顶的元素“弹出”：pop(E)； 取栈顶元素但不弹出：peek(E)。 在Java中，我们用Deque可以实现Stack的功能： 把元素压栈：push(E)/addFirst(E)； 把栈顶的元素“弹出”：pop(E)/removeFirst()； 取栈顶元素但不弹出：peek(E)/peekFirst()。 Java的集合类没有单独的Stack接口呢？因为有个遗留类名字就叫Stack，出于兼容性考虑，所以没办法创建Stack接口，只能用Deque接口来“模拟”一个Stack了。 当我们把Deque作为Stack使用时，注意只调用push()/pop()/peek()方法，不要调用addFirst()/removeFirst()/peekFirst()方法，这样代码更加清晰。 不要使用遗留类Stack。使用Deque来实现Stack即可！ 1、一个例子 使用Stack实现十进制转化为十六进制： 1234567891011121314151617181920212223242526272829303132package com.learn.java;import java.util.Deque;import java.util.LinkedList;public class StackTest { public static void main(String[] args) { String hex = toHex(12500); if (hex.equalsIgnoreCase(\"30D4\")) { System.out.println(\"测试通过\"); } else { System.out.println(\"测试失败\"); } } static String toHex(int n) { Deque&lt;String&gt; stack = new LinkedList&lt;&gt;(); String[] str = {\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"}; while(n != 0){ int t = n % 16; n /= 16; stack.push(str[t]); } StringBuilder s = new StringBuilder(); while(!stack.isEmpty()) { s.append(stack.pop()); } return s.toString(); }} 十四、使用Iterator1、for each遍历的实现 Java编译器并不知道如何遍历List。上述代码能够编译通过，只是因为编译器把for each循环通过Iterator改写为了普通的for循环： 12345678910List&lt;String&gt; list = List.of(\"Apple\", \"Orange\", \"Pear\");for (String s : list) { System.out.println(s);}// 编译器编译为如下：for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) { String s = it.next(); System.out.println(s);} 2、迭代器 我们把这种通过Iterator对象遍历集合的模式称为迭代器。 使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。 这样一来，调用方就必须知道集合的内部存储结构。并且，如果把ArrayList换成LinkedList，get(int)方法耗时会随着index的增加而增加。如果把ArrayList换成Set，上述代码就无法编译，因为Set内部没有索引。 用Iterator遍历就没有上述问题，因为Iterator对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的for each循环自动转换为Iterator遍历。 3、编写Iterator我们自己编写了一个集合类，想要使用for each循环，只需满足以下条件： 集合类实现Iterable接口，该接口要求返回一个Iterator对象； 用Iterator对象迭代集合内部数据。 这里的关键在于，集合类通过调用iterator()方法，返回一个Iterator对象，这个对象必须自己知道如何遍历该集合。 一个例子：实现List逆序的迭代器！ 稍有点复杂，要记得多看多练多查资料！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.learn.java;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class IteratorTest { public static void main(String[] args) { ReverseList&lt;String&gt; rlist = new ReverseList&lt;&gt;(); rlist.add(\"Apple\"); rlist.add(\"Orange\"); rlist.add(\"Pear\"); for (String s : rlist) { System.out.println(s); } }}class ReverseList&lt;T&gt; implements Iterable&lt;T&gt; { // 内部使用List存储 private List&lt;T&gt; list = new ArrayList&lt;&gt;(); public void add(T t) { list.add(t); } @Override // 覆写Iterator方法： public Iterator&lt;T&gt; iterator() { return new ReverseIterator(list.size()); } // 实现迭代器：内部类： class ReverseIterator implements Iterator&lt;T&gt; { int index; // 内部类构造方法： ReverseIterator(int index) { this.index = index; } @Override // 覆写hasNext public boolean hasNext() { return index &gt; 0; } @Override // 覆写next public T next() { index--; // 从index输出，即从后向前，访问外部类ReverseList的list的get方法来获取元素： return ReverseList.this.list.get(index); } }} 十五、使用Collections Collection，它是除Map外所有其他集合类的根接口，来自于java.util包！ Collections是JDK提供的工具类，同样位于java.util包中。它提供了一系列静态方法，能更方便地操作各种集合。 注意Collections结尾多了一个s，不是Collection！ 1、addAll方法 方法可以给一个Collection类型的集合添加若干元素。因为方法签名是Collection，所以我们可以传入List，Set等各种集合类型。 1public static boolean addAll(Collection&lt;? super T&gt; c, T... elements) { ... } 1234567891011121314151617package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; list2 = List.of(\"hello\", \"world\", \"hello\"); // 1. 分开写 /*Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.addAll(list2);*/ // 2.直接可以合并 Set&lt;String&gt; set1 = new HashSet&lt;&gt;(list2); for(var s : set1){ System.out.println(s); } }} 2、创建空集合 创建空List：List emptyList() 创建空Map：Map emptyMap() 创建空Set：Set emptySet() 要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。 其他类还可以用类.of()方法来创建空集合！ 12345678910111213package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; list = Collections.emptyList(); List&lt;String&gt; list1 = List.of(); list.add(\"hello\"); // throws UnsupportedOperationException list1.add(\"hello\"); // throws UnsupportedOperationException Map&lt;String, Integer&gt; map = Collections.emptyMap(); }} 3、创建单元素集合 创建一个元素的List：List singletonList(T o) 创建一个元素的Map：Map singletonMap(K key, V value) 创建一个元素的Set：Set singleton(T o) 要注意到返回的单元素集合也是不可变集合，无法向其中添加或删除元素。 也可以用各个集合接口提供的of(T...)方法创建单元素集合 使用of()方法创建的都是不变集合，无法进行增删！ 使用of()方法可以实现任意大小的不变集合，比Collections更加方便！ 12345678910List&lt;String&gt; list5 = List.of(\"apple\");List&lt;String&gt; list6 = Collections.singletonList(\"apple\");list5.add(\"hhh\"); // UnsupportedOperationExceptionList&lt;String&gt; list7 = List.of(); // empty list List&lt;String&gt; list8 = List.of(\"apple\"); // 1 elementList&lt;String&gt; list3 = List.of(\"apple\", \"pear\"); // 2 elementsList&lt;String&gt; list4 = List.of(\"apple\", \"pear\", \"orange\"); // 3 elementslist3.add(\"hello\"); // UnsupportedOperationException 4、排序 Collections可以对List进行排序。因为排序会直接修改List元素的位置，因此必须传入可变List： 只能对List排序！ 1234567891011121314151617package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; list01 = new ArrayList&lt;&gt;(); list01.add(\"apple\"); list01.add(\"pear\"); list01.add(\"orange\"); // 排序前: System.out.println(list01); // [apple, pear, orange] Collections.sort(list01); // 排序后: System.out.println(list01); // [apple, orange, pear] }} 5、洗牌算法 Collections提供了洗牌算法，即传入一个有序的List，可以随机打乱List内部元素的顺序，效果相当于让计算机洗牌： 只针对List！ 1234567891011121314151617package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;Integer&gt; list02 = new ArrayList&lt;&gt;(); for (int i=0; i&lt;10; i++) { list02.add(i); } // 洗牌前: System.out.println(list02); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Collections.shuffle(list02); // 洗牌后: System.out.println(list02); // [5, 7, 1, 4, 9, 2, 6, 0, 8, 3] }} 6、不可变集合Collections还提供了一组方法把可变集合封装成不可变集合： 封装成不可变List：List unmodifiableList(List list) 封装成不可变Set：Set unmodifiableSet(Set set) 封装成不可变Map：Map unmodifiableMap(Map m) 下面这种情况可以用of()方法代替，不过其他情况就不一定了，必须使用该方法了！ 123456789101112131415package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; mutable = new ArrayList&lt;&gt;(); mutable.add(\"apple\"); mutable.add(\"pear\"); // 变为不可变集合: List&lt;String&gt; immutable = Collections.unmodifiableList(mutable); List&lt;String&gt; immutable = List.of(\"apple\", \"pear\"); immutable.add(\"orange\"); // UnsupportedOperationException! }} 继续对原始的可变List进行增删是可以的，并且，会直接影响到封装后的“不可变”List： 原List可修改，会影响到封装后的List！所以需要将原List扔掉！ 123456789101112131415161718package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; mutable = new ArrayList&lt;&gt;(); mutable.add(\"apple\"); mutable.add(\"pear\"); // 变为不可变集合: List&lt;String&gt; immutable = Collections.unmodifiableList(mutable); List&lt;String&gt; immutable = List.of(\"apple\", \"pear\"); immutable.add(\"orange\"); // UnsupportedOperationException! System.out.println(immutable); //[apple, pear] mutable.add(\"orange\"); System.out.println(immutable); //[apple, pear, orange] }} 扔掉原List 操作：将原List置为null即可！ 12345678910111213141516package com.learn.java;import java.util.*;public class CollectionsTest { public static void main(String[] args) { List&lt;String&gt; mutable = new ArrayList&lt;&gt;(); mutable.add(\"apple\"); mutable.add(\"pear\"); // 变为不可变集合: List&lt;String&gt; immutable = Collections.unmodifiableList(mutable); // 立刻扔掉mutable的引用: mutable = null; System.out.println(immutable); //[apple, pear] }} 7、线程安全集合Collections还提供了一组方法，可以把线程不安全的集合变为线程安全的集合： 变为线程安全的List：List synchronizedList(List list) 变为线程安全的Set：Set synchronizedSet(Set s) 变为线程安全的Map：Map synchronizedMap(Map m) 多线程的概念我们会在后面讲。因为从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。 集合这一章完结，敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"集合","slug":"集合","permalink":"https://www.itnxd.cn/tags/%E9%9B%86%E5%90%88/"}],"author":"Mr.Niu"},{"title":"Java教程系列之泛型","slug":"Java教程系列之泛型","date":"2020-04-04T10:27:50.000Z","updated":"2021-02-06T14:08:45.303Z","comments":true,"path":"posts/16438.html","link":"","permalink":"https://www.itnxd.cn/posts/16438.html","excerpt":"","text":"一、泛型是什么 泛型就是编写模板代码来适应任意类型； 泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查； 1、以ArrayList举例 例如将其模板化： T可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的ArrayList： 编译器会针对定义类型进行检查： 12345678910111213141516171819public class ArrayList&lt;T&gt; { private T[] array; private int size; public void add(T e) {...} public void remove(int index) {...} public T get(int index) {...}}// 创建可以存储String的ArrayList:ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;();// 创建可以存储Float的ArrayList:ArrayList&lt;Float&gt; floatList = new ArrayList&lt;Float&gt;();// 创建可以存储Person的ArrayList:ArrayList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();strList.add(\"hello\"); // OKString s = strList.get(0); // OKstrList.add(new Integer(123)); // compile error!Integer n = strList.get(0); // compile error! 2、向上转型 Java标准库中的ArrayList实现了List接口，它可以向上转型为List： 12345public class ArrayList&lt;T&gt; implements List&lt;T&gt; { ...}List&lt;String&gt; list = new ArrayList&lt;String&gt;(); 3、特别注意 不能把ArrayList&lt;Integer&gt;向上转型为ArrayList&lt;Number&gt;或List&lt;Number&gt;。 我们把一个ArrayList转型为ArrayList类型后，这个ArrayList就可以接受Float类型，因为Float是Number的子类。但是，ArrayList实际上和ArrayList是同一个对象，也就是ArrayList类型，它不可能接受Float类型， 所以在获取Integer的时候将产生ClassCastException。 实际上，编译器为了避免这种错误，根本就不允许把ArrayList转型为ArrayList。 但是java14似乎连转型的第六行赋值都会报错。。。 12345678910// 创建ArrayList&lt;Integer&gt;类型：ArrayList&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;();// 添加一个Integer：integerList.add(new Integer(123));// “向上转型”为ArrayList&lt;Number&gt;：ArrayList&lt;Number&gt; numberList = integerList;// 添加一个Float，因为Float也是Number：numberList.add(new Float(12.34));// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：Integer n = integerList.get(1); // ClassCastException! 二、使用泛型1、泛型接口接口定义： 12345678public interface Comparable&lt;T&gt; { /** * 返回-1: 当前实例比参数o小 * 返回0: 当前实例与参数o相等 * 返回1: 当前实例比参数o大 */ int compareTo(T o);} 具体用法： 对Person0数组按年龄升序排列，年龄相同，按照姓名字典序排序！ 如果使用了泛型Comparable&lt;Person0&gt;则类内部必须进行compareTo的覆写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.hello;import java.util.Arrays;public class TYPE { public static void main(String[] args) { Person0[] list = new Person0[]{ new Person0(\"B\", 2), new Person0(\"A\", 3), new Person0(\"G\", 0), new Person0(\"A\", 2), new Person0(\"L\", 4) }; Arrays.sort(list); System.out.println(Arrays.toString(list)); // String 类型的排序，本身已经实现了Comparable接口： String[] str = {\"hello\", \"world\", \"hhhh\", \"wor\", \"adv\"}; Arrays.sort(str); System.out.println(Arrays.toString(str)); }}// 使用泛型覆写compareTo方法进行比较：class Person0 implements Comparable&lt;Person0&gt; { public String name; public int age; Person0(String name, int age){ this.name = name; this.age = age; } // 重构toString方法： public String toString(){ return this.name + \"-\" + this.age; } // 覆写compareTo方法： @Override public int compareTo(Person0 o) { if(this.age != o.age) return this.age - o.age; else return this.name.compareTo(o.name); }} 结果如下： 12[G-0, A-2, B-2, A-3, L-4][adv, hello, hhhh, wor, world] 三、编写泛型1、编写泛型 像这样，将需要的写类型的地方全部替换为T，类名称后面加一个&lt;T&gt;即可： 1234567891011121314public class Pair&lt;T&gt; { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { return first; } public T getLast() { return last; }} 2、静态方法 普通的方法是通过类的实例来调用的，创建实例的过程调用了构造方法，也就是说对象已经知道这个时候类上面定义的的具体类型了； 而静态方法不需要对象实例来调用，是直接通过类名调用的，两者必须得区分开来写：并且在static后面再加一个&lt;K&gt;： 123456789101112131415public class Pair&lt;T&gt; { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { ... } public T getLast() { ... } // 静态泛型方法应该使用其他类型区分: public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) { return new Pair&lt;K&gt;(first, last); }} 3、多参数泛型 同样的操作方法： Java标准库的Map就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。 123456789101112public class Pair&lt;T, K&gt; { private T first; private K last; public Pair(T first, K last) { this.first = first; this.last = last; } public T getFirst() { ... } public K getLast() { ... }}Pair&lt;String, Integer&gt; p = new Pair&lt;&gt;(\"test\", 123); 四、擦拭法 Java语言的泛型实现方式是擦拭法（Type Erasure）。 擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。 Java使用擦拭法实现泛型，导致了： 编译器把类型&lt;T&gt;视为Object； 编译器根据&lt;T&gt;实现安全的强制转型。 1、擦拭法过程编译器看到的代码： 123Pair&lt;String&gt; p = new Pair&lt;&gt;(\"Hello\", \"world\");String first = p.getFirst();String last = p.getLast(); 虚拟机看到的代码： 123Pair p = new Pair(\"Hello\", \"world\");String first = (String) p.getFirst();String last = (String) p.getLast(); 2、擦拭法实现泛型的局限 &lt;T&gt;不能是基本类型（必须是引用类型，因为会被编译器处理为Object） 无法取得带泛型的Class（获取到的Class是类的Class） 无法使用instanceof判断类型关系（同上一点原因） 不能实例化T类型 12345678910111213141516// 第一点：int和Object矛盾Pair&lt;int&gt; p = new Pair&lt;&gt;(1, 2); // compile error!// 第二点：都是Pair.class...Pair&lt;String&gt; p1 = new Pair&lt;&gt;(\"Hello\", \"world\");Pair&lt;Integer&gt; p2 = new Pair&lt;&gt;(123, 456);Class c1 = p1.getClass();Class c2 = p2.getClass();System.out.println(c1==c2); // trueSystem.out.println(c1==Pair.class); // true// 第三点：同第二点:Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);// Compile error:if (p instanceof Pair&lt;String&gt;.class) {} 第四点：创建new Pair&lt;String&gt;()和创建new Pair&lt;Integer&gt;()就全部成了Object，显然编译器要阻止这种类型不对的代码。 要实例化T类型，我们必须借助额外的Class&lt;T&gt;参数： 上述代码借助Class&lt;T&gt;参数并通过反射来实例化T类型，使用的时候，也必须传入Class&lt;T&gt; 1234567891011121314151617181920212223242526272829// 第四点：无法实例化public class Pair&lt;T&gt; { private T first; private T last; public Pair() { // Compile error: first = new T(); last = new T(); }}// 借助Class实例化：package com.hello;public class ClassInstance { public static void main(String[] args) throws Exception { PairOne&lt;String&gt; p = new PairOne&lt;&gt;(String.class); }}class PairOne &lt;T&gt; { public T first; public T second; PairOne(Class&lt;T&gt; clazz) throws Exception { first = clazz.newInstance(); second = clazz.newInstance(); }} 3、无法覆写 定义的equals(T t)方法实际上会被擦拭成equals(Object t)，而这个方法是继承自Object的，编译器会阻止一个实际上会变成覆写的泛型方法定义。 12345678910class PairOne &lt;T&gt; { // 无法覆写Object的方法:编译报错 public boolean equals(T t){ return this == t; } // 改名即可： public boolean equal(T t){ return this == t; }} 4、泛型继承 无法获取Pair&lt;T&gt;的T类型，即给定一个变量Pair&lt;String&gt; p，无法从p中获取到String类型。 但是，在父类是泛型类型的情况下，编译器就必须把类型T（对PairOne来说，也就是String类型）保存到子类的class文件中，不然编译器就不知道PairOne只能存取String这种类型。 在继承了泛型类型的情况下，子类可以获取父类的泛型类型。 实现方法如下； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.hello;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;public class ClassInstance { public static void main(String[] args) throws Exception { PairOne&lt;String&gt; p = new PairOne&lt;&gt;(String.class); // 获取父类的T类型： Class&lt;PairTwo&gt; cls = PairTwo.class; Type t = cls.getGenericSuperclass(); if(t instanceof ParameterizedType){ ParameterizedType pt = (ParameterizedType) t; Type[] types = pt.getActualTypeArguments(); Type firstType = types[0]; Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType; System.out.println(typeClass); } }}class PairOne &lt;T&gt; { public T first; public T second; PairOne(T first, T second){ this.first = first; this.second = second; } PairOne(Class&lt;T&gt; clazz) throws Exception { first = clazz.newInstance(); second = clazz.newInstance(); } // 无法覆写Object的方法 /*public boolean equals(T t){ return this == t; }*/ // 改名即可： public boolean equal(T t){ return this == t; }}class PairTwo extends PairOne&lt;String&gt;{ PairTwo(String first, String second) { super(first, second); }} Java 类型的结构图： 12345678910 ┌────┐ │Type│ └────┘ ▲ │ ┌────────────┬────────┴─────────┬───────────────┐ │ │ │ │┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐│Class││ParameterizedType││GenericArrayType││WildcardType│└─────┘└─────────────────┘└────────────────┘└────────────┘ 五、extends通配符 PairThree&lt;Number&gt;不是PairThree&lt;Ingeter&gt;的子类。 因为PairThree&lt;Number&gt;不是PairThree&lt;Ingeter&gt;的子类，因此，add(PairThree&lt;Number&gt;)不接受参数类型PairThree&lt;Integer&gt;。 1、无继承关系无法传参1234567891011121314151617181920212223242526272829303132333435package com.hello;public class Extends { public static void main(String[] args) { PairThree&lt;Number&gt; p = new PairThree&lt;&gt;(23, 89); System.out.println(add(p)); PairThree&lt;Integer&gt; i = new PairThree&lt;&gt;(23, 89); System.out.println(add(i));// 编程错误 } static int add(PairThree&lt;Number&gt; p){ Number first = p.getA(); Number second = p.getB(); return first.intValue() + second.intValue(); }}class PairThree &lt;T&gt; { private T a; private T b; public PairThree(T a, T b){ this.a = a; this.b = b; } public T getA() { return a; } public T getB() { return b; }} 很明显这里没什么毛病，属于向上转型，因为Integer向上转型为Number! 但是问题在add方法的参数上，PairThree&lt;Number&gt;是不可能接受PairThree&lt;Integer&gt;的，毕竟没有继承关系。。。 12Number first = p.getA();Number last = p.getB(); 2、通过extends通配符传继承子类 Java中的通配符：? 只要是Number的子类就可以进行传参： 使用&lt;? extends Number&gt;的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number了。 12345static int add(PairThree&lt;? extends Number&gt; p){ Number first = p.getA(); Number second = p.getB(); return first.intValue() + second.intValue();} 下面的赋值是无法通过的！ 编译器只是知道传入的是Number或其子类，并不知道到底是谁，具体类型无法确定！无法完成赋值！ 1Integer x = p.getFirst(); 3、extends通配符处理set方法 如此效果，也就是你只能对其进行获取，不能进行修改，极大保证了数据安全性！ 1234567891011static int addOne(PairThree&lt;? extends Number&gt; p){ Number first = p.getA(); Number second = p.getB(); // 当前p类型为PairThree&lt;? extends Number&gt; 无法传入除null之外的其他类型 // 报错 //p.setA(new Integer(123)); //p.setB(new Integer(345)); p.setA(null);// ok, 但是后面会抛出NullPointerException p.getA().intValue(); // NullPointerException return p.getA().intValue()+ p.getB().intValue();} 4、extends通配符作用 当然和上一点的安全性脱不了关系： 方法使用了通配符参数，有什么用呢？ 优点： 允许调用get()方法获取Integer的引用； 不允许调用set(? extends Integer)方法并传入任何Integer的引用（null除外）。 即通过通配符参数实现了List类的只读效果，保证了安全！ 123456789101112131415public interface List&lt;T&gt; { int size(); // 获取个数 T get(int index); // 根据索引获取指定元素 void add(T t); // 添加一个新元素 void remove(T t); // 删除一个已有元素}int sumOfList(List&lt;? extends Integer&gt; list) { int sum = 0; for (int i=0; i&lt;list.size(); i++) { Integer n = list.get(i); sum = sum + n; } return sum;} 5、使用extends通配符限定T类型 则在定义时只能是Number及其子类！ 其他类型将无法通过编译： 1public class Pair&lt;T extends Number&gt; { ... } 六、super通配符 和extends相反，extends通配符可以接收当前类以及子类，super通配符可以接收当前类及其父类： 但是无法通过当前类或其他类来接收当前获取到的值，除了Object对象： 很好理解：当前类型p是Integer本身或其父类，编译器无法确定到底是和类型，无法用一个Integer来接收Number，当然Object是可以接收的，所有类型都可以向上转型为Object对象！ 1、只能写不能读使用&lt;? super Integer&gt;通配符表示： 允许调用set(? super Integer)方法传入Integer的引用； 不允许调用get()方法获得Integer的引用。 唯一例外是可以获取Object的引用：Object o = p.getFirst()。 换句话说，使用&lt;? super Integer&gt;通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.hello;public class Super { public static void main(String[] args) { PairFive&lt;Integer&gt; p1 = new PairFive&lt;&gt;(123, 567); PairFive&lt;Number&gt; p2 = new PairFive&lt;&gt;(34, 69); setName(p1, 100); setName(p2, 200); System.out.println(p1.getA()); // 100 System.out.println(p2.getA()); // 200 } static void setName(PairFive&lt;? super Integer&gt; p, Integer n){ // 唯一可接受get方法的是Object Object oc = p.getA(); // 这样无法接收： Number nc = p.getA(); Integer ic = p.getA(); p.setA(n); p.setB(n); }}class PairFive &lt;T&gt; { private T a; private T b; public PairFive(T a, T b){ this.a = a; this.b = b; } public void setA(T a) { this.a = a; } public void setB(T b) { this.b = b; } public T getA() { return a; } public T getB() { return b; }} 2、extends 与 super 区别作为方法参数，&lt;? super T&gt;类型和&lt;? extends T&gt;类型的区别在于： &lt;? extends T&gt;允许调用读方法T get()获取T的引用，但不允许调用写方法set(T)传入T的引用（传入null除外）； &lt;? super T&gt;允许调用写方法set(T)传入T的引用，但不允许调用读方法T get()获取T的引用（获取Object除外）。 一个是允许读不允许写，另一个是允许写不允许读。 一个很好的例子： 作用：将src的元素全部添加到dest中： 这个copy()方法的定义就完美地展示了extends和super的意图： copy()方法内部不会读取dest，因为不能调用dest.get()来获取T的引用； copy()方法内部也不会修改src，因为不能调用src.add(T)。 倘若意外修改了src，或者意外读取了dest，就会导致一个编译错误： 12345678910111213141516171819202122232425package com.hello;import java.util.List;public class CollectionsTest { public static void main(String[] args) { }}class CollectionsDemo { // 把src的每个元素复制到dest中: public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { // 下面的循环可以用这句话替代： // dest.addAll(src); for (int i=0; i&lt;src.size(); i++) { T t = src.get(i); dest.add(t); } // 无法实现： T t = dest.get(0); // compile error! src.add(t); // compile error! }} 当然，也无法反过来添加： 这些都是通过super和extends通配符，并由编译器强制检查来实现的。 1234567// copy List&lt;Integer&gt; to List&lt;Number&gt; ok:List&lt;Number&gt; numList = ...;List&lt;Integer&gt; intList = ...;CollectionDemo.copy(numList, intList);// ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;:CollectionDemo.copy(intList, numList); 3、PECS 原则 何时使用extends，何时使用super？ 为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。 如果需要返回T，它是生产者（Producer），要使用extends通配符；如果需要写入T，它是消费者（Consumer），要使用super通配符。 任然使用这个例子： 12345678public class Collections { public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { for (int i=0; i&lt;src.size(); i++) { T t = src.get(i); // src是producer dest.add(t); // dest是consumer } }} 4、无界定通配符 即只定义一个&lt;?&gt;： 因为&lt;?&gt;通配符既没有extends，也没有super，因此： 不允许调用set(T)方法并传入引用（null除外）； 不允许调用T get()方法并获取T引用（只能获取Object引用）。 换句话说，既不能读，也不能写，那只能做一些null判断： 123static boolean isNull(Pair&lt;?&gt; p){ return p.getFirst() == null || p.getSecond() == null;} 大多数情况下，可以引入泛型参数&lt;T&gt;消除&lt;?&gt;通配符：(一般这样使用) 123static &lt;T&gt; boolean isNull(Pair&lt;T&gt; p) { return p.getFirst() == null || p.getSecond() == null;} &lt;?&gt;通配符有一个独特的特点，就是：Pair&lt;?&gt;是所有Pair&lt;T&gt;的超类(即父类)： 5、super通配符不能用于class 无法这样写： extends可以！ 123class demo &lt;T super Number&gt; {} 七、泛型与反射1、Class&lt;T&gt;是泛型123456789// 编译警告：可运行Class cls = String.class;String str0 = (String)cls.newInstance();// 无问题：Class&lt;String&gt; cl = String.class;String str = cl.newInstance();Class&lt;? super String&gt; sup = String.class.getSuperclass(); 2、Constructor&lt;T&gt;是泛型1234Class&lt;Integer&gt; clazz = Integer.class;Constructor&lt;Integer&gt; cons = clazz.getConstructor(int.class);Integer i = cons.newInstance(123);System.out.println(i); // 123 3、泛型数组创建 不能用new操作符创建带泛型的数组： 必须通过强制转型实现带泛型的数组： 可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型： 123456Pair&lt;String&gt;[] ps = null; // okPair&lt;String&gt;[] ps1 = new Pair&lt;String&gt;[2]; // compile error!// 正确使用：@SuppressWarnings(\"unchecked\")Pair&lt;String&gt;[] ps2 = (Pair&lt;String&gt;[]) new Pair[2]; 可以通过Array.newInstance(Class, int)创建T[]数组，需要强制转型： 廖雪峰教程，有点没看懂，以后再看！。。。 4、谨慎使用泛型可变参数 如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。 直接调用asArray(T...)似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生ClassCastException，原因还是因为擦拭法，在pickTwo()方法内部，编译器无法检测K[]的正确类型，因此返回了Object[]。 如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用@SafeVarargs消除警告。 12345678910111213141516171819202122package com.learn.java;import java.util.Arrays;public class Main01 { public static void main(String[] args) { String[] arr = asArray(\"one\", \"two\", \"three\"); System.out.println(Arrays.toString(arr)); // ClassCastException: String[] firstTwo = pickTwo(\"one\", \"two\", \"three\"); System.out.println(Arrays.toString(firstTwo)); } static &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) { return asArray(k1, k2); } @SafeVarargs static &lt;T&gt; T[] asArray(T... objs) { return objs; }} 输出结果： 123[one, two, three]Exception in thread \"main\" java.lang.ClassCastException: class [Ljava.lang.Object; cannot be cast to class [Ljava.lang.String; ([Ljava.lang.Object; and [Ljava.lang.String; are in module java.base of loader 'bootstrap') at com.learn.java.Main01.main(Main01.java:10) 泛型章节终于结束，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"泛型","slug":"泛型","permalink":"https://www.itnxd.cn/tags/%E6%B3%9B%E5%9E%8B/"}],"author":"Mr.Niu"},{"title":"Java教程系列之注解","slug":"Java教程系列之注解","date":"2020-04-02T09:50:48.000Z","updated":"2020-05-19T02:01:30.333Z","comments":true,"path":"posts/35258.html","link":"","permalink":"https://www.itnxd.cn/posts/35258.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、什么是注解 注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释” 注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。 注解的作用 从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定： Java的注解可以分为三类： 由编译器使用的注解 由工具处理.class文件使用的注解 在程序运行期能够读取的注解 第一类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。 第二类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。 第三类加载后一直存在于JVM中，这也是最常用的注解 注解的参数： 所有基本类型； String； 枚举类型； 基本类型、String以及枚举的数组。 因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。 注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。 此外，大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。 如果只写注解，相当于全部使用默认值。 二、定义注解1、如何定义注解（Annotation） 用@interface定义注解 添加参数、默认值 用元注解配置注解 必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。 注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。 12345678910// 第三步：@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)// 第一步：public @interface Report { // 第二步： int type() default 0; String level() default \"info\"; String value() default \"\";} 2、元注解 有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。 target 使用@Target可以定义Annotation能够被应用于源码的哪些位置： 实际上@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法。 类或接口：ElementType.TYPE； 字段：ElementType.FIELD； 方法：ElementType.METHOD； 构造方法：ElementType.CONSTRUCTOR； 方法参数：ElementType.PARAMETER。 123456789// 一个参数：@Target(ElementType.METHOD)// 多个参数：@Target({ElementType.TYPE, ElementType.METHOD})public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\";} Retention 定义了Annotation的生命周期： 如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解 仅编译期：RetentionPolicy.SOURCE； 仅class文件：RetentionPolicy.CLASS； 运行期：RetentionPolicy.RUNTIME。 123456@Retention(RetentionPolicy.RUNTIME)public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\";} Repeatable 可以定义Annotation是否可重复。这个注解应用不是特别广泛。 123456789101112131415161718192021222324// 参数为重复类的Class@Repeatable(Hellos.class)//@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE, ElementType.METHOD})@interface Hello { int type() default 0; String level() default \"info\"; String value() default \"\";}@Target(ElementType.TYPE)@interface Hellos{ Hello[] value();}// 重复注解：@Hello(type = 1, level = \"debug\", value = \"test\")@Hello(type = 2, level = \"warning\", value = \"warn\")@Hello(type = 3, value = \"niu\")class Test{} Inherited 使用@Inherited定义子类是否可继承父类定义的Annotation。 @Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效 123456789101112131415161718@Inherited@Target(ElementType.TYPE)@interface Hello { int type() default 0; String level() default \"info\"; String value() default \"\";}@Hello(type = 1, level = \"debug\", value = \"test\")class Test{}class TestSon extends Test{} 三、处理注解根据@Retention的配置 如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。 只有RUNTIME类型的注解不但要使用，还经常需要编写。 因此，我们只讨论如何读取RUNTIME类型的注解。 注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。 1、使用反射读取注解Java提供的使用反射API读取Annotation的方法包括： 判断某个注解是否存在于Class、Field、Method或Constructor： Class.isAnnotationPresent(Class) Field.isAnnotationPresent(Class) Method.isAnnotationPresent(Class) Constructor.isAnnotationPresent(Class) 使用反射API读取Annotation： Class.getAnnotation(Class) Field.getAnnotation(Class) Method.getAnnotation(Class) Constructor.getAnnotation(Class) 先判断Annotation是否存在再读取注解及类的定义： 12345678910111213141516171819@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@interface Hello { int type() default 0; String level() default \"info\"; String value() default \"\";}@Target(ElementType.TYPE)@interface Hellos{ Hello[] value();}@Hello(type = 1, level = \"debug\", value = \"test\")class Test{} 1234567Class cls = Test.class;if(cls.isAnnotationPresent(Hello.class)){ Hello hello = (Hello) cls.getAnnotation(Hello.class); System.out.println(hello.level()); // debug System.out.println(hello.type()); // 1 System.out.println(hello.value()); // test} 直接读取Annotation，不存在返回null1234567Class cls1 = Test.class;Hello hello = (Hello) cls1.getAnnotation(Hello.class);if(hello != null){ System.out.println(hello.level()); // debug System.out.println(hello.type()); // 1 System.out.println(hello.value()); // test} 读取方法参数的注解 有点没看懂。。先搁这里！点击这里查看！ 2、注解的使用 注解好处：再需要检查的字段或方法前加上再写一个Check方法即可实现所有检查！ 提高了效率： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.hello;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.lang.reflect.Field;public class Annotation1 { public static void main(String[] args){ Person p1 = new Person(\"niuge\", \"xinzhou\"); Person p2 = new Person(\"niuge\", \"shanxixinzhou\"); for(Person p : new Person[]{p1, p2}){ try{ Check(p); System.out.println(\"String 参数无误！\"); }catch (IllegalAccessException e){ System.out.println(\"String 参数有误！\" + e.toString()); } } } static void Check(Person p) throws IllegalAccessException { // 获取Person实例p的每个字段field for(Field field : p.getClass().getFields()){ // 获取每个字段的注解 Range range = field.getAnnotation(Range.class); // 注解存在时 if(range != null){ // 获取当前字段的值 Object value = field.get(p); // 是String类型时： if(value instanceof String){ String s = (String) value; // 判断是否符合范围Range if(s.length() &lt; range.min() || s.length() &gt; range.max()){ throw new IllegalAccessException(\"String 有误！(Check函数抛出)\"); } } } } }}@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)@interface Range{ int min() default 0; int max() default 0x3f;}class Person{ @Range(min = 1, max = 20) public String name; @Range(max = 10) public String city; public Person(String name, String city){ this.name = name; this.city = city; }} 输出结果： 12String 参数无误！String 参数有误！java.lang.IllegalAccessException: String 有误！(Check函数抛出) 注解已经完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://www.itnxd.cn/tags/%E6%B3%A8%E8%A7%A3/"}],"author":"Mr.Niu"},{"title":"Java教程系列之反射","slug":"Java教程系列之反射","date":"2020-04-01T10:05:20.000Z","updated":"2021-02-06T14:07:49.347Z","comments":true,"path":"posts/39487.html","link":"","permalink":"https://www.itnxd.cn/posts/39487.html","excerpt":"","text":"一、什么是反射反射：Reflection 反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。 通过Class实例获取class信息的方法称为反射（Reflection）。 二、Class类 class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。 每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来！ 这里的Class类型是一个名叫Class的class。。。。 1、以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来 2、Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。 3、此处为JVM自动创建，是一个私有类！ 1Class cls = new Class(String); 一个Class实例包含了该class的所有完整信息！ 由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。 这种通过Class实例获取class信息的方法称为反射（Reflection）。 1、创建CLass 直接通过一个class的静态变量class获取： 通过该实例变量提供的getClass()方法获取： 通过静态方法Class.forName()获取，参数为完整类名： 因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。可以用==比较两个Class实例： 12345String s = \"\";Class cls = String.class;Class cls1 = s.getClass();Class cls2 = Class.forName(\"java.lang.String\");System.out.println(cls == cls1); 2、== 和 instanceof() instanceof可以判断子类及继承关系！ ==可以用来精确判断类的类型！ 通常情况下，我们应该用instanceof判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个class的时候，我们才使用==判断class实例。 1234567Integer n = new Integer(123);boolean b1 = n instanceof Integer; // true，因为n是Integer类型boolean b2 = n instanceof Number; // true，因为n是Number类型的子类boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.classboolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class 3、通过Class来获取相关信息1234567891011121314151617181920212223242526package com.test;public class reflection { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException { printClassInfo(\"\".getClass()); printClassInfo(Runnable.class); printClassInfo(java.time.Month.class); printClassInfo(String[].class); printClassInfo(int.class); System.out.println(\"end\"); } static void printClassInfo(Class cls) { System.out.println(\"Class name: \" + cls.getName()); System.out.println(\"Simple name: \" + cls.getSimpleName()); if (cls.getPackage() != null) { System.out.println(\"Package name: \" + cls.getPackage().getName()); } System.out.println(\"is interface: \" + cls.isInterface()); System.out.println(\"is enum: \" + cls.isEnum()); System.out.println(\"is array: \" + cls.isArray()); System.out.println(\"is primitive: \" + cls.isPrimitive()); }} 输出结果： 数组（例如String[]）也是一种Class，而且不同于String.class，它的类名是[Ljava.lang.String 1234567891011121314151617181920212223242526272829303132333435Class name: java.lang.StringSimple name: StringPackage name: java.langis interface: falseis enum: falseis array: falseis primitive: falseClass name: java.lang.RunnableSimple name: RunnablePackage name: java.langis interface: trueis enum: falseis array: falseis primitive: falseClass name: java.time.MonthSimple name: MonthPackage name: java.timeis interface: falseis enum: trueis array: falseis primitive: false// 特殊：String 类型的数组Class name: [Ljava.lang.String;Simple name: String[]is interface: falseis enum: falseis array: trueis primitive: falseClass name: intSimple name: intis interface: falseis enum: falseis array: falseis primitive: trueend 4、动态加载 JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载： 当执行Main.java时，由于用到了Main，因此，JVM首先会把Main.class加载到内存。然而，并不会加载Person.class，除非程序执行到create()方法，JVM发现需要加载Person类时，才会首次加载Person.class。如果没有执行create()方法，那么Person.class根本就不会被加载。 1234567891011121314151617181920package com.test;public class reflectionTest { public static void main(String[] args) { if(args.length &gt; 0){ create(args[0]); } } static void create(String name){ Person1 p = new Person1(name); }}class Person1{ public String name; public Person1(String name){ this.name = name; }} 5、Log的动态加载 动态加载class的特性对于Java程序非常重要。利用JVM动态加载class的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下： 所以我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。 12345678910111213141516// Commons Logging优先使用Log4j:LogFactory factory = null;if (isClassPresent(\"org.apache.logging.log4j.Logger\")) { factory = createLog4j();} else { factory = createJdkLog();}boolean isClassPresent(String name) { try { Class.forName(name); return true; } catch (Exception e) { return false; }} 三、访问字段1、访问字段 Field getField(name)：根据字段名获取某个public的field（包括父类） Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类） Field[] getFields()：获取所有public的field（包括父类） Field[] getDeclaredFields()：获取当前类的所有field（不包括父类） 1234567891011121314151617181920public class Main { public static void main(String[] args) throws Exception { Class stdClass = Student.class; // 获取public字段\"score\": System.out.println(stdClass.getField(\"score\")); // 获取继承的public字段\"name\": System.out.println(stdClass.getField(\"name\")); // 获取private字段\"grade\": System.out.println(stdClass.getDeclaredField(\"grade\")); }}class Student extends Person { public int score; private int grade;}class Person { public String name;} 123public int Student.scorepublic java.lang.String Person.nameprivate int Student.grade 2、field对象方法一个Field对象包含了一个字段的所有信息： getName()：返回字段名称，例如，\"name\"； getType()：返回字段类型，也是一个Class实例，例如，String.class； getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。 String类的value字段如下定义： 123public final class String { private final byte[] value;} 获取所有信息： 12345678910111213141516171819package com.test;import java.lang.reflect.Field;import java.lang.reflect.Modifier;public class field { public static void main(String[] args) throws Exception { Field f = String.class.getDeclaredField(\"value\"); System.out.println(f.getName()); // \"value\" System.out.println(f.getType()); // class [B 表示byte[]类型 int m = f.getModifiers(); System.out.println(m); // 18 System.out.println(Modifier.isFinal(m)); // true System.out.println(Modifier.isPublic(m)); // false System.out.println(Modifier.isProtected(m)); // false System.out.println(Modifier.isPrivate(m)); // true System.out.println(Modifier.isStatic(m)); // false }} 3、获取字段值 先获取Class实例： 再获取Field实例： 然后，用Field.get(Object)获取指定实例的指定字段的值。 123456789101112131415161718192021package com.test;import java.lang.reflect.Field;public class getField { public static void main(String[] args) throws Exception { Object p = new Person3(\"Xiao Ming\"); Class c = p.getClass(); Field f = c.getDeclaredField(\"name\"); Object value = f.get(p); System.out.println(value); // \"Xiao Ming\" }}class Person3{ // public字段 public String name; public Person3(String name){ this.name = name; }} private字段main类是无法访问的： 直接访问会得到一个IllegalAccessException！ 解决方法： 在调用Object value = f.get(p);前，先写一句： 1f.setAccessible(true); 调用Field.setAccessible(true)的意思是，别管这个字段是不是public，一律允许访问。 如果使用反射可以获取private字段的值，那么类的封装还有什么意义？ 答案是正常情况下，我们总是通过p.name来访问Person的name字段，编译器会根据public、protected和private决定是否允许访问字段，这样就达到了数据封装的目的。 而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。 此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 修改如下： 123456789101112131415161718192021package com.test;import java.lang.reflect.Field;public class getField { public static void main(String[] args) throws Exception { Object p = new Person3(\"Xiao Ming\"); Class c = p.getClass(); Field f = c.getDeclaredField(\"name\"); f.setAccessible(true); Object value = f.get(p); System.out.println(value); // \"Xiao Ming\" }}class Person3{ private String name; public Person3(String name){ this.name = name; }} 4、设置字段值 设置字段值是通过Field.set(Object, Object)实现的，其中第一个Object参数是指定的实例，第二个Object参数是待修改的值： 修改非public字段，需要首先调用setAccessible(true)。 123456789101112131415161718192021222324252627package com.test;import java.lang.reflect.Field;public class getField { public static void main(String[] args) throws Exception { Person3 p = new Person3(\"Xiao Ming\"); System.out.println(p.getName()); Class c = p.getClass(); Field f = c.getDeclaredField(\"name\"); f.setAccessible(true); //Object value = f.get(p); f.set(p, \"Xiao Hong\"); System.out.println(p.getName()); // \"Xiao Hong\" }}class Person3{ private String name; public Person3(String name){ this.name = name; } public String getName() { return name; }} 四、调用方法1、调用方法我们已经能通过Class实例获取所有Field对象，同样的，可以通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method： Method getMethod(name, Class...)：获取某个public的Method（包括父类） Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类） Method[] getMethods()：获取所有public的Method（包括父类） Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类） 12345678910111213141516171819202122232425262728package com.test;public class method { public static void main(String[] args) throws Exception { Class stdClass = Students.class; // 获取public方法getScore，参数为String: System.out.println(stdClass.getMethod(\"getScore\", String.class)); // 获取继承的public方法getName，无参数: System.out.println(stdClass.getMethod(\"getName\")); // 获取private方法getGrade，参数为int: System.out.println(stdClass.getDeclaredMethod(\"getGrade\", int.class)); }}class Students extends Person4 { public int getScore(String type) { return 99; } private int getGrade(int year) { return 1; }}class Person4 { public String getName() { return \"Person\"; }} 输出结果： 123public int com.test.Students.getScore(java.lang.String)public java.lang.String com.test.Person4.getName()private int com.test.Students.getGrade(int) 2、method对象方法一个Method对象包含一个方法的所有信息： getName()：返回方法名称，例如：\"getScore\"； getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class； getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}； getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。 3、调用方法用反射来调用substring方法： 对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。 1234567891011121314151617package com.test;import java.lang.reflect.Method;public class getMethod { public static void main(String[] args) throws Exception{ // String对象: String s = \"Hello world\"; // 获取String substring(int)方法，参数为int: Method m = String.class.getMethod(\"substring\", int.class); System.out.println(m); // 在s对象上调用该方法并获取结果: String r = (String) m.invoke(s, 6); // 打印调用结果: System.out.println(r); }} 输出结果如下： 12public java.lang.String java.lang.String.substring(int)world 4、调用静态方法 如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null。 1234567891011121314package com.test;import java.lang.reflect.Method;public class Main { public static void main(String[] args) throws Exception { // 获取Integer.parseInt(String)方法，参数为String: Method m = Integer.class.getMethod(\"parseInt\", String.class); // 调用该静态方法并获取结果: Integer n = (Integer) m.invoke(null, \"12345\"); // 打印调用结果: System.out.println(n); // 12345 }} 5、调用非public方法 和Field类似，对于非public方法，我们虽然可以通过Class.getDeclaredMethod()获取该方法实例，但直接对其调用将得到一个IllegalAccessException。为了调用非public方法，我们通过Method.setAccessible(true)允许其调用： 此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 12345678910111213141516171819202122package com.test;import java.lang.reflect.Method;public class Main { public static void main(String[] args) throws Exception { Person p = new Person(); Method m = p.getClass().getDeclaredMethod(\"setName\", String.class); // 关键点： m.setAccessible(true); m.invoke(p, \"Bob\"); System.out.println(p.name); }}class Person { String name; private void setName(String name) { this.name = name; }} 6、多态 我们来考察这样一种情况：一个Person类定义了hello()方法，并且它的子类Student也覆写了hello()方法，那么，从Person.class获取的Method，作用于Student实例时，调用的方法到底是哪个？ 12345678910111213141516171819202122232425package com.test;import java.lang.reflect.Method;public class Main { public static void main(String[] args) throws Exception { // 获取Person的hello方法: Method h = Person.class.getMethod(\"hello\"); // 对Student实例调用hello方法: h.invoke(new Student()); //Student:hello }}class Person { public void hello() { System.out.println(\"Person:hello\"); }}class Student extends Person { public void hello() { System.out.println(\"Student:hello\"); }} 使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在） 123456Method m = Person.class.getMethod(\"hello\");m.invoke(new Student());// 相当于：Person p = new Student();p.hello(); 7、链式编程123456789// 普通方法：Method m1 = Integer.class.getMethod(\"parseInt\", String.class);Integer n = (Integer) m1.invoke(null, \"12345\");System.out.println(n);// 链式编程：Integer n = (Integer) Integer.class.getMethod(\"parseInt\", String.class).invoke(null, \"123456\");// 打印调用结果:System.out.println(n); 五、调用构造方法1、通过调用Class提供的newInstance()方法来创建构造方法实例 调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。 1Person p = Person.class.newInstance(); 2、通过调用Java的反射API提供了Constructor对象来创建构造方法实例通过Class实例获取Constructor的方法如下： getConstructor(Class...)：获取某个public的Constructor； getDeclaredConstructor(Class...)：获取某个Constructor； getConstructors()：获取所有public的Constructor； getDeclaredConstructors()：获取所有Constructor。 注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。 调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。 Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例： 12345678910111213141516import java.lang.reflect.Constructor;public class Main { public static void main(String[] args) throws Exception { // 获取构造方法Integer(int): Constructor cons1 = Integer.class.getConstructor(int.class); // 调用构造方法: Integer n1 = (Integer) cons1.newInstance(123); System.out.println(n1); // 123 // 获取构造方法Integer(String) Constructor cons2 = Integer.class.getConstructor(String.class); Integer n2 = (Integer) cons2.newInstance(\"456\"); System.out.println(n2); // 456 }} 六、获取继承关系1、获取父类Class 使用getSuperclass()方法： 12345678910public class Main { public static void main(String[] args) throws Exception { Class i = Integer.class; Class n = i.getSuperclass(); System.out.println(n); Class o = n.getSuperclass(); System.out.println(o); System.out.println(o.getSuperclass()); }} 输出结果： Integer的父类类型是Number，Number的父类是Object，Object的父类是null。 除Object外，其他任何非interface的Class都必定存在一个父类类型。 123class java.lang.Numberclass java.lang.Objectnull 2、获取接口Interface 使用getInterfaces()方法： 如果一个类没有实现任何interface，那么getInterfaces()返回空数组。 12345678910public class Main { public static void main(String[] args) throws Exception { Class s = Integer.class; Class[] is = s.getInterfaces(); for (Class i : is) { System.out.println(i); } }} 输出结果： 可知Integer有以下三个接口： 123interface java.lang.Comparableinterface java.lang.constant.Constableinterface java.lang.constant.ConstantDesc 要特别注意：getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型： 12345678910public class Main { public static void main(String[] args) throws Exception { Class s = Integer.class.getSuperclass(); System.out.println(s); Class[] is = s.getInterfaces(); for (Class i : is) { System.out.println(i); } }} 输出结果如下： 可知Number的接口只有下面这一个： 12class java.lang.Numberinterface java.io.Serializable 接口使用getSuperclass()方法永远返回null： 3、Class的继承关系 判断普通实例使用instanceof ()方法： 判断Class实例使用isAssignableFrom()方法： 可以这样简单理解：括号内的是否继承自外面的！ 12345678// Integer i = ?Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer// Number n = ?Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number// Object o = ?Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object// Integer i = ?Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer 七、动态代理（Dynamic Proxy）1、class 和 interfaceclass和interface的区别： 可以实例化class（非abstract）； 不能实例化interface。 2、静态代理实现 定义接口 编写实现类 创建实例转型为接口并调用 123456789101112131415161718package com.test;public class DynamicProxy { public static void main(String[] args) { Hello hello = new HelloWorlds(); hello.morning(\"Bob\"); }}class HelloWorlds implements Hello { public void morning(String name) { System.out.println(\"Good morning, \" + name); }}interface Hello { void morning(String name);} 3、动态代理实现在运行期动态创建一个interface实例的方法如下： 定义一个InvocationHandler实例，它负责实现接口的方法调用； 通过Proxy.newProxyInstance() 创建interface实例，它需要3个参数： 使用的ClassLoader，通常就是接口类的ClassLoader； 需要实现的接口数组，至少需要传入一个接口进去； 用来处理接口方法调用的InvocationHandler实例。 将返回的Object强制转型为接口。 ClassLoader，它是类加载器，用来将.class字节码加载转换成class类对象的！ InvocationHandler相当于：第一个参数传入了创建的实例hello，第二个参数传入了Hello的抽象方法morning，第三个参数传入了抽象方法morning的参数BOb。 1234567891011121314151617181920212223242526272829package com.test;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class DynamicProxy { public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); if (method.getName().equals(\"morning\")) { System.out.println(\"Good morning, \" + args[0]); } return null; } }; Hello1 hello = (Hello1) Proxy.newProxyInstance( Hello1.class.getClassLoader(), // 传入ClassLoader new Class[] { Hello1.class }, // 传入要实现的接口 handler); // 传入处理调用方法的InvocationHandler hello.morning(\"Bob\"); }}interface Hello1 { void morning(String name);} 输出结果： 12public abstract void com.test.Hello1.morning(java.lang.String)Good morning, Bob 4、动态代理实际实现方法 动态代理实际上是JDK在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样： 其实就是JDK帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。 目前我还不太会调用。。。 123456789101112public class HelloDynamicProxy implements Hello { InvocationHandler handler; public HelloDynamicProxy(InvocationHandler handler) { this.handler = handler; } public void morning(String name) { handler.invoke( this, Hello.class.getMethod(\"morning\"), new Object[] { name }); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"反射","slug":"反射","permalink":"https://www.itnxd.cn/tags/%E5%8F%8D%E5%B0%84/"}],"author":"Mr.Niu"},{"title":"Java教程系列之异常处理","slug":"Java教程系列之异常处理","date":"2020-03-30T11:55:07.000Z","updated":"2021-02-06T14:19:01.514Z","comments":true,"path":"posts/19314.html","link":"","permalink":"https://www.itnxd.cn/posts/19314.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、Java的异常1、异常的来源1.1 来源 用户输入造成 随机出现的错误 网络突然断了，连接不到远程服务器； 内存耗尽，程序崩溃了； 用户点“打印”，但根本没有打印机； …… 1.2 处理错误的方法 方法一：约定返回错误码。 例如，处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码： 因为使用int类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。 一般不这样处理！ 1234567891011121314int code = processFile(\"C:\\\\test.txt\");if (code == 0) { // ok:} else { // error: switch (code) { case 1: // file not found: case 2: // no read permission: default: // unknown error: }} 方法二：在语言层面上提供一个异常处理机制。 Java内置了一套异常处理机制，总是使用异常来表示错误。 异常是一种class，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了！ 使用的是try...catch...语句： 123456789101112try { String s = processFile(“C:\\\\test.txt”); // ok:} catch (FileNotFoundException e) { // file not found:} catch (SecurityException e) { // no read permission:} catch (IOException e) { // io error:} catch (Exception e) { // other error:} 1.3 异常的继承关系1234567891011121314151617181920212223242526 ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Throwable │ └───────────┘ ▲ ┌─────────┴─────────┐ │ │ ┌───────────┐ ┌───────────┐ │ Error │ │ Exception │ └───────────┘ └───────────┘ ▲ ▲ ┌───────┘ ┌────┴──────────┐ │ │ │┌─────────────────┐ ┌─────────────────┐┌───────────┐│OutOfMemoryError │... │RuntimeException ││IOException│...└─────────────────┘ └─────────────────┘└───────────┘ ▲ ┌───────────┴─────────────┐ │ │ ┌─────────────────────┐ ┌─────────────────────────┐ │NullPointerException │ │IllegalArgumentException │... └─────────────────────┘ └─────────────────────────┘ Throwable是异常体系的根，它继承自Object。Throwable有两个体系：Error和Exception，Error表示严重的错误，程序对此一般无能为力： OutOfMemoryError：内存耗尽 NoClassDefFoundError：无法加载某个Class StackOverflowError：栈溢出 而Exception则是运行时的错误，它可以被捕获并处理！ 某些异常是应用程序逻辑处理的一部分，应该捕获并处理！ 还有一些异常是程序逻辑编写不对造成的，应该修复程序本身！ NumberFormatException：数值类型的格式错误 FileNotFoundException：未找到文件 SocketException：读取网络失败 NullPointerException：对某个null的对象调用方法或字段 IndexOutOfBoundsException：数组索引越界 Exception分为两大类： RuntimeException以及它的子类； 非RuntimeException（包括IOException、ReflectiveOperationException等等） 1.4 哪些异常需要处理Java规定： 必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。 不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。 2、捕获异常（catch） 捕获异常使用try...catch语句，把可能发生异常的代码放到try {...}中，然后使用catch捕获对应的Exception及其子类！ 2.1 方法内部使用try catch捕获 不去捕获错误会发生编译错误： 12345Main.java:15: 错误: 未报告的异常错误UnsupportedEncodingException; 必须对其进行捕获或声明以便抛出 return s.getBytes(\"GBK\"); ^1 个错误错误: 编译失败 1234567891011121314151617181920212223package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); } public static byte[] toGBK(String s) { try { // 用指定编码转换String为byte[]: return s.getBytes(\"GBK\"); } catch (UnsupportedEncodingException e) { // 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException: System.out.println(e);// 打印错误信息 e.printStackTrace(); return s.getBytes();// 尝试使用用默认编码 } }} 来看一下String.getBytes(String)方法的定义： 在方法定义的时候，使用throws Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。 123public byte[] getBytes(String charsetName) throws UnsupportedEncodingException { ...} 2.2 方法定义处使用throws 在方法定义处用throws表示toGBK()方法可能会抛出UnsupportedEncodingException，就可以让toGBK()方法通过编译器检查： 告诉编译器可能会抛出错误，编译器会跳过检查该方法，但是会在main方法里面抛出异常： 12345Main.java:8: 错误: 未报告的异常错误UnsupportedEncodingException; 必须对其进行捕获或声明以便抛出 byte[] bs = toGBK(\"中文\"); ^1 个错误错误: 编译失败 123456789101112131415package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); } public static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); }} 做出修改如下： 修改一：在main方法内捕获异常： 12345678910111213141516171819package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) { try { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); }catch (UnsupportedEncodingException e) { System.out.println(e); } } public static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); }} 修改二：将main方法定义为throws Exception main()方法声明了可能抛出Exception，也就声明了可能抛出所有的Exception，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。 123456789101112131415package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) throws Exception { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); } public static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); }} 2.3 使用printStackTrace()打印异常栈 没有弄明白这样写为什么不会执行catch内部的语句。。。 1234567891011121314151617181920package com.test;import java.io.UnsupportedEncodingException;import java.util.Arrays;public class codeTest { public static void main(String[] args) { try { byte[] bs = toGBK(\"中国\"); System.out.println(Arrays.toString(bs)); }catch (UnsupportedEncodingException e) { System.out.println(e); e.printStackTrace(); } } public static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); }} 二、捕获异常1、多条catch语句 可以使用多个catch语句，每个catch分别捕获对应的Exception及其子类。JVM在捕获到异常后，会从上到下匹配catch语句，匹配到某个catch后，执行catch代码块，然后不再继续匹配。 多条catch语句只执行一个！ 由于从上到下匹配，所以catch语句要从子类开始写起，防止被一个父类直接截断！ 若将下方两个catch互换，则UnsupportedEncodingException根本无法执行，会被其父类IOException给截断！ 1234567891011public static void main(String[] args) { try { process1(); process2(); process3(); } catch (UnsupportedEncodingException e) { System.out.println(\"Bad encoding\"); } catch (IOException e) { System.out.println(\"IO error\"); }} 2、finally语句 无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？ 当然可以在每个catch语句都写一遍，显然这样很麻烦！ 所以引入一个finally语句，有无错误都会执行！ 可见，finally是用来保证一些代码必须执行的。 如果捕获异常跳转执行 catch 里面的语句块，return 先执行。finally 里面的代码总是最后执行。 注意finally的两个特点： finally语句不是必须的，可写可不写； finally总是最后执行。 执行流程： 如果没有发生异常，就正常执行try { ... }语句块，然后执行finally。如果发生了异常，就中断执行try { ... }语句块，然后跳转执行匹配的catch语句块，最后执行finally。 12345678910111213public static void main(String[] args) { try { process1(); process2(); process3(); } catch (UnsupportedEncodingException e) { System.out.println(\"Bad encoding\"); } catch (IOException e) { System.out.println(\"IO error\"); } finally { System.out.println(\"END\"); }} try...finally语句： 某些情况下，可以没有catch，只使用try ... finally结构！ 1234567void process(String file) throws IOException { try { ... } finally { System.out.println(\"END\"); }} 3、异常逻辑相同则合并 处理IOException和NumberFormatException的代码是相同的，所以我们可以把它两用|合并到一起： 1234567891011public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException | NumberFormatException e) { // IOException或NumberFormatException System.out.println(\"Bad input\"); } catch (Exception e) { System.out.println(\"Unknown error\"); }} 三、抛出异常 目的：是为了在代码执行发生错误的时候，停止，或者进行处理，以及抛出信息帮助程序员定位出现bug的位置！ 所以，需要在可能发生异常的地方，使用 throw 语句抛出异常！ 异常抛出之后，需要对异常进行捕获！ 1、异常的传播 当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try ... catch被捕获为止： 12345678910111213141516171819package com.test;public class codeTest { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { process2(); } static void process2() { Integer.parseInt(null); // 会抛出NumberFormatException }} 使用printStackTrace()方法打印方法的调用栈： printStackTrace()对于调试错误非常有用，下面信息表示：NumberFormatException是在java.lang.Integer.parseInt方法中被抛出的！ 123456789java.lang.NumberFormatException: null at java.base/java.lang.Integer.parseInt(Integer.java:614) at java.base/java.lang.Integer.parseInt(Integer.java:770) at com.test.codeTest.process2(codeTest.java:17) at com.test.codeTest.process1(codeTest.java:13) at com.test.codeTest.main(codeTest.java:6)Process finished with exit code 0 打印的是异常栈，是栈，所以从下往上看： main()调用process1()； process1()调用process2()； process2()调用Integer.parseInt(String)； Integer.parseInt(String)调用Integer.parseInt(String, int)。 2、抛出异常2.1 创建并抛出 创建某个Exception的实例； 用throw语句抛出。 通常会合并到一起来写： 12345678910111213void process2(String s) { if (s==null) { NullPointerException e = new NullPointerException(); throw e; }}// 合并写法：void process2(String s) { if (s==null) { throw new NullPointerException(); }} 2.2 异常转换 如果一个方法捕获了某个异常后，又在catch子句中抛出新的异常，就相当于把抛出的异常类型“转换”了： 后者覆盖前者： 当process2()抛出NullPointerException后，被process1()捕获，然后抛出IllegalArgumentException()。 123456789101112131415161718192021public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(); } } static void process2() { throw new NullPointerException(); }} 2.3 传入原始Exception来保留原始Exception 捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！ 12345678910111213141516171819202122public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { try { process2(); } catch (NullPointerException e) { // 关键点，传入原始Exception e throw new IllegalArgumentException(e); } } static void process2() { throw new NullPointerException(); }} 抛出信息的异常栈信息如下： 注意到Caused by: Xxx，说明捕获的IllegalArgumentException并不是造成问题的根源，根源在于NullPointerException，是在Main.process2()方法抛出的。 1234567java.lang.IllegalArgumentException: java.lang.NullPointerException at com.test.codeTest.process1(codeTest.java:16) at com.test.codeTest.main(codeTest.java:6)// 关键点：Caused by: java.lang.NullPointerException at com.test.codeTest.process2(codeTest.java:23) at com.test.codeTest.process1(codeTest.java:14) 3、finally语句是否执行 在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。 123456789101112public class Main { public static void main(String[] args) { try { Integer.parseInt(\"abc\"); } catch (Exception e) { System.out.println(\"catched\"); throw new RuntimeException(e); } finally { System.out.println(\"finally\"); } }} 1234catchedfinallyException in thread \"main\" java.lang.IllegalArgumentException at Main.main(Main.java:11) 4、异常屏蔽 在执行finally语句时抛出异常,catch语句的异常会被屏蔽！ finally抛出异常后，原来在catch中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception） Suppressed ：屏蔽 绝大多数情况下，在finally中不要抛出异常。因此，我们通常不需要关心Suppressed Exception。 12345678910111213public class Main { public static void main(String[] args) { try { Integer.parseInt(\"abc\"); } catch (Exception e) { System.out.println(\"catched\"); throw new RuntimeException(e); } finally { System.out.println(\"finally\"); throw new IllegalArgumentException(); } }} 抛出异常如下： 1234catchedfinallyException in thread \"main\" java.lang.IllegalArgumentException at Main.main(Main.java:11) 解决方法： 如果需要获知所有的异常，方法是先用origin变量保存原始异常，然后调用Throwable.addSuppressed()，把原始异常添加进来，最后在finally抛出： Suppressed ：屏蔽 1234567891011121314151617public class Main { public static void main(String[] args) throws Exception { Exception origin = null; try { System.out.println(Integer.parseInt(\"abc\")); } catch (Exception e) { origin = e; throw e; } finally { Exception e = new IllegalArgumentException(); if (origin != null) { e.addSuppressed(origin); } throw e; } }} 抛出异常信息如下： 1234567Exception in thread \"main\" java.lang.IllegalArgumentException at Main.main(Main.java:11) // 关键点：屏蔽异常信息：NumberFormatException Suppressed: java.lang.NumberFormatException: For input string: \"abc\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) 四、自定义异常1、Java标准库定义的 常用异常：1234567891011121314151617181920212223242526272829Exception│├─ RuntimeException│ ││ ├─ NullPointerException│ ││ ├─ IndexOutOfBoundsException│ ││ ├─ SecurityException│ ││ └─ IllegalArgumentException│ ││ └─ NumberFormatException│├─ IOException│ ││ ├─ UnsupportedCharsetException│ ││ ├─ FileNotFoundException│ ││ └─ SocketException│├─ ParseException│├─ GeneralSecurityException│├─ SQLException│└─ TimeoutException 2、自定义异常 在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。 一个常见的做法是自定义一个BaseException作为“根异常”，然后，派生出各种业务类型的异常。 BaseException需要从一个适合的Exception派生，通常建议从RuntimeException派生： BaseException构造方法实际上都是原样照抄RuntimeException。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。 12345678910111213141516171819202122232425public class BaseException extends RuntimeException { public BaseException() { super(); } public BaseException(String message, Throwable cause) { super(message, cause); } public BaseException(String message) { super(message); } public BaseException(Throwable cause) { super(cause); }}public class UserNotFoundException extends BaseException {}public class LoginFailedException extends BaseException {}... 五、NullPointerException 所有的RuntimeException异常中，最常见的就是NullPointerException了！ NullPointerException即空指针异常，俗称NPE。如果一个对象为null，调用其方法或访问其字段就会产生NullPointerException，这个异常通常是由JVM抛出的！ 1、处理NullPointerException NullPointerException是一种代码逻辑错误，遇到NullPointerException，遵循原则是早暴露，早修复，严禁使用catch来隐藏这种编码错误： 1.1 变量定义时尽量不使用null 使用空字符串\"\"而不是默认的null可避免很多NullPointerException，编写业务逻辑时，用空字符串\"\"表示未填写比null安全得多。 123public class Person { private String name = \"\";} 1.2 返回时尽量不返回null12345678910111213package com.test;public class codeTest { public static void main(String[] args) { String name = getName(); System.out.println(name.toString()); } public static String getName() { //return null; return \"\"; }} 1.3 必须返回null时使用Optional&lt;T&gt; 使用Optional.isPresent()来判断是不是null 使用Optional.of()返回T类型的值： 1234567891011121314151617181920package com.test;import java.util.Optional;public class codeTest { public static void main(String[] args) { Optional&lt;String&gt; name = getName(); if(name.isPresent()) { System.out.println(name); }else{ System.out.println(\"NULL\"); } } public static Optional&lt;String&gt; getName() { //return null; //return Optional.of(\"hhh\"); return Optional.empty(); }} 2、定位NullPointerException 这种增强的NullPointerException详细信息是Java 14新增的功能，但默认是关闭的，我们可以给JVM添加一个-XX:+ShowCodeDetailsInExceptionMessages参数启用它： 1java -XX:+ShowCodeDetailsInExceptionMessages Main.java 12345678910111213141516171819package com.test;public class codeTest { public static void main(String[] args) { Persons p = new Persons(); System.out.println(p.address.city.toLowerCase()); }}class Persons { String[] name = new String[2]; Address address = new Address();}class Address { String city; String street; String zipcode;} 定位信息如下：city是空的！ 12345java -XX:+ShowCodeDetailsInExceptionMessages Main.java// 信息如下：Exception in thread \"main\" java.lang.NullPointerException: Cannot invoke \"String.toLowerCase()\" because \"&lt;local1&gt;.address.city\" is null at com.test.codeTest.main(codeTest.java:6) 六、使用断言 实际开发中，很少使用断言。更好的方法是编写单元测试！ 断言条件预期为true，则正常执行。断言条件为false，抛出AssertionError。 后面可加参数来打印提示信息，更加便于调试！ Java断言的特点是：断言失败时会抛出AssertionError，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。 对可恢复的错误不能使用断言，而应该抛出异常； 1assert x &gt;= 0 : \"x must &gt;= 0\"; 1234567public class Main { public static void main(String[] args) { int x = -1; assert x &gt; 0; System.out.println(x); }} JVM默认关闭断言指令，即遇到assert语句就自动忽略了，不执行。 要执行assert语句，必须给Java虚拟机传递-enableassertions（可简写为-ea）参数启用断言。所以，上述程序必须在命令行下运行才有效果： 123$ java -ea Main.javaException in thread \"main\" java.lang.AssertionError at Main.main(Main.java:5) 七、使用JDK Loging 编写程序的过程中，发现程序运行结果与预期不符，使用System.out.println()打印变量信息！异常麻烦！ 所以使用Loging，日志就是Logging，它的目的是为了取代System.out.println()。 使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。 几点好处： 可以设置输出样式，避免自己每次都写\"ERROR: \" + var； 可以设置输出级别，禁止某些级别输出。例如，只输出错误日志； 可以被重定向到文件，这样可以在程序运行结束后查看日志； 可以按包名控制日志级别，只输出某些包打的日志； 可以…… 12345678910111213package com.test;import java.util.logging.Logger;public class codeTest { public static void main(String[] args) { Logger logger = Logger.getGlobal(); logger.info(\"start process...\"); logger.warning(\"memory is running out...\"); logger.fine(\"ignored.\"); logger.severe(\"process will be terminated...\"); }} 输出信息如下： 1234563月 31, 2020 6:12:33 下午 com.test.codeTest main信息: start process...3月 31, 2020 6:12:33 下午 com.test.codeTest main警告: memory is running out...3月 31, 2020 6:12:33 下午 com.test.codeTest main严重: process will be terminated... Logger日志的七个级别： 默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。 SEVERE WARNING INFO CONFIG FINE FINER FINEST Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行main()方法，就无法修改配置； 配置不太方便，需要在JVM启动时传递参数-Djava.util.logging.config.file=。 因此，Java标准库内置的Logging使用并不是非常广泛。 一个例子： 1234567891011121314151617181920package com.test;import com.sun.tools.javac.Main;import java.io.UnsupportedEncodingException;import java.util.logging.Logger;public class codeTest { public static void main(String[] args) { Logger logger = Logger.getLogger(Main.class.getName()); logger.info(\"Start process...\"); try { \"\".getBytes(\"invalidCharsetName\"); } catch (UnsupportedEncodingException e) { // TODO: 使用logger.severe()打印异常 logger.severe(e.toString()); } logger.info(\"Process end.\"); }} 日志如下： 1234567893月 31, 2020 6:18:43 下午 com.test.codeTest main信息: Start process...3月 31, 2020 6:18:43 下午 com.test.codeTest main严重: java.io.UnsupportedEncodingException: invalidCharsetName3月 31, 2020 6:18:43 下午 com.test.codeTest main信息: Process end.Process finished with exit code 0 八、使用Commons Logging 和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。 Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。 Commons Logging是一个第三方提供的库，所以，必须先把它下载下来。下载后，解压，找到commons-logging-1.2.jar这个文件，再把Java源码Main.java放到一个目录下 1、idea 导入方式：1.打开 File -&gt; Project Structure 2.单击 Modules -&gt; Dependencies -&gt; “+” -&gt; “Jars or directories” 3.选择硬盘上的jar包 4.Apply -&gt; OK 然后将鼠标放到导入的包上，点击提示信息的add classspath….即可成功导入！ 12345678910111213package com.test;import com.sun.tools.javac.Main;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class codeTest { public static void main(String[] args) { Log log = LogFactory.getLog(Main.class); log.info(\"start...\"); log.warn(\"end.\"); }} 信息如下： 12343月 31, 2020 6:51:39 下午 com.sun.tools.javac.Main main信息: start...3月 31, 2020 6:51:39 下午 com.sun.tools.javac.Main main警告: end. 2、Commons Logging定义了6个日志级别： FATAL ERROR WARNING INFO DEBUG TRACE 默认级别是INFO。 3、静态方法中引用log定义静态类型变量：12345678/ 在静态方法中引用Log:public class Main { static final Log log = LogFactory.getLog(Main.class); static void foo() { log.info(\"foo\"); }} 4、实例方法中引用log定义实例类型变量： 注意到实例变量log的获取方式是LogFactory.getLog(getClass())，虽然也可以用LogFactory.getLog(Person.class)，但是前一种方式有个非常大的好处，就是子类可以直接使用该log实例： 由于Java类的动态特性，子类获取的log字段实际上相当于LogFactory.getLog(Student.class)，但却是从父类继承而来，并且无需改动代码： 12345678910111213141516// 在实例方法中引用Log:public class Person { protected final Log log = LogFactory.getLog(getClass()); void foo() { log.info(\"foo\"); }}// 在子类中使用父类实例化的log:public class Student extends Person { void bar() { log.info(\"bar\"); }} 5、可抛出异常： Commons Logging的日志方法，例如info()，除了标准的info(String)外，还提供了一个非常有用的重载方法：info(String, Throwable)，这使得记录异常更加简单： 本例子使用了： 实例方法引用log定义实例变量 使用LogFactory.getLog(getClass())来是子类直接继承log 使用log的两个参数，第二个参数来抛出异常： 12345678910111213141516171819202122232425262728293031package com.test;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class codeTest { public static void main(String[] args) { var s = new Persons(); s.foo(); var t = new Tests(); t.bar(); }}class Persons{ protected final Log log = LogFactory.getLog(getClass()); void foo(){ try { Integer n = Integer.parseInt(\"abs\"); }catch (NumberFormatException e){ log.error(\"foo\", e); } }}class Tests extends Persons{ void bar(){ log.info(\"bar\"); }} 结果如下： 12345678910113月 31, 2020 7:09:22 下午 com.test.Persons foo严重: foojava.lang.NumberFormatException: For input string: \"abs\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) at com.test.Persons.foo(codeTest.java:20) at com.test.codeTest.main(codeTest.java:9)3月 31, 2020 7:09:22 下午 com.test.Tests bar信息: bar 九、使用Log4j 前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。 Log4j是一种非常流行的日志框架，最新版本是2.x。 在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入classpath，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。 1、Log4j架构：Log4j是一个组件化设计的日志系统，它的架构大致如下： 12345678910111213log.info(\"User signed in.\"); │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ Console │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ File │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ └──&gt;│ Appender │───&gt;│ Filter │───&gt;│ Layout │───&gt;│ Socket │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ 当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如： console：输出到屏幕； file：输出到文件； socket：通过网络输出到远程计算机； jdbc：输出到数据库 在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出ERROR级别的日志。 最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。 2、配置XML文件上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。 将下面保存到文件并命名为：log4j2.xml放到src目录下即可： 虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是INFO级别的日志，会自动输出到屏幕，而ERROR级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Configuration&gt; &lt;Properties&gt; &lt;!-- 定义日志格式 --&gt; &lt;Property name=\"log.pattern\"&gt;%d{MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36}%n%msg%n%n&lt;/Property&gt; &lt;!-- 定义文件名变量 --&gt; &lt;Property name=\"file.err.filename\"&gt;log/err.log&lt;/Property&gt; &lt;Property name=\"file.err.pattern\"&gt;log/err.%i.log.gz&lt;/Property&gt; &lt;/Properties&gt; &lt;!-- 定义Appender，即目的地 --&gt; &lt;Appenders&gt; &lt;!-- 定义输出到屏幕 --&gt; &lt;Console name=\"console\" target=\"SYSTEM_OUT\"&gt; &lt;!-- 日志格式引用上面定义的log.pattern --&gt; &lt;PatternLayout pattern=\"${log.pattern}\" /&gt; &lt;/Console&gt; &lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt; &lt;RollingFile name=\"err\" bufferedIO=\"true\" fileName=\"${file.err.filename}\" filePattern=\"${file.err.pattern}\"&gt; &lt;PatternLayout pattern=\"${log.pattern}\" /&gt; &lt;Policies&gt; &lt;!-- 根据文件大小自动切割日志 --&gt; &lt;SizeBasedTriggeringPolicy size=\"1 MB\" /&gt; &lt;/Policies&gt; &lt;!-- 保留最近10份 --&gt; &lt;DefaultRolloverStrategy max=\"10\" /&gt; &lt;/RollingFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=\"info\"&gt; &lt;!-- 对info级别的日志，输出到console --&gt; &lt;AppenderRef ref=\"console\" level=\"info\" /&gt; &lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt; &lt;AppenderRef ref=\"err\" level=\"error\" /&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是INFO级别的日志，会自动输出到屏幕，而ERROR级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。 3、下载并配置Log4j有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从这里下载Log4j，解压后，把以下3个jar包放到classpath中： log4j-api-2.x.jar log4j-core-2.x.jar log4j-jcl-2.x.jar 因为Commons Logging会自动发现并使用Log4j，所以，把上一节下载的commons-logging-1.2.jar也放到classpath中。 要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出，类似： 第八节第五点的输出信息变为如下： 123456789101103-31 19:35:03.119 [main] ERROR com.test.Personsfoojava.lang.NumberFormatException: For input string: \"abs\" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) ~[?:?] at java.lang.Integer.parseInt(Integer.java:652) ~[?:?] at java.lang.Integer.parseInt(Integer.java:770) ~[?:?] at com.test.Persons.foo(codeTest.java:20) [java-base/:?] at com.test.codeTest.main(codeTest.java:9) [java-base/:?]03-31 19:35:03.146 [main] INFO com.test.Testsbar 4、小结 通过Commons Logging实现日志，不需要修改代码即可使用Log4j； 使用Log4j只需要把log4j2.xml和相关jar放入classpath； 如果要更换Log4j，只需要移除log4j2.xml和相关jar； 只有扩展Log4j时，才需要引用Log4j的接口（例如，将日志加密写入数据库的功能，需要自己开发）。 十、使用SLF4J和Logback 前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。 有的童鞋可能还听说过SLF4J和Logback。这两个东东看上去也像日志，它们又是啥？ 其实SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。 为什么有了Commons Logging和Log4j，又会蹦出来SLF4J和Logback？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。 因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。 来看看SLF4J对Commons Logging的接口有何改进： SLF4J的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。 12345678910int score = 99;p.setScore(score);// Commons Logging 的拼接字符串：log.info(\"Set score \" + score + \" for Person \" + p.getName() + \" ok.\");// SLF4Jint score = 99;p.setScore(score);// 改进后的拼接字符串：logger.info(\"Set score {} for Person {} ok.\", score, p.getName()); 如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样！ 配置相关：使用SLF4J和Logback和前面讲到的使用Commons Logging加Log4j是类似的，先分别下载SLF4J和Logback，然后把以下jar包放到classpath下： slf4j-api-1.7.x.jar logback-classic-1.2.x.jar logback-core-1.2.x.jar 在src目录下新建一个logback.xml文件，写入下面内容： 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;charset&gt;utf-8&lt;/charset&gt; &lt;/encoder&gt; &lt;file&gt;log/output.log&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.FixedWindowRollingPolicy\"&gt; &lt;fileNamePattern&gt;log/output.log.%i&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;1MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt;&lt;/configuration&gt; 代码修改如下：123456789101112131415161718192021222324252627282930313233343536package com.test;import org.slf4j.LoggerFactory;import org.slf4j.Logger;public class codeTest { public static void main(String[] args) { var s = new Persons(); s.foo(); var t = new Tests(); t.bar(); }}class Persons{ //protected final Logger log = LoggerFactory.getLogger(getClass()); final Logger logger = LoggerFactory.getLogger(getClass()); void foo(){ try { Integer n = Integer.parseInt(\"abs\"); }catch (NumberFormatException e){ logger.error(\"foo\", e); } }}class Tests extends Persons{ String name = \"Mr.Niu\"; int age = 100; void bar(){ logger.info(\"bar\"); // 拼接字符串新方法： logger.info(\"name:{}, age:{}\",name, age); }} 输出信息如下： 12345678920:14:19.679 [main] ERROR com.test.Persons - foojava.lang.NumberFormatException: For input string: \"abs\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) at com.test.Persons.foo(codeTest.java:21) at com.test.codeTest.main(codeTest.java:9)20:14:19.693 [main] INFO com.test.Tests - bar20:14:19.697 [main] INFO com.test.Tests - name:Mr.Niu, age:100 小结 SLF4J和Logback可以取代Commons Logging和Log4j； 始终使用SLF4J的接口写入日志，使用Logback只需要配置，不需要修改代码。 异常处理已完结，敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://www.itnxd.cn/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}],"author":"Mr.Niu"},{"title":"Java教程系列之Java核心类","slug":"Java教程系列之Java核心类","date":"2020-03-27T09:56:43.000Z","updated":"2021-02-06T14:18:28.333Z","comments":true,"path":"posts/22799.html","link":"","permalink":"https://www.itnxd.cn/posts/22799.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、字符串和编码1、字符串（String） 在Java中，String是一个引用类型，它本身也是一个class。但是，Java编译器对String有特殊处理，即可以直接用\"...\"来表示一个字符串！ 实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的！ 因为String太常用了，所以Java提供了\"...\"这种字符串字面量表示方法。 Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。 12String s1 = \"hello!\";String s2 = new String(new char[] {'H', 'e', 'l', 'l', 'o', '!'}); 下面这个输出结果不一样，因为不可变性，所以其实就是指向变了！原来的字符串仍然在内存中！ 12345678public class Main { public static void main(String[] args) { String s = \"Hello\"; System.out.println(s); //Hello s = s.toUpperCase(); //HELLO System.out.println(s); }} 1.1 字符串比较（equal） 必须使用equals()方法而不能用==！ equal()方法比较的是实实在在指向的内容！ ==则比较的指向的对象或实例是否相同！ 一般情况下我们只需要比较内容，所以一定要射用equal方法！ 从表面上看，两个字符串用==和equals()比较都为true，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然s1和s2的引用就是相同的。 1234567891011121314public class Main { public static void main(String[] args) { String s1 = \"hello\"; String s2 = \"hello\"; System.out.println(s1 == s2);//true System.out.println(s1.equals(s2));//true // 上面纯属巧合！ String s3 = \"hello\"; String s4 = \"HELLO\".toLowerCase(); System.out.println(s3 == s4);//false System.out.println(s3.equals(s4));//true }} 要忽略大小写比较，使用equalsIgnoreCase()方法。 12345678910package com.test;public class codeTest { public static void main(String[] args) { String s = \"hello\"; String t = s.toUpperCase(); System.out.println(s.equals(t));//false System.out.println(s.equalsIgnoreCase(t));//true }} 1.2 字符串搜索 contains()：参数是CharSequence而不是String，因为CharSequence是String的父类。查找子串，返回bool型！ indexof()：返回查找第一次出现子串的下标位置！ lastIndexOf()：返回最后一次出现子串的下标位置！ startsWith()：返回是否以子串开头的bool型值！ endwith()：返回是否以子串结尾的bool型值！ substring()：截取子串！ substring(a)：返回下标a开始到最后！ substring(a, b)：返回下标a开始到b为止，左闭右开！ 1234567891011// 是否包含子串:\"Hello\".contains(\"ll\"); // true\"Hello\".indexOf(\"l\"); // 2\"Hello\".lastIndexOf(\"l\"); // 3\"Hello\".startsWith(\"He\"); // true\"Hello\".endsWith(\"lo\"); // true\"Hello\".substring(2); // \"llo\"\"Hello\".substring(2, 4); \"ll\" 1.3 取出首尾空白字符 trim()：移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n!并没有改变字符串的内容，而是返回了一个新字符串。 strip()：移除字符串首尾空白字符。它和trim()不同的是，类似中文的空格字符\\u3000也会被移除！ stripLeading()：移除首部！ stripTrailing()：移除尾部！ isEmpty()：潘福安字符串是否为空！ isBlank()：判断字符串是否为空白字符（空格）！ 1234567891011\" \\tHello\\r\\n \".trim(); // \"Hello\"\"\\u3000Hello\\u3000\".strip(); // \"Hello\"\" Hello \".stripLeading(); // \"Hello \"\" Hello \".stripTrailing(); // \" Hello\"\"\".isEmpty(); // true，因为字符串长度为0\" \".isEmpty(); // false，因为字符串长度不为0\" \\n\".isBlank(); // true，因为只包含空白字符\" Hello \".isBlank(); // false，因为包含非空白字符 1.4 子串替换（replace） 使用replace()方法： 123String s = \"hello\";s.replace('l', 'w'); // \"hewwo\"，所有字符'l'被替换为'w's.replace(\"ll\", \"~~\"); // \"he~~o\"，所有子串\"ll\"被替换为\"~~\" 使用正则表达式： 参考我之前在JavaScript教程的RegExp：点击这里! 当然语法不太相同，后面的java教程会讲到Re！ 12String s = \"A,,B;C ,D\";String tt = s.replaceAll(\"[,;\\\\s]+\", \",\"); // \"A,B,C,D\" 1.5 字符串分割 split()：参数为正则表达式！ 12String s = \"A,B,C,D\";String[] ss = s.split(\",\"); // {\"A\", \"B\", \"C\", \"D\"} 1.6 字符串拼接 join()：用指定的字符串连接字符串数组! 12String[] arr = {\"A\", \"B\", \"C\"};String s = String.join(\"***\", arr); // \"A***B***C\" 1.7 类型转换其他类型转换为字符串： valueof()：把任意基本类型或引用类型转换为字符串，这是一个重载方法，编译器会根据参数自动选择合适的方法！ 1234String.valueOf(123); // \"123\"String.valueOf(45.67); // \"45.67\"String.valueOf(true); // \"true\"String.valueOf(new Object()); // 输出java.lang.Object@636be97c 字符串转换为其他类型： Integer.parseInt()：int转换为String！ Boolean.parseBoolean()：boolean转换为String！ 12345int n1 = Integer.parseInt(\"123\"); // 123int n2 = Integer.parseInt(\"ff\", 16); // 按十六进制转换，255boolean b1 = Boolean.parseBoolean(\"true\"); // trueboolean b2 = Boolean.parseBoolean(\"FALSE\"); // false Integer的getInteger(String)方法，它不是将字符串转换为int，而是把该字符串对应的系统变量转换为Integer： 1System.out.println(\"java版本：\" + Integer.getInteger(\"java.version\"));// java版本：14 1.8 String与char[]互转 String转char[]：使用toCharArray()方法！ char[]转String：使用new String()方法！ 12char[] cs = \"Hello\".toCharArray(); // String -&gt; char[]String s = new String(cs); // char[] -&gt; String 通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份，所以，修改外部的char[]数组不会影响String实例内部的char[]数组，因为这是两个不同的数组。 new String()时：传入的是一个复制！ 123456789public class Main { public static void main(String[] args) { char[] cs = \"Hello\".toCharArray(); String s = new String(cs); System.out.println(s); cs[0] = 'X'; System.out.println(s); }} 当向类中传入引用时，外部改变会影响类的改变！ 由于Score内部直接引用了外部传入的int[]数组，这会造成外部代码对int[]数组的修改，影响到Score类的字段。如果外部代码不可信，这就会造成安全隐患。 可以使用数组的clone()方法， 123456789101112131415161718192021222324import java.util.Arrays;public class Main { public static void main(String[] args) { int[] scores = new int[] { 88, 77, 51, 66 }; Score s = new Score(scores); s.printScores();//[88, 77, 51, 66] scores[2] = 99; s.printScores();//[88, 77, 99, 66]修改后[88, 77, 51, 66] }}class Score { private int[] scores; public Score(int[] scores) { this.scores = scores; // 修改为使用克隆方法！ this.scores = scores.clone(); } public void printScores() { System.out.println(Arrays.toString(scores)); }} 2、字符编码 可参考廖雪峰的字符编码教程：点击这里！ 始终牢记：Java的String和char在内存中总是以Unicode编码表示。 2.1 ASCII编码 在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从0到127，最高位始终为0，称为ASCII编码。例如，字符'A'的编码是0x41，字符'1'的编码是0x31。 2.2 GB2312和GBK编码 如果要把汉字也纳入计算机编码，很显然一个字节是不够的。GB2312标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为1，以便和ASCII编码区分开。例如，汉字'中'的GB2312编码是0xd6d0。 1、收录不同：GB2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；GBK共收入21886个汉字和图形符号。 2、表示不同：GB2312对任意一个图形字符都采用两个字节表示，并对所收汉字进行了“分区”处理，每区含有94个汉字／符号，分别对应第一字节和第二字节。GBK采用双字节表示，总体编码范围为8140-FEFE之间，首字节在81-FE之间，尾字节在40-FE之间。 3、处理功能不同：对于人名、古汉语等方面出现的罕用字，GB2312不能处理，这导致了后来GBK 及GB18030 汉字字符集的出现。 GBK: 汉字国标扩展码,基本上采用了原来GB2312-80所有的汉字及码位，并涵盖了原Unicode中所有的汉字20902，总共收录了883个符号， 21003个汉字及提供了1894个造字码位。 Microsoft简体版中文Windows 95就是以GBK为内码，又由于GBK同时也涵盖了Unicode所有CJK汉字，所以也可以和Unicode做一一对应。 GB码，全称是GB2312-80《信息交换用汉字编码字符集 基本集》，1980年发布，是中文信息处理的国家标准，在大陆及海外使用简体中文的地区（如新加坡等）是强制使用的唯一中文编码。P-Windows3.2和苹果OS就是以GB2312为基本汉字编码， Windows 95/98则以GBK为基本汉字编码、但兼容支持GB2312。GB码共收录6763个简体汉字、682个符号，其中汉字部分：一级字3755，以拼音排序，二级字3008，以偏旁排序。该标准的制定和应用为规范、推动中文信息化进程起了很大作用。 GBK编码是中国大陆制订的、等同于UCS的新的中文编码扩展国家标准。GBK工作小组于1995年10月，同年12月完成GBK规范。该编码标准兼容GB2312，共收录汉字21003个、符号883个，并提供1894个造字码位，简、繁体字融于一库。 2.3 Unicode编码 为了统一全球所有语言的编码，全球统一码联盟发布了Unicode编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。 Unicode编码需要两个或者更多字节表示！ 2.4 UTF-8编码 因为英文字符的Unicode编码高字节总是00，包含大量英文的文本会浪费空间，所以，出现了UTF-8编码，它是一种变长编码，用来把固定长度的Unicode编码变成1～4字节的变长编码。通过UTF-8编码，英文字符'A'的UTF-8编码变为0x41，正好和ASCII码一致，而中文'中'的UTF-8编码为3字节0xe4b8ad。 UTF-8编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为UTF-8编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。 在Java中，char类型实际上就是两个字节的Unicode编码。如果我们要手动把字符串转换成其他编码，可以这样做： getBytes(\"UTF-8\")：这个编译通不过。。 使用getBytes(StandardCharsets.UTF_8)才可以！ 了解一下就好！ 转换编码后，就不再是char类型，而是byte类型表示的数组。 1234byte[] b1 = \"Hello\".getBytes(); // 按系统默认编码转换，不推荐byte[] b2 = \"Hello\".getBytes(\"UTF-8\"); // 按UTF-8编码转换byte[] b2 = \"Hello\".getBytes(\"GBK\"); // 按GBK编码转换byte[] b3 = \"Hello\".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换 将byte[]转换为String，可以这样做： 123byte[] b = ...String s1 = new String(b, \"GBK\"); // 按GBK转换String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换 3、String存储方式 早期JDK版本的String总是以char[]存储： 12345public final class String { private final char[] value; private final int offset; private final int count;} 较新的JDK版本的String则以byte[]存储： 如果String仅包含ASCII字符，则每个byte存储一个字符，否则，每两个byte存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的String通常仅包含ASCII字符： 对于使用者来说，String内部的优化不影响任何已有代码，因为它的public方法签名是不变的。 123public final class String { private final byte[] value; private final byte coder; // 0 = LATIN1, 1 = UTF16 二、StringBuilder 使用String拼接字符串时，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC(垃圾回收)效率。 为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象： 其他许多方法去编译器就可以看到！ 你可能还听说过StringBuffer，这是Java早期的一个StringBuilder的线程安全版本，它通过同步来保证多个线程操作StringBuffer也是安全的，但是同步会带来执行速度的下降。 StringBuilder和StringBuffer接口完全相同，现在完全没有必要使用StringBuffer。 也就是说StringBuffer已经是一个淘汰品了，不需要使用了！ 最大作用：高效拼接字符串！ 可以进行链式操作： 进行链式操作的关键是，定义的append()方法会返回this，这样，就可以不断调用自身的其他方法！ 参数capacity为初始容量，不够时，自动扩大为当前的二倍！ 也可以不写该参数！ 12345678910public class Main { public static void main(String[] args) { var sb = new StringBuilder(1024); sb.append(\"Mr \") .append(\"Bob\") .append(\"!\") .insert(0, \"Hello, \"); System.out.println(sb.toString()); }} 来设计一个支持链式操作的类！关键当然是可以返回this即可！ 1234567891011121314151617181920212223242526272829public class Main { public static void main(String[] args) { Adder adder = new Adder(); adder.add(3) .add(5) .inc() .add(10); System.out.println(adder.value()); }}class Adder { private int sum = 0; public Adder add(int n) { sum += n; return this; } public Adder inc() { sum ++; return this; } public int value() { return sum; }} 对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作。 三、StringJoiner 最大作用：可以用分隔符拼接字符串，也可以指定开始和结束！ StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的！！ 123456789101112131415import java.util.StringJoiner;public class Main { public static void main(String[] args) { String[] names = {\"Bob\", \"Alice\", \"Grace\"}; // 按逗号分隔 var sj = new StringJoiner(\", \"); // 指定开头和结尾 var sj = new StringJoiner(\", \", \"Hello \", \"!\"); for (String name : names) { sj.add(name); } System.out.println(sj.toString()); }} 不需要开头结尾时，可以使用更方便的String.join() 12String[] names = {\"Bob\", \"Alice\", \"Grace\"};var s = String.join(\", \", names); 四、包装类型Java的两种数据类型： 基本类型：byte，short，int，long，boolean，float，double，char 引用类型：所有class和interface类型 引用类型可以赋值为null，表示空，但基本类型不能赋值为null： 12String s = null;int n = null; // compile error! 将基本类型转换为引用类型就是包装类型！ 1、int转Integer12345678Integer n = null;Integer n2 = new Integer(99);Integer n3 = 98;Integer n4 = Integer.valueOf(99);// 通过静态方法valueOf(String)创建Integer实例:Integer n5 = Integer.valueOf(\"100\");int n6 = n2.intValue();int n7 = n3; Java对应的基本类型的包装类型： 基本类型 对应的引用类型 boolean java.lang.Boolean byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double char java.lang.Character 2、Auto Boxing 由于可以自动互转，所以可以直接简化的写，编译器自动完成转换加上相应语句！ 这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。 注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。 装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException： 123456Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue()// 这样拆箱会报错的：Integer n = null;int i = n; 3、不变类（final class） 所有的包装类型都是不变类，如Integer的源码： 两个Integer比较大小，不能使用==, 一定要用equal()方法! ，==比较，较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);，为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。 1234567891011121314151617public final class Integer { private final int value;}// 比较：public class Main { public static void main(String[] args) { Integer x = 127; Integer y = 127; Integer m = 99999; Integer n = 99999; System.out.println(\"x == y: \" + (x==y)); // true System.out.println(\"m == n: \" + (m==n)); // false System.out.println(\"x.equals(y): \" + x.equals(y)); // true System.out.println(\"m.equals(n): \" + m.equals(n)); // true }} 因为Integer.valueOf()可能始终返回同一个Integer实例，因此，在我们自己创建Integer的时候，以下两种方法： 方法1：Integer n = new Integer(100); 方法2：Integer n = Integer.valueOf(100); 方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。 我们把能创建“新”对象的静态方法称为静态工厂方法。Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。 创建新对象时，优先选用静态工厂方法而不是new操作符。 如果我们考察Byte.valueOf()方法的源码，可以看到，标准库返回的Byte实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例！ 4、Integer的进制转换 使用Integer.parseInt()方法或者是toString()....等等！ 输出结果都是String类型！ 12345678910111213public class Main { public static void main(String[] args) { // 将字符串解析成一个整数： int x1 = Integer.parseInt(\"100\"); // 100 int x2 = Integer.parseInt(\"100\", 16); // 256,因为按16进制解析 System.out.println(Integer.toString(100)); // \"100\",表示为10进制 System.out.println(Integer.toString(100, 36)); // \"2s\",表示为36进制 System.out.println(Integer.toHexString(100)); // \"64\",表示为16进制 System.out.println(Integer.toOctalString(100)); // \"144\",表示为8进制 System.out.println(Integer.toBinaryString(100)); // \"1100100\",表示为2进制 }} 5、静态变量一些静态变量： 123456789// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:Boolean t = Boolean.TRUE;Boolean f = Boolean.FALSE;// int可表示的最大/最小值:int max = Integer.MAX_VALUE; // 2147483647int min = Integer.MIN_VALUE; // -2147483648// long类型占用的bit和byte数量:int sizeOfLong = Long.SIZE; // 64 (bits)int bytesOfLong = Long.BYTES; // 8 (bytes) 所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型： 12345678// 向上转型为Number:Number num = new Integer(999);// 获取byte, int, long, float, double:byte b = num.byteValue();int n = num.intValue();long ln = num.longValue();float f = num.floatValue();double d = num.doubleValue(); 5、无符号处理 在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。 因为byte的-1的二进制表示是11111111，以无符号整型转换后的int就是255。 类似的，可以把一个short按unsigned转换为int，把一个int按unsigned转换为long。 12345678910111213public class Main { public static void main(String[] args) { byte x = -1; byte y = 1; short r = -1; int t = -1; System.out.println(Byte.toUnsignedInt(x)); // 255 System.out.println(Byte.toUnsignedInt(y)); // 127 System.out.println(Short.toUnsignedInt(r));//65535 System.out.println(Integer.toUnsignedLong(t));//4294967295 }} 无、JavaBean在Java中，有很多class的定义都符合这样的规范： 若干private实例字段； 通过public方法来读写实例字段。 1、JavaBean规范如果读写方法符合以下这种命名规范： 12345678910// 读方法:public Type getXyz()// 写方法:public void setXyz(Type value)// boolean特殊：读方法一般命名为isXyz()：// 读方法:public boolean isChild()// 写方法:public void setChild(boolean value) 那么这种class被称为JavaBean： 上面的字段是xyz，那么读写方法名分别以get和set开头，并且后接大写字母开头的字段名Xyz，因此两个读写方法名分别是getXyz()和setXyz() 我们通常把一组对应的读方法（getter）和写方法（setter）称为属性（property）。例如，name属性： 对应的读方法是String getName() 对应的写方法是setName(String) 只有getter的属性称为只读属性（read-only），例如，定义一个age只读属性： 对应的读方法是int getAge() 无对应的写方法setAge(int) 类似的，只有setter的属性称为只写属性（write-only）。 很明显，只读属性很常见，只写属性不常见。 getter和setter就实现了一种数据封装的方法！ 1234567891011121314public class Person { private String name; private int age; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public int getAge() { return this.age; } public void setAge(int age) { this.age = age; } public boolean isChild() { return age &lt;= 6; }} 2、JavaBean作用 JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。 通过IDE，可以快速生成getter和setter！ 3、枚举JavaBean属性 了解即可！ 使用Introspector.getBeanInfo()可以获取属性列表。 123456789101112131415161718192021222324252627282930313233343536373839package com.test;import java.beans.BeanInfo;import java.beans.IntrospectionException;import java.beans.Introspector;import java.beans.PropertyDescriptor;public class codeTest { public static void main(String[] args) throws IntrospectionException { BeanInfo info = Introspector.getBeanInfo(Person.class); for (PropertyDescriptor pd : info.getPropertyDescriptors()) { System.out.println(pd.getName()); System.out.println(\" \" + pd.getReadMethod()); System.out.println(\" \" + pd.getWriteMethod()); } }}class Persons { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 输出结果： 123456789101112age public int com.test.Person.getAge() public void com.test.Person.setAge(int)birth public int com.test.Person.getBirth() public void com.test.Person.setBirth(int)class public final native java.lang.Class java.lang.Object.getClass() nullname public java.lang.String com.test.Person.getName() public void com.test.Person.setName(java.lang.String) 六、枚举类（enum） 为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类！ 注意到定义枚举类是通过关键字enum实现的，我们只需依次列出枚举的常量名。 和int定义的常量相比，使用enum定义枚举有如下好处： 首先，enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误。 其次，不可能引用到非枚举的值，因为无法通过编译。 最后，不同类型的枚举不能互相比较或者赋值，因为类型不符！ 使用enum定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用equals()方法，如果使用==比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用equals()方法，但enum类型可以例外。 因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较： 12345678910111213141516171819public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day == Weekday.SAT || day == Weekday.SUN) { System.out.println(\"Work at home!\"); } else { System.out.println(\"Work at office!\"); } // 这样是编译不会通过的： int day = 1; if (day == Weekday.SUN) { // Compile error: bad operand types for binary operator '==' } }}enum Weekday { SUN, MON, TUE, WED, THU, FRI, SAT;} 1、enum类型通过enum定义的枚举类，和其他的class有什么区别？ 答案是没有任何区别。enum定义的类型就是class，只不过它有以下几个特点： 定义的enum类型总是继承自java.lang.Enum，且无法被继承； 只能定义出enum的实例，而无法通过new操作符创建enum的实例； 定义的每个实例都是引用类型的唯一实例； 可以将enum类型用于switch语句。 12345678910111213public enum Color { RED, GREEN, BLUE;}// 编译后大概长这样：public final class Color extends Enum { // 继承自Enum，标记为final class // 每个实例均为全局唯一: public static final Color RED = new Color(); public static final Color GREEN = new Color(); public static final Color BLUE = new Color(); // private构造方法，确保外部无法调用new操作符: private Color() {}} 编译后的enum类和普通class并没有任何区别。但是我们自己无法按定义普通class那样来定义enum，必须使用enum关键字，这是Java语法规定的。 因为enum是一个class，每个枚举的值都是class实例！ 2、常用方法 name()：返回常量名！ ordinal()：返回定义常量的顺序（从0开始）！ 12String s = Weekday.SUN.name(); // \"SUN\"int n = Weekday.MON.ordinal(); // 1 注意：当枚举类Weekday内部的顺序发生变化时，通过ordinal()方法获取到的值也会相应改变！ 想要不受影响，新增的变量值一定要放到最后！ 解决方法： 要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段： 默认情况下，对枚举常量调用toString()会返回和name()一样的字符串。但是，toString()可以被覆写，而name()则不行。我们可以给Weekday添加toString()方法： 覆写toString()的目的是在输出时更有可读性。 注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！ 默认调用day的toString()方法！ toString()覆写后则调用覆写后的方法！ 1234567891011121314151617181920212223242526272829public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day.dayValue == 6 || day.dayValue == 0) { // 默认调用day的toString()方法： System.out.println(\"Today is \" + day + \". Work at home!\"); } else { System.out.println(\"Today is \" + day + \". Work at office!\"); } }}enum Weekday { MON(1, \"星期一\"), TUE(2, \"星期二\"), WED(3, \"星期三\"), THU(4, \"星期四\"), FRI(5, \"星期五\"), SAT(6, \"星期六\"), SUN(0, \"星期日\"); public final int dayValue; private final String chinese; private Weekday(int dayValue, String chinese) { this.dayValue = dayValue; this.chinese = chinese; } @Override public String toString() { return this.chinese; }} 3、使用switch语句12345678910111213141516171819202122public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; switch(day) { case MON: case TUE: case WED: case THU: case FRI: System.out.println(\"Today is \" + day + \". Work at office!\"); break; case SAT: case SUN: System.out.println(\"Today is \" + day + \". Work at home!\"); break; } }}enum Weekday { MON, TUE, WED, THU, FRI, SAT, SUN;} 七、记录类（record） 使用String、Integer等类型的时候，这些类型都是不变类，一个不变类具有以下特点： 定义class时使用final，无法派生子类； 每个字段使用final，保证创建实例后无法修改任何字段。 为了保证不变类的比较，还需要正确覆写equals()和hashCode()方法，这样才能在集合类中正常使用。 从Java 14开始，引入了新的Record类。我们定义Record类时，使用关键字record， 1、record类 除了用final修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写toString()、equals()和hashCode()方法。 换句话说，使用record关键字，可以一行写出一个不变类。 和enum类似，我们自己不能直接从Record派生，只能通过record关键字由编译器实现继承。 12345678910public class Main { public static void main(String[] args) { Point p = new Point(123, 456); System.out.println(p.x()); System.out.println(p.y()); System.out.println(p); }}public record Point(int x, int y) {} 编译时编译器自动完成所需要的代码以及需要覆写的代码： 12345678910111213141516171819202122232425262728public final class Point extends Record { private final int x; private final int y; public Point(int x, int y) { this.x = x; this.y = y; } public int x() { return this.x; } public int y() { return this.y; } public String toString() { return String.format(\"Point[x=%s, y=%s]\", x, y); } public boolean equals(Object o) { ... } public int hashCode() { ... }} 2、record的构造方法 编译器默认按照record声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？ 假设Point类的x、y不允许负数，我们就得给Point的构造方法加上检查逻辑： 123456789101112131415161718192021public record Point(int x, int y) { public Point { if (x &lt; 0 || y &lt; 0) { throw new IllegalArgumentException(); } }}// 编译后的代码长这样：public final class Point extends Record { public Point(int x, int y) { // 这是我们编写的Compact Constructor: if (x &lt; 0 || y &lt; 0) { throw new IllegalArgumentException(); } // 这是编译器继续生成的赋值代码: this.x = x; this.y = y; } ...} 3、可以编写静态方法1234567891011public record Point(int x, int y) { public static Point of() { return new Point(0, 0); } public static Point of(int x, int y) { return new Point(x, y); }}var z = Point.of();var p = Point.of(123, 456); 4、小结：从Java 14开始，提供新的record关键字，可以非常方便地定义Data Class： 使用record定义的是不变类； 可以编写Compact Constructor（构造方法）对参数进行验证； 可以定义静态方法。 八、BigInteger 超出long的范围时可以使用java.math.BigInteger，来模拟大整数！ BigInteger内部用一个int[]数组来模拟一个非常大的整数！ 做运算时，只能通过实例方法来进行！ 和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢！ 可以使用longVanlue()方法来将其转化为long类型，前提当然是没有超过long的范围！超过会把报错！ 1234567891011121314151617181920BigInteger bi = new BigInteger(\"1234567890\");System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000// 加法BigInteger i1 = new BigInteger(\"1234567890\");BigInteger i2 = new BigInteger(\"12345678901234567890\");BigInteger sum = i1.add(i2); // 12345678902469135780// 转换为longBigInteger i = new BigInteger(\"123456789000\");System.out.println(i.longValue()); // 123456789000System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range// + - * /BigInteger s1 = s.add(new BigInteger(\"328423\"));BigInteger s3 = s.subtract(new BigInteger(\"89789797\"));BigInteger s2 = s.multiply(new BigInteger(\"328423\"));BigInteger s4 = s.divide(new BigInteger(\"2379743489\"));// s的5次方BigInteger s5 = s.pow(5); BigInteger和Integer、Long一样，也是不可变类，并且也继承自Number类。因为Number定义了转换为基本类型的几个方法： 转换为byte：byteValue() 转换为short：shortValue() 转换为int：intValue() 转换为long：longValue() 转换为float：floatValue() 转换为double：doubleValue() 因此，通过上述方法，可以把BigInteger转换成基本类型。如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。 float没有floatValueExact()方法，超出范围会输出Infintity； 123456789101112131415import java.math.BigInteger;public class Main { public static void main(String[] args) { BigInteger n = new BigInteger(\"999999\").pow(99); float f = n.floatValue(); System.out.println(f);//Infinity int s = n.intValueExact(); System.out.println(s);//报错 int s = n.intValue(); System.out.println(s);//结果会丢失，不准确！ }} 九、BigDecimal 和BigInteger类似，BigDecimal可以表示一个任意大小且精度完全准确的浮点数。 BigDecimal也是从Number继承的，也是不可变对象。 当然也有和BigInteger一样的方法！ BigDecimal用于表示精确的小数，常用于财务计算； 12BigDecimal bd = new BigDecimal(\"123.4567\");System.out.println(bd.multiply(bd)); // 15241.55677489 scale()：可以计算小数位数！ stripTrailingZeros()：去掉小数末尾的0！ 若为整数，则返回整数末尾的0的个数，为负值！ 12345678910111213141516BigDecimal d1 = new BigDecimal(\"123.45\");BigDecimal d2 = new BigDecimal(\"123.4500\");BigDecimal d3 = new BigDecimal(\"1234500\");System.out.println(d1.scale()); // 2,两位小数System.out.println(d2.scale()); // 4System.out.println(d3.scale()); // 0BigDecimal d1 = new BigDecimal(\"123.4500\");BigDecimal d2 = d1.stripTrailingZeros();System.out.println(d1.scale()); // 4System.out.println(d2.scale()); // 2,因为去掉了00BigDecimal d3 = new BigDecimal(\"1234500\");BigDecimal d4 = d3.stripTrailingZeros();System.out.println(d3.scale()); // 0System.out.println(d4.scale()); // -2 setScale()：设置精度，小数位数。两种截断方法： RoundingMode.HALF_UP：四舍五入截断 RoundingMode.DOWN：直接截断 123456789101112import java.math.BigDecimal;import java.math.RoundingMode;public class Main { public static void main(String[] args) { BigDecimal d1 = new BigDecimal(\"123.456789\"); BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568 BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567 System.out.println(d2); System.out.println(d3); }} 对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断： 1234BigDecimal d1 = new BigDecimal(\"123.456\");BigDecimal d2 = new BigDecimal(\"23.456789\");BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽 divideAndRemainder()：返回除数和余数！ signum()：有余数返回1，余数为0返回0！ 调用divideAndRemainder()方法时，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个BigDecimal是否是整数倍数： 123456789101112BigDecimal n = new BigDecimal(\"12.345\");BigDecimal m = new BigDecimal(\"0.12\");BigDecimal[] dr = n.divideAndRemainder(m);System.out.println(dr[0]); // 102System.out.println(dr[1]); // 0.105BigDecimal n = new BigDecimal(\"12.75\");BigDecimal m = new BigDecimal(\"0.15\");BigDecimal[] dr = n.divideAndRemainder(m);if (dr[1].signum() == 0) { // n是m的整数倍} BigDecimal比较 equal()方法，不但要求两个BigDecimal的值相等，还要求它们的scale()相等！ 可以使用stripTrailingZeros()去掉末尾0再比较！ 也可以使用compareTo()方法：它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。 比较必须使用compareTo()方法！ 12345BigDecimal d1 = new BigDecimal(\"123.456\");BigDecimal d2 = new BigDecimal(\"123.45600\");System.out.println(d1.equals(d2)); // false,因为scale不同System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2System.out.println(d1.compareTo(d2)); // 0 十、其他常用类1、Math类 Java标准库还提供了一个StrictMath，它提供了和Math几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，StrictMath保证所有平台计算结果都是完全相同的，而Math会尽量针对平台优化计算速度，所以，绝大多数情况下，使用Math就足够了。 abs()：绝对值 max()：最大 min()：最小 sqrt()：开方 exp()：e的x次方 log()：以e为底对数 log10()：以10为底对数 sin()、cos()、tan()、asin()、acos()：三角函数 PI：pai(3.14….) E：e(2.718….) 1234567891011121314151617Math.abs(-100); // 100Math.max(100, 99); // 100Math.min(1.2, 2.3); // 1.2Math.pow(2, 10); // 2的10次方=1024Math.sqrt(2); // 1.414...Math.exp(2); // 7.389...Math.log(4); // 1.386...Math.log10(100); // 2Math.sin(3.14); // 0.00159...Math.cos(3.14); // -0.9999...Math.tan(3.14); // -0.0015...Math.asin(1.0); // 1.57079...Math.acos(1.0); // 0.0double pi = Math.PI; // 3.14159...double e = Math.E; // 2.7182818...Math.sin(Math.PI / 6); // sin(π/6) = 0.5 2、Random类 Random用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。 要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()： 123456Random r = new Random();r.nextInt(); // 2071575453,每次都不一样r.nextInt(10); // 5,生成一个[0,10)之间的intr.nextLong(); // 8811649292570369305,每次都不一样r.nextFloat(); // 0.54335...生成一个[0,1)之间的floatr.nextDouble(); // 0.3716...生成一个[0,1)之间的double 倘若在创建实例时给定一个种子，则随机生成的数都是一定的，不会改变，不给种子是按照当前的时间戳自动确定种子，由于每时每刻时间不同，所以生成的数不同： 12Random r = new Random(3);System.out.println(r.nextInt());//-1155099828 3、SecureRandom类 有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的！ SecureRandom无法指定种子，它使用RNG（random number generator）算法。JDK的SecureRandom实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器： SecureRandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。 在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用SecureRandom来产生安全的随机数。 需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！ 虽然有点没看懂！以后回来再看！ 12345678910111213141516171819202122package com.test;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.util.Arrays;public class codeTest { public static void main(String[] args) { SecureRandom s = new SecureRandom(); System.out.println(s.nextInt()); SecureRandom sr = null; try { sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器 } catch (NoSuchAlgorithmException e) { sr = new SecureRandom(); // 获取普通的安全随机数生成器 } byte[] buffer = new byte[16]; sr.nextBytes(buffer); // 用安全随机数填充buffer System.out.println(Arrays.toString(buffer)); }} 常用Java核心类终于完结，敬请期待后续内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"String","slug":"String","permalink":"https://www.itnxd.cn/tags/String/"},{"name":"JavaBean","slug":"JavaBean","permalink":"https://www.itnxd.cn/tags/JavaBean/"},{"name":"包装类型","slug":"包装类型","permalink":"https://www.itnxd.cn/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"}],"author":"Mr.Niu"},{"title":"Java教程系列之面向对象编程","slug":"Java教程系列之面向对象编程","date":"2020-03-25T10:11:00.000Z","updated":"2021-02-06T14:14:42.095Z","comments":true,"path":"posts/40947.html","link":"","permalink":"https://www.itnxd.cn/posts/40947.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、class 和 instance 就是常说的类和实例！ 1、定义class 一个class可以包含多个字段（field），字段用来描述一个类的特征。 上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。因此，通过class，把一组数据汇集到一个对象上，实现了数据封装。 public是用来修饰字段的，它表示这个字段可以被外部访问。 123456789101112package com.test;public class codeTest { public static void main(String[] args) { }}class Person { public String name; public int age;} 2、创建instance 定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。 new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例： 访问实例变量可以用变量.字段 ! 小贴士：new出来的东西都在堆区，其他在栈区！ 123456789101112131415package com.test;public class codeTest { public static void main(String[] args) { Person ming = new Person(); ming.name = \"Xiao Ming\"; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = \"Xiao Hong\"; hong.age = 15; }} 上面创建的两个实例分别指向两块内存，存放在堆中！ 二、普通方法 通过在类的内部定义方法可以实现数据的封装，由于private的特性可以保证外部无法访问到私有成员field！ 一般使用set和get函数来进行赋值和获取，而字段field是private的，可以保证不被外部所修改！保证数据的安全性！ 1234567891011121314151617181920212223242526272829303132public class Main { public static void main(String[] args) { Person ming = new Person(); ming.setName(\"Xiao Ming\"); // 设置name ming.setAge(12); // 设置age System.out.println(ming.getName() + \", \" + ming.getAge()); }}class Person { private String name; private int age; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public int getAge() { return this.age; } public void setAge(int age) { if (age &lt; 0 || age &gt; 100) { throw new IllegalArgumentException(\"invalid age value\"); } this.age = age; }} 1、定义方法 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。 1234修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值;} 2、private方法 和private字段一样，private方法不允许外部调用，那我们定义private方法有什么用？ 定义private方法的理由是内部方法是可以调用private方法的。例如： 12345678910111213141516171819202122232425public class Main { public static void main(String[] args) { Person ming = new Person(); ming.setBirth(2008); System.out.println(ming.getAge()); }}class Person { private String name; private int birth; public void setBirth(int birth) { this.birth = birth; } public int getAge() { return calcAge(2019); // 调用private方法 } // private方法: private int calcAge(int currentYear) { return currentYear - this.birth; }} 观察上述代码，calcAge()是一个private方法，外部代码无法调用，但是，内部方法getAge()可以调用它。 此外，我们还注意到，这个Person类只定义了birth字段，没有定义age字段，获取age时，通过方法getAge()返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心Person实例在内部到底有没有age字段。 3、this变量 在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。因此，通过this.field就可以访问当前实例的字段。 3.1 没有命名冲突，直接return1234567class Person { private String name; public String getName() { return name; // 相当于this.name }} 3.2 有冲突，使用this.field1234567class Person { private String name; public void setName(String name) { this.name = name; // 前面的this不可少，少了就变成局部变量name了 }} 4、方法参数 方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递，对应位置对应相等！ 4.1 不可变参数123456class Person { ... public void setNameAndAge(String name, int age) { ... }} 4.2 可变参数 可变参数用类型...定义，可变参数相当于数组类型： 1234567class Group { private String[] names; public void setNames(String... names) { this.names = names; }} 也可以直接接收数组 1234567class Group { private String[] names; public void setNames(String[] names) { this.names = names; }} 二者的区别： 第一种可以直接方便的传参，而第二种只能使用new来传参，相比之下，第一种更加方便！ 123456789101112131415public class Main { public static void main(String[] args) { // 第一种： Group g = new Group(); g.setNames(\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"); // 传入3个String g.setNames(\"Xiao Ming\"); // 传入1个String g.setNames(); // 传入0个String // 第二种： Group g = new Group(); g.setNames(new String[] {\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"}); // 传入1个String[] }} 可变参数可以保证无法传入null，因为传入0个参数时，接收到的实际值是一个空数组而不是null。 5、参数绑定 基本类型参数的传递：是调用外部方法值的复制。双方各自的后续修改，互不影响。 引用类型参数的绑定：调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。 下面就是引用型参数例子，main中的修改会影响到类的field，因为指向的是同一块内存地址！ 12345678910111213141516171819202122public class Main { public static void main(String[] args) { Person p = new Person(); String[] fullname = new String[] { \"Homer\", \"Simpson\" }; p.setName(fullname); // 传入fullname数组 System.out.println(p.getName()); // \"Homer Simpson\" fullname[0] = \"Bart\"; // fullname数组的第一个元素修改为\"Bart\" System.out.println(p.getName()); // \"Homer Simpson\"还是\"Bart Simpson\"? }}class Person { private String[] name; public String getName() { return this.name[0] + \" \" + this.name[1]; } public void setName(String[] name) { this.name = name; }} 三、构造方法 在创建对象实例时就把内部字段进行初始化的操作！ 1、构造方法 没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false： 默认任何class都有构造方法！ 编译器自动生成：它没有参数，也没有执行语句，类似这样： 1234class Person { public Person() { }} 如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法： 如下方：无法找到默认构造函数Person()！ 1234567891011121314151617181920212223public class Main { public static void main(String[] args) { Person p = new Person(); // 编译错误:找不到这个构造方法 }}class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return this.name; } public int getAge() { return this.age; }} 当然可以将原来的默认方法与自定义的构造方法通过重载都写出来！ 2、构造方法重载 默认的构造方法依然可以使用！ 在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分 1234567891011121314151617class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this.name = name; this.age = 12; } public Person() { }} 3、构造方法自我调用 一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)： 1234567891011121314151617class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this(name, 18); // 调用另一个构造方法Person(String, int) } public Person() { this(\"Unnamed\"); // 调用另一个构造方法Person(String) }} 四、继承 继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让Student从Person继承时，Student就获得了Person的所有功能，我们只需要为Student编写新增的功能。 1、使用extends实现继承 在OOP的术语中，我们把Person称为超类（super class），父类（parent class），基类（base class），把Student称为子类（subclass），扩展类（extended class）。 123456789101112131415161718class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...}}class Student extends Person { // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() { … } public void setScore(int score) { … }} 注意到我们在定义Person的时候，没有写extends。在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类。 Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。 2、使用protected 子类无法访问父类的private的字段field，可以使用protected来修饰字段，使得该字段可以在一个继承树中被访问！ protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问 12345678910class Person { protected String name; protected int age;}class Student extends Person { public String hello() { return \"Hello, \" + name; // OK! }} 3、super super关键字表示父类（超类）。子类引用父类的字段时，可以用s uper.fieldName! 12345class Student extends Person { public String hello() { return \"Hello, \" + super.name; }} 使用super.name，或者this.name，或者name，效果都是一样的。编译器会自动定位到父类的name字段。 在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super(); 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。 小贴士：子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。 若父类是默认构造方法，则子类使用时会自动调用，不需要写；若是自定义构造方法，需要调用super并加上参数！ 12345678910111213141516171819202122232425public class Main { public static void main(String[] args) { Student s = new Student(\"Xiao Ming\", 12, 89); }}class Person { protected String name; protected int age; public Person(String name, int age) { this.name = name; this.age = age; }}class Student extends Person { protected int score; public Student(String name, int age, int score) { super(name, age); // 自动调用父类的构造方法 this.score = score; }} 4、向上转型 把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。 Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！ 继承树是Student &gt; Person &gt; Object ，所以可以把Student类型转型为Person，或者更高层次的Object。 老子可以拓展到儿子级别扩大功能！！！。。 1234Student s = new Student();Person p = new Person();Person p = new Student(); // ??? 5、向下转型 和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting） 1234Person p1 = new Student(); // upcasting, okPerson p2 = new Person();Student s1 = (Student) p1; // okStudent s2 = (Student) p2; // runtime error! ClassCastException! Person类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。在向下转型的时候，把p1转型为Student会成功，因为p1确实指向Student实例，把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。 向下转型错误时候，Java虚拟机会报ClassCastException。 总而言之：就是少的可以拓展为多的，多的无法删减为少的（从左到右说）！ 使用instanceof instanceof实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false。 如果实里原来就是子类，则将其向下转型时是可以正确转型的！ 可以使用instaceof 来判断原来是不是子类，使得话则可以向下转型，这样就可以避免转型错误的发生！ 12345Person p = new Student();if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功} 从Java 14开始，判断instanceof后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码： 直接使用obj instanceof String s 即可在判断可以向下转型的条件下直接进行转型到变量 s！ 使用instanceof variable这种判断并转型为指定类型变量的语法时，必须打开编译器开关--source 14和--enable-preview。 这是java14的语法！ 1234567891011Object obj = \"hello\";if (obj instanceof String) { String s = (String) obj; System.out.println(s.toUpperCase());}Object obj = \"hello\";if (obj instanceof String s) { // 可以直接使用变量s: System.out.println(s.toUpperCase());} 五、多态1、覆写（Override） 在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。 Override和Overload不同的是，如果方法签名不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是Override。 就和重载一样，全部一样才是才叫覆写！ 123456789101112class Person { public void run() { System.out.println(\"Person.run\"); }}class Student extends Person { @Override public void run() { System.out.println(\"Student.run\"); }} 2、关于@Override 加上@Override可以让编译器来判断你是不是进行覆写时参数或类型写错了，若不同则会直接编译错误！ 倘若不加的话，是不会去检查的，编译器认为这是你新写的方法，编译通过！ 如下方：加上，编译错误，不加，编译通过！ 1234567891011121314public class Main { public static void main(String[] args) { }}class Person { public void run() {}}public class Student extends Person { //@Override // Compile error! public void run(String s) {}} 3、多态（Polymorphic） 多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法 1234public void runTwice(Person p) { p.run(); p.run();} 它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。 所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？ 举个例子: 三种收税情况，覆写三种getTax函数，利用多态自动调用需要的覆写方法！ 观察totalTax()方法：利用多态，totalTax()方法只需要和Income打交道，它完全不需要知道Salary和StateCouncilSpecialAllowance的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从Income派生，然后正确覆写getTax()方法就可以。把新的类型传入totalTax()，不需要修改任何代码。 可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Main { public static void main(String[] args) { // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes = new Income[] { new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) }; System.out.println(totalTax(incomes)); } public static double totalTax(Income... incomes) { double total = 0; for (Income income: incomes) { total = total + income.getTax(); } return total; }}class Income { protected double income; public Income(double income) { this.income = income; } public double getTax() { return income * 0.1; // 税率10% }}class Salary extends Income { public Salary(double income) { super(income); } @Override public double getTax() { if (income &lt;= 5000) { return 0; } return (income - 5000) * 0.2; }}class StateCouncilSpecialAllowance extends Income { public StateCouncilSpecialAllowance(double income) { super(income); } @Override public double getTax() { return 0; }} 覆写object方法 因为所有的class最终都继承自Object，而Object定义了几个重要的方法： toString()：把instance输出为String； equals()：判断两个instance是否逻辑相等； hashCode()：计算一个instance的哈希值。 1234567891011121314151617181920212223242526class Person { ... // 显示更有意义的字符串: @Override public String toString() { return \"Person:name=\" + name; } // 比较是否相等: @Override public boolean equals(Object o) { // 当且仅当o为Person类型: if (o instanceof Person) { Person p = (Person) o; // 并且name字段相同时，返回true: return this.name.equals(p.name); } return false; } // 计算hash: @Override public int hashCode() { return this.name.hashCode(); }} 调用super 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。 1234567891011121314class Person { protected String name; public String hello() { return \"Hello, \" + name; }}Student extends Person { @Override public String hello() { // 调用父类的hello()方法: return super.hello() + \"!\"; }} 使用final 继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override： 12345678910111213class Person { protected String name; public final String hello() { return \"Hello, \" + name; }}Student extends Person { // compile error: 不允许覆写 @Override public String hello() { }} 如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承： 1234567final class Person { protected String name;}// compile error: 不允许继承自PersonStudent extends Person {} 对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改 可使用构造方法来进行给final字段赋值，赋值完毕，值将不可修改！ 1234567891011121314class Person { public final String name = \"Unamed\";}Person p = new Person();p.name = \"New Name\"; // compile error!// 定义构造函数赋值final字段class Person { public final String name; public Person(String name) { this.name = name; }} 4、一句话总结多态： JAVA变量在调用类方法时，以实际指向的实例类型为准，而不是声明类型 六、抽象类 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法： 把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person类也无法被实例化。编译器会告诉我们，无法编译Person类，因为它包含抽象方法。 必须把Person类本身也声明为abstract，才能正确编译它： 抽象方法不需要写大括号！ 123abstract class Person { public abstract void run();} 1、抽象类 如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。 因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。 使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类： 无法实例化的抽象类有什么用？ 因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。 例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法： 1234567891011121314151617public class Main { public static void main(String[] args) { Person p = new Student(); p.run(); }}abstract class Person { public abstract void run();}class Student extends Person { @Override public void run() { System.out.println(\"Student.run\"); }} 倘若不进行覆写run方法，则会直接编译错误！ 2、面向抽象编程 当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例： 这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型： 同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型： 这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。 12345678910Person s = new Student();Person t = new Teacher();// 不关心Person变量的具体子类型:s.run();t.run();// 同样不关心新的子类是如何实现run()方法的：Person e = new Employee();e.run(); 面向抽象编程的本质就是： 上层代码只定义规范（例如：abstract class Person）； 不需要子类就可以实现业务逻辑（正常编译）； 具体的业务逻辑由不同的子类实现，调用者并不关心。 七、接口 在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。 如果一个抽象类没有字段，所有方法全部都是抽象方法： 1234abstract class Person { public abstract void run(); public abstract String getName();} 1、接口（interface）就可以把该抽象类改写为接口：interface。 在Java中，使用interface可以声明一个接口： 所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。 Java的接口特指interface的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。 1234interface Person { void run(); String getName();} 2、implements 当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子： 1234567891011121314151617class Student implements Person { private String name; public Student(String name) { this.name = name; } @Override public void run() { System.out.println(this.name + \" run\"); } @Override public String getName() { return this.name; }} 我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，例如： 123class Student implements Person, Hello { // 实现了两个interface ...} 3、接口继承 一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如： 此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口。 12345678interface Hello { void hello();}interface Person extends Hello { void run(); String getName();} 4、抽象类与接口 合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度。 在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象! 5、default方法 在接口中，可以定义default方法。例如，把Person接口的run()方法改为default方法： 实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。 default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。 12345678910111213141516171819202122232425public class Main { public static void main(String[] args) { Person p = new Student(\"Xiao Ming\"); p.run(); }}interface Person { String getName(); default void run() { System.out.println(getName() + \" run\"); }}class Student implements Person { private String name; public Student(String name) { this.name = name; } public String getName() { return this.name; }} 6、一些接口的笔记为什么要有接口因为java中为了避免多重继承可能带来的继承关系混乱所以只允许单一继承，java为了 满足多重继承的需要，采用了规格的多重继承即接口,如果使用，即使没有继承关系的不同种类的对象也可以做共通的处理（我们可以在接口中定义一个方法，然后在两个没有继承关系的对象的不同父类中写一个相同方法签名和返回类型的方法） 接口和抽象类的区别 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实例是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。 类实现两个接口有同名方法时会发生的几种情况： 两个接口方法签名相同返回类型相同时 不会编译出错，可以直接override 两个接口方法签名相同返回类型不同，会编译出错。 两个接口方法名相同,在实现类里这两个同名方法签名符合overload条件的话可以同时实现不会报错，只要符合overload那方法返回类型就不重要了，一样不会报错。 类实现两个接口有同名default方法时会发生的几种情况 如果两个方法的方法签名相同方法返回类型相同那么需要在实现类override这个同名方法。 如果两个方法方法签名相同，返回类型不同会编译出错。 如果两个方法符合overload条件可以正常实现。 关于接口中的静态方法，静态变量静态变量： 可直接通过实现类或者实现类的实例直接访问到接口的静态变量,但如果多继承时这样调用会编译出错。 静态方法 无法通过实现类和它的实例访问到接口的静态方法 八、静态字段和静态方法1、静态字段 在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。 还有一种字段，是用static修饰的字段，称为静态字段：static field。 实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段 1234567891011121314151617181920212223public class Main { public static void main(String[] args) { Person ming = new Person(\"Xiao Ming\", 12); Person hong = new Person(\"Xiao Hong\", 15); ming.number = 88; System.out.println(hong.number); hong.number = 99; System.out.println(ming.number); }}class Person { public String name; public int age; public static int number; public Person(String name, int age) { this.name = name; this.age = age; }} 如下图： 12345678910111213141516 ┌──────────────────┐ming ──&gt;│Person instance │ ├──────────────────┤ │name = \"Xiao Ming\"│ │age = 12 │ │number ───────────┼──┐ ┌─────────────┐ └──────────────────┘ │ │Person class │ │ ├─────────────┤ ├───&gt;│number = 99 │ ┌──────────────────┐ │ └─────────────┘hong ──&gt;│Person instance │ │ ├──────────────────┤ │ │name = \"Xiao Hong\"│ │ │age = 15 │ │ │number ───────────┼──┘ └──────────────────┘ 虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。 因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。 推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。对于上面的代码，更好的写法是： 12Person.number = 99;System.out.println(Person.number); 2、静态方法 有静态字段，就有静态方法。用static修饰的方法称为静态方法。 调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数! 因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。 通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。 通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。 1234567891011121314public class Main { public static void main(String[] args) { Person.setNumber(99); System.out.println(Person.number); }}class Person { public static int number; public static void setNumber(int value) { number = value; }} 3、接口静态字段 因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型。 实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉！ 编译器会自动把该字段变为public static final类型。 记得一个java文件只能有一个public类哦！ 1234567891011public interface Person { public static final int MALE = 1; public static final int FEMALE = 2;}// 改进写法！public interface Person { // 编译器会自动加上public statc final: int MALE = 1; int FEMALE = 2;} 九、包（package）1、package 在Java中，我们使用package来解决名字冲突。 Java定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是包名.类名。 包可以是多层结构，用.隔开。例如：java.util。 没有定义包名的class，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。 要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。 123456789101112package ming; // 申明包名mingpublic class Person { }// 第二个包package mr.jun; // 申明包名mr.junpublic class Arrays { } 我们还需要按照包结构把上面的Java文件组织起来。假设以package_sample作为根目录，src作为源码目录，那么所有文件结构就是： 123456789package_sample└─ src ├─ hong │ └─ Person.java │ ming │ └─ Person.java └─ mr └─ jun └─ Arrays.java 编译后的.class文件也需要按照包结构存放。如果使用IDE，把编译后的.class文件放到bin目录下，那么，编译的文件结构就是： 123456789package_sample└─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class 2、包作用域 位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。 123456789101112131415161718package hello;public class Person { // 包作用域: void hello() { System.out.println(\"Hello!\"); }}// 同包调用package hello;public class Main { public static void main(String[] args) { Person p = new Person(); p.hello(); // 可以调用，因为Main和Person在同一个包 }} 3、import 为了引用其他包的类可以使用import导入包名！ 导入也可以直接写完整路径，很明显，不这样做！ 1234567891011121314151617181920// Person.javapackage ming;public class Person { public void run() { mr.jun.Arrays arrays = new mr.jun.Arrays(); }}// Person.javapackage ming;// 导入完整类名:import mr.jun.Arrays;public class Person { public void run() { Arrays arrays = new Arrays(); }} 在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）： 我们一般不推荐这种写法，因为在导入了多个包后，很难看出Arrays类属于哪个包。 1234567891011// Person.javapackage ming;// 导入mr.jun包的所有class:import mr.jun.*;public class Person { public void run() { Arrays arrays = new Arrays(); }} 还有一种import static的语法，它可以导入可以导入一个类的静态字段和静态方法： import static很少使用。 1234567891011package main;// 导入System类的所有静态字段和静态方法:import static java.lang.System.*;public class Main { public static void main(String[] args) { // 相当于调用System.out.println(…) out.println(\"Hello, world!\"); }} 4、包命名为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如： org.apache org.apache.commons.log com.niuge.sample 子包就可以根据功能自行命名。 5、class查找顺序Java编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时： 如果是完整类名，就直接根据完整类名查找这个class； 如果是简单类名，按下面的顺序依次查找： 查找当前package是否存在这个class； 查找import的包是否包含这个class； 查找java.lang包是否包含这个class。 如果按照上面的规则还无法确定类名，则编译报错。 因此，编写class的时候，编译器会自动帮我们做两个import动作： 默认自动import当前package的其他class； 默认自动import java.lang.*。 注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。 如果有两个class名称相同，例如，mr.jun.Arrays和java.util.Arrays，那么只能import其中一个，另一个必须写完整类名。 十、作用域 在Java中，我们经常看到public、protected、private这些修饰符。在Java中，这些修饰符可以用来限定访问作用域。 1、public 定义为public的class、interface可以被其他任何类访问： 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限： 导入包，只可以访问public类型的class等等！ 2、private 定义为private的field、method无法被其他类访问： 实际上，确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面，因为public方法定义了类对外提供的功能，阅读代码的时候，应该先关注public方法： 12345678910package abc;public class Hello { public void hello() { this.hi(); } private void hi() { }} 嵌套类 Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限： 定义在一个class内部的class称为嵌套类（nested class），Java支持好几种嵌套类。 内部嵌套类必须使用static修饰！ 123456789101112131415161718public class Main { public static void main(String[] args) { Inner i = new Inner(); i.hi(); } // private方法: private static void hello() { System.out.println(\"private hello!\"); } // 静态内部类: static class Inner { public void hi() { Main.hello(); } }} 3、protected protected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类： 4、包作用域详见第九点的小2！ 5、局部变量 在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。 6、final请查看第五点的小3的final！ 7、tips 如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法。 把方法定义为package权限有助于测试，因为测试类和被测试类只要位于同一个package，测试代码就可以访问被测试类的package权限方法。 一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。 十一、classpath和jar 廖雪峰本节教程参考！点击这里！ 1、classpath classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。 因为Java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。 一般不需要设置，IDE编译时会自动引入当前bin目录的参数！。。。。 所以，classpath就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用;分隔，带空格的目录用\"\"括起来，可能长这样： 1C:\\work\\project1\\bin;C:\\shared;\"D:\\My Documents\\project1\\bin\" 在Linux系统上，用:分隔，可能长这样： 1/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin 现在我们假设classpath是.;C:\\work\\project1\\bin;C:\\shared，当JVM在加载abc.xyz.Hello这个类时，会依次查找： &lt;当前目录&gt;\\abc\\xyz\\Hello.class C:\\work\\project1\\bin\\abc\\xyz\\Hello.class C:\\shared\\abc\\xyz\\Hello.class 注意到.代表当前目录。如果JVM在某个路径下找到了对应的class文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。 classpath的设定方法有两种： 在系统环境变量中设置classpath环境变量，不推荐； 在启动JVM时设置classpath变量，推荐。 我们强烈不推荐在系统环境变量中设置classpath，那样会污染整个系统环境。在启动JVM时设置classpath才是推荐的做法。实际上就是给java命令传入-classpath或-cp参数： 1java -classpath .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello 或者使用-cp的简写： 1java -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello 没有设置系统环境变量，也没有传入-cp参数，那么JVM默认的classpath为.，即当前目录： 1java abc.xyz.Hello 上述命令告诉JVM只在当前目录搜索Hello.class。 在IDE中运行Java程序，IDE自动传入的-cp参数是当前工程的bin目录和引入的jar包。 通常，我们在自己编写的class中，会引用Java核心库的class，例如，String、ArrayList等。这些class应该上哪去找？ 有很多“如何设置classpath”的文章会告诉你把JVM自带的rt.jar放入classpath，但事实上，根本不需要告诉JVM如何去Java核心库查找class，JVM怎么可能笨到连自己的核心库在哪都不知道？ 不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！ 更好的做法是，不要设置classpath！默认的当前目录.对于绝大多数情况都够用了。 2、jar 如果有很多.class文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。 jar包就是用来干这个事的，它可以把package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。 jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的class，就可以把jar包放到classpath中： 就是用来打包class的文件！ 1java -cp ./hello.jar abc.xyz.Hello 这样JVM会自动在hello.jar文件里去搜索某个类。 那么问题来了：如何创建jar包？ 因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从.zip改为.jar，一个jar包就创建成功。 假设编译输出的目录结构是这样： 123456789package_sample└─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class 这里需要特别注意的是，jar包里的第一层目录，不能是bin，而应该是hong、ming、mr。 打包位置应该是bin目录进去之后，或者是IDEA的out目录进去之后！ jar包还可以包含一个特殊的/META-INF/MANIFEST.MF文件，MANIFEST.MF是纯文本，可以指定Main-Class和其它信息。JVM会自动读取这个MANIFEST.MF文件，如果存在Main-Class，我们就不必在命令行指定启动的类名，而是用更方便的命令： 1java -jar hello.jar jar包还可以包含其它jar包，这个时候，就需要在MANIFEST.MF文件里配置classpath了。 在大型项目中，不可能手动编写MANIFEST.MF文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如Maven，可以非常方便地创建jar包。 十二、模块 廖雪峰模块教程，点击这里！ 从Java 9开始，JDK又引入了模块（Module）。 我们知道，.class文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆.class文件，很不便于管理，所以，jar文件就是class文件的容器。 在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫rt.jar，一共有60多M。 如果是自己开发的程序，除了一个自己的app.jar以外，还需要一堆第三方的jar包 此节有点复杂以后回来再看！。。。 1、模块运行一个Java程序，一般来说，命令行写这样： 1java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main 注意：JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。 如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出ClassNotFoundException。 所以，jar只是用于存放class的容器，它并不关心class之间的依赖。 从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果a.jar必须依赖另一个b.jar才能运行，那我们应该给a.jar加点说明啥的，让程序在编译和运行的时候能自动定位到b.jar，这种自带“依赖关系”的class容器就是模块。 为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的rt.jar分拆成了几十个模块，这些模块以.jmod扩展名标识，可以在$JAVA_HOME/jmods目录下找到它们： java.base.jmod java.compiler.jmod java.datatransfer.jmod java.desktop.jmod … 这些.jmod文件每一个都是一个模块，模块名就是文件名。例如：模块java.base对应的文件就是java.base.jmod。模块之间的依赖关系已经被写入到模块内的module-info.class文件了。所有的模块都直接或间接地依赖java.base模块，只有java.base模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从Object直接或间接继承而来。 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。 2、编写模块那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以oop-module工程为例，它的目录结构如下： 12345678910oop-module├── bin├── build.sh└── src ├── com │ └── itranswarp │ └── sample │ ├── Greeting.java │ └── Main.java └── module-info.java 其中，bin目录存放编译后的class文件，src目录存放源码，按包名的目录结构存放，仅仅在src目录下多了一个module-info.java这个文件，这就是模块的描述文件。在这个模块中，它长这样： 1234module hello.world { requires java.base; // 可不写，任何模块都会自动引入java.base requires java.xml;} 其中，module是关键字，后面的hello.world是模块的名称，它的命名规范与包一致。花括号的requires xxx;表示这个模块需要引用的其他模块名。除了java.base可以被自动引入外，这里我们引入了一个java.xml的模块。 当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，Main.java代码如下： 1234567891011package com.itranswarp.sample;// 必须引入java.xml模块后才能使用其中的类:import javax.xml.XMLConstants;public class Main { public static void main(String[] args) { Greeting g = new Greeting(); System.out.println(g.hello(XMLConstants.XML_NS_PREFIX)); }} 如果把requires java.xml;从module-info.java中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。 下面，我们用JDK提供的命令行工具来编译并创建模块。 首先，我们把工作目录切换到oop-module，在当前目录下编译所有的.java文件，并存放到bin目录下，命令如下： 1$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java 如果编译成功，现在项目结构如下： 123456789101112131415oop-module├── bin│ ├── com│ │ └── itranswarp│ │ └── sample│ │ ├── Greeting.class│ │ └── Main.class│ └── module-info.class└── src ├── com │ └── itranswarp │ └── sample │ ├── Greeting.java │ └── Main.java └── module-info.java 注意到src目录下的module-info.java被编译到bin目录下的module-info.class。 下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入--main-class参数，让这个jar包能自己定位main方法所在的类： 1$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin . 现在我们就在当前目录下得到了hello.jar这个jar包，它和普通jar包并无区别，可以直接使用命令java -jar hello.jar来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的jmod命令把一个jar包转换成模块： 1$ jmod create --class-path hello.jar hello.jmod 于是，在当前目录下我们又得到了hello.jmod这个模块文件，这就是最后打包出来的传说中的模块！ 3、运行模块 要运行一个jar，我们使用java -jar xxx.jar命令。要运行一个模块，我们只需要指定模块名。试试： 1$ java --module-path hello.jmod --module hello.world 结果是一个错误： 12Error occurred during initialization of boot layerjava.lang.module.FindException: JMOD format not supported at execution time: hello.jmod 原因是.jmod不能被放入--module-path中。换成.jar就没问题了： 12$ java --module-path hello.jar --module hello.worldHello, xml! 那我们辛辛苦苦创建的hello.jmod有什么用？答案是我们可以用它来打包JRE。 4、打包JRE 前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的rt.jar拆成了几十个.jmod模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。 过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？ 现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了jlink命令来干这件事。命令如下： 1$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/ 我们在--module-path参数指定了我们自己的模块hello.jmod，然后，在--add-modules参数中指定了我们用到的3个模块java.base、java.xml和hello.world，用,分隔。最后，在--output参数指定输出目录。 现在，在当前目录下，我们可以找到jre目录，这是一个完整的并且带有我们自己hello.jmod模块的JRE。试试直接运行这个JRE： 12$ jre/bin/java --module hello.worldHello, xml! 要分发我们自己的Java应用程序，只需要把这个jre目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。 5、访问权限 前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。 确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。 举个例子：我们编写的模块hello.world用到了模块java.xml的一个类javax.xml.XMLConstants，我们之所以能直接使用这个类，是因为模块java.xml的module-info.java中声明了若干导出： 123456module java.xml { exports java.xml; exports javax.xml.catalog; exports javax.xml.datatype; ...} 只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的hello.world模块中的com.itranswarp.sample.Greeting类，我们必须将其导出： 123456module hello.world { exports com.itranswarp.sample; requires java.base; requires java.xml;} 因此，模块进一步隔离了代码的访问权限。 Java面向对象告一段落了，敬请期待后序内容！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://www.itnxd.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"author":"Mr.Niu"},{"title":"AcWing-41.包含min函数的栈","slug":"AcWing-41-包含min函数的栈","date":"2020-03-23T12:11:57.000Z","updated":"2021-02-06T13:56:26.287Z","comments":true,"path":"posts/50257.html","link":"","permalink":"https://www.itnxd.cn/posts/50257.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：41. 包含min函数的栈 题目背景： 来源：剑指Offer,《算法竞赛进阶指南》, 美国 Hulu公式 面试题！ 两种做法：详细见下文！ 题目描述设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。 push(x)–将元素x插入栈中 pop()–移除栈顶元素 top()–得到栈顶元素 getMin()–得到栈中最小元素 样例12345678MinStack minStack = new MinStack();minStack.push(-1);minStack.push(3);minStack.push(-4);minStack.getMin(); --&gt; Returns -4.minStack.pop();minStack.top(); --&gt; Returns 3.minStack.getMin(); --&gt; Returns -1. 题目分析：题目要求：在普通栈的基础上实现一个可以实时获得最小值的 最小栈 ，而且使得复杂度达到O(1)的效果！ 解题思路：第一想法：暴力即可，其他操作都是O(1)的，只有获得最小值的操作不好弄，暴力的话直接扫描一遍，复杂度为O(N)，很明显不合题意！ 好了，正确解法开始！ 解法一：维护两个栈，一个为普通栈，一个为保存前i个数最小值的栈！ 最小栈的第i个位置永远保存前i个位置的最小值！ 最小栈的实现： push时：为空直接压入，不为空只需要判断当前栈顶与当前值得大小取一下min放入栈中即可！ pop时：直接删除即可！ top时：返回普通栈栈顶！ getMin时：直接返回栈顶即可！ 解法二：维护两个栈，一个为普通栈，一个为单调栈！ 单调栈就是：简而言之：就是具有单调性的栈！ 单调栈的实现： 当我们向栈中压入一个数时，如果该数 &lt;= 单调栈的栈顶元素，则将该数同时压入单调栈中； 否则，不压入，这是由于栈具有先进后出性质，所以在该数被弹出之前，栈中一直存在一个数比该数小，所以该数一定不会被当做最小数输出。 当我们从栈中弹出一个数时，如果该数等于单调栈的栈顶元素，则同时将单调栈的栈顶元素弹出。 单调栈由于其具有单调性，所以它的栈顶元素，就是当前栈中的最小数。 其实两种做法很类似的，但解法二用来单调栈的思想！ 可以参考一下的讲解或许会更加清楚！ yxc大神的题解，点击这里！ yxc大神的视频讲解，点击这里！ 题解：解法一：维护前i个数的最小值栈123456789101112131415161718192021222324252627282930313233343536class MinStack {public: /** initialize your data structure here. */ stack&lt;int&gt; stk, stk_min; MinStack() { } void push(int x) { stk.push(x); if(stk_min.size()) x = min(x, stk_min.top()); stk_min.push(x); } void pop() { stk.pop(); stk_min.pop(); } int top() { return stk.top(); } int getMin() { return stk_min.top(); }};/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 解法二：维护一个单调栈12345678910111213141516171819202122232425262728293031323334353637class MinStack {public: /** initialize your data structure here. */ stack&lt;int&gt; stk, stk_min; MinStack() { } void push(int x) { stk.push(x); if(stk_min.empty() || x &lt;= stk_min.top()) stk_min.push(x); } void pop() { if(stk_min.top() == stk.top()) stk_min.pop(); stk.pop(); } int top() { return stk.top(); } int getMin() { return stk_min.top(); }};/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"},{"name":"单调栈","slug":"单调栈","permalink":"https://www.itnxd.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"author":"Mr.Niu"},{"title":"AcWing-114.国王游戏","slug":"AcWing-114-国王游戏","date":"2020-03-18T13:12:46.000Z","updated":"2021-02-06T14:10:53.366Z","comments":true,"path":"posts/55540.html","link":"","permalink":"https://www.itnxd.cn/posts/55540.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：114. 国王游戏 题目背景： 贪心 + 高精度 以前好像在牛客做过一次。。。 以前的题解链接：点击这里！ 可以再一次温习一下高精度写法以及本题的贪心思路！ 题目描述恰逢 H 国国庆,国王邀请 n 位大臣来玩一个有奖游戏。 首先,他让每个大臣在左、右手上面分别写下一个整数,国王自己也在左、右手上各写一个整数。 然后,让这 n 位大臣排成一排,国王站在队伍的最前面。 排好队后,所有的大臣都会获得国王奖赏的若干金币,每位大臣获得的金币数分别是: 排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数,然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏,所以他想请你帮他重新安排一下队伍的顺序,使得获得奖赏最多的大臣,所获奖赏尽可能的少。 注意,国王的位置始终在队伍的最前面。 输入格式第一行包含一个整数 n,表示大臣的人数。 第二行包含两个整数 a 和 b,之间用一个空格隔开,分别表示国王左手和右手上的整数。 接下来 n 行,每行包含两个整数 a 和 b,之间用一个空格隔开,分别表示每个大臣左手和右手上的整数。 输出格式输出只有一行,包含一个整数,表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 数据范围1≤n≤10000&lt;a,b&lt;10000 输入样例：1234531 12 37 44 6 输出样例：12 题目分析：题目要求：一个国王，n个大臣，排成一排，国王在最前边，发一些金币，大臣得到的金币数计算方法为，大臣前面的所有人的左手上的数字乘积除以自己右手的数下取整的到的数。 通过一定的排序，想要达到一个得到金币最多的大臣得到的金币尽可能少！ 最后输出这个大臣的金币数！ 解题思路：贪心思路：（猜想。。） 按照大臣的左右手乘积从小到大排序，然后找出最大值！ 证明过程： 由于是累乘，而且每个数最大为10000，则必须使用高精度来存储： 涉及到高精度乘法，除法，比较大小的操作。 这里不做介绍了，参考下面高精度模板： 我的傻瓜解释版高精度模板！ yxc官网高精度模板！ 相关题解如下： 以前做过一次的题解：点击这里！ yxc大神的题解及证明过程！ yxc视频讲解，点击这里！ 题解：这里涉及到的计算都是高精度乘除一个小的数！ 比较简单！ 可以使用pair来存储 a*b 和 a ，另一个没有存储的数可以直接由二者计算得到！同时也可以借助pair默认排序安装第一个参数排序。。 同时比较两个vector的大小可以借助vector的自动按照字典序比较，当然我们得从高位到低位进行字典序比较，所以需要将vector反转一下，变成下标为0存储最高位即可！ 反转方法：可以使用vector构造函数： 1vector&lt;int&gt;(a.rbegin(), a.rend()) 也可以使用： 1reverse(c.begin(), c.end()); 注意：后者会修改原vector！ 参考具体代码进行理解！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;const int N = 1010;int n;PII T[N];LL S[N], maxn;// 692// i=2、1、0vector&lt;int&gt; mul(vector&lt;int&gt; a, int b){ int t = 0; vector&lt;int&gt; c; for(int i = 0; i &lt; a.size(); i++) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while(t) c.push_back(t % 10), t /= 10; return c;}vector&lt;int&gt; div(vector&lt;int&gt; a, int b){ int t = 0; vector&lt;int&gt; c; bool is_0 = false; for(int i = a.size() - 1; i &gt;= 0; i--) { t = t * 10 + a[i]; int x = t / b; // x 不为0 或前导不是0 if(x || is_0) { is_0 = true; c.push_back(x); } t %= b; } reverse(c.begin(), c.end()); return c;}vector&lt;int&gt; max_vec(vector&lt;int&gt; a, vector&lt;int&gt; b){ if(a.size() &gt; b.size()) return a; if(a.size() &lt; b.size()) return b; if(vector&lt;int&gt;(a.rbegin(), a.rend()) &lt; vector&lt;int&gt;(b.rbegin(), b.rend())) return b; else return a; }void print(vector&lt;int&gt; res){ for(int i = res.size() - 1; i &gt;= 0; i --) cout &lt;&lt; res[i];}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt;= n; i++) { int l, r; cin &gt;&gt; l &gt;&gt; r; T[i] = {l * r, l}; } sort(T + 1, T + n + 1); vector&lt;int&gt; p(1, T[0].second); // 记录累乘 vector&lt;int&gt; res(1, 0); // 记录最大结果 for(int i = 1; i &lt;= n; i++) { res = max_vec(res, div(p, T[i].first/T[i].second)); p = mul(p, T[i].second); } print(res); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"高精度","slug":"高精度","permalink":"https://www.itnxd.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}],"author":"Mr.Niu"},{"title":"蓝桥杯第十一届软件类校内模拟赛","slug":"蓝桥杯第十一届软件类校内模拟赛","date":"2020-03-17T10:53:00.000Z","updated":"2021-02-06T13:34:28.551Z","comments":true,"path":"posts/43446.html","link":"","permalink":"https://www.itnxd.cn/posts/43446.html","excerpt":"","text":"非编程题就不看了，都是水题！5、递增三元组问题描述 在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。 给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。 输入格式 输入的第一行包含一个整数 n。 第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。 输出格式 输出一行包含一个整数，表示答案。 样例输入1251 2 5 3 5 样例输出12 样例说明 a[2] 和 a[4] 可能是三元组的中心。 评测用例规模与约定 对于 50% 的评测用例，2 &lt;= n &lt;= 100，0 &lt;= 数列中的数 &lt;= 1000。 对于所有评测用例，2 &lt;= n &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。 题解一：暴力题解（或许超时）可以跨元素，并不是只能是挨着的三个！ 前面可以用最小值来找，后面直接循环一遍即可！ 我竟然没发现后面也可以存到数组去实现当前位置到最后元素的最大值！ 参考题解二！ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int a[N], n;int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int mina = a[1], res = 0; for(int j = 2; j &lt;= n - 1; j++) { bool flag1 = false, flag2 = false; mina = min(mina, a[j]); if(mina &lt; a[j]) flag1 = true; for(int k = j + 1; k &lt;= n; k++) if(a[j] &lt; a[k]) { flag2 = true; break; } if(flag1 &amp;&amp; flag2) res ++; } cout &lt;&lt; res &lt;&lt; endl; return 0;} 题解二：维护两个最大最小值数组先线性扫描维护两个数组！ 最小值数组，起点到当前位置的最小值； 最大值数组，终点到当前位置的最大值。 从前往后维护一个最小值数组 从后往前维护一个最大值数组 时间复杂度: O(N) 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int N = 1010;int a[N], n, small[N], big[N];int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; small[1] = a[1], big[n] = a[n]; for (int i = 2; i &lt;= n; i++) if (a[i] &lt; small[i - 1]) small[i] = a[i]; else small[i] = small[i - 1]; for (int i = n - 1; i &gt;= 1; i--) if (a[i] &gt; big[i + 1]) big[i] = a[i]; else big[i] = big[i + 1]; int res = 0; for (int i = 2; i &lt;= n - 1; i++) if (small[i - 1] &lt; a[i] &amp;&amp; a[i] &lt; big[i + 1]) res++; cout &lt;&lt; res &lt;&lt; endl; return 0;} 6、数位递增逆序数问题描述 一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。 给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？ 输入格式 输入的第一行包含一个整数 n。 输出格式 输出一行包含一个整数，表示答案。 样例输入130 样例输出126 评测用例规模与约定 对于 40% 的评测用例，1 &lt;= n &lt;= 1000。 对于 80% 的评测用例，1 &lt;= n &lt;= 100000。 对于所有评测用例，1 &lt;= n &lt;= 1000000。 题解：直接扫描一遍即可判断时可以用两个指针指向一前一后，进行判断即可！ 具体看代码实现！ 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, sum;void solve(int x){ int next = 0x3f, pre; bool flag = true; while(x) { int pre = x % 10; x /= 10; if(pre &gt; next) { flag = false; break; } next = pre; } if(flag) sum ++;}int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) solve(i); cout &lt;&lt; sum &lt;&lt; endl; return 0;} 7、元音辅音问题描述 小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。 给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。 元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。 输入格式 输入一行，包含一个单词，单词中只包含小写英文字母。 输出格式 输出答案，或者为yes，或者为no。 样例输入1lanqiao 样例输出1yes 样例输入1world 样例输出1no 评测用例规模与约定 对于所有评测用例，单词中的字母个数不超过100。 题解：扫描一遍即可！保证是辅音、元音、辅音、元音的顺序即可，并且只出现这四段，顺序也一样，多一段都不行！ 直接while去循环直到元辅音出现变化结束即可！ 使用flag可以控制他进入的顺序。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, sum;string str;int fuyin, yuanyin, flag;int main(){ cin &gt;&gt; str; for(int i = 0; i &lt; str.size();) { if(!flag)//辅音 { flag = 1; bool flag1 = false; while(str[i] != 'a' &amp;&amp; str[i] != 'e' &amp;&amp; str[i] != 'i' &amp;&amp; str[i] != 'o' &amp;&amp; str[i] != 'u') { flag1 = true; i ++; } if(!flag1) { cout &lt;&lt; \"no\" &lt;&lt; endl; return 0; } fuyin ++; } else//元音 { flag = 0; bool flag2 = false; while(str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' || str[i] == 'u') { flag2 = true; i ++; } if(!flag2) { cout &lt;&lt; \"no\" &lt;&lt; endl; return 0; } yuanyin ++; } } if(fuyin == 2 &amp;&amp; yuanyin == 2) cout &lt;&lt; \"yes\" &lt;&lt; endl; else cout &lt;&lt; \"no\" &lt;&lt; endl; return 0;} 8、长草问题描述 小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。 小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。 这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。 请告诉小明，k 个月后空地上哪些地方有草。 输入格式 输入的第一行包含两个整数 n, m。 接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。 接下来包含一个整数 k。 输出格式 输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。 样例输入12345678910114 5.g..........g.......2 样例输出1234567gggg.gggg.ggggg.ggg. 评测用例规模与约定 对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。 对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。 对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= k &lt;= 1000。 题解一：直接循环k个月先将有草的地方存起来，再去循环k个月，每次循环都将起点置为上一次的终点，可以有效减少扫描次数，每个月都去扫描上一次新增加的地方！ 貌似不会超时！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;typedef pair&lt;int, int&gt; PII;int n, m, k, r;string str[N];PII T[N * N];int dx[4] = {-1, 1, 0, 0};int dy[4] = {0, 0, -1, 1};bool in(int x, int y){ return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;}int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; str[i]; for(int j = 0; j &lt; m; j++) if(str[i][j] == 'g') T[r++] = {i, j}; } cin &gt;&gt; k; int t = 0, s; while(k--) { s = t, t = r; for(int i = s; i &lt; t; i++) { for(int j = 0; j &lt; 4; j++) { int tx = T[i].first + dx[j], ty = T[i].second + dy[j]; if(in(tx, ty) &amp;&amp; str[tx][ty] != 'g') str[tx][ty] = 'g', T[r++] = {tx, ty}; } } } for(int i = 0; i &lt; n; i++) cout &lt;&lt; str[i] &lt;&lt; endl; return 0;} 题解二：使用BFS貌似和上面解法没区别，复杂度我认为也没什么区别。。。 第二层while循环循环上一次新增加的地方，即队列的大小，内循环结束一次，上一次队列存储的值就会清空一次，然后当前队列存储的就是本月新增的地方，外循环循环月份即可！ 可能会发生某个月份长草时，已经全部长满了，则直接退出即可，即外循环增加一个非空判断条件即可！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 使用BFS#include &lt;queue&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;typedef pair&lt;int, int&gt; PII;int n, m, k, r;string str[N];int dx[4] = {-1, 1, 0, 0};int dy[4] = {0, 0, -1, 1};bool in(int x, int y){ return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;}queue&lt;PII&gt; q;int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; str[i]; for(int j = 0; j &lt; m; j++) if(str[i][j] == 'g') q.push({i, j}); } cin &gt;&gt; k; while(!q.empty() &amp;&amp; k--) { int len = q.size(); while(len--) { PII now = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) { int tx = now.first + dx[i], ty = now.second + dy[i]; if(in(tx, ty) &amp;&amp; str[tx][ty] != 'g') { str[tx][ty] = 'g'; q.push({tx, ty}); } } } } for(int i = 0; i &lt; n; i++) cout &lt;&lt; str[i] &lt;&lt; endl; return 0;} 9、序列数问题描述 小明想知道，满足以下条件的正整数序列的数量： 1. 第一项为 n； 2. 第二项不超过 n； 3. 从第三项开始，每一项小于前两项的差的绝对值。 请计算，对于给定的 n，有多少种满足条件的序列。 输入格式 输入一行包含一个整数 n。 输出格式 输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。 样例输入14 样例输出17 样例说明 以下是满足条件的序列： 4 1 4 1 1 4 1 2 4 2 4 2 1 4 3 4 4 评测用例规模与约定 对于 20% 的评测用例，1 &lt;= n &lt;= 5； 对于 50% 的评测用例，1 &lt;= n &lt;= 10； 对于 80% 的评测用例，1 &lt;= n &lt;= 100； 对于所有评测用例，1 &lt;= n &lt;= 1000。 题解：DFS(暴力TLE)直接DFS最多只能算到20几的数字，但本题数据范围为1000。。。 可以暴力跑一遍所有数组，存储起来，打表输出O(1)即可。。。 正确做法或许是记忆化搜索，动态规划之类。。。 就这样吧，打表或许是最好的选择！ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;#define mod 10000using namespace std;int n, ans;void dfs(int pre, int next){ ans = (ans + 1) % mod; if(abs(pre - next) &lt;= 1) return; for (int i = 1; i &lt; abs(pre - next); i++) dfs(next, i);}int main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) dfs(n, i); cout &lt;&lt; ans &lt;&lt; endl; return 0;} 10、选节目问题描述 小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。 这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。 小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。 小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。 输入格式 输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。 第二行包含 n 个整数，依次为每个节目的好看值。 输出格式 输出一行包含 m 个整数，为选出的节目的好看值。 样例输入1235 33 1 2 5 4 样例输出13 5 4 样例说明 选择了第1, 4, 5个节目。 评测用例规模与约定 对于 30% 的评测用例，1 &lt;= n &lt;= 20； 对于 60% 的评测用例，1 &lt;= n &lt;= 100； 对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。 题解：似乎不太对简单的觉得先按好看值从大到小排序，再按序号从小到大排序即可！ 似乎不是这么简单！ 听说用到了好多算法。。。 放过，再说吧！ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100000;struct Node{ int point, pos;};bool cmp(Node x, Node y){ return x.point &gt; y.point;}bool cmp1(Node x, Node y){ return x.pos &lt; y.pos;}int n, m;Node a[N];int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i].point, a[i].pos = i; sort(a, a + n, cmp); sort(a, a + m, cmp1); for(int i = 0; i &lt; m; i++) cout &lt;&lt; a[i].point &lt;&lt; \" \"; return 0;} 记录一下这垃圾的蓝桥杯校赛！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://www.itnxd.cn/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://www.itnxd.cn/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"author":"Mr.Niu"},{"title":"AcWing-112.雷达设备","slug":"AcWing-112-雷达设备","date":"2020-03-12T12:59:56.000Z","updated":"2021-02-06T14:10:17.446Z","comments":true,"path":"posts/27200.html","link":"","permalink":"https://www.itnxd.cn/posts/27200.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：112. 雷达设备 题目背景： 同样是贪心问题！ 题目描述假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。 每个小岛都位于海洋一侧的某个点上。 雷达装置均位于海岸线上，且雷达的监测范围为d，当小岛与某雷达的距离不超过d时，该小岛可以被雷达覆盖。 我们使用笛卡尔坐标系，定义海岸线为x轴，海的一侧在x轴上方，陆地一侧在x轴下方。 现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。 输入格式第一行输入两个整数n和d，分别代表小岛数目和雷达检测范围。 接下来n行，每行输入两个整数，分别代表小岛的x，y轴坐标。 同一行数据之间用空格隔开。 输出格式输出一个整数，代表所需的最小雷达数目，若没有解决方案则所需数目输出“-1”。 数据范围1≤n≤1000 输入样例：12343 21 2-3 12 1 输出样例：12 题目分析：题目要求：简单来说，就是给一条数轴，在数轴上方有一些点（小岛），要在数轴上放置雷达，使得可以使每个点都被覆盖住！ 求达到目的的最小雷达数目！ 解题思路：雷达有一个半径值，当然处于半径内则可以覆盖！ 首先先考虑一个点（x，y）,要想使得数轴上的雷达可以探测到，必须处于半径范围内，左右可以拓展的距离最大就是以点（x，y）往出拉一条雷达的半径d，与数轴的交点就是可以拓展的最大距离，即只要在[a，b] 范围内就可以保证当前点处于雷达可探测范围！ 如下图： 若发现无交点，即当前点太高，即使雷达放在正下方都够不着，超过了雷达的范围，则直接返回-1即可！ 判断条件：y &gt; d 时！够不着！ 计算区间a，b值可以利用勾股定理即可！ 这样我们可以得到每一个点的雷达取值区间，现在问题就从二维变为了一维的区间问题！ 具体解法： 我们可以给每个区间按照右端点从小到大排序！ 扫描每一个区间，看这个区间内是否有雷达？ 若没有雷达，则在当前区间右端点放置一颗雷达 若有雷达，则跳过即可 具体解释一下： 排好序后，如果前面有一个雷达则去看一下雷达有没有在当前点的区间，要知道：只有在当前点的区间内才能够得着这个点！ 为了尽可能的使放一个雷达可以最好，最大的服务后面的的点的区间，可以将每个雷达放到该点区间的右端点即可！ 既可以保证当前点被覆盖，又可以保证距离下一个点最近，达到最优的效果！ 最后的最少的雷达数就是区间上可以放置的雷达数，即进去if条件的次数！ 证明可以看一下下方yxc大神的证明！ yxc视频讲解，点击这里！ 题解：下一个区间要想判断是否在雷达的左或右边，可以简单的用一个last指针来动态指向雷达的位置，若区间没有雷达，则将last置为当前区间的右端点，否则跳过即可！ 注意：因为勾股定理需要开方，所以区间使用double来存储！ 数轴是正无穷到负无穷级别的，所以将last初值赋为负无穷大！ 具体参考代码理解！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;const double INF = 1e10;struct Node{ double l, r;};bool cmp(Node a, Node b){ return a.r &lt; b.r;}int n, d;Node a[N];int main(){ cin &gt;&gt; n &gt;&gt; d; for(int i = 0, x, y; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; if(y &gt; d) { cout &lt;&lt; -1 &lt;&lt; endl; return 0; } double l = x - sqrt(d * d - y * y), r = x + sqrt(d * d - y * y); a[i] = {l, r}; } sort(a, a + n, cmp); int res = 0; double last = -INF; for(int i = 0; i &lt; n; i++) { if(a[i].l &gt; last) { res ++; last = a[i].r; } } cout &lt;&lt; res &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"AcWing-111.畜栏预定","slug":"AcWing-111-畜栏预定","date":"2020-03-10T13:22:43.000Z","updated":"2021-02-06T14:05:09.276Z","comments":true,"path":"posts/23513.html","link":"","permalink":"https://www.itnxd.cn/posts/23513.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：111. 畜栏预定 题目背景： 贪心证明略过。。。 本题我在出列排序后的第一头牛时出现了问题，粗心了。。。 题目描述有N头牛在畜栏中吃草。 每个畜栏在同一时间段只能提供给一头牛吃草，所以可能会需要多个畜栏。 给定N头牛和每头牛开始吃草的时间A以及结束吃草的时间B，每头牛在[A,B]这一时间段内都会一直吃草。 当两头牛的吃草区间存在交集时（包括端点），这两头牛不能被安排在同一个畜栏吃草。 求需要的最小畜栏数目和每头牛对应的畜栏方案。 输入格式第1行：输入一个整数N。 第2..N+1行：第i+1行输入第i头牛的开始吃草时间A以及结束吃草时间B，数之间用空格隔开。 输出格式第1行：输入一个整数，代表所需最小畜栏数。 第2..N+1行：第i+1行输入第i头牛被安排到的畜栏编号，编号是从1开始的 连续 整数，只要方案合法即可。 数据范围1≤N≤500001≤A,B≤1000000 输入样例：12345651 102 43 65 84 7 输出样例：123456412324 题目分析：题目要求：给出n头牛吃草的时间区间，问最少可以划分几个容器，使得每个容器牛吃草时间不会冲突，端点相同也算冲突！ 解题思路： 根据时间区间的起点排序 用小根堆维护当前容器最后一头牛吃草的结束时间 若当前牛的起始值比堆顶结束的值都大，则更新堆顶，否则，新建一个节点，存入堆！ 至于为什么这样做是对的，那就是数学问题了，我就不细说了，证明请看下方的视频讲解！ 先默认排好序后的第一头牛为第一个容器，后面的牛则从2开始循环！ 具体看题解下方的解释！ yxc大神参考题解：点击这里！ yxc视频讲解 题解：题解一：暴力超时TLE代码结构体的三个变量：时间区间的开始结束和标号！ S数组存储两个值，当前容器的右端点和容器的编号，第一个变量不需要，随便写个0！ 内部for循环来找有没有可以放到同一个容器的区间，若能放到一起，则更新容器的右端点！并记录牛的容器编号！ 若没有找到可以放到一起的，则新建容器，编号++，右端点为当前牛的右端点，记录牛的编号！ 时间复杂度：O(n2) TLE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Node{ int start, end, pos;};bool cmp(Node x, Node y){ return x.start &lt; y.start;}const int N = 50010;int n, id[N];Node T[N], S[N];int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; T[i].start &gt;&gt; T[i].end, T[i].pos = i; sort(T + 1, T + 1 + n, cmp); S[1] = {0, T[1].end, 1}; int k = 1, r = 1; id[T[1].pos] = 1; for(int i = 2; i &lt;= n; i++) { bool flag = false; for(int j = 1; j &lt;= k; j++) { if(T[i].start &gt; S[j].end) { S[j].end = T[i].end; id[T[i].pos] = S[j].pos; flag = true; break; } } if(!flag) { S[++k] = {0, T[i].end, ++r}; id[T[i].pos] = r; } } cout &lt;&lt; k &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; id[i] &lt;&lt; endl; return 0;} 题解二：使用堆优化的AC代码想要从已知的容器中找一个比当前牛起始端点还小的容器，则可以简化为找一个最小的即可！ 然后比较容器右端点最小的容器和当前牛的左端点比较即可！ 则变成了动态变化的容器求最小值，这不就是堆的性质吗！ 可以建立一个优先队列，即小根堆！ 每次取堆顶即可，取出来再和当前牛比较！ 同样：排好序的第一头牛初始编号为1，先放入堆，for循环从2开始！ 堆中存储两个值，第一个为右端点（动态）第二个值为容器编号！ 比堆顶还小则新建一个节点，节点编号++，压入堆中！ 否则：取出堆顶，更新右端点，压入堆中！ 最后容器个数就是堆的大小！ 时间复杂度：O(NlogN) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;struct Node{ int start, end, pos;};bool cmp(Node x, Node y){ return x.start &lt; y.start;}const int N = 50010;int n, id[N];Node T[N], S[N];priority_queue &lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; T[i].start &gt;&gt; T[i].end, T[i].pos = i; sort(T + 1, T + 1 + n, cmp); // first -&gt; end , second -&gt; pos heap.push({T[1].end, 1}); id[T[1].pos] = 1; for(int i = 2; i &lt;= n; i++) { if(T[i].start &lt;= heap.top().first) { int s = heap.size() + 1; PII t = {T[i].end, s}; id[T[i].pos] = s; heap.push(t); } else { auto t = heap.top(); heap.pop(); t.first = T[i].end; id[T[i].pos] = t.second; heap.push(t); } } cout &lt;&lt; heap.size() &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; id[i] &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"堆","slug":"堆","permalink":"https://www.itnxd.cn/tags/%E5%A0%86/"}],"author":"Mr.Niu"},{"title":"AcWing-110.防晒","slug":"AcWing-110-防晒","date":"2020-03-07T11:36:56.000Z","updated":"2021-02-06T14:11:24.220Z","comments":true,"path":"posts/10715.html","link":"","permalink":"https://www.itnxd.cn/posts/10715.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：110. 防晒 题目背景： 贪心的证明就略过了，运用了大量数学知识，二分图。。。。 题目描述有C头奶牛进行日光浴，第i头奶牛需要minSPF[i]到maxSPF[i]单位强度之间的阳光。 每头奶牛在日光浴前必须涂防晒霜，防晒霜有L种，涂上第i种之后，身体接收到的阳光强度就会稳定为SPF[i]，第i种防晒霜有cover[i]瓶。 求最多可以满足多少头奶牛进行日光浴。 输入格式第一行输入整数C和L。 接下来的C行，按次序每行输入一头牛的minSPF和maxSPF值,即第i行输入minSPF[i]和maxSPF[i]。 再接下来的L行，按次序每行输入一种防晒霜的SPF和cover值,即第i行输入SPF[i]和cover[i]。 每行的数据之间用空格隔开。 输出格式输出一个整数，代表最多可以满足奶牛日光浴的奶牛数目。 数据范围1≤C,L≤25001≤minSPF≤maxSPF≤10001≤SPF≤1000 输入样例：1234563 23 102 51 56 24 1 输出样例：12 题目分析：题目要求：有一些奶牛，一些防晒霜，最大可能的使更多的牛涂了防晒霜后处于需求范围内！ 解题思路：将牛的区间按照左端点从大到小排序，如下图； 从上向下处理每一头牛，扫描当前区间的最大强度的防晒霜即可！ 简单解释： 第一头牛从右端点开始找起，找到的一定是在牛的区间范围内最少的，而左边的则可以满足多头牛！ 最终答案就是区间上使用了防晒霜的个数！ 用完一个就将防晒霜个数–，减到0从容器中删除！ 为了方便，使用map来存储防晒霜，由于防晒霜类型有重复，sp[spf] += cover;这里变为+=即可！ 找满足牛区间的最大值，可以使用upper_bound(x)函数 lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 找到大于右端点值时，直接–就找到了一个可能存在的防晒霜！ 若当前防晒霜在区间内，则当前牛可以满足条件，计数器++； 可参考下面题解： yxc大神参考题解：点击这里！ yxc视频讲解 题解：在这里map确实好用！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2510;struct Cow{ int first, second;};bool cmp(Cow x, Cow y){ if(x.first != y.first) return x.first &gt; y.first;}int n, m;Cow cows[N];map &lt;int, int&gt; sp;int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; cows[i].first &gt;&gt; cows[i].second; for(int i = 0; i &lt; m; i++) { int spf, cover; cin &gt;&gt; spf &gt;&gt; cover; sp[spf] += cover; } sort(cows, cows + n, cmp); int res = 0; sp[0] = sp[1001] = n; for(int i = 0; i &lt; n; i++) { // it是一个迭代器！ auto it = sp.upper_bound(cows[i].second); it --; if(it-&gt;first &gt;= cows[i].first) { res ++; it-&gt;second --; if(it-&gt;second == 0) sp.erase(it); } } cout &lt;&lt; res &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"AcWing-109.天才ACM","slug":"AcWing-109-天才ACM","date":"2020-03-07T08:44:34.000Z","updated":"2021-02-06T14:02:10.361Z","comments":true,"path":"posts/45606.html","link":"","permalink":"https://www.itnxd.cn/posts/45606.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：109. 天才ACM 题目背景： 又是一道好题，参考了许多题解，明白后，有因为粗心，debug了好久才AC了！ 题目描述给定一个整数 M，对于任意一个整数集合 S，定义“校验值”如下: 从集合 S 中取出 M 对数(即 2∗M 个数，不能重复使用集合中的数，如果 S 中的整数不够 M 对，则取到不能取为止)，使得“每对数的差的平方”之和最大，这个最大值就称为集合 S 的“校验值”。 现在给定一个长度为 N 的数列 A 以及一个整数 T。 我们要把 A 分成若干段，使得每一段的“校验值”都不超过 T。 求最少需要分成几段。 输入格式第一行输入整数 K，代表有 K 组测试数据。 对于每组测试数据，第一行包含三个整数 N,M,T 。 第二行包含 N 个整数，表示数列A1,A2…AN。 输出格式对于每组测试数据，输出其答案，每个答案占一行。 数据范围1≤K≤121≤N,M≤5000000≤T≤10180≤Ai≤220 输入样例：1234525 1 498 2 1 7 95 1 648 2 1 7 9 输出样例：1221 题目分析：题目要求：校验值：就是每对数的差的平方之和 将一个序列分成若干段，使得每一段的校验值都不超过T，求可分成的最小段数！ 每一段要取出M对数，即2 * M 个数，取到不能取为止！ 解题思路：贪心 + 归并(只用到合并) + 倍增 首先一段的校验值最大，很简单，直接排序后，取一个最大值和一个最小值，每次都去最大最小即可，这样贪心得到的校验值就是这一段的最大值！（当然不能重复取！） 如何可以使得段数尽可能的小了？ 那么一段要取多长？ 我们可以进行二分，每次都将二分得到的区间计算的到的校验值和T比较即可，然后动态的改变右端点！ 但是这样得到的区间要想计算校验值，得进行该序列的排序，用到sort，复杂度石灰超时的！ 这是可以用倍增来解决这个问题！ 要想使段数尽可能少，则要保证每一段在不超过T的情况下，尽可能的长！ 用 l 和 r 指向区间的左右端点，若区间不超过T，就进行倍增拓展长度（p），p 成倍增加，r 也要一直后移；若某次成倍增加是校验值超过T，则当前p就得成倍减少，直到p为0，此时就是说明找到了不超过T的最大长度！ 第一段开始，已排序序列b数组需要和那段倍增的长度进行拓展，需要进行排序，但是 b 数组已经有序，根本不需要去整段去排序，将倍增长度排序后，直接使用归并进行两个序列的合并，得到一个新数组即可！ 其后的每一段合并时，b数组都是排好序的，这样可以大大减少时间消耗！ b数组用来保存处理过的序列，c数组来保存每次倍增多出来的序列，temp数组来保存b和c合并后的序列！ 若当前序列不超过T，则将合并后的序列temp归还给b数组（表示处理过且当前是有序序列），返回true，右端点右移到倍增后的位置，p继续倍增！ 若当前序列超过了T，则直接返回false，此时b数组的存储没有被改变，然后p倍减！ 为什么会比二分更优化呢？ 因为每次的b数组都是有序的，不需要排序，省了很多时间！ 可以参考代码中的注释进行详细了解！ 也可以参考如下的一篇题解！ 参考题解：点击这里！ 题解：注意： 校验值可能会溢出，要使用long long！ 以防倍增后使右端点溢出，使用t = min(r + p, n - 1) 来进行约束！ 每一段找到右端点后，当前段在b数组就是有序的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 5e5 + 10;int K, n, m;LL a[N], b[N], c[N], temp[N], T;// 合并 l1~r1 和 l2~r2int merge(int l1, int r1, int l2, int r2){ int i = l1, j = l2, k = 0; while(i &lt;= r1 &amp;&amp; j &lt;= r2) { if(b[i] &lt;= c[j]) temp[k++] = b[i++]; else temp[k++] = c[j++]; } while(i &lt;= r1) temp[k++] = b[i++]; while(j &lt;= r2) temp[k++] = c[j++]; return k;}// 当前l ~ r1 是有序的 bool check(int l, int r1, int r2){ // 将 r1 + 1 ~ r2(倍增序列)存储起来 for(int i = r1 + 1; i &lt;= r2; i++) c[i] = a[i]; // 排序倍增序列 sort(c + r1 + 1, c + r2 + 1); // 合并倍增序列与已排好序的序列 int len = merge(l, r1, r1 + 1, r2); // 合并后的有序序列 计算校验值 LL cnt = 0, head = 0, tail = len - 1, sum = 0; while(cnt &lt; m &amp;&amp; head &lt; tail) { sum += (temp[head] - temp[tail]) * (temp[head] - temp[tail]); head ++, tail --, cnt ++; } if(sum &gt; T) return false; else { // 小于T 将临时temp存回到b数组，此时b数组是一个有序序列 int k = 0; for(int i = l; i &lt;= r2; i++) b[i] = temp[k++]; return true; }}int main(){ cin &gt;&gt; K; while(K--) { cin &gt;&gt; n &gt;&gt; m &gt;&gt; T; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; int l = 0, r = 0, p, nes = 0, t; // 若 r 到了最后就退出 while(r &lt; n - 1) { // b 在这里每次存储一段序列的头部！r 初始指向 l, p初始倍增为1 nes统计序列段数 b[l] = a[l], r = l, p = 1, nes++; // p 为0时，即找到了序列的最大长度 while(p) { // 倍增后的右端点 t = min(r + p, n - 1); // 若此时的合并后的序列的校验值 &lt;= T 则p倍增 合并完成的右端点r后移 否则：p倍减 if(check(l, r, t)) r = t, p &lt;&lt;= 1; else p &gt;&gt;= 1; // 保证r 不超过 n - 1 说明走到了序列末 是切割的最后一段 if(r == n - 1) break; } // 下一段开始的位置 l = r + 1; } cout &lt;&lt; nes &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"归并排序","slug":"归并排序","permalink":"https://www.itnxd.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"倍增","slug":"倍增","permalink":"https://www.itnxd.cn/tags/%E5%80%8D%E5%A2%9E/"}],"author":"Mr.Niu"},{"title":"AcWing-108.奇数码问题","slug":"AcWing-108-奇数码问题","date":"2020-03-06T08:12:44.000Z","updated":"2021-02-06T13:58:45.105Z","comments":true,"path":"posts/12934.html","link":"","permalink":"https://www.itnxd.cn/posts/12934.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：108.奇数码问题 题目背景： 同样是归并排序求逆序对的问题！ 参考我关于这类问题的一篇题解：AcWing-788.逆序对的数量 奇偶性很神奇，对于一类问题，如果属于同种性质（奇偶性相同），那么它们就是完全相同（这个在某种意义上说）的，一些特殊的情况又例外！ 题目描述你一定玩过八数码游戏，它实际上是在一个3×3的网格中进行的,1个空格和1~8这8个数字恰好不重不漏地分布在这3×3的网格中。 例如： 1235 2 81 3 _4 6 7 在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。 例如在上例中，空格可与左、上、下面的数字交换，分别变成： 1235 2 8 5 2 _ 5 2 81 _ 3 1 3 8 1 3 74 6 7 4 6 7 4 6 _ 奇数码游戏是它的一个扩展，在一个n×n的网格中进行，其中n为奇数，1个空格和1~n2−1这n2−1个数恰好不重不漏地分布在n×n的网格中。 空格移动的规则与八数码游戏相同，实际上，八数码就是一个n=3的奇数码游戏。 现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。 输入格式多组数据，对于每组数据： 第1行输入一个整数n，n为奇数。 接下来n行每行n个整数，表示第一个局面。 再接下来n行每行n个整数，表示第二个局面。 局面中每个整数都是0~n2−1之一，其中用0代表空格，其余数值与奇数码游戏中的意义相同，保证这些整数的分布不重不漏。 输出格式对于每组数据，若两个局面可达，输出TAK，否则输出NIE。 数据范围1≤n&lt;500 输入样例：1234567891031 2 30 4 67 5 81 2 34 5 67 8 0100 输出样例：12TAKTAK 题目分析：题目要求：询问是不是可以将一个矩阵中的空位 _ 通过上下左右交换变成另一个矩阵！ 解题思路：先来一个结论： 奇数码游戏两个局面可达，当且仅当两个局面下网格中的数依次写成1行n*n-1个元素的序列后(不考虑空格)，逆序对个数的奇偶性相同！ 空格左右移动时，写成的序列显然不变; 空格向上(下)移动时，相当于某个数与它后(前)边的n-1个数交换了位置，因为n-1是偶数，所以逆序对数的变化也只能是偶数。 该结论的充分性证明较为复杂，我们将不在此大篇幅讨论这样一个 数学问题。 可以参考下面这位同学的简单证明！ 我之前的题解：归并求逆序对！点击这里！ 参考题解：点击这里！ 题解：同样：使用long long，以防溢出！ 判断同奇同偶性，可以直接相减的绝对值对2取余即可，若为0，则是同类，若不为0则是一奇一偶！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 510;int a[N * N], temp[N * N], n, k;LL sum, suma, sumb;void merge_sort(int l, int r){ if(l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(l, mid), merge_sort(mid + 1, r); int i = l, j = mid + 1, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else { temp[k++] = a[j++]; sum += mid - i + 1; } } while(i &lt;= mid) temp[k++] = a[i++]; while(j &lt;= r) temp[k++] = a[j++]; for(int i = l, j= 0; i &lt;= r; i++, j++) a[i] = temp[j];}int main(){ while(cin &gt;&gt; n) { sum = 0, k = 0; for(int i = 0, x; i &lt; n * n; i++) { cin &gt;&gt; x; if(x) a[k++] = x; } merge_sort(0, n * n - 1); suma = sum; sum = 0, k = 0; for(int i = 0, x; i &lt; n * n; i++) { cin &gt;&gt; x; if(x) a[k++] = x; } merge_sort(0, n * n - 1); sumb = sum; if(abs(suma - sumb) % 2) cout &lt;&lt; \"NIE\" &lt;&lt; endl; else cout &lt;&lt; \"TAK\" &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"归并排序","slug":"归并排序","permalink":"https://www.itnxd.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"逆序对","slug":"逆序对","permalink":"https://www.itnxd.cn/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"奇偶性","slug":"奇偶性","permalink":"https://www.itnxd.cn/tags/%E5%A5%87%E5%81%B6%E6%80%A7/"}],"author":"Mr.Niu"},{"title":"AcWing-107.超快速排序","slug":"AcWing-107-超快速排序","date":"2020-03-06T03:58:14.000Z","updated":"2020-05-19T02:24:12.351Z","comments":true,"path":"posts/8382.html","link":"","permalink":"https://www.itnxd.cn/posts/8382.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：107. 超快速排序 题目背景： 又是归并排序求逆序对的问题！ 参考我关于这类问题的一篇题解：AcWing-788.逆序对的数量 题目描述在这个问题中，您必须分析特定的排序算法—-超快速排序。 该算法通过交换两个相邻的序列元素来处理n个不同整数的序列，直到序列按升序排序。 对于输入序列9 1 0 5 4，超快速排序生成输出0 1 4 5 9。 您的任务是确定超快速排序需要执行多少交换操作才能对给定的输入序列进行排序。 输入格式输入包括一些测试用例。 每个测试用例的第一行输入整数n，代表该用例中输入序列的长度。 接下来n行每行输入一个整数ai,代表用例中输入序列的具体数据，第i行的数据代表序列中第i个数。 当输入用例中包含的输入序列长度为0时，输入终止，该序列无需处理。 输出格式对于每个需要处理的输入序列，输出一个整数op，代表对给定输入序列进行排序所需的最小交换操作数，每个整数占一行。 数据范围0≤N&lt;5000000≤ai≤999999999 输入样例：123456789101159105431230 输出样例：1260 题目分析：题目要求：就是求逆序对的数目，遇到0结束输入！ 解题思路：同样是归并排序再求逆序对的数目： sum += mid - i + 1; 详细题解看类似的题目下面这篇我之前写的题解！ AcWing-788.逆序对的数量 题解：注意：以防越界，全部改为long long！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 500010;LL a[N], temp[N];LL n, sum;void merge_sort(int l, int r){ if(l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(l, mid), merge_sort(mid + 1, r); int i = l, j = mid + 1, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else { temp[k++] = a[j++]; sum += mid - i + 1; } } while(i &lt;= mid) temp[k++] = a[i++]; while(j &lt;= r) temp[k++] = a[j++]; for(int i = l, j= 0; i &lt;= r; i++, j++) a[i] = temp[j];}int main(){ while(cin &gt;&gt; n &amp;&amp; n) { sum = 0; for(int i = 0, x; i &lt; n; i++) cin &gt;&gt; a[i]; merge_sort(0, n - 1); cout &lt;&lt; sum &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"归并排序","slug":"归并排序","permalink":"https://www.itnxd.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"逆序对","slug":"逆序对","permalink":"https://www.itnxd.cn/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"}],"author":"Mr.Niu"},{"title":"AcWing-106.动态中位数","slug":"AcWing-106-动态中位数","date":"2020-03-05T10:38:26.000Z","updated":"2021-02-15T05:21:21.415Z","comments":true,"path":"posts/3455.html","link":"","permalink":"https://www.itnxd.cn/posts/3455.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：106. 动态中位数 题目背景： 让两个堆来构建一个有序序列，找到中位数，优先队列的优先就是用堆结构实现的！ 题目描述依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数。 输入格式第一行输入一个整数P，代表后面数据集的个数，接下来若干行输入各个数据集。 每个数据集的第一行首先输入一个代表数据集的编号的整数。 然后输入一个整数M，代表数据集中包含数据的个数，M一定为奇数，数据之间用空格隔开。 数据集的剩余行由数据集的数据构成，每行包含10个数据，最后一行数据量可能少于10个，数据之间用空格隔开。 输出格式对于每个数据集，第一行输出两个整数，分别代表数据集的编号以及输出中位数的个数（应为数据个数加一的二分之一），数据之间用空格隔开。 数据集的剩余行由输出的中位数构成，每行包含10个数据，最后一行数据量可能少于10个，数据之间用空格隔开。 输出中不应该存在空行。 数据范围1≤P≤10001≤M≤9999 输入样例：1234567893 1 9 1 2 3 4 5 6 7 8 9 2 9 9 8 7 6 5 4 3 2 1 3 23 23 41 13 22 -3 24 -31 -11 -8 -7 3 5 103 211 -311 -45 -67 -73 -81 -99 -33 24 56 输出样例：12345671 51 2 3 4 52 59 8 7 6 53 1223 23 22 22 13 3 5 5 3 -3 -7 -3 题目分析：题目要求：输入一串数，在输入奇数位时，输出当前序列的中位数！ 解题思路：本人的暴力做法： 每次输入一个数，就使用sort来拍一下序，为奇数位时，输出当前的中位数！ 看看时间复杂度：1e3 * 1e4 * NlogN 大概已经1e11 绝对TLE！ 更优的做法：使用对顶堆 时间复杂度：1e3 * 1e4 * logN 似乎是这样！不太会分析复杂度。。。 使用两个堆结构：大根堆和小根堆，且必须时刻满足这两个条件！ 大根堆：序列中从小到大排序为 1 ~ M / 2 个数存储到大根堆 小根堆：序列中从小到大排序为 M + 1~ M 个数存储到大根堆 始终保证大根堆元素小于小于等于小根堆，小根堆元素大于等于大根堆元素个数！ 输入一个数先进行存储，若比中位数小，存储到大根堆，比中位数大存储到小根堆！ 倘若不符合上面两个条件： 需要进行多的给少的，达到上面的限制条件即可！ 为什么要这样限制了？ 看一下这张图： 会发现每次插入结束后，只要保证右边大于等于左边，就可以轻而易举得到中位数，就是小根堆的堆顶！ 如果是偶数个数，则左右是相等个数，若为奇数，则右边一定会多一个！ 以这几个数举例：没有9时，则中位数为5？不对吧，没关系，题目要求在奇数个数时去找中位数，所以右边一定比左边多1，这时，也就是有9的时候，中位数就是5，没毛病！ 大根堆的堆顶为4，小根堆的堆顶为5 ! 具体实现请看下方代码！ 李煜东的视频讲解，大概在45分钟的时候！ 题解：题解一：本人的纯暴力做法！（TLE）123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int a[N], b[N];int p, q, n;int main(){ cin &gt;&gt; p; while(p --) { cin &gt;&gt; q &gt;&gt; n; int k = 0; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; sort(a + 1, a + 1 + i); if(i &amp; 1) b[k++] = a[i + 1 &gt;&gt; 1]; } cout &lt;&lt; q &lt;&lt; \" \" &lt;&lt; k &lt;&lt; endl; for(int i = 0; i &lt; k; i++) { if(i % 10 == 0 &amp;&amp; i) cout &lt;&lt; endl; cout &lt;&lt; b[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } return 0;} 题解二：使用对顶堆（大根堆和小根堆）（AC）注意：将第一个数直接插入小根堆，毕竟要保证右边大于等于左边！ 在清空堆的时候，由于没有clear函数，只能使用循环去删除达到空容器效果，或者直接赋值一个空容器，建议使用赋值方法！简单明了，vector可以直接使用clear函数清空！ 关于优先队列： 默认为大根堆，要使用小根堆得如代码这样写，很明显第三个参数为排序函数！ 12priority_queue &lt;int&gt; big, kong1; // 大根堆priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; small, kong2; // 小根堆 具体代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int p, q, n;vector &lt;int&gt; v, kongV;priority_queue &lt;int&gt; big, kong1; // 大根堆priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; small, kong2; // 小根堆int main(){ cin &gt;&gt; p; while(p --) { cin &gt;&gt; q &gt;&gt; n; int k = 0; big = kong1, small = kong2, v.clear(); for(int i = 1, x; i &lt;= n; i++) { cin &gt;&gt; x; if(small.empty()) { small.push(x); v.push_back(x); continue; } if(x &gt;= small.top()) small.push(x); else big.push(x); if(big.size() &gt; small.size()) { small.push(big.top()); big.pop(); } else if(small.size() - big.size() &gt; 1) { big.push(small.top()); small.pop(); } if(i &amp; 1) v.push_back(small.top()); } cout &lt;&lt; q &lt;&lt; \" \" &lt;&lt; v.size() &lt;&lt; endl; for(int i = 0; i &lt; v.size(); i++) { if(i % 10 == 0 &amp;&amp; i) cout &lt;&lt; endl; cout &lt;&lt; v[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"中位数","slug":"中位数","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"name":"priority_queue","slug":"priority-queue","permalink":"https://www.itnxd.cn/tags/priority-queue/"},{"name":"堆","slug":"堆","permalink":"https://www.itnxd.cn/tags/%E5%A0%86/"}],"author":"Mr.Niu"},{"title":"AcWing-122.糖果传递","slug":"AcWing-122-糖果传递","date":"2020-03-05T10:37:38.000Z","updated":"2020-05-19T02:33:51.181Z","comments":true,"path":"posts/58067.html","link":"","permalink":"https://www.itnxd.cn/posts/58067.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：122. 糖果传递 题目背景： 又是一道环形的均分纸牌问题，这也是这类题的一个基础的经典的例题了！ 我先做的 七夕祭 这道题，一个二维的环形均分纸牌问题，比这个复杂一点。。 题目描述有n个小朋友坐成一圈，每人有a[i]个糖果。 每人只能给左右两人传递糖果。 每人每次传递一个糖果代价为1。 求使所有人获得均等糖果的最小代价。 输入格式第一行输入一个正整数n，表示小朋友的个数。 接下来n行，每行一个整数a[i]，表示第i个小朋友初始得到的糖果的颗数。 输出格式输出一个整数，表示最小代价。 数据范围1≤n≤1000000数据保证一定有解。 输入样例：1234541254 输出样例：14 题目分析：题目要求：n个人围成一圈，没人有一些糖果，问最少交换多少次会达到均等时的最小步数！ 传递一个糖果代价为1！ 解题思路：同样是环形均分纸牌问题，里面的公式推导就不再推了，请看我的上一篇题解： AcWing-105.七夕祭 接下来总结一下环形纸牌问题： 第一步：将原值减去平均值 第二步：求当前的前缀和 第三步：将前缀和排序 此时转化为了货仓问题 第四部：求中位数 第五步：求 abs(b[i] - mid) 的和 题解：小技巧：求前缀和时，输入从下标为1开始，方便后序求前缀和等等！ 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1e6 + 10;LL a[N], b[N];int main(){ int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], a[0] += a[i]; for(int i = 1; i &lt;= n; i++) b[i] = b[i - 1] + a[i] - a[0]/n; sort(b + 1, b + 1 + n); LL sum = 0, mid = b[n + 1 &gt;&gt; 1]; for(int i = 1; i &lt;= n; i++) sum += abs(b[i] - mid); cout &lt;&lt; sum &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"前缀和","slug":"前缀和","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"中位数","slug":"中位数","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"AcWing-105.七夕祭","slug":"AcWing-105-七夕祭","date":"2020-03-04T10:51:43.000Z","updated":"2021-02-06T13:59:26.982Z","comments":true,"path":"posts/47007.html","link":"","permalink":"https://www.itnxd.cn/posts/47007.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：105. 七夕祭 此题为了理解折腾了一下午，写题解又写了一晚上！终于完整的记录了下来 题目背景： 本题运用了大量的数学公式化简，以及中位数性质等等，我会在题目分析当中进行详细介绍和解释！ 题目描述七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。 于是TYVJ今年举办了一次线下七夕祭。 Vani同学今年成功邀请到了cl同学陪他来共度七夕，于是他们决定去TYVJ七夕祭游玩。 TYVJ七夕祭和11区的夏祭的形式很像。 矩形的祭典会场由N排M列共计N×M个摊点组成。 虽然摊点种类繁多，不过cl只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。 Vani预先联系了七夕祭的负责人zhq，希望能够通过恰当地布置会场，使得各行中cl感兴趣的摊点数一样多，并且各列中cl感兴趣的摊点数也一样多。 不过zhq告诉Vani，摊点已经随意布置完毕了，如果想满足cl的要求，唯一的调整方式就是交换两个相邻的摊点。 两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。 由于zhq率领的TYVJ开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。 现在Vani想知道他的两个要求最多能满足多少个。 在此前提下，至少需要交换多少次摊点。 输入格式第一行包含三个整数N和M和T，T表示cl对多少个摊点感兴趣。 接下来T行，每行两个整数x, y，表示cl对处在第x行第y列的摊点感兴趣。 输出格式首先输出一个字符串。 如果能满足Vani的全部两个要求，输出both； 如果通过调整只能使得各行中cl感兴趣的摊点数一样多，输出row； 如果只能使各列中cl感兴趣的摊点数一样多，输出column； 如果均不能满足，输出impossible。 如果输出的字符串不是impossible， 接下来输出最小交换次数，与字符串之间用一个空格隔开。 数据范围1≤N,M≤1000000≤T≤min(N∗M,100000)1≤x≤N1≤y≤M 输入样例：123452 3 41 32 12 22 3 输出样例：1row 1 题目分析：题目要求：就是 n 行 m 列的构成的 n * m 个交叉点，输入 t 个点的坐标，询问是否能使得每行的点数相同，每列的点数相同，若能相同，输出最小交换步数！ 交换方法：上下左右交换，还有一个特殊的交换：每一行或每一列的第一个可以和每一行或每一列的最后一个交换，即可以看成环形的状态！ 解题思路：首先：想一个问题：什么情况才能让行或列所占点数相同？ 很明显，行或列点数和只有是行或列的倍数时才可以。这样才可以平分，对吧！ 答案前半部分很好判断，后半部分最小步数不太好判断！ 接着：在想一个问题，在做行与行间点的交换时，即上下交换，会发现，上下交换是不会影响列的数目变化，毕竟上下交换，一定在那一列，那一列总和不会变！ 同理：在做列与列的点的交换时，即左右交换，会发现，左右交换是不会影响行的数目变化，毕竟左右交换，一定在那一行，那一行总和不会变！ 所以本题可以分为两个部分，一个行，一个列，分别取处理！毕竟不会互相影响！ 这个题和均分纸牌问题类似： 读者可能已经想到了一个与此类似的经典问题“均分纸牌”。“均分.纸牌”问题是说，有M个人排成一行，他们手中分别有C[1]~C[M]张纸牌，在每一步操作中，可以让某个人把自己手中的一张纸牌交给他旁边的一个人，求至少需要多少步操作才能让每个人手中持有的纸牌数相等。 显然，“ 均分纸牌”问题当所有人手中持有的纸牌总数T能被M整除时有解。 我们这样想：假如可以均分，即最后牌数一样多时： 第一个人为了达到目标平均值 T/M ,要将多出来的 C[1] - T/M 给了第二个人，第二个人此时有 C[2] + C[1] - T/M张牌。 假如第一个人不够 T/M 张牌需要去第二个人处借 T/M - C[1]张牌，此时第二个人有C[2] + T/M - C[1]张牌。 终上：第一个人要想达到T/M张牌，必须去和下一个人借或给！结束之后第一个人变成了T/M张牌，发生的交换次数为|C[1] - T/M|次 第二个人当前的牌数为： C[2] + (C[1] - T/M) 为了达到T/M张牌，必须去和下一个人借或给！则要做 |C[2] + (C[1] - T/M) - T/M|次交换！ 化简一下可以得到：第i个人需要交换次数为 |C[i] + C[i - 1] +…C[1] - i * T/M| 次交换！ 最终交换次数就是将其求和即可！ 会发现每一项都有一个前缀和：令G[i] 为C[i] 的前缀和，即最终次数变成了： |G[i] - i* T/M| ：i 从 1到M求和即可！ 注意：不用考虑某个人变为负数啥的，因为最终他都会去想后面的人来补齐！这就是拆东墙补西墙，但是不一样的是，这个最终会都补好！ 继续：将每个人的初始牌数都减去T/M，得到相对于平均值的一些正负数，要想使得最终相等，那么每个人都得相对于平均值为0，即都是平均值才可以！ 假设：令 A[i] = C[i] - T/M 此时第一个人需要交换次数为|A[1]| 第二个人为|A[2] + A[1]| 第i个人为|A[i] + A[i - 1] … + A[1]| 令S[i] 为A[i] 的前缀和，则： 第i个人交换次数为：|S[i]| 所以最终次数变为了：|S[i]| ，i从1到M求和！ 到了这里，题目就简单多了！普通均分纸牌就结束了！ 回归本题：这道题就是在均分纸牌的条件上，多了一个首和尾可以交换！成为了环形均分纸牌： 首先给出一个结论： 最优解下，一定存在两个人没有进行交换 如下图： 图：2号标错了，标在紧挨3号的位置才对。。。懒得换了！ 假如发生了这样的交换，1号和2后都在给三号，我们要的是交换次数最少，最优！那么为什么不把2号到3号的直接砍断，让1号给三号多一点，给另一方少一点，这样不就可以减少交换次数吗？ 没毛病，这样就反证了刚刚的结论！ 现在我们只需要枚举在哪里有两个人没有发生交换即可！ 假设发生在k处！ 上面的那个求和公式则是在1号和M号之间断开了！即：|S[i]| ，i从1到M求和！ 发生在K处的话，前缀和S[i]会发生什么变化： 如图： 我们可以将1~M的长条进行多条拼接，即可得到在任意处砍断的完整长条，假设在K处砍断：前缀和发什么什么变化？ S[k + 1] ———–&gt; S[k + 1] +( S[M] - S[k]) （可以在左边再延长一条线看出来） S[k] —————&gt; 0 S[1] —————&gt; S[1] + (S[M] - S[k]) S[i] —————&gt; S[i] + (S[M] - S[k]) 然后又因为S[i] 是A[i] = C[i] - T/M 的前缀和，叨叨S[M]时，前面的都已经变为0了，即达到T/M了，最后一个人则自动达成最终的T/M，所以最后一项一定是0，不需要发生交换！ 所以原式子：|S[i]| ，i从1到M求和！ 有了砍断部分的加入则变成了|S[i] - S[M]| - S[k]| 因为S[M]为0，则最终变为：|S[i] - S[k]| 最终交换次数为：|S[i] - S[k]| i从1到M求和 现在就是要找到砍断的地方，使得，这个式子求和和值最小！ 看这个式子的几何意义：就是k到各个前缀和的距离，此时，没有什么点数，牌数，已经转变为了一个个前缀和，就像一个个条形的柱子，想统计学的柱形图一样，在中间找一个地方，使得到左右柱子的距离和最短！ 眼熟吗？ 这不就是刚刚做过的AcWing-104. 货仓选址 吗？ 砍断处 k 相当于货仓位置，s[i] 相当于各个商店位置！ 什么时候距离最小呢？ 参考货仓选址的中位数证明！ 所以只要将 砍断处选在 中位数的位置即可达到最优解！ 本题解完毕！ 可以看《算法竞赛进阶指南》的作者李煜东的讲解视频：大概在29分钟的时候！ 题解：注意：要用long long，数据很大！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;int n, m, t;int a[N], b[N], f[N];LL calc(int c[], int n){ // c[i]--&gt;A[i] = C[i] - T/M // f[i]--&gt;S[i] 为A[i]前缀和 for(int i = 1; i &lt;= n; i++) c[i] -= c[0]/n, f[i] = f[i - 1] + c[i]; sort(f + 1, f + 1 + n); LL mid = f[n + 1 &gt;&gt; 1]; LL res = 0; //求 |S[i] - S[k]| 的和 for(int i = 1; i &lt;= n; i++) res += abs(f[i] - mid); return res;}int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for(int i = 1, x, y; i &lt;= t; i++) { cin &gt;&gt; x &gt;&gt; y; a[x] ++, b[y] ++; } for(int i = 1; i &lt;= n; i++) a[0] += a[i]; for(int i = 1; i &lt;= m; i++) b[0] += b[i]; int row = a[0] % n, col = b[0] % m; if(!row &amp;&amp; !col) cout &lt;&lt; \"both \" &lt;&lt; calc(a, n) + calc(b, m) &lt;&lt; endl; else if(!row) cout &lt;&lt; \"row \" &lt;&lt; calc(a, n) &lt;&lt; endl; else if(!col) cout &lt;&lt; \"column \" &lt;&lt; calc(b, m) &lt;&lt; endl; else cout &lt;&lt; \"impossible\"; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"前缀和","slug":"前缀和","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"中位数","slug":"中位数","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"字符串-字典序问题","slug":"字符串-字典序问题","date":"2020-03-04T09:36:10.000Z","updated":"2020-05-19T02:35:41.191Z","comments":true,"path":"posts/65259.html","link":"","permalink":"https://www.itnxd.cn/posts/65259.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目背景：题目描述在数据加密和数据压缩中常需要对特殊的字符串进行编码。给定的字母表A由26个小写英文字母组成A={a,b,…,z}。该字母表产生的升序字符串是指字符串中字母按照从左到右出现的次序与字母在字母表中出现的次序相同，且每个字符最多出现1次。例如，a,b,ab,bc,xyz等字符串都是升序字符串。现在对字母表A产生的所有长度不超过6的升序字符串按照字典序排列并编码如下。 1 2 … 26 27 28 … a b … z ab ac … 对于任意长度不超过6的升序字符串，迅速计算出它在上述字典中的编码。 算法设计：对于给定的长度不超过6的升序字符串，计算出它在上述字典中的编码。 输入格式第一行是一个正整数k，表示接下来共有k行。 接下来的k行中，每行给出一个字符串。 输出格式输出共有k行，每行对应于一个字符串的编码。 数据范围1≤n≤100000 输入样例：1232aab 输出样例：12127 题目分析：题目要求：输入一个字典序字符串，输出对应的编号，注意没有aa，abccd，后面的一定比前面的大！ 解题思路：先举一个例子：假如输入 cdfg ，要怎么计算了？ 先看长度为字符串长度的处理： c开头的一定排在a和b开头的后面，我们可以先算出a打头的长度为4的字符串有多少个，用C(26 - 1, 4 - 1) 表示从25个字符中组合3长度的组合种类！这句话是不是相当于C 325 了，即数学中的排列组合的组合，这样既可保证不重不漏，还可以保证字典序正确！ a完了，还有b开头的长度为4的字符串种类，即C(26 - 2, 4 - 1) ab完了，到了c，很明显，c不需要处理 往后移动，到了d的位置，c的下一个就是d，不需要处理 下一个f，会发现f一定在e开头的长度为2的字符串之后，所以需要继续统计,即C(26 - 5 , 4 - 3) 继续发现下一个是g，这也是最后一个，就简单了，不需要用到组合，g一定在a之后，最后直接累加一下a ~ g的编号即可！ 再看长度小于字符串长度的处理： 很明显：我们处理完毕了字符串本身长度的排序，还没有处理，在自身长度之下，长度为1 ~ len - 1 的长度，不过这就更加简单了！ 长度为1：C(26, 1) 长度为2：C(26, 2) 长度为len - 1：C(26, len - 1);","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"字典序","slug":"字典序","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E5%85%B8%E5%BA%8F/"},{"name":"组合数","slug":"组合数","permalink":"https://www.itnxd.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"AcWing-104.货仓选址","slug":"AcWing-104-货仓选址","date":"2020-03-03T04:19:38.000Z","updated":"2021-02-06T13:55:51.642Z","comments":true,"path":"posts/57916.html","link":"","permalink":"https://www.itnxd.cn/posts/57916.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：104. 货仓选址 题目背景： 贪心，贪的我很服。。。 题目描述在一条数轴上有 N 家商店，它们的坐标分别为 A1~AN。 现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。 为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。 输入格式第一行输入整数N。 第二行N个整数A1~AN。 输出格式输出一个整数，表示距离之和的最小值。 数据范围1≤N≤100000 输入样例：1246 2 9 1 输出样例：112 题目分析：题目要求：有N个商店，要求放一个仓库使得到所有商店的距离和最小，输出最小值！ 解题思路：第一想法就是暴力扫描一遍，选出最小值即可！但是超时了，数据范围为1e5，平方就是1e10，肯定超时，详见题解一的代码： 正确思路： 先排序，使其变成一条链状的情况！ 把a[0] ~ a[N-1]排序，设货仓在X坐标处，X左侧的商店有P家，右侧的商店有Q家。若P &lt; Q，则每把仓库的选址向右移动1单位距离，距离之和就会变少Q - P.同理，若P &gt; Q，则仓库的选址向左移动会使距离之和变小。当P==Q时为最优解。 结合图片，红色的圈表示商店，蓝色的箭头表示仓库的所在地： 第一种情况：左边的商店数目小于右边时，往右移动，则左边的都要加一，右边的都要减一，而右边的多，所以最终距离和会变小！ 第二种情况：左边的商店数目大于右边时，往左移动，则左边的都要减一，右边的都要加一，而左边的多，所以最终距离和会变小！ 第三种情况：第一种情况左移，和第二种情况右移，会发现最终都是变大的！ 总结：仓库的位置一定不在靠左，也不在靠右，因为，如果在两边，都会有更优的地方，可以取到最小值！所以中间一定是最优的地方； 也就是上图的红色箭头处，五个仓库取中间即可！ 分一下奇偶数情况，都进行取中位数即可，即仓库从N个商店中找一个中间商店，若为偶数则随便即可！我们统一选择偶数时编号小的那个：即res = n- 1 &gt;&gt; 1 一篇好理解一点的题解：点击这里！ 题解：题解一：（TLE）超时代码时间复杂度：O(N2) 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int a[N], b[N], k;int main(){ int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); int res = 0x3f; for(int i = a[0]; i &lt; a[n - 1]; i++) { int sum = 0; for(int j = 0; j &lt; n; j++) { sum += abs(i - a[j]); } b[k++] = sum; } sort(b, b + k); cout &lt;&lt; b[0] &lt;&lt; endl; return 0;} 题解二：选取中位数为仓库处时间复杂度：O(N) 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int a[N];int main(){ int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); int int sum = 0; for(int i = 0; i &lt; n; i++) sum += abs(a[res] - a[i]); cout &lt;&lt; sum &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Niu"},{"title":"AcWing-102.最佳牛围栏","slug":"AcWing-102-最佳牛围栏","date":"2020-03-01T14:36:13.000Z","updated":"2020-05-18T13:54:01.940Z","comments":true,"path":"posts/35910.html","link":"","permalink":"https://www.itnxd.cn/posts/35910.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：102. 最佳牛围栏 题目背景： 一道难题，前缀和，差分，双指针的叠加应用！ 题目描述农夫约翰的农场由 N 块田地组成，每块地里都有一定数量的牛,其数量不会少于1头，也不会超过2000头。 约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。 围起区域内至少需要包含 F 块地，其中 F 会在输入中给出。 在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。 输入格式第一行输入整数 N 和 F ，数据间用空格隔开。 接下来 N 行，每行输出一个整数，第i+1行输出的整数代表，第i片区域内包含的牛的数目。 输出格式输出一个整数，表示平均值的最大值乘以1000再 向下取整 之后得到的结果。 数据范围1≤N≤1000001≤F≤N 输入样例：123456789101110 66 4210385941 输出样例：16500 题目分析：题目要求：给了N块地，每块地有一些牛，现在想让你在1 ~ N 块地里，连续的选取大于 f 块地，使得得到的平均数最大！ 输出最大的平均值！ 解题思路：首先说一下我的思路：（TLE） 因为数据是10的五次方，我用的是O(N)的做法，那就是10的10次方了，远远大于C++一秒可以计算的次数了！ 我就是暴力找一遍！ 先计算前缀和，为了以后用的时候方便！然后用两重for循环去找，一个在区间左端点，一个在右端点，为了保证区间长度大于f，如解法一的两重for 循环的循环变量设置！每次取一个最大值即可，当然，它超时了！ 现在开始正确的O(NlogN)的做法： 二分思想： 那么我们判断是否存在一个平均值大于等于mid，如果最优解是x，那么mid &lt;= x的时候，必然可以找到一段，其平均值≥mid， 否则 一定找不到！ 就是说最终的答案那个平均值，一定在1 ~ 2000头牛之间，我们用二分，从mid开始，如果发现mid是可以合法的，那么一定有大于mid的平均值可以作为最后答案，也就是一定有一个从mid开始的一个长度&gt;=f的区间可以达到更大的平均值！所以区间开始一步步缩小，为了达到乘1000向下取值，精度就得达到1e-4左右，为了保险将精度压到1e-5！ 在平均值check时，可以将原值都减去传入的二分平均值mid，最后再进行前缀和！这时看一个区间平均值就可以直接看前缀和是不是大于0，大于0则平均值大于mid，反之，小于mid！ 如果可选区间有一个大于mid的区间，那么，最终答案一定大于mid，在主函数内部进行二分区间的缩小，往后移动即可！ 此处有一个即可，有一个，只要有就行，只要有就可以使得mid成立，即最终结果一定比mid大，区间要后移！有就行，那么当然要选择最小的，sum[j] - minv &gt;= 0 要想使这个式子成立，只要使得minv为可选区间最小即可，只要成立一种就行，用最小的岂不是更方便！ 接下来就是区间的变化，i,j始终保持f的距离！然后sum[j] - minv &gt;= 0 可以看到这个区间的长度一定是大于f的，可以画个图去理解！ 可以结合下面某位大神的题解： 我们要找的是 有没有一段不小于F的区间，使这段区间的平均数尽可能的大，如果我们找到了一段连续的区间且区间长度不小于F且平均数大于我们二分的平均数 ，那么大于这个数的区间也一定满足了， 我们直接返回true！ 因为我们要找一段区间的平均数，根据平均数的一个基本应用，显而易见，对于一段序列，每个数减去我们所算的平均数，如果大于0 那么他本身就大于平均数，如果小于0 那么它本身就小于平均数， 此时我们就能算出哪些数大于0 哪些数小于0 ，之后我们再使用前缀和，就能判断一个区间内的平均值是否大于或小于我们二分的平均数了！ 我们还可以继续优化，因为我们不仅需要找F大小区间内，我们还要找＞F大小区间内的，我们如果用二次for太费时间了，我们这里可以使用双指针的做法，我们设i=0,j=F ，每次使两个数++ ，因为i,j始终满足相距F的距离，所以我们用一个变量minv来存储i所遍历到的最小值，这样我们比较的距离一定是≥F的，并且如果我们用j位的前缀和数减去minv的话，就能得到我们的最优解，如果这个最优解＞= 0 那么就满足我们的指定条件，即可以得到平均值大于min的取值，返回true！ yxc大神的视频讲解：点击这里！ 一篇好理解一点的题解：点击这里！ 题解：解法一：本人的暴力超时做法！（TLE）时间复杂度：O(N2) 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N = 100010;int g[N], n, f;int main(){ cin &gt;&gt; n &gt;&gt; f; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; g[i]; g[i] += g[i - 1]; } double res = 0; for(int r = f; r &lt;= n; r++) { for(int l = 1; l &lt;= r - f + 1; l++) { double t = (g[r] - g[l - 1])/(r - l + 1.0); res = max(res, t); } } res *= 1000; printf(\"%.0lf\\n\", res); return 0;} 解法二：使用二分，前缀和，双指针的yxc大神的AC做法！好好看看代码，可以结合上面的题解与上面附出的大神的视频！ 注意：r 要取最大牛，输入时用来max函数，其实不取最大值，直接带入2000也可以，但取最大值更加精准！ 可能的最大值 ：题目最后这样写的！即要输出极大值，很明显r 最终一定比l大，所以最后要输出 r , 而不是 l ，输出 l 的话，其值一定会比 r 小！ 这里sum数组的变化是不需要处理的，数组每次其实都是重新复制去覆盖的，不用担心上一下会影响到下一次！ cow[i] - avg：可以看成整体，将每一位数都减去平均值！ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;const int N = 100010;int cow[N];double sum[N]; int n, f;bool check(double avg){ for(int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + cow[i] - avg; double minv = 0; for(int i = 0, j = f; j &lt;= n; i++, j++) { minv = min(minv, sum[i]); if(sum[j] - minv &gt;= 0) return true; } return false;}int main(){ cin &gt;&gt; n &gt;&gt; f; double l = 0, r = 0; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; cow[i], r = max(r, (double)cow[i]); while(r - l &gt; 1e-5) { double mid = (l + r) / 2; if(check(mid)) l = mid; else r = mid; } cout &lt;&lt; int(r * 1000) &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"前缀和","slug":"前缀和","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"},{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"author":"Mr.Niu"},{"title":"AcWing-101.最高的牛","slug":"AcWing-101-最高的牛","date":"2020-03-01T08:44:34.000Z","updated":"2020-05-18T13:54:01.937Z","comments":true,"path":"posts/63414.html","link":"","permalink":"https://www.itnxd.cn/posts/63414.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：101. 最高的牛 题目背景： 差分应用！ 题目描述有 N 头牛站成一行，被编队为1、2、3…N，每头牛的身高都为整数。 当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。 现在，我们只知道其中最高的牛是第 P 头，它的身高是 H ，剩余牛的身高未知。 但是，我们还知道这群牛之中存在着 M 对关系，每对关系都指明了某两头牛 A 和 B 可以相互看见。 求每头牛的身高的最大可能值是多少。 输入格式第一行输入整数N,P,H,M，数据用空格隔开。 接下来M行，每行输出两个整数 A 和 B ，代表牛 A 和牛 B 可以相互看见，数据用空格隔开。 输出格式一共输出 NN 行数据，每行输出一个整数。 第 ii 行输出的整数代表第 ii 头牛可能的最大身高。 数据范围1≤N≤100001≤H≤10000001≤A,B≤100000≤M≤10000 输入样例：1234569 3 5 51 35 34 33 79 8 输出样例：123456789545344555 注意： 此题中给出的关系对可能存在重复 题目分析：题目要求：n头牛，给出多组互相可以看见的牛，求所有牛的最大高度是多少？ 并且，如果两头牛可以互相看到，则两头牛中间的牛的高度一定小于两端的高度！ 解题思路：了解一个性质： 可不可能有两组可看到的牛发生重合，例如：（3, 8），（5, 11），很明显不可能，5要比8小，才能使得3和8看见；5还要比8大，才能使得5和11看见，很明显，已经矛盾了！ 所以所有的组数，都不会有覆盖，只可能是嵌套，所以假设原高度都是h，如果当前牛在区间内则必须得减一，才能保证互相看到，假如另一组数据正好包围当前数据，那么由于传递性，最外面要比中间的高，所以中间得减一，最内部还得减一！ 这是就可以用到差分序列了，如果假设原数组高度都是h，则差分序列： g[1] = h；剩下的都是0。即可！ 给区间-1操作： g[a + 1] --, g[b] ++; 可以画一下看看！ 最后为了得到牛的高度，即将差分序列再转回前缀和序列即可！ yxc大神的视频讲解：点击这里！ 题解：注意：a，b大小，逆序时交换一下，方便！ 注意：可能有重复数据，则判断一下，防止多减一操作！ 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;const int N = 10010;int g[N];bool visit[N][N];int main(){ int n, p, h, m; cin &gt;&gt; n &gt;&gt; p &gt;&gt; h &gt;&gt; m; g[1] = h; for(int i = 0, a, b; i &lt; m; i++) { cin &gt;&gt; a &gt;&gt; b; if(a &gt; b) swap(a, b); if(!visit[a][b]) { visit[a][b] = true; g[a + 1] --; g[b] ++; } } for(int i = 1; i &lt;= n; i++) { g[i] += g[i - 1]; cout &lt;&lt; g[i] &lt;&lt; endl; } return 0;} 更好一点的话：可以使用set集合来代替数组，毕竟set具有极快的查找速度！ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int N = 10010;int g[N];int main(){ int n, p, h, m; cin &gt;&gt; n &gt;&gt; p &gt;&gt; h &gt;&gt; m; g[1] = h; set&lt;pair&lt;int, int&gt;&gt; s; for(int i = 0, a, b; i &lt; m; i++) { cin &gt;&gt; a &gt;&gt; b; if(a &gt; b) swap(a, b); if(!s.count({a, b})) { s.insert({a, b}); g[a + 1] --; g[b] ++; } } for(int i = 1; i &lt;= n; i++) { g[i] += g[i - 1]; cout &lt;&lt; g[i] &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"差分序列","slug":"差分序列","permalink":"https://www.itnxd.cn/tags/%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97/"}],"author":"Mr.Niu"},{"title":"AcWing-100.增减序列","slug":"AcWing-100-增减序列","date":"2020-03-01T06:24:16.000Z","updated":"2020-05-18T13:54:01.937Z","comments":true,"path":"posts/41483.html","link":"","permalink":"https://www.itnxd.cn/posts/41483.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：100. 增减序列 题目背景： 前缀和和差分序列是互逆的！ 题目分析处详细解释！ 题目描述给定一个长度为 n 的数列 a1,a2,…,an，每次可以选择一个区间 [l,r]，使下标在这个区间内的数都加一或者都减一。 求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。 输入格式第一行输入正整数n。 接下来n行，每行输入一个整数，第i+1行的整数代表ai。 输出格式第一行输出最少操作次数。 第二行输出最终能得到多少种结果。 数据范围0&lt;n≤1050≤ai&lt;2147483648 输入样例：1234541122 输出样例：1212 题目分析：题目要求：在一个序列内任意选择区间，将区间内的数都进行加一或减一操作，使得最后的序列数字都一样，问对少步数和达到最少步数的方法总数！ 解题思路：先引入差分： a数组是普通序列，b数组是a数组的差分序列！ 差分序列定义：b[i] = a[i] - a[i-1], b[1] = a[1] 然后就是两个定理： b 序列是 a 序列的差分序列（定义就是这样定义的！） a 序列是 b 序列的前缀和序列（开始证明！） a[i] 可以写为 b[1] + b[i]：如下： 123456a[1],a[2],.…a[n]b[i] = a[i] - a[i-1], b[1] = a[1]a[i] = b[1] + b[2] +.…+ b[i] = a[1] + a[2] - a[1] + a[3] - a[2] +.…+ a[i] - a[i-1] = a[i] 证明成立！ 接下来开始看题！ 在一个(L，R)序列上加一个常数 C，相当于： 1b[L] += C b[R + 1] -= C; 这个可以稍微想一下：或者那笔画一下！ 假设序列从下标为1开始存储！ 再想一下：要想全部数变成同样的数，可以让b数组变成什么样？ 当然是让 b[1] ~ b[n] 都为0，也就是整个序列此时都是 a[1] ，即 n 个 a[1]！ 首先先将差分序列处理出来，我们可以想，既然是区间的端点出进行加一或减一，那么，让一个正数去–，一个负数去++是不是可以更快的达到为0的目的！ 所以可以将差分序列的正数和负数都累加一下计算出来！得到两个值！ 这样的话：选取一个区间就会使累积的正数（假如是40）和一个负数（假如是34）减一，这样直到其中一方为0，这样正负数匹配就结束了，可能剩下的多出来的一方（不为0的）就需要和b[0]或b[n + 1]来处理。 正负匹配需要最少为 34次，即min(34, 40) 多出来的最少需要 40 - 34 次，即abs(34 - 40) 或者直接这样想，一次就需要正负减1，全部处理完，自然就是最大的数了！就是40次，直接max(34, 40) 所以最少次数为：min(34, 40) + abs(34 - 40) = max(34, 40) 以及最后的方案数： min(34, 40)是死的，最后不一样的就是多出来的（不为0的）的数的方案，即 abs(40- 34) + 1！ yxc大神的视频讲解：点击这里！ 题解：讲解是下标从1开始，我是从0开始，都一样的！ 防止溢出，使用 long long！ 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e5 + 10;int n;int a[N], b[N];int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt; n; i++) b[i] = a[i] - a[i - 1]; // positive number, negative number LL pos = 0, neg = 0; for(int i = 0; i &lt; n; i++) if(b[i] &gt; 0) pos += b[i]; else neg -= b[i]; cout &lt;&lt; max(pos, neg) &lt;&lt; endl &lt;&lt; abs(pos - neg) + 1 &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"差分序列","slug":"差分序列","permalink":"https://www.itnxd.cn/tags/%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97/"}],"author":"Mr.Niu"},{"title":"AcWing-99.激光炸弹","slug":"AcWing-99-激光炸弹","date":"2020-02-29T14:07:26.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/26178.html","link":"","permalink":"https://www.itnxd.cn/posts/26178.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：99. 激光炸弹 题目背景：题目描述地图上有 N 个目标，用整数Xi,Yi表示目标在地图上的位置，每个目标都有一个价值Wi。 注意：不同目标可能在同一位置。 现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有的目标。 激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和x，y轴平行。 若目标位于爆破正方形的边上，该目标不会被摧毁！ 求一颗炸弹最多能炸掉地图上总价值为多少的目标。 输入格式第一行输入正整数 N 和 R ,分别代表地图上的目标数目和正方形的边长，数据用空格隔开。 接下来N行，每行输入一组数据，每组数据包括三个整数Xi,Yi,Wi,分别代表目标的x坐标，y坐标和价值，数据用空格隔开。 输出格式输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。 数据范围0≤ R ≤1090&lt; N ≤100000≤ Xi,Yi ≤50000≤ Wi ≤1000 输入样例：1232 10 0 11 1 1 输出样例：11 题目分析：题目要求：就是在一个地图上放一个边长为 r 正方形，最后要输出这个正方形扣住的区域权值最大的值！ 注意：正方形的边上的不算！ 解题思路：首先引入一维前缀和： 作用：可以在O(1)的时间内求出某一段区间的和！ 举个例子： a[1]、a[2] ……… a[n] 引入s[i]前缀和： s[i] = s[0]……+s[i] 加入求a[7] ~ a[40] 那么就等于s[40] - s[6]！ 接着引入二维前缀和： 就是变成了一个坐标： 首先给出递归式：s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; 画个图：紫色的自己加上红色和绿色构成的矩形，再加上另一个红色和绿色构成的矩形，在减去多加的绿色部分！ 接下来开始预处理前缀和，在输入是让x和y都加了1，这样在预处理时，不会出现负数下标，免得处理边界问题！ 由于每个点不止一个目标：所以数组要进行累加：g[x][y] += w; 接下来开始划分边长为R的矩形，要保证边长足够，所以i和j 最小也得从R开始，此时的(i, j) 指向的是矩形的右下角，这样可以保证不越界！ 递推式：g[i][j] - g[i - r][j] - g[i][j - r] + g[i - r][j - r] 很好理解的：此时的(i , j)表示的行和列，即第i行第j列！ 如下图： 假如：r = 2,要计算 g[3][3]为右下角时，需要减去画那两道红线所构成的两个矩形，再加上多减掉的交叉部分，这样剩下的就是从青绿色右下角开始的四个蓝色的圈，这样看来，得到的结果就不是R 边长了，而是R- 1的边长，这样也就可以保证边上的不被计算！ 为什么不把右边和下边两条边也删掉了？ 我看了好久！才发现： 不能删，删掉上和左就够了！ 你可以在脑袋里想一下，将那个矩形在图上飘起来，会发现盖住的部分最多就是那四个蓝色的圈！而R - 1 就可以实现边上的不记录效果！ 好好理解一下，可能有点绕！ yxc大神视频讲解：点击这里！ 题解：123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;const int N = 5010;int g[N][N];int main(){ int s, r; cin &gt;&gt; s &gt;&gt; r; // 题目R的数据有点问题，怎么可能比坐标最大还打，所以约束一下 r = min(r, 5010); int n = 5010; for(int i = 0, x, y, w; i &lt; s; i++) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; x ++, y ++; g[x][y] += w; } // 预处理前缀和 for(int i = 1; i &lt; n; i++) for(int j = 1; j &lt; n; j++) g[i][j] += g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1]; // 找到（i，j）为矩形右下角 int res = 0; for(int i = r; i &lt; n; i++) for(int j = r; j &lt; n; j++) res = max(res, g[i][j] - g[i - r][j] - g[i][j - r] + g[i - r][j - r]); cout &lt;&lt; res &lt;&lt; endl; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"二维前缀和","slug":"二维前缀和","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"}],"author":"Mr.Niu"},{"title":"AcWing-96.奇怪的汉诺塔","slug":"AcWing-96-奇怪的汉诺塔","date":"2020-02-29T09:44:12.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/34850.html","link":"","permalink":"https://www.itnxd.cn/posts/34850.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：96. 奇怪的汉诺塔 题目背景：题目描述汉诺塔问题，条件如下： 1、这里有A、B、C和D四座塔。 2、这里有n个圆盘，n的数量是恒定的。 3、每个圆盘的尺寸都不相同。 4、所有的圆盘在开始时都堆叠在塔A上，且圆盘尺寸从塔顶到塔底逐渐增大。 5、我们需要将所有的圆盘都从塔A转移到塔D上。 6、每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。 请你求出将所有圆盘从塔A移动到塔D，所需的最小移动次数是多少。 汉诺塔塔参考模型 输入格式没有输入 输出格式对于每一个整数n(1≤n≤121≤n≤12),输出一个满足条件的最小移动次数，每个结果占一行。 输入样例：1没有输入 输出样例：1参考输出格式 题目分析：题目要求：此题是三根柱子汉诺塔的变形，现在有四根棍子，需要输出n 为1 到12的最小移动次数即可！ 解题思路：先介绍一下三根棍子情况：不论有多少个碟子，都可看为这几步： 将前n - 1 个盘子移到第二个棍子 再将最底下的1个盘子移到第三个棍子 再将n - 1个盘子移到第三个棍子 所以得到递推式：d[n] = d[n - 1] + 1 + d[n - 1]; 初始值为d[1] = 1; 再看一下四根棍子的情况：不论多少个盘子，都可以看为这几步： 将前 i 个盘子移到第二个棍子 再将剩下的n - i 个盘子移到第三个棍子 再将 前 i 个盘子移到第四根棍子 所以得到递归式：f[n] = f[i] + d[n - i] + f[i]; 初始值为f[0] = 0； 前i 个盘子有 j种情况！每次取一个min函数即可！ 至于为什么是d[n - 1]，可以这样想，将前 i 个移走后，第二根柱子就死了，不能再用了，所以可以看做是三根棍子，第二步就变为了三根棍子的情况！ yxc大神的视频讲解：点击这里！ 题解：123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int d[20], f[20];int main(){ d[1] = 1; for(int i = 2; i &lt;= 12; i++) d[i] = d[i - 1] + 1 + d[i - 1]; memset(f, 0x3f, sizeof f); f[0] = 0; for(int i = 1; i &lt;= 12; i++) for(int j = 0; j &lt; i; j++) f[i] = min(f[i], f[j] + d[i - j] + f[j]); for(int i = 1; i &lt;= 12; i++) cout &lt;&lt; f[i] &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"Dp","slug":"Dp","permalink":"https://www.itnxd.cn/tags/Dp/"},{"name":"递推","slug":"递推","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E6%8E%A8/"}],"author":"Mr.Niu"},{"title":"AcWing-95.费解的开关","slug":"AcWing-95-费解的开关","date":"2020-02-29T08:39:12.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/18232.html","link":"","permalink":"https://www.itnxd.cn/posts/18232.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：95.费解的开关 题目背景：题目描述你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态 123451011101101101111000011011 在改变了最左上角的灯的状态后将变成： 123450111111101101111000011011 再改变它正中间的灯后状态将变成： 123450111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。 输入格式第一行输入正整数n，代表数据中共有n个待解决的游戏初始状态。 以下若干行数据分为nn组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。 输出格式一共输出n行数据，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。 对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。 数据范围0&lt;n≤500 输入样例：1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 输出样例：12332-1 题目分析：题目要求：给定一个 5 x 5 的矩阵，想要全部变成1，求最少的步数，并且改变一个上下左右都换变化！ 解题思路：我们可以一层一层去想，先看第一层，如果第一层有 0， 我们需要在下一层的正下方的那个点作为中心改变状态即可，使上面的0变为1,；同样，第一层结束，要想使第二层也全变为1，做法一样，使有0 的正下方作为中心改变即可；最终只需要判断改变了前四行后，第五行有没有全部变为1即可，若没有变为1，则此种情况并不合法。 第一层的变化自然是有2的五次方，仍然想成二进制来表示，只需枚举这些所有情况即可，将可达到最终状态的最小值找出来即可！ 也就是说，如果只考虑第一层，他的开关方法有2的五次方，最终可以使最后一层全部变为1的就是一组解！ 注意：本题输入是没有空格的，我以为有空格，用int来存储的，结果出了问题，可以使用char数组来存储即可！ 为了方便的复制一份g数组，使用的cstring头文件的memcpy函数！ memcpy()函数： 第一个参数：备份数组 第二个参数：原数组 第三个参数：用sizeof计算的大小 在进行0,1取反时，直接和1异或即可！ char类型的 0 和 1 也可以：对应的ASCII码分别为48和49，二进制如下： 110000 110001 异或后结果没有问题！ yxc大神的视频讲解：点击这里！ 题解：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;char g[10][10];char backup[10][10];int dx[5] = {0, -1, 1, 0, 0}, dy[5] = {0, 0, 0, -1, 1};bool in(int x, int y){ return x &gt;= 0 &amp;&amp; x &lt; 5 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 5;}// 改变五个值void turn(int x, int y){ for(int i = 0; i &lt; 5; i++) { int a = x + dx[i], b = y + dy[i]; if(in(a, b)) g[a][b] ^= 1; }}int solve(){ int ans = 0x3f; //二进制的1来表示按那个灯 for(int i = 0; i &lt; 1 &lt;&lt; 5; i++) { int res = 0; // 扫描第一层按过的开关，并进行修改 for(int j = 0; j &lt; 5; j++) { if(i &gt;&gt; j &amp; 1) { res ++; turn(0, j); } } // 扫描前四层 for(int j = 0; j &lt; 4; j++) { for(int k = 0; k &lt; 5; k++) { if(g[j][k] == '0') { res ++; turn(j + 1, k); } } } // 扫描最后一层 bool flag = true; for(int j = 0; j &lt; 5; j++) if(g[4][j] == '0') { flag = false; break; } // 还原g数组的状态 memcpy(g, backup, sizeof g); if(flag) ans = min(ans, res); } if(ans &gt; 6) return -1; return ans;}int main(){ cin &gt;&gt; n; while(n --) { for(int i = 0; i &lt; 5; i++) cin &gt;&gt; g[i]; memcpy(backup, g, sizeof g); cout &lt;&lt; solve() &lt;&lt; endl; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"递推","slug":"递推","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E6%8E%A8/"},{"name":"位运算","slug":"位运算","permalink":"https://www.itnxd.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"author":"Mr.Niu"},{"title":"AcWing-94.递归实现排列型枚举","slug":"AcWing-94-递归实现排列型枚举","date":"2020-02-28T13:10:57.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/45388.html","link":"","permalink":"https://www.itnxd.cn/posts/45388.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：94. 递归实现排列型枚举 题目背景：题目描述把 1~n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。 输入格式一个整数n。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。 数据范围1≤n≤9 输入样例：13 输出样例：1234561 2 31 3 22 1 32 3 13 1 23 2 1 题目分析：题目要求：全排列，字典序小的在前！ 解题思路：具体看代码以及注释和介绍！ 题解：题解一：最普通的递归：不解释了！没什么说的，极易理解！ 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; using namespace std;int n;int a[10];bool visit[10];void dfs(int u){ if(u == n) { for(int i = 0; i &lt; n ; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = 1; i&lt;= n; i++) { if(!visit[i]) { a[u] = i; visit[i] = true; dfs(u + 1); visit[i] = false; } }}int main(){ cin &gt;&gt; n; dfs(0); return 0;} 题解二：yxc大神的使用vector的版本auto 是C++ 11 的新特性，要想编译通过，需要在编译器设置好！具体百度！ 和上面注释掉的for循环是一样的！ 用state存储二进制状态，u表示当前枚举到的数，退出条件：u == n 时！ dfs结束后记得还原vector的状态！ 12345678910111213141516171819202122232425262728293031323334#include &lt;vector&gt;#include &lt;iostream&gt; using namespace std;int n;vector&lt;int&gt; v;void dfs(int u, int state){ if(u == n) { //for(int i = 0; i &lt; v.size() ; i++) cout &lt;&lt; v[i] &lt;&lt; \" \"; for(auto x : v) cout &lt;&lt; x &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = 1; i&lt;= n; i++) { if(!(state &gt;&gt; i &amp; 1)) { v.push_back(i); dfs(u + 1, state | 1 &lt;&lt; i); v.pop_back(); } }}int main(){ cin &gt;&gt; n; dfs(0, 0); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"}],"author":"Mr.Niu"},{"title":"AcWing-93.递归实现组合型枚举","slug":"AcWing-93-递归实现组合型枚举","date":"2020-02-28T11:17:32.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/53888.html","link":"","permalink":"https://www.itnxd.cn/posts/53888.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：93. 递归实现组合型枚举 题目背景： 递归实现，看完本篇你大概将知道递归转化为非递归方法！ 题目描述从 1~n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。 输入格式两个整数 n,m ,在同一行用空格隔开。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。 数据范围n&gt;00≤m≤nn+(n−m)≤25 输入样例：15 3 输出样例：123456789101 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5 思考题：如果要求使用非递归方法，该怎么做呢？ 题目分析：题目要求：解题思路： 一篇好理解的题解，点击这里！ 题解：题解一：最普通的递归：不解释了！ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt; using namespace std;const int N = 30;int n, m;int a[N];bool visit[N];void dfs(int k, int t, int m){ if(k == m) { for(int i = 0; i &lt; k; i++) cout &lt;&lt; a[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = t + 1; i &lt;= n; i++) { if(!visit[i]) { a[k] = i; visit[i] = true; dfs(k + 1, i, m); visit[i] = false; } }}int main(){ cin &gt;&gt; n &gt;&gt; m; dfs(0, 0, m); return 0;} 题解二：这是错误的。。题目要求最后要按字典序输出，如果用上次的二进制表示，结果没问题，但是顺序是乱的！没有规律的！ Go Out！ 123456789101112131415161718192021222324#include &lt;iostream&gt; using namespace std;int n, m;int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; 1 &lt;&lt; n; i++) { int k = 0; for(int j = 0; j &lt; n; j++) if(i &gt;&gt; j &amp; 1) k++; if(k == m) { for(int t = 0; t &lt; n; t++) if(i &gt;&gt; t &amp; 1) cout &lt;&lt; t + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; } } return 0;} 题解三：yxc大神的递归，以及递归转非递归：递归容易爆栈，有时候需要使用非递归！ 递归仍然和上一题一样，稍微修改一下，多一个计数器，如果sum + 后面可以取到的数的最大位数 n - u， 还达不到 要求的m为，直接return；后面为了输出按照字典序，要换一下dfs选与不选的顺序，至于为什么（自己大脑稍微模拟一下过程即可）。 接下来就是，转化为非递归的做法，将递归的过程分为三部分，如图上所标示的： pos 为0，为1，为2，三种状态！ 使用State结构体存储状态，多一个pos来标识当前处于的状态： 将初状态鸭压入栈中：stk.push({0, 0, 0, 0}); 进入while循环来判断三种状态： pos = 0，将递归的那一段写进去，改一下变量，将return改为continue，然后将当前状态改为1，压入栈中，将状态0的最后一句dfs也压入栈中。 pos = 1，将当前状态改为2，压入栈中，将状态1的那一句dfs也压入栈中。 pos = 2， 直接continue。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stack&gt;#include &lt;iostream&gt; using namespace std;struct State{ int pos, u, sum, state; };int n, m;void dfs(int u, int sum, int state){ // pos = 0 if(sum + n - u &lt; m) return; if(sum == m) { for(int i = 0; i &lt; n; i++) if(state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt;\" \"; cout &lt;&lt; endl; return; } dfs(u + 1, sum + 1, state | 1 &lt;&lt; u); // pos = 1 dfs(u + 1, sum, state); // pos = 2}int main(){ cin &gt;&gt; n &gt;&gt; m; //dfs(0, 0, 0); stack&lt;State&gt; stk; stk.push({0, 0, 0, 0}); while(stk.size()) { State t = stk.top(); stk.pop(); if(t.pos == 0) { if(t.sum + n - t.u &lt; m) continue; if(t.sum == m) { for(int i = 0; i &lt; n; i++) if(t.state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; continue; } t.pos = 1; stk.push(t); stk.push({0, t.u + 1, t.sum + 1, t.state | 1 &lt;&lt; t.u}); } else if(t.pos == 1) { t.pos = 2; stk.push(t); stk.push({0, t.u + 1, t.sum, t.state}); } else continue; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"},{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"}],"author":"Mr.Niu"},{"title":"AcWing-92.递归实现指数型枚举","slug":"AcWing-92-递归实现指数型枚举","date":"2020-02-28T09:02:35.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/14886.html","link":"","permalink":"https://www.itnxd.cn/posts/14886.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：92. 递归实现指数型枚举 题目背景： 多种做法！ 题目描述从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。 输入格式输入一个整数n。 输出格式每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。 数据范围1≤n≤15 输入样例：13 输出样例：12345678322 311 31 21 2 3 题目分析：题目要求：输出任任意位的组合（从小到大），包括0位组合（即输出空行），不限制输出顺序！ 解题思路：详见下方四种解法： 一篇好理解的题解，点击这里！ 题解：注意：选择0位也是一种情况，千万别忘记！要输出一个空行！ 解法一：本人能想到的最粗糙的做法：1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt; using namespace std;const int N = 15;int n, b[N];bool flag[N];void dfs(int k, int cnt, int pos){ if(cnt &gt;= k) { for(int i = 0; i &lt; k; i++) cout &lt;&lt; b[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = pos + 1; i &lt;= n; i++) { if(!flag[i]) { b[cnt] = i; flag[i] = true; dfs(k, cnt + 1, i); flag[i] = false; } }}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt;= n; i++) dfs(i, 0, 0); return 0;} 解法二：使用二进制优化：和之前做过的类似：将每一位的选择变成0和1的二进制即可，和直接使用数组存储（解法一）不一样的点： 添加第 i 位时：state |= 1 &lt;&lt;(i - 1); 最后还要恢复原状态：state ^= 1 &lt;&lt; (i - 1); 用到了异或和按位或，不懂的去学习一下！ 为何数组不需要恢复状态，而二进制需要恢复状态？ 因为数组存储时时从下标为0开始存储，一次dfs结束后，会进入下一次for循环，此时，数组存储的下标仍然是cnt，没有变化，即进行了覆盖，不会影响； 然而：使用二进制就不一样了，二进制存储的是每一位的状态，没有下标的关系，如果不进行恢复状态，下一次for循环可不是数组的原位覆盖，而是在新的地方置为了1，这样state状态就会多一位被选择的数，造成错误答案！ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; using namespace std;const int N = 15;int n, b[N];bool flag[N];void dfs(int state, int k, int cnt, int pos){ if(cnt &gt;= k) { for(int i = 0; i &lt; n; i++) if(state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; return; } for(int i = pos + 1; i &lt;= n; i++) { if(!flag[i]) { state |= 1 &lt;&lt;(i - 1); flag[i] = true; dfs(state, k, cnt + 1, i); flag[i] = false; state ^= 1 &lt;&lt; (i - 1); } }}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt;= n; i++) dfs(0, i, 0, 0); return 0;} 解法三：状态压缩非递归类似于第二种解法：用state来存储二进制集合，当然共有 2 n种，然后第二层for循环直接去从第0位开始扫描即可，遇到1 就输出，遇到0就跳过即可！ 本人最喜欢这种做法，既好理解又简洁！推荐！！！ 1234567891011121314151617181920#include &lt;iostream&gt; using namespace std;const int N = 15;int n, state[N];bool flag[N];int main(){ cin &gt;&gt; n; for(int state = 0; state &lt; 1 &lt;&lt; n; state++) { for(int j = 0; j &lt; n; j++) if(state &gt;&gt; j &amp; 1) cout &lt;&lt; j + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; } return 0;} 解法四：状态压缩递归形式（来自yxc大神）也就是第三种解法的递归写法，仍然是每一位数都有两种选择，选与不选，所以，此处的dfs的两个参数，第一个代表当前扫描到了哪一位，state表示当前状态的二进制为情况！ 两种状态： dfs(u + 1, state); ：不选，state 没有进行改变！ dfs(u + 1, state | (1 &lt;&lt; u)); ：选择，state 已经将 u + 1加入到了state中！ 退出条件，扫描到最后一项时进行输出和判断！ 总而言之：就像是一个二叉搜索树，都有选与不选两种情况，答案则在最后的叶子节点上！ 1234567891011121314151617181920212223242526#include &lt;iostream&gt; using namespace std;const int N = 15;int n;void dfs(int u, int state){ if(u == n) { for(int i = 0; i &lt; n; i++) if(state &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt; \" \"; cout &lt;&lt; endl; return; } dfs(u + 1, state); dfs(u + 1, state | (1 &lt;&lt; u));} int main(){ cin &gt;&gt; n; dfs(0, 0); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"二进制","slug":"二进制","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://www.itnxd.cn/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}],"author":"Mr.Niu"},{"title":"AcWing-91.最短Hamilton路径","slug":"AcWing-91-最短Hamilton路径","date":"2020-02-27T11:19:09.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/30496.html","link":"","permalink":"https://www.itnxd.cn/posts/30496.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：91. 最短Hamilton路径 题目背景： 这对我来说是一道难题，经过我一直理解，看题解，看yxc大神视频，反复多次，一点点的，终于明白了这个思想并且可以自己独立写出来！ 坚持！反复！终将成功！ 此题，时间限制为 3s ！ 题目描述给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。 输入格式第一行输入整数n。 接下来n行每行n个整数，其中第ii行第jj个整数表示点ii到jj的距离（记为a[i,j]）。 对于任意的x,y,z 数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]&gt;=a[x,z]。 输出格式输出一个整数，表示最短Hamilton路径的长度。 数据范围1 ≤ n ≤ 200 ≤ a[i,j] ≤ 10 7 输入样例：12345650 2 4 5 12 0 6 5 34 6 0 8 35 5 8 0 51 3 3 5 0 输出样例：118 题目分析：题目要求：给了n个点，以及n个点之间的权，要求出从起点到终点的最短路径，并且要不重不漏的走一遍！ 解题思路：当然最容易想到的就是直接暴力枚举，但是，n的范围为20，暴力的话会达到20的阶乘，这绝对超过了C++一秒计算可达到的次数，虽然题目是三秒，但是和常数相比，还是远远不够的！ 所以要用到状态压缩： 即所有点都有两种状态，选或不选，可以用0,1来表示（二进制），这样，所有的情况就是最大就是220 , 这远比阶乘要小。 举个例子：假如有8个点，选择 0,1,5,6 时，当前状态可以表示为：01100011。 状态转移方程为：dp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; j)][k] + weight[k][j]); i 不是一个数，它表示的是二进制，即2的n次方中的一种情况； j 表示的是，当前的终点； 首先：当前状态的终点为 j 为，要想计算当前值，需要拿当前值 和 刨去 第 j 位后的状态中找一个走过的点 k,即dp[i - (1 &lt;&lt; j)][k] 在加上要到j 的终点 weight[k][j]) ,就是一个完整的路径，然后将当前状态的所有情况（即k 的取值情况）与 已知dp[i][j] 取一个min即可！ 最终答案当然就是求：dp[(1 &lt;&lt; n) - 1][n - 1] 即 dp[111..共n个1..111] 表示n个点全部走过来，第二维的 n - 1则是说终点是 最后一个点！ 要想保住是从第0个点开始，就要保证二进制的第0位永远为1，即保证他是个奇数； j 的取值当然要保证在 当前 i 的状态内，即 i &gt;&gt; j &amp; 1 用这个来判断！ k 作为中间量，当然要保证当前状态 i 刨去 j 后 k 仍然在 i 的状态内，才能进行与第三者的连接！即 i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1 ！ 最终进行状态转移方程：dp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; j)][k] + weight[k][j]); 位运算不太清楚可以百度一下学习！ yxc大神的视频讲解，点击这里！ 一篇好理解的题解，点击这里！ 题解：加快速度的办法：使用二进制，并且转态压缩本就是用二级制来存储转态的，所以可以提高速度！ 注意：要将dp数组初始化为极大值！ 12345678910111213141516171819202122232425262728293031#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1 &lt;&lt; 20;int n, weight[21][21];int dp[N][21];int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) cin &gt;&gt; weight[i][j]; memset(dp, 0x3f, sizeof dp); dp[1][0] = 0; for(int i = 0; i &lt; 1 &lt;&lt; n; i++) if(i &amp; 1) for(int j = 0; j &lt; n; j++) if(i &gt;&gt; j &amp; 1) for(int k = 0; k &lt; n; k++) if(i - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) dp[i][j] = min(dp[i][j], dp[i - (1 &lt;&lt; j)][k] + weight[k][j]); cout &lt;&lt; dp[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"二进制","slug":"二进制","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"状压Dp","slug":"状压Dp","permalink":"https://www.itnxd.cn/tags/%E7%8A%B6%E5%8E%8BDp/"},{"name":"最短路","slug":"最短路","permalink":"https://www.itnxd.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"author":"Mr.Niu"},{"title":"AcWing-90.64位整数乘法","slug":"AcWing-90-64位整数乘法","date":"2020-02-27T06:00:36.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/39845.html","link":"","permalink":"https://www.itnxd.cn/posts/39845.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：90. 64位整数乘法 题目背景：题目描述求 a 乘 b 对 p 取模的值。 输入格式第一行输入整数a，第二行输入整数b，第三行输入整数p。 输出格式输出一个整数，表示a*b mod p的值。 数据范围1≤a,b,p≤1018 输入样例：123345 输出样例：12 题目分析：题目要求：两个十八位数相乘，然后模十八位数！ 解题思路：直接算肯定会超出数据类型的最大范围，所以不能直接算！ 使用高精度乘法去算，显然可以，但是没必要，本题不需要最后结果，需要的是模p 的结果，所以可以借助快速幂思想： 参考这里：AcWing-89.a ^ b 类似的：十八位数乘法会溢出，那么加法肯定不会溢出，所以就是要将乘法转化为加法： a * b a + a + a + a + a + a + a … + a a * 1 = 1a a * 2 = 2a a * 4 = 4a a * 8 = 8a … 和之前一样同样是倍增思想！ 快速幂是一个平方，这个就是一直乘2即可！ yxc大神的视频讲解：点击这里！ 题解：注意：unsigned long long 的范围是C++最大的 unsigned int 0～4294967295 int -2147483648～2147483647 unsigned long 0～4294967295 long -2147483648～2147483647 long long的最大值：9223372036854775807（19位） long long的最小值：-9223372036854775808 unsigned long long的最大值：18446744073709551615 （20位） 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;typedef unsigned long long ULL;ULL a, b, p;ULL res;int main(){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; while(b) { if(b&amp;1) res = (res + a) % p; b &gt;&gt;= 1; a = a * 2 % p; } cout &lt;&lt; res &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"快速幂","slug":"快速幂","permalink":"https://www.itnxd.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}],"author":"Mr.Niu"},{"title":"AcWing-89.a ^ b","slug":"AcWing-89-a^b","date":"2020-02-27T04:34:36.000Z","updated":"2020-06-14T01:05:01.986Z","comments":true,"path":"posts/2286.html","link":"","permalink":"https://www.itnxd.cn/posts/2286.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：89. a^b 题目背景：题目描述求 a 的 b 次方对 p 取模的值。 输入格式三个整数 a,b,在同一行用空格隔开。 输出格式输出一个整数，表示a^b mod p的值。 数据范围0≤a,b,p≤109 输入样例：13 2 7 输出样例：12 题目分析：题目要求：求a 的 b 次方 模 p 的值。 解题思路：直接循环求a 的 b 次幂，很明显会超时，C++ 一秒大概能运行10的7次方到10的8次方次之间，本题数据为10的9次方，肯定超时！ 所以需要用到快速幂来计算： 快速幂思想如图： 假如计算3 的 7 次方，7的二进制为111，如图，3的7次相当于3的1次，2次，4次，即3的2的0次+1次+2次，而3的2次是3的1次的平方，4次是2次的平方，所以这样看来，7次本来要算7回，这样只需要算三次即可，当然这里数据较小，假如是3的1000000次，只需要计算20次左右！可见提高了多少速度。 具体思想：对次数取最后一位，如果是奇数（即对应二进制位为1），就去累乘，如果是偶数（即二进制位为0），就跳过；当然每次都要存储好下一次需要计算的数据，即将当前值平方即可！ yxc大神的快速幂模板，点击这里！ yxc大神的视频讲解，点击这里！ 题解：注意点： 如果数据是这样：9 0 1 ，此时while进不去，最后会输出初始值1，但结果要对1取余，所以应该是0！所以要在开始时就对res 取余，次数取余不会影响到后面计算，只要p 比1大，此处相当于没有变化，只有1的时候会变化！或者也可以用if 来判断一下即可！ b&amp;1 ：就是判断是不是奇数，或者说对应的二进制位是不是1 1ll ：可以简单的将数据转化为long long类型，以防溢出！ b &gt;&gt; 1 ：即二进制位右移，相当于除2，转化为二进制位就是将最后一位扔掉！ 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int a, b, p;long long res = 1;int main(){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; p; res %= p; while(b) { if(b&amp;1) res = res * 1ll * a % p; a = a * 1ll * a % p; b &gt;&gt;= 1; } cout &lt;&lt; res &lt;&lt; endl; return 0;} 每天学习一点点！每天进步一点点！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"快速幂","slug":"快速幂","permalink":"https://www.itnxd.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}],"author":"Mr.Niu"},{"title":"AcWing-788.逆序对的数量","slug":"AcWing-788-逆序对的数量","date":"2020-02-26T13:19:28.000Z","updated":"2020-05-18T13:54:01.938Z","comments":true,"path":"posts/25834.html","link":"","permalink":"https://www.itnxd.cn/posts/25834.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：788. 逆序对的数量 题目背景：题目描述给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。 逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。 输入格式第一行包含整数n，表示数列的长度。 第二行包含 n 个整数，表示整个数列。 输出格式输出一个整数，表示逆序对的个数。 数据范围1≤n≤100000 输入样例：1262 3 4 5 6 1 输出样例：15 题目分析：题目要求：题目要求求出逆序对的数目，所谓逆序对就是后面的数小于前面的数就是一组！ 解题思路：首先，应该想到逆序对不就是从小大大排序时，需要交换的两者吗？所以可以使用冒泡排序，在进行交换时就进行++记录。 但是：很明显冒泡排序复杂度太大，是O(N) 的，一定超时。 所以又想到归并排序，归并排序也有逆序对的交换，所以也可以进行记录。时间复杂度为O(NlogN)！ 归并排序模板！点击这里！ 稍微解释一下归并排序，先分后合的思想： 分：将原来的一条链一直从中间切开，直到切到当前只有一个元素，这时，它是有序的。 合：将当前两个有序序列排好序用中间变量存储起来，最后再将中间序列还给原序列。 直到序列全部有序！ 本题就是要在归并排序的过程中，产生逆序对的时候，进行记录： 其中res 就是用来记录的，res = mid - i + 1; 关于这里，要详细解释一下： 123456789while(i &lt;= mid &amp;&amp; j &lt;= r){ if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else { res += mid - i + 1; temp[k++] = a[j++]; }} 首先：相邻的这两个序列，对序列本身自己来说，它是内部有序的，假如左边的序列大于右边的序列，由于左右都是有序的，那么左边的序列从当前位置 i 到 mid 结束时，都是要大于右边当前值的，所以逆序对不是1，而是 res += mid - i + 1; ， 至于为什么要这样算，因为等到右边的较小值被存储了之后，左边当前值以后真的值就没有机会和右边的被存储值进行比较了！ 如图： 题解：注意：最好使用long long 或许数据很大！ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;const int N = 100050;int a[N], temp[N];long long n, res;void merge_sort(int a[], int l, int r){ if(l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(a, l, mid), merge_sort(a, mid + 1, r); int k = 0, i = l, j = mid + 1; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else { res += mid - i + 1; temp[k++] = a[j++]; } } while(i &lt;= mid) temp[k++] = a[i++]; while(j &lt;= r) temp[k++] = a[j++]; for(i = l, j = 0; i &lt;= r; i++, j++) a[i] = temp[j];}int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; merge_sort(a, 0, n - 1); cout &lt;&lt; res &lt;&lt; endl; return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"归并排序","slug":"归并排序","permalink":"https://www.itnxd.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"逆序对","slug":"逆序对","permalink":"https://www.itnxd.cn/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"}],"author":"Mr.Niu"},{"title":"AcWing-1326.军训队列","slug":"AcWing-1326-军训队列","date":"2020-02-25T11:08:02.000Z","updated":"2020-05-18T13:54:01.940Z","comments":true,"path":"posts/13968.html","link":"","permalink":"https://www.itnxd.cn/posts/13968.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：1326. 军训队列 题目背景：题目描述有 n 名学生参加军训，军训的一大重要内容就是走队列，而一个队列的不整齐程度是该队中最高的学生的身高与最矮的学生的身高差值的平方。 现在要将 n 名参加军训的学生分成 k 个队列，每个队列的人数可以是任意非负整数。 在安排队列时希望所有队列的不整齐度之和尽量小，请问不整齐度之和最小可以是多少？ 输入格式第一行两个整数 n,k，表示学生人数和队列数。 第二行 n 个整数，依次表示每名学生的身高。 输出格式一个整数表示答案。 数据范围对于10%的数据，k=1；对于另外10%的数据，k=2；对于另外10%的数据，k=3；对于另外10%的数据，k=4；对于另外10%的数据，1≤n,k≤5；对于另外10%的数据，1≤n,k≤10；对于另外20%的数据，1≤n,k≤100；对于另外5%的数据，n=k=500;对于所有的数据，1≤n,k≤500，0≤ 学生身高 ≤200 输入样例：123 2170 180 168 输出样例：14 题目分析：这对我来说是一道难题，用到了贪心和动态规划： 我也是第一次接触Dp。 我的理解动态规划就是从小集合算到大集合，找大的集合和小的集合的关系，即可实现后面用到的前面已经算出来的效果！ 尽我的能力写了一篇足够详细的题解： 题目要求：n 个人，分成 k 组，求 k 组的最大最小值差的平方的最小值，也就是在所有分法中找一个最优解！ 解题思路：贪心 + Dp 首先，分成 k 组，一定要让 k 组不空，因为如果分成k - 1组，和从k - 1组里拿出一个人给了第k 组，后者得到的结果一定不会比前者更坏，最优解一定不会变大，也就是说，全部分成k组得到的结果会更优，自己好好想想！ 用二维数组 f[i][j] 表示将前 i 个人分成 j 组！ 前提：当然是从小到大排好序了！ 探讨 f[i][j] 的情况： 将 i 个人 划分为 j 组，考虑一下最后一组的情况，也就是要保证最后一组之前要有j - 1组，每组至少一个人，所以 最后一组的起始点最小值也得是 j , 而总共i 个人，那么最后一组的起始值的范围是 j &lt;= k &lt;= i ，也就是f[i][j] 的划分集合共有i - j 种，而最优解一定为其中一种，如下图： 继续看图：最终f[i][j] 的值当然就是前面的 j - 1 组的结果加上最后一组的和了： 前面j - 1 组，相当于从 k - 1 个人中划分 j - 1组，即f[k - 1][j - 1] : 所以：最终结果： f[i][j] = min(f[i][j], f[k - 1][j - 1] + (a[i] - a[k]) * (a[i] - a[k])); 计算最小值，当然要将f数组初始化为较大值：0x3f 。 划分组数 j 要保证不大于人数 i，不大于划分数 m 。 边界：当然是f[1][1] , 要想的到该值，当然需要有 f[0][0] 。将0个人划分为 0 组，结果当然为0；处理好边界值：f[0][0] = 0; k 的取值范围正如上面所讲，j 到 i 。 最后输出f[n][m] 即可！ 官方题解视频： yxc大神官方讲解 题解：123456789101112131415161718192021222324252627282930313233343536#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m;int a[510];int f[510][510];int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; if(m &gt;= n) { cout &lt;&lt; 0 &lt;&lt; endl; return 0; } sort(a + 1, a + n + 1); memset(f, 0x3f, sizeof f); f[0][0] = 0; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= i &amp;&amp; j &lt;= m; j++) { for(int k = j; k &lt;= i; k++) { f[i][j] = min(f[i][j], f[k - 1][j - 1] + (a[i] - a[k]) * (a[i] - a[k])); } } } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;} 历经千辛万苦，终于折腾完毕！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"Dp","slug":"Dp","permalink":"https://www.itnxd.cn/tags/Dp/"}],"author":"Mr.Niu"},{"title":"AcWing-1324.五子棋","slug":"AcWing-1324-五子棋","date":"2020-02-25T07:29:54.000Z","updated":"2020-05-18T13:54:01.939Z","comments":true,"path":"posts/44380.html","link":"","permalink":"https://www.itnxd.cn/posts/44380.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 题目链接：1324. 五子棋 题目背景：题目描述小 A 和小 B 在下五子棋。 五子棋是在一个由网格构成的棋盘内进行的。 网格有 15 行 15 列，共有 225 个交叉点。 小 A 先手执黑棋，小 B 后手执白棋。 两人轮流下棋，每次下棋都将一个自己的棋子放在棋盘上一个空白的交叉点上。 然而，由于小 A 和小 B 都不知道五子棋的胜利条件，所以即使有一方已经胜利了，他们仍然会继续下棋。 现在想请你帮忙分析一下，所下的棋局是在第几步结束的。 当然，也有可能他们最终仍然没有分出胜负，这时请判定他们平局。 五子棋的胜利条件是这样的：当同一行或同一列或同一斜线（即与网格线成 45° 角的直线）上连续的五个或五个以上交叉点放有同色棋子的时候，立即判定使用该颜色棋子的玩家获得胜利，游戏结束。 输入格式第一行输入一个正整数 n，表示双方总共下了多少步棋。 接下来 n 行，每行两个正整数。其中，第 i 行的两个数 x,y 表示第 i 步的棋子下在了第 x 条横线和第 y 条竖线的交叉点上。若 i 为奇数，则这个棋子是黑棋，否则是白棋。 输出格式若没有人获得胜利，你需要输出“Tie”（不含引号）。 否则，若小 A 获胜，输出 “A”（不含引号），若小 B 获胜，输出 “B”（不含引号）；并输出一个正整数 w 表示第 w 步下完后游戏应当结束，字母与整数间用一个空格隔开。 数据范围对于 20% 的数据，游戏结果是平局。对于 30% 的数据，游戏在最后一手结束。对于 100% 的数据，0≤n≤225，1≤x,y≤150≤n≤225，1≤x,y≤15。 输入样例：1234567891091 12 11 22 21 32 31 42 41 5 输出样例：1A 9 题目分析：题目要求：题目意思就是在一个15 x 15 的棋盘下棋，要你求出谁最后赢了，并且是在下第几课棋子时赢的！ 解题思路： 当然还是要下一步棋子，就判断一下是否有人胜利！ 方法就是要在下棋子的地方展开，如果下了这步棋子，胜利了，那么最后的结果必有这一个棋子，所以从这里展开！ 有四个方向可能五子连珠：横向，竖向，以及两个斜向！ 所以直接扫描四个方向即可！ 五子连珠条件：一个方向的正反向相加再加1大于等于5即可！ 题解：由于一个方向的正反完全可以由正或反乘以-1得到，所以只需记录八个方向的相连的四个方向即可。本人用dx 和 dy数组记录。 先后手判断奇偶数即可。 arr 为 0 表示空，为1表示先手，为2表示后手。 win 为 0 表示平局，1表示先手赢，2表示后手赢。 flag 标记是否五子连珠，step 表示胜利时的步数。 需注意越界条件和下一个棋子是否是本方棋色。 一个方向的正向就是+该变量，反向就是-该变量！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;iostream&gt; #include &lt;algorithm&gt;using namespace std;int n;int arr[20][20];// 1 先手 2 后手 int main(){ cin &gt;&gt; n; // 四个方向：下、右下、右、右上 int dx[4] = {1, 1, 0, -1}; int dy[4] = {0, 1, 1, 1}; int step, win = 0;//先手为1，后手为2 for(int i = 1; i &lt;= n; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; if(i % 2) arr[x][y] = 1; else arr[x][y] = 2; bool flag = false; // 判断四个方向 for(int j = 0; j &lt; 4; j++) { int a = 0, b = 0;//一个方向的正反 记录该方向可走的步数 // 正向 while(true) { int tx = x + (a + 1) * dx[j]; int ty = y + (a + 1) * dy[j]; if(tx &lt; 1 || tx &gt; 15 || ty &lt; 1 || ty &gt; 15) break;//越界 if(arr[x][y] != arr[tx][ty]) break;//棋子颜色不同 a++;//正方向++ } // 反向 while(true) { int tx = x - (b + 1) * dx[j]; int ty = y - (b + 1) * dy[j]; if(tx &lt; 1 || tx &gt; 15 || ty &lt; 1 || ty &gt; 15) break;//越界 if(arr[x][y] != arr[tx][ty]) break;//棋子颜色不同 b++;//反方向++ } if(a + b + 1 &gt;= 5) { flag = true; break; } } if(flag) { win = arr[x][y]; step = i; break; } } if(win == 0) cout &lt;&lt; \"Tie\" &lt;&lt; endl; else if(win == 1) printf(\"A %d\\n\", step); else printf(\"B %d\\n\", step); return 0;} 欢迎访问！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Niu"},{"title":"人一生需要花多少钱","slug":"人一生需要花多少钱","date":"2020-02-24T03:25:05.000Z","updated":"2020-05-18T13:54:01.941Z","comments":true,"path":"posts/42468.html","link":"","permalink":"https://www.itnxd.cn/posts/42468.html","excerpt":"","text":"一首歌曲送上 我们都是语言的巨人，行动的矮子！ 分享偶然看到的四张图： 看到图后，我想了很多，当然是乐观的想，本人并不是那种悲观的人！ 人一生花费的钱有这么多，现在不努力更待何时！ 每天努力一点点，不要管于你无关的事情！ 又想到了自己博客首页的座右铭： 你现在的努力，是为了以后有更多的选择！ 一则启示：俄罗斯方块告诉我们，合群跟随大众，随波逐流，我们就会消失，变得没有自我 。贪吃蛇告诉我们，不断的吸收负能量，不断的懒惰，害死我们的终究是自己 。愤怒的小鸟告诉我们，嘲笑我们的终究没有我们具有选择性，他们只有嘲笑的能力而我们具有打败别人的能力，变成猪的人类也只会嘲笑努力的人。 其实自律很简单：其实自律很简单，需要认清自己，再朝一个方向去行动。刚开始要给自己时间去适应，慢慢的慢慢的你就会习惯成自然。也不要刻意的强求自己定要做什么什么然后没做成而感到懊恼，在努力的过程中需要付出很多心血和汗水不要放弃、不要悲伤。终有一天你的目标会开花结果。不要每天看一些励志视频就为自己打一针鸡血，努力一下又开始堕落、迷茫。加油陌生人，一起朝着梦想努力[打call][打call][打call] 成为自己想成为的人：我一点也不聪明 我必须很努力的学才能达到和同龄人同样的成绩 优秀的人太多 很多人轻轻松松就能获得我努力了很久才能换来的成果 甚至我拼尽全力也得不来的成果 心里当然不是滋味 但我不羡慕 没有人的成功是空穴来风的 他们能做到轻而易举 那是因为他们已经默默付出了很多 而我只看到了表面 我要做的就是做好我自己 我慢慢来 一步一步来 总是可以的 因为我喜欢的 想干的事太多了 我想成为自己喜欢的人 一则视频送给努力的你们！ 最后送上四十句话：第一：我有我要赶去的远方，哪怕风雨兼程披星戴月。 第二：一棵树的树冠越是向往高处的太阳，它的跟越是得深入黑暗的地底。 第三：你不能要求一个没有风暴的海洋。那不是海，是泥塘。 第四：没有一个冬天不可跨越，也没有一个春天不会来临。 第五：先努力让自己发光，对的人才能迎着光而来。 第六：你那么憎恨的人，和他们斗了那么久。最终却要变得和他们一样。人世间没有任何理想值得以这样的沉沦作为代价。 第七：觉得为时已晚的时候恰恰是最早的时候。 第八：你走的每一步，都藏着未来的影子。 第九：要变优秀，堵住那悠悠众口。 第十：那一天，我也曾看到花团锦簇。那一夜，我也曾梦见百万雄兵。 第十一：你背单词时，阿拉斯加的鳕鱼正跃出水面；你算数学时，太平洋彼岸的海鸥振翅掠过城市上空；你晚自习时，极图中的夜空散漫了五彩斑斓。但是少年你别着急，在你为自己未来踏踏实实地努力时，那些你感觉从来不会看到的景色，那些你觉得终身不会遇到的人，正一步步向你走来。 第十二：我要和生活再死磕几年，要么我就毁灭，要么我就注定铸就辉煌。 第十三：在隆冬，我终于知道，在我身上有一个不可战胜的夏天。 第十四：他们试图把你埋了，但你要记得，你是种子。 第十五：要偷偷努力，希望自己也能成为别人的梦想。 第十六：一生中总会遇到这样的时候，你的内心已经兵荒马乱天翻地覆了，可是在别人看来你只是比平时沉默了一点，没人会觉得奇怪，这种战争，注定单枪匹马。 第十七：既然我找不到你，只好站在显眼的地方让你找到了。 第十八：这是个第一人称的世界，现在开始有我来论证这一切。 第十九：即使身在井隅，也仍然有仰望星空的权利。况且，我们生而闪耀，又何必活在别人的阴影里。 第二十：天行健，君子以自强不息。 第二十一：人世间有一种庸俗势力的大合唱。谁一旦对它屈服，就永远沉沦了。 第二十二：谁将声震人间，必长久深自缄默。谁将点燃闪电，必长久如云漂泊。 第二十三：所谓无底深渊，下去，也是前程万里。 第二十四：从来不是让你把一次考试当成人生的赌注，只是想让你在足够年轻的时候体会一次全力以赴。 第二十五：但凡不能杀死你的，最终都会使你更强大。 第二十六：生前何必久睡，死后自会长眠。 第二十七：你终究会成为你正在成为的人。 第二十八：我要悄悄拔尖，然后惊艳所有人。 第二十九：因为，我喜欢的东西很贵，想去的地方很远，喜欢的人很优秀。 第三十：不恨古人吾不见，恨古人不见吾狂尔。 等三十一：待到秋来九月八，我花开后百花杀。 第三十二：春来我不先张口，哪个虫儿干作声。 第三十三：大鹏一日同风起，扶摇直上九万里。 第三十四：想当年，金戈铁马，气吞万里如虎。 第三十五：仙路尽头谁为峰，一见无始道成空。 第三十六：海到无边天做岸，山登绝顶我为峰。 第三十七：窥尽阴阳理，易掌定乾坤。 第三十八：春风得意马蹄疾，一夜看尽长安花。 第三十九：他年若有凌云日，敢笑黄巢不丈夫。 第四十：俱往矣，数风流人物，还看今朝。 现在根本不晚，站起来奋斗吧！ 加油吧！骚年们！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"随笔","slug":"随笔","permalink":"https://www.itnxd.cn/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"努力","slug":"努力","permalink":"https://www.itnxd.cn/tags/%E5%8A%AA%E5%8A%9B/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之面向浏览器","slug":"JavaScript教程系列之面向浏览器","date":"2020-02-19T11:20:35.000Z","updated":"2020-05-19T02:37:44.326Z","comments":true,"path":"posts/57030.html","link":"","permalink":"https://www.itnxd.cn/posts/57030.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、浏览器对象(BOM) BOM是一套操作浏览器的API（接口/方法/属性） 常见的BOM对象： window：代表整个浏览器窗口（window是BOM中的一个对象，并且是顶级的对象） Navigator ：代表浏览器当前的信息，通过Navigator我们可以获取用户当前使用的是什么浏览器 Location： 代表浏览器当前的地址信息，通过Location我们可以获取或者设置当前的地址信息 History：代表浏览器的历史信息，通过History我们可以实现上一步/刷新/下一步操作（出于对用户的隐私考虑，我们只能拿到当前的浏览记录，不能拿到所有的历史记录） Screen：代表用户的屏幕信息 1、window对象 window对象不但充当全局作用域，而且表示浏览器窗口。 还记得之前的什么alert，console啥的没，那都是全局对象window的属性或者成员！ window对象的成员加不加window都一样，不加默认就是window！ innerWidth 和 innerHeight 获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。(当然：包括滚动条) 简而言之就是网页部分的尺寸！ 当然他会随网页大小而改变： 123console.log('window inner size: ' + innerWidth + ' x ' + innerHeight);// 一样的效果：console.log('window inner size: ' + window.innerWidth + ' x ' + window.innerHeight); 效果如下： outerWidth 和 outerHeight 获取浏览器窗口的整个宽高。 计算的是浏览器，而不是网页。 也是随浏览器大小而改变的！ 12console.log('window outersize: ' + window.outerWidth+ ' x ' + window.outerHeight);// window outersize: 1536 x 864 2、navigator对象 navigator对象表示浏览器的信息，获取浏览器信息 常见属性： navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型；（不是你的电脑系统！） navigator.userAgent：浏览器设定的User-Agent字符串。 12345console.log('appName = ' + navigator.appName);console.log('appVersion = ' + navigator.appVersion);console.log('language = ' + navigator.language);console.log('platform = ' + navigator.platform);console.log('userAgent = ' + navigator.userAgent); 效果如下： 3、screen对象 screen对象用来获取屏幕的信息！ 常用属性： screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。 1234console.log('Screen size = ' + screen.width + ' x ' + screen.height);console.log('colorDepth = ' + screen.colorDepth );// Screen size = 1536 x 864// colorDepth = 24 4、location对象 location对象表示当前页面的URL信息！ 常用属性： 123456789101112http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOPlocation.href;//http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOPlocation.protocol; // 'http'location.host; // 'www.example.com'location.port; // '8080'location.pathname; // '/path/index.html'location.search; // '?a=1&amp;b=2'location.hash; // 'TOP'window.location.href; //获取当前地址栏的地址window.location.href = “http://www.baidu.com”; // 设置当前地址栏的地址 刷新和强制刷新（Ctrl + F5）: 123window.location.reload(); //刷新window.location.reload(true); //强制刷新window.location.assign('/'); // 设置一个新的URL地址 5、document对象 document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。 其独特之处是唯一一个既属于BOM又属于DOM的对象！ document.title：改变title标签的属性 1document.title = '努力学习JavaScript!'; getElementById()和getElementsByTagName() 通过id获取和通过标签获取！ 12var menu = document.getElementById('drink-menu');var drinks = document.getElementsByTagName('dt'); document.cookie document对象还有一个cookie属性，可以获取当前页面的Cookie。 1document.cookie; // 'v=123; remember=true; prefer=zh' 6、history对象 history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。 这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。 新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。 任何情况，你都不应该使用history这个对象了。 12345window.history.forword(); //上一步 window.history.back(); //下一步 window.history.go(0); //接收参数 0 表示刷新当前页面 window.history.go(2); //接收正整数 表示前进2个页面 window.history.go(-2); //接收负整数 表示后退2个页面 二、操作DOM DOM是一套操作标签的API（接口/方法/属性） 由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。 始终记住DOM是一个树形结构。 DOM的基本操作： 更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容； 遍历：遍历该DOM节点下的子节点，以便进行进一步操作； 添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点； 删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。 1、获取DOM节点 document.getElementById()：通过id获取 document.getElementsByTagName()：通过标签获取 document.getElementsByClassName()：通过class获取 注意：通过id获取是唯一的，通过标签和class获取的是一组DOM节点 1.1 可以通过先定位父节点再来定位子节点来进行唯一确定！123456789101112131415// 返回ID为'test'的节点：var test = document.getElementById('test');// 先定位ID为'test-table'的节点，再返回其内部所有tr节点：var trs = document.getElementById('test-table').getElementsByTagName('tr');// 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点：var reds = document.getElementById('test-div').getElementsByClassName('red');// 获取节点test下的所有直属子节点:var cs = test.children;// 获取节点test下第一个、最后一个子节点：var first = test.firstElementChild;var last = test.lastElementChild; 1.2 通过 querySelector() 和 querySelectorAll() 获取12345// 通过querySelector获取ID为q1的节点：var q1 = document.querySelector('#q1');// 通过querySelectorAll获取q1节点内的符合条件的所有节点：var ps = q1.querySelectorAll('div.highlighted &gt; p'); 1.3 一道简单测试题：题目背景： 12345678910111213141516&lt;!-- HTML结构 --&gt;&lt;div id=\"test-div\"&gt; &lt;div class=\"c-red\"&gt; &lt;p id=\"test-p\"&gt;JavaScript&lt;/p&gt; &lt;p&gt;Java&lt;/p&gt; &lt;/div&gt; &lt;div class=\"c-red c-green\"&gt; &lt;p&gt;Python&lt;/p&gt; &lt;p&gt;Ruby&lt;/p&gt; &lt;p&gt;Swift&lt;/p&gt; &lt;/div&gt; &lt;div class=\"c-green\"&gt; &lt;p&gt;Scheme&lt;/p&gt; &lt;p&gt;Haskell&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 选择指定项： 1234567891011121314151617181920212223242526272829// 1、选择&lt;p&gt;JavaScript&lt;/p&gt;:var js = document.getElementById('test-p');// 2、选择&lt;p&gt;Python&lt;/p&gt;,&lt;p&gt;Ruby&lt;/p&gt;,&lt;p&gt;Swift&lt;/p&gt;:// 2.1 分开写：var arr = document.querySelector('div[class = \"c-red c-green\"]').querySelectorAll('p');// 2.2 合并写：var arr = document.querySelectorAll('div[class = \"c-red c-green\"] &gt; p');// 2.3 另一种写法：var arr = document.querySelectorAll('.c-red.c-green p');// 2.4 另一种：var arr = document.getElementsByClassName('c-red')[1].children;// 3、选择&lt;p&gt;Haskell&lt;/p&gt;:// 3.1 用数组序号获取元素：var haskell = document.querySelectorAll('div[class = \"c-green\"] &gt; p')[1];// 3.2 另一种写法：var haskell = document.querySelector('.c-green:not(.c-red)').lastElementChild;// 测试:if (!js || js.innerText !== 'JavaScript') { alert('选择JavaScript失败!');} else if (!arr || arr.length !== 3 || !arr[0] || !arr[1] || !arr[2] || arr[0].innerText !== 'Python' || arr[1].innerText !== 'Ruby' || arr[2].innerText !== 'Swift') { console.log('选择Python,Ruby,Swift失败!');} else if (!haskell || haskell.innerText !== 'Haskell') { console.log('选择Haskell失败!');} else { console.log('测试通过!');} 2、更新DOM节点 用来直接修改节点的文本！ 2.1 innerHTML属性 可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树： 通过innerHTML属性，原内容已经被覆盖！ 1、可以传入普通内容 2、也可以传入标签，标签会直接被解析为HTML内容！ 1234567891011&lt;p id=\"my-p\"&gt;...&lt;/p&gt;&lt;script&gt; // 获取&lt;p id=\"p-id\"&gt;...&lt;/p&gt; let p1 = document.getElementById('my-p'); // 设置文本为abc: p1.innerHTML = 'cde'; // &lt;p id=\"p-id\"&gt;ABC&lt;/p&gt; // 设置HTML: p1.innerHTML = 'ABC &lt;span style=\"color:red\"&gt;RED&lt;/span&gt; XYZ'; // &lt;p&gt;...&lt;/p&gt;的内部结构已修改&lt;/script&gt; 2.2 innerText属性 属性中无法传入html标签，若传入，则会直接被解析为文本显示！不是解析为HTML标签！ 123456789&lt;p id=\"my-p\"&gt;...&lt;/p&gt;&lt;script&gt; // 获取&lt;p id=\"p-id\"&gt;...&lt;/p&gt; var p = document.getElementById('my-p'); // 设置文本: p.innerText = '&lt;span&gt;hhhhh&lt;/span&gt;';&lt;/script&gt; 特殊点： 无法正常显示script标签： 12345678910&lt;p id=\"p-id\"&gt;hello&lt;/p&gt;&lt;script&gt; var p = document.getElementById('p-id'); // 设置文本:此句无法正常显示 p.innerText = '&lt;script&gt;alert(\"Hi\")&lt;/script&gt;'; // HTML被自动编码，无法设置一个&lt;script&gt;节点:&lt;/script&gt;// 正常显示方法：&lt;p id=\"p-id\"&gt;&amp;lt;script&amp;gt;alert(\"Hi\")&amp;lt;/script&amp;gt;&lt;/p&gt; 2.3 textContent属性 两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本 作用和 innerText 一样！ 123456789&lt;p id=\"my-p\"&gt;...&lt;/p&gt;&lt;script&gt; // 获取&lt;p id=\"p-id\"&gt;...&lt;/p&gt; var p = document.getElementById('my-p'); // 设置文本: p.textContent = '&lt;span&gt;hhhhh&lt;/span&gt;';&lt;/script&gt; 2.4 style属性 DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize： CSS 的属性带有- 的都变为驼峰命名法！ 123456// 获取&lt;p id=\"p-id\"&gt;...&lt;/p&gt;var p = document.getElementById('p-id');// 设置CSS:p.style.color = '#ff0000';p.style.fontSize = '20px';p.style.paddingTop = '2em'; 3、插入DOM节点 如果这个DOM节点是空的，例如，&lt;div&gt;&lt;/div&gt;，那么，直接使用innerHTML = 'child'就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。 如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点。 方法一：使用 appendChild 把一个子节点添加到父节点的最后一个子节点 首先会从原先的位置删除，再插入到新的位置。 123456789101112&lt;!-- HTML结构 --&gt;&lt;p id=\"js\"&gt;JavaScript&lt;/p&gt;&lt;div id=\"list\"&gt; &lt;p id=\"java\"&gt;Java&lt;/p&gt; &lt;p id=\"python\"&gt;Python&lt;/p&gt; &lt;p id=\"scheme\"&gt;Scheme&lt;/p&gt;&lt;/div&gt;// JavaScript代码var js = document.getElementById('js'), list = document.getElementById('list');list.appendChild(js); 最终结果： 1234567&lt;!-- HTML结构 --&gt;&lt;div id=\"list\"&gt; &lt;p id=\"java\"&gt;Java&lt;/p&gt; &lt;p id=\"python\"&gt;Python&lt;/p&gt; &lt;p id=\"scheme\"&gt;Scheme&lt;/p&gt; &lt;p id=\"js\"&gt;JavaScript&lt;/p&gt;&lt;/div&gt; 一个例子：打开谷歌控制台，将下面代码复制到任意个网页，观看网页CSS变化！ 1234var d = document.createElement('style');d.setAttribute('type', 'text/css');d.innerHTML = 'p { color: red }';document.getElementsByTagName('head')[0].appendChild(d); 如下，会发现多了一行CSS，而网页只要是p标签都会被修改颜色！ 方法二：使用 insertBefore 可将子节点插入到指定位置！ 可以使用parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前。 123456789101112131415&lt;!-- HTML结构 --&gt;&lt;div id=\"list\"&gt; &lt;p id=\"java\"&gt;Java&lt;/p&gt; &lt;p id=\"python\"&gt;Python&lt;/p&gt; &lt;p id=\"scheme\"&gt;Scheme&lt;/p&gt;&lt;/div&gt;var list = document.getElementById('list'), ref = document.getElementById('python'), haskell = document.createElement('p');haskell.id = 'haskell';haskell.innerText = 'Haskell';// 将新建的p标签（haskell）插入到ref的前面list.insertBefore(haskell, ref); 效果如下： 1234567&lt;!-- HTML结构 --&gt;&lt;div id=\"list\"&gt; &lt;p id=\"java\"&gt;Java&lt;/p&gt; &lt;p id=\"haskell\"&gt;Haskell&lt;/p&gt; &lt;p id=\"python\"&gt;Python&lt;/p&gt; &lt;p id=\"scheme\"&gt;Scheme&lt;/p&gt;&lt;/div&gt; 使用 children 属性来遍历 遍历一个父节点的所有子节点！ 123456var i, c, list = document.getElementById('list');for (i = 0; i &lt; list.children.length; i++) { c = list.children[i]; // 拿到第i个子节点} 4、删除DOM 要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉： 注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 1234567// 拿到待删除节点:var self = document.getElementById('to-be-removed');// 拿到父节点:var parent = self.parentElement;// 删除:var removed = parent.removeChild(self);removed === self; // true 当你遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。 12345678&lt;div id=\"parent\"&gt; &lt;p&gt;First&lt;/p&gt; &lt;p&gt;Second&lt;/p&gt;&lt;/div&gt;var parent = document.getElementById('parent');parent.removeChild(parent.children[0]);parent.removeChild(parent.children[1]); // &lt;-- 浏览器报错 三、操作表单表单类型主要有以下几种： 文本框，对应的&lt;input type=\"text\"&gt;，用于输入文本； 口令框，对应的&lt;input type=\"password\"&gt;，用于输入口令； 单选框，对应的&lt;input type=\"radio\"&gt;，用于选择一项； 复选框，对应的&lt;input type=\"checkbox\"&gt;，用于选择多项； 下拉框，对应的&lt;input type=\"select\"&gt;，用于选择一项； 隐藏文本，对应的&lt;input type=\"hidden\"&gt;，用户不可见，但表单提交时会把隐藏文本发送到服务器。 1、获取值 如果我们获得了一个&lt;input&gt;节点的引用，就可以直接调用value获得对应的用户输入值： 123// &lt;input type=\"text\" id=\"email\"&gt;var input = document.getElementById('email');input.value; // '用户输入的值' 这种方式可以应用于text、password、hidden以及select。 但是，对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断： 12345678// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"monday\" value=\"1\"&gt; Monday&lt;/label&gt;// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"tuesday\" value=\"2\"&gt; Tuesday&lt;/label&gt;var mon = document.getElementById('monday');var tue = document.getElementById('tuesday');mon.value; // '1'tue.value; // '2'mon.checked; // true或者falsetue.checked; // true或者false 2、设置值 设置值和获取值类似，对于text、password、hidden以及select，直接设置value就可以： 123// &lt;input type=\"text\" id=\"email\"&gt;var input = document.getElementById('email');input.value = 'test@example.com'; // 文本框的内容已更新 对于单选框和复选框，设置checked为true或false即可。 123456// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"monday\" value=\"1\"&gt; Monday&lt;/label&gt;// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"tuesday\" value=\"2\"&gt; Tuesday&lt;/label&gt;var mon = document.getElementById('monday');var tue = document.getElementById('tuesday');mon.checked = true; // true或者falsetue.checked = false; // true或者false 3、HTML5控件 HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用``标签： 具体效果自己试一下！ 123&lt;input type=\"date\" value=\"2015-07-01\"&gt;&lt;input type=\"datetime-local\" value=\"2015-07-01T02:03:04\"&gt;&lt;input type=\"color\" value=\"#ff0000\"&gt; 3、提交表单 JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面章节介绍）。 通过绑定submit()方法实现： 这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击``时提交表单，或者用户在最后一个输入框按回车键！ 1234567891011121314&lt;!-- HTML --&gt;&lt;form id=\"test-form\"&gt; &lt;input type=\"text\" name=\"test\"&gt; &lt;button type=\"button\" onclick=\"doSubmitForm()\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function doSubmitForm() { var form = document.getElementById('test-form'); // 可以在此修改form的input... // 提交form: form.submit();}&lt;/script&gt; 通过form本身的onsubmit事件 注意要return true来告诉浏览器继续提交，如果return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。 在检查和修改时，要充分利用来传递数据。 1234567891011121314&lt;!-- HTML --&gt;&lt;form id=\"test-form\" onsubmit=\"return checkForm()\"&gt; &lt;input type=\"text\" name=\"test\"&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() { var form = document.getElementById('test-form'); // 可以在此修改form的input... // 继续下一步: return true;}&lt;/script&gt; 关于MD5 安全考虑，提交表单时不传输明文口令，而是口令的MD5 这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个*变成32个*（因为MD5有32个字符）。 12345678910111213141516&lt;!-- HTML --&gt;&lt;form id=\"login-form\" method=\"post\" onsubmit=\"return checkForm()\"&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;input type=\"password\" id=\"password\" name=\"password\"&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() { var pwd = document.getElementById('password'); // 把用户输入的明文变为MD5: pwd.value = toMD5(pwd.value); // 继续下一步: return true;}&lt;/script&gt; 利用&lt;input type=\"hidden\"&gt;实现： 可以实现不改变用户的输入！ 注意到id为md5-password的标记了`name=\"password\"`，而用户输入的`id`为`input-password`的没有name属性。没有name属性的``的数据不会被提交。 123456789101112131415161718&lt;!-- HTML --&gt;&lt;form id=\"login-form\" method=\"post\" onsubmit=\"return checkForm()\"&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;input type=\"password\" id=\"input-password\"&gt; &lt;input type=\"hidden\" id=\"md5-password\" name=\"password\"&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() { var input_pwd = document.getElementById('input-password'); var md5_pwd = document.getElementById('md5-password'); // 把用户输入的明文变为MD5: md5_pwd.value = toMD5(input_pwd.value); // 继续下一步: return true;}&lt;/script&gt; 4、一个例子利用JavaScript检查用户注册信息是否正确，在以下情况不满足时报错并阻止提交表单： 用户名必须是3-10位英文字母或数字； 口令必须是6-20位； 两次输入口令必须一致。 12345678910111213141516&lt;!-- HTML结构 --&gt;&lt;form id=\"test-register\" action=\"#\" target=\"_blank\" onsubmit=\"return checkRegisterForm()\"&gt; &lt;p id=\"test-error\" style=\"color:red\"&gt;&lt;/p&gt; &lt;p&gt; 用户名: &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;/p&gt; &lt;p&gt; 口令: &lt;input type=\"password\" id=\"password\" name=\"password\"&gt; &lt;/p&gt; &lt;p&gt; 重复口令: &lt;input type=\"password\" id=\"password-2\"&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt; &lt;button type=\"reset\"&gt;重置&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233&lt;script&gt; var checkRegisterForm = function () { let re1 = /^\\w{3,10}$/; re2 = /^.{6,20}$/; user = document.getElementById('username'); pwd = document.getElementById('password'); pwd2 = document.getElementById('password-2'); if ( re1.test(user.value) &amp;&amp; re2.test(pwd.value) &amp;&amp; pwd.value === pwd2.value ) { return true; } else { return false; } return false; } // 测试: ;(function () { window.testFormHandler = checkRegisterForm; var form = document.getElementById('test-register'); if (form.dispatchEvent) { var event = new Event('submit', { bubbles: true, cancelable: true }); form.dispatchEvent(event); } else { form.fireEvent('onsubmit'); } })();&lt;/script&gt; 四、操作文件 在HTML表单中，可以上传文件的唯一控件就是&lt;input type=\"file\"&gt;。 注意：当一个表单包含&lt;input type=\"file\"&gt;时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。 出于安全考虑，浏览器只允许用户点击&lt;input type=\"file\"&gt;来选择本地文件，用JavaScript对&lt;input type=\"file\"&gt;的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径： 通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件： 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022494381696#0 补充教程：https://www.w3school.com.cn/jsref/event_onchange.asp 目前一脸懵逼，以后再细看把！ 123456var f = document.getElementById('test-file-upload');var filename = f.value; // 'C:\\fakepath\\test.png'if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) { alert('Can only upload image file.'); return false;} File API 由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。 随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。 HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。 下面的例子演示了如何读取用户选取的图片文件，并在一个``中预览图像： 可以自己编一下看看效果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt; &lt;title&gt;文件api&lt;/title&gt; &lt;style&gt; #test-image-preview { width:500px; height:500px; border:1px solid #ff0000; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; &lt;div id=\"test-file-info\"&gt;&lt;/div&gt; &lt;div id=\"test-image-preview\"&gt;&lt;/div&gt; &lt;input id=\"test-image-file\" type=\"file\"&gt;&lt;/form&gt;&lt;script &gt; window.onload=function(){ var fileInput = document.getElementById('test-image-file'); var info = document.getElementById('test-file-info'); var preview = document.getElementById('test-image-preview'); fileInput.addEventListener('change',function(){ console.log('change...'); preview.style.backgroundImage=''; if (!fileInput.value){ info.innerHTML = '没有选择文件'; return ; } var file = fileInput.files[0]; info.innerHTML = '文件:' + file.name + '&lt;br&gt;'+'大小:'+file.size+'&lt;br&gt;'+'修改:'+file.lastModifiedDate; if(file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif'){ alert('不是有效的图片文件!'); return; } var reader = new FileReader(); reader.onload=function(e){ console.log('reader.onload'); var data = e.target.result;// 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage='url('+ data +')'; }; reader.readAsDataURL(file); }); };&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...，常用于设置图像。如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。 五、AJAX1、AJAX 的起源 AJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。 如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。 这就是Web的运作原理：一次HTTP请求对应一个页面。 如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。 最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。 用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 2、编写AJAX 通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest。注意，不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性，一是因为这个字符串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。 当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。 XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。 注意，千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。 最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象： 123456789101112131415161718192021222324252627282930313233function success(text) { var textarea = document.getElementById('test-response-text'); textarea.value = text;}function fail(code) { var textarea = document.getElementById('test-response-text'); textarea.value = 'Error code: ' + code;}var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象request.onreadystatechange = function () { // 状态发生变化时，函数被回调 if (request.readyState === 4) { // 成功完成 // 判断响应结果: if (request.status === 200) { // 成功，通过responseText拿到响应的文本: return success(request.responseText); } else { // 失败，根据响应码判断失败原因: return fail(request.status); } } else { // HTTP请求还在继续... }}// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); 对于低版本的IE，需要换一个ActiveXObject对象： 123456789101112131415161718192021222324252627282930313233function success(text) { var textarea = document.getElementById('test-ie-response-text'); textarea.value = text;}function fail(code) { var textarea = document.getElementById('test-ie-response-text'); textarea.value = 'Error code: ' + code;}var request = new ActiveXObject('Microsoft.XMLHTTP'); // 新建Microsoft.XMLHTTP对象request.onreadystatechange = function () { // 状态发生变化时，函数被回调 if (request.readyState === 4) { // 成功完成 // 判断响应结果: if (request.status === 200) { // 成功，通过responseText拿到响应的文本: return success(request.responseText); } else { // 失败，根据响应码判断失败原因: return fail(request.status); } } else { // HTTP请求还在继续... }}// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); 3、安全限制 有点看不懂了！ 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400#0 4、CORS 有点看不懂了！ 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400#0 六、Promise 有点看不懂了！ 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544 七、Canvas以后再看吧！ 参考教程：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022423592576 目前告一段落了！以后有机会再进行 JavaScript 的学习！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://www.itnxd.cn/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.itnxd.cn/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://www.itnxd.cn/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"https://www.itnxd.cn/tags/DOM/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之面向对象编程","slug":"JavaScript教程系列之面向对象编程","date":"2020-02-17T14:17:37.000Z","updated":"2020-05-19T02:08:32.173Z","comments":true,"path":"posts/55519.html","link":"","permalink":"https://www.itnxd.cn/posts/55519.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 有人这样说：这种高大上的东西都是造火箭才用得上的，平时干的都是拧螺丝的活当然用不上咯！ 但还是得知道并掌握。。。。！ class继承需要掌握，原型继承知道就好了…… 一、面向对象编程概述 JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。 1、通过__proto__ 来指向Student，并且继承Student的所有属性！ JavaScript它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。 12345678910111213141516var Student = { name: 'Robot', height: 1.2, run: function () { console.log(this.name + ' is running...'); }};var xiaoming = { name: '小明'};xiaoming.__proto__ = Student;xiaoming.name; // '小明'xiaoming.run(); // 小明 is running... 2、指向（原型）是可以改变的！ 在指向一个类后，可以直接修改他的指向（原型）！ 123456789101112var Bird = { fly: function () { console.log(this.name + ' is flying...'); }};var xiaoming = { name: '小明'};xiaoming.__proto__ = Bird;xiaoming.fly(); // 小明 is flying... 注意：不建议使用`__proto__`来改变指向 3、要使用Object.create()方法 该方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有 为了方便，可以创建一个函数来接收姓名参数，在函数内部做一下赋值的过程即可！ 12345678910111213141516171819202122// 原型对象:var Student = { name: 'Robot', height: 1.2, run: function () { console.log(this.name + ' is running...'); }};function createStudent(name) { // 基于Student原型创建一个新对象: var s = Object.create(Student); // 初始化新对象: s.name = name; return s;}//直接创建是没有属性“小明”的：let xiaoming = Object.create(Student);//通过新建函数，传入名字，即可：var xiaoming = createStudent('小明');xiaoming.run(); // 小明 is running...xiaoming.__proto__ === Student; // true 二、关于proto和prototype prototype是函数的一个属性（每个函数都有一个prototype属性），这个属性是一个指针，指向一个对象。它是显示修改对象的原型的属性。 __proto__是一个对象拥有的内置属性（请注意：prototype是函数的内置属性，__proto__是对象的内置属性），是JS内部使用寻找原型链的属性。 区别参考链接：https://www.cnblogs.com/yangjinjin/archive/2013/02/01/2889103.html 三、创建对象 为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写. 这样，一些语法检查工具如jslint将可以帮你检测到漏写的new。 本节参考：https://www.liaoxuefeng.com/wiki/1022910821149312/1023022043494624 1、原型链 当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。 数组原型链 Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。 12var arr = [1, 2, 3];arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null 函数原型链 Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。 1234function foo() { return 0;}foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null 2、构造函数 用new来调用函数，返回一个对象！ 函数内部的this指向新创建的对象！并默认返回this!不需要写return了！ 必须写new，不写new，函数返回的是undefined！ 12345678910function Student(name) { this.name = name; this.hello = function () { alert('Hello, ' + this.name + '!'); }}var xiaoming = new Student('小明');xiaoming.name; // '小明'xiaoming.hello(); // Hello, 小明! 此时小明的原型链： 1xiaoming ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null 3、constructor 用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身： 123456xiaoming.constructor === Student.prototype.constructor; // trueStudent.prototype.constructor === Student; // trueObject.getPrototypeOf(xiaoming) === Student.prototype; // truexiaoming instanceof Student; // true 4、公用函数（共享方法） 如果我们通过new Student()创建了很多对象，这些对象的hello函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。 通过够着函数.prototype.函数名来创建公用函数，节省内存！ 1234567function Student(name) { this.name = name;}Student.prototype.hello = function () { alert('Hello, ' + this.name + '!');}; 5、解决忘写new的方法 我们还可以编写一个createStudent()函数，在内部封装所有的new操作。 || ：用或符号来实现默认值，毕竟是就近原则的！ 将new封装后，即可不用写new了，以防忘写！ 123456789101112function Student(props) { this.name = props.name || '匿名'; // 默认值为'匿名' this.grade = props.grade || 1; // 默认值为1}Student.prototype.hello = function () { alert('Hello, ' + this.name + '!');};function createStudent(props) { return new Student(props || {})} 不传参都行 也可以这样定义 这样传参传的是一个对象，是不需要顺序的！ 12345var xiaoming = createStudent({ name: '小明'});xiaoming.grade; // 1 四、原型继承 本节参考：https://www.liaoxuefeng.com/wiki/1022910821149312/1023021997355072 原型链： 1new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null 我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： F空函数起到一个桥接的作用！ 123456789101112131415161718192021222324252627282930313233343536373839// PrimaryStudent构造函数:function PrimaryStudent(props) { Student.call(this, props); this.grade = props.grade || 1;}// 空函数F:function F() {}// 把F的原型指向Student.prototype:F.prototype = Student.prototype;// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:PrimaryStudent.prototype = new F();// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:PrimaryStudent.prototype.constructor = PrimaryStudent;// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：PrimaryStudent.prototype.getGrade = function () { return this.grade;};// 创建xiaoming:var xiaoming = new PrimaryStudent({ name: '小明', grade: 2});xiaoming.name; // '小明'xiaoming.grade; // 2// 验证原型:xiaoming.__proto__ === PrimaryStudent.prototype; // truexiaoming.__proto__.__proto__ === Student.prototype; // true// 验证继承关系:xiaoming instanceof PrimaryStudent; // truexiaoming instanceof Student; // true 关于call()函数：https://www.runoob.com/w3cnote/js-call-apply-bind.html 是用来重定义 this 这个对象的! 五、class继承 在上面的章节中我们看到了JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。 有没有更简单的写法？有！ 新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。 用class来写，上面章节中的继承和对象编程就简单多了！ constructor很明显是够着函数！ 注意没有function关键字！ 1234567891011class Student { constructor(name) { this.name = name; } hello() { alert('Hello, ' + this.name + '!'); }}var xiaoming = new Student('小明');xiaoming.hello(); class继承 用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现： extends表示原型链对象来自Student！ 使用super()函数来调用父类的（即Student）的构造方法！ class继承和原型继承没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。 12345678910class PrimaryStudent extends Student { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert('I am at grade ' + this.grade); }} 本章节到此结束，敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://www.itnxd.cn/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.itnxd.cn/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"https://www.itnxd.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之标准对象","slug":"JavaScript教程系列之标准对象","date":"2020-02-17T07:31:19.000Z","updated":"2020-05-18T13:54:01.940Z","comments":true,"path":"posts/15769.html","link":"","permalink":"https://www.itnxd.cn/posts/15769.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 在 JavaScript 的世界里，一切皆对象！ 一、包装对象1、用typeof来识别身份 number、string、boolean、function和undefined有别于其他类型。特别注意null的类型是object，Array的类型也是object，如果我们用typeof将无法区分出null、Array和通常意义上的object——{}。 123456789typeof 123; // 'number'typeof NaN; // 'number'typeof 'str'; // 'string'typeof true; // 'boolean'typeof undefined; // 'undefined'typeof Math.abs; // 'function'typeof null; // 'object'typeof []; // 'object'typeof {}; // 'object' 2、通过new来包装对象 number、boolean和string都有包装对象。没错，在JavaScript中，字符串也区分string类型和它的包装类型。包装对象用new创建： 经过new包装的元素类型已经变为了对象！ 注意：闲的蛋疼也不要使用包装对象！尤其是针对`string`类型！！！ 123var n = new Number(123); // 123,生成了新的包装类型var b = new Boolean(true); // true,生成了新的包装类型var s = new String('str'); // 'str',生成了新的包装类型 12345678typeof new Number(123); // 'object'new Number(123) === 123; // falsetypeof new Boolean(true); // 'object'new Boolean(true) === true; // falsetypeof new String('str'); // 'object'new String('str') === 'str'; // false 注意：创建包装对象后的与原始值不同！！！ 3、不使用new的结果 Number()、Boolean和String()被当做普通函数，把任何类型的数据转换为number、boolean和string类型（注意不是其包装类型）： 1234567891011var n = Number('123'); // 123，相当于parseInt()或parseFloat()typeof n; // 'number'var b = Boolean('true'); // truetypeof b; // 'boolean'var b2 = Boolean('false'); // true! 'false'字符串转换结果为true！因为它是非空字符串！var b3 = Boolean(''); // falsevar s = String(123.45); // '123.45'typeof s; // 'string' 4、简单总结 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === 'undefined'； toString()方法 除了null 和 undefined ,其他对象都有此方法！ 用来将一个对象转换为字符串类型！ 注意，数字调用toString方法时，会报错，因为程序会认为.不是调用方法而是看成了小数； 所以要使用两个点，或者加一个括号，将他变成整体！ 1234123.toString(); // SyntaxError123..toString(); // '123', 注意是两个点！(123).toString(); // '123' 二、Data对象1、获取对象 通过new Data()来构建一个时间对象 可以获得，年月日，星期，时分秒，毫秒，以及时间戳！ 注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。 1234567891011var now = new Date();now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)now.getFullYear(); // 2015, 年份now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月now.getDate(); // 24, 表示24号now.getDay(); // 3, 表示星期三now.getHours(); // 19, 24小时制now.getMinutes(); // 49, 分钟now.getSeconds(); // 22, 秒now.getMilliseconds(); // 875, 毫秒数now.getTime(); // 1435146562875, 以number形式表示的时间戳 2、创建对象创建指定日期的Data对象:12var d = new Date(2015, 5, 19, 20, 15, 30, 123);d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST) 注意：JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。！ 注意：JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 通过解析ISO 8601格式的字符串 返回值为时间戳！ 使用Date.parse()时传入的字符串使用实际月份01 ~ 12，转换为Date对象后getMonth()获取的月份值为0 ~ 11。 要获取具体内容，得通过传入时间戳创建对象，再调用函数获得具体信息！ 123456var d = Date.parse('2015-06-24T19:49:22.875+08:00');d; // 1435146562875var d = new Date(1435146562875);d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)d.getMonth(); // 5 时间戳 时间戳是个什么东西？时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。假设浏览器所在电脑的时间是准确的，那么世界上无论哪个时区的电脑，它们此刻产生的时间戳数字都是一样的，所以，时间戳可以精确地表示一个时刻，并且与时区无关。 我们只需要传递时间戳，或者把时间戳从数据库里读出来，再让JavaScript自动转换为当地时间就可以了。 获取当前时间戳： 两种方法： Data的now方法 Data的getTime方法 12console.log(Date.now()); console.log(new Date().getTime()); 时区 Date对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间： 只要我们传递的是一个number类型的时间戳，我们就不用关心时区转换。任何浏览器都可以把一个时间戳正确转换为本地时间。 123var d = new Date(1435146562875);d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时 三、RegExp对象 就是正则表达式！ 1、基础匹配 \\d ：一个数字 \\w ：一个数字或一个字母（大小写） \\s ：一个空格 . ：一个任意字符 \\. ：一个小数点 * ：任意个（包括0个） + ：至少一个 ？ ：0个或1个 {n} ：n个 {n, m} ：n 到 m 个 \\- ：一个- \\\\ ：一个\\ 123js. //可以表示js! js1 jsp\\d{3}\\s+\\d{3,8} //即三个数字一个空格然后是三到八个数字eg:010-12345 2、做到更精确的匹配，用方括号表示范围： [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串 [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就JavaScript允许的变量名 [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符） A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 你可能注意到了，js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了。 3、创建正则表达式通过/正则表达式/ 创建通过new RegExp('正则表达式')创建 注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个\\\\实际上是一个\\。 12345var re1 = /ABC\\-001/;var re2 = new RegExp('ABC\\\\-001');re1; // /ABC\\-001/re2; // /ABC\\-001/ 4、正则表达式匹配 使用re.test(待测字符串) 1234var re = /^\\d{3}\\-\\d{3,8}$/;re.test('010-12345'); // truere.test('010-1234x'); // falsere.test('010 12345'); // false 5、切分字符串 使用字符串.split(正则表达式) 来切割： 第一个：按一个空格分隔 第二个：按一个或多个空格分隔 第三个：按按空格和逗号大于等于一个的任意组合分隔 第四个：按空格和逗号和分号的大于等于一个的任意组合分隔 1234'a b c'.split(' '); // ['a', 'b', '', '', 'c']'a b c'.split(/\\s+/); // ['a', 'b', 'c']'a,b, c d'.split(/[\\s\\,]+/); // ['a', 'b', 'c', 'd']'a,b;; c d'.split(/[\\s\\,\\;]+/); // ['a', 'b', 'c', 'd'] 6、字符串分组 将需要分组的部分用()括起来即可 使用：正则表达式.exec(待测字符串) 进行分组 结果返回一个Array，[原字符串， 分组1， 分组2，....] 若无法匹配字符串，则返回null 123var re = /^(\\d{3})-(\\d{3,8})$/;re.exec('010-12345'); // ['010-12345', '010', '12345']re.exec('010 12345'); // null 看一个凶残的例子： 12var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;re.exec('19:05:30'); // ['19:05:30', '19', '05', '30'] | 表示或者，首先看冒号前的，从前往后表示00-09、10-19、20-29…最后一个是1-9，因为有时候01不写01，而写1，所以加一个[0-9]更合适。后面类似。。。 7、贪婪匹配 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： 12var re = /^(\\d+)(0*)$/;re.exec('102300'); // ['102300', '102300', ''] 由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配： ? ：即先满足后方的条件，再考虑前方！ 12var re = /^(\\d+?)(0*)$/;re.exec('102300'); // ['102300', '1023', '00'] 8、全局搜索 JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配： 即在正则表达式的最后加一个g 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引： 全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。 拓展：正则表达式还可以指定i标志，表示忽略大小写；m标志，表示执行多行匹配。 123var r1 = /test/g;// 等价于:var r2 = new RegExp('test', 'g'); 如下： 1234567891011121314151617var s = 'JavaScript, VBScript, JScript and ECMAScript';var re=/[a-zA-Z]+Script/g;// 使用全局匹配:re.exec(s); // ['JavaScript']re.lastIndex; // 10re.exec(s); // ['VBScript']re.lastIndex; // 20re.exec(s); // ['JScript']re.lastIndex; // 29re.exec(s); // ['ECMAScript']re.lastIndex; // 44re.exec(s); // null，直到结束仍没有匹配到 9、小栗子实现验证邮箱的正则表达式： 邮箱组成： 数字字母、下划线、小数点、- ,并且不以-开头 @符号 域名前缀：字母数字以及·-的任意组合，且不能以-开头 . 域名后缀： 1、只有一组字符：eg ：.com, .cn 2、有两组：eg: edu.cn、.com.cn eg：9zdfsk7sdf-hsdf7sdf88dsf.sdfhi.sjiodf99sdf@bbsdkf-88sdf-sgd.com.cn 例子有点夸张，哈哈哈哈哈！ 123let re = /^\\w+\\.?\\w+@\\w+\\.\\w+$/;let re = /^[0-9a-zA-Z]+\\.?[0-9a-zA-Z]+\\@[0-9a-zA-Z]+\\.[0-9a-zA-Z]+$/;let re = /^[a-zA-Z0-9]+([._-]?[a-zA-Z0-9]+)*@([a-zA-Z0-9]+[_-]?[a-zA-Z0-9]+)([_-][a-zA-Z0-9]+)*\\.[a-zA-Z]{2,3}(\\.[a-zA-Z]{2})?$/; 四、JSON对象 JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。 1、JSON的故事 在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。 终于，在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。 2、JSON的数据类型 number：和JavaScript的number完全一致； boolean：就是JavaScript的true或false； string：就是JavaScript的string； null：就是JavaScript的null； array：就是JavaScript的Array表示方式——[]； object：就是JavaScript的{ ... }表示方式。 JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。 为了统一解析，JSON的字符串规定必须用双引号\"\"，Object的键也必须用双引号\"\"。 由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。 3、JSON序列化 通过JSON的stringfy()方法来进行序列化： 123456789101112var xiaoming = { name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\\\"W3C\\\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp']};var s = JSON.stringify(xiaoming);console.log(s);//{\"name\":\"小明\",\"age\":14,\"gender\":true,\"height\":1.65,\"grade\":null,\"middle-school\":\"\\\"W3C\\\" Middle School\",\"skills\":[\"JavaScript\",\"Java\",\"Python\",\"Lisp\"]} 为了好看一点：按照缩进输出： 12345678910111213141516JSON.stringify(xiaoming, null, ' ');//结果：{ \"name\": \"小明\", \"age\": 14, \"gender\": true, \"height\": 1.65, \"grade\": null, \"middle-school\": \"\\\"W3C\\\" Middle School\", \"skills\": [ \"JavaScript\", \"Java\", \"Python\", \"Lisp\" ]} 123456789101112131415161718192021222324252627282930313233343536JSON.stringify(xiaoming, ['name', 'skills'], ' ');//结果：只输出name和skills的结果：{ \"name\": \"小明\", \"skills\": [ \"JavaScript\", \"Java\", \"Python\", \"Lisp\" ]}function convert(key, value) { if (typeof value === 'string') { return value.toUpperCase(); } return value;}JSON.stringify(xiaoming, convert, ' ');//结果：将值为String类型的都大写输出：{ \"name\": \"小明\", \"age\": 14, \"gender\": true, \"height\": 1.65, \"grade\": null, \"middle-school\": \"\\\"W3C\\\" MIDDLE SCHOOL\", \"skills\": [ \"JAVASCRIPT\", \"JAVA\", \"PYTHON\", \"LISP\" ]} 更精确控制： 可以在对象内部定义一个toJSON()的方法： 1234567891011121314151617var xiaoming = { name: '小明', age: 14, gender: true, height: 1.65, grade: null, 'middle-school': '\\\"W3C\\\" Middle School', skills: ['JavaScript', 'Java', 'Python', 'Lisp'], toJSON: function () { return { // 只输出name和age，并且改变了key： 'Name': this.name, 'Age': this.age }; }};JSON.stringify(xiaoming); // '{\"Name\":\"小明\",\"Age\":14}' 4、反序列化 将JSON格式化后的字符串变为JavaScript对象 格式：JSON.parse(格式化的字符串)； 1234JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]JSON.parse('{\"name\":\"小明\",\"age\":14}'); // Object {name: '小明', age: 14}JSON.parse('true'); // trueJSON.parse('123.45'); // 123.45 parse()还可以跟一个函数来控制： 如果属性是name，则在对应的值上加同学两个字： 1234567var obj = JSON.parse('{\"name\":\"小明\",\"age\":14}', function (key, value) { if (key === 'name') { return value + '同学'; } return value;});console.log(JSON.stringify(obj)); // {\"name\": \"小明同学\", \"age\": 14} 本节到此结束，欢迎阅读，敬请期待后续章节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://www.itnxd.cn/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.itnxd.cn/tags/JavaScript/"},{"name":"Data","slug":"Data","permalink":"https://www.itnxd.cn/tags/Data/"},{"name":"RegExp","slug":"RegExp","permalink":"https://www.itnxd.cn/tags/RegExp/"},{"name":"JSON","slug":"JSON","permalink":"https://www.itnxd.cn/tags/JSON/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之函数","slug":"JavaScript教程系列之函数","date":"2020-02-11T08:29:20.000Z","updated":"2020-05-19T02:38:30.339Z","comments":true,"path":"posts/52313.html","link":"","permalink":"https://www.itnxd.cn/posts/52313.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 一、函数的定义与调用定义1234567function abs(x) { if (x &gt;= 0) return x; else return -x;}abs(-9);// 9 JavaScript用function来指出这是一个函数 JavaScript不写return语句自动返回undefined 调用 调用时参数可以有多个，即使定义时参数为1个 12abs(10, 'blablabla'); // 返回10abs(-9, 'haha', 'hehe', null); // 返回9 传入参数比定义还少也可以，返回NaN 此时参数 x 将收到undefined，为了避免参数收到undefined，可以进行一下判断： 这样，若没有参数，或参数传错即可输出一条提示语句。 typedef 来返回值得类型，可以用括号将参数括起来，也可以直接以空格隔开。 throw 语句：语句允许您创建自定义错误。从技术上讲能够抛出异常（抛出错误）。异常可以是 JavaScript 字符串、数字、布尔或对象： 12345678910abs(); // 返回NaN x 收到参数为undefinedfunction abs(x) { if (typeof x !== 'number') throw 'Not a number'; if (x &gt;= 0) return x; else return -x;} arguments JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array： 可以接收传入的所有参数 123456789function foo(x) { console.log('x = ' + x); // 10 for (var i=0; i&lt;arguments.length; i++) { console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30 }}foo(10, 20, 30); 关键字在可以用来解决没有参数，但却传参无法接收参数的问题 1234567891011function abs() { if (arguments.length === 0) return 0; var x = arguments[0]; return x &gt;= 0 ? x : -x;}abs(); // 0abs(10); // 10abs(-9); // 9 解决可选参数问题 此函数可以用来解决可选参数与函数内部实际参数的对应关系，以免造成混乱 调用时是将a给了a，c给了b，所以为了保证对应，用if来判断，并作出修改 123456789101112// foo(a[, b], c)// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：function foo(a, b, c) { if (arguments.length === 2) { // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 } // ...} rest参数 rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。 123456789101112131415161718function foo(a, b, ...rest) { console.log('a = ' + a); console.log('b = ' + b); console.log(rest);}foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] return 语句注意：与C++不同，JavaScript引擎有一个在行末自动添加分号的机制，所以要保证你的句子不要写错。 12345678910111213141516171819function foo1() { return //这就是错的 { name: 'foo' };}function foo2() { return { name: 'foo' };}function foo3() { return { name: 'foo' };}foo3(); // { name: 'foo' } 如上：1是错的，2、3是对的。 二、变量作用域1、变量作用域同其他语言一样，从内到外2、变量提升变量提升介绍 只针对var声明的变量，let没有这些奇怪的用法 1234567891011121314151617function foo(){ var x = 'Hello, ' + y; console.log(x); var y = 'Bob';}foo();//Hello, undefined//上面的写法相当于下面的写法function foo(){ var y; // 提升变量y的申明，此时y为undefined var x = 'Hello, ' + y; console.log(x); y = 'Bob';} 不会报错，原因是变量y在稍后申明了。但是console.log显示Hello, undefined，说明变量y的值为undefined。 这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。 So 用到的变量最好提前声明。。。以防 不必要麻烦。。。 var 声明变量一次声明所有需要的变量。。 1234567function foo() { var x = 1, // x初始化为1 y = x + 1, // y初始化为2 z, i; // z和i为undefined} 全局作用域 不在任何函数内定义的变量就具有全局作用域。 实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性. 1234567891011121314var course = 'Learn JavaScript';alert(course); // 'Learn JavaScript'alert(window.course); // 'Learn JavaScript'function foo() { alert('foo');}foo(); // 直接调用foo()window.foo(); // 通过window.foo()调用alert(\"hhhhh\");window.alert('调用window.alert()'); 名字空间 全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中 著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。 其实就是用一个自定义的对象绑定了。。。 123456789101112// 唯一的全局变量MYAPP:var MYAPP = {};// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () { return 'foo';}; 局部作用域var无法实现for循环的局部范围 12345678function foo() { for (var i=0; i&lt;100; i++) { // } i += 100; // 仍然可以引用变量i} letlet没有这个问题 12345678910function foo() { var sum = 0; for (let i=0; i&lt;100; i++) { sum += i; } // SyntaxError: i += 1;} 所以定义变量建议全部使用let，而不使用var; const 用来定义常量，定义的常量不会被修改值 123const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14 3、解构赋值具体使用 使用解构赋值，直接对多个变量同时赋值 数组结构多个变量要使用[]来解构 数组若是嵌套，要保证对应层次相同 可以省略不想解构的值，逗号隔开即可 对对象解构要使用{} 对象的嵌套也要保证解构的层次对应清楚，属性后面根冒号再写大括号，eg：,address: {city, zip}, 找不到的属性会报错undefined 12345678910111213141516171819202122232425262728293031let [x, y, z] = ['hello', 'JavaScript', 'ES6'];console.log(x,y,z);//hello JavaScript ES6let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素let person ={ name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'};let {name, age, passport} = person;let person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: { city: 'Beijing', street: 'No.1 Road', zipcode: '100001' }};let {name, address: {city, zip}} = person;let {name, single=true} = person; 声明过的变量要想赋值，不能直接使用，要使用圆括号括起来 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来： 1234567// 声明变量:let x, y;// 解构赋值:{x, y} = { name: '小明', x: 100, y: 200};// 语法错误: Uncaught SyntaxError: Unexpected token =//正确写法:({x, y} = { name: '小明', x: 100, y: 200}); 如果想给对象中的属性换个名字，解构的时候可以在变量名后面加一个冒号，加上想要改的别名即可。。 1234567891011121314let person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'};// 把passport属性赋值给变量id:let {name, passport:id} = person;name; // '小明'id; // 'G-12345678'// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined 添加默认值，直接用等号赋值即可， 可以解决找不到属性，返回undefined的错误 1234567891011let person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678'};// 如果person对象没有single属性，默认赋值为true:let {name, single=true} = person;name; // '小明'single; // true 用处 用来交换两个值！ 12let x=1, y=2;[x, y] = [y, x] 快速获取当前页面域名和路径 1var {hostname:domain, pathname:path} = location; 创建Date对象 123456789101112131415161718function buildDate({year, month, day, hour=0, minute=0, second=0}){ return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);}let t = buildDate({ year: 2020, month: 2, day: 12, hour: 20, minute: 15 });console.log(t);//Wed Feb 12 2020 20:15:00 GMT+0800 (中国标准时间)//或者这样进行解构var time = {};time.year = 2018;time.month = 1;time.day = 1;time.hour = 23;time.minute = 45;time.second = 18;console.log(buildDate(time)); 三、对象内的函数1、定义及使用 调用时加上括号是调用函数 不加括号是调用函数内容，直接打印函数体 合着来写：1234567891011var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; }};console.log(xiaoming.age); // function xiaoming.age()console.log(xiaoming.age()); // 今年调用是25,明年调用就变成26了 浏览器返回的结果： 123456ƒ (){ var y = new Date().getFullYear(); return y - this.birth;}30 分开来写：1234567891011121314function getAge() { var y = new Date().getFullYear(); return y - this.birth;}var xiaoming = { name: '小明', birth: 1990, age: getAge};console.log(xiaoming.age()); // 25, 正常结果console.log(getAge()); // NaN 直接调用函数，由于this的指向就变成了全局对象windows，而windows并没有birth这个属性，所以最后会返回一个NaN; 错误写法12var fn = xiaoming.age; // 先拿到xiaoming的age函数fn(); // NaN 这种写法也是错的，必须直接用对象加点加属性来调用 1xiaoming.age(); 重构函数 第一种，this指向是windows，结果为NaN 第二种：this指向that,that指向xiaoming，结果正确 1234567891011121314151617181920212223242526272829303132333435//第一种，this指向是windowsvar xiaoming = { name: '小明', birth: 1990, age: function () { function getAgeFromBirth() { var y = new Date().getFullYear(); return y - this.birth; } return getAgeFromBirth(); }};xiaoming.age(); // NaN//第二种：this指向that,that指向xiaomingvar xiaoming = { name: '小明', birth: 1990, age: function () { var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() { var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this } return getAgeFromBirth(); }};xiaoming.age(); // 25 2、this 在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。 而直接在函数内部使用this，则指向的是windows全局对象 apply()方法 用来改变this 指向 它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 123456789101112131415function getAge() { var y = new Date().getFullYear(); return y - this.birth;}var xiaoming = { name: '小明', birth: 1990, age: getAge};xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 call()方法 apply()把参数打包成Array再传入； call()把参数按顺序传入。 对于一般函数，通常把this绑定为 null 即可 12Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5 3、装饰器 通过apply()方法我们可以动态改变函数作用 可以实现在原函数不变的情况下增加功能的效果 先保留原函数 再改变原函数，最后通过apply()方法传入this指向和参数，return回去原函数的作用 达到增加功能的效果 arguments即当前函数接收到的所有参数，再次传给保留的旧函数，进行作用 而apply最大的作用就是可以将改造函数传入的一堆参数再原封不动的传给旧函数！！！1234567891011121314var count = 0;var oldParseInt = parseInt; // 保存原函数window.parseInt = function () { count += 1; return oldParseInt.apply(null, arguments); // 调用原函数};// 测试:parseInt('10');parseInt('20');parseInt('30');console.log('count = ' + count); // 3 四、高阶函数 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 简单的例子： 123456function add(x, y, f){ return f(x) + f(y);}let x = add(-5, 8, Math.abs);console.log(x);//13 1、map()函数 此方法是专门针对数组的 由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果 map参数为函数名 1234567891011function pow(x){ return x * x;}var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]console.log(results);var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9'] 2、reduce()函数 Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上 这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： 1[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) 就是一个迭代过程！ 利用reduce求乘积12345function product(arr){ return arr.reduce((x,y)=&gt;x*y);}console.log(product([1,5,2,7,9]));//630 利用reduce 将数字数组转化为整数12345let arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) { return x * 10 + y;}); // 13579 将字符串变为数字1234567891011121314151617181920212223function stringToint(s) { let ss = []; for(let i = 0; i &lt; s.length; i++) ss.push(s[i]); let arr = ss.map(x =&gt; x -= '0'); let res = arr.reduce((x,y) =&gt; x * 10 + y); return res; //或者合并一下操作，这样也可以： return ss.map((x) =&gt; x -= '0').reduce((x, y) =&gt; (x*10+y)); //用split函数来得到一个副本为单个字符的数组 return s.split('').map(x =&gt; x * 1).reduce((x, y) =&gt; x * 10 + y) //或者直接使用下面的语句： return s* 1; //使用自带的parseInt函数 r = ss.map(function(x){ return parseInt(x)});}stringToint('43859843');//43859843 注意： return s* 1 ：隐式类型转换 ，会将操作数转换成数字类型，如运算符-, *, /,% 首字母大写，其他小写 输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']。 12345678910111213141516171819202122232425262728293031323334353637function normalize(arr) { let arrs = []; arrs = arr.map(function(x){ let s = x[0].toUpperCase(); for(let i = 1; i &lt; x.length; i++) s += x[i].toLowerCase(); return s; }); return arrs; //或者这样 return arr.map((x) =&gt; { let a = ''; for (let v of x) { if (!a) a += v.toUpperCase(); else a += v.toLowerCase(); } return a; })； //或者使用split函数分割再使用reduce进行拼接 return arr.map(function(s){ var c=s.toLowerCase().split(''); c[0]=c[0].toUpperCase(); return c.reduce((x,y)=&gt;x+y); });} //或者这样，比较精巧，使用字符串的substr函数 return arr.map(function(arr){ return arr[0].toUpperCase()+arr.substr(1).toLowerCase(); }); //或者这样，使用数组的slice函数 return arr.map(s =&gt; s[0].toUpperCase() + s.slice(1).toLowerCase());console.log(normalize(['adam', 'LISA', 'barT'])); 3、filter()函数 filter同样是作用于数组Array的函数！ filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。 简而言之：就是一个按条件过滤函数； 返回新数组！ 过滤掉偶数： 12345let arr = [1, 2, 4, 5, 6, 9, 10, 15];let r = arr.filter(function (x){ return x % 2 !== 0;});r; // [1, 5, 9, 15] 过滤掉空字符串： 字符串的trim函数用来删除字符串的头尾空格。 12345var arr = ['A', '', 'B', null, undefined, 'C', ' '];var r = arr.filter(function (s) { return s &amp;&amp; s.trim();});r; // ['A', 'B', 'C'] filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身： 1234567var arr = ['A', 'B', 'C'];var r = arr.filter(function (element, index, self) { console.log(element); // 依次打印'A', 'B', 'C' console.log(index); // 依次打印0, 1, 2 console.log(self); // ['A', 'B', 'C'] return true;}); 过滤掉相同的元素 过滤掉数组找到的当前元素下标和当前元素的真正下标不相等的 indexOf函数总是返回数组中找到的第一个匹配的下标，所以后面有相同字符串不同下标的时候就会自动过滤。 12345678910var r, arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry']; r = arr.filter(function (element, index, self) { return self.indexOf(element) === index;});console.log(r); 4、sort()函数 通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1 sort函数会直接修改当前Array，注意！ sort 返回修改后的数组！ 12345678// 看上去正常的结果:['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft'];// apple排在了最后:['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft\", 'apple']// 无法理解的结果:[10, 20, 1, 2].sort(); // [1, 10, 2, 20] 第一个正常 第二个不正常，都是按照ASKII码排序的 第三个不正常，虽然是数字，但Array的sort()方法默认把所有元素先转换为String再排序 作为高阶函数sort自然可以穿函数参数： 与其他语言不同，比较函数得写全，不能只写一个if 返回的1可以理解为需要交换 返回-1表示不需要交换 返回0表示。。。 数字比价 12345678910111213arr.sort(function (x, y) { if (x &lt; y) return -1; if (x &gt; y) return 1; return 0;});console.log(arr); // [1, 2, 10, 20]arr.sort(function (x, y) { if (x &lt; y) return 1; if (x &gt; y) return -1; return 0;});console.log(arr); // [20,10,2,1] 字符串比较 既有大写又有小写，则统一一下进行比较 123456789101112var arr = ['Google', 'apple', 'Microsoft'];arr.sort(function (s1, s2) { x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) { return -1; } if (x1 &gt; x2) { return 1; } return 0;}); // ['apple', 'Google', 'Microsoft'] 5、every()函数 every()方法可以判断数组的所有元素是否满足测试条件。 返回值为 true 或 false 123456789var arr = ['Apple', 'pear', 'orange'];console.log(arr.every(function (s) { return s.length &gt; 0;})); // true, 因为每个元素都满足s.length&gt;0console.log(arr.every(function (s) { return s.toLowerCase() === s;})); // false, 因为不是每个元素都全部是小写 6、find()函数 find()方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined： 返回元素 123456789var arr = ['Apple', 'pear', 'orange'];console.log(arr.find(function (s) { return s.toLowerCase() === s;})); // 'pear', 因为pear全部是小写console.log(arr.find(function (s) { return s.toUpperCase() === s;})); // undefined, 因为没有全部是大写的元素 7、findIndex()函数 findIndex()和find()类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，如果没有找到，返回-1： 返回索引 123456789var arr = ['Apple', 'pear', 'orange'];console.log(arr.findIndex(function (s) { return s.toLowerCase() === s;})); // 1, 因为'pear'的索引是1console.log(arr.findIndex(function (s) { return s.toUpperCase() === s;})); // -1 8、forEach forEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。forEach()常用于遍历数组，因此，传入的函数不需要返回值： 12var arr = ['Apple', 'pear', 'orange'];arr.forEach(console.log); // 依次打印每个元素 五、闭包1、函数作为返回值12345678function sum(arr) { return arr.reduce(function (x, y) { return x + y; });}sum([1, 2, 3, 4, 5]); // 15 2、延迟执行函数 对上一个进行包装，写成一个函数套函数即可实现 f1()和f2()的调用结果互不影响，返回的都是一个新的独立的函数！ 1234567891011121314151617function lazy_sum(arr) { var sum = function () { return arr.reduce(function (x, y) { return x + y; }); } return sum;}var f = lazy_sum([1, 2, 3, 4, 5]); // f接收sum用来求和的函数f(); // 15 调用f指向的sum函数var f1 = lazy_sum([1, 2, 3, 4, 5]);var f2 = lazy_sum([1, 2, 3, 4, 5]);f1 === f2; // false 3、闭包 闭包参考，加深理解： JavaScript之闭包 在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。 在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。 函数内部的函数不进行函数的函数调用是不会执行的！ 简而言之：就是为了让外部的人访问不到内部的东西，外部的人看不到内部存在的闭包 最简单的闭包：123456789101112function makeFunc() { var name = \"Mozilla\"; function displayName() { alert(name); } return displayName;}var myFunc = makeFunc();myFunc(); 在一些编程语言中，函数中的局部变量仅在函数的执行期间可用。 一旦 makeFunc() 执行完毕，我们会认为 name 变量将不能被访问。然而，因为代码运行得没问题，所以很显然在 JavaScript 中并不是这样的。 JavaScript这样的原因是：JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成，这个环境包括了这个闭包创建时所能访问的所有局部变量。在上面的例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用，而 displayName 实例仍可访问其词法作用域中的变量，即可以访问到 name 。由此，当 myFunc 被调用时，name 仍可被访问，其值 Mozilla 就被传递到alert中。 函数生产工厂12345678910111213function makeAdder(x) { return function(y) { return x + y; };}var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7 实现参数和5加的函数console.log(add10(2)); // 12 实现参数和10加的函数 闭包问题来源 本例子引用廖雪峰JavaScript之闭包 12345678910111213141516function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push(function () { return i * i; }); } return arr;}var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2]; 在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是： 123f1(); // 16f2(); // 16f3(); // 16 问题解析： 首先我们弄懂上面代码的运行流程： 首先var results = count();之后，函数count已经被调用了，所以一次执行函数内的各段代码：var arr = [];，for (var i=1; i&lt;=3; i++)，这个for循环尤其值得注意。 因为此时循环体执行了push方法，将一个个函数function () { return i * i;}添加到数组内，但是这个函数并没有被调用，还只是一个变量，所以for循环依次执行，直到i = 4。因为闭包，内部函数function () { return i * i;}引用的i就是外部变量，for循环中的i = 4。所以，之后数组arr内的函数的i都是4。 调用函数count后，变量results已经是数组arr了。数组里面元素依次是function f1() { return i * i;} function f2() { return i * i;} function f3() { return i * i;}。但是三个函数都没有被调用，直到var f1 = results[0];，此时function f1() { return i * i;}开始执行，如上段所写，此时的i = 4，所以，返回值就是16了。后面两个调用也是类似情况。 简而言之：就是因为函数内部的函数不会直接执行，会等到调用了外部函数之后，在调用 到内部的函数时，才会执行，也就是说，var results = count();这里还没有调用到内部的函数，直到var f1 = results[0];被调用时，才会调用到内部的函数！ 然而：在count()函数被调用时，i的值就已经变为了4，所以在result()调用时，i 其实是4,； 同理：后面的所有i 就都变为了4！ 解决办法 为了实现我们理想的结果，1，4，9；可以这样做： 注意这里用了一个“创建一个匿名函数并立刻执行”的语法： 123456789101112131415161718192021222324252627282930313233343536373839404142function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push((function (n) { return function () { return n * n; } })(i)); } return arr;}var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9//或者这样：function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push((function (n) { return n * n; })(i)); } return arr;}var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];console.log(f1); // 1console.log(results[1]);//4 “创建一个匿名函数并立刻执行” 最后小括号内引用的参数是用来保存值的，也是为了传递到函数的 x 参数使用的，同时做到了即刻执行的效果！ 注意：函数要用小括号括起来： 123(function (x) { return x * x;})(3); // 9 4、对象作为返回值 此时return 后面跟的是一个大括号，即是一个对象： 12345678910111213141516171819function create_counter(initial) { var x = initial || 0; return { inc: function () { x += 1; return x; } }}var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2c1.inc(); // 3var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12c2.inc(); // 13 解析： 在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。 函数内部的x += 1;实际上他已经改变了函数内部的x，也就是对当前函数来说的局部变量x,由于闭包的出现，导致c2这个函数不会终止，即第一次的调用对后续是有累积效应的！ 而c1和c2则是完全独立的！ 六、箭头函数最简单的例子：二者一样： 一条语句123456x =&gt; x * xfunction (x){ return x * x;} 箭头函数相当于匿名函数(即没有函数名！)，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ ... }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ ... }和return： 多条语句1234x =&gt; { if (x &gt; 0) return x * x; else return - x * x;} 多个参数： 需要用小括号括起来：无参数也需要括起来； 1234567891011121314// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; { var i, sum = x + y; for (i=0; i&lt;rest.length; i++) { sum += rest[i]; } return sum;} 返回对象 本来要用大括号，但是对象也是大括号，所以用小括号来括住了！ 1x =&gt; ({ foo: x }) this 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 箭头函数this的指向永远是作用域内的那个指向！ 而不是普通函数的指向；要想实现真正指向，如以前教程，可以var that = this; 如下：普通函数this指向windows会undefined 12345678910var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = function () { return new Date().getFullYear() - this.birth; // this指向window或undefined }; return fn(); }}; 改用箭头函数后：this始终指向obj对象！ 123456789var obj = { birth: 1990, getAge: function () { var b = this.birth; // 1990 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); }};obj.getAge(); // 25 使用了箭头函数后，无法通过参数来改变this指向 this指向还是obj，而不是此时的year！ 由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略： 123456789var obj = { birth: 1990, getAge: function (year) { var b = this.birth; // 1990 var fn = (y) =&gt; y - this.birth; // this.birth仍是1990 return fn.call({birth:2000}, year); }};obj.getAge(2015); // 25 七、generator 一个generator看上去像一个函数，但可以返回多次。 可以实现多次return的作用 1、普通的 实现斐波那契数列的算法 只有返回一个数组才能得到最终结果 1234567891011121314151617function fib(max) { var t, a = 0, b = 1, arr = [0, 1]; while (arr.length &lt; max) { [a, b] = [b, a + b]; arr.push(b); } return arr;}// 测试:fib(5); // [0, 1, 1, 2, 3]fib(10); // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 2、使用generator generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。 直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。 调用方法一：调用generator对象的next()方法： next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}， 然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。 当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。 12345678910111213141516171819202122function* fib(max) { var t, a = 0, b = 1, n = 0; while (n &lt; max) { yield a; [a, b] = [b, a + b]; n ++; } return;}var f = fib(5);// fib {[[GeneratorStatus]]: \"suspended\", [[GeneratorReceiver]]: Window}f.next(); // {value: 0, done: false}f.next(); // {value: 1, done: false}f.next(); // {value: 1, done: false}f.next(); // {value: 2, done: false}f.next(); // {value: 3, done: false}f.next(); // {value: undefined, done: true} 调用方法二：使用for of语句 此调用不需要我们来判断done,for of 可以自动判断！ 1234567891011121314151617181920function* fib(max) { var t, a = 0, b = 1, n = 0; while (n &lt; max) { yield a; [a, b] = [b, a + b]; n ++; } return;}for (var x of fib(10)){ console.log(x); // 依次输出0, 1, 1, 2, 3, ...} 3、一个小栗子 实现打印下一个id: 12345678910111213function* next_id() { var x=0; while(true) { yield ++x; }}// 测试:let x g = next_id();for (x = 1; x &lt; 100; x ++) console.log(g.next().value);//[1,2,3....99] 函数这节有点难度，也是看了好久，需要经常看！经过艰难险阻，终于完结了！敬请期待下一节！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://www.itnxd.cn/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.itnxd.cn/tags/JavaScript/"},{"name":"函数","slug":"函数","permalink":"https://www.itnxd.cn/tags/%E5%87%BD%E6%95%B0/"}],"author":"Mr.Niu"},{"title":"Java教程系列之快速入门","slug":"Java教程系列之快速入门","date":"2020-02-09T11:50:45.000Z","updated":"2020-05-18T13:54:01.940Z","comments":true,"path":"posts/12025.html","link":"","permalink":"https://www.itnxd.cn/posts/12025.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 为什么Java应用最广泛？从互联网到企业平台，Java是应用最广泛的编程语言，原因在于： Java是基于JVM虚拟机的跨平台语言，一次编写，到处运行； Java程序易于编写，而且有内置垃圾收集，不必考虑内存管理； Java虚拟机拥有工业级的稳定性和高度优化的性能，且经过了长时期的考验； Java拥有最广泛的开源社区支持，各种高质量组件随时可用。 Java语言常年霸占着三大市场： 互联网和企业应用，这是Java EE的长期优势和市场地位； 大数据平台，主要有Hadoop、Spark、Flink等，他们都是Java或Scala（一种运行于JVM的编程语言）开发的； Android移动平台。 这意味着Java拥有最广泛的就业市场。 一、Java 的诞生Java的出现 Java最早是由SUN公司（已被Oracle收购）的詹姆斯·高斯林（高司令，人称Java之父）在上个世纪90年代初开发的一种编程语言，最初被命名为Oak，目标是针对小型家电设备的嵌入式应用，结果市场没啥反响。谁料到互联网的崛起，让Oak重新焕发了生机，于是SUN公司改造了Oak，在1995年以Java的名称正式发布，原因是Oak已经被人注册了，因此SUN注册了Java这个商标。随着互联网的高速发展，Java逐渐成为最重要的网络编程语言。 Java语言类型 Java介于编译型语言和解释型语言之间。 编译型语言如C、C++，代码是直接编译成机器码执行，但是不同的平台（x86、ARM等）CPU的指令集不同，因此，需要编译出每一种平台的对应机器码。 解释型语言如Python、Ruby没有这个问题，可以由解释器直接加载源码然后运行，代价是运行效率太低。 而Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。当然，这是针对Java开发者而言。对于虚拟机，需要为每个平台分别开发。为了保证不同平台、不同公司开发的虚拟机都能正确执行Java字节码，SUN公司制定了一系列的Java虚拟机规范。从实践的角度看，JVM的兼容性做得非常好，低版本的Java字节码完全可以正常运行在高版本的JVM上。 Java三个版本 Java SE：Standard Edition Java EE：Enterprise Edition Java ME：Micro Edition Java SE就是标准版，包含标准的JVM和标准库 而Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。 Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。 Java学习路线 首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用； 如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的； 如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发； 如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。 无论怎么选择，Java SE的核心技术是基础 Java版本 1995年发布，目前已经到了 Java13 名次解释JDK 和 JRE JDK：Java Development Kit JRE：Java Runtime Environment JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。 JSR 和JCP JSR规范：Java Specification Request JCP组织：Java Community Process RI 和 TCK 比如有人提议要搞一个基于Java开发的消息服务器，这个提议很好啊，但是光有提议还不行，得贴出真正能跑的代码，这就是RI。如果有其他人也想开发这样一个消息服务器，如何保证这些消息服务器对开发者来说接口、功能都是相同的？所以还得提供TCK。 通常来说，RI只是一个“能跑”的正确的代码，它不追求速度，所以，如果真正要选择一个Java的消息服务器，一般是没人用RI的，大家都会选择一个有竞争力的商用或开源产品。 RI：Reference Implementation 参考实现 TCK：Technology Compatibility Kit 兼容性测试套件 二、JDK的安装环境变量配置 都在系统变量里设置： 1、新建JAVA_HOME变量，变量值为安装JDK的路径 2、新建CLASSPATH变量，变量值为.;%JAVA_HOME%\\lib。 3、新增CLASSPATH变量，变量值为%JAVA_HOME%\\bin。 找到PATH点击编辑-&gt;新建 测试win + R键打开cmd: 输入java -version，若显示如下，则说明配置正确，否则需要检查路径问题，重新配置。 三、Java编程规范1234567public class Hello { public static void main(String[] args) { System.out.println(\"Hello, world!\"); }} 大小写敏感 Java规定，某个类定义的public static void main(String[] args)是Java程序的固定入口方法，因此，Java程序总是从main方法开始执行。 当我们把代码保存为文件时，文件名必须是Hello.java，而且文件名也要注意大小写，因为要和我们定义的类名Hello完全保持一致。 注意：文件名，必须和类名一致。 运行程序 Java源码本质上是一个文本文件，我们需要先用javac把Hello.java编译成字节码文件Hello.class，然后，用java命令执行这个字节码文件： 因此，可执行文件javac是编译器，而可执行文件java就是虚拟机。 或者直接使用java hello.java 一次性完成两个过程 1234$ javac hello.java //生成hello.class$ java hello$ java hello.java 第一种，javac 后跟文件名.java , java后跟 类名，无后缀。 第二种，直接java 后跟文件名.java 需要注意的是，在实际项目中，单个不依赖第三方库的Java源码是非常罕见的，所以，绝大多数情况下，我们无法直接运行一个Java源码文件，原因是它需要依赖其他的库。 1.Java保存的文件名必须与类名一致； 2.如果文件中只有一个类，文件名必须与类名一致； 3.一个Java文件中只能有一个public类； 4.如果文件中不止一个类，文件名必须与public类名一致； 5.如果文件中不止一个类，而且没有public类，文件名可与任一类名一致。 四、java 程序基础1、类 Java是面向对象的语言，一个程序的基本单位就是class，class是关键字 类名要求： 类名必须以英文字母开头，后接字母，数字和下划线的组合 习惯以大写字母开头 注意： Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。 在class内部，可以定义若干方法（method） 句子以分号结束 2、注释 // ：单行注释 /* */：多行注释 /** */：如果有多行，每行通常以星号开头，可以用来自动创建文档的注释 123456789101112/** * 可以用来自动创建文档的注释 * * @auther Mr.Niu */public class Hello { public static void main(String[] args) { System.out.println(\"Hello, world!\"); }} 3、数据类型 计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从00000000~11111111，换算成十进制是0~255，换算成十六进制是00~ff。 整数类型： byte 一个字节 short 两个字节 int 四个字节 long 八个字节 浮点数类型： float 四个字节 double 八个字节 字符类型： char 两个字节 布尔类型： boolean 两个字节 So…….范围如下： byte：-128 ~ 127 short: -32768 ~ 32767 int: -2147483648 ~ 2147483647 long: -9223372036854775808 ~ 9223372036854775807 注意：long型数据结尾需要加L，否则会报错。不加L默认为int型。 123456789101112public class Main{ public static void main(String[] args) { int i = 2147483647; int i2 = -2147483648; int i3 = 2_000_000_000; // 加下划线更容易识别 int i4 = 0xff0000; // 十六进制表示的16711680 int i5 = 0b1000000000; // 二进制表示的512 long l = 9000000000000000000L; // long型的结尾需要加L }} 注意：float型数据末尾必须加f，否则会报错，不加f默认为double类型。 12345float f1 = 3.14f;float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38double d = 1.79e308;double d2 = -1.79e308;double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324 浮点数可表示的范围非常大，float类型可最大表示3.4x1038，而double类型可最大表示1.79x10308。 注意：boolean类型只有flase 和 true两个值 12345boolean b1 = true;boolean b2 = false;boolean isGreater = 5 &gt; 3; // 计算结果为trueint age = 12;boolean isAdult = age &gt;= 18; // 计算结果为false 注意：char类型既可以表示ASCII码也可以表示Unicode字符 单引号表示字符，双引号表示字符串 1234567891011public class Main{ public static void main(String[] args) { char a = 'A'; char zh = '中'; System.out.println(a); System.out.println(zh); }} 4、常量 定义变量的时候，如果加上final修饰符，这个变量就变成了常量： 1234final double PI = 3.14; // PI是一个常量double r = 5.0;double area = PI * r * r;PI = 300; // compile error! 5、var关键字 编译器会根据赋值语句自动推断出变量类型，省时，省力 123StringBuilder sb = new StringBuilder();var sb = new StringBuilder(); 6、数据运算除0编译可以通过，但运行会报错可以使用+=等等可以使用++、-- 运算符移位运算 带符号位移动： 左移 &lt;&lt; ：相当于乘2 右移 &gt;&gt; ：相当于除2 不带符号位移动： 右移 &gt;&gt;&gt; ：相当于除2 12345int n = 7; // 00000000 00000000 00000000 00000111 = 7int a = n &lt;&lt; 1; // 00000000 00000000 00000000 00001110 = 14int b = n &lt;&lt; 2; // 00000000 00000000 00000000 00011100 = 28int c = n &gt;&gt; 1; // 00000000 00000000 00000000 00000011 = 3int d = n &gt;&gt; 2; // 00000000 00000000 00000000 00000001 = 1 注意：对一个负数进行右移，最高位的1不动，结果仍然是一个负数： 12345int n = -536870912;int a = n &gt;&gt; 1; // 11110000 00000000 00000000 00000000 = -268435456int b = n &gt;&gt; 2; // 10111000 00000000 00000000 00000000 = -134217728int c = n &gt;&gt; 28; // 11111111 11111111 11111111 11111110 = -2int d = n &gt;&gt; 29; // 11111111 11111111 11111111 11111111 = -1 注意：使用不带符号右移，负数右移，会将最高位符号位也右移，变为正数 12345int n = -536870912;int a = n &gt;&gt;&gt; 1; // 01110000 00000000 00000000 00000000 = 1879048192int b = n &gt;&gt;&gt; 2; // 00111000 00000000 00000000 00000000 = 939524096int c = n &gt;&gt;&gt; 29; // 00000000 00000000 00000000 00000111 = 7int d = n &gt;&gt;&gt; 31; // 00000000 00000000 00000000 00000001 = 1 注意：对byte和short类型进行移位时，会首先转换为int再进行位移。 7、位运算 位运算是按位进行与、或、非和异或的运算。 &amp;：按位与 | ：按位或 ~ ：按位非 ^ ： 按位异或 :不同为1，相同为0 8、运算符优先级从高到低： () ! ~ ++ -- * / % + - &lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | += -= *= /= 9、类型提升和强转类型转换略，太简单了！ 10、浮点数 由于计算机二进制表示，判断浮点数相等仍得通过阀值和绝对值函数来实现。 12345678// 比较x和y是否相等，先计算其差的绝对值:double r = Math.abs(x - y);// 再判断绝对值是否足够小:if (r &lt; 0.00001) { // 可以认为相等} else { // 不相等} 11、溢出 NaN表示Not a Number Infinity表示无穷大 -Infinity表示负无穷大 123double d1 = 0.0 / 0; // NaNdouble d2 = 1.0 / 0; // Infinitydouble d3 = -1.0 / 0; // -Infinity 12、boolean运算 比较运算符：&gt;，&gt;=，&lt;，&lt;=，==，!= 与运算 &amp;&amp; 或运算 || 非运算 ! 123456boolean isGreater = 5 &gt; 3; // trueint age = 12;boolean isZero = age == 0; // falseboolean isNonZero = !isZero; // trueboolean isAdult = age &gt;= 18; // falseboolean isTeenager = age &gt;6 &amp;&amp; age &lt;18; // true 注意：若boolean运算可以判断最终结果为真或假，则不会进行后续无意义计算，即便后面有除0运算 1boolean result = true || (5 / 0 &gt; 0); // true 13、三目运算符？： …不介绍了。 14、字符和字符串char char类型既可以表示ASCII码也可以表示Unicode字符 用转义字符\\u+Unicode编码来表示一个字符： 123// 注意是十六进制:char c3 = '\\u0041'; // 'A'，因为十六进制0041 = 十进制65char c4 = '\\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013 String 用双引号表示 用\\表示转义 字符串连接 用+号连接 12345678910public class Main{ public static void main(String[] args) { String s1 = \"Hello\"; String s2 = \"world\"; String s = s1 + \" \" + s2 + \"!\"; System.out.println(s); }} 多行字符串 笨办法： 123String s = \"first line \\n\" + \"second line \\n\" + \"end\"; 新办法： 12345678910111213141516String s = \"\"\" SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC \"\"\"String s = \"\"\" SELECT * FROM users WHERE id &gt; 100 ORDER BY name DESC\"\"\";String s = \"\"\" SELECT * FROMusersWHERE id &gt; 100ORDER BY name DESC\"\"\"; 注意：上面表示五行还有一个换行符\\n 注意：下面表示四行，没有换行符 注意：最终格式总是以最靠左边的为基准。 第三种可以避免空格问题出现。。 若要使用cmd： 1$ javac --source 13 --enable-preview Main.java String的不可变特性12345678910public class Main { public static void main(String[] args) { String s = \"hello\"; System.out.println(s); // 显示 hello s = \"world\"; System.out.println(s); // 显示 world }} 原来的字符串\"hello\"还在，只是我们无法通过变量s访问它而已。因此，字符串的不可变是指字符串内容不可变。 相当于指针指向换了， 空值null1234String s1 = null; // s1是nullString s2; // 没有赋初值值，s2也是nullString s3 = s1; // s3也是nullString s4 = \"\"; // s4指向空字符串，不是null 15、数组类型数组定义 定义一个数组类型的变量，使用数组类型“类型[]”，例如，int[]。和单个基本类型变量不同，数组变量初始化必须使用new int[5]表示创建一个可容纳5个int元素的数组 Java的数组有几个特点： 数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false； 数组一旦创建后，大小就不可改变。 可以使用.length来获取数组长度 第一种12345678public class Main { public static void main(String[] args) { int[] ns = new int[5]; System.out.println(ns.length); // 5 }} 第二种可以用{}来初始化，自动推算数组大小： 12345678910public class Main { public static void main(String[] args) { // 5位同学的成绩: int[] ns = new int[] { 68, 79, 91, 85, 62 }; System.out.println(ns.length); // 编译器自动推算数组大小为5 }} 第三种：简略版1int[] ns = { 68, 79, 91, 85, 62 }; 数组大小不可变如下： 123456789101112public class Main { public static void main(String[] args) { // 5位同学的成绩: int[] ns; ns = new int[] { 68, 79, 91, 85, 62 }; System.out.println(ns.length); // 5 ns = new int[] { 1, 2, 3 }; System.out.println(ns.length); // 3 }} 看似大小变了，实际是数组指向变了，由原来指向五个数据的地方，指向了三个数据地方，而原来五个数组没有指向他的，所以无法访问了。 原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。 String类型数组，一样，改变一个值，值并没有消失，只是指向改变了，原来的值无法通过下标为1的数组来访问。 12345678910public class Main{ public static void main(String[] args) { String[] names = {\"ABC\", \"XYZ\", \"zoo\"}; String s = names[1]; names[1] = \"cat\"; System.out.println(s); // XYZ }} 五、流程控制1、输出System.out.println() println是print line的缩写，表示输出并换行 System.out.print() print：不换行 1234567891011public class Main { public static void main(String[] args) { System.out.print(\"A,\"); System.out.print(\"B,\"); System.out.print(\"C.\"); System.out.println();//可以用来换行 System.out.println(\"END\"); }} System.out.printf() 格式化输出，和C语言printf类似 可以%08.3f来控制小数与宽度与补位数 占位符： %d 格式化输出整数 %x 格式化输出十六进制整数 %f 格式化输出浮点数 %e 格式化输出科学计数法表示的浮点数 %s 格式化字符串 注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身 12345678910public class Main{ public static void main(String[] args) { int n = 12345000; System.out.printf(\"n=%d, hex=%08x\\n\", n, n); double d = 239.3839; System.out.printf(\"%09.2f\", d);//000239.38 }} 2、输入 首先，我们通过import语句导入java.util.Scanner，import是导入某个类的语句，必须放到Java源代码的开头 然后，创建Scanner对象并传入System.in。System.out代表标准输出流，而System.in代表标准输入流。直接使用System.in读取用户输入虽然是可以的，但需要更复杂的代码，而通过Scanner就可以简化后续的代码。 有了Scanner对象后，要读取用户输入的字符串，使用scanner.nextLine()，要读取用户输入的整数，使用scanner.nextInt()。Scanner会自动转换数据类型，因此不必手动转换。 1234567891011121314import java.util.Scanner;public class Main{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.out.print(\"Input your name: \"); // 打印提示 String name = scanner.nextLine(); // 读取一行输入并获取字符串 System.out.print(\"Input your age: \"); // 打印提示 int age = scanner.nextInt(); // 读取一行输入并获取整数 System.out.printf(\"Hi, %s, you are %d\\n\", name, age); // 格式化输出 }} 3、if语句判断引用类型相等 在Java中，判断值类型的变量是否相等，可以使用==运算符。 但是，判断引用类型的变量是否相等，==表示“引用是否相等”，或者说，是否指向同一个对象。 例如，下面的两个String类型，它们的内容是相同的，但是，分别指向不同的对象，用==判断，结果为false： 123456789101112131415public class Main { public static void main(String[] args) { String s1 = \"hello\"; String s2 = \"HELLO\".toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1 == s2) System.out.println(\"s1 == s2\"); else System.out.println(\"s1 != s2\"); }} 要判断引用类型的变量内容是否相等，必须使用equals()方法： 1234567891011121314public class Main { public static void main(String[] args) { String s1 = \"hello\"; String s2 = \"HELLO\".toLowerCase(); System.out.println(s1); System.out.println(s2); if (s1.equals(s2)) System.out.println(\"s1 equals s2\"); else System.out.println(\"s1 not equals s2\"); }} 注意： 执行语句s1.equals(s2)时，如果变量s1为null，会报NullPointerException： 4、switch语句 switch case break default 与C++一样，不介绍 switch表达式 使用switch时，如果遗漏了break，就会造成严重的逻辑错误，而且不易在源代码中发现错误。 从Java 12开始，switch语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要break语句： 注意新语法使用-&gt;，如果有多条语句，需要用{}括起来。不要写break语句，因为新语法只会执行匹配的语句，没有穿透效应。 123456789101112131415161718public class Main{ public static void main(String[] args) { String fruit = \"apple\"; switch (fruit) { case \"apple\" -&gt; System.out.println(\"Selected apple\"); case \"pear\" -&gt; System.out.println(\"Selected pear\"); case \"mango\" -&gt; { System.out.println(\"Selected mango\"); System.out.println(\"Good choice!\"); } default -&gt; System.out.println(\"No fruit selected\"); } }} 1234567891011121314public class Main { public static void main(String[] args) { String fruit = \"apple\"; int opt = switch (fruit) { case \"apple\" -&gt; 1; case \"pear\", \"mango\" -&gt; 2; default -&gt; 0; }; // 注意赋值语句要以;结束 System.out.println(\"opt = \" + opt); }} 5、yield 大多数时候，在switch表达式内部，我们会返回简单的值。 但是，如果需要复杂的语句，我们也可以写很多语句，放到{...}里，然后，用yield返回一个值作为switch语句的返回值： 123456789101112131415161718public class Main{ public static void main(String[] args) { String fruit = \"orange\"; int opt = switch (fruit) { case \"apple\" -&gt; 1; case \"pear\", \"mango\" -&gt; 2; default -&gt; { int code = fruit.hashCode(); yield code; // switch语句返回值 } }; System.out.println(\"opt = \" + opt); }} 运行结果： 注: Main.java 使用预览语言功能。注: 有关详细信息，请使用 -Xlint:preview 重新编译。opt = -1008851410 6、while和do while略。。。与C++一样。。。 7、for循环略。。。与C++一样。。。 for each 和for循环相比，for each循环的变量n不再是计数器，而是直接对应到数组的每个元素。for each循环的写法也更简洁。但是，for each循环无法指定遍历顺序，也无法获取数组的索引。 除了数组外，for each循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的List、Map等。 1234567891011public class Main{ public static void main(String[] args) { int[] ns = { 1, 4, 9, 16, 25 }; for (int n : ns) { System.out.println(n); } }} 8、break 和 continue略。。。与C++一样。。。 六、 数组操作1、for each 遍历参考第五个的for each 2、直接打印数组名 得到的是在JVM中的地址。。。 3、Arrays.toString() 需引入java.util.Arrays库，可以用来遍历数组 1234567891011import java.util.Arrays;public class Main { public static void main(String[] args) { int[] ns = { 1, 1, 2, 3, 5, 8 }; System.out.println(Arrays.toString(ns));//[1, 1, 2, 3, 5, 8] }} 4、Arrays.sort() 排序 对int排序，数组内存存储顺序已经改变 对String类型排序，数组内存存储顺序没有改变，只是指向的改变 123456789101112import java.util.Arrays;public class Main { public static void main(String[] args) { int[] ns = { 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 }; Arrays.sort(ns); System.out.println(Arrays.toString(ns)); }} 5、多维数组多维数组定义：123456789101112131415public class Main { public static void main(String[] args) { int[][] arr = new int[100][100]; int[][] ns = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }; System.out.println(ns.length); // 3 }} 多维数组遍历 普通遍历 使用for each遍历 12345678910111213141516171819202122public class Main { public static void main(String[] args) { int[][] arr = new int[100][100]; int[][] ns = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }; for (int[] t : ns) { for (int n : t) { System.out.print(n); System.out.print(\", \"); } System.out.println(); }} 6、命令行参数 命令行参数类型是String[]数组； 命令行参数由JVM接收用户输入并传给main方法； 我们可以利用接收到的命令行参数，根据不同的参数执行不同的代码。例如，实现一个-version参数，打印程序版本号 123456789101112131415161718public class Main { public static void main(String[] args) { for (String arg : args) { System.out.println(arg); } for (String arg : args) { if (\"-version\".equals(arg)) { System.out.println(\"v 1.0\"); break; } } }} 123$ javac Main.java$ java Main -version # 传一个参数v 1.0 快速入门结束，敬请期待后续内容，to be continued. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"入门","slug":"入门","permalink":"https://www.itnxd.cn/tags/%E5%85%A5%E9%97%A8/"},{"name":"基础","slug":"基础","permalink":"https://www.itnxd.cn/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"https://www.itnxd.cn/tags/Java/"}],"author":"Mr.Niu"},{"title":"JavaScript教程系列之基础语法入门","slug":"JavaScript教程系列之基础语法入门","date":"2020-02-09T05:53:06.000Z","updated":"2020-05-19T02:39:04.128Z","comments":true,"path":"posts/41103.html","link":"","permalink":"https://www.itnxd.cn/posts/41103.html","excerpt":"","text":"首先来首歌曲来放松一下吧！ 在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。 新兴的Node.js把JavaScript引入到了服务器端，JavaScript已经变成了全能型选手。 JavaScript确实很容易上手，但其精髓却不为大多数开发人员所熟知。编写高质量的JavaScript代码更是难上加难。 教程参考：JavaScript全栈教程 一、JavaScript的诞生 在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。 由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在两周之内设计出了JavaScript语言。你没看错，这哥们只用了10天时间。 为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。 二、JavaScript引入 JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到head中 第一种 123&lt;script&gt; alert('hello world!');&lt;/script&gt; 第二种 1&lt;script src=\"/static/js/abc.js\"&gt;&lt;/script&gt; 第三种 默认的type就是JavaScript，所以不必显式地把type指定为JavaScript。 123&lt;script type=\"text/javascript\"&gt; ...&lt;/script&gt; 三、基本语法句子以分号结束'Hello, world'; 也是完整语句注释 //：单行注释 /**/：多行注释 四、数据类型Number类型 123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 字符串类型 使用单引号或双引号引起来的内容 同样，要输出无法输出的字符，仍然可以使用\\来转义 字符串转义：123'I\\'m \\\"OK\\\"!'; //I'm \"OK\"!'\\x41'; // 完全等同于 'A'---\\x表示ASCII编码字符'\\u4e2d\\u6587'; // 完全等同于 '中文' ----\\u表示一个Unicode字符 多行字符串： 由于多行字符串用\\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 “``”表示： 反引号位于数字1的左边 123`这是一个多行字符串`; 模板字符串： 将多个字符串连接起来 使用 + 号 123var name = '小明';var age = 20;var message = '你好, ' + name + ', 你今年' + age + '岁了!'; 使用${变量}来表示，得用反引号引起来 1234var name = '小明';var age = 20;var message = `你好, ${name}, 你今年${age}岁了!`;alert(message); 显示结果都是： 你好, 小明, 你今年20岁了! str.length12var s = 'Hello, world!';s.length; // 13 索引操作略。 对索引赋值，无返回结果，不影响原值，并且字符串类型无法进行修改，是不可变类型 123var s = 'Test';s[0] = 'X';alert(s); // s仍然为'Test' toUpperCase()函数 小写变大写 12var s = 'Hello';s.toUpperCase(); // 返回'HELLO' toLowerCase()函数 大写边小写 123var s = 'Hello';var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lowerlower; // 'hello' indexOf()函数 返回字串出现位置，没有找到返回-1 123var s = 'hello, world';s.indexOf('world'); // 返回7s.indexOf('World'); // 没有找到指定的子串，返回-1 substring()函数 返回索引区间字串 123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' split()函数 split() 方法用于把一个字符串分割成字符串数组。 如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。 split() 方法不改变原始字符串。 *string*.split(*separator*,*limit*) 第一个参数：分隔符；第二个参数：限制返回字符数组的最大长度，不指定则不限制； 1234567891011var str=\"How are you doing today?\";var n=str.split(\" \");//[\"How\", \"are\", \"you\", \"doing\", \"today?\"]var nn = str.split();console.log(nn);//[\"How are you doing today?\"]var nnn = str.split(\"\");console.log(nnn);//[\"H\", \"o\", \"w\", \" \", \"a\", \"r\", \"e\", \" \", \"y\", \"o\", \"u\", \" \", \"d\", \"o\", \"i\", \"n\", \"g\", \" \", \"t\", \"o\", \"d\", \"a\", \"y\", \"?\"]var nnnn = str.split(\" \", 3);console.log(nnnn);//[\"How\", \"are\", \"you\"] 布尔类型 true 和 false 12false == 0; // truefalse === 0; // false 注意： ==：它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果 ===：它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 所以： 尽量不要使用 ==来进行比较，要使用===来比较！ 特例1：NaN 与自己比较也会返回false1NaN === NaN; // false 判断方法：使用isNaN()函数比较 1isNaN(NaN); // true 特例2：浮点数比较 浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值.（二级制无法表示0.1 。。。。。。） 11 / 3 === (1 - 2 / 3); // false 解决方法：使用Math.abs()函数 1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true null 和 undefined JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义. 数组 数组可以包括任意数据类型 中括号创建数组1[1, 2, 3.14, 'Hello', null, true]; 使用Array()函数创建数组：1new Array(1, 2, 3); // 创建了数组[1, 2, 3] 建议直接使用[]来创建数组 与其他语言一样，可以只用下标访问，超出下标范围返回undeifined 1234var arr = [1, 2, 3.14, 'Hello', null, true];arr[0]; // 返回索引为0的元素，即1arr[5]; // 返回索引为5的元素，即truearr[6]; // 索引超出了范围，返回undefined for循环遍历12var arr2 = [1,2,3,'', \"jdsoa\", null];for(var n in arr) console.log(arr[n]); s.length注意点：直接给Array的length赋一个新的值会导致Array大小的变化： 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] 可通过索引修改值 切记不可超出下标范围 indexOf()函数 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置：没有找到返回-1 12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 slice()函数 slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： 注意到slice()的起止参数包括开始索引，不包括结束索引。 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： 1234567var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G'] push()和pop()函数 push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] unshift()和shift()函数 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： 123456789var arr = [1, 2];arr.unshift('A', 'B'); // 返回Array新的长度: 4arr; // ['A', 'B', 1, 2]arr.shift(); // 'A'arr; // ['B', 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // [] sort()函数 sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序： 可自定义参数实现自定义排序 123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] reverse()函数 reverse()把整个Array的元素给掉个个，也就是反转： 123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] splice()函数 splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： 12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] concat()函数 concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： 1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] 实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里： 12var arr = ['A', 'B', 'C'];arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] join()函数 join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 多维数组 如果数组的某个元素又是一个Array，则可以形成多维数组 1var arr = [[1, 2, 3], [400, 500, 600], '-']; 对象 JavaScript的对象是一组由键-值组成的无序集合 JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。 JavaScript对象的键都是字符串类型，值可以是任意数据类型。person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为'Bob'，zipcode属性为null。 属性名若包括特殊字符，需用引号引起来。eg：middle-school 123456789var person = { name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, 'middle-school': 'No.1 Middle School', zipcode: null}; 对象访问方法： 12person.name; // 'Bob'person.zipcode; // null 注意：属性若有-等特殊字符，需要用引号引起来使用，并且访问时只能使用[]来访问，不能通过.访问。否则显示xxxx is not defined for循环遍历对象：用 in 来遍历，变量访问的是属性，通过[]来访问值。 若用.访问的属性不存在会自动创建一个，使用deletek可以进行删除，删除后再次访问会显示undefined。 用 in来判断属性名是否是对象的属性，但是无法判断由于继承得到的属性 使用hasOwnProperty()函数来判断解决继承问题得到的属性 12345678910111213141516171819202122232425var xiaoming = { name : \"小明\", age : 24, height : 9999, score : null, ps : undefined, str : '', hr : NaN, 'n-x' : 89, }; console.log(xiaoming.n-x);//报错，x is not defined console.log(xiaoming['n-x']); console.log(xiaoming['name']); for(var i in xiaoming) console.log(i + ':' + xiaoming[i]); xiaoming.zdf = '增加'; console.log(xiaoming.zdf); delete xiaoming.zdf; console.log(xiaoming.zdf); //undefined console.log('name' in xiaoming); //true console.log('toString' in xiaoming); //true console.log(xiaoming.hasOwnProperty('toString')); //false 变量 变量名是大小写英文、数字、$和_的组合，且不能用数字开头 申明一个变量用var语句 12345var a; // 申明了变量a，此时a的值为undefinedvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 = '007'; // s_007是一个字符串var Answer = true; // Answer是一个布尔值truevar t = null; // t的值是null 在JavaScript中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值， JavaScript是动态语言，弱类型语言 12var a = 123; // a的值是整数123a = 'ABC'; // a变为字符串 console.log()函数 可以在控制台打印需要的东西 无、条件判断 和C++一模一样，不做介绍 六、循环break和continue 和C++一模一样，不做介绍 for循环普通循环for in 循环 可以遍历对象，得到对象的属性名 要过滤掉对象继承的属性，用hasOwnProperty()来实现： 123456789101112var o = { name: 'Jack', age: 20, city: 'Beijing'};for (var key in o) { if (o.hasOwnProperty(key)) { console.log(key); // 'name', 'age', 'city' }} 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引： 请注意，for ... in对Array的循环得到的是String而不是Number。 12345var a = ['A', 'B', 'C'];for (var i in a) { console.log(i); // '0', '1', '2' console.log(a[i]); // 'A', 'B', 'C'} while循环和do while循环 和C++一模一样，不做介绍 七、Map Map是一组键值对的结构，具有极快的查找速度。 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 set()添加，get()查找，delete()删除，has()查询 set是一组key,value,后三个参数都为key 1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined set()添加时，后添加的会覆盖前面添加的。 1234var m = new Map();m.set('Adam', 67);m.set('Adam', 88);m.get('Adam'); // 88 for of 遍历Map对象1for(var j of m) console.log(j[0]+':'+j[1]); 八、Set Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 Set创建12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素自动过滤12var s = new Set([1, 2, 3, 3, '3']);s; // Set {1, 2, 3, \"3\"} add()添加，delete()删除 参数都是key 123456789s.add(4);s; // Set {1, 2, 3, 4}s.add(4);s; // 仍然是 Set {1, 2, 3, 4}var s = new Set([1, 2, 3]);s; // Set {1, 2, 3}s.delete(3);s; // Set {1, 2} for of 遍历Set对象1for(var j of s) console.log(j); 九、iterable 遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for ... of循环来遍历。 for in ：遍历属性名 for of：遍历值 123456789101112131415161718192021222324var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) { // 遍历Array console.log(x);}for (var x of s) { // 遍历Set console.log(x);}for (var x of m) { // 遍历Map console.log(x[0] + '=' + x[1]);}//for in 会将所以属性名都遍历var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x in a) { console.log(x); // '0', '1', '2', 'name'}//for of 只遍历该遍历的var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x of a) { console.log(x); // 'A', 'B', 'C'} 使用forEach()函数 它接收一个函数，每次迭代就自动回调该函数 结构： 参数可以有多个，可以只有一个。 参数1：对应值 参数2：对应键 参数3：对应类型 123456789101112a.forEach(function(参数1,参数2,参数3){ 语句块})；var a = [3,4,5,6,7];var sum = 0;// 第一种a.forEach(function(item){sum += item;});// 第二种a.forEach(item =&gt; sum += item);console.log(sum); 遍历Array123456789101112var a = ['A', 'B', 'C'];//访问值和键a.forEach(function (element, index, array){ console.log(element + ', index = ' + index);});//只访问值a.forEach(function (element) { console.log(element);}); 遍历Set12345var s = new Set(['A', 'B', 'C']);s.forEach(function (element, set) { console.log(element);}); 遍历Map12345var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map){ console.log(value);}); JavaScript教程系列一完美结束，敬请期待后续教程！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://www.itnxd.cn/categories/JavaScript%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.itnxd.cn/tags/JavaScript/"},{"name":"入门","slug":"入门","permalink":"https://www.itnxd.cn/tags/%E5%85%A5%E9%97%A8/"}],"author":"Mr.Niu"},{"title":"自学Git记录及用法总结","slug":"自学Git记录及用法总结","date":"2020-02-06T13:02:25.000Z","updated":"2020-08-01T13:04:36.104Z","comments":true,"path":"posts/50207.html","link":"","permalink":"https://www.itnxd.cn/posts/50207.html","excerpt":"","text":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 本文资料参考： 廖雪峰Git教程 菜鸟Git教程 相关文章推荐： Git五分钟教程 Github简明教程 Git命令文档参考： Git官方文档参考 菜鸟Git文档PDF 国外友人制作Git文档 一、 Git的诞生 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 二、 Git与 Svn 的区别 1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。 2、Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。 3、Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。 4、Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。 5、Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 三、Git的安装及配置直接去Git官网下载对应的安装程序，安装即可. 安装完成配置一下全局用户名和邮箱！ 12$ git config --global user.name \"xxxx\"$ git config --global user.email \"xxxx\" 查看用户名： 12$ git config user.name$ git config user.email 效果如下： 查看配置信息： 1$ git config --list 效果如下： 清空Git Bash的代码记录：输入reset回车即可 1$ reset 四、工作区，暂存区，版本库的区别 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下图来解释三者的关系： 图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。 图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 五、Git 创建版本库git init 命令首先本地新建一个文件夹名为test，然后cd 进去，打开Git Bash，输入初始化命令： 1$ git init 然后你会发现test文件夹多了一个.git目录： 这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了 但是你会发现你看不到，因为它为了防止被人改动，自动隐藏了，可以使用如下命令查看： 1$ ls -ah 效果如下： 会发现路径后面多了一个master，是说当前库是被git托管的，并且是在master的默认分支上。 接下来在本地目录新建一个README.md文档，用文本编辑器打开写上“我的Git自学记录！” 然后用Git命令将其提交到暂存区，再提交到版本库： 12$ git add README.md$ git commit -m \"增加README文件\" 效果如下： git add 与 git commit 命令 git add 命令：将文件从工作区提交到暂存区 后面可以跟文件名，或者多个文件名以空格分隔 也可以跟 .来表示所有文件 git commit 命令：将文件从暂存区提交到版本库 -m 参数：后面写本次提交的备注 -a 参数： 可以跳过备注，但会进入编辑备注模式，按shift键+ZZ可以退出。 git status 命令 用来查看状态：可以让我们时刻掌握仓库当前的状态，即工作区有没有提交到暂存区，暂存区有没有提交到版本库 接下来修改文件内容，增加一行“修改文件test1”。 如下： 然后再git bash 中使用 git status命令查看状态： 如下： 会提示”change not staged for commit”也就是改变还没有提交到版本库 会提示”modifiled : README.md”即，提示这个文件被修改了 会提示”git add &lt;file&gt;“，即使用此命令可以将当前改变提交到暂存区 会提示git restore &lt;file&gt;，即使用此命令可以将当前改变撤销，即本地文件会恢复到修改之前。 接下来使用git add .将文件提交到暂存区，在使用git status 来查看状态： 会发现红字变为了绿字，即当前修改已经提交成功到了暂存区。 会提示git restore --staged &lt;file&gt;来撤销暂存区修改，即暂存区还是原来的样子，而本地文件还是修改后的状态 想要恢复文件未被修改之前，参考上面提到的撤销命令git restore &lt;file&gt; 接下来使用git commit来将修改提交到版本库，然后使用git status查看状态： 会发现git status 的返回状态为”working tree clean”，即工作区很干净。 ls 命令 可以查看当前目录下的文件 -a ：查看隐藏目录 cd到.git目录可以看到HEAD(版本库)和index(暂存区)文件： cd 命令 cd d: ：即切换到d 盘 cd &lt;目录&gt;：即进入那个目录 cd ..：即退到上一目录 touch 命令 创建文件命令，后跟文件名。 mkdir命令 创建目录命令，后跟目录名 pwd 命令 用于显示当前路径 cat 命令 查看文件内容，后跟文件名 vim 或vi 命令 编辑文件命令，后跟文件名 进入编辑状态后： 按 i进入编辑模式 按 Esc键结束编辑 按shift + Z + Z 键退出编辑状态 若没有要打开的文件，则会自动新建一个文件，只有在新建文件中输入了东西，按下shift +Z + Z才能保存，若没有进行修改，文件也不会创建成功，所以也可以用此命令来代替touch命令，效果一样。 git diff命令 git diff：查看工作区和暂存区差异， git diff -cached：查看暂存区和版本库差异， git diff HEAD/master：查看工作区和版本库差异， 若没有差异，则不会有返回信息。 git rm 命令 rm file：删除工作区文件 git rm file：删除暂存区和工作区文件 git rm –cached file：只删除暂存区，保留工作区 git rm -r *：递归删除该目录下所有文件 只在工作区的文件，通过rm删除，无法恢复 提交到暂存区的文件，在工作区进行rm删除后，可以通过git checkout – file来撤销删除。新版命令：git restore file 提交到版本库的文件，在工作区进行rm删除后，也可以通过 git checkout – file 来撤销删除。新版命令：git restore file 提交到版本库的文件，通过git rm 进行删除后，其实已经将删除提交到了暂存区，所以应该用git reset HEAD file将版本库给了暂存区，再用git checkout – file将暂存区拉回工作区，即恢复原状。新版命令：git restore –staged file 再使用：git restore file. 若想彻底删除版本库文件，先git rm ，再commit 即可，若想恢复就得晋城版本回退操作，后序再讲。 提交到暂存区或版本库，用rm删除后恢复操作： 提交到版本库文件，用git rm删除恢复操作： 彻底删除版本库文件： 新版命令变化新版： 12$ git restore --staged file$ git restore file. 旧版： 12$ git reset HEAD file$ git checkout -- file 六、版本回退 版本回退即时空穿梭，只要提交到了版本库，你可以穿梭到任意一次版本库的提交记录。 git log 命令 git log命令显示从最近到最远的提交日志，会显示提交id,作者，邮箱，日期，以及提交备注。 可以使用git log --oneline来显示简略版的历史 可以使用 git log --pretty=oneline来显示在一行 只显示commit id ,以及提交备注 可以使用git log --graph查看拓扑图具体自己操作查看！ 可以使用 git log --reverse --oneline逆向显示记录可以使用git log --author=niuxvdong --oneline -5来指定作者名字更多log 参数命令前往官网查看https://git-scm.com/docs/git-log git用HEAD表示当前版本git reset 命令 回退命令！ git reset --hard HEAD^ 回退上一个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 此时再使用git log会发现未来的记录没了，只能查看当前记录。 So… 往上翻找到commitId再使用git reset --hard HEAD commitIdgit reflog 记录你的命令 可以找到commitId，然后git reset –hard HEAD commitId即可回到未来 七、远程仓库（远程库）创建密钥：1$ ssh-keygen -t rsa -C \"youremail@example.com\" 密钥相当于个人电脑的指纹，托管平台通过密钥来识别身份。 在C盘用户目录下的.ssh文件夹下的id_rsa和id_rsa.pub两个文件，一个私钥，一个公钥。 链接远程库： 将公钥复制到代码托管平台的SSH管理页面，名称随便填即可。 创建仓库： 名字起的像样点，相当于你的项目名。 如图所示，安照提示走： $ git remote add origin git@github.com:niuxvdong/test.git 123- ```bash $ git push -u origin master 以后即可直接git push 了，不需要那么多参数。 删除远程库 以便于连接另一个托管平台 1$ git remote rm origin 同时连接多个托管平台 因为远程库名字都叫origin，所以只需先删除已绑定的远程库，然后进行关联时候，将名字更改即可！ 1234$ git remote rm origin$ git remote add github git@github.com:niuxvdong/test.git$ git remote add gitee git@gitee.com:niuxvdong/test.git$ git remote -v so 现在的仓库名字不叫 origin 了，一个叫 github ，一个叫 gitee。用到origin的命令时，就要对应仓库名字进行修改了。 push 命令修改如下： 12$ git push github master$ git push gitee master 克隆仓库： git clone + ssh链接 git clone + ssh链接 + 路径 git remote命令12$ git remote $ git remote -v 远程库名称和详细信息 有push信息说明你有推送权限： 推送分支1$ git push origin master 推送其他分支即将master改为其他分支名 多人协作参考教程：https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320 git rabase参考教程：https://www.liaoxuefeng.com/wiki/896043488029600/1216289527823648 八、分支管理查看分支1$ git branch 创建分支1$ git branch &lt;name&gt; 切换分支1$ git switch &lt;name&gt; 或 git checkout &lt;name&gt; 创建并切换1$ git switch -c &lt;name&gt; 或 git checkout -b &lt;name&gt; 合并分支1$ git merge &lt;name&gt; 默认合并方式为Fast forward模式 此种合并方法看不到合并历史，对于开发来说不太好 尽量使用 –no-ff 参数来合并使用普通合并 此方法可以看到合并历史记录，便于开发和操作 可以追加上-m参数1$ git merge --no-ff -m \"merge with --no-ff\" 删除分支1$ git branch -d &lt;name&gt; 强制删除分支： 1$ git branch -D &lt;name&gt; 合并冲突解决创建dev分支1$ git branch dev 在master分支将文件修改后，add并且commit123$ vi new.c$ git add .$ git commit -m \"add hhhhhhhhhh\" 切换到dev分支1$ git switch dev 在dev分支将文件修改后，add 并 commit123$ vi new.c$ git add .$ git commit -m \"add ssssssssss\" 切换到master分支1$ git branch dev 合并dev分支1$ git merge dev 出现冲突 vi 编辑冲突文件1$ vi new.c add 并commit12$ git add .git commit -m \"merge confilt\" 删除dev分支1$ git branch -d dev 九、存储现场git stash 命令 用来存储当前工作状态，一遍先去处理遇到的问题或其他bug 12$ git stashSaved working directory and index state WIP on dev: f52c633 add merge git stash list12$ git stash liststash@{0}: WIP on dev: f52c633 add merge 恢复现场一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick命令，把bug提交的修改“复制”到当前分支，避免重复劳动。十、标签管理 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 创建标签1$ git tag v1.0 查看标签1$ git tag 通过commitId打标签 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了 12$ git log --oneline$ git tag v1.1 f52c633 查看具体标签信息 标签不是按时间顺序列出，而是按字母排序的。可以用git show查看标签信息： 12$ git tag$ git show v1.1 创建带有说明的标签 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m \"version 0.1 released\" 1094adb 注意： 标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 删除本地标签 当前本地标签未推送到远程库 1$ git tag -d v0.1 推送标签推送指定标签1$ git push origin v1.0 一次性推送全部尚未推送到远程的本地标签1$ git push origin --tags 删除已推送到远程库的标签先删除本地标签1$ git tag -d v0.9 再删除远程库1$ git push origin :refs/tags/v0.9 另一种删除方式1$ git push origin :&lt;branch&gt;/&lt;tag&gt; 注意冒号 : 必不可少, 后面跟远程库的分支名/标签名 十一、自定义忽略特殊文件参考文档：https://www.liaoxuefeng.com/wiki/896043488029600/900004590234208 给命令配置简短的别名参考文档： https://www.liaoxuefeng.com/wiki/896043488029600/898732837407424 完美结束，历时好久终于写完，感谢观看！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Git","slug":"Git","permalink":"https://www.itnxd.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.itnxd.cn/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://www.itnxd.cn/tags/Github/"}],"author":"Mr.Niu"},{"title":"hexo-theme-matery主题配置详解","slug":"hexo-theme-matery主题配置详解","date":"2020-02-05T04:24:09.000Z","updated":"2020-02-05T04:24:09.000Z","comments":true,"path":"posts/57378.html","link":"","permalink":"https://www.itnxd.cn/posts/57378.html","excerpt":"","text":"hexo-theme-matery 这是一个采用 Material Design 和响应式设计的 Hexo 博客主题。 特性 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 首页轮播文章及每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。 支持 DaoVoice、Tidio 在线聊天功能。 贡献者感谢下面列出的贡献者，没有他们，hexo-theme-matery 不会这么完美。 @HarborZeng @shw2018 @L1cardo @Five-great 下载当你看到这里的时候，应该已经有一个自己的 Hexo 博客了。如果还没有的话，不妨使用 Hexo 和 Markdown 来写博客和文章。 点击 这里 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。 当然你也可以在你的 themes 文件夹下使用 Git clone 命令来下载: 1git clone https://github.com/blinkfox/hexo-theme-matery.git 配置切换主题修改 Hexo 根目录下的 _config.yml 的 theme 的值：theme: hexo-theme-matery _config.yml 文件的其它修改建议: 请修改 _config.yml 的 url 的值为你的网站主 URL（如：http://xxx.github.io）。 建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。 如果你是中文用户，则建议修改 language 的值为 zh-CN。 新建分类 categories 页categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"categories\" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： 123456---title: categoriesdate: 2018-09-30 17:25:30type: \"categories\"layout: \"categories\"--- 新建标签 tags 页tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"tags\" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： 123456---title: tagsdate: 2018-09-30 18:23:38type: \"tags\"layout: \"tags\"--- 新建关于我 about 页about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"about\" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： 123456---title: aboutdate: 2018-09-30 17:25:30type: \"about\"layout: \"about\"--- 新建留言板 contact 页（可选的）contact 页是用来展示留言板信息的页面，如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"contact\" 编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容： 123456---title: contactdate: 2018-09-30 17:25:30type: \"contact\"layout: \"contact\"--- 注：本留言板功能依赖于第三方评论系统，请激活你的评论系统才有效果。并且在主题的 _config.yml 文件中，第 19 至 21 行的“菜单”配置，取消关于留言板的注释即可。 新建友情连接 friends 页（可选的）friends 页是用来展示友情连接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page \"friends\" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： 123456---title: friendsdate: 2018-12-12 21:25:30type: \"friends\"layout: \"friends\"--- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： 12345678910111213141516171819[{ \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\", \"name\": \"码酱\", \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\", \"url\": \"http://luokangyuan.com/\", \"title\": \"前去学习\"}, { \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\", \"name\": \"闪烁之狐\", \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\", \"url\": \"https://blinkfox.github.io/\", \"title\": \"前去学习\"}, { \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\", \"name\": \"ja_rome\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://me.csdn.net/jlh912008548\", \"title\": \"前去学习\"}] 菜单导航配置配置基本菜单导航的名称、路径url和图标icon.1.菜单导航名称可以是中文也可以是英文(如：Index或主页)2.图标icon 可以在Font Awesome 中查找 12345678910111213141516171819menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book 二级菜单配置方法如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作1.在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children)2.在children下创建二级菜单的 名称name,路径url和图标icon.3.注意每个二级菜单模块前要加 -.4.注意缩进格式 12345678910111213141516171819202122232425262728293031323334menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后就可以在文章中对应位置看到你用emoji语法写的表情了。 代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下： 1npm i -S hexo-prism-plugin 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下： 12345678highlight: enable: falseprism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: 搜索本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： 1npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123search: path: search.xml field: post 中文链接转拼音（建议安装）如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。 安装命令如下： 1npm i hexo-permalink-pinyin --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123permalink_pinyin: enable: true separator: '-' # default: '-' 注：除了此插件外，hexo-abbrlink 插件也可以生成非中文的链接。 文章字数统计插件（建议安装）如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。 安装命令如下： 1npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可： 1234567postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数. 添加emoji表情支持（可选的）本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下： 1npm install hexo-filter-github-emojis --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 添加 RSS 订阅支持（可选的）本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下： 1npm install hexo-generator-feed --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456789feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。 添加 DaoVoice 在线聊天功能（可选的）前往 DaoVoice 官网注册并且获取 app_id，并将 app_id 填入主题的 _config.yml 文件中。 添加 Tidio 在线聊天功能（可选的）前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 修改页脚页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。 修改社交链接在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： 12345&lt;% if (theme.socialLink.github) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.github %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-github\"&gt;&lt;/i&gt; &lt;/a&gt;&lt;% } %&gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0。 修改打赏的二维码图片在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 配置音乐播放器（可选的）要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。 首先，在你的博客 source 目录下的 _data 目录（没有的话就新建一个）中新建 musics.json 文件，文件内容如下所示： 12345678910111213141516[{ \"name\": \"五月雨变奏电音\", \"artist\": \"AnimeVibe\", \"url\": \"http://xxx.com/music1.mp3\", \"cover\": \"http://xxx.com/music-cover1.png\"}, { \"name\": \"Take me hand\", \"artist\": \"DAISHI DANCE,Cecile Corbel\", \"url\": \"/medias/music/music2.mp3\", \"cover\": \"/medias/music/cover2.png\"}, { \"name\": \"Shape of You\", \"artist\": \"J.Fla\", \"url\": \"http://xxx.com/music3.mp3\", \"cover\": \"http://xxx.com/music-cover3.png\"}] 注：以上 JSON 中的属性：name、artist、url、cover 分别表示音乐的名称、作者、音乐文件地址、音乐封面。 然后，在主题的 _config.yml 配置文件中激活配置即可： 1234567891011121314# 是否在首页显示音乐.music: enable: true showTitle: false title: 听听音乐 fixed: false # 是否开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'list' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: false # 列表默认折叠 listMaxHeight: # 列表最大高度 文章 Front-matter 介绍Front-matter 选项详解Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。 最简示例1234---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00--- 最全示例1234567891011121314151617---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags: - Typora - Markdown--- 效果截图 自定制修改在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分： 菜单 我的梦想 首页的音乐播放器和视频播放器配置 是否显示推荐文章名称和按钮配置 favicon 和 Logo 个人信息 TOC 目录 文章打赏信息 复制文章内容时追加版权信息 MathJax 文章字数统计、阅读时长 点击页面的’爱心’效果 我的项目 我的技能 我的相册 Gitalk、Gitment、Valine 和 disqus 评论配置 不蒜子统计和谷歌分析（Google Analytics） 默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图 我认为个人博客应该都有自己的风格和特色。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方： 修改主题颜色在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： 123456789101112/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);}@-webkit-keyframes rainbow { /* 动态切换背景颜色. */}@keyframes rainbow { /* 动态切换背景颜色. */} 修改 banner 图和文章特色图你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 &lt;script&gt;&lt;/script&gt; 代码中： 1$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); 在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。 版本记录 v1.2.2 新增了自定义文章 keywords 的功能； 新增静态彩带点击切换的功能和配置； 将文章字数统计、彩带和站点运行时间等功能默认设置为 false； 修改了文章的 description 的 meta 属性优先读取文章的 summary 属性； 修改了文章标题的 HTML 标签，从 div 改成了 h1 标题； 修改了页脚年份显示不正确的问题； 去掉了站点运行时间中多余的 setTimeout 代码； v1.2.1 新增了 TOC 的展开目录层级设置和滚动条功能，防止目录较多的时候目录溢出； 修改了首页的展示方式为以前的模式； 修复首页按钮没有边框的问题； 修复了音乐及吸底模式、视频、推荐文章等不激活时仍然生成首页卡片的问题； 修复 wordCount 插件未安装的问题，修改了部分配置； 修复音乐的 JSON 配置中有单引号的情况页面不显示的音乐的问题 修复标签云在Hexo4.0下链接失效的问题； v1.2.0 新增了 DaoVoice、Tidio 的在线聊天功能； 新增了两级菜单的功能； 新增了打字效果的副标题； 新增了网页内容预加载的功能； 新增了首页 banner 是否每日切换的配置功能； 新增了显示 ICP 备案信息的功能，默认未开启； 新增了百度分析的配置； 新增了代码块的语言显示、一键复制、显示行号等功能； 新增了首页轮播图和推荐文章可自定义配置的功能； 新增了文章页面显示更新日期； 新增了转载规则的图标； 修改了分享的布局和显示方式； 升级更新了部分依赖库的版本； 其他细节修改和优化； v1.1.0 新增了 emoji 的支持； 新增了站点运行时间统计及配置； 新增了留言板的功能,默认未开启； 新增了 Twitter、Facebook、知乎的社交链接； 更新了 Valine 的版本为最新版； 其他小细节的修改； v1.0.4 新增了能为每篇文章都自定义转载规则的功能； 修复上一页、下一页的自定义 summary 不显示的问题； 修复了友情链接显示错位的问题，改为了瀑布流的布局方式； 其他小细节 bug 的修改； v1.0.3 新增了TOC展开、收缩的按钮和相关配置，默认显示此按钮； v1.0.2 升级了 Materialize 框架版本为1.0.0，重构和修改了升级过程中的部分文件或问题； 新增了首页封面的全屏轮播特效，可以将更重要的文章设置到首页轮播中； 修复首页第一个按钮是中文的问题 修复了 iPhone 上点击搜索输入获取焦点的问题； 修复了 iPhone 上输入框获取焦点后页面放大的问题； 修复一些文章或 UI 显示问题； v1.0.1 调整 css、js 的文件请求路径在主题的_config.yml中配置，便于你更快捷的配置自己的 CDN； 新增代码是否折行为可配置，默认为折行； 默认激活 TOC 功能，并新增为某篇文章关闭 TOC 的 Front-matter 配置选项； 修复文章滚动时，高亮的目录选项不准确的问题； IOS下移除搜索框自动获得焦点属性，防止自动获得焦点后导致视图上移； v1.0.0 新增了所有基础功能； document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo主题","slug":"Hexo主题","permalink":"https://www.itnxd.cn/categories/Hexo%E4%B8%BB%E9%A2%98/"}],"tags":[{"name":"matery","slug":"matery","permalink":"https://www.itnxd.cn/tags/matery/"}],"author":"Mr.Niu"},{"title":"Hexo中引入音乐和视频","slug":"Hexo中引入音乐和视频","date":"2020-02-03T13:06:43.000Z","updated":"2020-08-01T13:07:44.601Z","comments":true,"path":"posts/14163.html","link":"","permalink":"https://www.itnxd.cn/posts/14163.html","excerpt":"","text":"1、通过网易云网站引入外链HTML代码: 如图所示，复制当中的HTML代码即可。效果如下: 1&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=100% height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=1346281717&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt; 2、通过B站来引入外链HTML代码: 如图所示，复制当中的HTML代码即可。效果如下: 3、通过Hexo的插件来引用音乐: hexo-tag-aplayer： 点击这里！ hexo-tag-dplayer： 点击这里！ 通过npm来安装两个插件： 1234$ npm install hexo-tag-aplayer --save$ npm install hexo-tag-dplayer --save 第一种：meting后面根歌单id。例如 :https://music.163.com/playlist?id=523845661&amp;userid=46562117 ，这个歌 单的id就是523845661，公司名可以是tencent、netease或是其他公司。 最新版的 hexo-tag-aplayer 已经支持了MetingJS的使用，可以直接解析网络平台的歌曲，在站点配置文件_config.yml中将aplayer的meting属性开启。 123aplayer: meting: true 参考文章：点击这里！ 有关细节及参数，点击这里！ 1{% meting \"523845661\" \"netease\" \"playlist\" \"theme:#FF4081\" \"mode:circulation\" \"mutex:true\" \"listmaxheight:340px\" \"preload:auto\" %} 第二种：写上名字，歌手，链接地址即可。 参考文章：点击这里！ 1{% aplayer \"她的睫毛\" \"周杰伦\" \"https://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3\" \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\" \"autoplay=false\" %} var ap = new APlayer({ element: document.getElementById(\"aplayer-obgTuYrN\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"她的睫毛\", author: \"周杰伦\", url: \"https://home.ustc.edu.cn/~mmmwhy/%d6%dc%bd%dc%c2%d7%20-%20%cb%fd%b5%c4%bd%de%c3%ab.mp3\", pic: \"http://home.ustc.edu.cn/~mmmwhy/jay.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 通过meting 和 aplayer 的引用，无法同时使用，都在的时候，只能加载meting!4、通过Hexo的插件来引用视频:效果如下: 12{% dplayer \"url=http://home.ustc.edu.cn/~mmmwhy/GEM.mp4\" \"pic=http://home.ustc.edu.cn/~mmmwhy/GEM.jpg\" \"loop=yes\" \"theme=#FADFA3\" \"autoplay=false\" \"token=tokendemo\" %} (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"http://home.ustc.edu.cn/~mmmwhy/GEM.mp4\",\"pic\":\"http://home.ustc.edu.cn/~mmmwhy/GEM.jpg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.itnxd.cn/categories/Hexo/"}],"tags":[{"name":"aplayer","slug":"aplayer","permalink":"https://www.itnxd.cn/tags/aplayer/"},{"name":"dplayer","slug":"dplayer","permalink":"https://www.itnxd.cn/tags/dplayer/"}],"author":"Mr.Niu"},{"title":"用法总结之Markdown","slug":"用法总结之Markdown","date":"2020-02-03T11:36:46.000Z","updated":"2021-02-15T05:19:43.624Z","comments":true,"path":"posts/25708.html","link":"","permalink":"https://www.itnxd.cn/posts/25708.html","excerpt":"","text":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。Markdown 编写的文档后缀为 .md, .markdown。 技术支持：Markdown教程|菜鸟教程 注意：Markdown可以使用Html语法及标签 一、编写 Markdown 好用软件1、Typora 优点：可视化很强，写了后回车即可见到真实效果。 2、VS Code 最强大的编辑器，只要安装了对应的插件，即可实现所有的编辑即代码运行调试！ 二、Markdown 语法1、标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 显示效果： 2、段落 Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 12这是段落！ 下一段落... 显示效果： 这是段落！ 下一段落… 3、字体3.1 粗体1**粗体** 显示效果： 粗体 3.2 斜体1*斜体* 显示效果： 斜体 3.3 粗斜体1___粗斜___ 显示效果： 粗斜体 4、分割线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。下面每种写法都可以建立分隔线： 1234567********------------- 显示效果： 5、列表5.1 有序列表 有序列表使用数字并加上 . 号来表示 1231. 第一项2. 第二项3. 第三项 显示效果： 第一项 第二项 第三项 5、2 无序列表 无序列表用 * + -来表示 123456789- 第一项- 第二项- 第三项+ 第一项+ 第二项+ 第三项* 第一项* 第二项* 第三项 显示效果： 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 5.3 列表嵌套1234561. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 显示效果： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 6、区块 Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号. 6.1 普通区块123&gt; 普通区块&gt; hello&gt; 床前明月光 显示效果： 普通区块hello床前明月光 6.2 列表中使用区块1234- 第一层 &gt; 我是Mr.Niu- 第二层 &gt; 你好，世界！ 显示效果： 第一层 我是Mr.Niu 第二层 你好，世界！ 6.3 区块中使用列表123&gt; 第一层 - 我是Mr.Niu - 你好世界！ 显示效果： 第一层 我是Mr.Niu 你好世界！ 6.4 区块嵌套123&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套 显示效果： 最外层 第一层嵌套 第二层嵌套 7、代码7.1 段落内代码1这是`printf()`函数 显示效果： 这是printf()函数！ 7.2 代码块 用 ``` 包裹一段代码，并指定一种语言（也可以不指定）： 123456789101112```c++#include &lt;iostream&gt;using namesapce std;int main(){ cout &lt;&lt; \"hello world!\" &lt;&lt; endl; return 0;}``` 显示效果： 123456789#include &lt;iostream&gt;using namesapce std;int main(){ cout &lt;&lt; \"hello world!\" &lt;&lt; endl; return 0;} 8、链接8.1 普通用法1234567[链接名称](链接地址)[Mr.Niu's Blog](https://niuxvdong.top)或者&lt;https://niuxvdong.top&gt; 显示效果： Mr.Niu’s Blog https://niuxvdong.top 8.2 高级用法：1234567链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 [Baidu][1]这个链接用 niu 作为网址变量 [Blog][niu]然后在文档的结尾为变量赋值（网址） [1]: https://www.baidu.com [niu]: https://niuxvdong.top 显示效果： 链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 Baidu这个链接用 niu 作为网址变量 Blog然后在文档的结尾为变量赋值（网址）： 9、图片 格式如下： 123![alt 属性文本](图片地址)![alt 属性文本](图片地址 \"可选标题\") 1![](https://cdn.jsdelivr.net/gh/niuxvdong/images/img/e%20(2).jpg) 显示效果： 10、表格 Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 格式如下： 1234| 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 显示效果： 表头 表头 单元格 单元格 单元格 单元格 对齐方式： 我们可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 1234|左对齐|右对齐|居中对齐||:----- | -----:|:------:||单元格|单元格|单元格||单元格|单元格|单元格| 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 11、高级技巧（使用HTML）11.1 使用html标签实现键盘按键图标1使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 显示效果： 使用 Ctrl+Alt+Del 重启电脑 11.2 用 \\ 来实现转义 Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： 12**文本加粗** \\*\\* 正常显示星号 \\*\\* 显示效果： 文本加粗** 正常显示星号 ** 可实现的转义字符如下： 123456789101112\\ 反斜线` 反引号* 星号_ 下划线{} 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号 11.3 更多高级用法参考菜鸟教程1234567​```mermaidgraph LRA[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 12345678​```mermaidgraph LRA[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://www.itnxd.cn/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://www.itnxd.cn/tags/Markdown/"}],"author":"Mr.Niu"},{"title":"Hello World","slug":"hello-world","date":"2020-01-31T04:21:55.000Z","updated":"2020-05-19T02:40:28.268Z","comments":true,"path":"posts/16107.html","link":"","permalink":"https://www.itnxd.cn/posts/16107.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.itnxd.cn/categories/Hexo/"}],"tags":[{"name":"Doc","slug":"Doc","permalink":"https://www.itnxd.cn/tags/Doc/"}]}],"categories":[{"name":"JDBC","slug":"JDBC","permalink":"https://www.itnxd.cn/categories/JDBC/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.itnxd.cn/categories/MySQL/"},{"name":"Java教程","slug":"Java教程","permalink":"https://www.itnxd.cn/categories/Java%E6%95%99%E7%A8%8B/"},{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://www.itnxd.cn/categories/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://www.itnxd.cn/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"数据库","slug":"数据库","permalink":"https://www.itnxd.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"JS实战","slug":"JS实战","permalink":"https://www.itnxd.cn/categories/JS%E5%AE%9E%E6%88%98/"},{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/categories/AcWing/"},{"name":"随笔","slug":"随笔","permalink":"https://www.itnxd.cn/categories/%E9%9A%8F%E7%AC%94/"},{"name":"JavaScript教程","slug":"JavaScript教程","permalink":"https://www.itnxd.cn/categories/JavaScript%E6%95%99%E7%A8%8B/"},{"name":"Git","slug":"Git","permalink":"https://www.itnxd.cn/categories/Git/"},{"name":"Hexo主题","slug":"Hexo主题","permalink":"https://www.itnxd.cn/categories/Hexo%E4%B8%BB%E9%A2%98/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.itnxd.cn/categories/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.itnxd.cn/categories/Markdown/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://www.itnxd.cn/tags/JDBC/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.itnxd.cn/tags/MySQL/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.itnxd.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"注解","slug":"注解","permalink":"https://www.itnxd.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"泛型","slug":"泛型","permalink":"https://www.itnxd.cn/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"StringBuilder","slug":"StringBuilder","permalink":"https://www.itnxd.cn/tags/StringBuilder/"},{"name":"StringBuffer","slug":"StringBuffer","permalink":"https://www.itnxd.cn/tags/StringBuffer/"},{"name":"枚举类","slug":"枚举类","permalink":"https://www.itnxd.cn/tags/%E6%9E%9A%E4%B8%BE%E7%B1%BB/"},{"name":"集合","slug":"集合","permalink":"https://www.itnxd.cn/tags/%E9%9B%86%E5%90%88/"},{"name":"面向对象","slug":"面向对象","permalink":"https://www.itnxd.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"DFS","slug":"DFS","permalink":"https://www.itnxd.cn/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E5%BD%92/"},{"name":"Flood Fill","slug":"Flood-Fill","permalink":"https://www.itnxd.cn/tags/Flood-Fill/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"哈希","slug":"哈希","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C/"},{"name":"最短路","slug":"最短路","permalink":"https://www.itnxd.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"BFS","slug":"BFS","permalink":"https://www.itnxd.cn/tags/BFS/"},{"name":"双指针","slug":"双指针","permalink":"https://www.itnxd.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"贪心","slug":"贪心","permalink":"https://www.itnxd.cn/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.itnxd.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"前后缀分解","slug":"前后缀分解","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E5%90%8E%E7%BC%80%E5%88%86%E8%A7%A3/"},{"name":"递推","slug":"递推","permalink":"https://www.itnxd.cn/tags/%E9%80%92%E6%8E%A8/"},{"name":"位运算","slug":"位运算","permalink":"https://www.itnxd.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"滚动数组","slug":"滚动数组","permalink":"https://www.itnxd.cn/tags/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E8%A1%A8/"},{"name":"平衡二叉树","slug":"平衡二叉树","permalink":"https://www.itnxd.cn/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"二叉树搜索树","slug":"二叉树搜索树","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"层序遍历","slug":"层序遍历","permalink":"https://www.itnxd.cn/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"后序遍历","slug":"后序遍历","permalink":"https://www.itnxd.cn/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"中序遍历","slug":"中序遍历","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"前序遍历","slug":"前序遍历","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"name":"Morris-traversal","slug":"Morris-traversal","permalink":"https://www.itnxd.cn/tags/Morris-traversal/"},{"name":"卡特兰数","slug":"卡特兰数","permalink":"https://www.itnxd.cn/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"},{"name":"搜索","slug":"搜索","permalink":"https://www.itnxd.cn/tags/%E6%90%9C%E7%B4%A2/"},{"name":"找规律","slug":"找规律","permalink":"https://www.itnxd.cn/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"},{"name":"格雷编码","slug":"格雷编码","permalink":"https://www.itnxd.cn/tags/%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/"},{"name":"数组","slug":"数组","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%BB%84/"},{"name":"单调栈","slug":"单调栈","permalink":"https://www.itnxd.cn/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"栈","slug":"栈","permalink":"https://www.itnxd.cn/tags/%E6%A0%88/"},{"name":"二分","slug":"二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E5%88%86/"},{"name":"线性扫描","slug":"线性扫描","permalink":"https://www.itnxd.cn/tags/%E7%BA%BF%E6%80%A7%E6%89%AB%E6%8F%8F/"},{"name":"二进制","slug":"二进制","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"哈希表","slug":"哈希表","permalink":"https://www.itnxd.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://www.itnxd.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"三指针","slug":"三指针","permalink":"https://www.itnxd.cn/tags/%E4%B8%89%E6%8C%87%E9%92%88/"},{"name":"二维二分","slug":"二维二分","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E7%BB%B4%E4%BA%8C%E5%88%86/"},{"name":"模拟","slug":"模拟","permalink":"https://www.itnxd.cn/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"取巧算法","slug":"取巧算法","permalink":"https://www.itnxd.cn/tags/%E5%8F%96%E5%B7%A7%E7%AE%97%E6%B3%95/"},{"name":"树的直径","slug":"树的直径","permalink":"https://www.itnxd.cn/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"},{"name":"两次搜索","slug":"两次搜索","permalink":"https://www.itnxd.cn/tags/%E4%B8%A4%E6%AC%A1%E6%90%9C%E7%B4%A2/"},{"name":"树形DP","slug":"树形DP","permalink":"https://www.itnxd.cn/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"链式前向星","slug":"链式前向星","permalink":"https://www.itnxd.cn/tags/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"},{"name":"字符串","slug":"字符串","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"高精度","slug":"高精度","permalink":"https://www.itnxd.cn/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"全排列","slug":"全排列","permalink":"https://www.itnxd.cn/tags/%E5%85%A8%E6%8E%92%E5%88%97/"},{"name":"排序","slug":"排序","permalink":"https://www.itnxd.cn/tags/%E6%8E%92%E5%BA%8F/"},{"name":"快速幂","slug":"快速幂","permalink":"https://www.itnxd.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"旋转","slug":"旋转","permalink":"https://www.itnxd.cn/tags/%E6%97%8B%E8%BD%AC/"},{"name":"字符集","slug":"字符集","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"name":"安全管理","slug":"安全管理","permalink":"https://www.itnxd.cn/tags/%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/"},{"name":"数据库维护","slug":"数据库维护","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/"},{"name":"改善性能","slug":"改善性能","permalink":"https://www.itnxd.cn/tags/%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD/"},{"name":"游标","slug":"游标","permalink":"https://www.itnxd.cn/tags/%E6%B8%B8%E6%A0%87/"},{"name":"触发器","slug":"触发器","permalink":"https://www.itnxd.cn/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/"},{"name":"表","slug":"表","permalink":"https://www.itnxd.cn/tags/%E8%A1%A8/"},{"name":"视图","slug":"视图","permalink":"https://www.itnxd.cn/tags/%E8%A7%86%E5%9B%BE/"},{"name":"存储过程","slug":"存储过程","permalink":"https://www.itnxd.cn/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"},{"name":"数独","slug":"数独","permalink":"https://www.itnxd.cn/tags/%E6%95%B0%E7%8B%AC/"},{"name":"事务","slug":"事务","permalink":"https://www.itnxd.cn/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"隔离","slug":"隔离","permalink":"https://www.itnxd.cn/tags/%E9%9A%94%E7%A6%BB/"},{"name":"倍增","slug":"倍增","permalink":"https://www.itnxd.cn/tags/%E5%80%8D%E5%A2%9E/"},{"name":"KMP","slug":"KMP","permalink":"https://www.itnxd.cn/tags/KMP/"},{"name":"堆","slug":"堆","permalink":"https://www.itnxd.cn/tags/%E5%A0%86/"},{"name":"k路归并","slug":"k路归并","permalink":"https://www.itnxd.cn/tags/k%E8%B7%AF%E5%BD%92%E5%B9%B6/"},{"name":"二路归并","slug":"二路归并","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6/"},{"name":"Dp","slug":"Dp","permalink":"https://www.itnxd.cn/tags/Dp/"},{"name":"回文数","slug":"回文数","permalink":"https://www.itnxd.cn/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"},{"name":"反转","slug":"反转","permalink":"https://www.itnxd.cn/tags/%E5%8F%8D%E8%BD%AC/"},{"name":"枚举","slug":"枚举","permalink":"https://www.itnxd.cn/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"分治","slug":"分治","permalink":"https://www.itnxd.cn/tags/%E5%88%86%E6%B2%BB/"},{"name":"修改","slug":"修改","permalink":"https://www.itnxd.cn/tags/%E4%BF%AE%E6%94%B9/"},{"name":"INSERT","slug":"INSERT","permalink":"https://www.itnxd.cn/tags/INSERT/"},{"name":"UPDATE","slug":"UPDATE","permalink":"https://www.itnxd.cn/tags/UPDATE/"},{"name":"DELETE","slug":"DELETE","permalink":"https://www.itnxd.cn/tags/DELETE/"},{"name":"油猴脚本","slug":"油猴脚本","permalink":"https://www.itnxd.cn/tags/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/"},{"name":"知乎","slug":"知乎","permalink":"https://www.itnxd.cn/tags/%E7%9F%A5%E4%B9%8E/"},{"name":"SELECT","slug":"SELECT","permalink":"https://www.itnxd.cn/tags/SELECT/"},{"name":"查询","slug":"查询","permalink":"https://www.itnxd.cn/tags/%E6%9F%A5%E8%AF%A2/"},{"name":"SQL","slug":"SQL","permalink":"https://www.itnxd.cn/tags/SQL/"},{"name":"加密","slug":"加密","permalink":"https://www.itnxd.cn/tags/%E5%8A%A0%E5%AF%86/"},{"name":"安全","slug":"安全","permalink":"https://www.itnxd.cn/tags/%E5%AE%89%E5%85%A8/"},{"name":"Regex","slug":"Regex","permalink":"https://www.itnxd.cn/tags/Regex/"},{"name":"JUnit","slug":"JUnit","permalink":"https://www.itnxd.cn/tags/JUnit/"},{"name":"Date","slug":"Date","permalink":"https://www.itnxd.cn/tags/Date/"},{"name":"Time","slug":"Time","permalink":"https://www.itnxd.cn/tags/Time/"},{"name":"IO","slug":"IO","permalink":"https://www.itnxd.cn/tags/IO/"},{"name":"File","slug":"File","permalink":"https://www.itnxd.cn/tags/File/"},{"name":"反射","slug":"反射","permalink":"https://www.itnxd.cn/tags/%E5%8F%8D%E5%B0%84/"},{"name":"异常处理","slug":"异常处理","permalink":"https://www.itnxd.cn/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"String","slug":"String","permalink":"https://www.itnxd.cn/tags/String/"},{"name":"JavaBean","slug":"JavaBean","permalink":"https://www.itnxd.cn/tags/JavaBean/"},{"name":"包装类型","slug":"包装类型","permalink":"https://www.itnxd.cn/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"},{"name":"AcWing","slug":"AcWing","permalink":"https://www.itnxd.cn/tags/AcWing/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://www.itnxd.cn/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"归并排序","slug":"归并排序","permalink":"https://www.itnxd.cn/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"逆序对","slug":"逆序对","permalink":"https://www.itnxd.cn/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"奇偶性","slug":"奇偶性","permalink":"https://www.itnxd.cn/tags/%E5%A5%87%E5%81%B6%E6%80%A7/"},{"name":"中位数","slug":"中位数","permalink":"https://www.itnxd.cn/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"name":"priority_queue","slug":"priority-queue","permalink":"https://www.itnxd.cn/tags/priority-queue/"},{"name":"前缀和","slug":"前缀和","permalink":"https://www.itnxd.cn/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"字典序","slug":"字典序","permalink":"https://www.itnxd.cn/tags/%E5%AD%97%E5%85%B8%E5%BA%8F/"},{"name":"组合数","slug":"组合数","permalink":"https://www.itnxd.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0/"},{"name":"差分序列","slug":"差分序列","permalink":"https://www.itnxd.cn/tags/%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97/"},{"name":"二维前缀和","slug":"二维前缀和","permalink":"https://www.itnxd.cn/tags/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://www.itnxd.cn/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"状压Dp","slug":"状压Dp","permalink":"https://www.itnxd.cn/tags/%E7%8A%B6%E5%8E%8BDp/"},{"name":"努力","slug":"努力","permalink":"https://www.itnxd.cn/tags/%E5%8A%AA%E5%8A%9B/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.itnxd.cn/tags/JavaScript/"},{"name":"BOM","slug":"BOM","permalink":"https://www.itnxd.cn/tags/BOM/"},{"name":"DOM","slug":"DOM","permalink":"https://www.itnxd.cn/tags/DOM/"},{"name":"Data","slug":"Data","permalink":"https://www.itnxd.cn/tags/Data/"},{"name":"RegExp","slug":"RegExp","permalink":"https://www.itnxd.cn/tags/RegExp/"},{"name":"JSON","slug":"JSON","permalink":"https://www.itnxd.cn/tags/JSON/"},{"name":"函数","slug":"函数","permalink":"https://www.itnxd.cn/tags/%E5%87%BD%E6%95%B0/"},{"name":"入门","slug":"入门","permalink":"https://www.itnxd.cn/tags/%E5%85%A5%E9%97%A8/"},{"name":"基础","slug":"基础","permalink":"https://www.itnxd.cn/tags/%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"https://www.itnxd.cn/tags/Java/"},{"name":"Git","slug":"Git","permalink":"https://www.itnxd.cn/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://www.itnxd.cn/tags/Github/"},{"name":"matery","slug":"matery","permalink":"https://www.itnxd.cn/tags/matery/"},{"name":"aplayer","slug":"aplayer","permalink":"https://www.itnxd.cn/tags/aplayer/"},{"name":"dplayer","slug":"dplayer","permalink":"https://www.itnxd.cn/tags/dplayer/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.itnxd.cn/tags/Markdown/"},{"name":"Doc","slug":"Doc","permalink":"https://www.itnxd.cn/tags/Doc/"}]}